<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>运维之美</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2020-05-13T04:58:44.537Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分享几个让 Linux 非 Root 用户运行的程序使用特权端口的技巧</title>
    <link href="https://www.hi-linux.com/posts/26613.html"/>
    <id>https://www.hi-linux.com/posts/26613.html</id>
    <published>2020-05-13T01:00:00.000Z</published>
    <updated>2020-05-13T04:58:44.537Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，在 <code>Linux</code> 系统下，只允许 <code>Root</code> 用户运行的程序才可以使用特权端口 ( <code>1024</code> 以下的端口 )。如果在普通用户下使用特权端口将会报错。</p><p>在一些特定的环境下，我们可能考虑到程序运行在 <code>Root</code> 帐户下，可能会给 <code>Linux</code> 系统带来安全风险。希望能让普通用户启动的程序运行在特权端口上，比如：Web 服务器。</p><p>那如何能够让普通用户启动的程序运行在特权端口呢？本文将介绍一些方法，让你能够解决这个问题。</p><h2 id="通过设置-cap_net_bind_service-实现">通过设置 CAP_NET_BIND_SERVICE 实现</h2><p><code>Linux</code> 内核从 2.6.24 版本开始就有了能力的概念，这使得普通用户也能够做只有超级用户才能完成的工作。</p><p>使用 <code>setcap</code> 命令让指定程序拥有绑定端口的能力，这样即使程序运行在普通用户下，也能够绑定到 1024 以下的特权端口上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 给指定程序设置 CAP_NET_BIND_SERVICE 能力</span><br><span class="line">$ setcap cap_net_bind_service&#x3D;+eip &#x2F;path&#x2F;to&#x2F;application</span><br></pre></td></tr></table></figure><p>下面我们来看一个实例，以 <code>Nginx</code> 为例：</p><p><img src="https://www.hi-linux.com/img/linux/setcap.jpg" alt=""></p><p>如果你的程序不再需要使用这个能力，你可以使用以下命令来清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setcap -r &#x2F;path&#x2F;to&#x2F;application</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>这个方法并不是所有 <code>Linux</code> 系统通用，<code>Linux</code> 内核在 2.6.24 之前的并没有提供此项能力，因此你需要检查要使用此方法所在系统是否支持。</p></li><li><p>另外需要注意的是，如果要运行的程序是一个脚本，这个方法是没有办法正常工作的。</p></li></ol></blockquote><a id="more"></a><h2 id="通过端口转发实现">通过端口转发实现</h2><p>如果要运行的程序有权限监听其他端口，那么这个方法是可以使用的。首先让程序运行在普通用户下，并绑定高于 1024 的端口。在确保能正常工作的时候，我们将通过端口转发将低端口的请求转到应用所在的高端口，从而实现普通用户启动的程序绑定到低端口。要使用此方法可以使用下面的方式。</p><ol><li>配置内核参数以启用转发功能</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Enable the IP FORWARD kernel parameter.</span><br><span class="line">$ sysctl -w net.ipv4.ip_forward&#x3D;1</span><br></pre></td></tr></table></figure><p>以上方法是临时性设置，重启之后将会被重置。如果你想长期保存，需要在 <code>/etc/sysctl.conf</code> 文件内修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim  &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line"># Default value is 0, need change to 1.</span><br><span class="line"># net.ipv4.ip_forward &#x3D; 0</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br></pre></td></tr></table></figure><p>然后，使用 <code>sysctl</code> 命令从文件中加载新的配置，并使其生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># load new sysctl.conf</span><br><span class="line">$ sysctl -p &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"> </span><br><span class="line"># or sysctl -p</span><br><span class="line"># default filename is &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>配置转发规则</li></ol><p>这里我们使用 <code>Iptables</code> 来配置的转发规则，以实现端口转发到程序所在的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将 80 端口转发到 8088</span><br><span class="line">$ iptables -F -t nat</span><br><span class="line">$ iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to:8088</span><br></pre></td></tr></table></figure><p>此种方法能够比较好的达到我们的目的，我们的程序可以通过普通用户来运行，并能够对外提供低端口号的服务。</p><h2 id="通过-authbind-实现">通过 authbind 实现</h2><p><code>authbind</code> 是一个支持普通用户就能绑定系统特权端口的程序，你只需要使用 <code>authbind</code> 程序来调用需要使用特权端口的程序就可以了。</p><ol><li>安装 authbind</li></ol><ul><li>Debian / Ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install authbind</span><br></pre></td></tr></table></figure><ul><li>CentOS / RHEL</li></ul><p>CentOS 系列的系统安装起来相对就要麻烦一些，因为官方仓库并没有提供编译好的软件包。不过幸运的是，已经有人编译好了对应的软件包，我们只需要直接安装就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -ivh https:&#x2F;&#x2F;s3.amazonaws.com&#x2F;aaronsilber&#x2F;public&#x2F;authbind-2.1.1-0.1.x86_64.rpm</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 authbind</li></ol><p><code>authbind</code> 默认的配置文件在 <code>/etc/authbind</code> 目录下，里面有三个目录：<code>byport</code>、<code>byaddr</code>、<code>byuid</code>。</p><p>假如我们有一个 test 的普通账号，想运行一个程序并绑定在 80 端口上。我们需要配置以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在 byport 目录下建立 80 文件</span><br><span class="line">$ sudo touch &#x2F;etc&#x2F;authbind&#x2F;byport&#x2F;80</span><br><span class="line"># 设置 test 账户有 80 文件的使用权限</span><br><span class="line">$ sudo chmod 755 &#x2F;etc&#x2F;authbind&#x2F;byport&#x2F;80</span><br><span class="line">$ sudo chown test.test &#x2F;etc&#x2F;authbind&#x2F;byport&#x2F;80</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 authbind 运行指定程序</li></ol><p>在你要启动的命令前加上 <code>authbind --deep</code> 命令即可。例如：要用 test 这个普通用户启动 <code>Nginx</code> 并绑定在 80 端口，只需执行以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ authbind --deep &quot;&#x2F;usr&#x2F;bin&#x2F;nginx&quot; -c &quot;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&quot;</span><br></pre></td></tr></table></figure><p>我们也可以直接在 IP 地址上直接绑定端口，只需在 <code>byaddr</code> 目录下建立 <code>ip:port</code> 文件就可以了。</p><h2 id="通过-setuid-实现">通过 SetUID 实现</h2><p><code>SetUID</code> 这一特性可以让只有普通用户权限的应用程序用 Root 权限来运行，我们可以看到系统下 <code>/usr/bin/passwd</code> 这个文件，就使用了 <code>SetUID</code>。这样就使得系统的每个普通用户都能用 <code>passwd</code> 来修改密码，因为修改密码需要更改 <code>/etc/passwd</code> 文件，而默认这个文件只有 Root 用户才有权限访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将程序的所有者更改为 root</span><br><span class="line">$ chown root.root &#x2F;path&#x2F;to&#x2F;application</span><br><span class="line"></span><br><span class="line"># 给程序设置 SetUID</span><br><span class="line">$ chmod u+s &#x2F;path&#x2F;to&#x2F;application</span><br></pre></td></tr></table></figure><p>既然要使用普通用户运行程序，目的就是要降低程序本身给系统带来的安全风险。因此，本方法使用的时候需要特别谨慎，特别是当要执行的程序本身存在安全风险。</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://www.cnblogs.com/chenjunjie12321/p/9226279.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenjunjie12321/p/9226279.html</a></li><li><a href="https://blog.csdn.net/Becivells/article/details/52842019" target="_blank" rel="noopener">https://blog.csdn.net/Becivells/article/details/52842019</a></li><li><a href="https://my.oschina.net/guol/blog/186430" target="_blank" rel="noopener">https://my.oschina.net/guol/blog/186430</a></li><li><a href="https://github.com/tootedom/authbind-centos-rpm" target="_blank" rel="noopener">https://github.com/tootedom/authbind-centos-rpm</a></li><li><a href="https://dzone.com/articles/running-tomcat-port-80-user" target="_blank" rel="noopener">https://dzone.com/articles/running-tomcat-port-80-user</a></li><li><a href="http://blog.useasp.net/archive/2015/07/09/non-root-user-application-bind-to-ports-less-than-1024-without-root-access.aspx" target="_blank" rel="noopener">http://blog.useasp.net/archive/2015/07/09/non-root-user-application-bind-to-ports-less-than-1024-without-root-access.aspx</a></li><li><a href="https://stackoverflow.com/questions/413807/is-there-a-way-for-non-root-processes-to-bind-to-privileged-ports-on-linux" target="_blank" rel="noopener">https://stackoverflow.com/questions/413807/is-there-a-way-for-non-root-processes-to-bind-to-privileged-ports-on-linux</a></li><li><a href="https://aaronsilber.me/2016/04/24/install-authbind-on-centos-7-x86_64-download-the-rpm/" target="_blank" rel="noopener">https://aaronsilber.me/2016/04/24/install-authbind-on-centos-7-x86_64-download-the-rpm/</a></li><li><a href="https://blog.webhosting.net/how-to-get-tomcat-running-on-centos-7-2-using-privileged-ports-1024/" target="_blank" rel="noopener">https://blog.webhosting.net/how-to-get-tomcat-running-on-centos-7-2-using-privileged-ports-1024/</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，在 &lt;code&gt;Linux&lt;/code&gt; 系统下，只允许 &lt;code&gt;Root&lt;/code&gt; 用户运行的程序才可以使用特权端口 ( &lt;code&gt;1024&lt;/code&gt; 以下的端口 )。如果在普通用户下使用特权端口将会报错。&lt;/p&gt;
&lt;p&gt;在一些特定的环境下，我们可能考虑到程序运行在 &lt;code&gt;Root&lt;/code&gt; 帐户下，可能会给 &lt;code&gt;Linux&lt;/code&gt; 系统带来安全风险。希望能让普通用户启动的程序运行在特权端口上，比如：Web 服务器。&lt;/p&gt;
&lt;p&gt;那如何能够让普通用户启动的程序运行在特权端口呢？本文将介绍一些方法，让你能够解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;通过设置-CAP-NET-BIND-SERVICE-实现&quot;&gt;通过设置 CAP_NET_BIND_SERVICE 实现&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 内核从 2.6.24 版本开始就有了能力的概念，这使得普通用户也能够做只有超级用户才能完成的工作。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;setcap&lt;/code&gt; 命令让指定程序拥有绑定端口的能力，这样即使程序运行在普通用户下，也能够绑定到 1024 以下的特权端口上。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 给指定程序设置 CAP_NET_BIND_SERVICE 能力&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ setcap cap_net_bind_service&amp;#x3D;+eip &amp;#x2F;path&amp;#x2F;to&amp;#x2F;application&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面我们来看一个实例，以 &lt;code&gt;Nginx&lt;/code&gt; 为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/setcap.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你的程序不再需要使用这个能力，你可以使用以下命令来清除。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ setcap -r &amp;#x2F;path&amp;#x2F;to&amp;#x2F;application&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这个方法并不是所有 &lt;code&gt;Linux&lt;/code&gt; 系统通用，&lt;code&gt;Linux&lt;/code&gt; 内核在 2.6.24 之前的并没有提供此项能力，因此你需要检查要使用此方法所在系统是否支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外需要注意的是，如果要运行的程序是一个脚本，这个方法是没有办法正常工作的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>nftables 简明教程</title>
    <link href="https://www.hi-linux.com/posts/29206.html"/>
    <id>https://www.hi-linux.com/posts/29206.html</id>
    <published>2020-05-12T01:00:00.000Z</published>
    <updated>2020-05-12T05:06:03.209Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-nftables">什么是 nftables？</h2><p><code>nftables</code> 是一个新式的数据包过滤框架，旨在替代现用的 <code>iptables</code>、<code>ip6tables</code>、<code>arptables</code> 和 <code>ebtables</code> 的新的包过滤框架。<code>nftables</code> 诞生于 2008 年，2013 年底合并到 <code>Linux 内核</code>，从 <code>Linux</code> 内核 <code>3.13</code> 版本开始大多数场景下 <code>nftables</code> 已经可以使用，但是完整的支持（即：<code>nftables</code> 优先级高于 <code>iptables</code>）应该是在 Linux 内核 <code>3.15</code> 版本。</p><p><code>nftables</code> 旨在解决现有 <code>{ip/ip6}tables</code> 工具存在的诸多限制。相对于旧的 <code>iptables</code>，<code>nftables</code> 最引人注目的功能包括：改进性能、支持查询表、事务型规则更新、所有规则自动应用等等。</p><p><code>nftables</code> 主要由三个组件组成：内核实现、<code>libnl netlink</code> 通信和 <code>nftables</code> 用户空间。其中内核提供了一个 <code>netlink</code> 配置接口以及运行时规则集评估，<code>libnl</code> 包含了与内核通信的基本函数，用户空间可以通过新引入的命令行工具 <code>nft</code> 和用户进行交互。</p><p><code>nft</code> 可以通过在寄存器中储存和加载来交换数据。也就是说，它的语法与 <code>iptables</code> 不同。但 <code>nft</code> 可以利用内核提供的表达式去模拟旧的 <code>iptables</code> 命令，维持兼容性的同时获得更大的灵活性。简单来说，<code>nft</code> 是 <code>iptables</code> 及其衍生指令（<code>ip6tables</code> 和 <code>arptables</code> ）的超集。</p><h3 id="nftables-的特点">nftables 的特点</h3><ol><li><p><code>nftables</code> 拥有一些高级的类似编程语言的能力，例如：定义变量和包含外部文件，即拥有使用额外脚本的能力。<code>nftables</code> 也可以用于多种地址簇的过滤和处理。</p></li><li><p>不同于 <code>iptables</code>, <code>nftables</code> 并不包含任何的内置表，需要哪些表并在这些表中添加什么处理规则一切由管理员决定。</p></li><li><p>表包含规则链，规则链包含规则。</p></li></ol><h3 id="nftables-相较于-iptables-的优点">nftables 相较于 iptables 的优点</h3><ol><li>更新速度更快</li></ol><p>在 <code>iptables</code> 中添加一条规则，会随着规则数量增多而变得非常慢。这种状况对 <code>nftables</code> 而言就不存在了，因为 <code>nftables</code> 使用原子的快速操作来更新规则集合。</p><ol start="2"><li>内核更新更少。</li></ol><p>使用 <code>iptables</code> 时，每一个匹配或投递都需要内核模块的支持。因此，如果你忘记一些东西或者要添加新的功能时都需要重新编译内核。而在 <code>nftables</code> 中就不存在这种情况了， 因为在 <code>nftables</code> 中，大部分工作是在用户态完成的，内核只知道一些基本指令（过滤是用伪状态机实现的）。例如，<code>icmpv6</code> 支持是通过 <code>nft</code> 工具的一个简单的补丁实现的，而在 <code>iptables</code> 中这种类型的更改需要内核和 <code>iptables</code> 都升级才可以。</p><a id="more"></a><h2 id="nftables-基础操作">nftables 基础操作</h2><p><code>nftables</code> 和 <code>iptables</code> 一样，由表（table）、链（chain）和规则（rule）组成，其中表包含链，链包含规则，规则是真正的动作。</p><p>在 <code>nftables</code> 中，表是链的容器。所以开始使用 <code>nftables</code> 时你首先需要做的是添加至少一个表。然后，你可以向你的表里添加链，然后往链里添加规则。</p><h3 id="nftables-的表管理">nftables 的表管理</h3><p>与 <code>iptables</code> 中的表不同，<code>nftables</code> 中没有内置表。表的数量和名称由用户决定。但是，每个表只有一个地址簇，并且只适用于该簇的数据包。<code>nftables</code> 表可以指定为以下五个簇中的一个：</p><table><thead><tr><th>nftables 簇</th><th>对应 iptables 的命令行工具</th></tr></thead><tbody><tr><td>ip</td><td>iptables</td></tr><tr><td>ip6</td><td>ip6tables</td></tr><tr><td>inet</td><td>iptables 和 ip6tables</td></tr><tr><td>arp</td><td>arptables</td></tr><tr><td>bridge</td><td>ebtables</td></tr></tbody></table><p><code>ip</code>（即 IPv4）是默认簇，如果未指定簇，则使用该簇。如果要创建同时适用于 <code>IPv4</code> 和 <code>IPv6</code> 的规则，请使用 <code>inet</code> 簇 。<code>inet</code> 允许统一 <code>ip</code> 和 <code>ip6</code> 簇，以便更容易地定义规则。</p><blockquote><p>注意: <code>inet</code> 不能用于 <code>nat</code> 类型的链，只能用于 <code>filter</code> 类型的链。</p></blockquote><p>下面我们来看看 <code>nftables</code> 是如何进行表管理操作的，以下为 <code>nftables</code> 创建表的基本命令语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nft list tables [&lt;family&gt;]</span><br><span class="line">nft list table [&lt;family&gt;] &lt;name&gt; [-n] [-a]</span><br><span class="line">nft (add | delete | flush) table [&lt;family&gt;] &lt;name&gt;</span><br></pre></td></tr></table></figure><p>这里我们以创建一个 <code>inet</code> 簇的表为例，演示如何创建和管理一个新的表。</p><ol><li>创建表</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的表</span></span><br><span class="line">$ nft add table inet mytable</span><br></pre></td></tr></table></figure><ol start="2"><li>列出表</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有表</span></span><br><span class="line">$ nft list tables</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定族的所有表</span></span><br><span class="line">$ nft list tables inet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 inet 簇中 mytable 表中的所有规则</span></span><br><span class="line">$ nft list table inet mytable</span><br></pre></td></tr></table></figure><ol start="3"><li>删除表</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除一个表</span></span><br><span class="line">$ nft delete table inet mytable</span><br></pre></td></tr></table></figure><blockquote><p>注意：只能删除不包含链的表。</p></blockquote><ol start="4"><li>清空表</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空一个表中的所有规则</span></span><br><span class="line">$ nft flush table inet mytable</span><br></pre></td></tr></table></figure><h3 id="nftables-的链管理">nftables 的链管理</h3><p>链是用来保存规则的，与 <code>iptables</code> 中的链不同，<code>nftables</code> 没有内置链。这意味着和表一样，链也需要被显示创建。链有以下两种类型：</p><ul><li><p>常规链 : 主要用来做跳转，不需要指定钩子类型和优先级。从逻辑上对规则进行分类，支持所有的 <code>nftables</code> 簇。</p></li><li><p>基本链 : 来自网络栈数据包的入口点，需要指定钩子类型和优先级，支持 <code>ip</code> 和 <code>ip6</code> 簇。</p></li></ul><p><strong>nftables 链支持钩子的类型</strong></p><p><code>nftables</code> 和 <code>iptables</code> 类似，依然使用 <code>netfiler</code> 中的 5 个 钩子。</p><p><img src="https://i.loli.net/2019/11/11/Xk6QsDoqw7xRC21.png" alt=""></p><p>不同的是 <code>nftables</code> 在 <code>Linux Kernel 4.2</code> 中新增了 <code>ingress</code> 钩子。</p><p><img src="https://i.loli.net/2019/11/11/498zJrR27kqptXT.png" alt=""></p><p><strong>nftables 链支持钩子的作用</strong></p><ul><li><p><code>prerouting</code>：刚到达并未被 <code>nftables</code> 的其他部分所路由或处理的数据包。</p></li><li><p><code>input</code>：已经被接收并且已经经过 <code>prerouting</code> 钩子的传入数据包。</p></li><li><p><code>forward</code>：如果数据报将被发送到另一个设备，它将会通过 <code>forward</code> 钩子。</p></li><li><p><code>output</code>：从本地传出的数据包。</p></li><li><p><code>postrouting</code>：仅仅在离开系统之前，可以对数据包进行进一步处理。</p></li></ul><p><strong>nftables 链支持钩子的适用范围</strong></p><ul><li><p><code>ip</code>、<code>ip6</code> 和 <code>inet</code> 簇支持的钩子有： <code>prerouting</code>、 <code>input</code>、<code>forward</code>、 <code>output</code>、<code>postrouting</code> 。</p></li><li><p><code>arp</code> 簇支持的钩子有： <code>input</code>、<code>output</code> 。</p></li></ul><p><strong>nftables 链支持的优先级</strong></p><p>优先级采用整数值表示，数字较小的链优先处理，并且可以是负数。可以使用的值有：</p><ul><li><p>NF_IP_PRI_CONNTRACK_DEFRAG (-400)</p></li><li><p>NF_IP_PRI_RAW (-300)</p></li><li><p>NF_IP_PRI_SELINUX_FIRST (-225)</p></li><li><p>NF_IP_PRI_CONNTRACK (-200)</p></li><li><p>NF_IP_PRI_MANGLE (-150)</p></li><li><p>NF_IP_PRI_NAT_DST (-100)</p></li><li><p>NF_IP_PRI_FILTER (0)</p></li><li><p>NF_IP_PRI_SECURITY (50)</p></li><li><p>NF_IP_PRI_NAT_SRC (100)</p></li><li><p>NF_IP_PRI_SELINUX_LAST (225)</p></li><li><p>NF_IP_PRI_CONNTRACK_HELPER (300)</p></li></ul><p><strong>nftables 链对报文数据支持采取的动作</strong></p><ul><li><p>accept</p></li><li><p>drop</p></li><li><p>queue</p></li><li><p>continue</p></li><li><p>return</p></li></ul><p><strong>nftables 创建链的基本命令语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nft (add | create) chain [&lt;family&gt;] &lt;table&gt; &lt;name&gt; [ &#123; <span class="built_in">type</span> &lt;<span class="built_in">type</span>&gt; hook &lt;hook&gt; [device &lt;device&gt;] priority &lt;priority&gt; \; [policy &lt;policy&gt; \;] &#125; ]</span><br><span class="line">nft (delete | list | flush) chain [&lt;family&gt;] &lt;table&gt; &lt;name&gt;</span><br><span class="line">nft rename chain [&lt;family&gt;] &lt;table&gt; &lt;name&gt; &lt;newname&gt;</span><br></pre></td></tr></table></figure><p><strong>nftables 创建链的基本操作</strong></p><ol><li>创建链</li></ol><ul><li>创建一个常规链</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将名为 tcpchain 的常规链添加到 inet 簇中名为 mytable 的表中</span></span><br><span class="line">$ nft add chain inet mytable tcpchain</span><br></pre></td></tr></table></figure><ul><li>创建一个基本链</li></ul><p>添加一个基本链，你必需指定钩子和优先级。基本链的类型可以是 <code>filter</code>、<code>route</code> 或者 <code>nat</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一个筛选输入数据包的基本链</span></span><br><span class="line">$ nft add chain inet mytable input &#123; <span class="built_in">type</span> filter hook input priority 0\; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：命令中的反斜线 <code>（\）</code> 用来转义，这样 <code>Shell</code> 就不会将分号解释为命令的结尾。</p></blockquote><ol start="2"><li>列出规则</li></ol><p>列出一个链中的所有规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出 inet 筛中 filter 表的 input 链中的所有的规则</span></span><br><span class="line">$ nft list chain inet filter input</span><br></pre></td></tr></table></figure><ol start="3"><li>编辑链</li></ol><p>要编辑一个链，只需按名称调用并重新定义要更改的规则即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将默认表中的 input 链策略从 accept 更改为 drop</span></span><br><span class="line">$ nft chain inet mytable input &#123; policy drop \; &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>清空链中的规则</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空指定链中的规则，这里为 input</span></span><br><span class="line">$ nft flush chain inet mytable input</span><br></pre></td></tr></table></figure><ol start="5"><li>删除链</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定的链，这里为 input</span></span><br><span class="line">$ nft delete chain inet mytable input</span><br></pre></td></tr></table></figure><blockquote><p>注意：要删除的链中不能包含任何规则或者跳转目标。</p></blockquote><h3 id="nftables-的规则管理">nftables 的规则管理</h3><p><code>nftables</code> 规则由语句或表达式构成，包含在链中。以下为创建 <code>nftables</code> 规则的基本命令语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nft add rule [&lt;family&gt;] &lt;table&gt; &lt;chain&gt; &lt;matches&gt; &lt;statements&gt;</span><br><span class="line">nft insert rule [&lt;family&gt;] &lt;table&gt; &lt;chain&gt; [position &lt;position&gt;] &lt;matches&gt; &lt;statements&gt;</span><br><span class="line">nft replace rule [&lt;family&gt;] &lt;table&gt; &lt;chain&gt; [handle &lt;handle&gt;] &lt;matches&gt; &lt;statements&gt;</span><br><span class="line">nft delete rule [&lt;family&gt;] &lt;table&gt; &lt;chain&gt; [handle &lt;handle&gt;]</span><br></pre></td></tr></table></figure><p>其中 <code>matches</code> 是报文需要满足的条件。<code>matches</code> 的内容非常多，可以识别以下多种类型的报文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ip          :  ipv4 协议字段</span><br><span class="line">ip6         :  ipv6 协议字段</span><br><span class="line">tcp         :  tcp 协议字段</span><br><span class="line">udp         :  udp 协议字段</span><br><span class="line">udplite     :  udp-lite 协议</span><br><span class="line">sctp        :  sctp 协议 </span><br><span class="line">dccp</span><br><span class="line">ah</span><br><span class="line">esp</span><br><span class="line">comp</span><br><span class="line">icmp</span><br><span class="line">icmpv6</span><br><span class="line">ether       :  以太头</span><br><span class="line">dst</span><br><span class="line">frag        :</span><br><span class="line">hbh</span><br><span class="line">mh</span><br><span class="line">rt            </span><br><span class="line">vlan        :  vlan</span><br><span class="line">arp         :  arp协议</span><br><span class="line">ct          :  连接状态</span><br><span class="line">meta        :  报文的基本信息</span><br></pre></td></tr></table></figure><p>对每一种类型的报文，你又可以同时检查多个字段，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ip dscp cs1</span><br><span class="line">ip dscp != cs1</span><br><span class="line">ip dscp 0x38</span><br><span class="line">ip dscp != 0x20</span><br><span class="line">ip dscp &#123;cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, af11, af12, af13, af21, </span><br><span class="line">af22, af23, af31, af32, af33, af41, af42, af43, ef&#125;</span><br><span class="line"></span><br><span class="line">ip length 232</span><br><span class="line">ip length != 233</span><br><span class="line">ip length 333-435</span><br><span class="line">ip length != 333-453</span><br><span class="line">ip length &#123; 333, 553, 673, 838&#125;</span><br><span class="line"></span><br><span class="line">ip6 flowlabel 22</span><br><span class="line">ip6 flowlabel != 233</span><br><span class="line">ip6 flowlabel &#123; 33, 55, 67, 88 &#125;</span><br><span class="line">ip6 flowlabel &#123; 33-55 &#125;</span><br></pre></td></tr></table></figure><p>而 <code>statement</code> 是报文匹配规则时触发的操作，大致有以下几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Verdict statements :   动作</span><br><span class="line">Log                :   记录日志并继续处理请求</span><br><span class="line">Reject             :   停止处理并拒绝请求</span><br><span class="line">Counter            :   计数</span><br><span class="line">Limit              :   如果达到了接收数据包的匹配限制，则根据规则处理数据包</span><br><span class="line">Nat                :   NAT</span><br><span class="line">Queuea             :   停止处理并发送数据包到用户空间程序</span><br></pre></td></tr></table></figure><p>其中 <code>Verdict Statements</code> 是一组动作，大致有以下几种：</p><ul><li><p>accept：接受数据包并停止剩余规则评估。</p></li><li><p>drop：丢弃数据包并停止剩余规则评估。</p></li><li><p>queue：将数据包排队到用户空间并停止剩余规则评估。</p></li><li><p>continue：使用下一条规则继续进行规则评估。</p></li><li><p>return：从当前链返回并继续执行最后一条链的下一条规则。</p></li><li><p>jump <chain>：跳转到指定的规则链，当执行完成或者返回时，返回到调用的规则链。</chain></p></li><li><p>goto <chain>：类似于跳转，发送到指定规则链但不返回。</chain></p></li></ul><p>下面将以添加一条允许 <code>SSH</code> 登录的规则为例，给大家介绍下如何增加或插入一条新的规则。</p><ol><li>增加规则</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add rule inet mytable input tcp dport ssh accept</span><br></pre></td></tr></table></figure><p>默认情况下，<code>add</code> 表示将规则添加到链的末尾。如果你想从链的开头增加规则，可以使用 <code>insert</code> 来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft insert rule inet mytable input tcp dport http accept</span><br></pre></td></tr></table></figure><ol start="2"><li>列出规则</li></ol><ul><li>列出目前链中所有的规则</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ nft list ruleset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        chain input &#123;</span><br><span class="line">                <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">                tcp dport http accept</span><br><span class="line">                tcp dport ssh accept</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>列出某个表中的所有规则</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft list table inet mytable</span><br></pre></td></tr></table></figure><ul><li>列出某条链中的所有规则</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft list chain inet mytable input</span><br></pre></td></tr></table></figure><ol start="3"><li>按指定位置增加规则</li></ol><p>无论你是使用 <code>add</code> 或者 <code>insert</code> 来增加规则，你都可以通过 <code>index</code> 或者 <code>handle</code> 来指定添加的位置。</p><ul><li>使用 index 来指定规则的索引</li></ul><p><code>index</code> 类似于 <code>iptables</code> 的 <code>-I</code> 选项， <code>add</code> 表示新规则添加在索引位置的规则后面，<code>inser</code> 表示新规则添加在索引位置的规则前面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 input 链中已有规则中的第二条规则前插入一条新的规则</span></span><br><span class="line">$ nft insert rule inet mytable input index 1 tcp dport nfs accept</span><br><span class="line">$ nft list ruleset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">     chain input &#123;</span><br><span class="line">             <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">             tcp dport http accept</span><br><span class="line">             tcp dport nfs accept</span><br><span class="line">             tcp dport ssh accept</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 input 链中已有规则中的第一条规则后插入一条新的规则</span></span><br><span class="line">$ nft add rule inet mytable input index 0 tcp dport 1234 accept</span><br><span class="line">$ nft list ruleset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">     chain input &#123;</span><br><span class="line">             <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">             tcp dport http accept</span><br><span class="line">             tcp dport 1234 accept</span><br><span class="line">             tcp dport nfs accept</span><br><span class="line">             tcp dport ssh accept</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>index</code> 的值是从 <code>0</code> 开始的，<code>index</code> 必须指向一个已存在的规则的索引。</p></blockquote><ul><li>使用 handle 来指定规则的句柄</li></ul><p>通过 <code>handle</code> 的值来指定规则添加的位置，必须先知道现有规则的句柄位置。你可以通过参数 <code>--handle</code> 来获取当前规则的句柄位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ nft --handle list ruleset</span><br><span class="line">table inet mytable &#123; <span class="comment"># handle 10</span></span><br><span class="line">     chain input &#123; <span class="comment"># handle 2</span></span><br><span class="line">             <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">             tcp dport http accept <span class="comment"># handle 4</span></span><br><span class="line">             tcp dport 1234 accept <span class="comment"># handle 6</span></span><br><span class="line">             tcp dport nfs accept <span class="comment"># handle 5</span></span><br><span class="line">             tcp dport ssh accept <span class="comment"># handle 3</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到当前规则的句柄位置后，我们就可以在指定句柄位置添加规则。下面我们以在句柄位置 4 后面和句柄位置 5 前面分别增加一条新的规则为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ nft add rule inet mytable input handle 4 tcp dport 2345 accept</span><br><span class="line">$ nft insert rule inet mytable input handle 5 tcp dport 3456 accept</span><br><span class="line">$ nft --handle list ruleset</span><br><span class="line">table inet mytable &#123; <span class="comment"># handle 10</span></span><br><span class="line">     chain input &#123; <span class="comment"># handle 2</span></span><br><span class="line">             <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">             tcp dport http accept <span class="comment"># handle 4</span></span><br><span class="line">             tcp dport 2345 accept <span class="comment"># handle 8</span></span><br><span class="line">             tcp dport 1234 accept <span class="comment"># handle 6</span></span><br><span class="line">             tcp dport 3456 accept <span class="comment"># handle 9</span></span><br><span class="line">             tcp dport nfs accept <span class="comment"># handle 5</span></span><br><span class="line">             tcp dport ssh accept <span class="comment"># handle 3</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>nftables</code> 中，句柄值是固定不变的，除非规则被删除。而 <code>index</code> 的值是可变的，只要有新规则插入，就有可能发生变化。一般建议使用 <code>handle</code> 来插入新规则。</p><p>你也可以在创建规则时就获取到规则的句柄值，只需要在创建规则时同时加上参数 <code>--echo</code> 和 <code>--handle</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nft --<span class="built_in">echo</span> --handle add rule inet mytable input udp dport 3333 accept</span><br><span class="line">add rule inet mytable input udp dport 3333 accept <span class="comment"># handle 10</span></span><br></pre></td></tr></table></figure><ol start="4"><li>删除规则</li></ol><p>单个规则只能通过句柄值删除，每个规则的句柄值可通过 <code>nft --handle list ruleset</code> 命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定句柄值对应的规则</span></span><br><span class="line">$ nft delete rule inet mytable input handle 8</span><br></pre></td></tr></table></figure><blockquote><p>小技巧：你可以使用 <code>iptables-translate</code> 实用程序将 <code>iptables</code> 规则转换成 <code>nftables</code> 格式</p></blockquote><h2 id="nftables-高级功能进阶">nftables 高级功能进阶</h2><p><code>nftables</code> 除了上面的基础功能外，还给我们额外提供了一些非常实用且功能强大的高级功能。</p><h3 id="集合">集合</h3><p><code>nftables</code> 的语法原生支持集合，可以用来匹配多个 <code>IP</code> 地址、端口号、网卡或其他任何条件。<code>nftables</code> 的集合可分为匿名集合与命名集合，相对 <code>iptables</code> 来说，<code>nftables</code> 是原生支持集合，并不需要借助 <code>ipset</code> 来实现。</p><ol><li>匿名集合</li></ol><p>匿名集合比较适合用于将来不需要更改的规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许来自源 IP 处于 10.10.10.123 ~ 10.10.10.231 这个区间内的主机的流量。</span></span><br><span class="line">$ nft add rule inet mytable input ip saddr &#123; 10.10.10.123, 10.10.10.231 &#125; accept</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许指定协义的流量通过</span></span><br><span class="line">$ nft add rule inet mytable input tcp dport &#123; http, nfs, ssh &#125; accept</span><br></pre></td></tr></table></figure><p>匿名集合的缺点是需要修改集合规则时，就得替换原规则。如果需要频繁修改的集合，推荐使用命名集合。</p><ol start="2"><li>命名集合</li></ol><p><code>nftables</code> 的命名集合是可以修改的。创建命名集合时需要指定其元素的类型，当前支持的数据类型有：</p><ul><li><p><code>ipv4_addr</code> : <code>IPv4</code> 地址</p></li><li><p><code>ipv6_addr</code> : <code>IPv6</code> 地址</p></li><li><p><code>ether_addr</code> : 以太网（Ethernet）地址</p></li><li><p><code>inet_proto</code> : 网络协议</p></li><li><p><code>inet_service</code> : 网络服务</p></li><li><p><code>mark</code> : 标记类型</p></li></ul><p>这里，我们来看一个实例。首先，创建一个空的命名集合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空的命名集合</span></span><br><span class="line">$ nft add <span class="built_in">set</span> inet mytable myset &#123; <span class="built_in">type</span> ipv4_addr \; &#125;</span><br><span class="line">$ nft list sets</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        <span class="built_in">set</span> myset &#123;</span><br><span class="line">                <span class="built_in">type</span> ipv4_addr</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们向集合中添加一些元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ nft add element inet mytable myset &#123; 10.10.10.22, 10.10.10.33 &#125;</span><br><span class="line">$ nft list <span class="built_in">set</span> inet mytable myset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        <span class="built_in">set</span> myset &#123;</span><br><span class="line">                <span class="built_in">type</span> ipv4_addr</span><br><span class="line">                elements = &#123; 10.10.10.22, 10.10.10.33 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在添加规则时引用集合，你可以使用 <code>@</code> 符号跟上集合的名字来引用命名集合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将来源为集合 myset 中的 IP 地址的请求阻止掉</span></span><br><span class="line">$ nft insert rule inet mytable input ip saddr @myset drop</span><br><span class="line">$ nft list chain inet mytable input</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        chain input &#123;</span><br><span class="line">                <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">                ip saddr @my_set drop</span><br><span class="line">                tcp dport http accept</span><br><span class="line">                tcp dport nfs accept</span><br><span class="line">                tcp dport ssh accept</span><br><span class="line">                ip saddr &#123; 10.10.10.123, 10.10.10.231 &#125; accept</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>支持区间</li></ol><p>从上面的例子中，我们可以看到填加元素时是使用的两个独立的 <code>IP</code> 地址，并没有直接使用 <code>10.10.10.0-10.10.10.255</code> 这样的区间段来表示。这是因为直接使用区间段会报以下类似错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nft add element inet mytable myset &#123; 10.10.10.0-10.10.10.255 &#125;</span><br><span class="line"></span><br><span class="line">Error: Set member cannot be range, missing interval flag on declaration</span><br><span class="line">add element inet mytable my_set &#123; 10.10.10.0-10.10.10.255 &#125;</span><br><span class="line">                                   ^^^^^^^^^^^^^^^^^^^^^^^</span><br></pre></td></tr></table></figure><p>如果你想在集合中使用区间，需要加上一个 <code>flag interval</code>，因为内核必须提前确认该集合存储的数据类型，以便采用适当的数据结构。我们来看一个实例吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个支持区间的命名集合</span></span><br><span class="line">$ nft add <span class="built_in">set</span> inet mytable my_rangeset &#123; <span class="built_in">type</span> ipv4_addr \; flags interval</span><br><span class="line">$ nft add element inet mytable my_rangeset &#123; 10.10.10.0/24 &#125;</span><br><span class="line">$ nft list <span class="built_in">set</span> inet mytable my_rangeset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        <span class="built_in">set</span> my_rangeset &#123;</span><br><span class="line">                <span class="built_in">type</span> ipv4_addr</span><br><span class="line">                flags interval</span><br><span class="line">                elements = &#123; 10.10.10.0/24 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中直接使用了子网掩码来表示 <code>IP</code> 地址段，它会被隐式转换为 <code>IP</code> 地址的区间，你也可以直接使用区间 <code>10.10.10.0-10.10.10.255</code> 来获得相同的效果。</p><ol start="4"><li>级联不同类型</li></ol><p>命名集合不仅支持同一类型元素，也可以支持对不同类型的元素进行级联。例如，下面的规则可以一次性匹配 <code>IP</code> 地址、协议和端口号。</p><p>首先，我们创建一个级联类型的集合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nft add <span class="built_in">set</span> inet mytable my_concatset  &#123; <span class="built_in">type</span> ipv4_addr . inet_proto . inet_service \; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同类型的元素可以通过级联操作符 . 来分隔。</span></span><br><span class="line">$ nft list <span class="built_in">set</span> inet mytable my_concatset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        <span class="built_in">set</span> my_concatset &#123;</span><br><span class="line">                <span class="built_in">type</span> ipv4_addr . inet_proto . inet_service</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，向集合中添加元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add element inet mytable my_concatset &#123; 10.30.30.30 . tcp . telnet &#125;</span><br></pre></td></tr></table></figure><p>最后，我们在规则中对级联类型的集合进行引用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果数据包的源 IP、协议类型、目标端口匹配 10.30.30.30、tcp、telnet 时，就会允许该数据包通过</span></span><br><span class="line">$ nft add rule inet mytable input ip saddr . meta l4proto . tcp dport @my_concatset accept</span><br></pre></td></tr></table></figure><p>除了命名集合，匿名集合也是可以使用级联元素，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add rule inet mytable input ip saddr . meta l4proto . udp dport &#123; 10.30.30.30 . udp . bootps &#125; accept</span><br></pre></td></tr></table></figure><p>在规则中引用级联类型的集合和一般类型集合的主要不同之处：主要在于需要标明集合中每个元素对应到规则中的哪个位置，这类似于 ipset 的聚合类型，例如 <code>hash:ip,port</code> 。</p><h3 id="字典">字典</h3><p>字典是 <code>nftables</code> 的又一个高级特性，它同样可以支持在一条规则上面使用不同类型的数据。</p><p>首先，我们创建一个命名字典。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add map inet mytable my_vmap &#123; <span class="built_in">type</span> inet_proto : verdict \; &#125;</span><br></pre></td></tr></table></figure><p>接着，我们向字典中添加一些元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add element inet mytable my_vmap &#123; 192.168.0.10 : drop, 192.168.0.11 : accept &#125;</span><br></pre></td></tr></table></figure><p>最后，我们就可以在规则中引用字典中的元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add rule inet mytable input ip saddr vmap @my_vmap</span><br></pre></td></tr></table></figure><p>和集合一样，除了命名字典，你也可以创建匿名字典。例如，为了从逻辑上对 <code>TCP</code> 和 <code>UDP</code> 的数据包拆分开来用两条不同链来处理，你就可以通过使用字典来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ nft add chain inet mytable my_tcpchain</span><br><span class="line">$ nft add chain inet mytable my_udpchain</span><br><span class="line">$ nft add rule inet mytable input meta l4proto vmap &#123; tcp : jump my_tcpchain, udp : jump my_udpchain &#125;</span><br><span class="line">$ nft list chain inet mytable input</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">    chain input &#123;</span><br><span class="line">    ...</span><br><span class="line">    meta nfproto ipv4 ip saddr . meta l4proto . udp dport &#123; 10.30.30.30 . udp . bootps &#125; accept</span><br><span class="line">    meta l4proto vmap &#123; tcp : jump my_tcpchain, udp : jump my_udpchain &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表与命名空间">表与命名空间</h3><p>在 <code>nftables</code> 中，每个表都是一个独立的命名空间，这就意味着不同的表中的链、集合、字典等名字可以相同。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ nft add table inet table_one</span><br><span class="line">$ nft add chain inet table_one mychain</span><br><span class="line">$ nft add table inet table_two</span><br><span class="line">$ nft add chain inet table_two mychain</span><br><span class="line">$ nft list ruleset</span><br><span class="line">...</span><br><span class="line">table inet table_one &#123;</span><br><span class="line">    chain mychain &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">table inet table_two &#123;</span><br><span class="line">    chain mychain &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个特性后，不同的应用就可以在相互不影响的情况下管理自己的表中的规则。不过使用这个特性前，你需要注意的一点是：由于 <code>nftables</code> 将每个表都被视为独立的防火墙，一个数据包必须被所有表中的规则放行才能真正通过。如果，出现两条链的优先级相同，就会进入竞争状态。</p><p>当然，你可以使用 <code>nftables</code> 优先级特性来解决这个问题。优先级值越高的链优先级越低，所以优先级值低的链会比优先级值高的链先执行。</p><h3 id="备份与恢复">备份与恢复</h3><p>默认情况下，通过 <code>nftables</code> 用户态工具 <code>nft</code> 直接在终端中加入的规则都是临时的。如果要想永久生效，我们可以将规则备份后并在开机自动加载时进行恢复。</p><ol><li>备份规则</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft list ruleset &gt; /root/nftables.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>恢复规则</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft -f /root/nftables.conf</span><br></pre></td></tr></table></figure><p>在 <code>CentOS 8</code> 中，<code>nftables</code> 是以 <code>Systemd</code> 服务形式进行工作的。<code>nftables.service</code> 的规则被存储在 <code>/etc/nftables.conf</code> 中，其中包含了一些其他的示例规则，一般会位于 <code>/etc/sysconfig/nftables.conf</code> 文件中。如果你想开机自加载 <code>nftables</code> 规则，只需将备份规则放到 <code>/etc/sysconfig/nftables.conf</code> 文件即可。</p><h2 id="总结">总结</h2><p>至此，本文对 <code>nftables</code> 的基本功能和用法就讲解完了，更高级的用法可以在以下文档中做进一步探索。</p><blockquote><ol><li><p>Archlinux Wiki：<a href="https://wiki.archlinux.org/index.php/Nftables" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Nftables</a></p></li><li><p>nftables HOWTO：<a href="https://farkasity.gitbooks.io/nftables-howto-zh/" target="_blank" rel="noopener">https://farkasity.gitbooks.io/nftables-howto-zh/</a></p></li><li><p>nftables Wiki：<a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page" target="_blank" rel="noopener">https://wiki.nftables.org/wiki-nftables/index.php/Main_Page</a></p></li></ol></blockquote><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://url.cn/56tJkD8" target="_blank" rel="noopener">https://url.cn/56tJkD8</a></p></li><li><p><a href="http://www.freecls.com/a/2712/fc" target="_blank" rel="noopener">http://www.freecls.com/a/2712/fc</a></p></li><li><p><a href="https://blog.51cto.com/babyshen/2065749" target="_blank" rel="noopener">https://blog.51cto.com/babyshen/2065749</a></p></li><li><p><a href="https://adoyle.me/Today-I-Learned/linux/iptables.html" target="_blank" rel="noopener">https://adoyle.me/Today-I-Learned/linux/iptables.html</a></p></li><li><p><a href="https://blog.csdn.net/dog250/article/details/54170683" target="_blank" rel="noopener">https://blog.csdn.net/dog250/article/details/54170683</a></p></li><li><p><a href="https://www.yangcs.net/posts/using-nftables/" target="_blank" rel="noopener">https://www.yangcs.net/posts/using-nftables/</a></p></li><li><p><a href="https://wiki.archlinux.org/index.php/Nftables" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Nftables</a></p></li><li><p><a href="https://farkasity.gitbooks.io/nftables-howto-zh/content/" target="_blank" rel="noopener">https://farkasity.gitbooks.io/nftables-howto-zh/content/</a></p></li><li><p><a href="https://blog.omicron3069.com/post/nftablesfornode/" target="_blank" rel="noopener">https://blog.omicron3069.com/post/nftablesfornode/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-nftables？&quot;&gt;什么是 nftables？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;nftables&lt;/code&gt; 是一个新式的数据包过滤框架，旨在替代现用的 &lt;code&gt;iptables&lt;/code&gt;、&lt;code&gt;ip6tables&lt;/code&gt;、&lt;code&gt;arptables&lt;/code&gt; 和 &lt;code&gt;ebtables&lt;/code&gt; 的新的包过滤框架。&lt;code&gt;nftables&lt;/code&gt; 诞生于 2008 年，2013 年底合并到 &lt;code&gt;Linux 内核&lt;/code&gt;，从 &lt;code&gt;Linux&lt;/code&gt; 内核 &lt;code&gt;3.13&lt;/code&gt; 版本开始大多数场景下 &lt;code&gt;nftables&lt;/code&gt; 已经可以使用，但是完整的支持（即：&lt;code&gt;nftables&lt;/code&gt; 优先级高于 &lt;code&gt;iptables&lt;/code&gt;）应该是在 Linux 内核 &lt;code&gt;3.15&lt;/code&gt; 版本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nftables&lt;/code&gt; 旨在解决现有 &lt;code&gt;{ip/ip6}tables&lt;/code&gt; 工具存在的诸多限制。相对于旧的 &lt;code&gt;iptables&lt;/code&gt;，&lt;code&gt;nftables&lt;/code&gt; 最引人注目的功能包括：改进性能、支持查询表、事务型规则更新、所有规则自动应用等等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nftables&lt;/code&gt; 主要由三个组件组成：内核实现、&lt;code&gt;libnl netlink&lt;/code&gt; 通信和 &lt;code&gt;nftables&lt;/code&gt; 用户空间。其中内核提供了一个 &lt;code&gt;netlink&lt;/code&gt; 配置接口以及运行时规则集评估，&lt;code&gt;libnl&lt;/code&gt; 包含了与内核通信的基本函数，用户空间可以通过新引入的命令行工具 &lt;code&gt;nft&lt;/code&gt; 和用户进行交互。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nft&lt;/code&gt; 可以通过在寄存器中储存和加载来交换数据。也就是说，它的语法与 &lt;code&gt;iptables&lt;/code&gt; 不同。但 &lt;code&gt;nft&lt;/code&gt; 可以利用内核提供的表达式去模拟旧的 &lt;code&gt;iptables&lt;/code&gt; 命令，维持兼容性的同时获得更大的灵活性。简单来说，&lt;code&gt;nft&lt;/code&gt; 是 &lt;code&gt;iptables&lt;/code&gt; 及其衍生指令（&lt;code&gt;ip6tables&lt;/code&gt; 和 &lt;code&gt;arptables&lt;/code&gt; ）的超集。&lt;/p&gt;
&lt;h3 id=&quot;nftables-的特点&quot;&gt;nftables 的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;nftables&lt;/code&gt; 拥有一些高级的类似编程语言的能力，例如：定义变量和包含外部文件，即拥有使用额外脚本的能力。&lt;code&gt;nftables&lt;/code&gt; 也可以用于多种地址簇的过滤和处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同于 &lt;code&gt;iptables&lt;/code&gt;, &lt;code&gt;nftables&lt;/code&gt; 并不包含任何的内置表，需要哪些表并在这些表中添加什么处理规则一切由管理员决定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表包含规则链，规则链包含规则。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;nftables-相较于-iptables-的优点&quot;&gt;nftables 相较于 iptables 的优点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;更新速度更快&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 &lt;code&gt;iptables&lt;/code&gt; 中添加一条规则，会随着规则数量增多而变得非常慢。这种状况对 &lt;code&gt;nftables&lt;/code&gt; 而言就不存在了，因为 &lt;code&gt;nftables&lt;/code&gt; 使用原子的快速操作来更新规则集合。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;内核更新更少。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;iptables&lt;/code&gt; 时，每一个匹配或投递都需要内核模块的支持。因此，如果你忘记一些东西或者要添加新的功能时都需要重新编译内核。而在 &lt;code&gt;nftables&lt;/code&gt; 中就不存在这种情况了， 因为在 &lt;code&gt;nftables&lt;/code&gt; 中，大部分工作是在用户态完成的，内核只知道一些基本指令（过滤是用伪状态机实现的）。例如，&lt;code&gt;icmpv6&lt;/code&gt; 支持是通过 &lt;code&gt;nft&lt;/code&gt; 工具的一个简单的补丁实现的，而在 &lt;code&gt;iptables&lt;/code&gt; 中这种类型的更改需要内核和 &lt;code&gt;iptables&lt;/code&gt; 都升级才可以。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="nftables" scheme="https://www.hi-linux.com/tags/nftables/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款 Go 语言多版本管理利器 GVM</title>
    <link href="https://www.hi-linux.com/posts/20165.html"/>
    <id>https://www.hi-linux.com/posts/20165.html</id>
    <published>2020-05-12T01:00:00.000Z</published>
    <updated>2020-05-12T05:06:03.211Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Golang</code> 发展迅速，代码迭代非常快，想要在同一环境调试和梳理不同项目进程就成了一件相对棘手的事情。二进制文件的管理比较简单，通过链接使用不同版本的程序即可。实际上主要是一些环境变量和标准库的设置问题，偶然间发现了 <code>GVM - Go Version Manager</code>，<code>GVM</code> 实际上就是帮助我们完成这些配置工作，这算是找到了调试切换版本的福音了。</p><h2 id="什么是-gvm">什么是 GVM</h2><p><code>Go</code> 语言版本管理器（<code>GVM</code>）是管理 <code>Go</code> 语言环境的开源工具。<code>GVM 「pkgsets」</code> 支持安装多个版本的 <code>Go</code> 并管理每个项目的模块。它最初由 <code>Josh Bussdieker</code> 开发，<code>GVM</code> 与 <code>Ruby RVM</code> 类似，允许你为每个项目或一组项目创建一个开发环境，分离不同的 <code>Go</code> 版本和包依赖关系，来提供更大的灵活性，以防不同版本造成的问题。<code>GVM</code> 主要有以下几个特性：</p><ul><li><p>管理 <code>Go</code> 的多个版本，包括安装、卸载和指定使用 <code>Go</code> 的某个版本</p></li><li><p>查看官方所有可用的 <code>Go</code> 版本，同时可以查看本地已安装和默认使用的 <code>Go</code> 版本</p></li><li><p>管理多个 <code>GOPATH</code>，并可编辑 <code>Go</code> 的环境变量</p></li><li><p>可将当前目录关联到 <code>GOPATH</code></p></li><li><p>可以查看 <code>GOROOT</code> 下的文件差异</p></li><li><p>支持 <code>Go</code> 版本切换</p></li></ul><blockquote><p>项目地址：<a href="https://github.com/moovweb/gvm" target="_blank" rel="noopener">https://github.com/moovweb/gvm</a></p></blockquote><a id="more"></a><h2 id="安装-gvm">安装 GVM</h2><p><code>GVM</code> 本质上就是一个 <code>SHELL</code> 脚本，它背后做的事情是先把源码下载下来，再用 <code>C</code> 做编译。所以，安装 <code>GVM</code> 前你需要先安装一些依赖包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debian/Ubuntu</span></span><br><span class="line">$ sudo apt-get install curl git mercurial make binutils bison gcc build-essential</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redhat/Centos</span></span><br><span class="line">$ sudo yum install curl</span><br><span class="line">$ sudo yum install git</span><br><span class="line">$ sudo yum install make</span><br><span class="line">$ sudo yum install bison</span><br><span class="line">$ sudo yum install gcc</span><br><span class="line">$ sudo yum install glibc-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS</span></span><br><span class="line">$ xcode-select --install</span><br><span class="line">$ brew update</span><br><span class="line">$ brew install mercurial</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>Centos</code> 官方仓库没有 <code>mercurial</code> 软件包，如果你需要可以在 <code>mercurial</code> 官网 <code>https://www.mercurial-scm.org/downloads</code> 下载后安装。</p></blockquote><p>安装好依赖环境后， <code>GVM</code> 的安装也很简单。官方提供了一键安装脚本，你只需直接运行就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</span><br></pre></td></tr></table></figure><p>如果你使用的是 <code>zsh</code> 的话将前面的 <code>bash</code> 改为 <code>zsh</code> 即可，这条命令主要是检查相关依赖环境并下载 <code>GVM</code> 相关的文件，然后创建所需目录，并且在 <code>.bashrc</code> 或者 <code>.zshrc</code> 中加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -s <span class="string">"/home/wcl/.gvm/scripts/gvm"</span> ]] &amp;&amp; <span class="built_in">source</span> <span class="string">"/home/wcl/.gvm/scripts/gvm"</span></span><br></pre></td></tr></table></figure><p>使每次登录 <code>Shell</code> 时都可以自动生效。</p><h2 id="使用-gvm-安装和管理-go-版本">使用 GVM 安装和管理 Go 版本</h2><p>一旦安装了 <code>GVM</code>，就可以开始使用它来安装和管理不同版本的 <code>Go</code>。首先，你可以用 <code>gvm listall</code> 命令显示可以下载和编译可用的 <code>Go</code> 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gvm listall</span><br><span class="line"></span><br><span class="line">gvm gos (available)</span><br><span class="line"></span><br><span class="line">   go1</span><br><span class="line">   go1.0.1</span><br><span class="line">   go1.0.2</span><br><span class="line">   go1.0.3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>安装特定的 <code>Go</code> 版本只需运行 <code>gvm install &lt;version&gt;</code>命令，其中 <code>&lt;version&gt;</code> 是表示要安装的版本。假设你正在处理一个使用 <code>Go 1.12.8</code> 版本的项目，你就可以使用 <code>gvm install go1.12.8</code> 命令来安装这个版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gvm install go1.12.8</span><br><span class="line">Installing go1.12.8...</span><br><span class="line"> * Compiling...</span><br><span class="line">go1.12.8 successfully installed!</span><br></pre></td></tr></table></figure><p>安装完成后，输入 <code>gvm list</code> 命令后，你会看到 <code>Go 1.12.8</code> 版本与系统自带的 <code>Go</code> 版本（使用操作系统的软件包管理器打包的版本）都同时存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gvm list</span><br><span class="line">gvm gos (installed)</span><br><span class="line">   go1.12.8</span><br><span class="line">=&gt; system</span><br></pre></td></tr></table></figure><p>不过，这时 <code>GVM</code> 仍然默认使用系统的 <code>Go</code> 版本，通过它旁边的 <code>=&gt;</code> 符号来表示。你可以使用 <code>gvm use</code> 命令来切换到新安装的 <code>go 1.12.8</code> 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gvm use go1.12.8</span><br><span class="line">Now using version go1.12.8</span><br><span class="line">$ go version</span><br><span class="line">go version go1.12.8 linux/amd64</span><br></pre></td></tr></table></figure><p>如果不想每次敲 <code>gvm use</code> 指令来切换版本，你可以加上 <code>--default</code> 参数来指定默认使用这个版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gvm use go1.12.8 --default</span><br></pre></td></tr></table></figure><p>是不是，很容易呢！<code>GVM</code> 使管理已安装的 <code>Go</code> 版本变得极其简单，但它不止如此！</p><blockquote><p>由于 <code>Go 1.5</code> 使用了自举（用 <code>Go</code> 编译 <code>Go</code>），如果在系统环境完全没有 <code>Go</code> 命令的情况下，直接使用 <code>gvm install go</code> 会报错。所以，你必须先安装 <code>Go 1.4</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装 1.4 版本的，-B 表示只安装二进制包。</span></span><br><span class="line">$ gvm install go1.4 -B  </span><br><span class="line">$ gvm use go1.4  </span><br><span class="line">$ <span class="built_in">export</span> GOROOT_BOOTSTRAP=<span class="variable">$GOROOT</span>  </span><br><span class="line"><span class="comment"># 再安装 1.5+ 版本的</span></span><br><span class="line">$ gvm install go1.12.8</span><br></pre></td></tr></table></figure><h2 id="使用-gvm-pkgset">使用 GVM pkgset</h2><p>默认情况下，如果你通过 <code>go get</code> 获取一个包，它会被下载到 <code>$GOPATH</code> 目录中的 <code>src</code> 和 <code>pkg</code> 目录下。然后你可以使用 <code>import</code> 将其引入到你的 <code>Go</code> 程序中。然而，在不同的项目中管理相同包的不同版本就会变得困难。</p><p><code>GVM</code> 通过使用「<code>pkgsets</code>」将项目的新目录附加到 <code>Go</code> 安装版本的默认 <code>$GOPATH</code>，类似 <code>Linux</code> 系统上的 <code>$PATH</code>，这样就可以很好地完成了项目之间包的管理和隔离。我们来看一个实例，安装一个新版本的 <code>Go 1.12.9</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$GOPATH</span></span><br><span class="line">/home/chris/.gvm/pkgsets/go1.12.8/global</span><br><span class="line">$ gvm install go1.12.9</span><br><span class="line">Installing go1.12.9...</span><br><span class="line"> * Compiling...</span><br><span class="line">go1.12.9 successfully installed</span><br><span class="line">$ gvm use go1.12.9</span><br><span class="line">Now using version go1.12.9</span><br></pre></td></tr></table></figure><p>当 <code>GVM</code> 被告知使用一个新版本时，它将会更换一个新的 <code>$GOPATH</code>，<code>gloabl pkgset</code> 将默认使用该版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$GOPATH</span></span><br><span class="line">/home/chris/.gvm/pkgsets/go1.12.9/global</span><br><span class="line">$ gvm pkgset list</span><br><span class="line">gvm go package sets (go1.12.9)</span><br><span class="line">=&gt;  global</span><br></pre></td></tr></table></figure><blockquote><p>尽管默认情况下没有安装额外的包，但是 <code>global pkgset</code> 中的包对于使用这个特定版本 <code>Go</code> 的任何项目都是可用的。</p></blockquote><p>现在，假设你正在启动一个新项目，它需要一个特定的包。首先，使用 <code>GVM</code> 创建一个名为 <code>introToGvm</code> 的新的 <code>pkgset</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gvm pkgset create introToGvm</span><br><span class="line">$ gvm pkgset use introToGvm</span><br><span class="line">Now using version go1.12.9@introToGvm</span><br><span class="line">$ gvm pkgset list</span><br><span class="line">gvm go package sets (go1.12.9)</span><br><span class="line">    global</span><br><span class="line">=&gt;  introToGvm</span><br></pre></td></tr></table></figure><p>如上所述，一个与 <code>pkgset</code> 同名的新目录 <code>introToGvm</code> 被添加到 <code>$GOPATH</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$GOPATH</span></span><br><span class="line">/home/chris/.gvm/pkgsets/go1.12.9/introToGvm:/home/chris/.gvm/pkgsets/go1.12.9/global</span><br></pre></td></tr></table></figure><p>接下来，验证下新目录 <code>introToGvm</code> 中的目录结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> $( awk -F<span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span> &lt;&lt;&lt; <span class="variable">$GOPATH</span> )</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/chris/.gvm/pkgsets/go1.12.9/introToGvm</span><br><span class="line">$ ls</span><br><span class="line">overlay  pkg  src</span><br></pre></td></tr></table></figure><blockquote><p>注意：新目录看起来很像普通的 <code>$GOPATH</code>，新的 <code>Go</code> 包会被  <code>Go get</code> 命令下载并且被添加到 <code>pkgset</code> 中。</p></blockquote><p>最后，使用以下命令获取一个 <code>gorilla/mux</code> 包，然后检查 <code>pkgset</code> 下的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/gorilla/mux</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── overlay</span><br><span class="line">│   ├── bin</span><br><span class="line">│   └── lib</span><br><span class="line">│       └── pkgconfig</span><br><span class="line">├── pkg</span><br><span class="line">│   └── linux_amd64</span><br><span class="line">│       └── github.com</span><br><span class="line">│           └── gorilla</span><br><span class="line">│               └── mux.a</span><br><span class="line">src/</span><br><span class="line">└── github.com</span><br><span class="line">    └── gorilla</span><br><span class="line">        └── mux</span><br><span class="line">            ├── AUTHORS</span><br><span class="line">            ├── bench_test.go</span><br><span class="line">            ├── context.go</span><br><span class="line">            ├── context_test.go</span><br><span class="line">            ├── doc.go</span><br><span class="line">            ├── example_authentication_middleware_test.go</span><br><span class="line">            ├── example_cors_method_middleware_test.go</span><br><span class="line">            ├── example_route_test.go</span><br><span class="line">            ├── go.mod</span><br><span class="line">            ├── LICENSE</span><br><span class="line">            ├── middleware.go</span><br><span class="line">            ├── middleware_test.go</span><br><span class="line">            ├── mux.go</span><br><span class="line">            ├── mux_test.go</span><br><span class="line">            ├── old_test.go</span><br><span class="line">            ├── README.md</span><br><span class="line">            ├── regexp.go</span><br><span class="line">            ├── route.go</span><br><span class="line">            └── test_helpers.go</span><br></pre></td></tr></table></figure><p>如上所示，<code>gorilla/mux</code> 按照预期添加到了 <code>pkgset</code> 的 <code>$GOPATH</code> 目录，现在你就可以与使用该 <code>pkgset</code> 的项目一起使用该模块了。</p><h2 id="卸载-gvm-或指定版本-go-语言">卸载 GVM 或指定版本 Go 语言</h2><ol><li>如果你只是想卸载某个安装好的 <code>Go</code> 版本，可以使用以下指令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gvm uninstall go1.12.8</span><br></pre></td></tr></table></figure><ol start="2"><li>如果你想完全卸载掉 GVM 和 所有安装的 Go 版本，可以使用以下指令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需谨慎操作</span></span><br><span class="line">$ gvm implode</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p><code>GVM</code> 是以一种直观的、非侵入性的方式来管理 <code>Go</code> 版本和包的工具。它可以单独使用，也可以使用 <code>GVM</code> 的 <code>Go</code> 版本管理功能与其他 <code>Go</code> 模块管理技术结合使用。<code>GVM</code> 通过对 <code>Go</code> 版本和包依赖关系的隔离使项目开发更加容易，并减少了管理版本冲突的复杂性。</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://bingohuang.com/go-gvm/" target="_blank" rel="noopener">https://bingohuang.com/go-gvm/</a></p></li><li><p><a href="https://learnku.com/articles/35269" target="_blank" rel="noopener">https://learnku.com/articles/35269</a></p></li><li><p><a href="https://dryyun.com/2018/11/28/how-to-use-gvm/" target="_blank" rel="noopener">https://dryyun.com/2018/11/28/how-to-use-gvm/</a></p></li><li><p><a href="https://laucyun.com/ff3bc3db699464aa76756e41be780712.html" target="_blank" rel="noopener">https://laucyun.com/ff3bc3db699464aa76756e41be780712.html</a></p></li><li><p><a href="https://opensource.com/article/19/10/go-introduction-gvm" target="_blank" rel="noopener">https://opensource.com/article/19/10/go-introduction-gvm</a></p></li><li><p><a href="http://blog.fatedier.com/2016/07/25/use-different-go-version-by-gvm/" target="_blank" rel="noopener">http://blog.fatedier.com/2016/07/25/use-different-go-version-by-gvm/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Golang&lt;/code&gt; 发展迅速，代码迭代非常快，想要在同一环境调试和梳理不同项目进程就成了一件相对棘手的事情。二进制文件的管理比较简单，通过链接使用不同版本的程序即可。实际上主要是一些环境变量和标准库的设置问题，偶然间发现了 &lt;code&gt;GVM - Go Version Manager&lt;/code&gt;，&lt;code&gt;GVM&lt;/code&gt; 实际上就是帮助我们完成这些配置工作，这算是找到了调试切换版本的福音了。&lt;/p&gt;
&lt;h2 id=&quot;什么是-GVM&quot;&gt;什么是 GVM&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 语言版本管理器（&lt;code&gt;GVM&lt;/code&gt;）是管理 &lt;code&gt;Go&lt;/code&gt; 语言环境的开源工具。&lt;code&gt;GVM 「pkgsets」&lt;/code&gt; 支持安装多个版本的 &lt;code&gt;Go&lt;/code&gt; 并管理每个项目的模块。它最初由 &lt;code&gt;Josh Bussdieker&lt;/code&gt; 开发，&lt;code&gt;GVM&lt;/code&gt; 与 &lt;code&gt;Ruby RVM&lt;/code&gt; 类似，允许你为每个项目或一组项目创建一个开发环境，分离不同的 &lt;code&gt;Go&lt;/code&gt; 版本和包依赖关系，来提供更大的灵活性，以防不同版本造成的问题。&lt;code&gt;GVM&lt;/code&gt; 主要有以下几个特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;管理 &lt;code&gt;Go&lt;/code&gt; 的多个版本，包括安装、卸载和指定使用 &lt;code&gt;Go&lt;/code&gt; 的某个版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看官方所有可用的 &lt;code&gt;Go&lt;/code&gt; 版本，同时可以查看本地已安装和默认使用的 &lt;code&gt;Go&lt;/code&gt; 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;管理多个 &lt;code&gt;GOPATH&lt;/code&gt;，并可编辑 &lt;code&gt;Go&lt;/code&gt; 的环境变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可将当前目录关联到 &lt;code&gt;GOPATH&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以查看 &lt;code&gt;GOROOT&lt;/code&gt; 下的文件差异&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 &lt;code&gt;Go&lt;/code&gt; 版本切换&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/moovweb/gvm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/moovweb/gvm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Go" scheme="https://www.hi-linux.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>再见 XShell 和 ITerm 2，是时候拥抱全平台高颜值终端工具 Hyper 了</title>
    <link href="https://www.hi-linux.com/posts/44812.html"/>
    <id>https://www.hi-linux.com/posts/44812.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-11T05:10:15.703Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>不论是 <code>macOS</code> 还是 <code>Windows</code> 下，我们都不推荐使用系统自带终端。无论是可拓展性还是可编程性都被「系统自带」这样的特点限制。特别是 <code>Windows</code> 下的万恶之源「小黑框」，在 9012 年真的是不太好用哟！</p><p>今天我们将给大家介绍一款基于 <code>Electron</code> 的全平台高颜值的终端工具 <code>Hyper</code>。<code>Hyper</code> 支持丰富的主题和插件功能，通过强大的插件系统提供了非常丰富的自定义选项，可谓是颜值和易用并存的神器。</p><blockquote><p>官网地址：<a href="https://hyper.is" target="_blank" rel="noopener">https://hyper.is</a></p></blockquote><p>下面先放一张配置好的预览效果图，让大家先睹为快。</p><p><img src="https://img.fythonfang.com/MacScreenShot%202018-07-20-5-35-35.png" alt=""></p><p>由于 <code>Hyper</code> 是基于 <code>Electron</code> 的，所以它的插件、主题等等可拓展性都非常强大。几行简单的 <code>Javascript</code>、<code>HTML</code>、 <code>CSS</code> 代码，你就可以定制自己的插件。</p><blockquote><p><code>Electron</code> 是一个利用最新 <code>Web</code> 技术栈搭建跨平台应用的项目，比如: <code>GitHub</code> 出品的代码编辑器 <code>Atom</code> 和微软出品的 <code>VSCode</code> 都是基于 <code>Electron</code> 的。</p></blockquote><h2 id="安装-hyper">安装 Hyper</h2><p><code>Hyper</code> 的安装非常简单，只需要在官网下载对应平台二进制安装包后，直接安装就可以运行。</p><p><img src="https://cdn.sspai.com/editor/u_735639/media/15651037049805/15651047302326.jpg" alt=""></p><p>如果你是 <code>macOS</code> 平台，你还可以通过 <code>Homebrew</code> 命令来快速完成安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install hyper</span><br></pre></td></tr></table></figure><p>如果你还不知道 <code>Homebrew</code> 如何安装和使用可以参考 ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247484646&amp;idx=1&amp;sn=f73feedee278c03c6c2d138154f822fb&amp;chksm=eac525cfddb2acd964c163f6020cc1c385abc8f0680cc6086881a8093b73511db31c34e3e3fc&amp;token=985021721&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「macOS 不可或缺的套件管理器——Homebrew」</a> 和  ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247484672&amp;idx=1&amp;sn=55dc5a5b3283fe618124684d9b683a17&amp;chksm=eac52429ddb2ad3fba77229c3ffbe4c3e3cf7b6477fbc08a43232e0c67bdc367be3a293f04d5&amp;token=985021721&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「macOS小技巧 —— 如何用 Homebrew 安装指定版本软件」</a> 两篇文章先了解下。</p><a id="more"></a><h2 id="hyper-主题安装">Hyper 主题安装</h2><p><code>Hyper</code> 做为一个高颜值终端工具，自然就少不了对主题的支持。官方首页推荐了 4 种不同颜色的主题，你可以在官方主题地址 <code>https://hyper.is/themes</code> 直接查看并安装。</p><p><img src="https://www.hi-linux.com/img/linux/hyper-theme.jpg" alt=""></p><p>当然，如果上面官方推荐的主题满足不了你，你也可以去在上面的主题地址中的 <code>NEWEST</code> 页签找到更多主题，或者是去 <code>GitHub</code> 搜索更多好看的主题。</p><h2 id="善用-hyper-插件">善用 Hyper 插件</h2><p><code>Hyper</code> 本身是支持插件系统的，在安装扩展插件前，你需要先安装 <code>Hyper</code> 命令行程序。你可以点击菜单，选择 <code>Plugin</code> 选项，然后点击 <code>Install Hyper CLI command in PATH</code>。</p><p><code>Hyper</code> 命令行程序安装完成后，<code>Hyper</code> 插件安装就十分简单了，只需要打开 <code>Hyper</code> 之后一行代码就可以搞定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i verminal</span><br></pre></td></tr></table></figure><p>这样就安装了 <code>verminal</code> 这个插件。</p><p><code>Hyper</code> 官方也在首页给大家推荐了 4 个比较易用的插件，推荐大家全部都安装试试。</p><h3 id="1-hypercwd">1. hypercwd</h3><p><img src="https://raw.githubusercontent.com/hharnisc/hypercwd/master/newTabs.gif" alt=""></p><p>它可以让你的终端在新建标签页时，保持上一个终端的目录地址。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hypercwd</span><br></pre></td></tr></table></figure><h3 id="2-hyper-search">2. hyper-search</h3><p><img src="https://www.hi-linux.com/img/linux/hyper-search.jpg" alt=""></p><p>它可以让你搜索整个终端的所有文本内容。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hyper-search</span><br></pre></td></tr></table></figure><h3 id="3-hyper-pane">3. hyper-pane</h3><p><img src="https://hyper-plugin-screenshots.now.sh/hyper-pane.gif" alt=""></p><p>该插件用来增强窗口导航，对于支持多个页签的软件来说这是个利器。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hyper-pane</span><br></pre></td></tr></table></figure><h3 id="4-hyperpower">4. hyperpower</h3><p><img src="https://cloud.githubusercontent.com/assets/13041/16820268/13c9bfe6-4905-11e6-8fe4-baf8fc8d9293.gif" alt=""></p><p>这是一个让你的终端变得更加绚丽的插件，类似于 <code>Atom</code> 里面的一个叫做 <code>activate-power-mode</code> 的插件。当然这么炫酷的效果是不是会影响你的工作呢，还是要视个人情而定。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hyperpower</span><br></pre></td></tr></table></figure><p>如果你需要更多的插件和主题，你可以在官方网站以下地址中找到。</p><blockquote><ol><li><p><code>Hyper</code> 的官方主题地址：<a href="https://hyper.is/themes" target="_blank" rel="noopener">https://hyper.is/themes</a></p></li><li><p><code>Hyper</code> 的官方插件地址：<a href="https://hyper.is/plugins" target="_blank" rel="noopener">https://hyper.is/plugins</a></p></li></ol></blockquote><p>除了，官方提供的主题和插件。目前还有一个社区驱动的 <code>awesome-hyper</code> 项目，里面有着更多开源的 <code>Hyper</code> 终端插件、主题等等。如果你对不同的主题和插件有兴趣，可以去这个项目里进行探索哟！</p><blockquote><ol><li>项目地址：<a href="https://github.com/bnb/awesome-hyper" target="_blank" rel="noopener">https://github.com/bnb/awesome-hyper</a></li></ol></blockquote><h2 id="整合-zsh">整合 ZSH</h2><p>通常 <code>Linux</code> 服务器上面默认使用的 <code>SHELL</code> 是 <code>Bash</code>。其实除了 <code>Bash</code> 之外，还有很多其他的 <code>SHELL</code> 程序，比如：<code>ZSH</code>、<code>CSH</code>、<code>Fish</code> 等等。</p><p>这里我们将介绍的 <code>ZSH</code> 是我认为在类 <code>Unix</code> 系统下最优雅的 <code>Shell</code> 程序 。虽然 <code>ZSH</code> 设置复杂，但得益于开源社区，我们可以使用  <code>Oh-My-ZSH</code> 这个神器来很方便的管理和配置 <code>ZSH</code>。</p><h3 id="安装-zsh-和-oh-my-zsh">安装 ZSH 和 Oh-My-ZSH</h3><p>在使用 <code>Oh-My-ZSH</code> 之前，你需要先安装 <code>ZSH</code>。各个平台安装的方式可能不一样，这里就只简单说下比较常用的 <code>Centos</code> 和 <code>Ubuntu</code> 系统下的安装方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redhat / Centos</span></span><br><span class="line">$ yum install zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debian / Ubuntu</span></span><br><span class="line">$ apt-get install zsh</span><br></pre></td></tr></table></figure><p>更多平台的安装方法，你可以通过 ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483784&amp;idx=1&amp;sn=60aa4c40e12b0d64bf373d5606f8e2e9&amp;chksm=eac520a1ddb2a9b70ce515e9ee6f290842ef2276d0b52f620f05280b8e30f7f3c7591802ca5f&amp;token=1853415346&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「利用 Oh-My-Zsh 打造你的超级终端」</a> 这篇文章了解。</p><p>安装好 <code>ZSH</code>  后，就可以安装 <code>Oh-My-ZSH</code> 了。<code>Oh-My-ZSH</code> 的安装也是非常简单的，你只需要用下面两条指令中的任意一条就可完成安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 curl 安装</span></span><br><span class="line">$ sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 wget 安装</span></span><br><span class="line">$ sh -c <span class="string">"<span class="variable">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure><p>安装完成后，你就会发现你的终端 <code>SHELL</code> 变成了 <code>ZSH</code>。你还可以通过命令 <code>chsh -s /bin/zsh</code> 将 <code>ZSH</code> 设置为默认的 <code>Shell</code>。</p><h3 id="配置主题">配置主题</h3><p><code>Oh-My-ZSH</code> 默认也附带了大量好看的主题，你可以利用它们对终端界面做进一步增强和美化。<code>Oh-My-ZSH</code> 默认的主题存放在 <code>~/.oh-my-zsh/themes</code> 目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ls ~/.oh-my-zsh/themes</span><br><span class="line"></span><br><span class="line">3den.zsh-theme                essembeh.zsh-theme            junkfood.zsh-theme            rgm.zsh-theme</span><br><span class="line">Soliah.zsh-theme              evan.zsh-theme                kafeitu.zsh-theme             risto.zsh-theme</span><br><span class="line">adben.zsh-theme               example.zsh-theme             kardan.zsh-theme              rixius.zsh-theme</span><br><span class="line">af-magic.zsh-theme            fino-time.zsh-theme           kennethreitz.zsh-theme        rkj-repos.zsh-theme</span><br><span class="line">afowler.zsh-theme             fino.zsh-theme                kiwi.zsh-theme                rkj.zsh-theme</span><br><span class="line">agnoster.zsh-theme            fishy.zsh-theme               kolo.zsh-theme                robbyrussell.zsh-theme</span><br><span class="line">alanpeabody.zsh-theme         flazz.zsh-theme               kphoen.zsh-theme              sammy.zsh-theme</span><br><span class="line">amuse.zsh-theme               fletcherm.zsh-theme           lambda.zsh-theme              simonoff.zsh-theme</span><br><span class="line">apple.zsh-theme               fox.zsh-theme                 linuxonly.zsh-theme           simple.zsh-theme</span><br><span class="line">arrow.zsh-theme               frisk.zsh-theme               lukerandall.zsh-theme         skaro.zsh-theme</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>对于主题的启用，你只需编辑 <code>ZSH</code> 配置文件 <code>~/.zshrc</code>。并在 <code>ZSH_THEME</code> 项中直接修改主题名称为要启用的主题名称即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME&#x3D;&quot;agnoster&quot;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你安装的主题无法显示预期效果，那是因为响应的主题的系统字体没有安装。这时，你需要正确的安装了 <code>Powerline</code> 字体才会显示出来。</p><ol><li><p><code>Powerline</code> 项目地址：<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a></p></li><li><p><code>Powerline</code> 安装教程：<a href="https://powerline.readthedocs.io/en/latest/installation.html#fonts-installation" target="_blank" rel="noopener">https://powerline.readthedocs.io/en/latest/installation.html#fonts-installation</a></p></li></ol></blockquote><p>如果这些默认主题还不能满足你的需要，你还可以到下面这些地址中找到更多的 <code>ZSH</code> 主题。</p><blockquote><ol><li><p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a></p></li><li><p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes</a></p></li><li><p><a href="https://github.com/unixorn/awesome-zsh-plugins#themes" target="_blank" rel="noopener">https://github.com/unixorn/awesome-zsh-plugins#themes</a></p></li></ol></blockquote><h3 id="配置插件">配置插件</h3><p><code>Oh-My-ZSH</code> 之所以强大，其中一个原因就是支持诸多功能强大的插件，<code>Oh-My-ZSH</code> 默认自带的插件都存放在 <code>~/.oh-my-zsh/plugins</code> 目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ls ~/.oh-my-zsh/plugins</span><br><span class="line"></span><br><span class="line">adb               brew         coffee             dirpersist      fastfile         gitignore                 httpie     last-working-dir  nanoc                  pod         rebar       sprunge        terminitor  vault              zeus</span><br><span class="line">ant               brew-cask    colemak            django          fbterm           git-prompt                iwhois     lein              nmap                   postgres    redis-cli   ssh-agent      terraform   vim-interaction    zsh-navigation-tools</span><br><span class="line">apache2-macports  bundler      colored-man-pages  dnf             fedora           git-remote-branch         jake-node  lighthouse        node                   pow         repo        stack          textastic   vi-mode            zsh_reload</span><br><span class="line">archlinux         bwana        colorize           docker          forklift         glassfish                 jhbuild    lol               npm                    powder      rsync       sublime        textmate    virtualenv</span><br><span class="line">asdf              cabal        <span class="built_in">command</span>-not-found  docker-compose  frontend-search  gnu-utils                 jira       macports          nvm                    powify      ruby        sudo           thefuck     virtualenvwrapper</span><br><span class="line">autoenv           cake         common-aliases     emacs           gas              go                        jruby      man               nyan                   profiles    rvm         supervisor     themes      vundle</span><br><span class="line">autojump          cakephp3     compleat           ember-cli       geeknote         golang                    jsontools  marked2           osx                    pyenv       safe-paste  suse           thor        wakeonlan</span><br><span class="line">autopep8          capistrano   composer           emoji           gem              gpg-agent                 jump       mercurial         pass                   pylint      sbt         svn            tmux        wd</span><br><span class="line">aws               cask         copydir            emoji-clock     git              gradle                    kate       meteor            paver                  python      scala       svn-fast-info  tmux-cssh   web-search</span><br><span class="line">battery           catimg       copyfile           emotty          git-extras       grails                    kitchen    mix               pep8                   rails       scd         symfony        tmuxinator  wp-cli</span><br><span class="line">bbedit            celery       cp                 encode64        gitfast          grunt                     knife      mix-fast          per-directory-history  rake        screen      symfony2       torrent     xcode</span><br><span class="line">bgnotify          chruby       cpanm              extract         git-flow         gulp                      knife_ssh  mosh              perl                   rake-fast   scw         systemadmin    tugboat     yii</span><br><span class="line">boot2docker       chucknorris  debian             fabric          git-flow-avh     heroku                    laravel    mvn               phing                  rand-quote  sfffe       systemd        ubuntu      yii2</span><br><span class="line">bower             cloudapp     dircycle           fancy-ctrl-z    github           <span class="built_in">history</span>                   laravel4   mysql-macports    pip                    rbenv       singlechar  taskwarrior    urltools    yum</span><br><span class="line">branch            codeclimate  dirhistory         fasd            git-hubflow      <span class="built_in">history</span>-substring-search  laravel5   n98-magerun       pj                     rbfu        spring      terminalapp    vagrant     z</span><br></pre></td></tr></table></figure><p>默认情况下，<code>Oh-My-ZSH</code> 只启用 <code>Git</code> 插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 插件可以十分清晰的显示出当前代码仓库里与远程仓库是否同步，以及最新同步日期等等信息。</span></span><br><span class="line">plugins=(git)</span><br></pre></td></tr></table></figure><p>如果你需启用更多插件，只需加入要启用插件的名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=(git wd web-search <span class="built_in">history</span> <span class="built_in">history</span>-substring-search)</span><br></pre></td></tr></table></figure><p>除默认自带的插件外，你还可以在 <code>GitHub</code> 上找到更多好用的 <code>ZSH</code> 三方插件，这里推荐几个比较好用三方插件。</p><blockquote><ol><li>zsh-history-substring-search</li></ol><p>项目地址：<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/history-substring-search" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/history-substring-search</a></p><ol start="2"><li>zsh-syntax-highlighting</li></ol><p>项目地址：<a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-syntax-highlighting</a></p><ol start="3"><li>zsh-autosuggestions</li></ol><p>项目地址：<a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-autosuggestions</a></p></blockquote><p>如果你想更多了解 <code>ZSH</code> 和 <code>Oh-My-ZSH</code>，可以通过 ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483784&amp;idx=1&amp;sn=60aa4c40e12b0d64bf373d5606f8e2e9&amp;chksm=eac520a1ddb2a9b70ce515e9ee6f290842ef2276d0b52f620f05280b8e30f7f3c7591802ca5f&amp;token=1853415346&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「利用 Oh-My-Zsh 打造你的超级终端」</a> 和  ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247488164&amp;idx=1&amp;sn=4a0d6635638148684d893aa0b45b0946&amp;chksm=eac5338dddb2ba9bd8e071a5aba95697a0f7b4891087a5740cc1f0297382f9035ac9fc7895ac&amp;token=1853415346&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「让你提前体验 macOS Catalina 的 Shell — Oh My Zsh 配置指南」</a> 这两篇文章进一步探索。</p><h2 id="集成-wsl">集成 WSL</h2><p>通常在使用 <code>WSL (Windows Subsystem for Linux)</code> 工作时，我们希望启动终端时就进入 <code>WSL</code> 的 <code>SHELL</code> 内部。但默认情况下我们需要在启动终端并输入 <code>bash</code> 命令后才能进入 <code>WSL</code> 终端。</p><p>很显然有此一步操作后，我们会觉得太繁琐了。有了 <code>Hyper</code> 后，我们只需要改动一下配置文件，上面这步就可以直接省略。</p><p>现在，你只需打开 <code>Hyper</code> 设置页面文件，从菜单 <code>Edit -&gt; Preferences</code> 进入，然后编辑 <code>shell</code> 和 <code>shellArgs</code> 参数即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell: <span class="string">'C:\\Windows\\System32\\bash.exe'</span>,</span><br><span class="line">shellArgs: [],</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aHlvbmctY24tZmlsZS5vc3MtY24tc2hhbmdoYWkuYWxpeXVuY3MuY29tLzIwMTgxMi8yMDE4LTEyLTE1XzE3LTI0LTQzLnBuZw" alt=""></p><p>修改完成后，再次重新打开 <code>Hyper</code>，你会发现默认已经进入了 <code>Bash</code> 终端界面了。</p><h2 id="总结">总结</h2><p>本文讲述了如何安装和使用 <code>Hyper</code> 这个高颜值跨平台的终端软件，其中包括配置 <code>Hyper</code> 插件和主题。并讲述了如何使用 <code>ZSH</code> 来代替 <code>Bash</code> 让你的终端更加强大易用的方法。都看到这里了，你还在等什么呢？是时候放弃你的 <code>Xshell</code> 和 <code>iTerm 2</code> 吧！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://sspai.com/post/56081" target="_blank" rel="noopener">https://sspai.com/post/56081</a></p></li><li><p><a href="https://sspai.com/post/45332" target="_blank" rel="noopener">https://sspai.com/post/45332</a></p></li><li><p><a href="https://archive.spencerwoo.com/posts/2018/06/17/terminal.html" target="_blank" rel="noopener">https://archive.spencerwoo.com/posts/2018/06/17/terminal.html</a></p></li><li><p><a href="https://www.fythonfang.com/blog/post/24" target="_blank" rel="noopener">https://www.fythonfang.com/blog/post/24</a></p></li><li><p><a href="https://github.com/sindresorhus/hyper-snazzy" target="_blank" rel="noopener">https://github.com/sindresorhus/hyper-snazzy</a></p></li><li><p><a href="https://www.veinin.com/2018/11/30/hyper-windows-tutorial/" target="_blank" rel="noopener">https://www.veinin.com/2018/11/30/hyper-windows-tutorial/</a></p></li><li><p><a href="https://blog.csdn.net/was172/article/details/85016495" target="_blank" rel="noopener">https://blog.csdn.net/was172/article/details/85016495</a></p></li><li><p><a href="https://github.com/sindresorhus/pure" target="_blank" rel="noopener">https://github.com/sindresorhus/pure</a></p></li><li><p><a href="https://www.fythonfang.com/blog/post/24" target="_blank" rel="noopener">https://www.fythonfang.com/blog/post/24</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不论是 &lt;code&gt;macOS&lt;/code&gt; 还是 &lt;code&gt;Windows&lt;/code&gt; 下，我们都不推荐使用系统自带终端。无论是可拓展性还是可编程性都被「系统自带」这样的特点限制。特别是 &lt;code&gt;Windows&lt;/code&gt; 下的万恶之源「小黑框」，在 9012 年真的是不太好用哟！&lt;/p&gt;
&lt;p&gt;今天我们将给大家介绍一款基于 &lt;code&gt;Electron&lt;/code&gt; 的全平台高颜值的终端工具 &lt;code&gt;Hyper&lt;/code&gt;。&lt;code&gt;Hyper&lt;/code&gt; 支持丰富的主题和插件功能，通过强大的插件系统提供了非常丰富的自定义选项，可谓是颜值和易用并存的神器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://hyper.is&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hyper.is&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面先放一张配置好的预览效果图，让大家先睹为快。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.fythonfang.com/MacScreenShot%202018-07-20-5-35-35.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;Hyper&lt;/code&gt; 是基于 &lt;code&gt;Electron&lt;/code&gt; 的，所以它的插件、主题等等可拓展性都非常强大。几行简单的 &lt;code&gt;Javascript&lt;/code&gt;、&lt;code&gt;HTML&lt;/code&gt;、 &lt;code&gt;CSS&lt;/code&gt; 代码，你就可以定制自己的插件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Electron&lt;/code&gt; 是一个利用最新 &lt;code&gt;Web&lt;/code&gt; 技术栈搭建跨平台应用的项目，比如: &lt;code&gt;GitHub&lt;/code&gt; 出品的代码编辑器 &lt;code&gt;Atom&lt;/code&gt; 和微软出品的 &lt;code&gt;VSCode&lt;/code&gt; 都是基于 &lt;code&gt;Electron&lt;/code&gt; 的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装-Hyper&quot;&gt;安装 Hyper&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Hyper&lt;/code&gt; 的安装非常简单，只需要在官网下载对应平台二进制安装包后，直接安装就可以运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/editor/u_735639/media/15651037049805/15651047302326.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你是 &lt;code&gt;macOS&lt;/code&gt; 平台，你还可以通过 &lt;code&gt;Homebrew&lt;/code&gt; 命令来快速完成安装。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew cask install hyper&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你还不知道 &lt;code&gt;Homebrew&lt;/code&gt; 如何安装和使用可以参考 ​&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247484646&amp;amp;idx=1&amp;amp;sn=f73feedee278c03c6c2d138154f822fb&amp;amp;chksm=eac525cfddb2acd964c163f6020cc1c385abc8f0680cc6086881a8093b73511db31c34e3e3fc&amp;amp;token=985021721&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「macOS 不可或缺的套件管理器——Homebrew」&lt;/a&gt; 和  ​&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247484672&amp;amp;idx=1&amp;amp;sn=55dc5a5b3283fe618124684d9b683a17&amp;amp;chksm=eac52429ddb2ad3fba77229c3ffbe4c3e3cf7b6477fbc08a43232e0c67bdc367be3a293f04d5&amp;amp;token=985021721&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「macOS小技巧 —— 如何用 Homebrew 安装指定版本软件」&lt;/a&gt; 两篇文章先了解下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款超实用的命令行备忘神器 Navi</title>
    <link href="https://www.hi-linux.com/posts/29102.html"/>
    <id>https://www.hi-linux.com/posts/29102.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-11T05:22:20.129Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，无论对于运维,还是开发来说，命令行工具都是非常高效的一种管理方式。但有一个很常见的现象就是，很多命令行语句比较复杂，用过一段时间后就忘记了。当然，这时我们可以通过网络搜索或者使用命令的 <code>-—help</code> 选项来快速找到答案。虽然这种常用的方法能解决问题，但是使用起来相对还是显得不那么快速高效。</p><p>之前，我们在「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487743&amp;idx=1&amp;sn=e726fa2c2b8fa0e56e5653c9aba08732&amp;chksm=eac531d6ddb2b8c06c599a1290a1fb4dd22d53855d88294a8a8b443be74a0279fdcaf912eb67&amp;token=1334996765&amp;lang=zh_CN#rd" target="_blank" rel="noopener">如何快速的回忆起遗忘的 Linux 命令</a>」 一文中介绍了如何利用 <code>Apropos</code> 命令来快速查找相应的 <code>Linux</code> 命令。今天，我们再给大家推荐另一款神器 <code>navi</code>。</p><p><code>navi</code> 是一位来自巴西的小哥哥 <code>Denis Isidoro</code> 在 <code>GitHub</code> 上开源的一个的工具 ，目前已经获得超过 4200 星。<code>navi</code> 可以在命令行里给你提供了一个很方便使用的交互式的备忘录，能够帮助你在命令行里快速查阅、调用各种复杂难记的命令行语句。</p><blockquote><p>项目地址：<a href="https://github.com/denisidoro/navi" target="_blank" rel="noopener">https://github.com/denisidoro/navi</a></p></blockquote><p>俗话说得好，不看广告看疗效。废话不多说，先看看下面的演示效果图吧！</p><p><img src="https://www.hi-linux.com/img/linux/navi1.gif" alt=""></p><p>从演示中，我们可能看到使用了 <code>navi</code> 后，只需要键入一个单词，备忘录中的相关命令以及命令用法注释都会实时显示在下方供你直接选择使用，这时我们只需找到想要的命令后即可直接运行相关命令。是不是觉得很神奇和强大呢！</p><a id="more"></a><h2 id="安装-navi">安装 Navi</h2><p><code>navi</code> 的安装还是很容易的，<code>macOS</code> 和 <code>Linux</code> 用户都可以安装。如果你已经安装了 <code>Homebrew</code> 或者 <code>Linuxbrew</code>，那么只需下面一句命令就可以安装好 <code>navi</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install denisidoro&#x2F;tools&#x2F;navi</span><br></pre></td></tr></table></figure><p>如果你没有安装 <code>Homebrew</code> 或者 <code>Linuxbrew</code> 这样的包管理器，你也可以直接通过源码安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth 1 https:&#x2F;&#x2F;github.com&#x2F;denisidoro&#x2F;navi &#x2F;opt&#x2F;navi</span><br><span class="line">$ cd &#x2F;opt&#x2F;navi</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你使用源码进行编译，你需要先安装好命令行模糊查找工具 <code>fzf</code>。 有关 <code>fzf</code> 的具体安装方法，你可以参考其官方网址：<a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">https://github.com/junegunn/fzf</a> 。</p></blockquote><h2 id="使用-navi">使用 Navi</h2><p><code>navi</code> 使用也是很简单的，你只需直接输入 <code>navi</code> 命令并回车后，即可进入交互界面进行命令查找。</p><p><img src="https://www.hi-linux.com/img/linux/navi2.jpeg" alt=""></p><p>默认情况下，选中的命令会直接执行。如果你只想将选中的命令输入到命令行上，你可以加上 <code>--print</code> 选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi --print</span><br></pre></td></tr></table></figure><p>你也可以在 <code>navi</code> 命令后直接加入 <code>query</code> 子命令来预先过滤要输出的命令结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi query &lt;cmd&gt;</span><br></pre></td></tr></table></figure><p>如果你想查找一些命令的常用语法，你也可以使用 <code>search</code> 子命令来从在线仓库中下载对应的备忘清单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi search &lt;cmd&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义备忘录">自定义备忘录</h3><p><code>navi</code> 所使用的备忘清单都是以 <code>.cheat</code> 为后缀的一些文件，<code>navi</code> 安装完后，默认包括了以下这些备忘清单。</p><p><img src="https://i.loli.net/2019/10/21/Kl1J8tBA75wbnjq.png" alt=""></p><p><code>navi</code> 之所以如此受欢迎，主要原因是它支持强大的自定义功能，而且自定义注释还支持中文哟。</p><p>要实现此功能，我们可以用 <code>--dir</code> 参数将自己定义的备忘录 ( <code>.cheat</code> 文件) 传递给 <code>navi</code> 使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi --dir &quot;&#x2F;folder&#x2F;with&#x2F;cheats&quot;</span><br></pre></td></tr></table></figure><p>如果你觉得每次都通过 <code>--dir</code> 参数过于麻烦，你也可以通过环境变量来进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export NAVI_PATH&#x3D;&quot;&#x2F;folder&#x2F;with&#x2F;cheats:&#x2F;another&#x2F;folder&quot;</span><br></pre></td></tr></table></figure><p>介绍完了如何使用自定义的备忘清单后，接下来我们看看如何自已写一个备忘清单。</p><h4 id="cheat-文件语法">.cheat 文件语法</h4><p>我们先来看一个官方给出的 <code>.cheat</code> 文件的示例内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% git, code</span><br><span class="line"></span><br><span class="line"># Change branch</span><br><span class="line">git checkout &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">$ branch: git branch | awk &#39;&#123;print $NF&#125;&#39;</span><br></pre></td></tr></table></figure><p><code>.cheat</code> 文件语法主要有以下几个注意点。</p><ul><li><p>以「<code>%</code>」开头的行定义了该文件包含的特定的标签</p></li><li><p>以「<code>#</code>」开头的行描述了该命令的作用和用法</p></li><li><p>以「<code>$</code>」开头的行定义了给定参数的可选值</p></li><li><p>其它所有的非空行都被视为可执行命令，命令中的变量以 <code>&lt;&gt;</code> 表示</p></li></ul><p>最后我们来看一个实例，我们常用到的 <code>ffmpeg</code> 处理视频的命令通常都太长，这里我们就定义一个 <code>ffmpeg.cheat</code> 文件来管理这些日常常用的命令。</p><p><img src="https://www.hi-linux.com/img/linux/navi4.gif" alt=""></p><p>从上图可以看到，我们在完成 <code>ffmpeg</code> 命令备忘清单的定义后。日常使用中再也不用输入长长的命令，只需要选中对应命令后，再输入自定义参数就可完成所有操作。这样以来，是不是大大提升了工作效率呢!</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="https://url.cn/5pyiQLg" target="_blank" rel="noopener">https://url.cn/5pyiQLg</a></li><li><a href="https://url.cn/5EE2Ejc" target="_blank" rel="noopener">https://url.cn/5EE2Ejc</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，无论对于运维,还是开发来说，命令行工具都是非常高效的一种管理方式。但有一个很常见的现象就是，很多命令行语句比较复杂，用过一段时间后就忘记了。当然，这时我们可以通过网络搜索或者使用命令的 &lt;code&gt;-—help&lt;/code&gt; 选项来快速找到答案。虽然这种常用的方法能解决问题，但是使用起来相对还是显得不那么快速高效。&lt;/p&gt;
&lt;p&gt;之前，我们在「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487743&amp;amp;idx=1&amp;amp;sn=e726fa2c2b8fa0e56e5653c9aba08732&amp;amp;chksm=eac531d6ddb2b8c06c599a1290a1fb4dd22d53855d88294a8a8b443be74a0279fdcaf912eb67&amp;amp;token=1334996765&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何快速的回忆起遗忘的 Linux 命令&lt;/a&gt;」 一文中介绍了如何利用 &lt;code&gt;Apropos&lt;/code&gt; 命令来快速查找相应的 &lt;code&gt;Linux&lt;/code&gt; 命令。今天，我们再给大家推荐另一款神器 &lt;code&gt;navi&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;navi&lt;/code&gt; 是一位来自巴西的小哥哥 &lt;code&gt;Denis Isidoro&lt;/code&gt; 在 &lt;code&gt;GitHub&lt;/code&gt; 上开源的一个的工具 ，目前已经获得超过 4200 星。&lt;code&gt;navi&lt;/code&gt; 可以在命令行里给你提供了一个很方便使用的交互式的备忘录，能够帮助你在命令行里快速查阅、调用各种复杂难记的命令行语句。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/denisidoro/navi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/denisidoro/navi&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;俗话说得好，不看广告看疗效。废话不多说，先看看下面的演示效果图吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/navi1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从演示中，我们可能看到使用了 &lt;code&gt;navi&lt;/code&gt; 后，只需要键入一个单词，备忘录中的相关命令以及命令用法注释都会实时显示在下方供你直接选择使用，这时我们只需找到想要的命令后即可直接运行相关命令。是不是觉得很神奇和强大呢！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>分享一个快速获取 Nginx 客户端公网 IP 的神技</title>
    <link href="https://www.hi-linux.com/posts/4701.html"/>
    <id>https://www.hi-linux.com/posts/4701.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-11T04:51:39.272Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将给大家介绍一个 <code>Nginx</code> 的小技巧，可以在不使用任何编程语言的情况下，直接返回客户端公网 <code>IP</code> 地址。</p><p>实现方法非常的简单，你只要在 <code>Nginx</code> 中配置以下内容就可以解决问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;ip &#123;</span><br><span class="line">    default_type text&#x2F;plain;</span><br><span class="line">    return 200 $remote_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>curl</code> 命令测试一下，我们从响应结果可以看到只显示了客户端的 <code>IP</code> 地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl https:&#x2F;&#x2F;example.com&#x2F;ip</span><br><span class="line">2001:1b48:103::189</span><br></pre></td></tr></table></figure><blockquote><p><code>default_type text/plain</code> 指令除了阻止 <code>Web</code> 浏览器尝试将响应下载为文件外，并没有使用任何实用程序。即，<code>Web</code> 浏览器可以直接显示 <code>IP</code> 地址。</p></blockquote><a id="more"></a><p>如果你想将以上结果以 <code>JSON</code> 格式输出，只需做一点小修改即可实现。具体方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;json_ip &#123;</span><br><span class="line">    default_type application&#x2F;json;</span><br><span class="line">    return 200 &quot;&#123;\&quot;ip\&quot;:\&quot;$remote_addr\&quot;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，响应的就是一个漂亮的 <code>JSON</code> 格式的输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s https:&#x2F;&#x2F;example.com&#x2F;json_ip | jq</span><br><span class="line">&#123;</span><br><span class="line">    &quot;ip&quot;: &quot;2001:1b48:103::189&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，快速通过 <code>Nginx</code> 获取客户端公网 <code>IP</code> 地址的小技巧就演示完了。希望这个 <code>Nginx</code> 的小技巧可以为你节省一些维护时间。</p><blockquote><p>本文翻译至：<a href="https://url.cn/5Th0D1e%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82" target="_blank" rel="noopener">https://url.cn/5Th0D1e，版权归原作者所有。</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将给大家介绍一个 &lt;code&gt;Nginx&lt;/code&gt; 的小技巧，可以在不使用任何编程语言的情况下，直接返回客户端公网 &lt;code&gt;IP&lt;/code&gt; 地址。&lt;/p&gt;
&lt;p&gt;实现方法非常的简单，你只要在 &lt;code&gt;Nginx&lt;/code&gt; 中配置以下内容就可以解决问题。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;location &amp;#x2F;ip &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default_type text&amp;#x2F;plain;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 200 $remote_addr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用 &lt;code&gt;curl&lt;/code&gt; 命令测试一下，我们从响应结果可以看到只显示了客户端的 &lt;code&gt;IP&lt;/code&gt; 地址。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ curl https:&amp;#x2F;&amp;#x2F;example.com&amp;#x2F;ip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2001:1b48:103::189&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;default_type text/plain&lt;/code&gt; 指令除了阻止 &lt;code&gt;Web&lt;/code&gt; 浏览器尝试将响应下载为文件外，并没有使用任何实用程序。即，&lt;code&gt;Web&lt;/code&gt; 浏览器可以直接显示 &lt;code&gt;IP&lt;/code&gt; 地址。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="https://www.hi-linux.com/categories/nginx/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款史上最强跨平台、多端加密同步神器 Restic</title>
    <link href="https://www.hi-linux.com/posts/42308.html"/>
    <id>https://www.hi-linux.com/posts/42308.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-11T04:51:39.273Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-restic">什么是 Restic</h2><p><code>Restic</code> 是一款 GO 语言开发的开源免费且快速、高效和安全的跨平台备份工具。<code>Restic</code> 使用加密技术来保证你的数据安全性和完整性，可以将本地数据加密后传输到指定的存储。</p><p><code>Restic</code> 同样支持增量备份，可随时备份和恢复备份。<code>Restic</code> 支持大多数主流操作系统，比如：<code>Linux</code>、<code>macOS</code>、<code>Windows</code> 以及一些较小众的操作系统 <code>FreeBSD</code> 和 <code>OpenBSD</code> 等。</p><blockquote><p>项目地址：<a href="https://github.com/restic/restic" target="_blank" rel="noopener">https://github.com/restic/restic</a></p></blockquote><p><strong>Restic 支持的存储类型</strong></p><p><code>Restic</code> 支持的存储种类比较多，大致有如下这些类型：</p><ul><li><p>本地存储</p></li><li><p>SFTP</p></li><li><p>REST Server</p></li><li><p>Amazon S3</p></li><li><p>Minio Server</p></li><li><p>OpenStack Swift</p></li><li><p>Backblaze B2</p></li><li><p>Microsoft Azure Blob Storage</p></li><li><p>Google Cloud Storage</p></li><li><p>通过 Rclone 挂载的存储 (比如：Google Drive、OneDrive 等)</p></li></ul><p><strong>Restic 与 Rclone 的区别</strong></p><p><code>Restic</code> 与 <code>Rclone</code> 都是开源的命令行文件备份（同步）工具，但却有着很本质的区别。</p><ol><li>两者的相同点</li></ol><ul><li><p>两者都是基于命令行的开源文件同步和备份工具。</p></li><li><p>两者都支持将文件备份到本地、远程服务器或对象存储。</p></li></ul><ol start="2"><li>两者不同点</li></ol><ul><li><p>Rclone 面向的是文件同步，即保证两端文件的一致，也可以增量备份。</p></li><li><p>Restic 面向的是文件备份和加密，文件先加密再传输备份，而且是增量备份，即每次只备份变化的部分。</p></li><li><p>Rclone 仓库配置保存在本地，备份的文件会保持原样的同步于存储仓库中。</p></li><li><p>Restic 配置信息直接写在仓库，只要有仓库密码，在任何安装了 Restic 的计算机上都可以操作仓库。</p></li><li><p>Rclone 不记录文件版本，无法根据某一次备份找回特定时间点上的文件。</p></li><li><p>Restic 每次备份都会生成一个快照，记录当前时间点的文件结构，可以找回特定时间点的文件。</p></li><li><p>Rclone 可以在配置的多个存储端之间传输文件。</p></li></ul><p>总的来说，<code>Rclone</code> 和 <code>Restic</code> 各有所长，要根据不同的业务需求选择使用。比如：网站数据的增量备份，用 <code>Resitc</code> 就比较合适。而常规文件的远程备份归档，用 <code>Rclone</code> 就很合适。</p><a id="more"></a><h2 id="安装-restic">安装 Restic</h2><p><code>Restic</code> 可以通过系统软件包安装，也可以直接下载最新的二进制包方式进行安装。</p><ol><li>通过软件包安装</li></ol><ul><li>Debian &amp; Ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install restic</span><br></pre></td></tr></table></figure><ul><li>RHEL &amp; CentOS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install yum-plugin-copr</span><br><span class="line">$ yum copr enable copart&#x2F;restic</span><br><span class="line">$ yum install restic</span><br></pre></td></tr></table></figure><ul><li>Fedora</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dnf install restic</span><br></pre></td></tr></table></figure><ul><li>Arch Linux</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pacman -S restic</span><br></pre></td></tr></table></figure><ul><li>macOS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install restic</span><br></pre></td></tr></table></figure><p>更多平台的软件包安装方法可参见官方文档：<a href="https://restic.readthedocs.io/en/stable/020_installation.html" target="_blank" rel="noopener">https://restic.readthedocs.io/en/stable/020_installation.html</a></p><ol start="2"><li>通过二进制版本安装</li></ol><p>通过预编译好的二进制版本进行安装，非常的简单。只要根据自己所需的平台选择对应的版本下载即可，这里以 <code>Linux</code> 系统为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 下载指定版本的安装包</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;restic&#x2F;restic&#x2F;releases&#x2F;download&#x2F;v0.9.5&#x2F;restic_0.9.5_linux_amd64.bz2</span><br><span class="line"></span><br><span class="line"># 解压并删除压缩包</span><br><span class="line">$ bzip2 -d restic*.bz2 &amp;&amp; rm -rf restic*.bz2</span><br><span class="line"></span><br><span class="line"># 增加执行权限</span><br><span class="line">$ chmod +x restic*</span><br><span class="line"></span><br><span class="line"># 移动二进制文件到指定目录</span><br><span class="line">$ mv restic* &#x2F;usr&#x2F;local&#x2F;bin&#x2F;restic</span><br><span class="line"></span><br><span class="line"># 验证所安装的版本</span><br><span class="line">$ restic version</span><br></pre></td></tr></table></figure><p>如果以后需要更新到最新版本，只需运行以下命令就可完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接升级二进制文件到最新版本</span><br><span class="line">$ restic self-update</span><br></pre></td></tr></table></figure><ol start="3"><li>Restic 常用语法命令</li></ol><p><code>Restic</code> 支持的命令和参数比较多，你可以使用 <code>--help</code> 参数来查看它们的基本用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">$ restic --help</span><br><span class="line">restic is a backup program which allows saving multiple revisions of files and</span><br><span class="line">directories in an encrypted repository stored on different backends.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  restic [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  backup        Create a new backup of files and&#x2F;or directories</span><br><span class="line">  cache         Operate on local cache directories</span><br><span class="line">  cat           Print internal objects to stdout</span><br><span class="line">  check         Check the repository for errors</span><br><span class="line">  diff          Show differences between two snapshots</span><br><span class="line">  dump          Print a backed-up file to stdout</span><br><span class="line">  find          Find a file or directory</span><br><span class="line">  forget        Remove snapshots from the repository</span><br><span class="line">  generate      Generate manual pages and auto-completion files (bash, zsh)</span><br><span class="line">  help          Help about any command</span><br><span class="line">  init          Initialize a new repository</span><br><span class="line">  key           Manage keys (passwords)</span><br><span class="line">  list          List objects in the repository</span><br><span class="line">  ls            List files in a snapshot</span><br><span class="line">  migrate       Apply migrations</span><br><span class="line">  mount         Mount the repository</span><br><span class="line">  prune         Remove unneeded data from the repository</span><br><span class="line">  rebuild-index Build a new index file</span><br><span class="line">  restore       Extract the data from a snapshot</span><br><span class="line">  snapshots     List all snapshots</span><br><span class="line">  stats         Count up sizes and show information about repository data</span><br><span class="line">  tag           Modify tags on snapshots</span><br><span class="line">  unlock        Remove locks other processes created</span><br><span class="line">  version       Print version information</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --cacert file              file to load root certificates from (default: use system certificates)</span><br><span class="line">      --cache-dir string         set the cache directory. (default: use system default cache directory)</span><br><span class="line">      --cleanup-cache            auto remove old cache directories</span><br><span class="line">  -h, --help                     help for restic</span><br><span class="line">      --json                     set output mode to JSON for commands that support it</span><br><span class="line">      --key-hint string          key ID of key to try decrypting first (default: $RESTIC_KEY_HINT)</span><br><span class="line">      --limit-download int       limits downloads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --limit-upload int         limits uploads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --no-cache                 do not use a local cache</span><br><span class="line">      --no-lock                  do not lock the repo, this allows some operations on read-only repos</span><br><span class="line">  -o, --option key&#x3D;value         set extended option (key&#x3D;value, can be specified multiple times)</span><br><span class="line">  -p, --password-file string     read the repository password from a file (default: $RESTIC_PASSWORD_FILE)</span><br><span class="line">  -q, --quiet                    do not output comprehensive progress report</span><br><span class="line">  -r, --repo string              repository to backup to or restore from (default: $RESTIC_REPOSITORY)</span><br><span class="line">      --tls-client-cert string   path to a file containing PEM encoded TLS client certificate and private key</span><br><span class="line">  -v, --verbose n[&#x3D;-1]           be verbose (specify --verbose multiple times or level n)</span><br><span class="line"></span><br><span class="line">Use &quot;restic [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><p>与 <code>Git</code> 等程序类似 <code>Restic</code> 有许多子命令，每个子命令都有自己的命令行选项。如果你要列出每个子命令的帮助选项，可以使用类似下面的命令语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 以备份子命令为例</span><br><span class="line">$ restic backup --help</span><br><span class="line">The &quot;backup&quot; command creates a new snapshot and saves the files and directories</span><br><span class="line">given as the arguments.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  restic backup [flags] FILE&#x2F;DIR [FILE&#x2F;DIR] ...</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -e, --exclude pattern                  exclude a pattern (can be specified multiple times)</span><br><span class="line">      --exclude-caches                   excludes cache directories that are marked with a CACHEDIR.TAG file. See http:&#x2F;&#x2F;bford.info&#x2F;cachedir&#x2F;spec.html for the Cache Directory Tagging Standard</span><br><span class="line">      --exclude-file file                read exclude patterns from a file (can be specified multiple times)</span><br><span class="line">      --exclude-if-present stringArray   takes filename[:header], exclude contents of directories containing filename (except filename itself) if header of that file is as provided (can be specified multiple times)</span><br><span class="line">      --files-from string                read the files to backup from file (can be combined with file args&#x2F;can be specified multiple times)</span><br><span class="line">  -f, --force                            force re-reading the target files&#x2F;directories (overrides the &quot;parent&quot; flag)</span><br><span class="line">  -h, --help                             help for backup</span><br><span class="line">      --hostname hostname                set the hostname for the snapshot manually. To prevent an expensive rescan use the &quot;parent&quot; flag</span><br><span class="line">  -x, --one-file-system                  exclude other file systems</span><br><span class="line">      --parent string                    use this parent snapshot (default: last snapshot in the repo that has the same target files&#x2F;directories)</span><br><span class="line">      --stdin                            read backup from stdin</span><br><span class="line">      --stdin-filename string            file name to use when reading from stdin (default &quot;stdin&quot;)</span><br><span class="line">      --tag tag                          add a tag for the new snapshot (can be specified multiple times)</span><br><span class="line">      --time string                      time of the backup (ex. &#39;2012-11-01 22:08:41&#39;) (default: now)</span><br><span class="line">      --with-atime                       store the atime for all files and directories</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">      --cacert file              file to load root certificates from (default: use system certificates)</span><br><span class="line">      --cache-dir string         set the cache directory. (default: use system default cache directory)</span><br><span class="line">      --cleanup-cache            auto remove old cache directories</span><br><span class="line">      --json                     set output mode to JSON for commands that support it</span><br><span class="line">      --key-hint string          key ID of key to try decrypting first (default: $RESTIC_KEY_HINT)</span><br><span class="line">      --limit-download int       limits downloads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --limit-upload int         limits uploads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --no-cache                 do not use a local cache</span><br><span class="line">      --no-lock                  do not lock the repo, this allows some operations on read-only repos</span><br><span class="line">  -o, --option key&#x3D;value         set extended option (key&#x3D;value, can be specified multiple times)</span><br><span class="line">  -p, --password-file string     read the repository password from a file (default: $RESTIC_PASSWORD_FILE)</span><br><span class="line">  -q, --quiet                    do not output comprehensive progress report</span><br><span class="line">  -r, --repo string              repository to backup to or restore from (default: $RESTIC_REPOSITORY)</span><br><span class="line">      --tls-client-cert string   path to a file containing PEM encoded TLS client certificate and private key</span><br><span class="line">  -v, --verbose n[&#x3D;-1]           be verbose (specify --verbose multiple times or level n)</span><br></pre></td></tr></table></figure><h2 id="配置-restic-支持的存储方式">配置 Restic 支持的存储方式</h2><p>安装好 <code>Restic</code> 后，我们需要配置下存储方式。也就是你想备份数据到本地，还是其它远程服务上。</p><p>本文将主要讲讲最常用的本地、SFTP 两种备份方式，其它远程库配置方法可参考官方文档：<a href="https://restic.readthedocs.io/en/stable/030_preparing_a_new_repo.html" target="_blank" rel="noopener">https://restic.readthedocs.io/en/stable/030_preparing_a_new_repo.html</a> 。</p><ol><li>配置本地存储仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 备份到本地 &#x2F;home&#x2F;mike&#x2F;backup 文件夹</span><br><span class="line">$ restic init --repo &#x2F;home&#x2F;mike&#x2F;backup</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 SFTP 方式的存储仓库</li></ol><p>该方法适合将文件备份到另一台服务器上。首先，我们需要在两台服务器间配置免密码登录。</p><blockquote><p>注意：以下将需要备份的服务器称为 A，备份服务器称为 B。</p></blockquote><p>2.1 配置 SSH 免密码登录</p><p>这部分内容比较基础，就不在这里展开了。如果你不会配置可以参考以下两篇文章：</p><ul><li><p>「CentOS 下配置 SSH 免密码登录」：<a href="https://zhuanlan.zhihu.com/p/45025702" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45025702</a></p></li><li><p>「SSH 和 ssh-copy-id 以及批量多机无密码登陆详解」: <a href="https://www.cnblogs.com/operationhome/p/9166583.html" target="_blank" rel="noopener">https://www.cnblogs.com/operationhome/p/9166583.html</a></p></li></ul><p>2.2 在服务器 A 上进行数据备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># root 为服务器 B 的用户名，192.168.1.100 为 B 服务器 IP，端口默认为 22，&#x2F;home&#x2F;mike&#x2F;backup 为服务器 B 上的目录，如果不存在则会自动创建。</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup init</span><br></pre></td></tr></table></figure><p>如果服务器 B 的 <code>SSH</code> 默认端口不是 22，你就需要简单调整下 A 服务器上的 <code>SSH</code> 配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在服务器 A 中 ~&#x2F;.ssh 目录创建一个 config 文件，并新增如下内容。</span><br><span class="line"># 分别是 B 服务器的 IP、用户名和 SSH 的端口。</span><br><span class="line">$ vim ~&#x2F;.ssh&#x2F;config</span><br><span class="line">Host 192.168.1.100</span><br><span class="line">    User root</span><br><span class="line">    Port 2000</span><br></pre></td></tr></table></figure><p>由于上面配置了默认的 B 服务器的用户名和密码，现在就可以直接只写 B 服务器的 IP 就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup init</span><br></pre></td></tr></table></figure><blockquote><p>注意：以上配置过程中都会要求你输入密码，切记不要遗忘。</p></blockquote><h2 id="使用-restic-备份数据">使用 Restic 备份数据</h2><p>经过上面的步骤，我们已经完成了备份存储的初始化。现在我就来看几个 <code>Restic</code> 备份的例子。</p><p>以下我们所有演示的例子均是将 A 服务器上 <code>/var/www/</code> 目录下的文件备份到 B 服务器上的 <code>/home/mike/backup</code> 目录下。</p><h3 id="创建备份快照">创建备份快照</h3><p>以下命令是备份的 <code>/var/www</code> 整个目录，如果只需备份目录中单个文件，比如：<code>/var/www/mike.zip</code>，那备份内容就可以改成 <code>/var/www/mike.zip</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 本地备份</span><br><span class="line">$ restic -r &#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www</span><br><span class="line"></span><br><span class="line"># SFTP 备份</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www</span><br></pre></td></tr></table></figure><p>如果你不想备份目录下全部的内容，你还可以用以下参数排除或包含指定的备份目录或者文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--include 指定一次或多次以包含一个或者多个目录或文件</span><br><span class="line">--exclude 指定一次或多次以排除一个或多个目录或文件</span><br><span class="line">--exclude-caches 指定一次以排除包含特殊文件的目录</span><br><span class="line">--exclude-file 指定一次或多次以排除给定文件中列出的项目</span><br><span class="line">--exclude-if-present 如果目录内容包含给定文件，则指定一次或多次排除目录的内容</span><br></pre></td></tr></table></figure><p>具体用法可以参考官方文档: <a href="https://restic.readthedocs.io/en/stable/040_backup.html#including-and-excluding-files" target="_blank" rel="noopener">https://restic.readthedocs.io/en/stable/040_backup.html#including-and-excluding-files</a></p><p><code>Restic</code> 还支持直接将命令的输出进行重定向，比如：将备份好的数据库文件直接通过 <code>SFTP</code> 方式备份到另一台服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将 Wordpress 数据库备份到另一台服务器，并命名为 Wordpress_Backup.sql</span><br><span class="line">$ mysqldump -uroot -ppasswd 000000 --databases Wordpress | restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup backup --stdin --stdin-filename Wordpress_Backup.sql</span><br></pre></td></tr></table></figure><h3 id="列出备份快照">列出备份快照</h3><p>备份完成后，可以使用以下命令查看备份的快照信息。您可以看到我们在第一次备份期间的快照 ID，拍摄快照的时间戳，主机名，标签以及备份的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有备份快照</span><br><span class="line"></span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup snapshots</span><br><span class="line">ID        Time                 Host        Tags              Paths</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">ef5ff5fe  2019-08-25 17:03:57  Mike-Dev01                          &#x2F;home&#x2F;mike&#x2F;backup</span><br><span class="line">9f0bc19e  2019-08-26 17:18:57  Mike-Dev02                          &#x2F;home&#x2F;devops&#x2F;backup</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 只查看 &#x2F;home&#x2F;mike&#x2F;backup 目录的备份快照</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup snapshots --path&#x3D;&quot;&#x2F;home&#x2F;mike&#x2F;backup&quot;</span><br><span class="line">ID        Time                 Host        Tags              Paths</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">ef5ff5fe  2019-08-25 17:03:57  Mike-Dev01                          &#x2F;home&#x2F;mike&#x2F;backup</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 只查看主机名为 Mike-Dev01 的备份快照</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup snapshots --host Mike-Dev01</span><br><span class="line">ID        Time                 Host        Tags              Paths</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">ef5ff5fe  2019-08-25 17:03:57  Mike-Dev01                          &#x2F;home&#x2F;mike&#x2F;backup</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 列出某个快照中所包含的文件</span><br><span class="line">$ restic ls ef5ff5fe</span><br><span class="line">snapshot ef5ff5fe of [&#x2F;home&#x2F;mike&#x2F;backup] at 2019-08-25 20:35:39.450146467 +0800 CST):</span><br><span class="line">&#x2F;backup</span><br><span class="line">&#x2F;backup&#x2F;2019-04-19_2004334933.jpg</span><br><span class="line">&#x2F;backup&#x2F;2019-04-13_15-00-15.png</span><br><span class="line">&#x2F;backup&#x2F;2019-04-16_15-19-39.png</span><br><span class="line">&#x2F;backup&#x2F;2019-04-16_15-20-22.png</span><br><span class="line">&#x2F;backup&#x2F;2019-04-18_17-11-52.png</span><br></pre></td></tr></table></figure><p>从上面的结果，我们可以看到 <code>Tags</code> 列是空的。这是因为备份时没有使用 <code>--tag</code> 参数，下面我们演示下 <code>--tag</code> 参数的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 给备份文件指定标签</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www --tag site</span><br></pre></td></tr></table></figure><p>如果你想加入更多标签来更详细的区分备份，那就在后面多加几个 <code>--tag</code> 参数。</p><h3 id="恢复备份快照">恢复备份快照</h3><p>这里以 <code>SFTP</code> 存储仓库为例，我们将远程存储目录 <code>/home/mike/backup</code> 的备份文件恢复到本地 <code>/var/wwww</code> 文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># restore 后面指定为要恢复备份的 ID</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup restore ef5ff5fe --target &#x2F;var&#x2F;wwww</span><br><span class="line"></span><br><span class="line"># 你也可以直接使用 latest 来恢复最后一次的备份文件</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup restore latest --target &#x2F;var&#x2F;wwww</span><br></pre></td></tr></table></figure><h3 id="删除备份快照">删除备份快照</h3><p>如果你不在再要一些备份快照，你可以直接使用下面的命令删除指定的备份快照。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ef5ff5fe 为要删除文件的 ID</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup forget ef5ff5fe</span><br></pre></td></tr></table></figure><p>不过上面的命令只是将快照记录清除了，但快照中包含的文件数据仍存储在存储库中。如果要彻底清除未引用的数据，你必须运行 <code>prune</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup prune</span><br><span class="line">enter password for repository:</span><br><span class="line"></span><br><span class="line">counting files in repo</span><br><span class="line">building new index for repo</span><br><span class="line">[0:00] 100.00%  22 &#x2F; 22 files</span><br><span class="line">repository contains 22 packs (8512 blobs) with 100.092 MiB bytes</span><br><span class="line">processed 8512 blobs: 0 duplicate blobs, 0B duplicate</span><br><span class="line">load all snapshots</span><br><span class="line">find data that is still in use for 1 snapshots</span><br><span class="line">[0:00] 100.00%  1 &#x2F; 1 snapshots</span><br><span class="line">found 8433 of 8512 data blobs still in use</span><br><span class="line">will rewrite 3 packs</span><br><span class="line">creating new index</span><br><span class="line">[0:00] 86.36%  19 &#x2F; 22 files</span><br><span class="line">saved new index as 544a5084</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>清理完成后，存储库的空间就会释放出来。当然你也可以直接使用 <code>--prune</code> 参数来将上面两步合成为一步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ef5ff5fe 为要删除文件的 ID</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup forget ef5ff5fe --prune</span><br></pre></td></tr></table></figure><h2 id="使用-restic-进行自动备份">使用 Restic 进行自动备份</h2><ol><li>免密码操作存储仓库</li></ol><p>上面的备份中我们都手工输入了密码，如果需要定期备份当然是通过一个脚本来实现是最方便，但是在使用脚本备份时如果要显示输入访问存储仓库的密码肯定不适用的。这里我们就需要使用 <code>--password-file</code> 参数来达到自动读取密码的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将密码保存在 &#x2F;home&#x2F;mike&#x2F;resticpasswd 文本中</span><br><span class="line">$ echo &#39;000000&#39; &gt; &#x2F;home&#x2F;mike&#x2F;resticpasswd</span><br><span class="line"></span><br><span class="line"># 在备份命令中使用 --password-file 参数来读取文本中的密码</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www --password-file &#x2F;home&#x2F;mike&#x2F;resticpasswd</span><br></pre></td></tr></table></figure><p>除了使用 <code>--password-file</code> 参数指定密码外，你也可以使用环境变量来指定一些 <code>Restic</code> 所需的参数。例如，使用腾讯云的对象存储就可以使用下面这些环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export TencentCloud_ACCESS_KEY_ID&#x3D;&quot;your-access-key&quot;</span><br><span class="line">export TencentCloud_SECRET_ACCESS_KEY&#x3D;&quot;your-secret-key&quot;</span><br><span class="line">export RESTIC_REPOSITORY&#x3D;&quot;s3:server-url&#x2F;bucket-name&quot;</span><br><span class="line">export RESTIC_PASSWORD&#x3D;&quot;a-strong-password&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>结合 Cron 完成自动备份</li></ol><p><code>Restic</code> 中的 <code>forget</code> 命令可以帮助你来维护快照的运行存档。你可以使用 <code>restic forget --prune</code> 来设置每小时、每日、每周等保留的备份数量，任何不符合策略的备份都将从存储库中清除。</p><p>这里我们将使用 <code>Cron</code> 系统服务每 30 分钟运行一次备份任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br><span class="line">30 * * * * &#x2F;usr&#x2F;local&#x2F;bin&#x2F;restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup backup --password-file &#x2F;home&#x2F;mike&#x2F;resticpasswd -q &#x2F;var&#x2F;www; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;restic forget -q --prune --keep-hourly 24 --keep-daily 7</span><br></pre></td></tr></table></figure><p>上面的计划任务里，其中 <code>30 * * * *</code> 定义了 Cron 中任务运行的时间，这里定义为每隔 30 分钟运行。<code>--keep-hourly 24 --keep-daily 7</code> 定义了根据指定的保留标志并删除不再需要的旧快照，在这里我们是将 24 小时内的快照保留 7 天。</p><p>更多策略可参考官方文档：<a href="https://restic.readthedocs.io/en/latest/060_forget.html#removing-snapshots-according-to-a-policy" target="_blank" rel="noopener">https://restic.readthedocs.io/en/latest/060_forget.html#removing-snapshots-according-to-a-policy</a></p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://restic.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://restic.readthedocs.io/en/latest/</a></p></li><li><p><a href="https://www.moerats.com/archives/897/" target="_blank" rel="noopener">https://www.moerats.com/archives/897/</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1160729" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1160729</a></p></li><li><p><a href="https://it.ismy.fun/2018/04/22/restic-backup-to-aliyun-oss/" target="_blank" rel="noopener">https://it.ismy.fun/2018/04/22/restic-backup-to-aliyun-oss/</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/66324926" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66324926</a></p></li><li><p><a href="https://www.elasticfeed.com/e8590b1297e81b6e7ab19c66be4f037d/" target="_blank" rel="noopener">https://www.elasticfeed.com/e8590b1297e81b6e7ab19c66be4f037d/</a></p></li><li><p><a href="https://www.vmvps.com/restic-a-new-opensource-backup-free-tool-to-backup-your-vps-files.html" target="_blank" rel="noopener">https://www.vmvps.com/restic-a-new-opensource-backup-free-tool-to-backup-your-vps-files.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Restic&quot;&gt;什么是 Restic&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 是一款 GO 语言开发的开源免费且快速、高效和安全的跨平台备份工具。&lt;code&gt;Restic&lt;/code&gt; 使用加密技术来保证你的数据安全性和完整性，可以将本地数据加密后传输到指定的存储。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 同样支持增量备份，可随时备份和恢复备份。&lt;code&gt;Restic&lt;/code&gt; 支持大多数主流操作系统，比如：&lt;code&gt;Linux&lt;/code&gt;、&lt;code&gt;macOS&lt;/code&gt;、&lt;code&gt;Windows&lt;/code&gt; 以及一些较小众的操作系统 &lt;code&gt;FreeBSD&lt;/code&gt; 和 &lt;code&gt;OpenBSD&lt;/code&gt; 等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/restic/restic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/restic/restic&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Restic 支持的存储类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 支持的存储种类比较多，大致有如下这些类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SFTP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST Server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Amazon S3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Minio Server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenStack Swift&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Backblaze B2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Microsoft Azure Blob Storage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Google Cloud Storage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 Rclone 挂载的存储 (比如：Google Drive、OneDrive 等)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Restic 与 Rclone 的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 与 &lt;code&gt;Rclone&lt;/code&gt; 都是开源的命令行文件备份（同步）工具，但却有着很本质的区别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两者的相同点&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两者都是基于命令行的开源文件同步和备份工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两者都支持将文件备份到本地、远程服务器或对象存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;两者不同点&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Rclone 面向的是文件同步，即保证两端文件的一致，也可以增量备份。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restic 面向的是文件备份和加密，文件先加密再传输备份，而且是增量备份，即每次只备份变化的部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rclone 仓库配置保存在本地，备份的文件会保持原样的同步于存储仓库中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restic 配置信息直接写在仓库，只要有仓库密码，在任何安装了 Restic 的计算机上都可以操作仓库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rclone 不记录文件版本，无法根据某一次备份找回特定时间点上的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restic 每次备份都会生成一个快照，记录当前时间点的文件结构，可以找回特定时间点的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rclone 可以在配置的多个存储端之间传输文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总的来说，&lt;code&gt;Rclone&lt;/code&gt; 和 &lt;code&gt;Restic&lt;/code&gt; 各有所长，要根据不同的业务需求选择使用。比如：网站数据的增量备份，用 &lt;code&gt;Resitc&lt;/code&gt; 就比较合适。而常规文件的远程备份归档，用 &lt;code&gt;Rclone&lt;/code&gt; 就很合适。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Restic" scheme="https://www.hi-linux.com/tags/Restic/"/>
    
  </entry>
  
  <entry>
    <title>分享几个无需 Docker 环境拉取容器镜像的神器</title>
    <link href="https://www.hi-linux.com/posts/46425.html"/>
    <id>https://www.hi-linux.com/posts/46425.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T03:23:02.446Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>你是否曾经遇到过需要在没有安装任何 <code>Docker</code> 客户端的机器上拉取容器镜像这样变态的需求呢？如果有,你当时又是如何解决的呢？今天我们就来给大家介绍几种另辟蹊径的方法来实现这样的需求。</p><h2 id="使用-docker-drag-实现">使用 docker-drag 实现</h2><p>根据官网介绍：<code>docker-drag</code> 是一个用于与 <code>Docker Hub</code> 交互的工具，并且不需 <code>Docker</code> 客户端本身支持。它主要是通过与 <code>Docker Hub</code> 的 <code>HTTPS API</code> 进行交互来实现相应功能。</p><blockquote><p>项目地址：<a href="https://github.com/NotGlop/docker-drag" target="_blank" rel="noopener">https://github.com/NotGlop/docker-drag</a></p></blockquote><h3 id="安装-docker-drag">安装 docker-drag</h3><p><code>docker-drag</code> 其实就是一个 <code>Python</code> 脚本，目前版本总共才 168 行代码。你只需要去官网仓库直接下载就可以使用了，非常的简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;NotGlop&#x2F;docker-drag&#x2F;master&#x2F;docker_pull.py</span><br></pre></td></tr></table></figure><h3 id="使用-docker-drag">使用 docker-drag</h3><p>我们先来看一下官方给出的演示效果。</p><p><img src="https://user-images.githubusercontent.com/26483750/63388733-b419f480-c3a9-11e9-8617-7c5b47b76dbd.gif" alt=""></p><p><code>docker-drag</code> 的使用也是非常简单的，基本上和 <code>docke pull</code> 命令使用方法一致。其主要是借助 <code>Python</code> 的 <code>Request</code> 库和 <code>HTTPS API</code> 直接从仓库中拉取镜像，并保存为 <code>TAR</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在官方仓库拉取官方镜像</span></span><br><span class="line">$ python docker_pull.py nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接在官方仓库拉取三方镜像</span></span><br><span class="line">$ python docker_pull.py mysql/mysql-server:8.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接在三方仓库拉取镜像</span></span><br><span class="line">$ python docker_pull.py mcr.microsoft.com/windows/nanoserver@sha256:ae443bd9609b9ef06d21d6caab59505cb78f24a725cc24716d4427e36aedabf2</span><br></pre></td></tr></table></figure><p>镜像下载完成后，你可以直接使用 <code>docker load -i</code> 命令对 <code>TAR</code> 文件进行加载。由于不在依赖容器工具本身，在一些实际使用场景中，例如：CICD 流程。这个小工具或许能助你解决大问题哟！</p><a id="more"></a><h2 id="使用-download-frozen-image-v2-实现">使用 download-frozen-image-v2 实现</h2><p>与 <code>docker-drag</code> 类似的工具，还有一个 <code>SHELL</code> 脚本的实现 <code>download-frozen-image-v2</code>，该脚本隶属于 <code>Moby</code> 项目。</p><blockquote><p>项目地址：<a href="https://github.com/moby/moby" target="_blank" rel="noopener">https://github.com/moby/moby</a></p></blockquote><p>它的使用基本上和 <code>docker-drag</code> 类似，大致有如以下几步所示。</p><ol><li>下载对应的脚本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://raw.githubusercontent.com/moby/moby/master/contrib/download-frozen-image-v2.sh</span><br></pre></td></tr></table></figure><ol start="2"><li>download-frozen-image-v2 脚本使用语法</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">download-frozen-image-v2.sh target_dir image[:tag][@digest] ...</span><br></pre></td></tr></table></figure><ol start="3"><li>一个完整的使用实例</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 Ubuntu 容器镜像</span></span><br><span class="line">$ bash download-frozen-image-v2.sh ubuntu ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># download-frozen-image-v2 这里要稍为复杂点，需要自己手动打成 TAR 包</span></span><br><span class="line">$ tar -C <span class="string">'ubuntu'</span> -cf <span class="string">'ubuntu.tar'</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入容器镜像</span></span><br><span class="line">$ docker load -i ubuntu.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入容器镜像完成后，运一个容器</span></span><br><span class="line">$ docker run --rm -ti ubuntu bash</span><br><span class="line">root@1dd5e62113b9:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="使用-dp-实现">使用 dp 实现</h2><p><code>dp</code> 同样也是一个实现上述类似需求的小工具。<code>dp</code> 使用 <code>Go</code> 语言开发，天生具有良好的跨平台性。相对于前两个工具来说更容易在多平台上部署使用，而且 <code>dp</code> 还支持将多个镜像打包在一起。</p><blockquote><p>项目地址：<a href="https://github.com/zhangguanzhang/dp/" target="_blank" rel="noopener">https://github.com/zhangguanzhang/dp/</a></p></blockquote><h3 id="安装-dp">安装 dp</h3><p><code>dp</code> 的安装非常简单，只需在官方仓库 <code>Releases</code> 页面直接下载各平台对应的版本，解压后即可使用。</p><h3 id="使用-dp">使用 dp</h3><p><code>dp</code> 使用起来也是很容易的，下面我们就来看几个实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从官方仓库拉取一个容器镜像</span></span><br><span class="line">$ dp pull nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从官方仓库拉取一个容器镜像并打包到压缩文件</span></span><br><span class="line">$ dp pull -o nginx.tar.gz nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 sha256 拉取一个容器镜像</span></span><br><span class="line">$ dp pull mcr.microsoft.com/windows/nanoserver@sha256:ae443bd9609b9ef06d21d6caab59505cb78f24a725cc24716d4427e36aedabf2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次从官方仓库拉取多个容器镜像并打包到压缩文件</span></span><br><span class="line">$ dp pull -o project.tar.gz nginx:alpine nginx:1.17.5-alpine-perl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从三方镜像仓库拉取多个容器镜像并打包到压缩文件</span></span><br><span class="line">$ dp pull -o project.tar.gz nginx:alpine gcr.io/google_containers/pause-amd64:3.1</span><br></pre></td></tr></table></figure><p>至此，我们就演示完了如何在不需要 <code>Docker</code> 客户端的前提下拉取容器镜像的方法。如果你还有更多更好的方法，欢迎大家积极留言哟！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://xbuba.com/questions/37905763" target="_blank" rel="noopener">https://xbuba.com/questions/37905763</a></p></li><li><p><a href="https://blog.fleeto.us/post/pull-image-without-docker/" target="_blank" rel="noopener">https://blog.fleeto.us/post/pull-image-without-docker/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否曾经遇到过需要在没有安装任何 &lt;code&gt;Docker&lt;/code&gt; 客户端的机器上拉取容器镜像这样变态的需求呢？如果有,你当时又是如何解决的呢？今天我们就来给大家介绍几种另辟蹊径的方法来实现这样的需求。&lt;/p&gt;
&lt;h2 id=&quot;使用-docker-drag-实现&quot;&gt;使用 docker-drag 实现&lt;/h2&gt;
&lt;p&gt;根据官网介绍：&lt;code&gt;docker-drag&lt;/code&gt; 是一个用于与 &lt;code&gt;Docker Hub&lt;/code&gt; 交互的工具，并且不需 &lt;code&gt;Docker&lt;/code&gt; 客户端本身支持。它主要是通过与 &lt;code&gt;Docker Hub&lt;/code&gt; 的 &lt;code&gt;HTTPS API&lt;/code&gt; 进行交互来实现相应功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/NotGlop/docker-drag&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/NotGlop/docker-drag&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装-docker-drag&quot;&gt;安装 docker-drag&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker-drag&lt;/code&gt; 其实就是一个 &lt;code&gt;Python&lt;/code&gt; 脚本，目前版本总共才 168 行代码。你只需要去官网仓库直接下载就可以使用了，非常的简单。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ wget https:&amp;#x2F;&amp;#x2F;raw.githubusercontent.com&amp;#x2F;NotGlop&amp;#x2F;docker-drag&amp;#x2F;master&amp;#x2F;docker_pull.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用-docker-drag&quot;&gt;使用 docker-drag&lt;/h3&gt;
&lt;p&gt;我们先来看一下官方给出的演示效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26483750/63388733-b419f480-c3a9-11e9-8617-7c5b47b76dbd.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker-drag&lt;/code&gt; 的使用也是非常简单的，基本上和 &lt;code&gt;docke pull&lt;/code&gt; 命令使用方法一致。其主要是借助 &lt;code&gt;Python&lt;/code&gt; 的 &lt;code&gt;Request&lt;/code&gt; 库和 &lt;code&gt;HTTPS API&lt;/code&gt; 直接从仓库中拉取镜像，并保存为 &lt;code&gt;TAR&lt;/code&gt; 文件。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 直接在官方仓库拉取官方镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ python docker_pull.py nginx:alpine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 直接在官方仓库拉取三方镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ python docker_pull.py mysql/mysql-server:8.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 直接在三方仓库拉取镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ python docker_pull.py mcr.microsoft.com/windows/nanoserver@sha256:ae443bd9609b9ef06d21d6caab59505cb78f24a725cc24716d4427e36aedabf2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;镜像下载完成后，你可以直接使用 &lt;code&gt;docker load -i&lt;/code&gt; 命令对 &lt;code&gt;TAR&lt;/code&gt; 文件进行加载。由于不在依赖容器工具本身，在一些实际使用场景中，例如：CICD 流程。这个小工具或许能助你解决大问题哟！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>分享一个超实用的 Web 版 SSH 工具 Sshwifty</title>
    <link href="https://www.hi-linux.com/posts/2389.html"/>
    <id>https://www.hi-linux.com/posts/2389.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T03:23:02.448Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>无论你是一名开发或者运维，相信都对 <code>SSH</code> 这个工具都不陌生。不管是开发需要访问服务器处理程序错误还是运维访问服务器处理服务异常，我们都需要通过 <code>SSH</code> 协议来远程连接到服务器。</p><p>通常我们使用 <code>SSH</code> 协议访问服务器基本都是使用 <code>SSH</code> 客户端软件，比如：<code>Xshell</code>、<code>Putty</code>、<code>SecureCRT</code>、<code>iTerm 2</code> 等。这些客户端软件虽然使用上都比较方便，但在有些场景下，我们需要在没有安装 <code>SSH</code> 客户端的环境下访问远程服务器。这时我们应该怎么办呢，当然是有办法解决的，那就是通过 <code>WebSSH</code> 这种方法来进行访问。</p><blockquote><p><code>WebSSH</code> 泛指一种可以在网页上实现一个 <code>SSH</code> 终端的技术。从而无需任何 <code>SSH</code> 客户端工具就可进行 <code>SSH</code> 连接，将 <code>SSH</code> 从 <code>C/S</code> 架构转变成了 <code>B/S</code> 架构。</p></blockquote><p>目前，可以实现 <code>WebSSH</code> 的软件有很多，比如：<code>GateOne</code>、<code>Shellinabox</code>、<code>WSSH</code>、<code>Xterm.js</code> 等，而我们今天要介绍的是一款更为强大的 <code>WebSSH</code> 软件 <code>Sshwifty</code>。<code>Sshwifty</code> 使用 <code>Go</code>、<code>Vuejs</code> 和 <code>xtermjs</code> 进行开发，几乎实现了目前所有  <code>WebSSH</code> 软件的功能。</p><blockquote><p>项目地址：<a href="https://github.com/niruix/sshwifty" target="_blank" rel="noopener">https://github.com/niruix/sshwifty</a></p></blockquote><p><img src="https://github.com/niruix/sshwifty/raw/master/Screenshot.png" alt=""></p><a id="more"></a><h2 id="安装-sshwifty">安装 Sshwifty</h2><ol><li>通过二进制包安装</li></ol><p>由于  <code>Sshwifty</code> 采用 <code>Go</code> 语言开发，良好的原生跨平台支持。安装起来非常简单，基本开箱即用。这里以 <code>Linux</code> 平台为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 下载并解压 Sshwifty 安装包</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;niruix&#x2F;sshwifty&#x2F;releases&#x2F;download&#x2F;0.1.0-beta-release-prebuild&#x2F;sshwifty_0.1.0-beta-release_linux_amd64.tar.gz</span><br><span class="line">$ tar -xzvf sshwifty_0.1.0-beta-release_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 复制可执行文件到指定目录并赋予执行权限</span><br><span class="line">$ cp sshwifty_linux_amd64 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;sshwifty</span><br><span class="line">$ chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;sshwifty</span><br><span class="line"></span><br><span class="line"># 生成默认配置文件</span><br><span class="line">$ cp sshwifty.conf.example.json &#x2F;etc&#x2F;sshwifty.conf.json</span><br><span class="line"></span><br><span class="line"># 启动 Sshwifty</span><br><span class="line">$ sshwifty</span><br></pre></td></tr></table></figure><blockquote><p>使用默认配置文件会在 <code>127.0.0.1</code> 的 <code>8182</code> 端口启动 <code>Sshwifty</code> 服务，你可以根据自行需要更改。</p></blockquote><p>更多平台的二进制安装包，可自行在官方项目地址的 <a href="https://github.com/niruix/sshwifty/releases" target="_blank" rel="noopener">Releases</a> 页面进行下载。</p><ol start="2"><li>通过 Docker 安装</li></ol><p>如果你会一点 <code>Docker</code> 的话，强烈建议使用 <code>Docker</code> 进行部署安装。通过 <code>Docker</code> 安装仅需要一条指令就可以搞定，比二进制包安装更加的简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --detach \</span><br><span class="line">  --restart&#x3D;always \</span><br><span class="line">  --publish 8182:8182 \</span><br><span class="line">  --name sshwifty \</span><br><span class="line">  niruix&#x2F;sshwifty:latest</span><br></pre></td></tr></table></figure><p>如果你想给 <code>Sshwifty</code> 部署一个 <code>HTTPS</code> 证书，可以使用以下的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --detach \</span><br><span class="line">  --restart&#x3D;always \</span><br><span class="line">  --publish 8182:8182 \</span><br><span class="line">  --env SSHWIFTY_DOCKER_TLSCERT&#x3D;&quot;$(cat &#x2F;path&#x2F;to&#x2F;domain.crt)&quot;</span><br><span class="line">  --env SSHWIFTY_DOCKER_TLSCERTKEY&#x3D;&quot;$(cat &#x2F;path&#x2F;to&#x2F;domain.key)&quot;</span><br><span class="line">  --name sshwifty \</span><br><span class="line">  niruix&#x2F;sshwifty:latest</span><br></pre></td></tr></table></figure><blockquote><p><code>/path/to/domain.crt</code> 和 <code>/path/to/domain.key</code> 是用来指定本地 <code>HTTPS</code> 证书和密钥文件所在的位置。</p></blockquote><h2 id="使用-sshwifty">使用 Sshwifty</h2><p><code>Sshwifty</code> 部署好后，直接用浏览器访问相应地址即可使用。首次访问时，会要求输入一个认证口令。</p><p><img src="https://i.loli.net/2019/09/16/DiOCrIVw6mPYEnu.png" alt=""></p><blockquote><p>默认口令为：<code>WEB_ACCESS_PASSWORD</code>，如需修改可变更配置文件中的 <code>&quot;SharedKey&quot;: &quot;WEB_ACCESS_PASSWORD&quot;</code> 配置项。</p></blockquote><p>认证完成后，成功登陆 <code>Sshwifty</code>。</p><p><img src="https://i.loli.net/2019/09/16/Uj5ClXMmyA3wLTF.png" alt=""></p><p>点击左上角 <code>+</code> 号图标后，就可新建一个访问远程服务器 <code>SSH</code> 或 <code>Telnet</code> 的连接。</p><p><img src="https://i.loli.net/2019/09/16/SgXJMa2ECVxDBfA.png" alt=""></p><p>如果你觉得自已部署还是太麻烦，也可以直接使用官方提供的演示地址进行体验哟！</p><blockquote><p>官方演示地址：<a href="https://sshwifty.herokuapp.com/" target="_blank" rel="noopener">https://sshwifty.herokuapp.com/</a></p></blockquote><p>你在这里不仅可以体验 <code>Sshwifty</code> 的强大功能，还可以在这里观看有趣的星球大战 <code>Telnet</code> 版哟！</p><p><img src="https://i.loli.net/2019/09/16/E4VAHQi9Mm8FTJw.png" alt=""></p><p>至此，<code>Sshwifty</code> 的基本使用就已经介绍完成了。如果你对它很有兴趣，可以自行去官网进行探索哟！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://github.com/niruix/sshwifty" target="_blank" rel="noopener">https://github.com/niruix/sshwifty</a></p></li><li><p><a href="https://www.cnblogs.com/franknihao/p/8963634.html" target="_blank" rel="noopener">https://www.cnblogs.com/franknihao/p/8963634.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论你是一名开发或者运维，相信都对 &lt;code&gt;SSH&lt;/code&gt; 这个工具都不陌生。不管是开发需要访问服务器处理程序错误还是运维访问服务器处理服务异常，我们都需要通过 &lt;code&gt;SSH&lt;/code&gt; 协议来远程连接到服务器。&lt;/p&gt;
&lt;p&gt;通常我们使用 &lt;code&gt;SSH&lt;/code&gt; 协议访问服务器基本都是使用 &lt;code&gt;SSH&lt;/code&gt; 客户端软件，比如：&lt;code&gt;Xshell&lt;/code&gt;、&lt;code&gt;Putty&lt;/code&gt;、&lt;code&gt;SecureCRT&lt;/code&gt;、&lt;code&gt;iTerm 2&lt;/code&gt; 等。这些客户端软件虽然使用上都比较方便，但在有些场景下，我们需要在没有安装 &lt;code&gt;SSH&lt;/code&gt; 客户端的环境下访问远程服务器。这时我们应该怎么办呢，当然是有办法解决的，那就是通过 &lt;code&gt;WebSSH&lt;/code&gt; 这种方法来进行访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;WebSSH&lt;/code&gt; 泛指一种可以在网页上实现一个 &lt;code&gt;SSH&lt;/code&gt; 终端的技术。从而无需任何 &lt;code&gt;SSH&lt;/code&gt; 客户端工具就可进行 &lt;code&gt;SSH&lt;/code&gt; 连接，将 &lt;code&gt;SSH&lt;/code&gt; 从 &lt;code&gt;C/S&lt;/code&gt; 架构转变成了 &lt;code&gt;B/S&lt;/code&gt; 架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前，可以实现 &lt;code&gt;WebSSH&lt;/code&gt; 的软件有很多，比如：&lt;code&gt;GateOne&lt;/code&gt;、&lt;code&gt;Shellinabox&lt;/code&gt;、&lt;code&gt;WSSH&lt;/code&gt;、&lt;code&gt;Xterm.js&lt;/code&gt; 等，而我们今天要介绍的是一款更为强大的 &lt;code&gt;WebSSH&lt;/code&gt; 软件 &lt;code&gt;Sshwifty&lt;/code&gt;。&lt;code&gt;Sshwifty&lt;/code&gt; 使用 &lt;code&gt;Go&lt;/code&gt;、&lt;code&gt;Vuejs&lt;/code&gt; 和 &lt;code&gt;xtermjs&lt;/code&gt; 进行开发，几乎实现了目前所有  &lt;code&gt;WebSSH&lt;/code&gt; 软件的功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/niruix/sshwifty&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/niruix/sshwifty&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/niruix/sshwifty/raw/master/Screenshot.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="https://www.hi-linux.com/categories/SSH/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="SSH" scheme="https://www.hi-linux.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>推荐一个比 Postman 更好用的接口测试神器 Postwoman</title>
    <link href="https://www.hi-linux.com/posts/31368.html"/>
    <id>https://www.hi-linux.com/posts/31368.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T03:23:02.449Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>对于经常进行接口调试的同学来说，应该是比较熟悉 <code>Postman</code> 了。<code>Postman</code> 虽然功能强大，但也有很多弊端。比如：不支持 <code>Web</code> 方式，需要安装客户端软件等。如果你只想简单地测试下接口返回，就需要安装一个客户端工具就显得比较麻烦了。</p><p>为了解决这个痛点，今天就给大家推荐一个轻量级、功能强大且颜值超高的神器 <code>Postwoman</code>。<code>Postwoman</code> 是一个 <code>HTTP API</code> 测试工具，支持 <code>REST</code>、<code>SOAP</code> 和 <code>GraphQL</code> 请求，并且可以实现自动化接口测试、接口监控、模拟接口数据、生成接口文档、多人协作等功能。简单来说，<code>Postwoman</code> 是一个好用且功能非常强大的 <code>API</code> 调试工具。</p><h2 id="什么是-postwoman">什么是 Postwoman</h2><p><code>Postwoman</code> 是一个基于 <code>Vue</code> 开发的的 <code>Web</code> 项目，功能类似 <code>Poatman</code> 的免费且美观的开源替代方案，它可以帮助开发人员更快地创建请求，提升工作效率。目前，该项目在 <code>Github</code> 上的 <code>Star</code> 数已经超过 10k 了！</p><blockquote><p>项目地址：<a href="https://github.com/liyasthomas/postwoman" target="_blank" rel="noopener">https://github.com/liyasthomas/postwoman</a></p></blockquote><p><img src="https://raw.githubusercontent.com/liyasthomas/postwoman/master/static/images/screenshot1.png" alt=""></p><h2 id="postwoman-功能介绍">Postwoman 功能介绍</h2><ol><li>Postwoman 相关特性</li></ol><ul><li><p>采用简约的 UI 设计，简单的设计是最好的设计</p></li><li><p>响应速度更快，软件使用更轻量、更简洁</p></li><li><p>实时发送请求并获取/复制响应</p></li></ul><ol start="2"><li>Postwoman 支持的方法</li></ol><ul><li><p>GET</p></li><li><p>HEAD</p></li><li><p>POST</p></li><li><p>PUT</p></li><li><p>DELETE</p></li><li><p>OPTIONS</p></li><li><p>PATCH</p></li></ul><ol start="3"><li>Postwoman 支持界面定制</li></ol><ul><li><p>支持主题选择：Kinda Dark（默认）、Clearly White、Just Black 和 System 主题</p></li><li><p>支持自定义强调颜色：绿色（默认）、黄色、粉红色、红色、紫色、橙色、青色和蓝色</p></li></ul><ol start="4"><li>其它支持的特性</li></ol><ul><li><p>支持以 <code>PWA</code> 方式进行安装</p></li><li><p>支持离线使用</p></li><li><p>内存和 <code>CPU</code> 使用率非常低</p></li><li><p>支持多平台、多设备</p></li><li><p>支持 <code>WebSocket</code></p></li><li><p>支持 <code>GraphQL</code></p></li><li><p>支持多种 <code>HTTP</code> 认证方式</p></li><li><p>…</p></li></ul><p>除此之外，<code>Postwoman</code> 还具备很多好用的特性，完整功能列表介绍可以戳「<a href="https://github.com/liyasthomas/postwoman" target="_blank" rel="noopener">这里</a>」。</p><a id="more"></a><h2 id="使用-postwoman">使用 Postwoman</h2><p><img src="https://github.com/liyasthomas/postwoman/blob/master/static/images/screenshot2.png" alt=""></p><p><code>Postwoman</code> 既然是一个 <code>Web</code> 项目，使用起来也就非常简单，你只需直接访问其官网地址即可直接使用。</p><blockquote><p>官网地址：<a href="https://postwoman.io/" target="_blank" rel="noopener">https://postwoman.io/</a></p></blockquote><p>如果你想在本地自行搭建也是可以的，大致过程如下：</p><ul><li>使用源代码进行搭建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/liyasthomas/postwoman.git</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><ul><li>使用 Docker 进行搭建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取 Postwoman 相关镜像</span></span><br><span class="line">$ docker pull liyasthomas/postwoman</span><br><span class="line"><span class="comment"># 运行一个 Postwoman 的容器</span></span><br><span class="line">$ docker run -p 3000:3000 liyasthomas/postwoman:latest</span><br></pre></td></tr></table></figure><p>不论使用以下哪种方法搭建，搭建成功后，你只需打开浏览器访问对应主机 <code>IP</code> 的 <code>3000</code> 端口即可访问本地的 <code>Postwoman</code> 环境。</p><h2 id="更多的界面截图">更多的界面截图</h2><p><img src="https://i.loli.net/2019/11/29/L9RsVMEhzUdYbPS.png" alt=""></p><p><img src="https://i.loli.net/2019/11/29/DmWaUkgT7uK5rif.png" alt=""></p><p><img src="https://i.loli.net/2019/11/29/z61X8EbiQRDFhAH.png" alt=""></p><p><img src="https://i.loli.net/2019/11/29/mkYbxGTMgesJh1B.png" alt=""></p><h2 id="总结">总结</h2><p>如果你觉得 <code>Postman</code> 不够好用或者确实是想要使用一个界面更加好看的接口调试工具，那么 <code>Postwoman</code> 将是你最佳的选择！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://github.com/liyasthomas/postwoman" target="_blank" rel="noopener">https://github.com/liyasthomas/postwoman</a></p></li><li><p><a href="https://juejin.im/post/5dca85cb6fb9a04a8953fef6" target="_blank" rel="noopener">https://juejin.im/post/5dca85cb6fb9a04a8953fef6</a></p></li><li><p><a href="http://www.xmhzd.com/study/article/view-607.html" target="_blank" rel="noopener">http://www.xmhzd.com/study/article/view-607.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于经常进行接口调试的同学来说，应该是比较熟悉 &lt;code&gt;Postman&lt;/code&gt; 了。&lt;code&gt;Postman&lt;/code&gt; 虽然功能强大，但也有很多弊端。比如：不支持 &lt;code&gt;Web&lt;/code&gt; 方式，需要安装客户端软件等。如果你只想简单地测试下接口返回，就需要安装一个客户端工具就显得比较麻烦了。&lt;/p&gt;
&lt;p&gt;为了解决这个痛点，今天就给大家推荐一个轻量级、功能强大且颜值超高的神器 &lt;code&gt;Postwoman&lt;/code&gt;。&lt;code&gt;Postwoman&lt;/code&gt; 是一个 &lt;code&gt;HTTP API&lt;/code&gt; 测试工具，支持 &lt;code&gt;REST&lt;/code&gt;、&lt;code&gt;SOAP&lt;/code&gt; 和 &lt;code&gt;GraphQL&lt;/code&gt; 请求，并且可以实现自动化接口测试、接口监控、模拟接口数据、生成接口文档、多人协作等功能。简单来说，&lt;code&gt;Postwoman&lt;/code&gt; 是一个好用且功能非常强大的 &lt;code&gt;API&lt;/code&gt; 调试工具。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Postwoman&quot;&gt;什么是 Postwoman&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Postwoman&lt;/code&gt; 是一个基于 &lt;code&gt;Vue&lt;/code&gt; 开发的的 &lt;code&gt;Web&lt;/code&gt; 项目，功能类似 &lt;code&gt;Poatman&lt;/code&gt; 的免费且美观的开源替代方案，它可以帮助开发人员更快地创建请求，提升工作效率。目前，该项目在 &lt;code&gt;Github&lt;/code&gt; 上的 &lt;code&gt;Star&lt;/code&gt; 数已经超过 10k 了！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/liyasthomas/postwoman&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/liyasthomas/postwoman&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liyasthomas/postwoman/master/static/images/screenshot1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Postwoman-功能介绍&quot;&gt;Postwoman 功能介绍&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Postwoman 相关特性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;采用简约的 UI 设计，简单的设计是最好的设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应速度更快，软件使用更轻量、更简洁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实时发送请求并获取/复制响应&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Postwoman 支持的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HEAD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PUT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DELETE&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OPTIONS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PATCH&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Postwoman 支持界面定制&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;支持主题选择：Kinda Dark（默认）、Clearly White、Just Black 和 System 主题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持自定义强调颜色：绿色（默认）、黄色、粉红色、红色、紫色、橙色、青色和蓝色&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;其它支持的特性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;支持以 &lt;code&gt;PWA&lt;/code&gt; 方式进行安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持离线使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存和 &lt;code&gt;CPU&lt;/code&gt; 使用率非常低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持多平台、多设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 &lt;code&gt;WebSocket&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 &lt;code&gt;GraphQL&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持多种 &lt;code&gt;HTTP&lt;/code&gt; 认证方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，&lt;code&gt;Postwoman&lt;/code&gt; 还具备很多好用的特性，完整功能列表介绍可以戳「&lt;a href=&quot;https://github.com/liyasthomas/postwoman&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>巧用 Cowrie 部署 SSH 蜜罐，让黑客攻击无处遁形</title>
    <link href="https://www.hi-linux.com/posts/6021.html"/>
    <id>https://www.hi-linux.com/posts/6021.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T05:08:04.782Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是蜜罐">什么是蜜罐</h2><p>蜜罐其实就是一台无人使用但却被严密监控的网络主机，里面包含着各类虚假的高价值资源和一些已知漏洞，以此吸引入侵者来入侵该主机。并且在被入侵的过程中，实时记录和审计入侵者的所有入侵攻击流量、行为和数据。以此了解入侵者的攻击方式、手段和目的，便于后期快速完成对其的溯源和取证工作。</p><p><strong>蜜罐的一些主要构成模块</strong></p><ol><li>按实现逻辑划分</li></ol><ul><li><p>控制：将入侵者牢牢控制在指定的网络范围中，使其不能再以此机器作为跳板来攻击其它的机器。</p></li><li><p>捕获：把入侵者在入侵过程中所产生的各种流量捕获住。</p></li><li><p>分析：将捕获到的各种数据存到数据库或者其它指定地方，便于后续还原其详细的入侵攻击过程。</p></li></ul><ol start="2"><li>按具体实现过程划分</li></ol><ul><li><p>监控各种主机项，如：进程、文件、注册表、网络等。</p></li><li><p>同时提交给入侵检测，以识别其更详细的入侵手段，并对整个入侵过程做详细记录。</p></li><li><p>入侵数据汇总分析，其实就是把上述两步所得到的各种数据进行集中分析，最后勾勒出完整的入侵轨迹画像。</p></li></ul><ol start="3"><li>最容易理解的说法</li></ol><ul><li><p>蜜罐环境隔离: 使用虚拟环境将物理环境和蜜罐隔绝开，防止某些敏感操作在其真实的系统环境中进行造成破坏。</p></li><li><p>敏感操作记录：把蜜罐中所有的入侵操作都写进数据库。</p></li><li><p>邮件报警系统：蜜罐被入侵后自动发送报警邮件通知相关安全应急人员。</p></li></ul><a id="more"></a><h2 id="蜜罐的分类">蜜罐的分类</h2><p><strong>1. 低交互蜜罐</strong></p><p>低交互蜜罐最大的特点是：蜜罐为攻击者展示的所有攻击弱点和攻击对象都不是真正的产品系统，而是对各种系统及其提供的服务的模拟。由于它的服务都是模拟的行为，所以蜜罐可以获得的信息非常有限，只能对攻击者进行简单的应答。不过，它也是最安全的蜜罐类型。</p><p><strong>2. 中交互蜜罐</strong></p><p>中交互蜜罐是对真正的操作系统的各种行为的模拟，它提供了更多的交互信息，同时也可以从攻击者的行为中获得更多的信息。在这个模拟行为的系统中，蜜罐此时看起来和一个真正的操作系统没有区别，它们甚至是比真正系统还诱人的攻击目标。</p><p><strong>3. 高交互蜜罐</strong></p><p>高交互蜜罐具有一个真实的操作系统，它的优点体现在对攻击者提供完全真实的系统。当攻击者获得 ROOT 权限后，受系统、数据真实性的迷惑，他的更多活动和行为将被记录下来。缺点是被入侵的可能性很高，如果整个高交互蜜罐被入侵，那么它就会成为攻击者下一步攻击的跳板，不太安全。</p><h2 id="什么是-cowrie">什么是 Cowrie</h2><p><code>Cowrie</code> 是一个具有中等交互的 <code>SSH</code> 蜜罐，它可以获取攻击者用于暴力破解的字典、输入的命令以及上传或下载的恶意文件。所有这些攻击记录都会被记载到日志中，以便日后分析。</p><blockquote><p>项目地址：<a href="https://github.com/cowrie/cowrie" target="_blank" rel="noopener">https://github.com/cowrie/cowrie</a></p></blockquote><p><img src="http://image.3001.net/images/20160816/14713421328918.png" alt=""></p><h2 id="cowrie-安装部署">Cowrie 安装部署</h2><h3 id="使用源码部署">使用源码部署</h3><p>本次搭建使用的基础环境是 <code>Ubuntu</code> ，以下步骤除切换到虚拟环境中的操作，其它均为 root 权限执行。</p><h4 id="安装必要的支持软件">安装必要的支持软件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Python 3</span><br><span class="line">$ sudo apt-get install git python-virtualenv libssl-dev libffi-dev build-essential libpython3-dev python3-minimal authbind virtualenv</span><br><span class="line"></span><br><span class="line"># Python 2</span><br><span class="line">$ sudo apt-get install git python-virtualenv libssl-dev libffi-dev build-essential libpython-dev python2.7-minimal authbind</span><br></pre></td></tr></table></figure><h4 id="添加一个普通用户">添加一个普通用户</h4><p>对外提供服务的程序均以普通用户身份运行，能更好的保证服务器安全性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser --disabled-password cowrie</span><br><span class="line">Adding user &#39;cowrie&#39; ...</span><br><span class="line">Adding new group &#39;cowrie&#39; (1002) ...</span><br><span class="line">Adding new user &#39;cowrie&#39; (1002) with group &#39;cowrie&#39; ...</span><br><span class="line">Changing the user information for cowrie</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">Full Name []:</span><br><span class="line">Room Number []:</span><br><span class="line">Work Phone []:</span><br><span class="line">Home Phone []:</span><br><span class="line">Other []:</span><br><span class="line">Is the information correct? [Y&#x2F;n]</span><br><span class="line"></span><br><span class="line">$ sudo su - cowrie</span><br></pre></td></tr></table></figure><h4 id="安装-cowire">安装 Cowire</h4><p>由于 <code>Cowire</code> 是采用 <code>Python</code> 开发，为了方便管理和安全，我们就直接将 <code>Cowire</code> 部署到 <code>Python</code> 的虚拟环境中。</p><ol><li>下载 Cowire</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;cowrie&#x2F;</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;cowrie&#x2F;cowrie.git</span><br></pre></td></tr></table></figure><ol start="2"><li>在 Python 虚拟环境中安装 Cowire</li></ol><ul><li>进入 <code>Cowrie</code> 所在目录，并安装虚拟环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;cowrie&#x2F;cowrie</span><br></pre></td></tr></table></figure><ul><li>使用 Python 3 创建虚拟环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --python&#x3D;python3 cowrie-env</span><br><span class="line">New python executable in .&#x2F;cowrie&#x2F;cowrie-env&#x2F;bin&#x2F;python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure><ul><li>使用 Python 2 创建虚拟环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --python&#x3D;python2 cowrie-env</span><br><span class="line">New python executable in .&#x2F;cowrie&#x2F;cowrie-env&#x2F;bin&#x2F;python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure><ul><li>激活 Cowrie 环境，并安装必要的软件包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ source cowrie-env&#x2F;bin&#x2F;activate</span><br><span class="line">(cowrie-env) $ pip install --upgrade pip</span><br><span class="line">(cowrie-env) $ pip install --upgrade -r requirements.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>创建并修改 Cowire 的配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(cowrie-env) $ cd etc&#x2F;</span><br><span class="line">(cowrie-env) $ cp cowrie.cfg.dist cowrie.cfg</span><br><span class="line">(cowrie-env) $ vi cowrie.cfg</span><br></pre></td></tr></table></figure><ul><li>打开 SSH 服务，并且修改监听端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ssh]</span><br><span class="line"></span><br><span class="line"># Enable SSH support</span><br><span class="line"># (default: true)</span><br><span class="line">enabled &#x3D; true</span><br><span class="line"></span><br><span class="line">listen_endpoints &#x3D; tcp:2222:interface&#x3D;0.0.0.0</span><br></pre></td></tr></table></figure><ul><li>配置日志文件输出</li></ul><p>默认情况下，<code>Cowire</code> 支持将日志输出到多个接收终端中。比如：文件文件、<code>Cucko</code>o、<code>ELK Stack</code>、<code>Graylog</code>、<code>Kippo-Graph</code>、<code>Splunk</code>、<code>SQL</code> (<code>MySQL</code>、<code>SQLite3</code>、<code>RethinkDB</code>) 等等中。这里我们就来说说最常用的文本文件和 <code>MySQL</code> 数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 保存在文本文件中，需要配置以下一些内容。</span><br><span class="line">[output_textlog]</span><br><span class="line">enabled &#x3D; true</span><br><span class="line">logfile &#x3D; $&#123;honeypot:log_path&#125;&#x2F;audit.log</span><br><span class="line">format &#x3D; text</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 保存在数据库中，需要配置以下一些内容。</span><br><span class="line">[output_mysql]</span><br><span class="line">host &#x3D; localhost</span><br><span class="line">database &#x3D; cowrie</span><br><span class="line">username &#x3D; cowrie</span><br><span class="line">password &#x3D; PASSWORD HERE</span><br><span class="line">port &#x3D; 3306</span><br><span class="line">debug &#x3D; false</span><br><span class="line">enabled &#x3D; true</span><br></pre></td></tr></table></figure><p>如果是需要保存在 <code>MySQL</code> 数据库中，当然只配置是不行的，你还得需要有一个对应的数据库。如果你没有，可以按下面的步骤进行安装。</p><ul><li>安装 MySQL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install mysql-server mysql-client libmysqlclient-dev python-mysqldb</span><br></pre></td></tr></table></figure><p>安装成功后，你可以通过下面的命令测试是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure><ul><li>在 Python 虚拟环境中安装 MySQL 依赖包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ source cowrie-env&#x2F;bin&#x2F;activate</span><br><span class="line">$ pip install mysqlclient mysql-python</span><br></pre></td></tr></table></figure><ul><li>创建名为 cowrie 的数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">mysql&gt; create database cowrie;</span><br></pre></td></tr></table></figure><ul><li>创建一个给 Cowrie 访问数据库的用户</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT INSERT, SELECT, UPDATE ON cowrie.* TO &#39;cowrie&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;PASSWORD HERE&#39;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">mysql&gt; exit</span><br></pre></td></tr></table></figure><ul><li>数据库和对应的数据库用户创建完成后，在数据库中导入初始数据的 SQL 语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;cowrie&#x2F;docs&#x2F;sql&#x2F;</span><br><span class="line">$ mysql -u cowrie -p</span><br><span class="line">mysql&gt; USE cowrie;</span><br><span class="line">mysql&gt; source mysql.sql;</span><br><span class="line">mysql&gt; exit</span><br></pre></td></tr></table></figure><ol start="4"><li>在 Python 虚拟环境下启动蜜罐</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(cowrie-env) $ bin&#x2F;cowrie start</span><br><span class="line">Activating virtualenv &quot;cowrie-env&quot;</span><br><span class="line">Starting cowrie with extra arguments [] ...</span><br></pre></td></tr></table></figure><ol start="5"><li>修改 SSH 默认的监听端口</li></ol><p>在 <code>root</code> 用户下将 <code>Ubuntu</code> 自身的 <code>SSH</code> 监听端口进行更改，并修改 <code>Iptables</code> 规则。</p><p>首先，我们验证下是否安装 <code>SSH</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep sshd</span><br><span class="line">root      2720     1  0 Nov 02 ? 00:00:00 &#x2F;usr&#x2F;sbin&#x2F;sshd</span><br></pre></td></tr></table></figure><p>如果输出结果和以上类似就证明已经安装，没有安装的话可以使用以下命令安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>安装完成后，我们可以修改 <code>sshd_config</code> 文件将默认端口改为一个较高的端口，这里为 51268 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"># Port 22</span><br><span class="line">Port 51268</span><br></pre></td></tr></table></figure><blockquote><p>注意：一定不要与 <code>cowrie.cfg</code> 文件中监听的端口一致，否则进入 <code>22</code> 端口的流量就转发到真正的 <code>SSH</code> 服务端口，蜜罐就不起作用了。</p></blockquote><ol start="6"><li>配置 Iptables 进行端口转发</li></ol><p>以上都配置好后，最后就是在 <code>Iptables</code> 中新增一条转发规则，将默认到 <code>22</code> 端口的请求转发到蜜罐中对应的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-port 2222</span><br><span class="line">$ iptables-save</span><br></pre></td></tr></table></figure><p>除了使用 <code>Iptables</code> 外，你还可以在没有 <code>Root</code> 权限的条件下使用 <code>Authbind</code> 或 <code>Setcap</code> 将蜜罐绑定到一些特权端口上，以达到伪装一些正常服务的目的。具体方法可以参见官方文档如下部分：</p><blockquote><ol><li><p><a href="https://cowrie.readthedocs.io/en/latest/INSTALL.html#authbind" target="_blank" rel="noopener">https://cowrie.readthedocs.io/en/latest/INSTALL.html#authbind</a></p></li><li><p><a href="https://cowrie.readthedocs.io/en/latest/INSTALL.html#setcap" target="_blank" rel="noopener">https://cowrie.readthedocs.io/en/latest/INSTALL.html#setcap</a></p></li></ol></blockquote><h3 id="使用-docker-部署">使用 Docker 部署</h3><p>上面讲解的通过源码安装，主要是为了演示 <code>Cowrie</code> 如何工作的，当然最方便的还是直接使用 <code>Docker</code> 部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 2222:2222 cowrie&#x2F;cowrie</span><br><span class="line">$ ssh -p 2222 root@localhost</span><br></pre></td></tr></table></figure><p>如上所示，只需一条指令，<code>Cowrie</code> 就部署完成了。剩下就只需要自己用 <code>Iptables</code> 进行端口转发就可以了。</p><h2 id="cowrie-日志分析">Cowrie 日志分析</h2><p>蜜罐系统的作用主要是用作实时记录和审计入侵者攻击行为和数据，所以最重要的还是事后的日志分析工作。</p><ol><li>如果日志记录在文本文件，你可以使用下面的命令进行一些数据统计分析。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep login &#x2F;home&#x2F;cowrie&#x2F;cowrie&#x2F;var&#x2F;log&#x2F;cowrie&#x2F;audit.log | awk &#39;&#123;print $5&#125;&#39; | sort | uniq -c</span><br></pre></td></tr></table></figure><ol start="2"><li>如果日志记录在数据库，你可以通过下面的一些方式进行一些数据统计分析。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u cowrie -p</span><br><span class="line">mysql&gt; USE cowrie;</span><br><span class="line">mysql&gt; SELECT * FROM auth;</span><br><span class="line">+----+--------------+---------+----------+-------------+---------------------+</span><br><span class="line">| id | session      | success | username | password    | timestamp           |</span><br><span class="line">+----+--------------+---------+----------+-------------+---------------------+</span><br><span class="line">|  1 | a551c0a74e06 |       0 | root     | 12345       | 2019-09-27 23:15:56 |</span><br><span class="line">|  2 | a551c0a74e06 |       0 | root     | seiko2005   | 2019-09-27 23:15:58 |</span><br><span class="line">|  3 | a551c0a74e06 |       0 | root     | anko        | 2019-09-27 23:15:59 |</span><br><span class="line">|  4 | a551c0a74e06 |       0 | root     | 123456      | 2019-09-27 23:16:00 |</span><br><span class="line">|  5 | a551c0a74e06 |       0 | root     | dreambox    | 2019-09-27 23:16:01 |</span><br></pre></td></tr></table></figure><p>当然上面只是举了一些简单的例子，更多高级玩法还等着你去探索哟！</p><h2 id="其它">其它</h2><p>目前开源的蜜罐系统有很多，除了 <code>Cowrie</code> 以外，还有 <code>Kippo</code>、<code>T-Pot</code>、<code>MHN</code>、<code>SSH-Honeypot</code> 等等。如果你对蜜罐系统很感兴趣，可以参考 <code>GitHub</code> 上以下两个开源项目。</p><blockquote><ol><li><p><a href="https://github.com/jwxa2015/honeypotcollection" target="_blank" rel="noopener">https://github.com/jwxa2015/honeypotcollection</a></p></li><li><p><a href="https://github.com/paralax/awesome-honeypots" target="_blank" rel="noopener">https://github.com/paralax/awesome-honeypots</a></p></li></ol></blockquote><p>至此，使用 <code>Cowrie</code> 快速构建一个蜜罐系统的基本方法就介绍完了。如果你对 <code>Cowrie</code> 非常的感兴趣，还可以去官网探索更多高级功能哟！</p><p>对于快速构建一个蜜罐系统，你还有哪些更好用高效的方法呢？欢迎大家在留言讨论哟！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://cowrie.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://cowrie.readthedocs.io/en/latest/</a></p></li><li><p><a href="https://www.cnblogs.com/bmjoker/p/10156220.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/10156220.html</a></p></li><li><p><a href="https://www.cnblogs.com/HacTF/p/8094516.html" target="_blank" rel="noopener">https://www.cnblogs.com/HacTF/p/8094516.html</a></p></li><li><p><a href="https://klionsec.github.io/2017/10/19/cowrie/" target="_blank" rel="noopener">https://klionsec.github.io/2017/10/19/cowrie/</a></p></li><li><p><a href="https://www.twblogs.net/a/5cb0b56bbd9eee48d788646c" target="_blank" rel="noopener">https://www.twblogs.net/a/5cb0b56bbd9eee48d788646c</a></p></li><li><p><a href="https://ama2in9.top/2019/03/12/cowrie/" target="_blank" rel="noopener">https://ama2in9.top/2019/03/12/cowrie/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是蜜罐&quot;&gt;什么是蜜罐&lt;/h2&gt;
&lt;p&gt;蜜罐其实就是一台无人使用但却被严密监控的网络主机，里面包含着各类虚假的高价值资源和一些已知漏洞，以此吸引入侵者来入侵该主机。并且在被入侵的过程中，实时记录和审计入侵者的所有入侵攻击流量、行为和数据。以此了解入侵者的攻击方式、手段和目的，便于后期快速完成对其的溯源和取证工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;蜜罐的一些主要构成模块&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按实现逻辑划分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;控制：将入侵者牢牢控制在指定的网络范围中，使其不能再以此机器作为跳板来攻击其它的机器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;捕获：把入侵者在入侵过程中所产生的各种流量捕获住。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析：将捕获到的各种数据存到数据库或者其它指定地方，便于后续还原其详细的入侵攻击过程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;按具体实现过程划分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;监控各种主机项，如：进程、文件、注册表、网络等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同时提交给入侵检测，以识别其更详细的入侵手段，并对整个入侵过程做详细记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;入侵数据汇总分析，其实就是把上述两步所得到的各种数据进行集中分析，最后勾勒出完整的入侵轨迹画像。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;最容易理解的说法&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;蜜罐环境隔离: 使用虚拟环境将物理环境和蜜罐隔绝开，防止某些敏感操作在其真实的系统环境中进行造成破坏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;敏感操作记录：把蜜罐中所有的入侵操作都写进数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;邮件报警系统：蜜罐被入侵后自动发送报警邮件通知相关安全应急人员。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="https://www.hi-linux.com/categories/SSH/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="SSH" scheme="https://www.hi-linux.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 私有集群负载均衡器终极解决方案 MetalLB ( 贫苦 K8S 用户的 LoadBalancer )</title>
    <link href="https://www.hi-linux.com/posts/34820.html"/>
    <id>https://www.hi-linux.com/posts/34820.html</id>
    <published>2020-05-08T01:00:00.000Z</published>
    <updated>2020-05-08T05:14:23.217Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>私有云裸金属架构（这里是相对云上环境来说，不是说无操作系统）上部署的 Kubernetes 集群，通常是无法使用 LoadBalancer 类型的 Service 的。因为 Kubernetes 本身没有为裸机群集提供网络负载均衡器（类型为 LoadBalancer 的服务）的实现。如果你的 Kubernetes 集群没有在公有云的 IaaS 平台（GCP，AWS，Azure …）上运行，则 LoadBalancers 将在创建时无限期地保持 “挂起” 状态，也就是说只有公有云厂商自家的 Kubernetes 支持 LoadBalancer 。</p><p>为了从外部访问裸机 Kubernetes 群集，目前只能使用 <code>NodePort</code> 或 <code>Ingress</code> 的方法进行服务暴露。前者的缺点是每个暴露的服务需要占用所有节点的某个端口，后者的缺点是仅仅能支持 <code>HTTP</code> 协议。</p><h2 id="什么是-metallb">什么是 MetalLB</h2><p><code>MetalLB</code> 是一个负载均衡器，专门解决裸金属 Kubernetes 集群中无法使用 <code>LoadBalancer</code> 类型服务的痛点。<code>MetalLB</code> 使用标准化的路由协议，以便裸金属 Kubernetes 集群上的外部服务也尽可能地工作。即 MetalLB 能够帮助你在裸金属 Kubernetes 集群中创建 LoadBalancer 类型的 Kubernetes 服务，该项目发布于 2017 年底，当前处于 <code>Beta</code> 阶段。</p><blockquote><p>项目地址：<a href="https://github.com/danderson/metallb" target="_blank" rel="noopener">https://github.com/danderson/metallb</a></p></blockquote><h2 id="metallb-工作原理">MetalLB 工作原理</h2><p>MetalLB 会在 Kubernetes 内运行，监控服务对象的变化，一旦监测到有新的 LoadBalancer 服务运行，并且没有可申请的负载均衡器之后，就会完成地址分配和外部声明两部分的工作。</p><h3 id="地址分配">地址分配</h3><p>在云环境中，当你请求一个负载均衡器时，云平台会自动分配一个负载均衡器的 IP 地址给你，应用程序通过此 IP 来访问经过负载均衡处理的服务。</p><p>使用 MetalLB 时，MetalLB 会自己为用户的 LoadBalancer 类型 Service 分配 IP 地址，当然该 IP 地址不是凭空产生的，需要用户在配置中提供一个 IP 地址池，Metallb 将会在其中选取地址分配给服务。</p><h3 id="外部声明">外部声明</h3><p>MetalLB 将 IP 分配给某个服务后，它需要对外宣告此 IP 地址，并让外部主机可以路由到此 IP。</p><p>MetalLB 支持两种声明模式：Layer 2（ ARP / NDP ）模式或者 BGP 模式。</p><ol><li>Layer 2 模式</li></ol><p><img src="https://kubernetes.github.io/ingress-nginx/images/baremetal/metallb.jpg" alt=""></p><p>在任何以太网环境均可使用该模式。当在第二层工作时，将有一台机器获得 IP 地址（即服务的所有权）。MetalLB 使用标准的地址发现协议（对于 IPv4 是 ARP，对于 IPv6 是 NDP）宣告 IP 地址，使其在本地网路中可达。从 LAN 的角度来看，仅仅是某台机器多配置了一个 IP 地址。</p><p>Layer 2 模式下，每个 Service 会有集群中的一个 Node 来负责。服务的入口流量全部经由单个节点，然后该节点的 Kube-Proxy 会把流量再转发给服务的 Pods。也就是说，该模式下 MetalLB 并没有真正提供负载均衡器。尽管如此，MetalLB 提供了故障转移功能，如果持有 IP 的节点出现故障，则默认 10 秒后即发生故障转移，IP 会被分配给其它健康的节点。</p><p>Layer 2 模式的优缺点：</p><ul><li><p>Layer 2 模式更为通用，不需要用户有额外的设备；</p></li><li><p>Layer 2 模式下存在单点问题，服务的所有入口流量经由单点，其网络带宽可能成为瓶颈；</p></li><li><p>由于 Layer 2 模式需要 ARP/NDP 客户端配合，当故障转移发生时，MetalLB 会发送 ARP 包来宣告 MAC 地址和 IP 映射关系的变化，地址分配略为繁琐。</p></li></ul><ol start="2"><li>BGP 模式</li></ol><p>当在第三层工作时，集群中所有机器都和你控制的最接近的路由器建立 BGP 会话，此会话让路由器能学习到如何转发针对 K8S 服务 IP 的数据包。</p><p>通过使用 BGP，可以实现真正的跨多节点负载均衡（需要路由器支持 multipath），还可以基于 BGP 的策略机制实现细粒度的流量控制。</p><p>具体的负载均衡行为和路由器有关，可保证的共同行为是：每个连接（TCP 或 UDP 会话）的数据包总是路由到同一个节点上。</p><p>BGP 模式的优缺点：</p><ul><li><p>不能优雅处理故障转移，当持有服务的节点宕掉后，所有活动连接的客户端将收到 Connection reset by peer ；</p></li><li><p>BGP 路由器对数据包的源 IP、目的 IP、协议类型进行简单的哈希，并依据哈希值决定发给哪个 K8S 节点。问题是 K8S 节点集是不稳定的，一旦（参与 BGP）的节点宕掉，很大部分的活动连接都会因为 rehash 而坏掉。</p></li></ul><p>BGP 模式问题的缓和措施：</p><ul><li><p>将服务绑定到一部分固定的节点上，降低 rehash 的概率。</p></li><li><p>在流量低的时段改变服务的部署。</p></li><li><p>客户端添加透明重试逻辑，当发现连接 TCP 层错误时自动重试。</p></li></ul><a id="more"></a><h2 id="部署-metallb">部署 MetalLB</h2><h3 id="环境要求">环境要求</h3><p>根据部署模式不同，MetalLB 可能需要以下环境：</p><ol><li><p>一个 Kubernetes 集群，运行 Kubernetes 1.13.0 或更高版本。</p></li><li><p>Kubernetes 集群的网络配置可以与 MetalLB 共存。</p></li><li><p>有一些提供给 MetalLB 分发的 IPv4 地址。</p></li><li><p>根据部署模式，可能需要一个或多个 BGP 的路由器 。</p></li></ol><p>MetalLB 目前支持网络插件范围</p><table><thead><tr><th>网络插件</th><th>兼容性</th></tr></thead><tbody><tr><td>Calico</td><td>部分支持（有附加文档）</td></tr><tr><td>Flannel</td><td>支持</td></tr><tr><td>Kube-router</td><td>不支持</td></tr><tr><td>Romana</td><td>支持（有附加文档）</td></tr><tr><td>Weave Net</td><td>支持</td></tr></tbody></table><blockquote><p>从 Kubernetes 1.9 开始, Kube-Proxy 除了支持默认的 Iptables 模式之外，还支持更高效的 IPVS 模式。MetalLB 可以在Kubenetes 1.13 或更高版本的 Kube-Proxy 中使用 IPVS 模式。但是,它尚未明确测试，因此风险自负。具体内容可参考：<a href="https://github.com/google/metallb/issues/153" target="_blank" rel="noopener">https://github.com/google/metallb/issues/153</a></p></blockquote><h3 id="安装-metallb">安装 MetalLB</h3><p>安装 MetalLB 一共有两种方法：使用 Kubernetes YAML 文件或使用 Helm 包管理器。</p><h4 id="使用-yaml-文件部署">使用 YAML 文件部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 目前 MetalLB 最新版本为 0.8.1</span><br><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;google&#x2F;metallb&#x2F;v0.8.1&#x2F;manifests&#x2F;metallb.yaml</span><br></pre></td></tr></table></figure><p>部署完成后，将在 <code>metallb-system</code> 命名空间下将 MetalLB 部署到集群。YAML 文件中主要包含以下一些组件：</p><ol><li><p><code>metallb-system/controller</code>，这是处理 <code>IP</code> 地址分配的控制器。</p></li><li><p><code>metallb-system/speakerdaemonset</code> 这是支持你选择协议以使服务可达的组件。</p></li><li><p><code>Controller</code> 和 <code>Speaker</code> 的 <code>Service Accounts</code>，以及组件需要运行的 <code>RBAC</code> 权限。</p></li></ol><blockquote><p>通过 YAML 安装文件部署并不包含 MetalLB 配置文件，但 MetalLB 的组件仍能启动，但在你定义和部署 <code>configmap</code> 之前将保持空闲状态 。</p></blockquote><h4 id="使用-helm-部署">使用 Helm 部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm install --name metallb stable&#x2F;metallb</span><br></pre></td></tr></table></figure><p>如果你还不知道什么是 Helm，可以先参考 <a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486154&amp;idx=1&amp;sn=becd5dd0fadfe0b6072f5dfdc6fdf786&amp;chksm=eac52be3ddb2a2f555b8b1028db97aa3e92d0a4880b56f361e4b11cd252771147c44c08c8913&amp;token=1182029777&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「Helm 入门指南」</a> 一文。</p><h2 id="配置-metallb">配置 MetalLB</h2><p>MetalLB 安装完成后，我们还需要根据具体的地址和通告方式配置名为 <code>metallb-system/config</code> 的 ConfigMap。Controller 会读取该 ConfigMap，并重新加载配置。</p><blockquote><p>通过 Helm 安装时，MetalLB 读取的 ConfigMap 名为 metallb-config 。</p></blockquote><h3 id="配置-metallb-为二层模式">配置 MetalLB 为二层模式</h3><p>第二层模式是最简单的配置方式：在许多情况下，您不需要任何特定于协议的配置，只需要 IP 地址。</p><p>第二层模式不要求将 IP 绑定到工作节点的网络接口。它的工作原理是直接响应本地网络上的 ARP 请求，将机器的 MAC 地址提供给客户端。</p><p>下面我们来看一个实际例子，我们将配置一个由 MetalLB 二层模式控制的外部 IP 段为 192.168.1.240 - 192.168.1.250。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat MetalLB-Layer2-Config.yaml</span><br><span class="line"></span><br><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: config</span><br><span class="line">  namespace: metallb-system</span><br><span class="line">data:</span><br><span class="line">  config: |</span><br><span class="line">    address-pools:</span><br><span class="line">    - name: default</span><br><span class="line">      protocol: layer2</span><br><span class="line">      addresses:</span><br><span class="line">      - 192.168.0.10-192.168.0.100</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的 IP 地址范围需要跟集群实际情况相对应。</p></blockquote><p>首先，我们使用 <code>kubectl apply -f MetalLB-Layer2-Config.yaml</code> 命令使配置生效。如果你想看到详细配置更新过程，可以使用以下类似命令查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs -f [metallb-controller-pod]</span><br><span class="line">或者　</span><br><span class="line">$ kubectl logs -l component&#x3D;speaker -n metallb-system</span><br></pre></td></tr></table></figure><p>接下来，我们来创建一个服务类型为 LoadBalancer 的 Nginx 服务来验证下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ cat nginx-test.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps&#x2F;v1beta2</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  type: LoadBalancer</span><br></pre></td></tr></table></figure><p>服务创建完成，运行 <code>kubectl apply -f nginx-test.yaml</code> 命令后，我们可以看到对应服务信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods nginx-68995d8957-bczhf -o wide</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE       </span><br><span class="line">nginx-68995d8957-bczhf   2&#x2F;2     Running   0          19d   10.244.0.78   ubuntu-1  </span><br><span class="line"></span><br><span class="line">$ kubectl get svc</span><br><span class="line">NAME    TYPE           CLUSTER-IP      EXTERNAL-IP    PORT(S)        AGE</span><br><span class="line">nginx   LoadBalancer   10.97.187.100   192.168.0.10   80:32353&#x2F;TCP   179m</span><br></pre></td></tr></table></figure><p>从输出结果，我们可以看到 LoadBalancer 类型的服务，并且分配的外部 IP 地址是地址池中的第一个 IP <code>192.168.0.10</code>。</p><p>最后，我们通过 <code>curl http://192.168.0.10</code> 命令来验证下，发现可以正常显示 Nginx 的欢迎信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;</span><br><span class="line">................</span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>至此，<code>MetalLB Layer 2</code> 模式的配置就结束了。</p><h3 id="配置-metallb-为-bgp-模式">配置 MetalLB 为 BGP 模式</h3><p>对于配置为具有一个 <code>BGP</code> 路由器和一个 IP 地址范围的 BGP 模式，你需要先准备好以下 4 条配置信息：</p><ol><li><p>MetalLB 应连接的路由器 IP 地址。</p></li><li><p>路由器的 AS 号。</p></li><li><p>MetalLB 应该使用的 AS 编号。</p></li><li><p>IP 地址范围，表示为 CIDR 前缀。</p></li></ol><p>由于这种配置方式需要具备 BGP 功能的硬件路由器支持，目前我们环境中不具备此等条件。这里就简单说下 MetalLB 对应的配置方式，具体内容就不展开讲解了。</p><p>由于前面已经安装了 MetalLB 的 <code>Controller</code> 和 <code>Speaker</code>，只是使用的是 Layer 2 模式。这里只需要改为 BGP 模式，我们修改 Configmap 中 Config 配置就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 假如要为 MetalLB 提供范围 192.168.9.0&#x2F;24 和 AS 号 65009，并将其连接到 192.168.0.1 的 AS 号为 65000 的路由器。</span><br><span class="line">$ cat MetalLB-BGP-Config.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  namespace: metallb-system</span><br><span class="line">  name: config</span><br><span class="line">data:</span><br><span class="line">  config: |</span><br><span class="line">    peers:</span><br><span class="line">    - peer-address: 192.168.0.1</span><br><span class="line">      peer-asn: 65000</span><br><span class="line">      my-asn: 65009</span><br><span class="line">    address-pools:</span><br><span class="line">    - name: default</span><br><span class="line">      protocol: bgp</span><br><span class="line">      addresses:</span><br><span class="line">      #- 192.168.0.10-192.168.0.100</span><br><span class="line">      - 192.168.9.0&#x2F;24</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>本文简单介绍了 MetalLB 的用途以及 MetalLB 的两种部署模式：Layer 2 模式和 BGP 模式。在实际应用中，如果条件满足，推荐使用 BGP 模式。</p><h2 id="参考资料">参考资料</h2><ol><li><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a></p></li><li><p><a href="https://blog.fleeto.us/post/intro-metallb/" target="_blank" rel="noopener">https://blog.fleeto.us/post/intro-metallb/</a></p></li><li><p><a href="https://ieevee.com/tech/2019/06/30/metallb.html" target="_blank" rel="noopener">https://ieevee.com/tech/2019/06/30/metallb.html</a></p></li><li><p><a href="https://blog.csdn.net/kunyus/article/details/88616653" target="_blank" rel="noopener">https://blog.csdn.net/kunyus/article/details/88616653</a></p></li><li><p><a href="https://vqiu.cn/metallb-si-you-ji-qun-loadbalancer/amp/" target="_blank" rel="noopener">https://vqiu.cn/metallb-si-you-ji-qun-loadbalancer/amp/</a></p></li><li><p><a href="https://sre.ink/metallb-kubernetes-loadbalancer-no-ipvs/" target="_blank" rel="noopener">https://sre.ink/metallb-kubernetes-loadbalancer-no-ipvs/</a></p></li><li><p><a href="https://blog.csdn.net/networken/article/details/85928369" target="_blank" rel="noopener">https://blog.csdn.net/networken/article/details/85928369</a></p></li><li><p><a href="https://blog.gmem.cc/external-lb-for-on-premise-k8s-cluster" target="_blank" rel="noopener">https://blog.gmem.cc/external-lb-for-on-premise-k8s-cluster</a></p></li><li><p><a href="https://leeif.me/2019/02/k8s-deploy-metallb-LoadBalancer.html" target="_blank" rel="noopener">https://leeif.me/2019/02/k8s-deploy-metallb-LoadBalancer.html</a></p></li><li><p><a href="https://mshk.top/2019/04/kubernetes-metallb-loadbalancer-nginx-ingress-controller/" target="_blank" rel="noopener">https://mshk.top/2019/04/kubernetes-metallb-loadbalancer-nginx-ingress-controller/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;私有云裸金属架构（这里是相对云上环境来说，不是说无操作系统）上部署的 Kubernetes 集群，通常是无法使用 LoadBalancer 类型的 Service 的。因为 Kubernetes 本身没有为裸机群集提供网络负载均衡器（类型为 LoadBalancer 的服务）的实现。如果你的 Kubernetes 集群没有在公有云的 IaaS 平台（GCP，AWS，Azure …）上运行，则 LoadBalancers 将在创建时无限期地保持 “挂起” 状态，也就是说只有公有云厂商自家的 Kubernetes 支持 LoadBalancer 。&lt;/p&gt;
&lt;p&gt;为了从外部访问裸机 Kubernetes 群集，目前只能使用 &lt;code&gt;NodePort&lt;/code&gt; 或 &lt;code&gt;Ingress&lt;/code&gt; 的方法进行服务暴露。前者的缺点是每个暴露的服务需要占用所有节点的某个端口，后者的缺点是仅仅能支持 &lt;code&gt;HTTP&lt;/code&gt; 协议。&lt;/p&gt;
&lt;h2 id=&quot;什么是-MetalLB&quot;&gt;什么是 MetalLB&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MetalLB&lt;/code&gt; 是一个负载均衡器，专门解决裸金属 Kubernetes 集群中无法使用 &lt;code&gt;LoadBalancer&lt;/code&gt; 类型服务的痛点。&lt;code&gt;MetalLB&lt;/code&gt; 使用标准化的路由协议，以便裸金属 Kubernetes 集群上的外部服务也尽可能地工作。即 MetalLB 能够帮助你在裸金属 Kubernetes 集群中创建 LoadBalancer 类型的 Kubernetes 服务，该项目发布于 2017 年底，当前处于 &lt;code&gt;Beta&lt;/code&gt; 阶段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/danderson/metallb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/danderson/metallb&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;MetalLB-工作原理&quot;&gt;MetalLB 工作原理&lt;/h2&gt;
&lt;p&gt;MetalLB 会在 Kubernetes 内运行，监控服务对象的变化，一旦监测到有新的 LoadBalancer 服务运行，并且没有可申请的负载均衡器之后，就会完成地址分配和外部声明两部分的工作。&lt;/p&gt;
&lt;h3 id=&quot;地址分配&quot;&gt;地址分配&lt;/h3&gt;
&lt;p&gt;在云环境中，当你请求一个负载均衡器时，云平台会自动分配一个负载均衡器的 IP 地址给你，应用程序通过此 IP 来访问经过负载均衡处理的服务。&lt;/p&gt;
&lt;p&gt;使用 MetalLB 时，MetalLB 会自己为用户的 LoadBalancer 类型 Service 分配 IP 地址，当然该 IP 地址不是凭空产生的，需要用户在配置中提供一个 IP 地址池，Metallb 将会在其中选取地址分配给服务。&lt;/p&gt;
&lt;h3 id=&quot;外部声明&quot;&gt;外部声明&lt;/h3&gt;
&lt;p&gt;MetalLB 将 IP 分配给某个服务后，它需要对外宣告此 IP 地址，并让外部主机可以路由到此 IP。&lt;/p&gt;
&lt;p&gt;MetalLB 支持两种声明模式：Layer 2（ ARP / NDP ）模式或者 BGP 模式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Layer 2 模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://kubernetes.github.io/ingress-nginx/images/baremetal/metallb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在任何以太网环境均可使用该模式。当在第二层工作时，将有一台机器获得 IP 地址（即服务的所有权）。MetalLB 使用标准的地址发现协议（对于 IPv4 是 ARP，对于 IPv6 是 NDP）宣告 IP 地址，使其在本地网路中可达。从 LAN 的角度来看，仅仅是某台机器多配置了一个 IP 地址。&lt;/p&gt;
&lt;p&gt;Layer 2 模式下，每个 Service 会有集群中的一个 Node 来负责。服务的入口流量全部经由单个节点，然后该节点的 Kube-Proxy 会把流量再转发给服务的 Pods。也就是说，该模式下 MetalLB 并没有真正提供负载均衡器。尽管如此，MetalLB 提供了故障转移功能，如果持有 IP 的节点出现故障，则默认 10 秒后即发生故障转移，IP 会被分配给其它健康的节点。&lt;/p&gt;
&lt;p&gt;Layer 2 模式的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Layer 2 模式更为通用，不需要用户有额外的设备；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Layer 2 模式下存在单点问题，服务的所有入口流量经由单点，其网络带宽可能成为瓶颈；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于 Layer 2 模式需要 ARP/NDP 客户端配合，当故障转移发生时，MetalLB 会发送 ARP 包来宣告 MAC 地址和 IP 映射关系的变化，地址分配略为繁琐。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;BGP 模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当在第三层工作时，集群中所有机器都和你控制的最接近的路由器建立 BGP 会话，此会话让路由器能学习到如何转发针对 K8S 服务 IP 的数据包。&lt;/p&gt;
&lt;p&gt;通过使用 BGP，可以实现真正的跨多节点负载均衡（需要路由器支持 multipath），还可以基于 BGP 的策略机制实现细粒度的流量控制。&lt;/p&gt;
&lt;p&gt;具体的负载均衡行为和路由器有关，可保证的共同行为是：每个连接（TCP 或 UDP 会话）的数据包总是路由到同一个节点上。&lt;/p&gt;
&lt;p&gt;BGP 模式的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不能优雅处理故障转移，当持有服务的节点宕掉后，所有活动连接的客户端将收到 Connection reset by peer ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BGP 路由器对数据包的源 IP、目的 IP、协议类型进行简单的哈希，并依据哈希值决定发给哪个 K8S 节点。问题是 K8S 节点集是不稳定的，一旦（参与 BGP）的节点宕掉，很大部分的活动连接都会因为 rehash 而坏掉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BGP 模式问题的缓和措施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将服务绑定到一部分固定的节点上，降低 rehash 的概率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在流量低的时段改变服务的部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端添加透明重试逻辑，当发现连接 TCP 层错误时自动重试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>再见 Docker，是时候拥抱下一代容器工具了</title>
    <link href="https://www.hi-linux.com/posts/62714.html"/>
    <id>https://www.hi-linux.com/posts/62714.html</id>
    <published>2020-05-08T01:00:00.000Z</published>
    <updated>2020-05-08T07:01:17.891Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-linux-容器">什么是 Linux 容器？</h2><p><code>Linux</code> 容器是由 <code>Linux</code> 内核所提供的具有特定隔离功能的进程，<code>Linux</code> 容器技术能够让你对应用及其整个运行时环境（包括全部所需文件）一起进行打包或隔离。从而让你在不同环境（如开发、测试和生产等环境）之间轻松迁移应用的同时，还可保留应用的全部功能。</p><p><code>Linux</code> 容器还有利于明确划分职责范围，减少开发和运维团队间的冲突。这样，开发人员可以全心投入应用开发，而运维团队则可专注于基础架构维护。由于 <code>Linux</code> 容器基于开源技术构建，还将便于你在未来轻松采用各类更新、更强的技术产品。包括 <code>CRI-O</code>、<code>Kubernetes</code> 和 <code>Docker</code> 在内的容器技术，可帮助你的团队有效简化、加速和编排应用的开发与部署。</p><h2 id="什么是-docker">什么是 Docker？</h2><p><code>Docker</code> 是一个开源的应用容器引擎，属于 <code>Linux</code> 容器的一种封装，<code>Docker</code> 提供简单易用的容器使用接口，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 <code>Linux</code> 机器上。容器是完全使用沙箱机制，相互之间不会有任何接口。</p><p>Docker 是目前最流行的 <code>Linux</code> 容器解决方案，即使 <code>Docker</code> 是目前管理 <code>Linux</code> 容器的一个非常方便的工具，但它也有两个缺点：</p><ol><li><p><code>Docker</code> 需要在你的系统上运行一个守护进程。</p></li><li><p><code>Docker</code> 是以 <code>root</code> 身份在你的系统上运行该守护程序。</p></li></ol><p>这些缺点的存在可能有一定的安全隐患，为了解决这些问题，下一代容器化工具 <code>Podman</code> 出现了 。</p><h2 id="什么是-podman">什么是 Podman ？</h2><p><img src="https://static.oschina.net/uploads/img/201808/31192253_l67X.png" alt=""></p><p><code>Podman</code> 是一个开源的容器运行时项目，可在大多数 <code>Linux</code> 平台上使用。<code>Podman</code> 提供与 <code>Docker</code> 非常相似的功能。正如前面提到的那样，它不需要在你的系统上运行任何守护进程，并且它也可以在没有 <code>root</code> 权限的情况下运行。</p><p><code>Podman</code> 可以管理和运行任何符合 <code>OCI</code>（Open Container Initiative）规范的容器和容器镜像。<code>Podman</code> 提供了一个与 <code>Docker</code> 兼容的命令行前端来管理 <code>Docker</code> 镜像。</p><blockquote><ol><li><p>Podman 官网地址：<a href="https://podman.io/" target="_blank" rel="noopener">https://podman.io/</a></p></li><li><p>Podman 项目地址：<a href="https://github.com/containers/libpod" target="_blank" rel="noopener">https://github.com/containers/libpod</a></p></li></ol></blockquote><a id="more"></a><h2 id="安装-podman">安装 Podman</h2><p><code>Podman</code> 目前已支持大多数发行版本通过软件包来进行安装，下面我们来举几个常用发行版本的例子。</p><ul><li>Fedora / CentOS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install podman</span><br></pre></td></tr></table></figure><ul><li>Ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update -qq</span><br><span class="line">$ sudo apt-get install -qq -y software-properties-common uidmap</span><br><span class="line">$ sudo add-apt-repository -y ppa:projectatomic&#x2F;ppa</span><br><span class="line">$ sudo apt-get update -qq</span><br><span class="line">$ sudo apt-get -qq -y install podman</span><br></pre></td></tr></table></figure><ul><li>MacOS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install podman</span><br></pre></td></tr></table></figure><ul><li>RHEL 7</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo subscription-manager repos --enable&#x3D;rhel-7-server-extras-rpms</span><br><span class="line">$ sudo yum -y install podman</span><br></pre></td></tr></table></figure><ul><li>Arch Linux</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S podman</span><br></pre></td></tr></table></figure><p>更多系统的安装方法，可参考官方文档：<a href="https://github.com/containers/libpod/blob/master/install.md" target="_blank" rel="noopener">https://github.com/containers/libpod/blob/master/install.md</a></p><h2 id="使用-podman">使用 Podman</h2><p>使用 <code>Podman</code> 非常的简单，<code>Podman</code> 的指令跟 <code>Docker</code> 大多数都是相同的。下面我们来看几个常用的例子：</p><h3 id="运行一个容器">运行一个容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ podman run -dt -p 8080:8080&#x2F;tcp  \</span><br><span class="line">-e HTTPD_VAR_RUN&#x3D;&#x2F;var&#x2F;run&#x2F;httpd  \</span><br><span class="line">-e HTTPD_MAIN_CONF_D_PATH&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf.d \</span><br><span class="line">-e HTTPD_MAIN_CONF_PATH&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf \</span><br><span class="line">-e HTTPD_CONTAINER_SCRIPTS_PATH&#x3D;&#x2F;usr&#x2F;share&#x2F;container-scripts&#x2F;httpd&#x2F; \</span><br><span class="line">registry.fedoraproject.org&#x2F;f27&#x2F;httpd &#x2F;usr&#x2F;bin&#x2F;run-httpd</span><br></pre></td></tr></table></figure><h3 id="列出运行的容器">列出运行的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ podman ps -a</span><br></pre></td></tr></table></figure><h3 id="分析一个运行的容器">分析一个运行的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ podman inspect -l | grep IPAddress\&quot;:</span><br><span class="line">&quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">&quot;IPAddress&quot;: &quot;&quot;,</span><br></pre></td></tr></table></figure><h3 id="查看一个运行中容器的日志">查看一个运行中容器的日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman logs --latest</span><br><span class="line">10.88.0.1 - - [07&#x2F;Feb&#x2F;2018:15:22:11 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;curl&#x2F;7.55.1&quot; &quot;-&quot;</span><br><span class="line">10.88.0.1 - - [07&#x2F;Feb&#x2F;2018:15:22:30 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;curl&#x2F;7.55.1&quot; &quot;-&quot;</span><br><span class="line">10.88.0.1 - - [07&#x2F;Feb&#x2F;2018:15:22:30 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;curl&#x2F;7.55.1&quot; &quot;-&quot;</span><br><span class="line">10.88.0.1 - - [07&#x2F;Feb&#x2F;2018:15:22:31 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;curl&#x2F;7.55.1&quot; &quot;-&quot;</span><br><span class="line">10.88.0.1 - - [07&#x2F;Feb&#x2F;2018:15:22:31 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;curl&#x2F;7.55.1&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><h3 id="查看一个运行容器中的进程资源使用情况">查看一个运行容器中的进程资源使用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman top &lt;container_id&gt;</span><br><span class="line">  UID   PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">    0 31873 31863  0 09:21 ?        00:00:00 nginx: master process nginx -g daemon off;</span><br><span class="line">  101 31889 31873  0 09:21 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure><h3 id="停止一个运行中的容器">停止一个运行中的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman stop --latest</span><br></pre></td></tr></table></figure><h3 id="删除一个容器">删除一个容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman rm --latest</span><br></pre></td></tr></table></figure><p>以上这些特性基本上都和 <code>Docker</code> 一样，<code>Podman</code> 除了兼容这些特性外，还支持了一些新的特性。</p><h3 id="给容器设置一个检查点">给容器设置一个检查点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman container checkpoint &lt;container_id&gt;</span><br></pre></td></tr></table></figure><blockquote><p>需要 CRIU 3.11 以上版本支持，CRIU 项目地址：<a href="https://criu.org/" target="_blank" rel="noopener">https://criu.org/</a></p></blockquote><h3 id="根据检查点位置恢复容器">根据检查点位置恢复容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman container restore &lt;container_id&gt;</span><br></pre></td></tr></table></figure><h3 id="迁移容器">迁移容器</h3><p>Podman 支持将容器从一台机器迁移到另一台机器。</p><p>首先，在源机器上对容器设置检查点，并将容器打包到指定位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman container checkpoint &lt;container_id&gt; -e &#x2F;tmp&#x2F;checkpoint.tar.gz</span><br><span class="line">$ scp &#x2F;tmp&#x2F;checkpoint.tar.gz &lt;destination_system&gt;:&#x2F;tmp</span><br></pre></td></tr></table></figure><p>其次，在目标机器上使用源机器上传输过来的打包文件对容器进行恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman container restore -i &#x2F;tmp&#x2F;checkpoint.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置别名">配置别名</h3><p>如果习惯了使用 <code>Docker</code> 命令，可以直接给 <code>Podman</code> 配置一个别名来实现无缝转移。你只需要在 <code>.bashrc</code> 下加入以下行内容即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;alias docker&#x3D;podman&quot; &gt;&gt; .bashrc</span><br><span class="line">$ source .bashrc</span><br></pre></td></tr></table></figure><h3 id="podman-如何实现开机重启容器">Podman 如何实现开机重启容器</h3><p>由于 <code>Podman</code> 不再使用守护进程管理服务，所以不能通过守护进程去实现自动重启容器的功能。那如果要实现开机自动重启容器，又该如何实现呢？</p><p>其实方法很简单，现在大多数系统都已经采用 <code>Systemd</code> 作为守护进程管理工具。这里我们就可以使用 <code>Systemd</code> 来实现 <code>Podman</code> 开机重启容器，这里我们以启动一个 <code>Nginx</code> 容器为例子。</p><p>首先，我们先运行一个 <code>Nginx</code> 容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman run -t -d -p 80:80 --name nginx nginx</span><br></pre></td></tr></table></figure><p>然后，在建立一个 <code>Systemd</code> 服务配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;nginx_container.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Podman Nginx Service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">After&#x3D;network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;podman start -a nginx</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;bin&#x2F;podman stop -t 10 nginx</span><br><span class="line">Restart&#x3D;always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>接下来，启用这个 <code>Systemd</code> 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl enable nginx_container.service</span><br><span class="line">$ sudo systemctl start nginx_container.service</span><br></pre></td></tr></table></figure><p>服务启用成功后，我们可以通过 <code>systemctl status</code> 命令查看到这个服务的运行状况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status nginx_container.service</span><br><span class="line">● nginx_container.service - Podman Nginx Service</span><br><span class="line">   Loaded: loaded (&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;nginx_container.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Sat 2019-08-20 20:59:26 UTC; 1min 41s ago</span><br><span class="line"> Main PID: 845 (podman)</span><br><span class="line">    Tasks: 16 (limit: 4915)</span><br><span class="line">   Memory: 37.6M</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;nginx_container.service</span><br><span class="line">           └─845 &#x2F;usr&#x2F;bin&#x2F;podman start -a nginx</span><br><span class="line"></span><br><span class="line">Aug 20 20:59:26 Ubuntu-dev.novalocal systemd[1]: Started Podman Nginx Service.</span><br></pre></td></tr></table></figure><p>之后每次系统重启后 <code>Systemd</code> 都会自动启动这个服务所对应的容器。</p><h2 id="其它相关工具">其它相关工具</h2><p><code>Podman</code> 只是 <code>OCI</code> 容器生态系统计划中的一部分，主要专注于帮助用户维护和修改符合 <code>OCI</code> 规范容器镜像。其它的组件还有 <code>Buildah</code>、<code>Skopeo</code> 等。</p><h3 id="buildah">Buildah</h3><p><img src="https://camo.githubusercontent.com/843f7639202a27bf5b6abc2afcc405e82804156a/68747470733a2f2f63646e2e7261776769742e636f6d2f636f6e7461696e6572732f6275696c6461682f6d61737465722f6c6f676f732f6275696c6461682d6c6f676f5f6c617267652e706e67" alt=""></p><p>虽然 <code>Podman</code> 也可以支持用户构建 <code>Docker</code> 镜像，但是构建速度比较慢。并且默认情况下使用 <code>VFS</code> 存储驱动程序会消耗大量磁盘空间。</p><p><code>Buildah</code> 是一个专注于构建 <code>OCI</code> 容器镜像的工具，<code>Buildah</code> 构建速度非常快并使用覆盖存储驱动程序，可以节约大量的空间。</p><p><code>Buildah</code> 基于 <code>fork-exec</code> 模型，不以守护进程运行。<code>Buildah</code> 支持 <code>Dockerfile</code> 中的所有命令。你可以直接使用 <code>Dockerfiles</code> 来构建镜像，并且不需要任何 <code>root</code> 权限。 <code>Buildah</code> 也支持用自己的语法文件构建镜像，可以允许将其他脚本语言集成到构建过程中。</p><p>下面是一个使用 <code>Buidah</code> 自有语法构建的例子。</p><p><img src="https://i.loli.net/2019/08/23/coEdGDYeFlMquUT.png" alt=""></p><p><code>Buildah</code> 和 <code>Podman</code> 之间的一个主要区别是：<code>Podman</code> 用于运行和管理容器， 允许我们使用熟悉的容器 <code>CLI</code> 命令在生产环境中管理和维护这些镜像和容器，而 <code>Buildah</code> 主用于构建容器。</p><blockquote><p>项目地址：<a href="https://github.com/containers/buildah" target="_blank" rel="noopener">https://github.com/containers/buildah</a></p></blockquote><h3 id="skopeo">Skopeo</h3><p><img src="https://camo.githubusercontent.com/19ba0305d59474c3cada4b65d5812c8c4c59465c/68747470733a2f2f63646e2e7261776769742e636f6d2f636f6e7461696e6572732f736b6f70656f2f6d61737465722f646f63732f736b6f70656f2e737667" alt=""></p><p><code>Skopeo</code> 是一个镜像管理工具，允许我们通过 <code>Push</code>、<code>Pull</code>和复制镜像来处理 <code>Docker</code> 和符合 <code>OCI</code> 规范的镜像。</p><blockquote><p>项目地址：<a href="https://github.com/containers/skopeo" target="_blank" rel="noopener">https://github.com/containers/skopeo</a></p></blockquote><h2 id="延伸阅读">延伸阅读</h2><h3 id="什么是-oci">什么是 OCI？</h3><p><code>OCI</code> (Open Container Initiative)，是一个轻量级，开放的治理结构（项目）。在 <code>Linux</code> 基金会的支持下成立，致力于围绕容器格式和运行时创建开放的行业标准。</p><p><code>OCI</code> 项目由 <code>Docker</code>、<code>CoreOS</code> 和容器行业中的其它领导者在 2015 年 6 月的时候启动，<code>OCI</code> 的技术委员会成员包括 <code>Red Hat</code>、<code>Microsoft</code>、<code>Docker</code>、<code>Cruise</code>、<code>IBM</code>、<code>Google</code>、<code>Red Hat</code> 和 <code>SUSE</code> 等。</p><h3 id="什么是-cri">什么是 CRI？</h3><p><code>CRI</code>（Container Runtime Interface）是 <code>Kubernetes</code> v1.5 引入的容器运行时接口，它将 <code>Kubelet</code> 与容器运行时解耦，将原来完全面向 <code>Pod</code> 级别的内部接口拆分成面向 <code>Sandbox</code> 和 <code>Container</code> 的 <code>gRPC</code> 接口，并将镜像管理和容器管理分离到不同的服务。</p><p><img src="https://i.loli.net/2019/08/23/L8lM1KENGdxqmgn.png" alt=""></p><h3 id="什么是-cni">什么是 CNI？</h3><p><code>CNI</code>（Container Network Interface）是 <code>CNCF</code> 旗下的一个项目，是 <code>Google</code> 和 <code>CoreOS</code> 主导制定的容器网络标准。<code>CNI</code> 包含方法规范、参数规范等，是 <code>Linux</code> 容器网络配置的一组标准和库，用户可以根据这些标准和库来开发自己的容器网络插件。<code>CNI</code> 已经被 <code>Kubernetes</code>、<code>Mesos</code>、<code>Cloud Foundry</code>、<code>RKT</code> 等使用，同时 <code>Calico</code>、<code>Weave</code> 等项目都在为 CNI 提供插件。</p><p><img src="https://www.hi-linux.com/img/linux/cni.png" alt=""></p><h2 id="总结">总结</h2><p>本文介绍三个了符合 <code>CRI</code> 标准的容器工具 <code>Podman</code>、 <code>Buildah</code> 和 <code>Skopeo</code>。这三个工具都是基于 <code>*nix</code> 传统的 <code>fork-exec</code> 模型，解决了由于 <code>Docker</code> 守护程序导致的启动和安全问题，提高了容器的性能和安全。</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://igene.tw/podman-intro" target="_blank" rel="noopener">https://igene.tw/podman-intro</a></li><li><a href="https://zhuanlan.zhihu.com/p/77373246" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77373246</a></li><li><a href="https://zhuanlan.zhihu.com/p/47706426" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47706426</a></li><li><a href="https://xuanwo.io/2019/08/06/oci-intro/" target="_blank" rel="noopener">https://xuanwo.io/2019/08/06/oci-intro/</a></li><li><a href="https://www.jianshu.com/p/62e71584d1cb" target="_blank" rel="noopener">https://www.jianshu.com/p/62e71584d1cb</a></li><li><a href="https://kubernetes.feisky.xyz/cha-jian-kuo-zhan/cri" target="_blank" rel="noopener">https://kubernetes.feisky.xyz/cha-jian-kuo-zhan/cri</a></li><li><a href="https://blog.csdn.net/networken/article/details/98684527" target="_blank" rel="noopener">https://blog.csdn.net/networken/article/details/98684527</a></li><li><a href="https://www.zcfy.cc/article/demystifying-the-open-container-initiative-oci-specifications" target="_blank" rel="noopener">https://www.zcfy.cc/article/demystifying-the-open-container-initiative-oci-specifications</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Linux-容器？&quot;&gt;什么是 Linux 容器？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 容器是由 &lt;code&gt;Linux&lt;/code&gt; 内核所提供的具有特定隔离功能的进程，&lt;code&gt;Linux&lt;/code&gt; 容器技术能够让你对应用及其整个运行时环境（包括全部所需文件）一起进行打包或隔离。从而让你在不同环境（如开发、测试和生产等环境）之间轻松迁移应用的同时，还可保留应用的全部功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 容器还有利于明确划分职责范围，减少开发和运维团队间的冲突。这样，开发人员可以全心投入应用开发，而运维团队则可专注于基础架构维护。由于 &lt;code&gt;Linux&lt;/code&gt; 容器基于开源技术构建，还将便于你在未来轻松采用各类更新、更强的技术产品。包括 &lt;code&gt;CRI-O&lt;/code&gt;、&lt;code&gt;Kubernetes&lt;/code&gt; 和 &lt;code&gt;Docker&lt;/code&gt; 在内的容器技术，可帮助你的团队有效简化、加速和编排应用的开发与部署。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Docker？&quot;&gt;什么是 Docker？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 是一个开源的应用容器引擎，属于 &lt;code&gt;Linux&lt;/code&gt; 容器的一种封装，&lt;code&gt;Docker&lt;/code&gt; 提供简单易用的容器使用接口，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 &lt;code&gt;Linux&lt;/code&gt; 机器上。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;
&lt;p&gt;Docker 是目前最流行的 &lt;code&gt;Linux&lt;/code&gt; 容器解决方案，即使 &lt;code&gt;Docker&lt;/code&gt; 是目前管理 &lt;code&gt;Linux&lt;/code&gt; 容器的一个非常方便的工具，但它也有两个缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 需要在你的系统上运行一个守护进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 是以 &lt;code&gt;root&lt;/code&gt; 身份在你的系统上运行该守护程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些缺点的存在可能有一定的安全隐患，为了解决这些问题，下一代容器化工具 &lt;code&gt;Podman&lt;/code&gt; 出现了 。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Podman-？&quot;&gt;什么是 Podman ？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201808/31192253_l67X.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Podman&lt;/code&gt; 是一个开源的容器运行时项目，可在大多数 &lt;code&gt;Linux&lt;/code&gt; 平台上使用。&lt;code&gt;Podman&lt;/code&gt; 提供与 &lt;code&gt;Docker&lt;/code&gt; 非常相似的功能。正如前面提到的那样，它不需要在你的系统上运行任何守护进程，并且它也可以在没有 &lt;code&gt;root&lt;/code&gt; 权限的情况下运行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Podman&lt;/code&gt; 可以管理和运行任何符合 &lt;code&gt;OCI&lt;/code&gt;（Open Container Initiative）规范的容器和容器镜像。&lt;code&gt;Podman&lt;/code&gt; 提供了一个与 &lt;code&gt;Docker&lt;/code&gt; 兼容的命令行前端来管理 &lt;code&gt;Docker&lt;/code&gt; 镜像。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Podman 官网地址：&lt;a href=&quot;https://podman.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://podman.io/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Podman 项目地址：&lt;a href=&quot;https://github.com/containers/libpod&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/containers/libpod&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>再见 NTP，是时候拥抱下一代时间同步服务 Chrony 了</title>
    <link href="https://www.hi-linux.com/posts/44857.html"/>
    <id>https://www.hi-linux.com/posts/44857.html</id>
    <published>2020-05-08T01:00:00.000Z</published>
    <updated>2020-05-08T06:31:03.045Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Chrony</code> 是一个多功能的 <code>NTP (Network Time Protocol)</code> 实现，类 <code>Unix</code> 系统上 <code>NTP</code> 客户端和服务器的替代品。它可以通过 <code>NTP</code> 服务或者类似 <code>GPS</code> 时钟接收器的硬件级参考时钟来同步系统时钟，具有更好的时钟准确度，并且对于那些间歇性互联网连接的系统很有帮助。<code>Chrony</code> 是免费开源的，并且支持 <code>GNU/Linux</code> 和 <code>BSD</code> 衍生版（比如：<code>FreeBSD</code>、<code>NetBSD</code>）、<code>macOS</code> 和 <code>Solaris</code> 等。</p><p><code>Chrony</code> 有两个核心组件：一个是 <code>chronyd</code> 守护进程，主要用于调整内核中运行的系统时间和时间服务器同步。它确定计算机增减时间的比率，并对此进行调整补偿。另一个是 <code>chronyc</code>，它提供一个用户界面，用于监控性能并进行多样化的配置。<code>chronyc</code> 可以在 <code>chronyd</code> 实例控制的计算机上工作，也可以在一台不同的远程计算机上工作。</p><p><strong>Chrony 和 NTPD 精度对比测试</strong></p><p>我们可以从 <code>Chrony</code> 的官方网站上可以看到与 <code>NTPD</code> 各维度详细对比：</p><p><img src="https://www.hi-linux.com/img/linux/chrony-1.png" alt=""></p><p>从其测试结果上看似乎是各维度性能都可以吊打 <code>NTPD</code>。因此 <code>Chrony</code> 对自身的整体评价还是比较高的。</p><p><strong>Chrony 相较于 NTPD 服务的优势</strong></p><ol><li><p>更快的同步只需要数分钟而非数小时时间，从而最大程度的减少时间和频率误差，这对于并非全天运行的台式计算机或系统而言非常有用。</p></li><li><p>能够更好的响应时间频率的快速变化，这对于具备不稳定时钟的虚拟机或导致时钟频率反复变化的节能技术而言非常有用。</p></li><li><p>在初始同步后，它并不会停止时钟，以防对需要系统时间保持单调的程序造成影响。</p></li><li><p>在应对临时非对称延迟时，（例如：大规模下载造成连接饱和时）提供了更好的稳定性。</p></li><li><p>无需对服务器进行定期轮询，因此具备间歇性网络连接的系统仍然可以快速同步时钟。</p></li></ol><a id="more"></a><h2 id="安装-chrony">安装 Chrony</h2><p>从 <code>Centos 7.x</code> 开始的最小发行版中都已经预装并开启了 <code>Chrony</code>。如果你的系统上没有安装 <code>Chrony</code>，你也可以使用下面的命令轻松安装它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install chrony    <span class="comment"># [On CentOS/RHEL]</span></span><br><span class="line">$ apt install chrony       <span class="comment"># [On Debian/Ubuntu]</span></span><br><span class="line">$ dnf -y install chrony    <span class="comment"># [On Fedora 22+]</span></span><br></pre></td></tr></table></figure><p>安装完成后，你可以使用以下命令来检查 <code>chronyd</code> 的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status chronyd     <span class="comment"># [On SystemD]</span></span><br><span class="line">$ /etc/init.d/chronyd status   <span class="comment"># [On Init]</span></span><br></pre></td></tr></table></figure><p>如果要在开机引导时自动启用 <code>Chrony</code> 的守护程序，你可以使用以下命令来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> chrony       <span class="comment"># [On SystemD]</span></span><br><span class="line">$ chkconfig --add chronyd       <span class="comment"># [On Init]</span></span><br></pre></td></tr></table></figure><h2 id="配置-chrony">配置 Chrony</h2><p><code>Chrony</code> 的默认配置文件为 <code>/etc/chrony.conf</code>，下面将介绍一些常用的配置项。</p><ol><li>server hostname [option]</li></ol><p><code>server</code> 指令用于指定要同步的 <code>NTP</code> 服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server 0.centos.pool.ntp.org iburst</span><br></pre></td></tr></table></figure><p>其中的 <code>0.centos.pool.ntp.org</code> 是 <code>NTP</code> 服务器的地址，默认有四组官方的 <code>NTP</code> 服务器。你也可以修改为自定义的时间服务器，例如：<code>ntp1.aliyun.com</code>。</p><p><code>iburst</code> 是参数, 一般用此参数即可。该参数的含义是在头四次 <code>NTP</code> 请求以 <code>2s</code> 或者更短的间隔，而不是以 <code>minpoll x</code> 指定的最小间隔，这样的设置可以让 <code>chronyd</code> 启动时快速进行一次同步。</p><p>其他的参数有 <code>minpoll x</code> 默认值是 6，代表 <code>64s</code>。<code>maxpoll x</code> 默认值是 9，代表 <code>512s</code>。</p><ol start="2"><li>driftfile file</li></ol><p><code>Chrony</code> 会根据实际时间计算修正值，并将补偿参数记录在该指令指定的文件里，默认为 <code>driftfile /var/lib/chrony/drift</code>。</p><p>与 <code>ntpd</code> 或者 <code>ntpdate</code> 最大的区别就是，<code>Chrony</code> 的修正是连续的，通过减慢时钟或者加快时钟的方式连续的修正。而 <code>ntpd</code> 或者 <code>ntpdate</code> 搭配 <code>Crontab</code> 的校时工具是直接调整时间，会出现间断，并且相同时间可能会出现两次。因此，请放弃使用 <code>ntpd</code>、<code>ntpdate</code> 来校时。</p><ol start="3"><li>makestep threshold limit</li></ol><p>此指令使 <code>Chrony</code> 根据需要通过加速或减慢时钟来逐渐校正任何时间偏移。例如：<code>makestep 1.0 3</code>，就表示当头三次校时，如果时间相差 <code>1.0s</code>, 则跳跃式校时。</p><ol start="4"><li>rtcsync</li></ol><p>启用内核时间与 <code>RTC</code> 时间同步 (自动写回硬件)。</p><ol start="5"><li>logdir</li></ol><p>该参数用于指定 <code>Chrony</code> 日志文件的路径。</p><ol start="6"><li>stratumweight</li></ol><p>该参数用于设置当 <code>chronyd</code> 从可用源中选择同步源时，每个层应该添加多少距离到同步距离。默认情况下设置为 0，让 <code>chronyd</code> 在选择源时忽略源的层级。</p><p>基本上常用的参数就只有这几个了，通常默认的配置文件就可以直接使用了，下面我们来看一个修改完成后的配置文件内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里只修改了 server 中的 NTP 服务器地址，如果网络环境良好可以使用默认配置</span></span><br><span class="line">server ntp1.aliyun.com iburst</span><br><span class="line">server ntp2.aliyun.com iburst</span><br><span class="line"></span><br><span class="line">driftfile /var/lib/chrony/drift</span><br><span class="line">makestep 1.0 3</span><br><span class="line">rtcsync</span><br><span class="line">logdir /var/<span class="built_in">log</span>/chrony</span><br></pre></td></tr></table></figure><h2 id="使用-chrony-客户端程序进行管理">使用 Chrony 客户端程序进行管理</h2><ol><li>检查 Chrony 是否实际同步</li></ol><p>为了检查 <code>Chrony</code> 是否实际同步，我们将使用它的命令行程序 <code>chronyc</code> 来验证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc tracking </span><br><span class="line"></span><br><span class="line">Reference ID    : 78197314 (120.25.115.20)</span><br><span class="line">Stratum         : 3</span><br><span class="line">Ref time (UTC)  : Fri Jun 28 13:58:17 2019</span><br><span class="line">System time     : 0.000042858 seconds slow of NTP time</span><br><span class="line">Last offset     : -0.000187823 seconds</span><br><span class="line">RMS offset      : 0.001029734 seconds</span><br><span class="line">Frequency       : 17.614 ppm slow</span><br><span class="line">Residual freq   : +0.008 ppm</span><br><span class="line">Skew            : 5.552 ppm</span><br><span class="line">Root delay      : 0.034440458 seconds</span><br><span class="line">Root dispersion : 0.002149768 seconds</span><br><span class="line">Update interval : 64.1 seconds</span><br><span class="line">Leap status     : Normal</span><br></pre></td></tr></table></figure><p>这里主要关注 <code>Update interval</code> 这个参数, 说明最后两次更新的时间间隔是 <code>64.1s</code>。以上结果中的其它参数的含义分别是：</p><ul><li><p>引用 <code>ID</code> - 计算机当前同步的引用 <code>ID</code> 和名称。</p></li><li><p><code>Stratum</code> - 连接参考时钟的计算机的跳数。</p></li><li><p>参考时间 - 这是参考源的最后一次测量的 <code>UTC</code> 时间。</p></li><li><p>系统时间 - 来自同步服务器的系统时钟延迟。</p></li><li><p>最后一次偏移 - 上次时钟更新的估计偏移量。</p></li><li><p><code>RMS</code> 偏移 - 偏移值的长期平均值。</p></li><li><p>频率 - 如果 <code>chronyd</code> 没有纠正它，那么系统的时钟错误的速率。它以 <code>ppm</code> （百万分率）提供。</p></li><li><p>残余频率 - 残余频率表示参考源的测量值与当前使用的频率之间的差异。</p></li><li><p>偏斜 - 估计频率的误差界限。</p></li><li><p>根延迟 - 网络路径延迟到计算机正在同步的层计算机的总和。</p></li><li><p>跳跃状态 - 这是跳跃状态，可以具有以下值之一：正常、插入秒、删除秒或不同步。</p></li></ul><ol start="2"><li>显示所有 NTP 源服务器的信息</li></ol><p>这里需要注意的是第二个参数，<code>*</code> 代表当前同步的源，<code>-</code> 代表通过组合算法计算后排除的源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc sources -v</span><br><span class="line"></span><br><span class="line">210 Number of sources = 2</span><br><span class="line"></span><br><span class="line">  .-- Source mode  <span class="string">'^'</span> = server, <span class="string">'='</span> = peer, <span class="string">'#'</span> = <span class="built_in">local</span> clock.</span><br><span class="line"> / .- Source state <span class="string">'*'</span> = current synced, <span class="string">'+'</span> = combined , <span class="string">'-'</span> = not combined,</span><br><span class="line">| /   <span class="string">'?'</span> = unreachable, <span class="string">'x'</span> = time may be <span class="keyword">in</span> error, <span class="string">'~'</span> = time too variable.</span><br><span class="line">||                                                 .- xxxx [ yyyy ] +/- zzzz</span><br><span class="line">||      Reachability register (octal) -.           |  xxxx = adjusted offset,</span><br><span class="line">||      Log2(Polling interval) --.      |          |  yyyy = measured offset,</span><br><span class="line">||                                \     |          |  zzzz = estimated error.</span><br><span class="line">||                                 |    |           \</span><br><span class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample</span><br><span class="line">===============================================================================</span><br><span class="line">^* 120.25.115.20                 2   6    37    12    +85us[ -960us] +/-   20ms</span><br><span class="line">^- 203.107.6.88                  2   6    37    12   +262us[ +262us] +/-   21ms</span><br></pre></td></tr></table></figure><ol start="3"><li>查看 NTP 服务器的在线和离线状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc activity</span><br></pre></td></tr></table></figure><ol start="4"><li>查看 Chrony 服务的日志</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl -u chronyd</span><br></pre></td></tr></table></figure><ol start="5"><li>检查 NTP 访问是否对特定主机可用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc accheck</span><br></pre></td></tr></table></figure><ol start="6"><li>该命令会显示有多少 NTP 源在线/离线</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc activity</span><br></pre></td></tr></table></figure><ol start="7"><li>手动添加一台新的 NTP 服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc add server</span><br></pre></td></tr></table></figure><ol start="8"><li>在客户端报告已访问到服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc clients</span><br></pre></td></tr></table></figure><ol start="9"><li>手动移除 NTP 服务器或对等服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc delete</span><br></pre></td></tr></table></figure><ol start="10"><li>手动设置守护进程时间</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc settime</span><br></pre></td></tr></table></figure><ol start="11"><li>校准时间服务器，显示系统时间信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc tracking</span><br></pre></td></tr></table></figure><ol start="12"><li>检查 NTP 访问是否对特定主机可用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc accheck</span><br></pre></td></tr></table></figure><ol start="13"><li>查看时间同步源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc sources -v</span><br></pre></td></tr></table></figure><ol start="14"><li>查看时间同步源状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc sourcestats -v</span><br></pre></td></tr></table></figure><p><code>Chrony</code> 客户端程序的功能非常强大，远不止上面介绍这些。不但支持命令行模式，而且还支持交互模式。如果你想了解更多 <code>Chrony</code> 客户端程序的使用方法，可以使用 <code>man  chronyc</code> 命令获取更多帮助。</p><h2 id="使用-chrony-作为-ntp-服务器">使用 Chrony 作为 NTP 服务器</h2><p>要将 <code>Chrony</code> 作为一个 <code>NTP</code> 服务器，方法很简单。</p><p>首先，你需要修改 <code>/etc/chrony.conf</code> 文件，并添加以下配置即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于安全要求比较高的，这里可以限制谁能访问本机提供的 NTP 服务。</span></span><br><span class="line">allow 192.168.1.0/24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 chronyd 监听在哪个网络接口</span></span><br><span class="line">bindcmdaddress 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个地方很重要，如果服务器本身也不能同步时间，那么就用本地时间替代，层级为 10</span></span><br><span class="line"><span class="built_in">local</span> stratum 10</span><br></pre></td></tr></table></figure><p>其次，重启 <code>Chronyd</code> 服务，以加载新的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart chronyd</span><br></pre></td></tr></table></figure><p><code>Chronyd</code> 服务启动成功后，会监听以下两个端口。</p><ul><li><p>端口 <code>123/udp</code> 为标准的 <code>NTP</code> 监听端口，如果要对外提供 <code>NTP Server</code> 功能，必须开启防火墙和监听地址为外部可访问地址。如需修改，你可以通过配置 <code>port</code> 参数来修改。</p></li><li><p>端口 <code>323/udp</code> 为默认的管理端口。如需修改，你可以通过配置 <code>cmdport</code> 参数来修改。</p></li></ul><p>最后，修改防火墙设置，以放行对 <code>123/udp</code> 的请求，这里以 <code>CentOS 7</code> 的 <code>Firewalld</code> 为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --zone=public --add-port=123/udp --permanent</span><br><span class="line">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="延伸阅读">延伸阅读</h2><h3 id="一些可用的公共-ntp-服务">一些可用的公共 NTP 服务</h3><p>公共 <code>NTP</code> 服务网上很多，但国内环境下最好用的应该还属阿里云的公网 <code>NTP</code> 服务。</p><p><img src="https://i.loli.net/2019/10/31/TKhznvkqWb3ydxr.png" alt=""></p><h3 id="一些时间相关的概念介绍">一些时间相关的概念介绍</h3><ol><li>GMT、UTC、CST、DST 时间</li></ol><ul><li><p><code>UTC</code> 整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时 (<code>UTC, Universal Time Coordinated</code>)。</p></li><li><p><code>GMT</code> 格林威治标准时间 (<code>Greenwich Mean Time</code>) 指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。( <code>UTC</code> 与 <code>GMT</code> 时间基本相同)</p></li><li><p><code>CST</code> 中国标准时间 (<code>China Standard Time</code>)</p></li><li><p><code>GMT</code> + 8 = <code>UTC</code> + 8 = <code>CST</code></p></li><li><p><code>DST</code> 夏令时 (<code>Daylight Saving Time</code>) 指在夏天太阳升起的比较早时，将时间拨快一小时，以提早日光的使用。（中国不使用）</p></li></ul><ol start="2"><li>硬件时间和系统时间</li></ol><ul><li><p>硬件时间：<code>RTC (Real-Time Clock)</code> 或 <code>CMOS</code> 时间，一般在主板上靠电池供电，服务器断电后也会继续运行。仅保存日期时间数值，无法保存时区和夏令时设置。</p></li><li><p>系统时间：一般在服务器启动时复制 <code>RTC</code> 时间，之后独立运行，保存了时间、时区和夏令时设置。</p></li></ul><h3 id="一些设置时区和时间的命令">一些设置时区和时间的命令​</h3><ol><li>查看当前系统时区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用 timedatectl 命令也等同于以下命令</span></span><br><span class="line">$ timedatectl status</span><br><span class="line">      Local time: Fri 2018-2-29 13:31:04 CST</span><br><span class="line">  Universal time: Fri 2018-2-29 05:31:04 UTC</span><br><span class="line">        RTC time: Fri 2018-2-29 08:17:20</span><br><span class="line">       Time zone: Asia/Shanghai (CST, +0800)</span><br><span class="line">     NTP enabled: yes</span><br><span class="line">NTP synchronized: yes</span><br><span class="line"> RTC <span class="keyword">in</span> <span class="built_in">local</span> TZ: no</span><br><span class="line">      DST active: n/a</span><br></pre></td></tr></table></figure><ol start="2"><li>设置当前系统时区</li></ol><p>如果你当前的时区不正确，请按照以下操作设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有可用的时区</span></span><br><span class="line">$ timedatectl list-timezones</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上海可用时区</span></span><br><span class="line">$ timedatectl list-timezones |  grep  -E <span class="string">"Asia/S.*"</span></span><br><span class="line">Asia/Sakhalin</span><br><span class="line">Asia/Samarkand</span><br><span class="line">Asia/Seoul</span><br><span class="line">Asia/Shanghai</span><br><span class="line">Asia/Singapore</span><br><span class="line">Asia/Srednekolymsk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前系统为 Asia/Shanghai 上海时区</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置完时区后，在强制同步下系统时钟</span></span><br><span class="line">$ chronyc -a makestep</span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure><ol start="3"><li>显示系统的当前时间和日期</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl <span class="built_in">set</span>-time <span class="string">"YYYY-MM-DD HH:MM:SS"</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-time <span class="string">"YYYY-MM-DD"</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-time <span class="string">"HH:MM:SS"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>修改当前日期时间</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以只修改其中一个</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-time <span class="string">"2019-10-31 15:50:00"</span></span><br></pre></td></tr></table></figure><ol start="5"><li>设置硬件时间</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 硬件时间默认为 UTC，下面两条命令效果等同</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-local-rtc 1</span><br><span class="line">$ hwclock --systohc --localtime</span><br></pre></td></tr></table></figure><ol start="6"><li>启用或者禁止 NTP 时间同步</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yes 或 no，1 或 0 也可以</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-ntp yes/no</span><br><span class="line">$ timedatectl <span class="built_in">set</span>-ntp <span class="literal">true</span>/flase</span><br></pre></td></tr></table></figure><h2 id="参考文档">参考文档</h2><ol><li><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a></p></li><li><p><a href="https://url.cn/5RYX5Ob" target="_blank" rel="noopener">https://url.cn/5RYX5Ob</a></p></li><li><p><a href="https://chegva.com/3265.html" target="_blank" rel="noopener">https://chegva.com/3265.html</a></p></li><li><p><a href="https://blog.gnuers.org/?p=1483" target="_blank" rel="noopener">https://blog.gnuers.org/?p=1483</a></p></li><li><p><a href="https://yq.aliyun.com/articles/503151" target="_blank" rel="noopener">https://yq.aliyun.com/articles/503151</a></p></li><li><p><a href="http://tswblog.com/article/linux/chrony/" target="_blank" rel="noopener">http://tswblog.com/article/linux/chrony/</a></p></li><li><p><a href="https://www.cnblogs.com/cloudos/p/NTP.html" target="_blank" rel="noopener">https://www.cnblogs.com/cloudos/p/NTP.html</a></p></li><li><p><a href="https://www.itsfun.tk/better-ntp-server-chrony/" target="_blank" rel="noopener">https://www.itsfun.tk/better-ntp-server-chrony/</a></p></li><li><p><a href="https://www.mnstory.net/2018/12/09/chrony-ntp-date-sync/" target="_blank" rel="noopener">https://www.mnstory.net/2018/12/09/chrony-ntp-date-sync/</a></p></li><li><p><a href="https://www.howtoing.com/install-chrony-in-centos-ubuntu-linux" target="_blank" rel="noopener">https://www.howtoing.com/install-chrony-in-centos-ubuntu-linux</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Chrony&lt;/code&gt; 是一个多功能的 &lt;code&gt;NTP (Network Time Protocol)&lt;/code&gt; 实现，类 &lt;code&gt;Unix&lt;/code&gt; 系统上 &lt;code&gt;NTP&lt;/code&gt; 客户端和服务器的替代品。它可以通过 &lt;code&gt;NTP&lt;/code&gt; 服务或者类似 &lt;code&gt;GPS&lt;/code&gt; 时钟接收器的硬件级参考时钟来同步系统时钟，具有更好的时钟准确度，并且对于那些间歇性互联网连接的系统很有帮助。&lt;code&gt;Chrony&lt;/code&gt; 是免费开源的，并且支持 &lt;code&gt;GNU/Linux&lt;/code&gt; 和 &lt;code&gt;BSD&lt;/code&gt; 衍生版（比如：&lt;code&gt;FreeBSD&lt;/code&gt;、&lt;code&gt;NetBSD&lt;/code&gt;）、&lt;code&gt;macOS&lt;/code&gt; 和 &lt;code&gt;Solaris&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Chrony&lt;/code&gt; 有两个核心组件：一个是 &lt;code&gt;chronyd&lt;/code&gt; 守护进程，主要用于调整内核中运行的系统时间和时间服务器同步。它确定计算机增减时间的比率，并对此进行调整补偿。另一个是 &lt;code&gt;chronyc&lt;/code&gt;，它提供一个用户界面，用于监控性能并进行多样化的配置。&lt;code&gt;chronyc&lt;/code&gt; 可以在 &lt;code&gt;chronyd&lt;/code&gt; 实例控制的计算机上工作，也可以在一台不同的远程计算机上工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chrony 和 NTPD 精度对比测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以从 &lt;code&gt;Chrony&lt;/code&gt; 的官方网站上可以看到与 &lt;code&gt;NTPD&lt;/code&gt; 各维度详细对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/chrony-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从其测试结果上看似乎是各维度性能都可以吊打 &lt;code&gt;NTPD&lt;/code&gt;。因此 &lt;code&gt;Chrony&lt;/code&gt; 对自身的整体评价还是比较高的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chrony 相较于 NTPD 服务的优势&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更快的同步只需要数分钟而非数小时时间，从而最大程度的减少时间和频率误差，这对于并非全天运行的台式计算机或系统而言非常有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能够更好的响应时间频率的快速变化，这对于具备不稳定时钟的虚拟机或导致时钟频率反复变化的节能技术而言非常有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在初始同步后，它并不会停止时钟，以防对需要系统时间保持单调的程序造成影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在应对临时非对称延迟时，（例如：大规模下载造成连接饱和时）提供了更好的稳定性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无需对服务器进行定期轮询，因此具备间歇性网络连接的系统仍然可以快速同步时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="NTP" scheme="https://www.hi-linux.com/tags/NTP/"/>
    
  </entry>
  
  <entry>
    <title>看业界大神是如何进行独立思考的！做为技术人，你具备这样的能力吗？</title>
    <link href="https://www.hi-linux.com/posts/34120.html"/>
    <id>https://www.hi-linux.com/posts/34120.html</id>
    <published>2020-05-06T01:00:00.000Z</published>
    <updated>2020-05-06T04:39:24.993Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这是一个非常复杂的世界，这个世界上有很多各式各样的观点和思维方式，作为一个程序员的我，也会有程序员的思维方式，程序员的思维方式更接近数学的思维方式，数学的思维方式让可以很容易地理清楚这个混乱的世界，其实，并不需要太复杂的数学逻辑，只需要使用一些简单的数学方法，就可以大幅提升自己的认识能力，所以，在这里，记录一篇我自己的思维方式，一方面给大家做个参考，另一方面也供更高阶的人给我进行指正。算是 “开源我的思维方式”，开放不仅仅是为了输出，更是为了看看有没有更好的方式。</p><p>我的思维方式中，使用数学逻辑的方式进行思考，通常来说，我会使用五步思考的方式：</p><h3 id="第一步信息数据可考证">第一步：信息数据可考证</h3><p>如果一个观点或是一个见解的数据是错误的，那么就会造成后面的观点全是错的，所以，首要的是要进行数据的查证或考证。一般来说，如果一篇文章的作者足够严谨的话，他的需要给他的数据建立相关的引用或是可以考证的方法方式。如果一篇文章中出现的是，“有关专家表明”、“美国科学家证明”、“经济学家指出”，但是没有任出处，也没有点明这个专家或是科学家的名字，或是，也没有说明或引用让读者可以自己去验证的方法。那么，其引用的话或是数据是无法考证的，如果是无法考证的，那么，这篇文章的水份就非常大了。一般来说，当我读到一篇文章中的东西没有可考证的来源或是方法时，通常来说，我就不会再读了，因为这篇文章的价值已经不大了，如果我关心这篇文章中的东西，我会改为自己去查找的方式，虽然变“重”了，但是很安全。（所以，像 Wikipedia 这样的网站是我经常去获得信息的地方，因为信息可以被考证是其基本价值观）</p><h3 id="第二步处理集合和其包含关系">第二步：处理集合和其包含关系</h3><p>这是一个非常简单的人人都会的数学逻辑。比如：哲学家是人，柏拉图是哲学家，所以，柏拉图是人。就是一个在包含关系下的推理。你不要小看这个简单的逻辑，其实很多人并不会很好的应用，相反，当感情支配了他们以后，他们会以点代面，以特例代替普遍性。比如，地图炮就是一种，他们看到了多个案例，他们就开始把这个案例上升上更大的范围，比如：河南人新疆人都是小偷，上海人都是小市民。日本人都是变态和反人类……等等。除了这些地图炮外，还有否定整个人的，比如一个人犯了个错或是性格上有缺陷，就会把整个人全盘否定掉，员工抢个月饼就上升到其价值观有问题……。在数学的逻辑包含中，超集的定义可以适用于子集，通过子集的特征可以对超集进行探索，但是没法定义超集。另外，集合的大小也是一个很重要的事，<a href="https://zh.wikipedia.org/wiki/%E5%80%96%E5%AD%98%E8%80%85%E5%81%8F%E5%B7%AE" target="_blank" rel="noopener">幸存者偏差</a>会是一个很容易让人掉下去的陷阱，因为可能会有很大的样本集可能在你的视线盲区。</p><a id="more"></a><h3 id="第三步处理逻辑因果关系">第三步：处理逻辑因果关系</h3><p>所谓因果关系，其实就是分辨充分条件、必要条件和充分必要条件，然后处理其中的逻辑是否有关联性，而且有非常强的因果关系。没有能力分辨充分必要条件处理因果关系是很多人的硬伤。就像我在《<a href="https://coolshell.cn/articles/19271.html" target="_blank" rel="noopener">努力就会成功</a>》中说的一样，“努力” 和 “成功”是否有因果关系？各种逻辑混淆、概念偷换、模糊因果、似是而非全是在这里。比如：掩耳盗铃、刻舟求剑就是因果关系混乱的表现。人们会经常地混淆两个看来一起发生，但是并没有关联在一起的事。因果关系是最容易被模糊和偷换的，比如：很多人都容易混淆“加班”就会有“产出”，混淆了“行动”就会有“结果”，混淆了“抵制”就会赢得“尊重”，混淆了“批评”等于“反对”……等等。除了这些以外，微信公众号里的很多时评文章，他们的文章中的结论和其论据是没有因果关系的，好多文章就是混淆、模糊、偷换……<strong>因果关系出问题的文章读多了是对大脑有损伤的，要尽量远离。</strong></p><h3 id="第四步找到靠谱的基准线">第四步：找到靠谱的基准线</h3><p>就像我们写代码一样，我们都是会去找一些最佳实践或是业内标准，原因是因为，这样的东西都是经过长时间被这个世界上很多人 Review 过的，是值得依赖和靠谱的，他们会考虑到很多你没有考虑过的问题。所以，你也会看到很多时评都会找欧美发达国家的作参考的做法，因为毕竟人家的文化是相对比较文明、科学、开放和先进的。找到世界或是国际的通行标准，会更容易让人进步。比如：以开放包容加强沟通的心态，就会比封闭抵制敌对的心态要好得多得多，智者建桥，愚者建墙。当然，我们也开始发现，有一些事上，有利于自己的就对标，不利于自己的就不对标，而且，除了好的事，不好的事也在找欧美作对标，于是开始 “多基准线” 和 “乱基准线”，这种方式需要我们小心分辨。</p><h3 id="第五步更为深入和高维的思考">第五步：更为深入和高维的思考</h3><p>如果一件事情只在表面上进行思考其实只是一种浅度思考，在 Amazon，线上系统出现故障的时候，需要写一个 Correction of Errors 的报告，其中需要Ask 5 Whys（参看 Wikipedia 的 <a href="https://en.wikipedia.org/wiki/Five_whys" target="_blank" rel="noopener">Five Whys 词条</a>），这种思考方式可以让你不断追问到深层次的本质问题，会让你自己做大量的调查和研究，让你不会成为一个只会在表面上进行思考的简单动物。比如：当你看到有出乎你意料的事件发生时（比如负面的暴力事件），你需要问一下，为什么会发生，原因是什么？然后罗列尽可能全的原因，再不断地追问并拷证下去（这跟写程序一样，需要从正向案例和负向案例进行考虑分析，才可能写出健壮性很强的代码），我们才会得出一个比较健壮的答案或结构。</p><p>需要注意的是，在上述的这五种思维方式下，你的思考是不可能快得起来的，这是一个 “慢思考”（注：如果读过《<a href="https://book.douban.com/subject/10785583/" target="_blank" rel="noopener">思考，快与慢</a>》这本书的人就知道我在说什么），独立思考是需要使用大脑中的“慢系统”，慢系统是反人性的，所以，能真正做到独立思考的人很少。更多的人的“独立思考”其实只不过是毫无章法的乱思考罢了。</p><p>通过上述的这五点，我相信你是很容易识别或是分辨出哪些信息是靠谱的，哪些信息是很扯的，甚至会改善你自己的言论和思考。但是，<strong>请注意，这些方法并不能让你获得真理或是真相。</strong></p><p>但是这也够了，一个人如果拥有了能够分辨是非的能力，也是很不错的了。虽然不知道事实是什么，但是你也不会盲从和偏信，从而不会被人煽动，而成为幕后黑手的的一只“肉鸡”。</p><p>多说两句，下面是一些我个人的一些实践：</p><ul><li><p>当新闻报道报道的不是客观事实，而是加入了很多观点，那么这篇新闻报道是不可信的。</p></li><li><p>对于评论性的文章，没有充足权威可信的论据时，不能完全相信。</p></li><li><p>不是当事人，不是见证人，还要装作自己是知情的……不知道这种人的自信怎么来的？</p></li><li><p>信息不公开的，并有意屏蔽信息的，不能作为可信的信息源。</p></li><li><p>当出现大是或是大非的事时，一定要非常小心，这个世界不存在完全的美和完全的丑，这样的观点通常来说都是危险的，此时要多看看不同角度的报道和评论，要多收集一些信息，还要多问问为什么。</p></li></ul><p>欢迎大家在评论区留言，告诉我一些你的实践和思维方式。</p><blockquote><p>本文转载自：「酷壳」，原文：<a href="https://url.cn/5MGMoTP%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5MGMoTP，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个非常复杂的世界，这个世界上有很多各式各样的观点和思维方式，作为一个程序员的我，也会有程序员的思维方式，程序员的思维方式更接近数学的思维方式，数学的思维方式让可以很容易地理清楚这个混乱的世界，其实，并不需要太复杂的数学逻辑，只需要使用一些简单的数学方法，就可以大幅提升自己的认识能力，所以，在这里，记录一篇我自己的思维方式，一方面给大家做个参考，另一方面也供更高阶的人给我进行指正。算是 “开源我的思维方式”，开放不仅仅是为了输出，更是为了看看有没有更好的方式。&lt;/p&gt;
&lt;p&gt;我的思维方式中，使用数学逻辑的方式进行思考，通常来说，我会使用五步思考的方式：&lt;/p&gt;
&lt;h3 id=&quot;第一步：信息数据可考证&quot;&gt;第一步：信息数据可考证&lt;/h3&gt;
&lt;p&gt;如果一个观点或是一个见解的数据是错误的，那么就会造成后面的观点全是错的，所以，首要的是要进行数据的查证或考证。一般来说，如果一篇文章的作者足够严谨的话，他的需要给他的数据建立相关的引用或是可以考证的方法方式。如果一篇文章中出现的是，“有关专家表明”、“美国科学家证明”、“经济学家指出”，但是没有任出处，也没有点明这个专家或是科学家的名字，或是，也没有说明或引用让读者可以自己去验证的方法。那么，其引用的话或是数据是无法考证的，如果是无法考证的，那么，这篇文章的水份就非常大了。一般来说，当我读到一篇文章中的东西没有可考证的来源或是方法时，通常来说，我就不会再读了，因为这篇文章的价值已经不大了，如果我关心这篇文章中的东西，我会改为自己去查找的方式，虽然变“重”了，但是很安全。（所以，像 Wikipedia 这样的网站是我经常去获得信息的地方，因为信息可以被考证是其基本价值观）&lt;/p&gt;
&lt;h3 id=&quot;第二步：处理集合和其包含关系&quot;&gt;第二步：处理集合和其包含关系&lt;/h3&gt;
&lt;p&gt;这是一个非常简单的人人都会的数学逻辑。比如：哲学家是人，柏拉图是哲学家，所以，柏拉图是人。就是一个在包含关系下的推理。你不要小看这个简单的逻辑，其实很多人并不会很好的应用，相反，当感情支配了他们以后，他们会以点代面，以特例代替普遍性。比如，地图炮就是一种，他们看到了多个案例，他们就开始把这个案例上升上更大的范围，比如：河南人新疆人都是小偷，上海人都是小市民。日本人都是变态和反人类……等等。除了这些地图炮外，还有否定整个人的，比如一个人犯了个错或是性格上有缺陷，就会把整个人全盘否定掉，员工抢个月饼就上升到其价值观有问题……。在数学的逻辑包含中，超集的定义可以适用于子集，通过子集的特征可以对超集进行探索，但是没法定义超集。另外，集合的大小也是一个很重要的事，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%80%96%E5%AD%98%E8%80%85%E5%81%8F%E5%B7%AE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;幸存者偏差&lt;/a&gt;会是一个很容易让人掉下去的陷阱，因为可能会有很大的样本集可能在你的视线盲区。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="思想" scheme="https://www.hi-linux.com/tags/%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款命令行下最快的文本搜索神器 RipGrep</title>
    <link href="https://www.hi-linux.com/posts/29245.html"/>
    <id>https://www.hi-linux.com/posts/29245.html</id>
    <published>2018-09-17T01:00:00.000Z</published>
    <updated>2018-09-17T02:18:53.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Ripgrep 是命令行下一个基于行的搜索工具，RipGrep 使用 Rust 开发，可以在多平台下运行，支持 Mac、Linux 和 Windows 等平台。RipGrep 与 The Silver Searcher、Ack 和 GNU Grep 的功能类似。</p><p>RipGrep 官方号称比其它类似工具在搜索速度上快上 N 倍，VSCode 也从 <a href="https://code.visualstudio.com/updates/v1_11#_text-search-improvements" target="_blank" rel="noopener">1.11 版本</a>开始默认将 RipGrep 做为其搜索工具，由此其功能强大可见一斑。</p><p>项目地址：<a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">https://github.com/BurntSushi/ripgrep</a></p><p><strong>Ripgrep 支持的一些特性</strong></p><ul><li>自动递归搜索 （grep 需要 -R）。</li><li>自动忽略 .gitignore 中的文件以及二进制文件和隐藏文件。</li><li>可以搜索指定文件类型，如：<code>rg -tpy foo</code> 则限定只搜索 Python 文件，<code>rg -Tjs foo</code> 则排除掉 JS 文件。</li><li>支持大部分 Grep 的 特性，例如：显示搜索结果的上下文、支持多个模式搜索、高亮匹配的搜索结果以及支持 Unicode 等。</li><li>支持各种文本编码格式，如：UTF-8、UTF-16、latin-1、GBK、EUC-JP、Shift_JIS 等。</li><li>支持搜索常见格式的压缩文件，如：gzip、xz、lzma、bzip2、lz4 等。</li><li>自动高亮匹配的结果。</li></ul><a id="more"></a><p><strong>Ripgrep 官方性能基准测试结果</strong></p><ul><li>搜索整个 Linux 内核源代码</li></ul><table><thead><tr><th>Tool</th><th>Command</th><th>Line count</th><th>Time</th></tr></thead><tbody><tr><td>ripgrep (Unicode)</td><td><code>rg -n -w '[A-Z]+_SUSPEND'</code></td><td>450</td><td><strong>0.106s</strong></td></tr><tr><td><a href="https://www.kernel.org/pub/software/scm/git/docs/git-grep.html" target="_blank" rel="noopener">git grep</a></td><td><code>LC_ALL=C git grep -E -n -w '[A-Z]+_SUSPEND'</code></td><td>450</td><td>0.553s</td></tr><tr><td><a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="noopener">The Silver Searcher</a></td><td><code>ag -w '[A-Z]+_SUSPEND'</code></td><td>450</td><td>0.589s</td></tr><tr><td><a href="https://www.kernel.org/pub/software/scm/git/docs/git-grep.html" target="_blank" rel="noopener">git grep (Unicode)</a></td><td><code>LC_ALL=en_US.UTF-8 git grep -E -n -w '[A-Z]+_SUSPEND'</code></td><td>450</td><td>2.266s</td></tr><tr><td><a href="https://github.com/svent/sift" target="_blank" rel="noopener">sift</a></td><td><code>sift --git -n -w '[A-Z]+_SUSPEND'</code></td><td>450</td><td>3.505s</td></tr><tr><td><a href="https://github.com/petdance/ack2" target="_blank" rel="noopener">ack</a></td><td><code>ack -w '[A-Z]+_SUSPEND'</code></td><td>1878</td><td>6.823s</td></tr><tr><td><a href="https://github.com/monochromegane/the_platinum_searcher" target="_blank" rel="noopener">The Platinum Searcher</a></td><td><code>pt -w -e '[A-Z]+_SUSPEND'</code></td><td>450</td><td>14.208s</td></tr></tbody></table><table><thead><tr><th>Tool</th><th>Command</th><th>Line count</th><th>Time</th></tr></thead><tbody><tr><td>ripgrep</td><td><code>rg -L -u -tc -n -w '[A-Z]+_SUSPEND'</code></td><td>404</td><td><strong>0.079s</strong></td></tr><tr><td><a href="https://github.com/gvansickle/ucg" target="_blank" rel="noopener">ucg</a></td><td><code>ucg --type=cc -w '[A-Z]+_SUSPEND'</code></td><td>390</td><td>0.163s</td></tr><tr><td><a href="https://www.gnu.org/software/grep/" target="_blank" rel="noopener">GNU grep</a></td><td><code>egrep -R -n --include='*.c' --include='*.h' -w '[A-Z]+_SUSPEND'</code></td><td>404</td><td>0.611s</td></tr></tbody></table><ul><li>在单个大文件上对 Ripgrep 和 GNU Grep 进行比较，文件大小大约 9.3G。</li></ul><table><thead><tr><th>Tool</th><th>Command</th><th>Line count</th><th>Time</th></tr></thead><tbody><tr><td>ripgrep</td><td><code>rg -w 'Sherlock [A-Z]\w+'</code></td><td>5268</td><td><strong>2.108s</strong></td></tr><tr><td><a href="https://www.gnu.org/software/grep/" target="_blank" rel="noopener">GNU grep</a></td><td><code>LC_ALL=C egrep -w 'Sherlock [A-Z]\w+'</code></td><td>5268</td><td>7.014s</td></tr></tbody></table><p><strong>Ripgrep 效果图</strong></p><p><img src="https://www.hi-linux.com/img/linux/ripgrep.png" alt=""></p><h3 id="安装-ripgrep">安装 Ripgrep</h3><p>Ripgrep 具有良好跨平台特性，支持在 Linux、macOS、Windows 等多种平台下安装。官方也提供了各平台对应的二进制版本，下面我们以 Linux 平台为例使用二进制版本进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget  https://github.com/BurntSushi/ripgrep/releases/download/0.10.0/ripgrep-0.10.0-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line">$ tar xzvf ripgrep-0.10.0-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line">$ cp ripgrep-0.10.0-x86_64-unknown-linux-musl/rg  /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>如果你使用其它平台，方法与其类似。你可根据实际情况在官方<a href="https://github.com/BurntSushi/ripgrep/releases" target="_blank" rel="noopener">下载页面</a>下载对应版本进行安装。当然官方也提供了其它多种多样的安装方式，具体可参考官方<a href="https://github.com/BurntSushi/ripgrep#installation" target="_blank" rel="noopener">安装文档</a>。</p><h3 id="ripgrep-语法格式">Ripgrep 语法格式</h3><ul><li>整体语法格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">USAGE:</span><br><span class="line"></span><br><span class="line">    rg [OPTIONS] PATTERN [PATH ...]</span><br><span class="line">    rg [OPTIONS] [-e PATTERN ...] [-f PATTERNFILE ...] [PATH ...]</span><br><span class="line">    rg [OPTIONS] --files [PATH ...]</span><br><span class="line">    rg [OPTIONS] --<span class="built_in">type</span>-list</span><br><span class="line">    <span class="built_in">command</span> | rg [OPTIONS] PATTERN</span><br><span class="line"></span><br><span class="line">ARGS:</span><br><span class="line">    &lt;PATTERN&gt;</span><br><span class="line">            A regular expression used <span class="keyword">for</span> searching. To match a pattern beginning with a</span><br><span class="line">            dash, use the -e/--regexp flag.</span><br><span class="line"></span><br><span class="line">            For example, to search <span class="keyword">for</span> the literal <span class="string">'-foo'</span>, you can use this flag:</span><br><span class="line"></span><br><span class="line">                rg -e -foo</span><br><span class="line"></span><br><span class="line">            You can also use the special <span class="string">'--'</span> delimiter to indicate that no more flags</span><br><span class="line">            will be provided. Namely, the following is equivalent to the above:</span><br><span class="line"></span><br><span class="line">                rg -- -foo</span><br><span class="line"></span><br><span class="line">    &lt;PATH&gt;...</span><br><span class="line">            A file or directory to search. Directories are searched recursively. Paths specified on</span><br><span class="line">            the <span class="built_in">command</span> line override glob and ignore rules.</span><br></pre></td></tr></table></figure><ul><li>支持的命令行选项</li></ul><p>这里我们把一些常用选项做下介绍。</p><table><thead><tr><th>选项</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>-A, --after-context <code>&lt;NUM&gt;</code></td><td>显示匹配内容后的 <code>&lt;NUM&gt;</code> 行。</td><td>会覆盖 <code>--context</code> 选项。</td></tr><tr><td>-B, --before-context <code>&lt;NUM&gt;</code></td><td>显示匹配内容前的 <code>&lt;NUM&gt;</code> 行。</td><td>会覆盖 <code>--context</code> 选项。</td></tr><tr><td>-b, --byte-offset</td><td>显示匹配内容在文件中的字节偏移。</td><td>和 <code>-o</code> 一起使用时只打印偏移。</td></tr><tr><td>-s, --case-sensitive</td><td>启用大小写敏感。</td><td>会覆盖 <code>-i(--ignore case)</code> 和 <code>-S(--smart case)</code> 选项。</td></tr><tr><td>–color <code>&lt;WHEN&gt;</code></td><td>什么时候使用颜色，默认值为：auto。可选值有：never、auto、always、ansi。</td><td>如果 <code>--vimgre</code> 选项被使用，那么默认值是 never。</td></tr><tr><td>–column</td><td>显示匹配所在列数 (从 1 开始)。</td><td>如果不显示列号可用 <code>--no-column</code> 取消掉。</td></tr><tr><td>-C, --context <code>&lt;NUM&gt;</code></td><td>显示匹配内容的前面和后面的 <code>&lt;NUM&gt;</code> 行。</td><td>该选项会覆盖 <code>-B</code> 和 <code>-A</code> 选项。</td></tr><tr><td>–context-separator <code>&lt;SEPARATOR&gt;</code></td><td>在输出结果中分隔非连续的输出行 。</td><td>可以使用<code>\x7F</code> 或 <code>\t</code>，默认是 <code>--</code>。</td></tr><tr><td>-c, --count</td><td>只显示匹配结果的总行数。</td><td>如果只有一个文件给 Ripgrep，那么只打印匹配结果的总行数。可以用 <code>--with-filename</code> 来强制打印文件名，该选项会覆盖 <code>--count-matches</code> 选项。</td></tr><tr><td>–count-matches</td><td>只显示匹配结果的总次数。</td><td>可以用 <code>--with-filename</code> 来强制在只有一个文件时也输出文件名。</td></tr><tr><td>–debug</td><td>显示调试信息。</td><td></td></tr><tr><td>–dfa-size-limit <code>&lt;NUM+SUFFIX?&gt;</code></td><td>指定正则表达式 DFA 的上限，默认为 10M。</td><td>该选项允许接受与 <code>--max-filesize</code> 相同大小的后缀标志。</td></tr><tr><td>-E, --encoding <code>&lt;ENCODING&gt;</code></td><td>指定文本编码格式, 默认是 auto。</td><td>更多编码格式参考：<a href="https://encoding.spec.whatwg.org/#concept-encoding-get" target="_blank" rel="noopener">https://encoding.spec.whatwg.org/#concept-encoding-get</a></td></tr><tr><td>-f, --file <code>&lt;PATTERNFILE&gt;</code>…</td><td>从文件中读入搜索模式, 一行一个模式。</td><td>结合 <code>-e/--regexp</code> 参数可多个文件一起组合使用，所有组合会被匹配。</td></tr><tr><td>–files</td><td>打印所有将被搜索的文件路径。</td><td>以 <code>rg &lt;options&gt; --files [PATH...]</code> 方式使用，不能增加搜索模式。</td></tr><tr><td>-l, --files-with-matches</td><td>只打印有匹配的文件名。</td><td>该选项会覆盖 <code>--files-without-match</code>。</td></tr><tr><td>–files-without-match</td><td>只打印无匹配的文件名。</td><td>该选项会覆盖 <code>--file-with-matches</code>。</td></tr><tr><td>-F, --fixed-strings</td><td>把搜索模式当成常规文字而非正则表达式。</td><td>该选项可以用<code>--no-fixed-strings</code> 来禁止。</td></tr><tr><td>-L, --follow</td><td>该选项会递归搜索符号链接，默认是关闭的。</td><td>该选项可以用 <code>--no-follow</code> 选项来手动关闭。</td></tr><tr><td>-g, --glob <code>&lt;GLOB&gt;</code>…</td><td>包含或排除用于搜索匹配给定的文件和目录，可以用 ! 来取反。</td><td>该选项可以多次使用，会匹配 .gitignore 中的规则。</td></tr><tr><td>-h, --help</td><td>打印帮助信息。</td><td></td></tr><tr><td>–heading</td><td>打印文件名到匹配内容的上方而不是在同一行。</td><td>该选项是默认启用的，可以用 <code>--no-heading</code> 来关闭。</td></tr><tr><td>–hidden</td><td>启用搜索隐藏文件和文件夹。</td><td>默认情况下是忽略搜索隐藏文件和文件夹的, 可用 <code>--no-hidden</code> 来关闭。</td></tr><tr><td>–iglob <code>&lt;GLOB&gt;</code>…</td><td>作用同 <code>--glob</code>, 但这个选项大小写不敏感。</td><td></td></tr><tr><td>-i, --ignore-case</td><td>指定搜索模式中的大小写不敏感。</td><td>该选项会被 <code>-s/--case-sensitive</code> 或 <code>-S/--smart-case</code> 覆盖。</td></tr><tr><td>–ignore-file <code>&lt;PATH&gt;</code>…</td><td>指定搜索时需忽略的路径，格式同 <code>.gitignore</code>, 可同时指定多个。</td><td>如果存在多个 <code>--ignore-file</code> 标记时，后面优先级会更高。</td></tr><tr><td>-v, --invert-match</td><td>反向匹配，显示与给定模式不匹配的行。</td><td></td></tr><tr><td>-n, --line-number</td><td>显示匹配内容所在文件的行数，该选项默认是打开的。</td><td></td></tr><tr><td>-x, --line-regexp</td><td>只显示整行都匹配搜索模式的行。</td><td>该选项会覆盖 <code>--word-regexp</code>。</td></tr><tr><td>-M, --max-columns <code>&lt;NUM&gt;</code></td><td>不打印长于 <code>&lt;NUM&gt;</code> 中指定节字大小的匹配行内容，只显示该行的匹配数。</td><td></td></tr><tr><td>-m, --max-count <code>&lt;NUM&gt;</code></td><td>限制一个文件中最多 <code>&lt;NUM&gt;</code> 行被匹配。</td><td></td></tr><tr><td>–max-depth <code>&lt;NUM&gt;</code></td><td>限制文件夹递归搜索深度。</td><td>如：<code>rg --max-depth 0 dir/</code> 则表示不执行任何搜索。</td></tr><tr><td>–max-filesize <code>&lt;NUM+SUFFIX?&gt;</code></td><td>搜索时忽略大于 <code>&lt;NUM&gt;</code> byte 的文件。</td><td>SUFFIX 的单位可以是：K、M、G，默认是：byte。</td></tr><tr><td>–mmap</td><td>尽量使用 Memory Maps 进行搜索，这样速度会更快。该选项是默认行为。</td><td>如果使用 <code>--mmap</code> 搜索文件时 Ripgrep 发生意外中止，可使用 <code>--no-mmap</code> 选项关闭它。</td></tr><tr><td>–no-config</td><td>不读取 configuration 文件, 并忽略 RIPGREP_CONFIG_PATH 变量。</td><td></td></tr><tr><td>–no-filename</td><td>不要打印匹配文件的文件名。</td><td></td></tr><tr><td>–no-heading</td><td>不在每个匹配行上方打印文件名，而是在匹配行的同一行上打印。</td><td></td></tr><tr><td>–no-ignore</td><td>不读取忽略文件，如：.gitignore、.ignore 等。</td><td>该选项可以用 <code>--ignore</code> 关闭。</td></tr><tr><td>–no-ignore-global</td><td>不读取全局的 ignore 文件，比如: <code>$HOME/.config/git/ignore</code>。</td><td>该选项可以用 <code>--ignore-global</code> 关闭。</td></tr><tr><td>–no-ignore-messages</td><td>取消解析 .ignroe、.gitignore 文件中相关错误信息。</td><td>该选项可通过 <code>--ignore-messages</code> 关闭。</td></tr><tr><td>–no-ignore-parent</td><td>不读取父文件夹里的 .gitignore、.ignore 文件。</td><td>该选项可通过 <code>--ignore-parent</code> 关闭。</td></tr><tr><td>–no-ignore-vcs</td><td>不读取版本控制器中的 .ignore 文件。</td><td>该选项可通过 <code>--ignore-vcs</code> 关闭。</td></tr><tr><td>-N, --no-line-number</td><td>不打印匹配行数。</td><td></td></tr><tr><td>–no-messages</td><td>不打印打开和读取文件时相关错误信息。</td><td></td></tr><tr><td>-0, --null</td><td>在打印的文件路径后加一个 NUL 字符。</td><td>这对于结合 Xargs 使用时是非常有用的。</td></tr><tr><td>-o, --only-matching</td><td>只打印匹配的内容，而不是整行。</td><td></td></tr><tr><td>–passthru</td><td>同时打印文件中匹配和不匹配的行。</td><td></td></tr><tr><td>–path-separator <code>&lt;SEPARATOR&gt;</code></td><td>路径分隔符，在 Linux 上默认是 /，Windows 上默认是 \ 。</td><td></td></tr><tr><td>–pre <code>&lt;COMMAND&gt;</code></td><td>用 <code>&lt;COMMAND&gt;</code> 处理文件后，并将结果传递给 Ripgrep。</td><td>该选项存在一定的性能损耗。</td></tr><tr><td>-p, --pretty</td><td>该选项是 <code>--color always --heading --line-number</code> 的别名。</td><td></td></tr><tr><td>-q, --quiet</td><td>该选项不会打印到标准输出, 如果匹配发现时就停止搜索。</td><td>当 RipGrep 用于 exit 代码时该选项非常有用。</td></tr><tr><td>–regex-size-limit <code>&lt;NUM+SUFFIX?&gt;</code></td><td>设置已编译正则表达式的上限，默认限制为10M。</td><td></td></tr><tr><td>-e, --regexp <code>&lt;PATTERN&gt;</code>…</td><td>使用正则来匹配搜索条件。</td><td>该选项可以多次使用，可打印匹配任何模式的行。</td></tr><tr><td>-r, --replace <code>&lt;REPLACEMENT_TEXT&gt;</code></td><td>用相应文件内容代替匹配内容打印出来。</td><td></td></tr><tr><td>-z, --search-zip</td><td>在 gz、bz2、xz、lzma、lz4 文件类型中搜索。</td><td>该选项可通过 <code>--no-search-zip</code> 关闭。</td></tr><tr><td>-S, --smart-case</td><td>如果全小写，则大小写不敏感，否则大小写敏感。</td><td>该选项可通过 <code>-s/--case-sensitive</code> 和 <code>-i/--ignore-case</code> 来关闭。</td></tr><tr><td>–sort <code>&lt;SORTBY&gt;</code></td><td>将输出结果按升序进行排序，可排序类型有：path、modified、accessed、created 。</td><td></td></tr><tr><td>–sortr <code>&lt;SORTBY&gt;</code></td><td>将输出结果按降序进行排序，可排序类型有：path、modified、accessed、created 。</td><td></td></tr><tr><td>–stats</td><td>打印出统计结果。</td><td></td></tr><tr><td>-a, --text</td><td>搜索二进制文件。</td><td>该选项可通过 <code>--no-text</code> 关闭。</td></tr><tr><td>-j, --threads <code>&lt;NUM&gt;</code></td><td>搜索时要使用的线程数。</td><td></td></tr><tr><td>-t, --type <code>&lt;TYPE&gt;</code>…</td><td>只搜索指定的文件类型。</td><td>可以通过 <code>--type-list</code> 来列出支持的文件类型。</td></tr><tr><td>–type-add <code>&lt;TYPE_SPEC&gt;</code>…</td><td>添加一种文件类型。</td><td></td></tr><tr><td>–type-clear <code>&lt;TYPE&gt;</code>…</td><td>清除默认的文件类型。</td><td></td></tr><tr><td>–type-list</td><td>列出所有内置文件类型。</td><td></td></tr><tr><td>-T, --type-not <code>&lt;TYPE&gt;</code>…</td><td>不要搜索某种文件类型。</td><td></td></tr><tr><td>-u, --unrestricted</td><td><code>-u</code> 搜索.gitignore 里的文件, <code>-uu</code> 搜索隐藏文件，<code>-uuu</code> 搜索二进制文件。</td><td></td></tr><tr><td>-V, --version</td><td>打印版本信息。</td><td></td></tr><tr><td>–vimgrep</td><td>每一次匹配都单独打印一行，如果一行有多次匹配会打印成多行。</td><td></td></tr><tr><td>-H, --with-filename</td><td>打印匹配的文件路径，该选项默认打开。</td><td>该选项可通过 <code>--no-filename</code> 关闭。</td></tr><tr><td>-w, --word-regexp</td><td>把搜索参数作为单独单词匹配。</td><td>该选项会覆盖 <code>--line-regexp</code> 选项。</td></tr></tbody></table><p>更多命令行选项，可通过 <code>rg --help</code> 自行查看。</p><h3 id="ripgrep-使用实例">Ripgrep 使用实例</h3><h4 id="搜索指定文件中包含关键字的内容">搜索指定文件中包含关键字的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'github.com'</span>  README.md</span><br><span class="line">1:&lt;h1 align=<span class="string">"center"</span>&gt;&lt;a title=<span class="string">"New «NexT» 6.0.0 version [Reloaded]"</span> href=<span class="string">"https://github.com/theme-next/hexo-theme-next"</span>&gt;NexT&lt;/a&gt;&lt;/h1&gt;</span><br><span class="line">6:[![mnt-image]](https://github.com/theme-next/hexo-theme-next)</span><br><span class="line">21:More NexT examples [here](https://github.com/iissnan/hexo-theme-next/issues/119).</span><br><span class="line">41:   $ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d <span class="string">'"'</span> -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br><span class="line">51:   $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2 | tar -zxv -C themes/next --strip-components=1</span><br><span class="line">57:   $ git <span class="built_in">clone</span> --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line">67:   $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball | tar -zxv -C themes/next --strip-components=1</span><br><span class="line">73:   $ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line">110:For those who also encounter **Error: Cannot find module <span class="string">'hexo-util'</span>** [issue](https://github.com/iissnan/hexo-theme-next/issues/1490), please check your NPM version.</span><br><span class="line">128:<span class="comment">### Theme configurations using Hexo data files ([#328](https://github.com/iissnan/hexo-theme-next/issues/328))</span></span><br><span class="line">282:NexT uses [Tomorrow Theme](https://github.com/chriskempson/tomorrow-theme) with 5 themes <span class="keyword">for</span> you to choose from.</span><br><span class="line">288:Head over to [Tomorrow Theme](https://github.com/chriskempson/tomorrow-theme) <span class="keyword">for</span> more details.</span><br><span class="line">367:[download-latest-url]: https://github.com/iissnan/hexo-theme-next/archive/master.zip</span><br><span class="line">368:[releases-latest-url]: https://github.com/iissnan/hexo-theme-next/releases/latest</span><br><span class="line">369:[releases-url]: https://github.com/iissnan/hexo-theme-next/releases</span><br><span class="line">370:[tags-url]: https://github.com/iissnan/hexo-theme-next/tags</span><br><span class="line">371:[commits-url]: https://github.com/iissnan/hexo-theme-next/commits/master</span><br></pre></td></tr></table></figure><h4 id="搜索指定文件中包含以关键字开头的单词的内容">搜索指定文件中包含以关键字开头的单词的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'lang\w+'</span> README.md</span><br><span class="line">154:<span class="comment">### Multiple languages support, including:</span></span><br><span class="line">168:Default language is English.</span><br><span class="line">171:language: en</span><br><span class="line">172:<span class="comment"># language: zh-Hans</span></span><br><span class="line">173:<span class="comment"># language: zh-hk</span></span><br><span class="line">174:<span class="comment"># language: zh-tw</span></span><br><span class="line">175:<span class="comment"># language: ru</span></span><br><span class="line">176:<span class="comment"># language: fr-FR</span></span><br><span class="line">177:<span class="comment"># language: de</span></span><br><span class="line">178:<span class="comment"># language: ja</span></span><br><span class="line">179:<span class="comment"># language: id</span></span><br><span class="line">180:<span class="comment"># language: pt</span></span><br><span class="line">181:<span class="comment"># language: pt-BR</span></span><br></pre></td></tr></table></figure><h4 id="搜索指定文件中包含以关键字开头的内容">搜索指定文件中包含以关键字开头的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'hexo\w*'</span> README.md</span><br><span class="line">1:&lt;h1 align=<span class="string">"center"</span>&gt;&lt;a title=<span class="string">"New «NexT» 6.0.0 version [Reloaded]"</span> href=<span class="string">"https://github.com/theme-next/hexo-theme-next"</span>&gt;NexT&lt;/a&gt;&lt;/h1&gt;</span><br><span class="line">3:&lt;p align=<span class="string">"center"</span>&gt;NexT is a high quality elegant &lt;a href=<span class="string">"http://hexo.io"</span>&gt;Hexo&lt;/a&gt; theme. It is crafted from scratch, with love.&lt;/p&gt;</span><br><span class="line">6:[![mnt-image]](https://github.com/theme-next/hexo-theme-next)</span><br><span class="line">9:[![hexo-image]][hexo-url]</span><br><span class="line">21:More NexT examples [here](https://github.com/iissnan/hexo-theme-next/issues/119).</span><br><span class="line">25:**1.** Change dir to **hexo root** directory. There must be `node_modules`, `<span class="built_in">source</span>`, `themes` and other directories:</span><br><span class="line">27:   $ <span class="built_in">cd</span> hexo</span><br><span class="line">41:   $ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d <span class="string">'"'</span> -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br><span class="line">51:   $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2 | tar -zxv -C themes/next --strip-components=1</span><br><span class="line">57:   $ git <span class="built_in">clone</span> --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h4 id="搜索指定目录及子目中包含关键字的内容">搜索指定目录及子目中包含关键字的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'github.com'</span> ./</span><br><span class="line">./src/scrollspy.js</span><br><span class="line">6:* Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)</span><br><span class="line"></span><br><span class="line">./src/affix.js</span><br><span class="line">6: * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)</span><br><span class="line"></span><br><span class="line">./src/js.cookie.js</span><br><span class="line">3: * https://github.com/js-cookie/js-cookie</span><br></pre></td></tr></table></figure><h4 id="搜索以关键字为独立单词的内容">搜索以关键字为独立单词的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ rg -w <span class="string">'github.com'</span> ./</span><br><span class="line">./bower.json</span><br><span class="line">36:    <span class="string">"url"</span> : <span class="string">"http://github.com/julianshapiro/velocity.git"</span></span><br><span class="line"></span><br><span class="line">./velocity.ui.js</span><br><span class="line">58:        var abortError = <span class="string">"Velocity UI Pack: You need to update Velocity (jquery.velocity.js) to a newer version. Visit http://github.com/julianshapiro/velocity."</span>;</span><br><span class="line"></span><br><span class="line">./velocity.js</span><br><span class="line">442:    /* IE detection. Gist: https://gist.github.com/julianshapiro/9098609 */</span><br><span class="line">463:    /* rAF shim. Gist: https://gist.github.com/julianshapiro/9497513 */</span><br><span class="line">472:            /* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */</span><br><span class="line">480:    /* Array compacting. Copyright Lo-Dash. MIT License: https://github.com/lodash/lodash/blob/master/LICENSE.txt */</span><br><span class="line">522:        /* Copyright Martin Bohm. MIT License: https://gist.github.com/Tomalak/818a78a226a0738eaade */</span><br></pre></td></tr></table></figure><h4 id="搜索包含关键字内容的文件并且只打印文件名">搜索包含关键字内容的文件并且只打印文件名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rg -w <span class="string">'github.com'</span> ./ -l</span><br><span class="line">./velocity.js</span><br><span class="line">./bower.json</span><br><span class="line">./velocity.ui.js</span><br><span class="line">./velocity.ui.min.js</span><br></pre></td></tr></table></figure><h4 id="在指定文件类型格式为-js-的文件中搜索包含关键字的内容">在指定文件类型格式为 JS 的文件中搜索包含关键字的内容</h4><p>RipGrep 实现的方式存在多种多样，这里介绍比较常用的两种。</p><ul><li>第一种：使用 <code>--type</code> 选项指定文件类型。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'function writeOnCanvas'</span> --<span class="built_in">type</span> js</span><br><span class="line"><span class="built_in">source</span>/lib/Han/dist/han.js</span><br><span class="line">1726:<span class="keyword">function</span> writeOnCanvas( text, font ) &#123;</span><br></pre></td></tr></table></figure><ul><li>第二种：使用 <code>--glob</code> 选项来通配需要的文件类型。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rg  <span class="string">'function writeOnCanvas'</span> -g <span class="string">'*.js'</span></span><br><span class="line"><span class="built_in">source</span>/lib/Han/dist/han.js</span><br><span class="line">1726:<span class="keyword">function</span> writeOnCanvas( text, font ) &#123;</span><br></pre></td></tr></table></figure><p>如果要同时搜索多个文件类型可以写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'Hanzi'</span> -g <span class="string">'*.&#123;js,css&#125;'</span></span><br><span class="line">han.min.js</span><br><span class="line">2:/*! Han.css: the CSS typography framework optimised <span class="keyword">for</span> Hanzi */</span><br><span class="line"></span><br><span class="line">han.js</span><br><span class="line">3: * Han.css: the CSS typography framework optimised <span class="keyword">for</span> Hanzi</span><br><span class="line">48:  // Address Hanzi and Western script mixed spacing</span><br><span class="line">426:    /* Hanzi and Western mixed spacing </span><br><span class="line"></span><br><span class="line">han.css</span><br><span class="line">4:/*! Han.css: the CSS typography framework optimised <span class="keyword">for</span> Hanzi */</span><br><span class="line"></span><br><span class="line">han.min.css</span><br><span class="line">4:/*! Han.css: the CSS typography framework optimised <span class="keyword">for</span> Hanzi */</span><br></pre></td></tr></table></figure><h4 id="在当前目下并且不包含文件类型格式为-css-的文件中搜索包含关键字的内容">在当前目下并且不包含文件类型格式为 CSS 的文件中搜索包含关键字的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'revertVowel'</span> --<span class="built_in">type</span>-not css</span><br><span class="line"><span class="built_in">source</span>/lib/Han/dist/han.min.js</span><br><span class="line">(this[<span class="string">"comb-liga-zhuyin"</span>]=O.substZhuyinCombLiga(this.context)),this&#125;,revertVowelCombLiga:<span class="function"><span class="title">function</span></span>()&#123;try&#123;this[<span class="string">"comb-liga-vowel"</span>].revert(<span class="string">"all"</span>)&#125;catch(a)&#123;&#125;<span class="built_in">return</span> this&#125;,revertVowelICombLiga:<span class="function"><span class="title">function</span></span>()&#123;try&#123;this[<span class="string">"comb-liga-vowel-i"</span>].revert(<span class="string">"all"</span>)&#125;catch(a)&#123;&#125;<span class="built_in">return</span> this&#125;,revertZhuyinCombLiga:<span class="function"><span class="title">function</span></span>()&#123;try&#123;this[<span class="string">"comb-liga-zhuyin"</span>].revert(<span class="string">"all"</span>)&#125;catch(a)&#123;&#125;<span class="built_in">return</span> this&#125;,revertCombLigaWithPUA:<span class="function"><span class="title">function</span></span>()&#123;try&#123;this[<span class="string">"comb-liga-vowel"</span>].revert(<span class="string">"all"</span>),this[<span class="string">"comb-liga-vowel-i"</span>].revert(<span class="string">"all"</span>),this[<span class="string">"comb-liga-zhuyin"</span>].revert(<span class="string">"all"</span>)&#125;catch(a)&#123;&#125;<span class="built_in">return</span> this&#125;,substInaccurateChar:<span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> this[<span class="string">"inaccurate-char"</span>]=O.substInaccurateChar(this.context),this&#125;,revertInaccurateChar:<span class="function"><span class="title">function</span></span>()&#123;try&#123;this[<span class="string">"inaccurate-char"</span>].revert(<span class="string">"all"</span>)&#125;catch(a)&#123;&#125;<span class="built_in">return</span> this&#125;&#125;),a.addEventListener(<span class="string">"DOMContentLoaded"</span>,<span class="function"><span class="title">function</span></span>()&#123;var a;K.classList.contains(<span class="string">"han-init"</span>)?O.init():(a=J.querySelector(<span class="string">".han-init-context"</span>))&amp;&amp;(O.init=O(a).render())&#125;),(<span class="string">"undefined"</span>==typeof b||b===!1)&amp;&amp;(a.Han=O),O&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span>/lib/Han/dist/han.js</span><br><span class="line">2939:  revertVowelCombLiga: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">2946:  revertVowelICombLiga: <span class="function"><span class="title">function</span></span>() &#123;</span><br></pre></td></tr></table></figure><p>你也可以用下面的更简洁的写法来达到同样的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rg &#39;revertVowel&#39; -Tcss</span><br></pre></td></tr></table></figure><h4 id="使用正则表达式进行关键字搜索">使用正则表达式进行关键字搜索</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ rg -e <span class="string">"noConf.*lict"</span> ./</span><br><span class="line">./js.cookie.js</span><br><span class="line">21:api.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"></span><br><span class="line">./scrollspy.js</span><br><span class="line">166:  $.fn.scrollspy.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"></span><br><span class="line">./affix.js</span><br><span class="line">139:  $.fn.affix.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br></pre></td></tr></table></figure><h4 id="搜索匹配关键字的内容及显示其上下内容各两行">搜索匹配关键字的内容及显示其上下内容各两行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$  rg -e <span class="string">"noConf.*lict"</span>  -C2</span><br><span class="line">js.cookie.js</span><br><span class="line">19-var OldCookies = window.Cookies;</span><br><span class="line">20-var api = window.Cookies = factory();</span><br><span class="line">21:api.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">22-window.Cookies = OldCookies;</span><br><span class="line">23-<span class="built_in">return</span> api;</span><br><span class="line"></span><br><span class="line">scrollspy.js</span><br><span class="line">164-  // =====================</span><br><span class="line">165-</span><br><span class="line">166:  $.fn.scrollspy.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">167-    $.fn.scrollspy = old</span><br><span class="line">168-    <span class="built_in">return</span> this</span><br><span class="line"></span><br><span class="line">affix.js</span><br><span class="line">137-  // =================</span><br><span class="line">138-</span><br><span class="line">139:  $.fn.affix.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">140-    $.fn.affix = old</span><br><span class="line">141-    <span class="built_in">return</span> this</span><br></pre></td></tr></table></figure><h4 id="搜索不包含关键字的内容">搜索不包含关键字的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ rg -v <span class="string">"hexo"</span> merge-configs.js</span><br><span class="line">2:</span><br><span class="line">3:var merge = require(<span class="string">'./merge'</span>);</span><br><span class="line">4:</span><br><span class="line">5:/**</span><br><span class="line">8: */</span><br><span class="line">12:    <span class="keyword">if</span> ( data &amp;&amp; data.next ) &#123;</span><br><span class="line">13:      <span class="keyword">if</span> ( data.next.override ) &#123;</span><br><span class="line">15:      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">17:      &#125;</span><br><span class="line">18:    &#125;</span><br><span class="line">19:  &#125;</span><br><span class="line">20:&#125;);</span><br><span class="line">21:</span><br><span class="line">30:&#125;);</span><br></pre></td></tr></table></figure><h4 id="搜索关键字并只显示关键字部分的内容">搜索关键字并只显示关键字部分的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ rg -e <span class="string">"hexo.*warn"</span> -o ./</span><br><span class="line">./tags/lazy-image.js</span><br><span class="line">12:hexo.log.warn</span><br><span class="line"></span><br><span class="line">./merge-configs.js</span><br><span class="line">23:hexo.log.warn</span><br><span class="line">24:hexo.log.warn</span><br><span class="line">25:hexo.log.warn</span><br><span class="line">26:hexo.log.warn</span><br><span class="line">27:hexo.log.warn</span><br><span class="line">28:hexo.log.warn</span><br><span class="line">29:hexo.log.warn</span><br><span class="line"></span><br><span class="line">./tags/button.js</span><br><span class="line">13:hexo.log.warn</span><br><span class="line"></span><br><span class="line">./tags/full-image.js</span><br><span class="line">12:hexo.log.warn</span><br></pre></td></tr></table></figure><h4 id="搜索关键字并忽略关键字大小写的内容">搜索关键字并忽略关键字大小写的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rg -ie &quot;Return.*&quot; merge.js</span><br><span class="line">103:var root &#x3D; freeGlobal || freeSelf || Function(&#39;return this&#39;)();</span><br><span class="line">120:    return freeProcess &amp;&amp; freeProcess.binding(&#39;util&#39;);</span><br><span class="line">134: * @returns &#123;Object&#125; Returns &#96;map&#96;.</span><br><span class="line">137:  &#x2F;&#x2F; Don&#39;t return &#96;map.set&#96; because it&#39;s not chainable in IE 11.</span><br><span class="line">139:  return map;</span><br><span class="line">148: * @returns &#123;Object&#125; Returns &#96;set&#96;.</span><br><span class="line">151:  &#x2F;&#x2F; Don&#39;t return &#96;set.add&#96; because it&#39;s not chainable in IE 11.</span><br></pre></td></tr></table></figure><h4 id="把关键字当成常量字符进行搜索">把关键字当成常量字符进行搜索</h4><p>关键字中包含 <code>.(){}*+</code> 类似字符时，不需要手动转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rg -F <span class="string">"i++)"</span> ./</span><br><span class="line">./tags/exturl.js</span><br><span class="line">27:  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">./tags/group-pictures.js</span><br><span class="line">795:    <span class="keyword">for</span> (var i = 0; i &lt; rows; i++) &#123;</span><br><span class="line">805:    <span class="keyword">for</span> (var i = 0; i &lt; rows.length; i++) &#123;</span><br><span class="line">825:    <span class="keyword">for</span> (var i = 0; i &lt; pictures.length; i++) &#123;</span><br></pre></td></tr></table></figure><p>如果要搜索的字符是以 <code>-</code> 开头时，要用 <code>--</code> 来作为分隔符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ rg -- -1 merge.js</span><br><span class="line">190:  var index &#x3D; -1,</span><br><span class="line">210:  var index &#x3D; -1,</span><br><span class="line">233:  var index &#x3D; -1,</span><br><span class="line">255:  var index &#x3D; -1,</span><br><span class="line">317:  var index &#x3D; -1,</span><br><span class="line">348:  var index &#x3D; -1,</span><br><span class="line">435:  var index &#x3D; -1,</span><br><span class="line">533:  var index &#x3D; -1,</span><br><span class="line">605:  return assocIndexOf(this.__data__, key) &gt; -1;</span><br><span class="line">645:  var index &#x3D; -1,</span><br><span class="line">889: * @returns &#123;number&#125; Returns the index of the matched value, else &#96;-1&#96;.</span><br><span class="line">898:  return -1;</span><br></pre></td></tr></table></figure><p>或者使用 <code>-e</code> 参数也可以达到类似目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rg -e <span class="string">"-1"</span> <span class="built_in">source</span>/js</span><br><span class="line"><span class="built_in">source</span>/js/src/js.cookie.js</span><br><span class="line">113:cookie = cookie.slice(1, -1);</span><br><span class="line">155:expires: -1</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span>/js/src/motion.js</span><br><span class="line">190:    cursor: -1,</span><br><span class="line">223:        getMistLineSettings(<span class="variable">$logoLineBottom</span>, <span class="string">'-100%'</span>)</span><br></pre></td></tr></table></figure><h4 id="打印当前目下所有将被搜索的文件列表">打印当前目下所有将被搜索的文件列表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ rg --files</span><br><span class="line">merge.js</span><br><span class="line">merge-configs.js</span><br><span class="line">tags/lazy-image.js</span><br><span class="line">tags/center-quote.js</span><br><span class="line">tags/tabs.js</span><br><span class="line">tags/note.js</span><br><span class="line">tags/button.js</span><br><span class="line">tags/full-image.js</span><br><span class="line">tags/group-pictures.js</span><br><span class="line">tags/label.js</span><br><span class="line">tags/exturl.js</span><br></pre></td></tr></table></figure><h4 id="输出所有内置可识别文件类型">输出所有内置可识别文件类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ rg --type-list</span><br><span class="line">agda: *.agda, *.lagda</span><br><span class="line">aidl: *.aidl</span><br><span class="line">amake: *.bp, *.mk</span><br><span class="line">asciidoc: *.adoc, *.asc, *.asciidoc</span><br><span class="line">asm: *.S, *.asm, *.s</span><br><span class="line">ats: *.ats, *.dats, *.hats, *.sats</span><br><span class="line">avro: *.avdl, *.avpr, *.avsc</span><br><span class="line">awk: *.awk</span><br><span class="line">bazel: *.bzl, BUILD, WORKSPACE</span><br><span class="line">bitbake: *.bb, *.bbappend, *.bbclass, *.conf, *.inc</span><br><span class="line">bzip2: *.bz2</span><br><span class="line">c: *.H, *.c, *.cats, *.h</span><br><span class="line">cabal: *.cabal</span><br><span class="line">cbor: *.cbor</span><br><span class="line">ceylon: *.ceylon</span><br><span class="line">clojure: *.clj, *.cljc, *.cljs, *.cljx</span><br><span class="line">cmake: *.cmake, CMakeLists.txt</span><br><span class="line">coffeescript: *.coffee</span><br><span class="line">config: *.cfg, *.conf, *.config, *.ini</span><br><span class="line">cpp: *.C, *.H, *.cc, *.cpp, *.cxx, *.h, *.hh, *.hpp, *.hxx, *.inl</span><br><span class="line">creole: *.creole</span><br><span class="line">crystal: *.cr, Projectfile</span><br><span class="line">cs: *.cs</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="自定义搜索文件类型">自定义搜索文件类型</h4><p>默认情况下，Ripgrep 附带了一堆预定义的类型。 通常，这些类型对应于众所周知的公共格式。 您也可以定义自己的类型，例如：您可能经常搜索 Web 类型文件，其中包含 Javascript、HTML 和 CSS 类型的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ rg --type-add &#39;web:*.html&#39; --type-add &#39;web:*.css&#39; --type-add &#39;web:*.js&#39; -tweb display</span><br><span class="line">han.css</span><br><span class="line">28:  display: block;</span><br><span class="line">34:  display: inline-block;</span><br><span class="line">37:  display: none;</span><br><span class="line">45:  display: none;</span><br><span class="line">174:  display: table; &#x2F;* 1 *&#x2F;</span><br><span class="line"></span><br><span class="line">han.js</span><br><span class="line">442:    &#x2F;&#x2F; The feature displays the following characters</span><br><span class="line">446:    &#39;display-as&#39;: &#123;</span><br><span class="line">1732:  canvas.style.display &#x3D; &#39;none&#39;</span><br></pre></td></tr></table></figure><p>也可以直接简写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rg --type-add &#39;web:*.&#123;html,css,js&#125;&#39; -tweb display</span><br></pre></td></tr></table></figure><p>不过有一点是要注意的，上面增加的 Web 类型文件是临时的，只对当前命令有效。如果需要长期使用自定义的类型，你可以新增一个别名来在每次运行 RipGrep 时自动增加对应的文件类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ alias rg&#x3D;&quot;rg --type-add &#39;web:*.&#123;html,css,js&#125;&#39;&quot;</span><br></pre></td></tr></table></figure><p>当然还有另一种方法来达到类似的目的，那就是使用 RipGrep 的配置文件，RipGrep 的配置文件默认为 <code>$HOME/.ripgreprc</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="variable">$HOME</span>/.ripgreprc</span><br><span class="line"><span class="comment"># Don't let ripgrep vomit really long lines to my terminal.</span></span><br><span class="line">--max-columns=150</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add my 'web' type.</span></span><br><span class="line">--<span class="built_in">type</span>-add</span><br><span class="line">web:*.&#123;html,css,js&#125;*</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using glob patterns to include/exclude files or folders</span></span><br><span class="line">--glob=!git/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">--glob</span><br><span class="line">!git/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the colors.</span></span><br><span class="line">--colors=line:none</span><br><span class="line">--colors=line:style:bold</span><br><span class="line"></span><br><span class="line"><span class="comment"># Because who cares about case!?</span></span><br><span class="line">--smart-case</span><br></pre></td></tr></table></figure><h4 id="将包含关键字的内容在查找结果中进行替换">将包含关键字的内容在查找结果中进行替换</h4><p>RipGrep 提供了一个在查找过程中直接将关键字内容进行替换的功能，下面我们来看一个将关键字中部分内容的小写字母转大写字母的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ rg browse README.md --replace Browse</span><br><span class="line">305:<span class="comment"># can be any image format supported by web Browsers (JPEG,PNG,GIF,SVG,..)</span></span><br><span class="line">322:![Browser-image]</span><br><span class="line">324:[![Browser Stack](.github/Browserstack_logo.png)](https://www.Browserstack.com/)</span><br><span class="line">325:&gt;**BrowserStack** is a cloud-based cross-Browser testing tool that enables developers to <span class="built_in">test</span> their websites across various Browsers on different operating systems and mobile devices, without requiring users to install virtual machines, devices or emulators.</span><br><span class="line">343:[Browser-image]: https://img.shields.io/badge/Browser-%20chrome%20%7C%20firefox%20%7C%20opera%20%7C%20safari%20%7C%20ie%20%3E%3D%209-lightgrey.svg</span><br><span class="line">344:[Browser-url]: https://www.Browserstack.com</span><br></pre></td></tr></table></figure><p>上面的结果实质上只是在标准输出中进行替换，并不会对实际文件进行修改。如果你需要对实际文件进行修改，你可以结合 Sed 命令来达到目的。</p><ul><li>如果你使用 GNU Sed (CentOS、Ubuntu 等各种 Linux 发行版)，可以使用以下命令。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rg browse --files-with-matches | xargs sed -i <span class="string">'s/browse/Browse/g'</span></span><br></pre></td></tr></table></figure><ul><li>如果您使用 BSD Sed（ macOS 和 FreeBSD），则必须将以上命令修改为以下命令。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rg browse --files-with-matches | xargs sed -i <span class="string">''</span> <span class="string">'s/browse/Browse/g'</span></span><br></pre></td></tr></table></figure><blockquote><p>BSD Sed 中的 -i 标志需要提供文件扩展名以对所有已修改的文件进行备份，这里指定空字符串可防止进行文件备份。</p></blockquote><ul><li>如果您的文件路径中包含空格，则需要使用 NUL 终结符分隔文件路径。这里就需要使用 <code>-0</code> 参数来告诉 Ripgrep 在每个路径之间输出 NUL 字节，并告诉 Xargs 读取由 NUL 字节分隔的路径。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rg Browse --files-with-matches -0 | xargs -0 sed -i &#39;&#39; &#39;s&#x2F;Browse&#x2F;browse&#x2F;g&#39;</span><br></pre></td></tr></table></figure><h4 id="直接在压缩文件中搜索包含关键字的内容">直接在压缩文件中搜索包含关键字的内容</h4><p>Ripgrep 目前仅支持 gzip、bzip2、lzma、lz4 和 xz 这几种压缩格式，并且需要在系统上已安装相应的 gzip，bzip2 和 xz 工具包。也就是说，Ripgrep 是通过 Shelling 到另一个进程来进行解压缩的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rg -z license UNLICENSE.gz</span><br><span class="line">24:For more information, please refer to &lt;http://unlicense.org/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Ripgrep 目前不会搜索存档格式，因此会跳过 *.tar.gz 文件。</p></blockquote><h4 id="自动补全功能">自动补全功能</h4><p>RipGrep 提供的二进制包中默认提供了 SHELL 自动补全功能，只需根据不同 SHELL 放到对应目录即可使用了。</p><ul><li>Bash</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv rg.bash <span class="variable">$XDG_CONFIG_HOME</span>/bash_completion/</span><br><span class="line">或者</span><br><span class="line">$ mv rg.bash /etc/bash_completion.d/</span><br></pre></td></tr></table></figure><ul><li>ZSH</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv _rg <span class="variable">$fpath</span>/</span><br></pre></td></tr></table></figure><ul><li>Fish</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv rg.fish <span class="variable">$HOME</span>/.config/fish/completions/</span><br></pre></td></tr></table></figure><h3 id="参考文档">参考文档</h3><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a><br><a href="http://t.cn/ROI5tMv" target="_blank" rel="noopener">http://t.cn/ROI5tMv</a><br><a href="http://t.cn/Rs3caWW" target="_blank" rel="noopener">http://t.cn/Rs3caWW</a><br><a href="http://t.cn/Rs3F6Ty" target="_blank" rel="noopener">http://t.cn/Rs3F6Ty</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ripgrep 是命令行下一个基于行的搜索工具，RipGrep 使用 Rust 开发，可以在多平台下运行，支持 Mac、Linux 和 Windows 等平台。RipGrep 与 The Silver Searcher、Ack 和 GNU Grep 的功能类似。&lt;/p&gt;
&lt;p&gt;RipGrep 官方号称比其它类似工具在搜索速度上快上 N 倍，VSCode 也从 &lt;a href=&quot;https://code.visualstudio.com/updates/v1_11#_text-search-improvements&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1.11 版本&lt;/a&gt;开始默认将 RipGrep 做为其搜索工具，由此其功能强大可见一斑。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/BurntSushi/ripgrep&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/BurntSushi/ripgrep&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ripgrep 支持的一些特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动递归搜索 （grep 需要 -R）。&lt;/li&gt;
&lt;li&gt;自动忽略 .gitignore 中的文件以及二进制文件和隐藏文件。&lt;/li&gt;
&lt;li&gt;可以搜索指定文件类型，如：&lt;code&gt;rg -tpy foo&lt;/code&gt; 则限定只搜索 Python 文件，&lt;code&gt;rg -Tjs foo&lt;/code&gt; 则排除掉 JS 文件。&lt;/li&gt;
&lt;li&gt;支持大部分 Grep 的 特性，例如：显示搜索结果的上下文、支持多个模式搜索、高亮匹配的搜索结果以及支持 Unicode 等。&lt;/li&gt;
&lt;li&gt;支持各种文本编码格式，如：UTF-8、UTF-16、latin-1、GBK、EUC-JP、Shift_JIS 等。&lt;/li&gt;
&lt;li&gt;支持搜索常见格式的压缩文件，如：gzip、xz、lzma、bzip2、lz4 等。&lt;/li&gt;
&lt;li&gt;自动高亮匹配的结果。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你打造高效的 Kubernetes 命令行终端</title>
    <link href="https://www.hi-linux.com/posts/44953.html"/>
    <id>https://www.hi-linux.com/posts/44953.html</id>
    <published>2018-09-13T01:00:00.000Z</published>
    <updated>2018-09-13T02:34:56.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Kubernetes 作为云原生时代的操作系统，熟悉和使用它是每名用户的必备技能。本文将介绍一些提高操作 Kubernetes 效率的技巧以及如何打造一个高效的 Kubernetes 命令行终端的方法。</p><h3 id="kubectl-自动补全">Kubectl 自动补全</h3><p>Kubectl 这个命令行工具非常重要，与之相关的命令也很多。我们也记不住那么多的命令，而且也会经常写错，所以命令行自动补全是很有必要的。Kubectl 工具本身就支持自动补全，只需简单设置一下即可。</p><ul><li>Bash 用户</li></ul><p>大多数用户的 Shell 使用的是 Bash，Linux 系统可以通过下面的命令来设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"source &lt;(kubectl completion bash)"</span> &gt;&gt; ~/.bashrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>如果发现不能自动补全，可以尝试安装 <code>bash-completion</code> 然后刷新即可！</p><ul><li>ZSH 用户</li></ul><p>如果你使用的 Shell 是 ZSH，可以通过下面的命令来设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"source &lt;(kubectl completion zsh)"</span> &gt;&gt; ~/.zshrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="交互式-kubernetes-客户端">交互式 Kubernetes 客户端</h3><h4 id="kube-prompt">Kube-prompt</h4><p>Kube-prompt 可以让你在命令行下接受与 Kubectl 相同的命令，并且不需要提供 Kubectl前缀。Kube-prompt 还提了交互式会话下的命令提示、自动补全等功能。</p><p>项目地址：<a href="https://github.com/c-bata/kube-prompt" target="_blank" rel="noopener">https://github.com/c-bata/kube-prompt</a></p><p><strong>安装 Kube-prompt</strong></p><p>Kube-prompt 使用 Go 语言开发，天生良好的跨平台性。安装起来非常简单，只需下载各平台对应的二进制版本就可以开箱即用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Linux</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;c-bata&#x2F;kube-prompt&#x2F;releases&#x2F;download&#x2F;v1.0.3&#x2F;kube-prompt_v1.0.3_linux_amd64.zip</span><br><span class="line">$ unzip kube-prompt_v1.0.3_linux_amd64.zip</span><br><span class="line"></span><br><span class="line"># macOS (darwin)</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;c-bata&#x2F;kube-prompt&#x2F;releases&#x2F;download&#x2F;v1.0.3&#x2F;kube-prompt_v1.0.3_darwin_amd64.zip</span><br><span class="line">$ unzip kube-prompt_v1.0.3_darwin_amd64.zip</span><br><span class="line"></span><br><span class="line"># 给 kube-prompt 加上执行权限并移动常用的可搜索路径。</span><br><span class="line">$ chmod +x kube-prompt</span><br><span class="line">$ sudo mv .&#x2F;kube-prompt &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kube-prompt</span><br></pre></td></tr></table></figure><p><strong>Kube-prompt 使用效果图</strong></p><p><img src="https://www.hi-linux.com/img/linux/kube-prompt.gif" alt=""></p><h4 id="kube-shell">Kube-shell</h4><p>Kube-shell 可以为 Kubectl 提供自动的命令提示和补全，Kube-shell 与 Kube-prompt 的使用方法类似。</p><p>项目地址：<a href="https://github.com/cloudnativelabs/kube-shell" target="_blank" rel="noopener">https://github.com/cloudnativelabs/kube-shell</a></p><p><strong>Kube-shell 特性</strong></p><ul><li>命令提示，给出命令的使用说明。</li><li>自动补全，列出可选命令并可以通过 TAB 键自动补全，支持模糊搜索。</li><li>支持语法高亮。</li><li>使用 TAB 键可以列出可选的对象。</li><li>支持 VIM 模式。</li></ul><p><strong>安装 Kube-shell</strong></p><p>Kube-shell 安装非常的简单，使用 PIP 就可以一键安装了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install kube-shell</span><br></pre></td></tr></table></figure><blockquote><p>注：kube-shell 必须用 root 用户运行。如果是普通用户运行会报 <code>/bin/sh: 1: kubectl: not found</code> 错误。即使使用了 <code>sudo  kube-shell</code> 同样也是不行的。</p></blockquote><p><strong>Kube-shell 使用效果图</strong></p><p><img src="https://www.hi-linux.com/img/linux/kube-shell.gif" alt=""></p><blockquote><p>注：Kube-prompt 和 Kube-shell 我都使用过，更推荐 Kube-prompt。Go 的原生性更好一些，并且 Kube-prompt 也不需要 root 权限。</p></blockquote><h3 id="kubectl-aliases">Kubectl Aliases</h3><p>Kubectl Aliases 是一个通过编程方式生成的 Kubectl 别名脚本。如果你需要频繁地使用 Kubectl 和 Kubernetes API 进行交互，使用别名将会为你节省大量的时间。</p><p>项目地址: <a href="https://github.com/ahmetb/kubectl-aliases" target="_blank" rel="noopener">https://github.com/ahmetb/kubectl-aliases</a></p><p><strong>安装 Kubectl Aliases</strong></p><p>Kubectl Aliases 就只是一个 SHELL 脚本，你只需直接下载 <code>.kubectl_aliases</code> 文件并将其保存在 <code>$HOME</code> 目录中，然后在 <code>SHELL</code> 配置文件中调用即可。</p><ul><li>下载脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">$ wget https://raw.githubusercontent.com/ahmetb/kubectl-alias/master/.kubectl_aliases</span><br></pre></td></tr></table></figure><ul><li>配置 SHELL</li></ul><p>Bash 用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br><span class="line"></span><br><span class="line">[ -f ~/.kubectl_aliases ] &amp;&amp; <span class="built_in">source</span> ~/.kubectl_aliases</span><br></pre></td></tr></table></figure><p>ZSH 用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.zshrc</span><br><span class="line"></span><br><span class="line">[ -f ~/.kubectl_aliases ] &amp;&amp; <span class="built_in">source</span> ~/.kubectl_aliases</span><br></pre></td></tr></table></figure><p>如果你想在运行之前打印完整的 Kubectl 命令，可以加上以下行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">kubectl</span></span>() &#123; <span class="built_in">echo</span> <span class="string">"+ kubectl <span class="variable">$@</span>"</span>; <span class="built_in">command</span> kubectl <span class="variable">$@</span>; &#125;</span><br></pre></td></tr></table></figure><p><strong>Kubectl 别名生成规则</strong></p><p><img src="https://www.hi-linux.com/img/linux/kubectl-alias.jpeg" alt=""></p><p><strong>Kubectl 别名使用示例</strong></p><ul><li>简单别名示例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kd → kubectl describe</span><br></pre></td></tr></table></figure><ul><li>高级别名示例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kgdepallw → kubectl get deployment –all-namespaces –watch</span><br></pre></td></tr></table></figure><h3 id="kubeval">Kubeval</h3><p>如果你手动写 Kubernetes manifest 文件，检查 manifest 文件的语法是否有误是很困难的，特别是当你有多个不同版本的 Kubernetes 集群时，确认配置文件语法是否正确更是难上加难。</p><p>Kubeval 是一个用于校验 Kubernetes YAML 或 JSON 配置文件的工具，支持多个 Kubernetes 版本，可以帮助我们解决不少的麻烦。</p><p>项目地址：<a href="https://github.com/garethr/kubeval" target="_blank" rel="noopener">https://github.com/garethr/kubeval</a></p><p><strong>Kubeval 安装</strong></p><p>Kubeval 同样是一款使用 Go 语言开发，天生良好的跨平台性。安装起来非常简单，只需下载各平台对应的二进制版本就可以开箱即用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Linux</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;garethr&#x2F;kubeval&#x2F;releases&#x2F;download&#x2F;0.7.1&#x2F;kubeval-linux-amd64.tar.gz</span><br><span class="line">$ tar xf kubeval-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># macOS (darwin)</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;garethr&#x2F;kubeval&#x2F;releases&#x2F;download&#x2F;0.7.1&#x2F;kubeval-darwin-amd64.tar.gz</span><br><span class="line">$ tar xf kubeval-darwin-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 给 kubeval 加上执行权限并移动常用的可搜索路径。</span><br><span class="line">$ chmod +x kubeval</span><br><span class="line">$ sudo mv kubeval &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><p><strong>Kubeval 使用示例</strong></p><ul><li>Kubernetes manifest 文件正常的情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubeval nginx-deployment.yaml</span><br><span class="line">The document nginx-deployment.yaml contains a valid Deployment</span><br></pre></td></tr></table></figure><ul><li>Kubernetes manifest 文件不正常的情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubeval nginx.yaml</span><br><span class="line"></span><br><span class="line">The document nginx.yaml contains an invalid Deployment</span><br><span class="line">---&gt; spec.replicas: Invalid type. Expected: integer, given: string</span><br></pre></td></tr></table></figure><h3 id="其它一些实用工具">其它一些实用工具</h3><p>下面这几个工具也挺不错的，使用起来都很简单。就不展开讲了，如果有兴趣可以去看下官方文档具体的使用方法。</p><ul><li>Kube-ps1</li></ul><p>该工具主要作用为命令行终端增加一个提示符。</p><p>项目地址：<a href="https://github.com/jonmosco/kube-ps1" target="_blank" rel="noopener">https://github.com/jonmosco/kube-ps1</a></p><p>Kube-ps1 使用效果图</p><p><img src="https://www.hi-linux.com/img/linux/kube-ps1.gif" alt=""></p><ul><li>Kubectx</li></ul><p>该工具主要作用是快速在多个 Kubernetes 集群中切换。</p><p>项目地址：<a href="https://github.com/ahmetb/kubectx" target="_blank" rel="noopener">https://github.com/ahmetb/kubectx</a></p><p>Kubectx 使用效果图</p><p><img src="https://www.hi-linux.com/img/linux/kubectx-demo.gif" alt=""></p><ul><li>Kubens</li></ul><p>该工具可以帮助您快速的在 Kubernetes 的多个命名空间之间切换。</p><p>项目地址：<a href="https://github.com/ahmetb/kubectx" target="_blank" rel="noopener">https://github.com/ahmetb/kubectx</a></p><p>Kubens 使用效果图</p><p><img src="https://www.hi-linux.com/img/linux/kubens-demo.gif" alt=""></p><h3 id="参考文档">参考文档</h3><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a><br><a href="http://t.cn/RD6vxGf" target="_blank" rel="noopener">http://t.cn/RD6vxGf</a><br><a href="http://t.cn/RD6vbc1" target="_blank" rel="noopener">http://t.cn/RD6vbc1</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 作为云原生时代的操作系统，熟悉和使用它是每名用户的必备技能。本文将介绍一些提高操作 Kubernetes 效率的技巧以及如何打造一个高效的 Kubernetes 命令行终端的方法。&lt;/p&gt;
&lt;h3 id=&quot;Kubectl-自动补全&quot;&gt;Kubectl 自动补全&lt;/h3&gt;
&lt;p&gt;Kubectl 这个命令行工具非常重要，与之相关的命令也很多。我们也记不住那么多的命令，而且也会经常写错，所以命令行自动补全是很有必要的。Kubectl 工具本身就支持自动补全，只需简单设置一下即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bash 用户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大多数用户的 Shell 使用的是 Bash，Linux 系统可以通过下面的命令来设置：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;source &amp;lt;(kubectl completion bash)&quot;&lt;/span&gt; &amp;gt;&amp;gt; ~/.bashrc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt; ~/.bashrc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果发现不能自动补全，可以尝试安装 &lt;code&gt;bash-completion&lt;/code&gt; 然后刷新即可！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ZSH 用户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你使用的 Shell 是 ZSH，可以通过下面的命令来设置：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;source &amp;lt;(kubectl completion zsh)&quot;&lt;/span&gt; &amp;gt;&amp;gt; ~/.zshrc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt; ~/.zshrc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>使用 TC 和 Netem 模拟网络异常</title>
    <link href="https://www.hi-linux.com/posts/35699.html"/>
    <id>https://www.hi-linux.com/posts/35699.html</id>
    <published>2018-09-10T01:00:00.000Z</published>
    <updated>2018-09-10T04:00:22.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在某些情况下，我们需要模拟网络很差的状态来测试软件能够正常工作，比如网络延迟、丢包、乱序、重复等。Linux 系统下强大的流量控制工具 TC 能很轻松地完成这个需求，TC 命令行工具是 <code>IProute2</code> 软件包中的软件，可以根据系统版本自行安装。</p><p>这篇文章介绍的功能主要是通过 <code>Netem</code> 这个内核模块来实现的。<code>Netem</code> 是 <code>Network Emulator</code> 的缩写，关于更多功能以及参数的详细解释可以参阅 <code>TC-Netem</code> 的 Man Page。</p><blockquote><p>Netem 与 TC 简要说明</p><p>Netem 是 Linux 2.6 及以上内核版本提供的一个网络模拟功能模块。该功能模块可以用来在性能良好的局域网中，模拟出复杂的互联网传输性能。例如:低带宽、传输延迟、丢包等等情况。使用 Linux 2.6 (或以上) 版本内核的很多 Linux 发行版都默认开启了该内核模块，比如：Fedora、Ubuntu、Redhat、OpenSuse、CentOS、Debian 等等。</p><p>TC 是 Linux 系统中的一个用户态工具，全名为 Traffic Control (流量控制)。TC 可以用来控制 Netem 模块的工作模式，也就是说如果想使用 Netem 需要至少两个条件，一是内核中的 Netem 模块被启用，另一个是要有对应的用户态工具 TC 。</p></blockquote><p>TC 能做的事情很多，除了本文介绍的还有带宽控制、优先级控制等等。这些功能是通过类似 Netem 的内核模块实现的。</p><a id="more"></a><h3 id="网络状况模拟">网络状况模拟</h3><p>网络状况欠佳从用户角度来说就是下载东西慢（网页一直加载、视频卡顿、图片加载很久等），从网络报文角度来看却有很多情况：比如：延迟（某个机器发送报文很慢）、丢包（发送的报文在网络中丢失需要一直重传）、乱序（报文顺序错乱，需要大量计算时间来重新排序）、重复（报文有大量重复，导致网络拥堵）、错误（接收到的报文有误只能丢弃重传）等。</p><p>对于这些情况，都可以用 Netem 来模拟。需要注意的是，Netem 是直接作用于指定网卡上的，也就是说所有从该网卡发送出去的包都会收到配置参数的影响，所以最好搭建临时的虚拟机进行测试。</p><p>在下面的例子中 <code>add</code> 表示为指定网卡添加 Netem 配置，<code>change</code> 表示修改已经存在的 Netem 配置到新的值，<code>replace</code> 表示替换已经存在的 Netem 配置的值。如果要删除网卡上的 Netem 配置可以使用 <code>del</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc del dev enp0s5 root</span><br></pre></td></tr></table></figure><h4 id="1-模拟延迟传输">1. 模拟延迟传输</h4><p>最简单的例子是所有的报文延迟 100ms 发送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc add dev enp0s5 root netem delay 100ms</span><br></pre></td></tr></table></figure><p>如果你想在一个局域网里模拟远距离传输的延迟可以用这个方法，比如实际用户访问网站延迟为 101 ms，而你测试环境网络交互只需要 1ms，那么只要添加 100ms 额外延迟就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc replace dev enp0s5 root netem delay 100ms</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;102 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;100 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;100 ms</span><br><span class="line">^C</span><br><span class="line">--- dev-node-02 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3000ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 100.293&#x2F;101.053&#x2F;102.795&#x2F;1.061 ms</span><br></pre></td></tr></table></figure><p>如果在网络中看到非常稳定的时延，很可能是某个地方加了定时器，因为网络线路很复杂，传输过程一定会有变化。因此实际情况网络延迟一定会有变化的，<code>Netem</code> 也考虑到这一点，提供了额外的参数来控制延迟的时间分布。完整的参数列表为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELAY :&#x3D; delay TIME [ JITTER [ CORRELATION ]]]</span><br><span class="line">    [ distribution &#123; uniform | normal | pareto |  paretonormal &#125; ]</span><br></pre></td></tr></table></figure><p>除了延迟时间 <code>TIME</code> 之外，还有三个可选参数：</p><ul><li><code>JITTER</code>：抖动，增加一个随机时间长度，让延迟时间出现在某个范围。</li><li><code>CORRELATION</code>：相关，下一个报文延迟时间和上一个报文的相关系数。</li><li><code>distribution</code>：分布，延迟的分布模式。可以选择的值有 <code>uniform</code>、<code>normal</code>、<code>pareto</code> 和 <code>paretonormal</code>。</li></ul><p>先说说 <code>JITTER</code>，如果设置为 <code>20ms</code>，那么报文延迟的时间在 100ms  ± 20ms 之间，具体值随机选择：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc replace dev enp0s5 root netem delay 100ms 20ms</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;108 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;107 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;92 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><code>CORRELATION</code> 指相关性，因为网络状况是平滑变化的，短时间里相邻报文的延迟应该是近似的而不是完全随机的。这个值是个百分比，如果为 <code>100%</code>，就退化到固定延迟的情况；如果是 <code>0%</code> 则退化到随机延迟的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc replace dev enp0s5 root netem delay 100ms 20ms 50%</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;104 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;109 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;5 ttl&#x3D;64 time&#x3D;101 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>报文的分布和很多现实事件一样都满足某种统计规律，比如最常用的正态分布。因此为了更逼近现实情况，可以使用 <code>distribution</code> 参数来限制它的延迟分布模型。比如让报文延迟时间满足正态分布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc replace dev enp0s5 root netem delay 100ms 20ms distribution normal</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;82.0 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;82.3 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;98.1 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这样的话，大部分的延迟会在平均值的一定范围内，而很少接近出现最大值和最小值的延迟。</p><p>其他分布方法包括：<a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)" target="_blank" rel="noopener">uniform</a>、<a href="https://en.wikipedia.org/wiki/Pareto_distribution" target="_blank" rel="noopener">pareto</a> 和 <code>paretonormal</code>，这些分布方法感兴趣的读者可以自行了解。对于大多数情况，随机在某个时间范围里延迟就能满足需求的。</p><h4 id="2-模拟丢包率">2. 模拟丢包率</h4><p>另一个常见的网络异常是因为丢包，丢包会导致重传，从而增加网络链路的流量和延迟。Netem 的 <code>loss</code> 参数可以模拟丢包率，比如发送的报文有 50% 的丢包率（为了容易用 ping 看出来，所以这个数字我选的很大，实际情况丢包率可能比这个小很多，比如 <code>0.5%</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc change dev enp0s5 root netem loss 50%</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.290 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.308 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;5 ttl&#x3D;64 time&#x3D;0.221 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;8 ttl&#x3D;64 time&#x3D;0.371 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;9 ttl&#x3D;64 time&#x3D;0.315 ms</span><br></pre></td></tr></table></figure><p>可以从 <code>icmp_seq</code> 序号看出来大约有一半的报文丢掉了，和延迟类似丢包率也可以增加一个相关系数，表示后一个报文丢包概率和它前一个报文的相关性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc change dev enp0s5 root netem loss 0.3% 25%</span><br></pre></td></tr></table></figure><p>这个命令表示，丢包率是 0.3%，并且当前报文丢弃的可能性和前一个报文有 25% 相关。默认的丢包模型为随机，loss 也支持 <code>state</code>（4-state Markov 模型） 和 <code>gemodel</code>（Gilbert-Elliot 丢包模型） 两种模型的丢包，因为两者都相对复杂，这里就不再详细介绍了。</p><p>需要注意的是，丢包信息会发送到上层协议。如果是 TCP 协议，那么 TCP 会进行重传，所以对应用来说看不到丢包。这时候要模拟丢包，需要把 loss 配置到网桥或者路由设备上。</p><h4 id="3-模拟包重复">3. 模拟包重复</h4><p>报文重复和丢包的参数类似，就是重复率和相关性两个参数，比如随机产生 50% 重复的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc change dev enp0s5 root netem duplicate 50%</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.284 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.420 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.447 ms (DUP!)</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.437 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.515 ms (DUP!)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="4-模拟包损坏">4. 模拟包损坏</h4><p>报文损坏和报文重复的参数也类似，比如随机产生 2% 损坏的报文（在报文的随机位置造成一个比特的错误）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc change dev enp0s5 root netem corrupt 2%</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">......</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.362 ms</span><br><span class="line">Warning: time of day goes back (-4611686018427387574us), taking countermeasures.</span><br><span class="line">Warning: time of day goes back (-4611686018427387454us), taking countermeasures.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.000 ms</span><br><span class="line">wrong data byte #53 should be 0x35 but was 0xb5</span><br><span class="line">#1610 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f</span><br><span class="line">#4830 31 32 33 34 b5 36 37</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;5 ttl&#x3D;64 time&#x3D;0.476 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="5-模拟包乱序">5. 模拟包乱序</h4><p>网络传输并不能保证顺序，传输层 TCP 会对报文进行重组保证顺序，所以报文乱序对应用的影响比上面的几种问题要小。</p><p>报文乱序和前面的参数不太一样，因为上面的报文问题都是独立的。针对单个报文做操作就行，而乱序则牵涉到多个报文的重组。模拟报乱序一定会用到延迟（因为模拟乱序的本质就是把一些包延迟发送），Netem 有两种方法可以做。</p><p>第一种是固定的每隔一定数量的报文就乱序一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 每 5 个报文（第 5、10、15…报文）会正常发送，其他的报文延迟 100ms。</span><br><span class="line">$ tc qdisc change dev enp0s5 root netem reorder 50% gap 3 delay 100ms</span><br><span class="line">$ ping -i 0.05 dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;9 ttl&#x3D;64 time&#x3D;2.55 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;8 ttl&#x3D;64 time&#x3D;100 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;10 ttl&#x3D;64 time&#x3D;100 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;11 ttl&#x3D;64 time&#x3D;100 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;13 ttl&#x3D;64 time&#x3D;0.245 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;12 ttl&#x3D;64 time&#x3D;102 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;14 ttl&#x3D;64 time&#x3D;1.00 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>要想看到 ping 报文的乱序，我们要保证发送报文的间隔小于报文的延迟时间 <code>100ms</code>，这里用 <code>-i 0.05</code> 把发送间隔设置为 <code>50ms</code>。</p><p>第二种方法的乱序是相对随机的，使用概率来选择乱序的报文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc change dev enp0s5 root netem reorder 50% 15% delay 300ms</span><br><span class="line">$ ping -i 0.05 dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.423 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;7 ttl&#x3D;64 time&#x3D;0.250 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;301 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;301 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;9 ttl&#x3D;64 time&#x3D;0.238 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;5 ttl&#x3D;64 time&#x3D;301 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>50% 的报文会正常发送，其他报文（1-50%）延迟 300ms 发送，这里选择的延迟很大是为了能够明显看出来乱序的结果。</p><h4 id="6-其它技巧">6. 其它技巧</h4><ul><li>查看已经配置的网络条件</li></ul><p>该命令将查看并显示 enp0s5 网卡的相关传输配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc show dev enp0s5</span><br></pre></td></tr></table></figure><h3 id="推荐两个工具">推荐两个工具</h3><p>Netem 在 TC 中算是比较简单的模块，如果要实现流量控制或者精细化的过滤需要更复杂的配置。这里推荐两个小工具，它们共同的特点是用法简单，能满足特定的需求，而不用自己去倒腾 TC 的命令。</p><h4 id="1-wondershaper">1. Wondershaper</h4><p>项目地址：<a href="https://github.com/magnific0/wondershaper" target="_blank" rel="noopener">https://github.com/magnific0/wondershaper</a></p><p>Netem 只能模拟网络状况，不能控制带宽，<a href="https://www.hecticgeek.com/2012/02/simple-traffic-shaping-ubuntu-linux/" target="_blank" rel="noopener">Wondershaper</a> 则能完美解决这个问题。Wondershaper 实际上是一个 SHELL 脚本，它使用 TC 来进行流量速率调整，使用 QoS 来处理特定的网络接口。外发流量通过放在不同优先级的队列中，来达到限制传出流量速率的目的；而传入流量通过丢包的方式来达到速率限制的目的。</p><h5 id="安装-wondershaper">安装 Wondershaper</h5><ul><li>在 Ubuntu / Debian 下安装 Wondershaper</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install wondershaper</span><br></pre></td></tr></table></figure><ul><li>在 Fdora / CentOS / RHEL 中安装 Wondershaper</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 需启用 EPEL 仓库</span><br><span class="line">$ sudo yum install wondershaper</span><br></pre></td></tr></table></figure><h5 id="使用-wondershaper">使用 Wondershaper</h5><p>Wondershaper 的使用非常简单，只有三个参数：网卡名、下行限速、上行限速。比如要设置网卡下载速度为 200kb/s，上传速度为 <code>150kb/s</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo wondershaper enp0s5 200 150</span><br></pre></td></tr></table></figure><p>如果你要将速率限制消除，可以通过运行下面的命令来达到目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo wondershaper clear enp0s5</span><br></pre></td></tr></table></figure><h4 id="2-comcast">2. Comcast</h4><p>项目地址：<a href="https://github.com/tylertreat/comcast" target="_blank" rel="noopener">https://github.com/tylertreat/comcast</a></p><p><a href="https://github.com/tylertreat/comcast" target="_blank" rel="noopener">Comcast</a> 是一个跨平台的网络模拟工具，旨在其他平台（OSX、Windows、BSD）也能提供类似网络模拟的功能。</p><p>它的使用也相对简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ comcast --device&#x3D;enp0s5 --latency&#x3D;250 \</span><br><span class="line">    --target-bw&#x3D;1000 \</span><br><span class="line">    --default-bw&#x3D;1000000 \</span><br><span class="line">    --packet-loss&#x3D;10% \</span><br><span class="line">    --target-addr&#x3D;8.8.8.8,10.0.0.0&#x2F;24 \</span><br><span class="line">    --target-proto&#x3D;tcp,udp,icmp \</span><br><span class="line">    --target-port&#x3D;80,22,1000:2000</span><br></pre></td></tr></table></figure><ul><li><code>--device</code> 说明要控制的网卡为 <code>enp0s5</code>。</li><li><code>--latency</code> 指定 250ms 的延迟。</li><li><code>--target-bw</code>指定目标带宽。</li><li><code>--default-bw</code> 指定默认带宽。</li><li><code>--packet-loss</code> 指定丢包率。</li><li><code>--target-addr</code>、<code>--target-proto</code>、<code>--target-port</code> 参数指定在满足这些条件的报文上实施上面的配置。</li></ul><h3 id="总结">总结</h3><p>可以看出，TC 的 Netem 模块主要用来模拟各种网络的异常状况，本身并没有提供宽带限制的功能，而且一旦在网卡上配置了 Netem，该网卡上所有的报文都会受影响，如果想精细地控制部分报文，需要用到 TC 的 <a href="http://lartc.org/howto/lartc.qdisc.filters.html" target="_blank" rel="noopener">filter</a> 功能。</p><h3 id="参考资料">参考资料</h3><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a><br><a href="http://t.cn/RsUAV3y" target="_blank" rel="noopener">http://t.cn/RsUAV3y</a><br><a href="http://t.cn/RsUwmQX" target="_blank" rel="noopener">http://t.cn/RsUwmQX</a><br><a href="http://t.cn/RsUVqk0" target="_blank" rel="noopener">http://t.cn/RsUVqk0</a></p><blockquote><p>本文在 「使用 tc netem 模拟网络异常」的基础上整理和修改，原文地址：<a href="http://t.cn/RsUwmQX%E3%80%82" target="_blank" rel="noopener">http://t.cn/RsUwmQX。</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某些情况下，我们需要模拟网络很差的状态来测试软件能够正常工作，比如网络延迟、丢包、乱序、重复等。Linux 系统下强大的流量控制工具 TC 能很轻松地完成这个需求，TC 命令行工具是 &lt;code&gt;IProute2&lt;/code&gt; 软件包中的软件，可以根据系统版本自行安装。&lt;/p&gt;
&lt;p&gt;这篇文章介绍的功能主要是通过 &lt;code&gt;Netem&lt;/code&gt; 这个内核模块来实现的。&lt;code&gt;Netem&lt;/code&gt; 是 &lt;code&gt;Network Emulator&lt;/code&gt; 的缩写，关于更多功能以及参数的详细解释可以参阅 &lt;code&gt;TC-Netem&lt;/code&gt; 的 Man Page。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Netem 与 TC 简要说明&lt;/p&gt;
&lt;p&gt;Netem 是 Linux 2.6 及以上内核版本提供的一个网络模拟功能模块。该功能模块可以用来在性能良好的局域网中，模拟出复杂的互联网传输性能。例如:低带宽、传输延迟、丢包等等情况。使用 Linux 2.6 (或以上) 版本内核的很多 Linux 发行版都默认开启了该内核模块，比如：Fedora、Ubuntu、Redhat、OpenSuse、CentOS、Debian 等等。&lt;/p&gt;
&lt;p&gt;TC 是 Linux 系统中的一个用户态工具，全名为 Traffic Control (流量控制)。TC 可以用来控制 Netem 模块的工作模式，也就是说如果想使用 Netem 需要至少两个条件，一是内核中的 Netem 模块被启用，另一个是要有对应的用户态工具 TC 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TC 能做的事情很多，除了本文介绍的还有带宽控制、优先级控制等等。这些功能是通过类似 Netem 的内核模块实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>关于 Kubernetes Master 高可用的一些策略</title>
    <link href="https://www.hi-linux.com/posts/2897.html"/>
    <id>https://www.hi-linux.com/posts/2897.html</id>
    <published>2018-09-05T01:00:00.000Z</published>
    <updated>2018-09-05T08:36:24.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 高可用也许是完成了初步的技术评估，打算将生产环境迁移进 Kubernetes 集群之前普遍面临的问题。 为了减少因为服务器当机引起的业务中断，生产环境中的业务系统往往已经做好了高可用，而当引入 Kubernetes 这一套新的集群管理系统之后，服务器不再是单一的个体，位于中央位置的 Kubernetes Master 一旦中断服务，将导致所有 Node 节点均不可控，有可能造成严重的事故。</p><p>总体来讲这是一个<a href="https://kubernetes.io/docs/admin/high-availability/" target="_blank" rel="noopener">被多次讨论</a>，但暂时<a href="https://kubernetes.io/docs/tasks/administer-cluster/highly-available-master/" target="_blank" rel="noopener">没有形成统一解决方案</a>的话题。今天主要介绍一些 Kubernetes Master 高可用的策略，供大家参考。</p><h3 id="一个小目标">一个小目标</h3><p>高可用是复杂的系统工程。出于篇幅的考虑以及能力的限制，今天我们先关注一个小目标：所有的 Kubernetes Master 服务器没有单点故障，任何一台服务器当机均不影响 Kubernetes 的正常工作。</p><p>实现这一目标带来的直接收益是我们可以在不影响业务正常运行的前提下实现所有服务器的滚动升级，有助于完成系统组件升级以及安全补丁的下发。</p><p>为了实现没有单点故障的目标，需要为以下几个组件建立高可用方案：</p><ul><li><a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">etcd</a></li><li><a href="https://kubernetes.io/docs/admin/kube-apiserver/" target="_blank" rel="noopener">kube-apiserver</a></li><li><a href="https://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="noopener">kube-controller-manager</a> 与 <a href="https://kubernetes.io/docs/admin/kube-scheduler/" target="_blank" rel="noopener">kube-scheduler</a></li><li><a href="https://github.com/kubernetes/dns" target="_blank" rel="noopener">kube-dns</a></li></ul><p>这些组件的关系可参考下面这张集群架构示意图。</p><p><img src="https://www.hi-linux.com/img/linux/kubernetes-architecture.png" alt=""></p><p>下面为大家逐个详细介绍各个组件的高可用策略。</p><a id="more"></a><h3 id="etcd高可用">etcd高可用</h3><p>etcd 是 Kubernetes 当中唯一带状态的服务，也是高可用的难点。Kubernetes 选用 etcd 作为它的后端数据存储仓库正是看重了其使用分布式架构，没有单点故障的特性。</p><p>虽然单节点的 etcd 也可以正常运行。但是推荐的部署方案均是采用 3 个或者 5 个节点组成 etcd 集群，供 Kubernetes 使用。</p><p>大家常使用的 <a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="noopener">kubeadm</a> 工具默认是在一个单节点上启动 etcd 以及所有的 Master 组件。虽然使用起来非常方便，但是要用到生产环境还是要注意这个节点当机的风险。</p><p>etcd 的高可用基本有三种思路：</p><p>一是使用独立的 etcd 集群，使用 3 台或者 5 台服务器只运行 etcd，独立维护和升级。甚至可以使用 CoreOS 的 update-engine 和 locksmith 让服务器完全自主的完成升级。这个 etcd 集群将作为基石用于构建整个集群。采用这项策略的主要动机是 etcd 集群的节点增减都需要显式的通知集群，保证 etcd 集群节点稳定可以更方便的用程序完成集群滚动升级，减轻维护负担。</p><p>二是在 Kubernetes Master 上用 static pod 的形式来运行 etcd，并将多台 Kubernetes Master 上的 etcd 组成集群。 在这一模式下，各个服务器的 etcd 实例被注册进了 Kubernetes 当中，虽然无法直接使用 kubectl 来管理这部分实例，但是监控以及日志搜集组件均可正常工作。在这一模式运行下的 etcd 可管理性更强。</p><p>三是使用 CoreOS 提出的 <a href="https://github.com/kubernetes-incubator/bootkube/issues/31" target="_blank" rel="noopener">self-hosted etcd</a> 方案，将本应在底层为 Kubernetes 提供服务的 etcd 运行在 Kubernetes 之上。 实现 Kubernetes 对自身依赖组件的管理。在这一模式下的 etcd 集群可以直接使用 <a href="https://github.com/coreos/etcd-operator" target="_blank" rel="noopener">etcd-operator</a> 来自动化运维，最符合 Kubernetes 的使用习惯。</p><p>这三种思路均可以实现 etcd 高可用的目标，但是在选择过程中却要根据实际情况做出一些判断。简单来讲预算充足但保守的项目选方案一， 想一步到位并愿意承担一定风险的项目选方案三。折中一点选方案二。各个方案的优劣以及做选择过程中的取舍在这里就不详细展开了，对这块有疑问的朋友可以私下联系交流。</p><h3 id="kube-apiserver-高可用">kube-apiserver 高可用</h3><p>apiserver 本身是一个无状态服务，要实现其高可用相对要容易一些，难点在于如何将运行在多台服务器上的 apiserver 用一个统一的外部入口暴露给所有 Node 节点。</p><p>说是难点，其实对于这种无状态服务的高可用，我们在设计业务系统的高可用方案时已经有了相当多的经验积累。需要注意的是 apiserver 所使用的 SSL 证书要包含外部入口的地址，不然 Node 节点无法正常访问 apiserver。</p><p>apiserver 的高可用也有三种基本思路：</p><p>一是使用外部负载均衡器，不管是使用公有云提供的负载均衡器服务或是在私有云中使用 LVS 或者 HaProxy 自建负载均衡器都可以归到这一类。 负载均衡器是非常成熟的方案，在这里略过不做过多介绍。如何保证负载均衡器的高可用，则是选择这一方案需要考虑的新问题。</p><p>二是在网络层做负载均衡。比如在 Master 节点上用 BGP 做 ECMP，或者在 Node 节点上用 iptables 做 NAT 都可以实现。采用这一方案不需要额外的外部服务，但是对网络配置有一定的要求。</p><p>三是在 Node 节点上使用反向代理对多个 Master 做负载均衡。这一方案同样不需要依赖外部的组件，但是当 Master 节点有增减时，如何动态配置 Node 节点上的负载均衡器成为了另外一个需要解决的问题。</p><p>从目前各个集群管理工具的选择来看，这三种模式都有被使用，目前还没有明确的推荐方案产生。建议在公有云上的集群多考虑第一种模式，在私有云环境中由于维护额外的负载均衡器也是一项负担，建议考虑第二种或是第三种方案。</p><h3 id="kube-controller-manager-与-kube-scheduler-高可用">kube-controller-manager 与 kube-scheduler 高可用</h3><p>这两项服务是 Master 节点的一部分，他们的高可用相对容易，仅需要运行多份实例即可。这些实例会通过向 apiserver 中的 Endpoint 加锁的方式来进行 leader election， 当目前拿到 leader 的实例无法正常工作时，别的实例会拿到锁，变为新的 leader。</p><p>目前在多个 Master 节点上采用 static pod 模式部署这两项服务的方案比较常见，激进一点也可以采用 self-hosted 的模式，在 Kubernetes 之上用 DaemonSet 或者 Deployment 来部署。</p><h3 id="kube-dns-高可用">Kube-dns 高可用</h3><p>严格来说 kube-dns 并不算是 Master 组件的一部分，因为它是可以跑在 Node 节点上，并用 Service 向集群内部提供服务的。但在实际环境中，由于默认配置只运行了一份 kube-dns 实例，在其升级或是所在节点当机时，会出现集群内部 dns 服务不可用的情况，严重时会影响到线上服务的正常运行。</p><p>为了避免故障，请将 kube-dns 的 replicas 值设为 2 或者更多，并用 anti-affinity 将他们部署在不同的 Node 节点上。这项操作比较容易被疏忽，直到出现故障时才发现原来是 kube-dns 只运行了一份实例导致的故障。</p><h3 id="总结">总结</h3><p>上面介绍了 Kubernetes Master 各个组件高可用可以采用的策略。其中 etcd 和 kube-apiserver 的高可用是整个方案的重点。由于存在多种高可用方案，集群管理员应当根据集群所处环境以及其他限制条件选择适合的方案。</p><p>这种没有绝对的通用方案，需要集群建设者根据不同的现状在多个方案中做选择的情况在 Kubernetes 集群建设过程中频频出现， 也是整个建设过程中最有挑战的一部分。容器网络方案的选型作为 Kubernetes 建设过程中需要面对的另外一个大问题也属于这种情况，今后有机会再来分享这个话题。</p><p>在实际建设过程中，在完成了上述四个组件的高可用之后，最好采取实际关机检验的方式来验证高可用方案的可靠性，并根据检验的结果不断调整和优化整个方案。</p><p>此外将高可用方案与系统自动化升级方案结合在一起考虑，实现高可用下的系统自动升级，将大大减轻集群的日常运维负担，值得投入精力去研究。</p><p>虽然本篇主要在讲 Kubernetes Master 高可用的方案，但需要指出的是高可用也并不是必须的，为了实现高可用所付出的代价并不低， 需要有相应的收益来平衡。对于大量的小规模集群来说，业务系统并没有实现高可用，贸然去做集群的高可用收益有限。这时采用单 Master 节点的方案，做好 etcd 的数据备份，不失为理性的选择。</p><blockquote><p>来源：极术<br>原文：<a href="http://t.cn/Rs72Axn" target="_blank" rel="noopener">http://t.cn/Rs72Axn</a><br>题图：来自谷歌图片搜索<br>版权：本文版权归原作者所有</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://kubernetes.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kubernetes&lt;/a&gt; 高可用也许是完成了初步的技术评估，打算将生产环境迁移进 Kubernetes 集群之前普遍面临的问题。 为了减少因为服务器当机引起的业务中断，生产环境中的业务系统往往已经做好了高可用，而当引入 Kubernetes 这一套新的集群管理系统之后，服务器不再是单一的个体，位于中央位置的 Kubernetes Master 一旦中断服务，将导致所有 Node 节点均不可控，有可能造成严重的事故。&lt;/p&gt;
&lt;p&gt;总体来讲这是一个&lt;a href=&quot;https://kubernetes.io/docs/admin/high-availability/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;被多次讨论&lt;/a&gt;，但暂时&lt;a href=&quot;https://kubernetes.io/docs/tasks/administer-cluster/highly-available-master/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;没有形成统一解决方案&lt;/a&gt;的话题。今天主要介绍一些 Kubernetes Master 高可用的策略，供大家参考。&lt;/p&gt;
&lt;h3 id=&quot;一个小目标&quot;&gt;一个小目标&lt;/h3&gt;
&lt;p&gt;高可用是复杂的系统工程。出于篇幅的考虑以及能力的限制，今天我们先关注一个小目标：所有的 Kubernetes Master 服务器没有单点故障，任何一台服务器当机均不影响 Kubernetes 的正常工作。&lt;/p&gt;
&lt;p&gt;实现这一目标带来的直接收益是我们可以在不影响业务正常运行的前提下实现所有服务器的滚动升级，有助于完成系统组件升级以及安全补丁的下发。&lt;/p&gt;
&lt;p&gt;为了实现没有单点故障的目标，需要为以下几个组件建立高可用方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/coreos/etcd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;etcd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/admin/kube-apiserver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kube-apiserver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/admin/kube-controller-manager/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kube-controller-manager&lt;/a&gt; 与 &lt;a href=&quot;https://kubernetes.io/docs/admin/kube-scheduler/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kube-scheduler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes/dns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kube-dns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些组件的关系可参考下面这张集群架构示意图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/kubernetes-architecture.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面为大家逐个详细介绍各个组件的高可用策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Docker 最佳实践之多阶段构建</title>
    <link href="https://www.hi-linux.com/posts/55545.html"/>
    <id>https://www.hi-linux.com/posts/55545.html</id>
    <published>2018-09-03T01:00:00.000Z</published>
    <updated>2018-09-03T02:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Docker 目前在容器市场可以说是占领了大部分市场，Docker 掀起了容器革命，同时也改变了现代化云平台的构建方式。尽管 Docker 很强大，但使用过程当中也遇到了一些问题。比如:我想要构建一个编译型语言镜像，需要先在一个 Dockerfile 中编译，然后再使用另外一个 Dockerfile 把编译好的文件放到镜像中。这样无形当中就增大了 CI/CD 的复杂度。</p><blockquote><p>Docker 多阶段构建是 17.05 以后引入的新特性，旨在解决编译和构建复杂的问题。因此要使用多阶段构建特性必须使用高于或等于 17.05 的 Docker。</p></blockquote><h3 id="多阶段构建出现之前">多阶段构建出现之前</h3><ul><li>构建镜像最具挑战性的一点是使镜像大小尽可能的小。Dockerfile 中的每条指令都为镜像添加了一个镜像层，您需要记住在移动到下一个镜像层之前清理任何不需要的组件。</li><li>为了编写一个真正高效的 Dockerfile，传统上需要使用 Shell 技巧和其它逻辑来保持镜像层尽可能小，并确保每个镜像层都具有前一层所需的组件而不是其它任何东西。</li></ul><p>很多时候我们用一个 Dockerfile 维护开发环境（包含构建应用程序所需的所有内容），用另一个 Dockerfile 维护生产环境（只包含您的应用程序以及运行它所需的内容）。实际上同时维护两个 Dockerfiles 并不是一种理想的构建模式，这种模式被称为建造者模式。</p><p>我们来看一个例子，这是一个 Dockerfile.build 和 Dockerfile 的例子，它遵循上面的模式。</p><p><strong>Dockerfile.build</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR &#x2F;go&#x2F;src&#x2F;github.com&#x2F;alexellis&#x2F;href-counter&#x2F;</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN go get -d -v golang.org&#x2F;x&#x2F;net&#x2F;html \</span><br><span class="line">  &amp;&amp; CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o app .</span><br></pre></td></tr></table></figure><p>请注意，此示例使用 Bash <code>&amp;&amp;</code> 运算符人为合并两个 RUN 命令，以避免在 Image 中创建出其它层。这种方法很容易出错并且难以维护。</p><a id="more"></a><p><strong>Dockerfile</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:latest  </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR &#x2F;root&#x2F;</span><br><span class="line">COPY app .</span><br><span class="line">CMD [&quot;.&#x2F;app&quot;]</span><br></pre></td></tr></table></figure><p><strong><a href="http://build.sh" target="_blank" rel="noopener">build.sh</a></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> Building alexellis2/href-counter:build</span><br><span class="line">docker build --build-arg https_proxy=<span class="variable">$https_proxy</span> --build-arg http_proxy=<span class="variable">$http_proxy</span> \  </span><br><span class="line">    -t alexellis2/href-counter:build . -f Dockerfile.build</span><br><span class="line">docker container create --name extract alexellis2/href-counter:build  </span><br><span class="line">docker container cp extract:/go/src/github.com/alexellis/href-counter/app ./app  </span><br><span class="line">docker container rm -f extract</span><br><span class="line"><span class="built_in">echo</span> Building alexellis2/href-counter:latest</span><br><span class="line">docker build --no-cache -t alexellis2/href-counter:latest .</span><br><span class="line">rm ./app</span><br></pre></td></tr></table></figure><p>当您运行 <code>build.sh</code> 脚本时，它首先会构建第一个 Image 并从创建容器中复制编译好的程序到本地。然后在第二个 Image 中将构建好的程序运行起来。</p><h3 id="使用多阶段构建">使用多阶段构建</h3><p>从上面的过程中可以看到过程是非常复杂且容易出错的，多阶段构建的出现就大大简化了这种情况！</p><p>对于多阶段构建，您可以在 Dockerfile 中使用多个 FROM 语句。每个 FROM 指令可以使用不同的基础镜像，并且每个 FROM 指令都会开始一个新的构建阶段。您可以选择性地将各构建阶段中的内容从一个阶段复制到另一个阶段，从而在最终 Image 中只留下您想要的内容。</p><p>为了说明这是如何工作的，我们调整上述示例中的 Dockerfile 使用多阶段方式来构建。</p><p><strong>Dockerfile</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR &#x2F;go&#x2F;src&#x2F;github.com&#x2F;alexellis&#x2F;href-counter&#x2F;</span><br><span class="line">RUN go get -d -v golang.org&#x2F;x&#x2F;net&#x2F;html  </span><br><span class="line">COPY app.go .</span><br><span class="line">RUN CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest  </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR &#x2F;root&#x2F;</span><br><span class="line">COPY --from&#x3D;0 &#x2F;go&#x2F;src&#x2F;github.com&#x2F;alexellis&#x2F;href-counter&#x2F;app .</span><br><span class="line">CMD [&quot;.&#x2F;app&quot;]</span><br></pre></td></tr></table></figure><p>可以看到您只需要单个 Dockerfile 并且不需要任何的单独构建脚本，就可以构建出上面相同的 Image。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t app:latest .</span><br></pre></td></tr></table></figure><p>通过 <code>docker build</code> 构建后，最终结果是产生与之前相同大小的 Image，但复杂性显著降低。您不需要创建任何中间 Image，也不需要将任何编译结果临时提取到本地系统。</p><p>哪它是如何工作的呢？关键就在 <code>COPY --from=0</code> 这个指令上。Dockerfile 中第二个 FROM 指令以 alpine:latest 为基础镜像开始了一个新的构建阶段，并通过 <code>COPY --from=0</code> 仅将前一阶段的构建文件复制到此阶段。前一构建阶段中产生的 Go SDK 和任何中间层都会在此阶段中被舍弃，而不是保存在最终 Image 中。</p><h3 id="为多构建阶段命名">为多构建阶段命名</h3><p>默认情况下，构建阶段是未命名的。您可以通过一个整数值来引用它们，默认是从第 0 个 FROM 指令开始的。 为了方便管理，您也可以通过向 FROM 指令添加 as NAME 来命名您的各个构建阶段。下面的示例就通过命名各个构建阶段并在 COPY 指令中使用名称来访问指定的构建阶段。</p><p>这样做的好处就是即使稍后重新排序 Dockerfile 中的指令，COPY 指令一样能找到对应的构建阶段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3 as builder</span><br><span class="line">WORKDIR &#x2F;go&#x2F;src&#x2F;github.com&#x2F;alexellis&#x2F;href-counter&#x2F;</span><br><span class="line">RUN go get -d -v golang.org&#x2F;x&#x2F;net&#x2F;html  </span><br><span class="line">COPY app.go    .</span><br><span class="line">RUN CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest  </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR &#x2F;root&#x2F;</span><br><span class="line">COPY --from&#x3D;builder &#x2F;go&#x2F;src&#x2F;github.com&#x2F;alexellis&#x2F;href-counter&#x2F;app .</span><br><span class="line">CMD [&quot;.&#x2F;app&quot;]</span><br></pre></td></tr></table></figure><h3 id="停在特定的构建阶段">停在特定的构建阶段</h3><p>构建镜像时，不一定需要构建整个 Dockerfile 中每个阶段，您也可以指定需要构建的阶段。比如：您只构建 Dockerfile 中名为 builder 的阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --target builder -t alexellis2&#x2F;href-counter:latest .</span><br></pre></td></tr></table></figure><p>此功能适合以下场景：</p><ul><li>调试特定的构建阶段。</li><li>在 Debug 阶段，启用所有程序调试模式或调试工具，而在生产阶段尽量精简。</li><li>在 Testing 阶段，您的应用程序使用测试数据，但在生产阶段则使用生产数据。</li></ul><h3 id="使用外部镜像作为构建阶段">使用外部镜像作为构建阶段</h3><p>使用多阶段构建时，您不仅可以从 Dockerfile 中创建的镜像中进行复制。您还可以使用 <code>COPY --from</code> 指令从单独的 Image 中复制，支持使用本地 Image 名称、本地或 Docker 注册中心可用的标记或标记 ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY --from&#x3D;nginx:latest &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;nginx.conf</span><br></pre></td></tr></table></figure><blockquote><p>本文在 「Docker 最佳实践之多阶段构建 」的基础上整理和修改，原文地址：<a href="http://t.cn/RFx6ML2" target="_blank" rel="noopener">http://t.cn/RFx6ML2</a> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 目前在容器市场可以说是占领了大部分市场，Docker 掀起了容器革命，同时也改变了现代化云平台的构建方式。尽管 Docker 很强大，但使用过程当中也遇到了一些问题。比如:我想要构建一个编译型语言镜像，需要先在一个 Dockerfile 中编译，然后再使用另外一个 Dockerfile 把编译好的文件放到镜像中。这样无形当中就增大了 CI/CD 的复杂度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker 多阶段构建是 17.05 以后引入的新特性，旨在解决编译和构建复杂的问题。因此要使用多阶段构建特性必须使用高于或等于 17.05 的 Docker。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;多阶段构建出现之前&quot;&gt;多阶段构建出现之前&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建镜像最具挑战性的一点是使镜像大小尽可能的小。Dockerfile 中的每条指令都为镜像添加了一个镜像层，您需要记住在移动到下一个镜像层之前清理任何不需要的组件。&lt;/li&gt;
&lt;li&gt;为了编写一个真正高效的 Dockerfile，传统上需要使用 Shell 技巧和其它逻辑来保持镜像层尽可能小，并确保每个镜像层都具有前一层所需的组件而不是其它任何东西。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多时候我们用一个 Dockerfile 维护开发环境（包含构建应用程序所需的所有内容），用另一个 Dockerfile 维护生产环境（只包含您的应用程序以及运行它所需的内容）。实际上同时维护两个 Dockerfiles 并不是一种理想的构建模式，这种模式被称为建造者模式。&lt;/p&gt;
&lt;p&gt;我们来看一个例子，这是一个 Dockerfile.build 和 Dockerfile 的例子，它遵循上面的模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dockerfile.build&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FROM golang:1.7.3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WORKDIR &amp;#x2F;go&amp;#x2F;src&amp;#x2F;github.com&amp;#x2F;alexellis&amp;#x2F;href-counter&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;COPY app.go .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN go get -d -v golang.org&amp;#x2F;x&amp;#x2F;net&amp;#x2F;html \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;amp;&amp;amp; CGO_ENABLED&amp;#x3D;0 GOOS&amp;#x3D;linux go build -a -installsuffix cgo -o app .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;请注意，此示例使用 Bash &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符人为合并两个 RUN 命令，以避免在 Image 中创建出其它层。这种方法很容易出错并且难以维护。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
  </entry>
  
</feed>
