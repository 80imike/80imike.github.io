<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>运维之美</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2020-05-16T04:33:24.280Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 1 期 )</title>
    <link href="https://www.hi-linux.com/posts/43626.html"/>
    <id>https://www.hi-linux.com/posts/43626.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T04:33:24.280Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h3 id="业界资讯">业界资讯</h3><p>1、<a href="https://www.williamlong.info/archives/5747.html" target="_blank" rel="noopener">中国设立互联网根服务器</a></p><p>近日，中国工信部官网一篇题为 “工业和信息化部关于同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及域名根服务器运行机构的批复” 的文章引起外界广泛关注。工信部当天的消息称，同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及成为域名根服务器运行机构，负责运行、维护和管理相关域名根服务器。</p><p>链接：<a href="https://www.williamlong.info/archives/5747.html" target="_blank" rel="noopener">https://www.williamlong.info/archives/5747.html</a></p><p>2、<a href="https://www.solidot.org/story?sid=61096" target="_blank" rel="noopener">微软正式发布 Windows Terminal 预览版</a></p><p>微软在 Microsoft Store 发布了 Windows Terminal 的预览版。</p><p>Windows Terminal 是微软上个月在开发者大会上宣布的新命令行终端，源代码发布在 GitHub 上。Windows Terminal 支持多标签、Unicode 和 UTF-8 字符、GPU 加速 DirectWrite/DirectX 文本渲染引擎，定制主题、样式和配置。更多特性详细介绍可参考<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487033&amp;idx=1&amp;sn=2cc918c4a2f9ddf7da341e7996183872&amp;chksm=eac52f10ddb2a606ee40e98646dc8eb8b4409ef88169c6172f5b42ead00c866c4693d7a3387f&amp;token=1817029934&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a> 。</p><p>下载安装 Windows Terminal  需要 Windows 10 version 18362.0 及更新版本。</p><p>链接：<a href="https://www.solidot.org/story?sid=61096" target="_blank" rel="noopener">https://www.solidot.org/story?sid=61096</a></p><p><img src="https://i.loli.net/2019/07/29/5d3ebfc2aaafd80489.jpg" alt=""></p><p>3、<a href="https://www.oschina.net/news/107833/dns-over-https-ga" target="_blank" rel="noopener">谷歌宣布 DNS Over HTTPS 服务普遍可用</a></p><p>谷歌于 2009 年推出 Google Public DNS，并于 2016 年在此基础上推出 DNS Over HTTPS，这是一项实验性服务，旨在加强 DNS 的安全性，此前的服务入口是 <a href="http://dns.google.com/experimental%E3%80%82" target="_blank" rel="noopener">dns.google.com/experimental。</a></p><p>现在谷歌宣布 DoH 已经正式普遍可用，并且完全支持 RFC 8484 文档，同时继续提供对 2016 年推出的 JSON API 的支持。用户可以使用 dns.google 域中的 DoH 解析 DNS，其中包含与常规 DNS 服务相同的任播地址，如 8.8.8.8。新的访问入口是：<a href="https://dns.google/dns-query" target="_blank" rel="noopener">https://dns.google/dns-query</a> ((RFC 8484) 和 <a href="https://dns.google/resolve" target="_blank" rel="noopener">https://dns.google/resolve</a> (JSON API)。</p><p>链接：<a href="https://www.oschina.net/news/107833/dns-over-https-ga" target="_blank" rel="noopener">https://www.oschina.net/news/107833/dns-over-https-ga</a></p><p><img src="https://oscimg.oschina.net/oscnet/fe994bc0e5e401523320b7953a92696045f.jpg" alt=""></p><p>4、<a href="http://news.51cto.com/art/201906/598801.htm" target="_blank" rel="noopener">Mozilla 发布下一代移动浏览器 Firefox Preview</a></p><p>Mozilla 已于近日在 Google Play 正式上架面向 Android 的全新移动浏览器 Firefox Preview。</p><p>与现已推出与大多数浏览器所采用的 Bink 渲染引擎不同，Firefox Preview 的渲染引擎 GeckoView 由 Mozilla 自己开发，这种独立性一定程度上避免了互联网被单一的科技巨头控制。</p><p>虽然已经公开发布，不过 Mozilla 表示 Firefox Preview 仍处于测试阶段，真正的大招会憋到今年秋季再放，届时将提供更丰富的功能和更精美的界面。</p><p>链接：<a href="http://news.51cto.com/art/201906/598801.htm" target="_blank" rel="noopener">http://news.51cto.com/art/201906/598801.htm</a></p><p><img src="https://s4.51cto.com/oss/201907/01/da021001f2e94c283777ac8f67a880b8.jpg-wh_651x-s_2719880675.jpg" alt=""></p><p>5、<a href="https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop" target="_blank" rel="noopener">OpenJDK Docker 镜像存在错误版本漏洞</a></p><p>OpenJDK 邮件列表确认，OpenJDK 的官方 Docker 镜像中包含错误标记版本号，这表明部分 JRE 应包含的安全补丁实际上并不存在。</p><p>该问题已经通过 OpenJDK 和 Debian 间的跨社区协作得以解决。该 “官方” 版本是由 Docker 和其他方制作的，因为 OpenJDK 社区没有创建镜像或生成构建。该 Docker 镜像已被下载超过一千万次。</p><p>链接：<a href="https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop" target="_blank" rel="noopener">https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop</a></p><p>6、<a href="https://www.oschina.net/news/107663/v-lang-source-code-released" target="_blank" rel="noopener">安全的全新编程语言 V 发布首个可用版本</a></p><p>日前，一种新的静态类型编程语言 V 语言正式开源了，并发布了首个可用版本。</p><p>据了解，V 语言全名叫：Vlang。V 语言是一个结合 Go 语言的简洁以及 Rust 的安全特性的新语言，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。</p><p>链接：<a href="https://www.oschina.net/news/107663/v-lang-source-code-released" target="_blank" rel="noopener">https://www.oschina.net/news/107663/v-lang-source-code-released</a></p><p><img src="https://raw.githubusercontent.com/vlang/v/master/examples/tetris/screenshot.png" alt=""></p><a id="more"></a><h3 id="趣站酷软">趣站酷软</h3><p>1、<a href="https://github.com/Eugeny/terminus" target="_blank" rel="noopener">Terminus</a></p><p>Terminus 是一个高度可配置的终端模拟器，适用于 Windows、macOS 和 Linux。</p><p>项目地址: <a href="https://github.com/Eugeny/terminus" target="_blank" rel="noopener">https://github.com/Eugeny/terminus</a></p><p><img src="https://raw.githubusercontent.com/Eugeny/terminus/master/docs/readme.png" alt=""></p><p>2、<a href="https://github.com/ovity/octotree" target="_blank" rel="noopener">Octotree</a></p><p>一个浏览器插件，可以将 GitHub 的仓库变成文件浏览器，提供便于查看的树状文件结构。</p><p>项目地址: <a href="https://github.com/ovity/octotree" target="_blank" rel="noopener">https://github.com/ovity/octotree</a></p><p><img src="https://raw.githubusercontent.com/ovity/octotree/v3/docs/chrome-github.png" alt=""></p><p>3、<a href="https://github.com/Peltoche/lsd" target="_blank" rel="noopener">LSD</a></p><p>文件列表命令 ls 的替代品。</p><p>项目地址: <a href="https://github.com/Peltoche/lsd" target="_blank" rel="noopener">https://github.com/Peltoche/lsd</a></p><p><img src="https://raw.githubusercontent.com/Peltoche/lsd/assets/screen_lsd.png" alt=""></p><p>4、<a href="https://github.com/marcenacp/kubeasy" target="_blank" rel="noopener">Kubeasy</a></p><p>一个用来管理 Kubernetes 集群的 CLI 工具，提供了沉浸式的命令行界面。</p><p>项目地址: <a href="https://github.com/marcenacp/kubeasy" target="_blank" rel="noopener">https://github.com/marcenacp/kubeasy</a></p><p><img src="https://raw.githubusercontent.com/marcenacp/kubeasy/master/public/kubeasy.gif" alt=""></p><p>5、<a href="https://github.com/wercker/stern" target="_blank" rel="noopener">Stern</a></p><p>Stern 是 Kubernetes 下多容器日志查看工具，如果你有需求一次看多个 Pod 的日志，Stern 这个工具可以将日志从多个 Pod 中拉出来，非常方便实用。</p><p>Stern 支持正则表达式，只需以 Pod 部署名称开头就可以跟踪所有部署 Pod 中的日志，并不需要知道每个 Pod 的确切名称。</p><p>项目地址: <a href="https://github.com/wercker/stern" target="_blank" rel="noopener">https://github.com/wercker/stern</a></p><p><img src="https://static001.infoq.cn/resource/image/b4/8a/b4b4400dc8666b0c4176871d829dcf8a.png" alt=""></p><p>6、<a href="https://github.com/wfxr/tmux-fzf-url" target="_blank" rel="noopener">tmux-fzf-url</a></p><p>tmux-fzf-url 是一个Tmux 插件，可以帮助你解放鼠标，提高工作效率的 CLI 工具。它可以从终端快速打开屏幕中的 URL，当 URL 有多个的时候，还可以通过 FZF 进行交互式地筛选，同时打开所有选中的链接，全程无需使用鼠标。（ 配合浏览器插件 cVim、Surfingkeys 等使用更佳）</p><p>项目地址: <a href="https://github.com/wfxr/tmux-fzf-url" target="_blank" rel="noopener">https://github.com/wfxr/tmux-fzf-url</a></p><p><img src="https://raw.githubusercontent.com/wfxr/i/master/tmux-fzf-url.gif" alt=""></p><p>7、<a href="https://github.com/jiansiting/Decryption-Tools" target="_blank" rel="noopener">Decryption-Tools</a></p><p>一个勒索病毒解密工具的仓库，上面收集了各种勒索病毒解密工具, 希望对大家有用。</p><p>项目地址: <a href="https://github.com/jiansiting/Decryption-Tools" target="_blank" rel="noopener">https://github.com/jiansiting/Decryption-Tools</a></p><h3 id="技术文章">技术文章</h3><p>1、<a href="https://tonybai.com/2019/06/25/using-git-with-svn-repo/" target="_blank" rel="noopener">使用 Git 操作 SVN 仓库</a></p><p>如今，虽然 Git 已经大行其道，但是仍有很多 IT 公司和组织依旧在使用集中式的版本控制系统 Subversion，尤其是一些传统软件公司，他们倾向于集中式的联网开发。</p><p>如果你是一个 Git Fans，并且你要是遇到代码仓库依旧是使用 Subversion 进行版本控制的情况，你又该如何施展呢？</p><p>本文将介绍一种如何优雅的使用 Git 对 Subversion 仓库进行操作的方法。</p><p>链接：<a href="https://tonybai.com/2019/06/25/using-git-with-svn-repo/" target="_blank" rel="noopener">https://tonybai.com/2019/06/25/using-git-with-svn-repo/</a></p><p>2、<a href="http://dockone.io/article/8832" target="_blank" rel="noopener">容器发展简史</a></p><p>在过去四年中（2015-2019），云以及分布式计算成为最受欢迎的技术之一，它们从小众技能逐渐变成更被雇主看重的突出技能。容器化技术是云经济和 IT 生态系统中最新潮的技术之一。这篇文章可能会帮助您理解有关 Docker 和容器的一些令人困惑的概念。我们还将看到容器化生态系统在 2019 年的现状以及演变方向。</p><p>链接：<a href="http://dockone.io/article/8832" target="_blank" rel="noopener">http://dockone.io/article/8832</a></p><p>3、<a href="https://zhuanlan.zhihu.com/p/69554144" target="_blank" rel="noopener">怎样去理解 Linux 用户态和内核态？</a></p><p>在 Linux 技术讨论中经常会用户态和内核态术语脱口而出，可你们想过吗？用户态和内核态代表是什么？本片文章，就来谈一谈这个话题。</p><p>链接：<a href="https://zhuanlan.zhihu.com/p/69554144" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69554144</a></p><p>4、<a href="https://www.sysgeek.cn/configure-dns-over-https-in-firefox/" target="_blank" rel="noopener">如何为 Firefox 浏览器配置 DNS Over HTTPS 支持</a></p><p>DNS 查询在当今互联网上扮演着不可或缺的重要角色，当您在浏览器地址栏中输入域名访问网站时，就是由 DNS 服务进行名称查询并解析为对应服务端的 IP 地址，这些由客户端自动发起的 DNS 查询通常都没有任何形式的加密、防偷窥或防篡改措施。</p><p>DNS over HTTPS 是一项相对较新的安全新功能，它可以提高 DNS 查询的隐私性、安全性和连接可靠性，主要由 Google、Cloudflare 和 Mozilla 等领先技术的科技公司在产品中使用。</p><p>本文将介绍如何在 Firefox 浏览器中启用 DNS Over HTTPS 的方法。</p><p>链接 1：<a href="https://www.sysgeek.cn/configure-dns-over-https-in-firefox/" target="_blank" rel="noopener">https://www.sysgeek.cn/configure-dns-over-https-in-firefox/</a><br>链接 2：<a href="https://zhuanlan.zhihu.com/p/42468805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42468805</a></p><p>5、<a href="https://www.oschina.net/news/107847/geckoview-in-2019" target="_blank" rel="noopener">聊聊 Firefox Preview 背后的渲染引擎 GeckoView</a></p><p>通过将 GeckoView 引擎与 Firefox 应用程序相分离，开发团队创建了一种更新、更快和更容易维护的方式来开发 Android 应用程序。这种方法利用了 Gecko 卓越的性能、隐私和对最新 Web 标准的支持。</p><p>本文将介绍一些关于 GeckoView 的特性和应用案例。</p><p>链接：<a href="https://www.oschina.net/news/107847/geckoview-in-2019" target="_blank" rel="noopener">https://www.oschina.net/news/107847/geckoview-in-2019</a></p><h3 id="每周观点">每周观点</h3><p>1、钓鱼的两个原则：一是在有鱼的地方钓鱼，二是不要忘记第一条原则。投资的道理也是一样的。在一些地方，无论你是多好的渔夫，你也不可能钓到很多鱼。生活是一场持久的比赛，接受生活，竭尽全力地做事。如果你能够活到很大的年纪，你会获得很多机遇，可能总共是两种机遇，但抓住其中一个机遇就好啦。—— 查理∙芒格</p><p>2、向那些狂妄之徒致敬。那些特立独行的，桀骜不驯的，那些惹是生非的，格格不入的。那些喜欢另辟蹊径，绝不墨守成规，从不安于现状的家伙。你可以赞美他们，引述他们，反对他们，质疑他们，颂扬或是诋毁他们，却惟独不能忽视他们，因为他们改变了事物。他们发明，想象，治愈，他们探索，创造，启迪，他们推动人类进步。他们或有不得不疯狂的理由。你能于白纸之上看到美妙的画作么？你能于寂静之中听见动人的乐声么？你能于星空之中想到神奇的太空轮么？我们为这些家伙制造良机。别人看到的或为疯子，我们看到的却是天才。因为，只有那些疯狂到以为自己能够改变世界的人，才能真正地改变世界。——「Think Different，1997 年 Apple 广告」</p><p>3、想换个方式喜欢你了，不追逐、不逢迎、无风雨、无喜悲。——德卡先生的信箱</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h3 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.williamlong.info/archives/5747.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中国设立互联网根服务器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，中国工信部官网一篇题为 “工业和信息化部关于同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及域名根服务器运行机构的批复” 的文章引起外界广泛关注。工信部当天的消息称，同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及成为域名根服务器运行机构，负责运行、维护和管理相关域名根服务器。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.williamlong.info/archives/5747.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.williamlong.info/archives/5747.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.solidot.org/story?sid=61096&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软正式发布 Windows Terminal 预览版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软在 Microsoft Store 发布了 Windows Terminal 的预览版。&lt;/p&gt;
&lt;p&gt;Windows Terminal 是微软上个月在开发者大会上宣布的新命令行终端，源代码发布在 GitHub 上。Windows Terminal 支持多标签、Unicode 和 UTF-8 字符、GPU 加速 DirectWrite/DirectX 文本渲染引擎，定制主题、样式和配置。更多特性详细介绍可参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487033&amp;amp;idx=1&amp;amp;sn=2cc918c4a2f9ddf7da341e7996183872&amp;amp;chksm=eac52f10ddb2a606ee40e98646dc8eb8b4409ef88169c6172f5b42ead00c866c4693d7a3387f&amp;amp;token=1817029934&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;下载安装 Windows Terminal  需要 Windows 10 version 18362.0 及更新版本。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.solidot.org/story?sid=61096&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.solidot.org/story?sid=61096&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/29/5d3ebfc2aaafd80489.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/107833/dns-over-https-ga&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谷歌宣布 DNS Over HTTPS 服务普遍可用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;谷歌于 2009 年推出 Google Public DNS，并于 2016 年在此基础上推出 DNS Over HTTPS，这是一项实验性服务，旨在加强 DNS 的安全性，此前的服务入口是 &lt;a href=&quot;http://dns.google.com/experimental%E3%80%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dns.google.com/experimental。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在谷歌宣布 DoH 已经正式普遍可用，并且完全支持 RFC 8484 文档，同时继续提供对 2016 年推出的 JSON API 的支持。用户可以使用 dns.google 域中的 DoH 解析 DNS，其中包含与常规 DNS 服务相同的任播地址，如 8.8.8.8。新的访问入口是：&lt;a href=&quot;https://dns.google/dns-query&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dns.google/dns-query&lt;/a&gt; ((RFC 8484) 和 &lt;a href=&quot;https://dns.google/resolve&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dns.google/resolve&lt;/a&gt; (JSON API)。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/107833/dns-over-https-ga&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/107833/dns-over-https-ga&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/fe994bc0e5e401523320b7953a92696045f.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;http://news.51cto.com/art/201906/598801.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mozilla 发布下一代移动浏览器 Firefox Preview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mozilla 已于近日在 Google Play 正式上架面向 Android 的全新移动浏览器 Firefox Preview。&lt;/p&gt;
&lt;p&gt;与现已推出与大多数浏览器所采用的 Bink 渲染引擎不同，Firefox Preview 的渲染引擎 GeckoView 由 Mozilla 自己开发，这种独立性一定程度上避免了互联网被单一的科技巨头控制。&lt;/p&gt;
&lt;p&gt;虽然已经公开发布，不过 Mozilla 表示 Firefox Preview 仍处于测试阶段，真正的大招会憋到今年秋季再放，届时将提供更丰富的功能和更精美的界面。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://news.51cto.com/art/201906/598801.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://news.51cto.com/art/201906/598801.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s4.51cto.com/oss/201907/01/da021001f2e94c283777ac8f67a880b8.jpg-wh_651x-s_2719880675.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenJDK Docker 镜像存在错误版本漏洞&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OpenJDK 邮件列表确认，OpenJDK 的官方 Docker 镜像中包含错误标记版本号，这表明部分 JRE 应包含的安全补丁实际上并不存在。&lt;/p&gt;
&lt;p&gt;该问题已经通过 OpenJDK 和 Debian 间的跨社区协作得以解决。该 “官方” 版本是由 Docker 和其他方制作的，因为 OpenJDK 社区没有创建镜像或生成构建。该 Docker 镜像已被下载超过一千万次。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://www.oschina.net/news/107663/v-lang-source-code-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安全的全新编程语言 V 发布首个可用版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;日前，一种新的静态类型编程语言 V 语言正式开源了，并发布了首个可用版本。&lt;/p&gt;
&lt;p&gt;据了解，V 语言全名叫：Vlang。V 语言是一个结合 Go 语言的简洁以及 Rust 的安全特性的新语言，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/107663/v-lang-source-code-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/107663/v-lang-source-code-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/vlang/v/master/examples/tetris/screenshot.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 2 期 )</title>
    <link href="https://www.hi-linux.com/posts/43609.html"/>
    <id>https://www.hi-linux.com/posts/43609.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T04:44:06.740Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你想我们一起交流，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h3 id="业界资讯">业界资讯</h3><p>1、<a href="https://www.cnbeta.com/articles/soft/862853.htm" target="_blank" rel="noopener">GitHub 官方中文文档上线</a></p><p>GitHub 推出官方中文帮助文档，这是继日文版之后第二个非英语语种的帮助文档。GitHub 希望借此能够帮助中文开发者更好的理解 GitHub 操作规范，更加熟悉对 GitHub 的操作。</p><p>链接：<a href="https://www.cnbeta.com/articles/soft/862853.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/soft/862853.htm</a></p><p><img src="https://static.cnbetacdn.com/article/2019/0701/81c468f1fc60c58.jpeg" alt=""></p><p>2、<a href="https://github.com/microsoft/WSL2-Linux-Kernel" target="_blank" rel="noopener">微软正式开源 WSL 2 内核源码</a></p><p>微软在今年 5 月举办的 Build 2019 上宣布了第二代 Windows 的 Linux 子系统 WSL 2。与第一代相比，WSL 2 重新设计了架构，使用真正的 Linux 内核，支持在 Windows 上运行 ELF64 Linux 二进制文件。</p><p>近日，微软正式开源了 WSL 2 的内核源码，并将代码托管在 GitHub 上。</p><p>链接：<a href="https://github.com/microsoft/WSL2-Linux-Kernel" target="_blank" rel="noopener">https://github.com/microsoft/WSL2-Linux-Kernel</a></p><p><img src="https://www.hi-linux.com/img/linux/wsl2.jpeg" alt=""></p><p>3、<a href="https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1" target="_blank" rel="noopener">Gitlab 从 12.1 版本开始将不再支持 MySQL</a></p><p>Gitlab 官方宣布，将从 12.1 版本开始不再支持 MySQL 数据库。</p><p>链接：<a href="https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1" target="_blank" rel="noopener">https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1</a></p><p><img src="https://about.gitlab.com/images/blogimages/gitlab-blog-cover.png" alt=""></p><p>4、<a href="https://www.oschina.net/news/108045/debian-10-released" target="_blank" rel="noopener">Debian 10 Buster 正式发布</a></p><p>经历了 25 个月的开发后，Debian 团队于 2019 年 7 月 6 日正式宣布推出代号为 「Buster」 的 Debian 10 稳定版。</p><p>Debian 10 是一个主要版本，带来了许多更新的组件和许多新功能和改进。此版本将在未来 5 年获得由 Debian 安全团队和 Debian 长期支持团队提供的技术支持。</p><p>链接：<a href="https://www.oschina.net/news/108045/debian-10-released" target="_blank" rel="noopener">https://www.oschina.net/news/108045/debian-10-released</a></p><p><img src="https://static.oschina.net/uploads/space/2019/0707/142126_FSUH_2720166.png" alt=""></p><p>5、<a href="https://www.leikeji.com/article/27315" target="_blank" rel="noopener">Chrome 代码出现广告拦截功能，谷歌或将治理网页广告乱象</a></p><p>几乎每一个网民都逃不开广告的影响，它已经深刻地进入到我们的生活之中。无论是刷新信息流还是访问某个具体的内容，广告都会在那里出现，从不在乎你是否想看到。有一部分广告明显影响到了访问网页时的体验，有的会让内容难以查看，有的则会大幅占用系统资源，甚至让电脑操作变慢。</p><p>作为当前市场占有率最大的浏览器 Chrome 打算为用户分担一部分烦恼。根据 9to5google 的报道，Chrome 浏览器的开源代码中出现了内置广告拦截功能的踪影，这项功能将帮用户屏蔽掉部分广告。</p><p>根据页面相关描述，Chrome 会对广告对系统资源的占用进行分析，然后找出那些使用了太多带宽或者 CPU 能力的广告并屏蔽掉它们。最后用户只会看到广告被屏蔽后 “该广告已经移除” 提示。</p><p>链接：<a href="https://www.leikeji.com/article/27315" target="_blank" rel="noopener">https://www.leikeji.com/article/27315</a></p><p><img src="https://www.hi-linux.com/img/linux/chrome.png" alt=""></p><p>6、<a href="https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat" target="_blank" rel="noopener">IBM 340 亿美元红帽收购案完成：定义混合云的开放未来</a></p><p>7 月 9 日晚，IBM 宣布以 340 亿美元（约合人民币 2340 亿）正式收购红帽。早在去年 10 月 29 日，IBM 和红帽就共同宣布两家公司已达成最终协议。根据协议，IBM 将收购红帽所有已发行的普通股，每股 190 美元，总企业价值约 340 亿美元。现在，这次庞大的收购终于完成。</p><p>IBM 表示，本次收购重新定义了企业级云市场。红帽开放的混合云技术，与 IBM 广泛且深入的创新和行业洞察，以及在超过 175 个国家和地区领先的销售能力相结合，通过提供下一代混合多云平台，将共同加速企业创新。基于 Linux 和 Kubernetes 等开源技术，该平台可以使企业在本地、私有云以及多个公有云平台上安全部署、运行、管理数据及应用。</p><p>链接：<a href="https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat" target="_blank" rel="noopener">https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat</a></p><p><img src="https://oscimg.oschina.net/oscnet/30975bdc2ed93d5937c918fca2f46814f05.jpg" alt=""></p><a id="more"></a><h3 id="趣站酷软">趣站酷软</h3><p>1、<a href="https://github.com/IBM/kui" target="_blank" rel="noopener">Kui</a></p><p>Kui 是一款由 IBM 开源的用来管理 Kubernetes 集群的 CLI 工具，Kui 使用 Electron 提供 GUI 能力。</p><p>Kui 结合了原有 CLI 的强大功能，并提供一种可视化的方式，方便我们对 Kubernetes 中 YAML 或者 JSON 格式数据的处理。</p><p>项目地址: <a href="https://github.com/IBM/kui" target="_blank" rel="noopener">https://github.com/IBM/kui</a></p><p><img src="https://raw.githubusercontent.com/IBM/kui/master/docs/readme/images/kubectl-examples.jpg" alt=""></p><p>2、<a href="https://github.com/sentialx/multrin" target="_blank" rel="noopener">Multrin</a></p><p>Multrin 是一个基于 Electron、React、样式组件与 TypeScript 的应用，它可以将不同应用组织在一个 tab 标签下，大大提高生产力。</p><p>目前支持 Windows 与 macOS，Linux 支持正在开发中。</p><p>项目地址: <a href="https://github.com/sentialx/multrin" target="_blank" rel="noopener">https://github.com/sentialx/multrin</a></p><p><img src="https://github.com/sentialx/multrin/raw/master/screenshots/screen1.gif" alt=""></p><p>3、<a href="https://github.com/huangjianke/Gitter" target="_blank" rel="noopener">Gitter</a></p><p>一个 GitHub 的微信小程序客户端，可能是目前颜值最高的。</p><p>项目地址: <a href="https://github.com/huangjianke/Gitter" target="_blank" rel="noopener">https://github.com/huangjianke/Gitter</a></p><p><img src="https://raw.githubusercontent.com/huangjianke/Gitter/master/images/img00.png" alt=""></p><p>4、<a href="https://github.com/derailed/popeye" target="_blank" rel="noopener">Popeye</a></p><p>Popeye 是一个 Kubernetes 集群资源清理的实用程序，它可以实时扫描 Kubernetes 集群并报告已部署资源和配置的潜在问题。</p><p>Popeye 根据部署的内容而不是磁盘上的内容来清理群集。 通过扫描您的群集，它可以检测到错误配置并确保最佳实践，从而防止潜在问题发生。</p><p>Popeye 是一个只读工具，它不会以任何方式改变你的任何 Kubernetes 资源。</p><p>项目地址: <a href="https://github.com/derailed/popeye" target="_blank" rel="noopener">https://github.com/derailed/popeye</a></p><p><img src="https://github.com/derailed/popeye/raw/master/assets/a_score.png" alt=""></p><p>5、<a href="https://github.com/hiroppy/fusuma" target="_blank" rel="noopener">Fusuma</a></p><p>Fusuma 是一个简单方便的使用 Markdown 创建幻灯片的工具。</p><p>你只需要写好想要作为幻灯片展示的 Markdown，并按照顺序整理好目录结构，再写好需要的 CSS 文件之后，这个项目就能够让你简单的使用浏览器展示它们，或者是把它整体导出为一个 PDF 文件。</p><p>项目地址: <a href="https://github.com/hiroppy/fusuma" target="_blank" rel="noopener">https://github.com/hiroppy/fusuma</a></p><p><img src="https://raw.githubusercontent.com/hiroppy/fusuma/master/site/docs/assets/live-mode-comments.png" alt=""></p><p>6、<a href="https://github.com/jesseduffield/lazydocker" target="_blank" rel="noopener">LazyDocker</a></p><p>这是一个为了能在终端中更方便管理 Docker 和 Docker-Compose 的简单终端 UI 工具。</p><p>作者表示记住 Docker 命令很难，并且在多个终端窗口中跟踪容器几乎是不可能的。LazyDocker 正是为了解决这种问题而产生的，它可以在一个终端窗口中拥有所需的所有信息，并且每个 Docker 常用命令都可以绑定快捷键，同时可以添加自定义命令。</p><p>项目地址: <a href="https://github.com/jesseduffield/lazydocker" target="_blank" rel="noopener">https://github.com/jesseduffield/lazydocker</a></p><p><img src="https://oscimg.oschina.net/oscnet/4ad1a013236976fa04761509d03d4fbeecf.jpg" alt=""></p><h3 id="技术文章">技术文章</h3><p>1、<a href="https://www.cnblogs.com/xuxinkun/p/11025020.html" target="_blank" rel="noopener">Docker/Kubernetes 国内镜像源解决方式</a></p><p>本文整理了国内的一些 Docker/Kubernetes 可用的镜像源，非常实用。</p><p>链接：<a href="https://www.cnblogs.com/xuxinkun/p/11025020.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuxinkun/p/11025020.html</a></p><p>2、<a href="https://free.com.tw/mojave-dark-menu-bar-dock/" target="_blank" rel="noopener">如何让 macOS Mojave 只有菜单列和 Dock 使用深色模式？</a></p><p>你可能觉得 macOS 浅色介面有点刺眼，但 Mojave 深色模式又太过深邃？</p><p>至少我使用起来并不是那么愉快，反而花更多时间在辨识不太清楚的文字或图标，甚至有点怀念更早之前的暗色选单（Mojave 以后已经没有这个选项），如果你跟我一样，或许可以考虑透过一个小设定来为现在的 macOS Mojave 开启深色菜单和 Dock 功能。</p><p>链接：<a href="https://free.com.tw/mojave-dark-menu-bar-dock/" target="_blank" rel="noopener">https://free.com.tw/mojave-dark-menu-bar-dock/</a></p><p>3、<a href="https://www.jianshu.com/p/68384978c0a3" target="_blank" rel="noopener">对运维开发工作的一些思考</a></p><p>运维开发这个岗位与普通的业务开发不同，与日常的运维工作也不同，要求兼顾开发与运维两种能力。既要掌握不弱于业务开发的开发技术，又要负责 SRE 同学日常的运维能力。上线之前，还要像 QA 同学一样，对自己的服务进行测试和分级变更。本文将针对运维领域「自动化平台开发」的工作对 DevOPS 进行探讨。</p><p>链接：<a href="https://www.jianshu.com/p/68384978c0a3" target="_blank" rel="noopener">https://www.jianshu.com/p/68384978c0a3</a></p><p>4、<a href="http://blog.ihipop.info/2019/07/5212.html" target="_blank" rel="noopener">记录一次磁盘镜像的 LVM 分区缩小调整过程</a></p><p>本文将分享一些 LVM 分区大小调整的技巧。</p><p>链接：<a href="http://blog.ihipop.info/2019/07/5212.html" target="_blank" rel="noopener">http://blog.ihipop.info/2019/07/5212.html</a></p><p>5、使用斐讯 N1 作为 Prometheus 监控服务器</p><p>新出的树莓派 4，性能方面可以说对于老的 3B+ 的版本可以说是有全面的提升。但价格方面 4G 内存配置的就已经需要 50$，已经逼近台 x86 的准系统。同时因为树莓派是裸板，如果想要在生产环境使用，后面还需要自己增加存储、外壳等，全套上去其实性价比已经不高。</p><p>本文作者另辟蹊径采用斐讯的 N1 来部署了一个 Prometheus 监控服务器。</p><p>链接：<a href="https://www.gracecode.com/posts/3184.html" target="_blank" rel="noopener">https://www.gracecode.com/posts/3184.html</a></p><p><img src="https://friable.rocks/_/2019_07_01/1561965398165370.png" alt=""></p><h3 id="每周观点">每周观点</h3><p>1、梦想可以天花乱坠，理想是我们一步一个脚印踩出来的坎坷道路。—— 三毛<br>2、没事早点睡，有空多挣钱。—— 佚名<br>3、在你我生命中，都不需要完美。做自己的萤火，温暖少数人就足够了。—— 佚名<br>4、人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以至始至终陪着走完，当陪你的人要下车时，即使不舍，也该心存感激，然后挥手道别。—— 宫崎骏「千与千寻」</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你想我们一起交流，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h3 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnbeta.com/articles/soft/862853.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 官方中文文档上线&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub 推出官方中文帮助文档，这是继日文版之后第二个非英语语种的帮助文档。GitHub 希望借此能够帮助中文开发者更好的理解 GitHub 操作规范，更加熟悉对 GitHub 的操作。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/soft/862853.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/soft/862853.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.cnbetacdn.com/article/2019/0701/81c468f1fc60c58.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://github.com/microsoft/WSL2-Linux-Kernel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软正式开源 WSL 2 内核源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软在今年 5 月举办的 Build 2019 上宣布了第二代 Windows 的 Linux 子系统 WSL 2。与第一代相比，WSL 2 重新设计了架构，使用真正的 Linux 内核，支持在 Windows 上运行 ELF64 Linux 二进制文件。&lt;/p&gt;
&lt;p&gt;近日，微软正式开源了 WSL 2 的内核源码，并将代码托管在 GitHub 上。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://github.com/microsoft/WSL2-Linux-Kernel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/microsoft/WSL2-Linux-Kernel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/wsl2.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gitlab 从 12.1 版本开始将不再支持 MySQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitlab 官方宣布，将从 12.1 版本开始不再支持 MySQL 数据库。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://about.gitlab.com/images/blogimages/gitlab-blog-cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.oschina.net/news/108045/debian-10-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Debian 10 Buster 正式发布&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经历了 25 个月的开发后，Debian 团队于 2019 年 7 月 6 日正式宣布推出代号为 「Buster」 的 Debian 10 稳定版。&lt;/p&gt;
&lt;p&gt;Debian 10 是一个主要版本，带来了许多更新的组件和许多新功能和改进。此版本将在未来 5 年获得由 Debian 安全团队和 Debian 长期支持团队提供的技术支持。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108045/debian-10-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108045/debian-10-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2019/0707/142126_FSUH_2720166.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.leikeji.com/article/27315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome 代码出现广告拦截功能，谷歌或将治理网页广告乱象&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;几乎每一个网民都逃不开广告的影响，它已经深刻地进入到我们的生活之中。无论是刷新信息流还是访问某个具体的内容，广告都会在那里出现，从不在乎你是否想看到。有一部分广告明显影响到了访问网页时的体验，有的会让内容难以查看，有的则会大幅占用系统资源，甚至让电脑操作变慢。&lt;/p&gt;
&lt;p&gt;作为当前市场占有率最大的浏览器 Chrome 打算为用户分担一部分烦恼。根据 9to5google 的报道，Chrome 浏览器的开源代码中出现了内置广告拦截功能的踪影，这项功能将帮用户屏蔽掉部分广告。&lt;/p&gt;
&lt;p&gt;根据页面相关描述，Chrome 会对广告对系统资源的占用进行分析，然后找出那些使用了太多带宽或者 CPU 能力的广告并屏蔽掉它们。最后用户只会看到广告被屏蔽后 “该广告已经移除” 提示。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.leikeji.com/article/27315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.leikeji.com/article/27315&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/chrome.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IBM 340 亿美元红帽收购案完成：定义混合云的开放未来&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7 月 9 日晚，IBM 宣布以 340 亿美元（约合人民币 2340 亿）正式收购红帽。早在去年 10 月 29 日，IBM 和红帽就共同宣布两家公司已达成最终协议。根据协议，IBM 将收购红帽所有已发行的普通股，每股 190 美元，总企业价值约 340 亿美元。现在，这次庞大的收购终于完成。&lt;/p&gt;
&lt;p&gt;IBM 表示，本次收购重新定义了企业级云市场。红帽开放的混合云技术，与 IBM 广泛且深入的创新和行业洞察，以及在超过 175 个国家和地区领先的销售能力相结合，通过提供下一代混合多云平台，将共同加速企业创新。基于 Linux 和 Kubernetes 等开源技术，该平台可以使企业在本地、私有云以及多个公有云平台上安全部署、运行、管理数据及应用。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/30975bdc2ed93d5937c918fca2f46814f05.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 3 期 )</title>
    <link href="https://www.hi-linux.com/posts/27209.html"/>
    <id>https://www.hi-linux.com/posts/27209.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T04:52:42.443Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.cnbeta.com/articles/soft/865277.htm" target="_blank" rel="noopener">Linux Kernel 5.2 正式版发布，代号为 Bobtail Squid</a></p><p>经历了 7 个 RC 候选版本之后，Linus Torvalds 正式宣布了 Linux Kernel 5.2 正式版。本次主要版本更新在改进驱动程序和核心组件之外，还引入了一些有趣的特性和增强功能。不过需要注意的是 Linux Kernel 5.2 并非长期支持（LTS）分支，因此推荐注重稳定的用户还是使用当前的 LTS 内核。</p><p>链接：<a href="https://www.cnbeta.com/articles/soft/865277.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/soft/865277.htm</a></p><p><img src="https://static.cnbetacdn.com/thumb/article/2019/0708/1cb25fe820d7a25.jpg" alt=""></p><p>2、<a href="https://www.cnbeta.com/articles/tech/865885.htm" target="_blank" rel="noopener">知名 DNS 解析服务商 CloudXNS 将停止免费服务</a></p><p>国内知名 DNS 解析服务商「CloudXNS」发布了 “关于停止免费用户解析服务的公告”。该公告表示：“为贯彻国家网络安全政策法规，加强监管力度，更好地服务于 VIP 客户，CloudXNS 将停止免费用户使用 CloudXNS 的解析服务。”</p><p>链接：<a href="https://www.cnbeta.com/articles/tech/865885.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/tech/865885.htm</a></p><p>3、<a href="https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html" target="_blank" rel="noopener">Google 开源 robots.txt 解析器，推动 REP 标准化</a></p><p>Google 在其博客上发布了一个重要消息，它宣布 Google 开源了存储 robots.txt 解析器的 C++ 库，以便推动 REP（Robots Exclusion Protocol，也称爬虫协议、机器人协议）成为互联网标准。</p><p>链接：<a href="https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html" target="_blank" rel="noopener">https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html</a></p><p><img src="https://static.leiphone.com/uploads/new/images/20190702/5d1b31955ff60.png" alt=""></p><p>4、<a href="https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC" target="_blank" rel="noopener">阿里云 PHP Composer 全量镜像正式上线</a></p><p>阿里云正式上线 PHP Composer 全量镜像，所有 PHP 开发者都可以通过我们的开发者社区 <a href="http://developer.aliyun.com/composer" target="_blank" rel="noopener">developer.aliyun.com/composer</a> 加速 Composer 安装器。</p><p>这款镜像工具的最大优势是快，几乎实现与 PHP Packagist 官方实时同步，每隔 30 秒刷新全国 CDN 缓存。它基于阿里云的对象存储 OSS 和 CDN 研发同步系统，通过任务分发，实现同步的快速和稳定。</p><p>链接：<a href="https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC" target="_blank" rel="noopener">https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC</a></p><p>5、 <a href="https://www.oschina.net/news/108197/coredns-1-5-2-released" target="_blank" rel="noopener">CoreDNS v1.5.2 发布</a></p><p>CoreDNS 1.5.2 发布了，该版本包含一些小的 Bug 修复。在此版本中，一个重要的变更便是移除掉了 upstream 插件相关的所有文档和说明。在此次变更之后， upstream 配置行便可直接移除。</p><p>链接：<a href="https://www.oschina.net/news/108197/coredns-1-5-2-released" target="_blank" rel="noopener">https://www.oschina.net/news/108197/coredns-1-5-2-released</a></p><p><img src="https://www.hi-linux.com/img/linux/coredns.jpeg" alt=""></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://browserframe.com/" target="_blank" rel="noopener">BrowserFrame</a></p><p>「BrowserFrame」是一个很好用的在线工具，可以将截图或任何图片加上浏览器外框。</p><p>BrowserFrame 提供了两种方式来生成截图，分别是上传本地截图和输入网址生成截图。后者输入网址生产截图由于会受到网页加载速度的影响，生成速度可能会比较慢，容易出现「生成失败」的情况，建议选择直接上传本地截图的方法。</p><p>BrowserFrame 支持多种平台的多款浏览器样式，包括 Google Chrome、Firefox、Safari、Opera、IE 和 Edge 等。你不仅可以根据自己喜好选择不同的样式，还可以自定义一些细节设置，比如：窗口顏色、宽度、高度或间距等等。</p><p>项目地址: <a href="https://browserframe.com/" target="_blank" rel="noopener">https://browserframe.com/</a></p><p><img src="https://www.hi-linux.com/img/linux/BrowserFrame.jpeg" alt=""></p><p>2、<a href="https://github.com/thegreatjavascript/FakeScreenshot" target="_blank" rel="noopener">FakeScreenshot</a></p><p>这是一个可以伪造微博、知乎、豆瓣、简书等网站界面截图的项目，该项目能够非常简单的生成一个能够以假乱真的截图。</p><p>实际上想要做一张假截图是很简单的事情，不管是模仿还是干脆 PS 合成一个，导致很多时候这些截图会被拿去传播谣言。这个项目的意义在于告诉人们看到任何截图的时候都应该保持怀疑。</p><p>项目地址: <a href="https://github.com/thegreatjavascript/FakeScreenshot" target="_blank" rel="noopener">https://github.com/thegreatjavascript/FakeScreenshot</a></p><p><img src="https://openingsource.org/wp-content/uploads/2019/06/473-1.png" alt=""></p><p>3、<a href="https://mdnice.com/" target="_blank" rel="noopener">Markdown Nice</a></p><p>Markdown Nice 是一个开源的专门针对微信公众号文章排版而设计的 Markdown 在线编辑器。编写完成即排版完成，复制到公众号文章编辑器即可，非常好用。</p><p>Markdown Nice 还有很多特色功能，比如：支持自定义样式、浏览器中实时保存和预览内容样式、支持零配置图床、脚注、代码、公式等。</p><p>项目地址: <a href="https://mdnice.com/" target="_blank" rel="noopener">https://mdnice.com/</a></p><p><img src="https://www.hi-linux.com/img/linux/mdnice.jpeg" alt=""></p><p>4、<a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a></p><p><a href="http://SM.MS" target="_blank" rel="noopener">SM.MS</a> 是由 V2EX 的 Showfom 自建的一个免费图床，图床速度还不错，已经运行四年多了。该图床免注册且永久存储，且无外链、无流量限制，支持 HTTPS。</p><p>图床图片上传限制：每个图片最大 5M，每次最多上传 10 张。</p><p>项目地址：<a href="https://sm.ms" target="_blank" rel="noopener">https://sm.ms</a></p><p><img src="https://www.hi-linux.com/img/linux/smms.jpeg" alt=""></p><p>5、<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a></p><p>PicGo 是一款开源跨平台的免费图片上传工具以及图床相册管理软件，支持 Windows、macOS 和 Linux 系统。</p><p>PicGo 使用非常简单，它能帮你快速地将图片上传到微博、又拍云、阿里云 OSS、腾讯云 COS、七牛、GitHub、<a href="http://sm.ms" target="_blank" rel="noopener">sm.ms</a>、Imgur 等常见的免费图床网站或云存储服务上，并自动复制图片的链接到剪贴板里，使用上非常高效便捷。</p><p>项目地址：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></p><p><img src="https://i.loli.net/2019/05/08/5cd2dc258f927.png" alt=""></p><p>6、<a href="https://www.pexels.com" target="_blank" rel="noopener">Pexels</a></p><p>Pexels 堪称最值得推荐的免费图库之一，它的特色是将许多大大小小图库及素材来源整合在同一网站，加入搜索、分类及标签等功能，让使用者在找图片时更快更准确。</p><p>Pexels 提供各种尺寸的相片，甚至有 HD 高画质的原始图片，无须注册就能下载，更棒的是还能依照使用者需求，设定尺寸后自动在线上裁剪，节省下载后必须自行编辑所耗费的时间。</p><p>项目地址：<a href="https://www.pexels.com/" target="_blank" rel="noopener">https://www.pexels.com/</a></p><p><img src="https://www.hi-linux.com/img/linux/Pexels.jpeg" alt=""></p><p>7、<a href="https://github.com/sxfad/porter" target="_blank" rel="noopener">Porter</a></p><p>Porter 是一款数据同步中间件，主要用于解决同构/异构数据库之间的表级别数据同步问题。</p><p>Porter 是一个插件友好型的数据聚合、分发中间件，提供源端、目标端、数据过滤等插件自定义开发的能力，能够根据场景需要轻松定制同步任务。</p><p>项目地址：<a href="https://github.com/sxfad/porter" target="_blank" rel="noopener">https://github.com/sxfad/porter</a></p><p><img src="https://raw.githubusercontent.com/sxfad/porter/master/doc/img/Home.png" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="https://cloud.tencent.com/developer/article/1448440" target="_blank" rel="noopener">如何在 MySQL 8.0.16 在组复制中启用成员自动重新加入</a></p><p>随着 MySQL 8.0.16 的发布，MGR 添加了一些功能以增强其高可用性。其中一个功能是能够在某些情况下启用已离开组的成员自动重新加入，而无需用户干预。本文将介绍这一新特性所带来的变化。</p><p>链接：<a href="https://cloud.tencent.com/developer/article/1448440" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1448440</a></p><p>2、<a href="https://www.yichya.dev/dns-poisoning-and-countering/" target="_blank" rel="noopener">DNS 污染和攻击</a></p><p>DNS 污染极为简单易行且效果极佳，这篇文章将介绍一下常见的 DNS 投毒现象，以及几种避免 DNS 攻击的解决方案。</p><p>链接：<a href="https://www.yichya.dev/dns-poisoning-and-countering/" target="_blank" rel="noopener">https://www.yichya.dev/dns-poisoning-and-countering/</a></p><p>3、<a href="https://arkingc.github.io/2018/12/11/2018-12-11-docker-storage-persist" target="_blank" rel="noopener">Docker 容器数据持久化</a></p><p>本文介绍了三种常用的 Docker 数据持久化的使用方法和适用的场景。</p><p>链接：<a href="https://arkingc.github.io/2018/12/11/2018-12-11-docker-storage-persist/" target="_blank" rel="noopener">https://arkingc.github.io/2018/12/11/2018-12-11-docker-storage-persist/</a></p><p>4、<a href="https://sspai.com/post/55703" target="_blank" rel="noopener">如何在 macOS Mojave 中将 U 盘格式化成通用格式</a></p><p>本文将介绍如何在 macOS Mojave 中将 APFS 格式的 U 盘在系统自带的磁盘工具中格式化成通用格式的方法。</p><p>链接：<a href="https://sspai.com/post/55703" target="_blank" rel="noopener">https://sspai.com/post/55703</a></p><h2 id="每周观点">每周观点</h2><p>1、人生重要的不是所站的位置，而是所朝的方向。—— 李嘉诚</p><p>2、如果不继续成长，就会开始走向死亡。—— 华特·迪士尼</p><p>3、这个世界如此美好，值得为它奋战。—— 海明威</p><p>4、这世界不缺少发现，而是缺少发现后的思考。—— 牛根生</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnbeta.com/articles/soft/865277.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux Kernel 5.2 正式版发布，代号为 Bobtail Squid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经历了 7 个 RC 候选版本之后，Linus Torvalds 正式宣布了 Linux Kernel 5.2 正式版。本次主要版本更新在改进驱动程序和核心组件之外，还引入了一些有趣的特性和增强功能。不过需要注意的是 Linux Kernel 5.2 并非长期支持（LTS）分支，因此推荐注重稳定的用户还是使用当前的 LTS 内核。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/soft/865277.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/soft/865277.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.cnbetacdn.com/thumb/article/2019/0708/1cb25fe820d7a25.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnbeta.com/articles/tech/865885.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知名 DNS 解析服务商 CloudXNS 将停止免费服务&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;国内知名 DNS 解析服务商「CloudXNS」发布了 “关于停止免费用户解析服务的公告”。该公告表示：“为贯彻国家网络安全政策法规，加强监管力度，更好地服务于 VIP 客户，CloudXNS 将停止免费用户使用 CloudXNS 的解析服务。”&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/tech/865885.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/tech/865885.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google 开源 robots.txt 解析器，推动 REP 标准化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google 在其博客上发布了一个重要消息，它宣布 Google 开源了存储 robots.txt 解析器的 C++ 库，以便推动 REP（Robots Exclusion Protocol，也称爬虫协议、机器人协议）成为互联网标准。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/images/20190702/5d1b31955ff60.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里云 PHP Composer 全量镜像正式上线&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里云正式上线 PHP Composer 全量镜像，所有 PHP 开发者都可以通过我们的开发者社区 &lt;a href=&quot;http://developer.aliyun.com/composer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;developer.aliyun.com/composer&lt;/a&gt; 加速 Composer 安装器。&lt;/p&gt;
&lt;p&gt;这款镜像工具的最大优势是快，几乎实现与 PHP Packagist 官方实时同步，每隔 30 秒刷新全国 CDN 缓存。它基于阿里云的对象存储 OSS 和 CDN 研发同步系统，通过任务分发，实现同步的快速和稳定。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、 &lt;a href=&quot;https://www.oschina.net/news/108197/coredns-1-5-2-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CoreDNS v1.5.2 发布&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CoreDNS 1.5.2 发布了，该版本包含一些小的 Bug 修复。在此版本中，一个重要的变更便是移除掉了 upstream 插件相关的所有文档和说明。在此次变更之后， upstream 配置行便可直接移除。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108197/coredns-1-5-2-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108197/coredns-1-5-2-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/coredns.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 4 期 )</title>
    <link href="https://www.hi-linux.com/posts/43583.html"/>
    <id>https://www.hi-linux.com/posts/43583.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:20:54.834Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.williamlong.info/archives/5771.html" target="_blank" rel="noopener">谷歌确认回归中国的 Dragonfly 计划彻底终止</a></p><p>近日，谷歌副总裁巴提亚（Karan Bhatia）出席美国参议院司法委员会举行的听证会时确认谷歌已经终止了在中国推出审查搜索引擎的 “蜻蜓计划”，该计划原打算推出中国定制版、通过中国法律审查的搜索引擎。</p><p>链接：<a href="https://www.williamlong.info/archives/5771.html" target="_blank" rel="noopener">https://www.williamlong.info/archives/5771.html</a></p><p><img src="https://i.loli.net/2019/07/22/5d355ee15057b67703.jpg" alt=""></p><p>2、<a href="https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code" target="_blank" rel="noopener">微软计划将 Rust 作为 C 和 C++ 的安全替代品</a></p><p>微软正在探索使用 Rust 编程语言作为 C、C++ 和其他语言的替代方案，以此来改善应用程序的安全状况。</p><p>链接：<a href="https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code" target="_blank" rel="noopener">https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code</a></p><p><img src="https://oscimg.oschina.net/oscnet/a6c6690735238bf57e020b1beb346f77686.jpg" alt=""></p><p>3、<a href="https://www.oschina.net/news/108462/develop-with-python-on-windows" target="_blank" rel="noopener">微软官方上线 Python 配置教程</a></p><p>微软近日上线了一套 Python 配置教程 《Develop with Python on Windows》，文档内容包括设置 Python 开发环境、在 Windows 与 WSL 子系统中安装相应开发工具，以及集成 VS Code 与 Git 工具并进行开发等。</p><p>链接：<a href="https://www.oschina.net/news/108462/develop-with-python-on-windows" target="_blank" rel="noopener">https://www.oschina.net/news/108462/develop-with-python-on-windows</a></p><p><img src="https://i.loli.net/2019/07/23/5d36cacdacd2d91648.jpg" alt=""></p><p>4、<a href="https://www.oschina.net/news/108481/docker-ce-19-03-0-released" target="_blank" rel="noopener">Docker CE 19.03 正式发布，无需 root 权限</a></p><p>Docker CE 19.03 和 EE 3.0 都已经正式发布，19.03 主要内容包括无需 root 权限、支持 GPU 的增强功能和 CLI 插件更新等等。Docker CE 19.03 现在是允许非 root 用户运行守护程序，启用 Rootless 模式可以防止攻击者夺取主机的 root 权限，即使 Docker 存在漏洞或设置错误。</p><p>链接：<a href="https://www.oschina.net/news/108481/docker-ce-19-03-0-released" target="_blank" rel="noopener">https://www.oschina.net/news/108481/docker-ce-19-03-0-released</a></p><p>5、<a href="https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb" target="_blank" rel="noopener">华为将开源全球首个 AI 原生数据库 GaussDB 内核</a></p><p>日前，华为在正在进行的鲲鹏计算产业论坛上宣布将开源其内部大规模使用的 GaussDB 数据库内核。该内核具备超越现有开源 MySQL、PostgreSQL 的极致性能，在鲲鹏 920 服务器上 TPC-C 性能能够达到 150 万 TPMC。并具备业内最快的故障恢复时间，完全满足各种高端企业用户的 Oracle 替代需求。</p><p>链接：<a href="https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb" target="_blank" rel="noopener">https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb</a></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://github.com/guanpengchn/markdown-resume" target="_blank" rel="noopener">Markdown-Resume</a></p><p>Markdown-Resume 是一个支持 Markdown 和富文本的在线简历排版工具，如果你想快速的制作一个好用又好看的简历，不妨试试哟~</p><p>项目地址: <a href="https://github.com/guanpengchn/markdown-resume" target="_blank" rel="noopener">https://github.com/guanpengchn/markdown-resume</a></p><p><img src="https://www.hi-linux.com/img/linux/markdown-resume.jpeg" alt=""></p><p>2、<a href="https://github.com/joeblau/gitignore.io" target="_blank" rel="noopener">gitignore.io</a></p><p>项目地址: <a href="https://github.com/joeblau/gitignore.io" target="_blank" rel="noopener">https://github.com/joeblau/gitignore.io</a></p><p>这是由 Uber 一名工程师 joeblau 所开发的 .gitignore 文件快速生成工具，开发者只需要在网站上搜索当前正在使用的操作系统、IDE、编程语言，它便会自动生成一个特定的 .gitignore 配置文件。</p><p>如果你不想用网站进行搜索，还可以安装下它的命令行工具。安装完成后，就可以使用 gi 命令来快速生成 .gitignore 配置文件啦，超级方便！</p><p><img src="https://www.hi-linux.com/img/linux/gitignore.jpeg" alt=""></p><p>3、<a href="https://github.com/crossoverJie/blog.toolbox/" target="_blank" rel="noopener">blog.toolbox</a></p><p>这是一个图床搬家工具，可以很方便的帮你将图片批量的从失效的图床搬到新的图床中。</p><p>项目地址: <a href="https://github.com/crossoverJie/blog.toolbox/" target="_blank" rel="noopener">https://github.com/crossoverJie/blog.toolbox/</a></p><p><img src="https://www.hi-linux.com/img/linux/blog-toolbox.gif" alt=""></p><p>4、<a href="https://iplist.cc" target="_blank" rel="noopener">IPList</a></p><p>IPList 是一个在线 IP、Hostname 查询工具，支持 IPv4、IPv6。只要输入查询内容就会显示出相关信息，也可看到打开网站你目前的 IP 地址。</p><p>IPList 实际上一个免费的 IP 信息查询 API，可供开发者快速取得某个 IP 或 Hostname 的信息，只要把查询的对象拼接在 <a href="https://iplist.cc/api/" target="_blank" rel="noopener">https://iplist.cc/api/</a> 网址后面就会得到结果。</p><p>项目地址: <a href="https://iplist.cc/" target="_blank" rel="noopener">https://iplist.cc/</a></p><p><img src="https://www.hi-linux.com/img/linux/iplist.jpeg" alt=""></p><p>5、<a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">Learn-Regex</a></p><p>这个项目是一个关于正则表达式的教程，不仅收录了学习资料，还提供了一个在线的学习网站帮助巩固所学，在实操中多练习一下能够让你更快的达到不需要每次使用的时候都翻开教程的境界，熟能生巧，这种东西还是全记下来用的才方便。</p><p>项目地址: <a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">https://github.com/ziishaned/learn-regex</a></p><p><img src="https://www.hi-linux.com/img/linux/Learn-Regex.png" alt=""></p><p>6、<a href="https://github.com/chubin/cheat.sh" target="_blank" rel="noopener">cheat.sh</a></p><p>一个在线查询 Linux 命令快速使用方法的网站。比如要查询 tar 命令的用法， 只需要执行 curl <a href="http://cht.sh/tar" target="_blank" rel="noopener">cht.sh/tar</a> 就可以很快得到 tar 命令的常用方法，结果比 man 命令简洁实用得多。</p><p>项目地址: <a href="https://github.com/chubin/cheat.sh" target="_blank" rel="noopener">https://github.com/chubin/cheat.sh</a></p><p><img src="https://www.hi-linux.com/img/linux/cheat.jpeg" alt=""></p><p>7、<a href="https://virtual-kubelet.io/" target="_blank" rel="noopener">Virtual Kubelet</a></p><p>Virtual Kubelet 是一个开源的 Kubernetes Kubelet 实现。它伪装成 Kubelet，目的是将 Kubernetes 连接到其他 API，这允许节点得到其他服务(如 ACI、AWS Fargate、IoT Edge 等)的支持。Virtual Kubelet 的主要场景是将Kubernetes API 扩展到无服务器的容器平台（如 ACI 和 Fargate ）。</p><p>Virtual Kubelet 提供一个库，开发者可以在项目中使用这个库来构建自定义 Kubernetes 节点代理。</p><p>项目地址: <a href="https://virtual-kubelet.io/" target="_blank" rel="noopener">https://virtual-kubelet.io/</a></p><p><img src="https://www.hi-linux.com/img/linux/Virtual-Kubelet.png" alt=""></p><p>8、<a href="https://github.com/eryajf/magic-of-sysuse-scripts" target="_blank" rel="noopener">magic-of-sysuse-scripts</a></p><p>一个可快速初始化服务器环境和安装常用软件环境的运维小工具。(@李启龙 投稿)</p><p>项目地址: <a href="https://github.com/eryajf/magic-of-sysuse-scripts" target="_blank" rel="noopener">https://github.com/eryajf/magic-of-sysuse-scripts</a></p><p><img src="https://i.loli.net/2019/07/23/5d36c5cada13b68380.gif" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="https://github.com/aCoder2013/blog/issues/35" target="_blank" rel="noopener">API 网关从入门到放弃</a></p><p>本文将以电商平台为例讲解设计 API 网关的要点和 API 网关的优劣势。</p><p>链接：<a href="https://github.com/aCoder2013/blog/issues/35" target="_blank" rel="noopener">https://github.com/aCoder2013/blog/issues/35</a></p><p><img src="https://www.hi-linux.com/img/linux/api-gateway.jpeg" alt=""></p><p>2、<a href="https://github.com/caicloud/kube-ladder" target="_blank" rel="noopener">Kubernetes 学习路径</a></p><p>本文由才云科技（Caicloud）于 2019 年内部推出，现以开源的形式进行维护。文档旨在为广大从业者提供一个 Kubernetes 学习路径，为大家提供一定的指引。我们最终的目标是让所有人剥茧抽丝般地了解 Kubernetes，不仅仅知道怎么用 Kubernetes，还知道 Kubernetes 各个功能是如何设计的。</p><p>链接：<a href="https://github.com/caicloud/kube-ladder" target="_blank" rel="noopener">https://github.com/caicloud/kube-ladder</a></p><p>3、<a href="https://github.com/blueboay/ceph-study" target="_blank" rel="noopener">Ceph-Study</a></p><p>Ceph 是一个可靠、自动均衡、自动恢复的分布式存储系统，通常可用于对象存储，块设备存储和文件系统存储。Ceph-Study 是网友整理的一份 Ceph 学习指南，写的十分详细，欢迎初学者浏览学习。</p><p>链接：<a href="https://github.com/blueboay/ceph-study" target="_blank" rel="noopener">https://github.com/blueboay/ceph-study</a></p><p><img src="https://i.loli.net/2019/07/22/5d356ee51461d56865.png" alt=""></p><p>4、<a href="https://github.com/jwasham/coding-interview-university" target="_blank" rel="noopener">Coding Interview University</a></p><p>这份指南里面包含 Google 相关的介绍视频、面试过程、教学资源，同时也有数据结构、算法、密码学等计算机专业的知识讲解。</p><p>链接：<a href="https://github.com/jwasham/coding-interview-university" target="_blank" rel="noopener">https://github.com/jwasham/coding-interview-university</a></p><p>为了便于国内开发者查看，掘金翻译团队已将该指南译为中文。</p><p>链接：<a href="https://github.com/jwasham/coding-interview-university/blob/master/translations/README-cn.md" target="_blank" rel="noopener">https://github.com/jwasham/coding-interview-university/blob/master/translations/README-cn.md</a></p><p><img src="https://i.loli.net/2019/07/23/5d366e052e79a91004.jpg" alt=""></p><p>5、<a href="https://github.com/selfteaching/the-craft-of-selfteaching" target="_blank" rel="noopener">自学是门手艺</a></p><blockquote><p>没有自学能力的人没有未来。</p></blockquote><p>「自学是门手艺」是李笑来开源的一本电子书，介绍了掌握自学能力的重要性，并以学习 Python 编程为例子讲解如何进行有效的自学的方法。</p><p>链接：<a href="https://github.com/selfteaching/the-craft-of-selfteaching" target="_blank" rel="noopener">https://github.com/selfteaching/the-craft-of-selfteaching</a></p><p>在线版链接：<a href="http://the-craft-of-selfteaching.surge.sh" target="_blank" rel="noopener">http://the-craft-of-selfteaching.surge.sh</a></p><h2 id="每周观点">每周观点</h2><p>1、美妙人生的关键在于你能迷上什么东西。——「球状闪电」</p><p>2、工作上的执着，实际上是人的一种意志。—— 张近东</p><p>3、生活是属于每个人自己的感受，不属于任何别人的看法。——「活着」</p><p>4、人生的某些障碍，你是逃不掉的。与其费尽周折绕过去，不如勇敢的地攀越，或许这会铸就你人生的高点。—— 宫崎骏「龙猫」</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.williamlong.info/archives/5771.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谷歌确认回归中国的 Dragonfly 计划彻底终止&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，谷歌副总裁巴提亚（Karan Bhatia）出席美国参议院司法委员会举行的听证会时确认谷歌已经终止了在中国推出审查搜索引擎的 “蜻蜓计划”，该计划原打算推出中国定制版、通过中国法律审查的搜索引擎。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.williamlong.info/archives/5771.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.williamlong.info/archives/5771.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/22/5d355ee15057b67703.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软计划将 Rust 作为 C 和 C++ 的安全替代品&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软正在探索使用 Rust 编程语言作为 C、C++ 和其他语言的替代方案，以此来改善应用程序的安全状况。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/a6c6690735238bf57e020b1beb346f77686.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/108462/develop-with-python-on-windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软官方上线 Python 配置教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软近日上线了一套 Python 配置教程 《Develop with Python on Windows》，文档内容包括设置 Python 开发环境、在 Windows 与 WSL 子系统中安装相应开发工具，以及集成 VS Code 与 Git 工具并进行开发等。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108462/develop-with-python-on-windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108462/develop-with-python-on-windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/23/5d36cacdacd2d91648.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.oschina.net/news/108481/docker-ce-19-03-0-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker CE 19.03 正式发布，无需 root 权限&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker CE 19.03 和 EE 3.0 都已经正式发布，19.03 主要内容包括无需 root 权限、支持 GPU 的增强功能和 CLI 插件更新等等。Docker CE 19.03 现在是允许非 root 用户运行守护程序，启用 Rootless 模式可以防止攻击者夺取主机的 root 权限，即使 Docker 存在漏洞或设置错误。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108481/docker-ce-19-03-0-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108481/docker-ce-19-03-0-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;华为将开源全球首个 AI 原生数据库 GaussDB 内核&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;日前，华为在正在进行的鲲鹏计算产业论坛上宣布将开源其内部大规模使用的 GaussDB 数据库内核。该内核具备超越现有开源 MySQL、PostgreSQL 的极致性能，在鲲鹏 920 服务器上 TPC-C 性能能够达到 150 万 TPMC。并具备业内最快的故障恢复时间，完全满足各种高端企业用户的 Oracle 替代需求。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款无需安装，仅需 1 条指令，秒实现内网穿透的神器 Serveo</title>
    <link href="https://www.hi-linux.com/posts/56863.html"/>
    <id>https://www.hi-linux.com/posts/56863.html</id>
    <published>2020-05-15T01:00:00.000Z</published>
    <updated>2020-05-15T04:58:10.461Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-serveo">什么是 Serveo</h2><p><code>Serveo</code> 是一个免费的内网穿透服务，<code>Serveo</code> 可以将本地计算机暴露在互联网上，官方声称其为 <code>Ngrok</code> 的绝佳替代品。</p><p><code>Serveo</code> 其最大优点是使用现有的 <code>SSH</code> 客户端，无需安装任何客户端软件，即可完成端口转发。</p><p><img src="https://www.hi-linux.com/img/linux/serveo.png" alt=""></p><p><code>Serveo</code> 工作原理很简单：当用户通过 <code>SSH</code> 连接到 <code>Serveo</code> 时会与该网站建立一个远程代理，<code>Serveo</code> 随后会生成一个 公共 <code>URL</code>，任何人都可以通过这个 <code>URL</code> 访问你的本地计算机。</p><blockquote><p>项目地址: <a href="https://serveo.net" target="_blank" rel="noopener">https://serveo.net</a></p></blockquote><a id="more"></a><h2 id="使用-serveo">使用 Serveo</h2><p><code>Serveo</code> 的使用非常简单，只需要可以使用 <code>SSH</code> 客户端并且能连接到互联网的任意系统都行。比如：<code>Linux</code>、<code>Windows</code>、<code>MacOS</code> 等系统，就算是 <code>Android</code>、<code>iOS</code> 也同样没问题。下面我们来看几个最常用的使用实例：</p><ol><li>开放本地服务到公网</li></ol><p>将一个本地应用的 8080 端口映射到公网中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果要转发其它端口，只需替换端口为其它就可以了</span><br><span class="line">$ ssh -R 80:localhost:8080 serveo.net</span><br><span class="line">Hi there</span><br><span class="line">Forwarding HTTP traffic from https:&#x2F;&#x2F;heryum.serveo.net</span><br><span class="line">Press g to start a GUI session and ctrl-c to quit.</span><br></pre></td></tr></table></figure><p><code>SSH</code> 连接成功后，会随机生成一个 <code>serveo.net</code> 二级域名。随后你就可以使用浏览器访问这个随机生成的二级域名 <code>heryum.serveo.net</code> 间接访问到本地计算机 8080 端口上的服务了。</p><blockquote><p><code>SSH</code> 初次和一个新服务器建立连接时会有提示，直接选择 yes 即可。</p></blockquote><p>如果你不想使用随机域名，想指定一个固定的二级域名也是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 这里指定为 ywzm.serveo.net，可以根据自身情况进行替换</span><br><span class="line">$ ssh -R ywzm:80:localhost:8080 serveo.net</span><br><span class="line">Hi there</span><br><span class="line">Forwarding HTTP traffic from https:&#x2F;&#x2F;ywzm.serveo.net</span><br><span class="line">Press g to start a GUI session and ctrl-c to quit.</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 上面的域名是简写的，你也可以写出完整的域名。</span><br><span class="line">$ ssh -R ywzm.serveo.net:80:localhost:8080 serveo.net</span><br></pre></td></tr></table></figure><p><code>SSH</code> 连接成功后，此时就可以在公网上使用 <code>ywzm.serveo.net</code> 访问到你本地计算机 8080 端口的服务了。</p><p>上面的例子中，我们转发的是 <code>HTTP</code> 服务。如果你需要转发的是 <code>TCP</code> 服务，又应该怎么做呢？其实方法也很简单，同样只需设置公网的转发端口和本地端口就可以了。例如：我们需要将本地 3306 端口转发到公网中，使用下面命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 可以自行设置公网端口，这里设置为 1492</span><br><span class="line">$ ssh -R 1492:localhost:3306 serveo.net</span><br><span class="line"></span><br><span class="line"># 如果公网端口设置为 0，就会采用一个随机端口进行转发</span><br><span class="line">$ ssh -R 0:localhost:3306 serveo.net</span><br></pre></td></tr></table></figure><ol start="2"><li>将本地 SSH 重定向到公网</li></ol><p>在很多场景下，我们需要远程访问到本地计算机的 <code>SSH</code> 服务。要实现这样的需求也很简单，只需要使用下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 名称为自定义的，这里设置为 myhost</span><br><span class="line">$ ssh -R myhost:22:localhost:22 serveo.net</span><br><span class="line">Hi there</span><br><span class="line">Forwarding SSH traffic from alias &quot;myhost&quot;</span><br><span class="line">Press g to start a GUI session and ctrl-c to quit.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>连接成功后，接下来你就可以从公网上对这个内网计算机的 <code>SSH</code> 进行访问了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -J serveo.net myuser@myhost</span><br><span class="line">Hi there</span><br><span class="line">myuser@myhost&#39;s password:</span><br><span class="line">Last login: Mon Dec 24 21:00:32 2019 from 127.0.0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>-J</code> 选项是在 <code>OpenSSH 7.3</code> 版本才引入的，如果你使用的 <code>SSH</code> 客户端版本较旧，则可以使用 <code>ProxyCommand</code> 选项来替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -o ProxyCommand&#x3D;&quot;ssh -W myhost:22 serveo.net&quot; user@myhost</span><br></pre></td></tr></table></figure><h2 id="一些其它技巧">一些其它技巧</h2><ol><li>保持 SSH 连接不超时</li></ol><p>众所周知，<code>SSH</code> 连接一旦超时就会自动断开，这样就很容易造成服务中断。这里我们只需给 <code>SSH</code> 连接增加一个保活参数 <code>-o ServerAliveInterval=60</code> 就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每隔 60 秒做一次连接保活</span><br><span class="line">$ ssh -o ServerAliveInterval&#x3D;60 -R 80:localhost:8080 serveo.net</span><br></pre></td></tr></table></figure><ol start="2"><li>对 SSH 连接进行守护</li></ol><p>上面的方法虽然可以解决超时的问题，但进程始终是在前台运行的。为了彻底解决这个问题，官方推荐使用 <code>AutoSSH</code> 来进行进程守护。</p><blockquote><p><code>AutoSSH</code> 是一个用来对 <code>SSH</code> 连接进行监控的程序，可在遇到程序问题或者是网络问题时自动进行重连，以达到长期保持 <code>SSH</code> 稳定连接的目的 。</p></blockquote><ul><li>安装 AutoSSH</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Debian &#x2F; Ubuntu 系统</span><br><span class="line">$ apt install autossh -y</span><br><span class="line"></span><br><span class="line"># CentOS &#x2F; RHEL 系统</span><br><span class="line">$ yum install autossh -y</span><br></pre></td></tr></table></figure><ul><li>将 AutoSSH 加入到系统服务</li></ul><p>这里以加入到 <code>Systemd</code> 系统服务为例，此方法适用于 <code>CentOS 7</code>、<code>Debian 8</code>、<code>Ubuntu 16</code> 及以上系统版本。首先，我们创建一个 AutoSSH 的 Systemd 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;autossh.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;autossh</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">Environment&#x3D;&quot;AUTOSSH_GATETIME&#x3D;0&quot;</span><br><span class="line">ExecStart&#x3D;$(command -v autossh) -M 0 -o &quot;ServerAliveInterval 60&quot; -o &quot;ServerAliveCountMax 3&quot; -R 80:localhost:8080 serveo.net</span><br><span class="line">Restart&#x3D;on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p><code>AutoSSH</code> 的 <code>-M</code> 参数主要用于指定一个监听端口来监视 <code>SSH</code> 连接状态，这里指定为 0 的主要目的是禁用 <code>AutoSSH</code> 的监控端口。保活依然使用 <code>SSH</code> 自己的 <code>ServerAliveInterval</code> 和 <code>ServerAliveCountMax</code> 选项来完成。</p></blockquote><p>其次，<code>Systemd</code> 系统服务创建完成后，我们启动这个 <code>AutoSSH</code> 的服务并设置为开机自启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start autossh</span><br><span class="line">$ systemctl enable autossh</span><br></pre></td></tr></table></figure><ol start="3"><li>如果你无法通过 22 端口连接到 Serveo，官方还预留了 443 端口给你使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 443 -R 80:localhost:8080 serveo.net</span><br></pre></td></tr></table></figure><ol start="4"><li>使用自定义的域名 / 子域名</li></ol><p>默认情况下，我们都是使用的 <code>Serveo</code> 生成的二级域名进行连接的。如果你想使用自己的域名也是可以的，方法非常简单。只需要在你的域名所在 DNS 中添加一条 A 记录和一条 TXT 记录就可实现。</p><p>4.1 添加一条 A 记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A | serveo | 159.89.214.31</span><br></pre></td></tr></table></figure><p>4.2 添加一条 TXT 记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TXT | serveo | authkeyfp&#x3D;SHA256:pmc7ZRv7ymCmghUwHoJWEm5ToSTd33ryeDeps5RnfRY</span><br></pre></td></tr></table></figure><blockquote><p><code>authkeyfp</code> 后面跟的那一串字符是 <code>RSA</code> 密钥指纹，你可以使用 <code>ssh-keygen -l</code> 命令进行查看。</p></blockquote><p>DNS 解析记录增加好后，你就可以使用自定义域名进行连接了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -R serveo.ywzm.org:80:localhost:3000 serveo.net</span><br></pre></td></tr></table></figure><p>至此，<code>Serveo</code> 的基本用法就介绍完了。如果你对它有更多的兴趣，欢迎去官网进行探索。</p><h2 id="参考文档">参考文档</h2><ol><li><p>https:/www.google.com</p></li><li><p><a href="https://www.moerats.com/archives/990/" target="_blank" rel="noopener">https://www.moerats.com/archives/990/</a></p></li><li><p><a href="https://blog.rxliuli.com/p/5ad7fa84/" target="_blank" rel="noopener">https://blog.rxliuli.com/p/5ad7fa84/</a></p></li><li><p><a href="https://www.jianshu.com/p/d0b3991a9ce1" target="_blank" rel="noopener">https://www.jianshu.com/p/d0b3991a9ce1</a></p></li><li><p><a href="https://blog.csdn.net/kongxx/article/details/86178364" target="_blank" rel="noopener">https://blog.csdn.net/kongxx/article/details/86178364</a></p></li><li><p><a href="https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-autossh/" target="_blank" rel="noopener">https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-autossh/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Serveo&quot;&gt;什么是 Serveo&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Serveo&lt;/code&gt; 是一个免费的内网穿透服务，&lt;code&gt;Serveo&lt;/code&gt; 可以将本地计算机暴露在互联网上，官方声称其为 &lt;code&gt;Ngrok&lt;/code&gt; 的绝佳替代品。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Serveo&lt;/code&gt; 其最大优点是使用现有的 &lt;code&gt;SSH&lt;/code&gt; 客户端，无需安装任何客户端软件，即可完成端口转发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/serveo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Serveo&lt;/code&gt; 工作原理很简单：当用户通过 &lt;code&gt;SSH&lt;/code&gt; 连接到 &lt;code&gt;Serveo&lt;/code&gt; 时会与该网站建立一个远程代理，&lt;code&gt;Serveo&lt;/code&gt; 随后会生成一个 公共 &lt;code&gt;URL&lt;/code&gt;，任何人都可以通过这个 &lt;code&gt;URL&lt;/code&gt; 访问你的本地计算机。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址: &lt;a href=&quot;https://serveo.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://serveo.net&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="内网穿透" scheme="https://www.hi-linux.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>25 个 Linux 下的炫酷又强大的命令行神器，你用过其中哪几个呢？</title>
    <link href="https://www.hi-linux.com/posts/28627.html"/>
    <id>https://www.hi-linux.com/posts/28627.html</id>
    <published>2020-05-15T01:00:00.000Z</published>
    <updated>2020-05-15T08:15:43.267Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，我们在 Linux 下大多数时候是使用命令行来处理任务的。这样不但操作起来效率比较高，而且界面也比较炫酷。下面，我们就给大家推荐一些不但炫酷又好用的 Linux 命令行神器。</p><h2 id="1-exa">1. exa</h2><p><img src="https://www.hi-linux.com/img/linux/exa.png" alt=""></p><p>exa 是一个用来替代 ls 的工具， exa 相比于 ls 增加了很多新的特性，比如：支持不同文件类型可以用不同颜色来展示、exa 比 ls 速度更快一些等。</p><blockquote><p>项目地址：<a href="https://github.com/ogham/exa" target="_blank" rel="noopener">https://github.com/ogham/exa</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247488536&amp;idx=1&amp;sn=05896e203e9c78740243ab552f59f535&amp;chksm=eac53531ddb2bc27629978c121bfa53f9d3c540dce134d8267259fa7c96e19e1ab07448b4e50&amp;token=1606750990&amp;lang=zh_CN#rd" target="_blank" rel="noopener">推荐一个比 ls 命令速度快 100 倍的文件目录浏览神器</a>」 一文。</p><h2 id="2-fd">2. FD</h2><p><img src="https://www.hi-linux.com/img/linux/fd.jpeg" alt=""></p><p>fd 是基于 Rust 开发的一个速度超快的命令行搜索工具，fd 旨在成为 Linux / Unix 下 find 命令的替代品。</p><p>fd 虽然不能提供现在 find 命令所有的强大功能，但它也提供了足够强大的功能来满足你日常需要。比如：简洁的语法、彩色的终端输出、超快的查询速度、智能大小写、支持正则表达式以及可并行执行命令等特性。</p><blockquote><p>项目地址：<a href="https://github.com/sharkdp/fd" target="_blank" rel="noopener">https://github.com/sharkdp/fd</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486196&amp;idx=1&amp;sn=6141148903295af608e64aecf192c33a&amp;chksm=eac52bddddb2a2cbe4c7a3252c933cb76835bb5bf94b4b3c592d28b7a3b24ce56ddc05641870&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">推荐一款比 Find 快 10 倍的搜索工具 FD</a>」 一文。</p><a id="more"></a><h2 id="3-ripgrep">3. RipGrep</h2><p><img src="https://www.hi-linux.com/img/linux/rg.jpeg" alt=""></p><p>Ripgrep 是命令行下一个基于行的命令行搜索工具，比 ag、grep、ack 速度更快。RipGrep 使用 Rust 开发，可以在多平台下运行，支持 Mac、Linux 和 Windows 等平台。</p><blockquote><p>项目地址：<a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">https://github.com/BurntSushi/ripgrep</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486258&amp;idx=1&amp;sn=8ff0fafd8ae2b261bd17985d3079acd6&amp;chksm=eac52a1bddb2a30d88dc449cdcf84d66801a84e85454d0335843f6e44cec9ec14398b818b6de&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">推荐一款命令行下最快的文本搜索神器 RipGrep</a>」 一文。</p><h2 id="4-tig">4. Tig</h2><p><img src="https://darrenburns.net/tig-cb475140e22bbb7f227d7e03f9050556.gif" alt=""></p><p>Tig 是一款命令行下 Git 的可视化工具，可以很方便地在命令行下以交互的方式完成 Git 的各种操作。</p><blockquote><p>项目地址：<a href="https://github.com/jonas/tig" target="_blank" rel="noopener">https://github.com/jonas/tig</a></p></blockquote><h2 id="5-fzf">5. FZF</h2><p><img src="https://raw.githubusercontent.com/junegunn/i/master/fzf-preview.png" alt=""></p><p>FZF 是使用 GO 语言开发的一款命令行下支持模糊搜索的交互式工具。FZF 可以用来查找任何列表内容，包括文件、Git 分支、进程等。所有的命令行工具都可以生成列表后再通过管道将结果输入到 FZF 上进行模糊搜索。FZF 还可以结合其它工具(比如：rg、bat 和 Fasd )来完成更多的工作。</p><blockquote><p>项目地址：<a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">https://github.com/junegunn/fzf</a></p></blockquote><h2 id="6-fpp">6. FPP</h2><p><img src="https://darrenburns.net/fpp-217fdcd6bcffaa605df85f31e8d84d79.gif" alt=""></p><p>FPP (Facebook Path Picker ) 是由 Fackbook 开源一款终端多文件路径选择工具，它可以用于完善优化终端中的操作, 比如：Git、Grep 等的输出结果。</p><blockquote><p>项目地址：<a href="https://github.com/facebook/PathPicker" target="_blank" rel="noopener">https://github.com/facebook/PathPicker</a></p></blockquote><h2 id="7-bat">7. BAT</h2><p><img src="https://www.hi-linux.com/img/linux/bat.jpeg" alt=""></p><p>BAT 是命令行下一款用来显示文件内容的工具，bat 命令功能跟常用命令 cat 类似。只是 bat 功能上更加强大一些，bat 在 cat 命令的基础上加入了行号显示、代码高亮和 Git 集成。</p><blockquote><p>项目地址： <a href="https://github.com/sharkdp/bat" target="_blank" rel="noopener">https://github.com/sharkdp/bat</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247485893&amp;idx=1&amp;sn=c6ff22b7f4afa84446e595bb5b14e7a0&amp;chksm=eac528ecddb2a1fa36861c98d10889d374bf9c1dbdb57c27914a96656a6d6556ae5ff0acffd4&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">推荐一款命令行下支持语法高亮和Git集成的文件查看工具 bat</a>」 一文。</p><h2 id="8-mycli">8. MyCli</h2><p><img src="https://www.hi-linux.com/img/linux/mycli.gif" alt=""></p><p>MyCli 是一个 MySQL 的命令行客户端，可以实现自动补全和语法高亮。MyCli 也可用于 MariaDB 和Percona。</p><blockquote><p>项目地址：<a href="http://mycli.net/" target="_blank" rel="noopener">http://mycli.net/</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483873&amp;idx=1&amp;sn=3e1e178510a33239cf4551f6377b8faf&amp;chksm=eac520c8ddb2a9de407d309303d9d7a5a51336efc8390d4e02f07b7791a96f159e53d3a65c0e&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL的增强型语法高亮终端-MyCli</a>」 一文。</p><h2 id="9-htop">9. HTop</h2><p><img src="https://hisham.hm/htop/htop_graph.gif" alt=""></p><p>HTop 称之为 Top 的增强版，是一个相对于 Top 命令提供更美观、更方便的进程监控工具。</p><blockquote><p>项目地址: <a href="https://hisham.hm/htop/" target="_blank" rel="noopener">https://hisham.hm/htop/</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247484585&amp;idx=1&amp;sn=6f49154c7f53025a616953803d5cd403&amp;chksm=eac52580ddb2ac96d2446a3cfe3d121720e9e103224b85bb377cf277f7714e4d324d1dc2281e&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">一款比 top 强悍好用的进程管理监控工具</a>」 一文。</p><h2 id="10-glances">10. Glances</h2><p><img src="https://raw.githubusercontent.com/nicolargo/glances/develop/docs/_static/glances-summary.png" alt=""></p><p>Glances 是一个用于监控系统的跨平台、基于文本模式的命令行工具。它是用 Python 编写的，使用 psutil 库从系统获取信息。你可以用它来监控 CPU、平均负载、内存、网络接口、磁盘 I/O，文件系统空间利用率、挂载的设备、所有活动进程以及消耗资源最多的进程。信息比 htop 更加丰富，除了命令行，Glances 还提供页面服务，可以让你从页面上随时查看某服务器的状态。</p><blockquote><p>项目地址: <a href="https://github.com/nicolargo/glances" target="_blank" rel="noopener">https://github.com/nicolargo/glances</a></p></blockquote><h2 id="11-lrzsz">11. lrzsz</h2><p>lrzsz 软件包是一个支持 Zmodem 协议的工具包。 其中包含的 rz、sz 命令是通过 ZModem 协议在远程服务器和终端机器间上传下载文件的利器。</p><p>lrzsz 支持交互式文件传输，在多重跳板机下传输文件非常好用，不用一级一级传输。</p><blockquote><p>项目地址: <a href="https://www.ohse.de/uwe/software/lrzsz.html" target="_blank" rel="noopener">https://www.ohse.de/uwe/software/lrzsz.html</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247485436&amp;idx=1&amp;sn=871a661688d6a2894f7d200709bf54bf&amp;chksm=eac526d5ddb2afc3e465faba25294e7361746d3ff821aa9c6df78f66ca6d202fc4b0312c1072&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">在 iTerm2 中使用 Zmodem 实现快速传输文件</a>」 一文。</p><h2 id="12-ncdu">12. Ncdu</h2><p><img src="https://dev.yorhel.nl/img/ncduinfo-2.png" alt=""></p><p>Ncdu (NCurses Disk Usage) 是一个基于 Ncurses 库的 du 命令的界面。它通过大家熟知的 du 命令，为用户提供一个快速且容易被使用的界面。它可以显示磁盘使用的百分比，且允许你使用 ncurses 库的方式在目录之间导航。</p><blockquote><p>项目地址: <a href="https://dev.yorhel.nl/ncdu" target="_blank" rel="noopener">https://dev.yorhel.nl/ncdu</a></p></blockquote><h2 id="13-tmux">13. Tmux</h2><p><img src="http://dotshare.it/public/images/uploads/29.png" alt=""></p><p>Tmux 是一个优秀的终端复用工具，功能类似 GNU Screen，但使用 BSD 许可发布。用户可以通过 Tmux 在一个终端内管理多个分离的会话、窗口及面板，对于同时使用多个命令行，或多个任务时非常方便。</p><blockquote><p>项目地址: <a href="https://github.com/tmux/tmux" target="_blank" rel="noopener">https://github.com/tmux/tmux</a></p></blockquote><h2 id="14-multitail">14. MultiTail</h2><p><img src="https://www.debuntu.org/wp-content/uploads/2013/04/multitail-splitoutput.png" alt=""></p><p>MultiTail 是一个开源的 Ncurses 实用程序，可用于在单个窗口或单个 Shell 中将多个日志文件同时显示到标准输出。</p><blockquote><p>项目地址: <a href="https://www.vanheusden.com/multitail" target="_blank" rel="noopener">https://www.vanheusden.com/multitail</a></p></blockquote><h2 id="15-shellcheck">15. ShellCheck</h2><p><img src="https://github.com/koalaman/shellcheck/raw/master/doc/terminal.png" alt=""></p><p>ShellCheck 是一款实用的 Shell 脚本静态检查工具，可以帮助你提前发现并修复语法错误以及不规范的写法。</p><blockquote><p>项目地址：<a href="https://github.com/koalaman/shellcheck" target="_blank" rel="noopener">https://github.com/koalaman/shellcheck</a></p></blockquote><h2 id="16-explainshell">16. Explainshell</h2><p><img src="https://darrenburns.net/static/explain_shell-0edc1706c18af98816645e6b2db89607-c83f1.png" alt=""></p><p>Explainshell 是一个帮助你解释命令行的网站，它会分析命令的帮助文档，然后根据你想查询的命令参数来抽取对应的解释，然后简洁易懂地显示出来。</p><blockquote><p>项目地址: <a href="https://github.com/idank/explainshell" target="_blank" rel="noopener">https://github.com/idank/explainshell</a></p></blockquote><h2 id="17-asciinema">17. Asciinema</h2><p><img src="https://www.hi-linux.com/img/linux/asciinema.jpeg" alt=""></p><p>Asciinema 是一个终端下非常棒的录屏和回放软件。Asciinema 对终端输入输出进行捕捉，然后以文本的形式来记录和回放。</p><p>基于 Asciinema 用文本来记录的特性，使其拥有了非常炫酷的特性。你可以在播放过程中随时暂停，然后对播放器中的文本进行复制或者其它操作。</p><blockquote><p>项目地址：<a href="https://github.com/asciinema/asciinema" target="_blank" rel="noopener">https://github.com/asciinema/asciinema</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486341&amp;idx=1&amp;sn=7996231ebcec64780b28ea90adfdc024&amp;chksm=eac52aacddb2a3ba63dd50bc9e40f6f0e292a1622353a04fd5a86d9f191bb96b1bcb8f174c1b&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">手把手教你使用终端录屏神器 Asciinema</a>」 一文。</p><h2 id="18-svg-term">18. Svg-term</h2><p><img src="https://i.gyazo.com/thumb/1000/fc8e8d6942c4b4792e05ce2c25a0ac10-png.png" alt=""></p><p>一个可以根据 Asciinema 录制文件生成 SVG 动画的小工具。</p><blockquote><p>项目地址： <a href="https://github.com/marionebl/svg-term-cli" target="_blank" rel="noopener">https://github.com/marionebl/svg-term-cli</a></p></blockquote><p>来看一个实例：将通过 Asciinema 在终端录制的视频转换为 SVG 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 安装 svg-term </span><br><span class="line">$ npm install -g svg-term-cli</span><br><span class="line"></span><br><span class="line"># 直接转换发布在 Asciinema 网站上的视频，需要先确认视频所在链接中的录制 ID，例如: https:&#x2F;&#x2F;asciinema.org&#x2F;a&#x2F;219486 的 ID 就是 219486</span><br><span class="line">$ svg-term --cast&#x3D;219486 --out ~&#x2F;home&#x2F;mike&#x2F;out.svg --padding 18 --height 8 --width 80</span><br><span class="line"></span><br><span class="line"># 如果你不想把录制文件上传到 Asciinema 网站上，你也可以直接使用 svg-term 转换本地录制文件</span><br><span class="line"></span><br><span class="line">$ asciinema rec cast.json</span><br><span class="line">$ cat cast.json | svg-term-cli</span><br></pre></td></tr></table></figure><h2 id="19-wrk">19. Wrk</h2><p><img src="https://pbs.twimg.com/media/DrPwgeOUwAAeqrR.jpg" alt=""></p><p>Wrk 是轻量级的 HTTP 性能测试工具。相比于 Apache ab 功能更强大，支持 HTTP 1.1，而且可以用 Lua 写脚本支持更复杂的测试场景。</p><blockquote><p>项目地址：<a href="https://github.com/wg/wrk" target="_blank" rel="noopener">https://github.com/wg/wrk</a></p></blockquote><h2 id="20-httpie">20. HTTPie</h2><p><img src="https://www.hi-linux.com/img/linux/httpie.jpeg" alt=""></p><p>HTTPie (读aych-tee-tee-pie) 是一款开源的命令行 HTTP 工具。HTTPie 采用 Python 开发，底层用到了 Requests 和 Pygments 库。</p><p>HTTPie 设计用来增强 wget 和 curl 的可用性。它的主要目标是使通过命令行与网络服务器进行交互的过程变得尽可能的人性化。其提供了一个简单的 HTTP 环境来让我们通过简单而自然的语法发送任意 HTTP 请求，并显示彩色输出。HTTPie 可用于测试，调试和与 HTTP 服务器进行普通的交互。</p><blockquote><p>项目地址: <a href="http://httpie.org/" target="_blank" rel="noopener">http://httpie.org/</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483830&amp;idx=1&amp;sn=dec71acedef41690ba000b05ab2da039&amp;chksm=eac5209fddb2a9896d7d665bcdf3a0476a2bdf1c3d1e0ed3e5ba8bb9c964b480eb9cc6aba3de&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">如何用 HTTPie 更高效的调试接口</a>」 一文。</p><h2 id="21-http-prompt">21. HTTP Prompt</h2><p><img src="https://www.hi-linux.com/img/linux/http-prompt.gif" alt=""></p><p>HTTP Prompt 是一个交互式的命令行 HTTP 客户端，支持自动完成、语法高亮，基于 HTTPie 和 prompt_toolkit 构建。HTTP Prompt 相对于其它命令行的 HTTP 客户端 (如：HTTPie、Curl 等)使用上更加直观方便。</p><blockquote><p>项目地址: <a href="https://github.com/eliangcs/http-prompt" target="_blank" rel="noopener">https://github.com/eliangcs/http-prompt</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483962&amp;idx=1&amp;sn=45e50270c32fde2d06ce59e274d31cc5&amp;chksm=eac52313ddb2aa0571a01088983bb061be36cf0a35bf235d32637ddc3490968890ae36f7f230&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Linux 命令行下交互式 HTTP 客户端–HTTP Prompt</a>」 一文。</p><h2 id="22-tldr">22. TLDR</h2><p><img src="https://tldr.sh/assets/img/screenshot.png" alt=""></p><p>TLDR 全称Too long, Don’t read，翻译成中文就是太长不读。它可以帮助你快速查看命令行工具的使用实例。简而言之，就是 Man 页面的精简版本。</p><blockquote><p>项目地址: <a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">https://github.com/tldr-pages/tldr</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483858&amp;idx=1&amp;sn=960f18327f4936bcf1e8f5d12eff8721&amp;chksm=eac520fbddb2a9edab7bc68ac91106ced74391886a631dd632c2ef9d0c90a1a736887117e2ce&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Linux命令行学习神器tldr</a>」 一文。</p><h2 id="23-ranger">23. Ranger</h2><p><img src="https://raw.githubusercontent.com/ranger/ranger-assets/master/screenshots/screenshot.png" alt=""></p><p>Ranger 是一个命令行下的文件管理器。Ranger 使用 Python 编写，默认为使用 Vim 风格的按键绑定。</p><blockquote><p>项目地址: <a href="https://github.com/ranger/ranger" target="_blank" rel="noopener">https://github.com/ranger/ranger</a></p></blockquote><h2 id="24-axel">24. Axel</h2><p><img src="https://i.loli.net/2019/08/30/I3m5peN7hMlvHJn.jpg" alt=""></p><p>Axel 是 Linux 下一个不错的高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。非常适合网速不给力时多线程下载，以提高下载速度。</p><blockquote><p>项目地址: <a href="https://github.com/axel-download-accelerator/axel" target="_blank" rel="noopener">https://github.com/axel-download-accelerator/axel</a></p></blockquote><h2 id="25-cloc">25. Cloc</h2><p><img src="https://www.hi-linux.com/img/linux/cloc.png" alt=""></p><p>Cloc 是一款使用 Perl 语言开发的开源代码统计工具，支持多平台使用、多语言识别，能够计算指定目标文件或文件夹中的文件数(files)、空白行数(blank)、注释行数(comment)和代码行数(code)。</p><blockquote><p>项目地址: <a href="http://cloc.sourceforge.net/" target="_blank" rel="noopener">http://cloc.sourceforge.net/</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483854&amp;idx=1&amp;sn=0c8a52b8504264b2e9bbe2699574c69a&amp;chksm=eac520e7ddb2a9f126be81ad83ff3221aa350d91b50a584f8d1a98942d019735143970099f59&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">代码统计利器 CLOC</a>」 一文。</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a></p></li><li><p><a href="https://darrenburns.net/posts/tools/" target="_blank" rel="noopener">https://darrenburns.net/posts/tools/</a></p></li><li><p><a href="https://darrenburns.net/posts/more-tools" target="_blank" rel="noopener">https://darrenburns.net/posts/more-tools</a></p></li><li><p><a href="https://darrenburns.net/posts/even-more-tools" target="_blank" rel="noopener">https://darrenburns.net/posts/even-more-tools</a></p></li><li><p><a href="https://darrenburns.net/posts/command-line-tools-iv" target="_blank" rel="noopener">https://darrenburns.net/posts/command-line-tools-iv</a></p></li><li><p><a href="https://juejin.im/post/5afabcb1f265da0b886d92b6" target="_blank" rel="noopener">https://juejin.im/post/5afabcb1f265da0b886d92b6</a></p></li><li><p><a href="https://www.cnblogs.com/zqb-all/p/10054594.html" target="_blank" rel="noopener">https://www.cnblogs.com/zqb-all/p/10054594.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，我们在 Linux 下大多数时候是使用命令行来处理任务的。这样不但操作起来效率比较高，而且界面也比较炫酷。下面，我们就给大家推荐一些不但炫酷又好用的 Linux 命令行神器。&lt;/p&gt;
&lt;h2 id=&quot;1-exa&quot;&gt;1. exa&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/exa.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;exa 是一个用来替代 ls 的工具， exa 相比于 ls 增加了很多新的特性，比如：支持不同文件类型可以用不同颜色来展示、exa 比 ls 速度更快一些等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/ogham/exa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ogham/exa&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多详细介绍可参考：「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247488536&amp;amp;idx=1&amp;amp;sn=05896e203e9c78740243ab552f59f535&amp;amp;chksm=eac53531ddb2bc27629978c121bfa53f9d3c540dce134d8267259fa7c96e19e1ab07448b4e50&amp;amp;token=1606750990&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;推荐一个比 ls 命令速度快 100 倍的文件目录浏览神器&lt;/a&gt;」 一文。&lt;/p&gt;
&lt;h2 id=&quot;2-FD&quot;&gt;2. FD&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/fd.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;fd 是基于 Rust 开发的一个速度超快的命令行搜索工具，fd 旨在成为 Linux / Unix 下 find 命令的替代品。&lt;/p&gt;
&lt;p&gt;fd 虽然不能提供现在 find 命令所有的强大功能，但它也提供了足够强大的功能来满足你日常需要。比如：简洁的语法、彩色的终端输出、超快的查询速度、智能大小写、支持正则表达式以及可并行执行命令等特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/sharkdp/fd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sharkdp/fd&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多详细介绍可参考：「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247486196&amp;amp;idx=1&amp;amp;sn=6141148903295af608e64aecf192c33a&amp;amp;chksm=eac52bddddb2a2cbe4c7a3252c933cb76835bb5bf94b4b3c592d28b7a3b24ce56ddc05641870&amp;amp;token=98555220&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;推荐一款比 Find 快 10 倍的搜索工具 FD&lt;/a&gt;」 一文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用 Kind 在 5 分钟内快速部署一个 Kubernetes 高可用集群</title>
    <link href="https://www.hi-linux.com/posts/42332.html"/>
    <id>https://www.hi-linux.com/posts/42332.html</id>
    <published>2020-05-14T01:00:00.000Z</published>
    <updated>2020-05-14T05:17:15.652Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-kind">什么是 Kind</h2><p><code>Kind</code>（Kubernetes in Docker） 是一个 <code>Kubernetes</code> 孵化项目，<code>Kind</code> 是一套开箱即用的 <code>Kubernetes</code> 环境搭建方案。顾名思义，就是将 <code>Kubernetes</code> 所需要的所有组件，全部部署在一个 <code>Docker</code> 容器中，可以很方便的搭建 <code>Kubernetes</code> 集群。</p><p><code>Kind</code> 已经广泛的应用于 <code>Kubernetes</code> 上游及相关项目的 <code>CI</code> 环境中，官方文档中也把 <code>Kind</code> 作为一种本地集群搭建的工具推荐给大家。</p><blockquote><p>项目地址：<a href="https://github.com/kubernetes-sigs/kind" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kind</a></p></blockquote><p><strong>Kind 可以做什么？</strong></p><ol><li><p>快速创建一个或多个 <code>Kubernetes</code> 集群</p></li><li><p>支持部署高可用的 <code>Kubernetes</code> 集群</p></li><li><p>支持从源码构建并部署一个 <code>Kubernetes</code> 集群</p></li><li><p>可以快速低成本体验一个最新的 <code>Kubernetes</code> 集群，并支持 <code>Kubernetes</code> 的绝大部分功能</p></li><li><p>支持本地离线运行一个多节点集群</p></li></ol><p><strong>Kind 有哪些优势？</strong></p><ol><li><p>最小的安装依赖，仅需要安装 <code>Docker</code> 即可</p></li><li><p>使用方法简单，只需 <code>Kind Cli</code> 工具即可快速创建集群</p></li><li><p>使用容器来模似 <code>Kubernetes</code> 节点</p></li><li><p>内部使用 <code>Kubeadm</code> 的官方主流部署工具</p></li><li><p>通过了 <code>CNCF</code> 官方的 <code>K8S Conformance</code> 测试</p></li></ol><a id="more"></a><p><strong>Kind 是如何工作的？</strong></p><p><img src="https://www.hi-linux.com/img/linux/kind-demo.gif" alt=""></p><p><code>Kind</code> 使用容器来模拟每一个 <code>Kubernetes</code> 节点，并在容器里面运行 <code>Systemd</code>。 容器里的 <code>Systemd</code> 托管了 <code>Kubelet</code> 和 <code>Containerd</code>，然后容器内部的 <code>Kubelet</code> 把其它 <code>Kubernetes</code> 组件：<code>Kube-Apiserver</code>、<code>Etcd</code>、<code>CNI</code> 等等组件运行起来。</p><p><code>Kind</code> 内部使用了 <code>Kubeadm</code> 这个工具来做集群的部署，包括高可用集群也是借助 <code>Kubeadm</code> 提供的特性来完成的。在高用集群下还会额外部署了一个 <code>Nginx</code> 来提供负载均衡 <code>VIP</code>。</p><h2 id="安装-kind">安装 Kind</h2><h3 id="安装-kind-依赖组件">安装 Kind 依赖组件</h3><p><code>Kind</code> 把部署 <code>Kubernetes</code> 环境的依赖降低到了最小，仅需要机器安装 <code>Docker</code> 即可。</p><ol><li>安装 Docker</li></ol><p>这里以 <code>Linux</code> 系统为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh</span><br></pre></td></tr></table></figure><p>更多平台的安装方法可参考官方文档：<a href="https://docs.docker.com/install/" target="_blank" rel="noopener">https://docs.docker.com/install/</a></p><ol start="2"><li>安装 Kubectl</li></ol><p>如果你需要通过命令行管理集群，则需要安装 <code>Kubectl</code>。</p><p>这里以 <code>Linux</code> 系统为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -LO https:&#x2F;&#x2F;storage.googleapis.com&#x2F;kubernetes-release&#x2F;release&#x2F;v1.15.0&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl</span><br><span class="line">$ chmod +x .&#x2F;kubectl</span><br><span class="line">$ sudo mv .&#x2F;kubectl &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kubectl</span><br></pre></td></tr></table></figure><p>更多平台的安装方法可参考官方文档：<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl</a></p><h3 id="安装-kind">安装 Kind</h3><p><code>Kind</code> 使用 <code>Golang</code> 进行开发，原生支持良好的跨平台特性，通常只需要直接下载构建好的二进制文件就可使用。</p><ol><li>通过二进制安装</li></ol><ul><li>Linux</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -Lo .&#x2F;kind https:&#x2F;&#x2F;github.com&#x2F;kubernetes-sigs&#x2F;kind&#x2F;releases&#x2F;download&#x2F;v0.5.1&#x2F;kind-linux-amd64</span><br><span class="line">$ chmod +x .&#x2F;kind</span><br><span class="line">$ mv .&#x2F;kind &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kind</span><br></pre></td></tr></table></figure><ul><li>Windows</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl.exe -Lo kind-windows-amd64.exe https:&#x2F;&#x2F;github.com&#x2F;kubernetes-sigs&#x2F;kind&#x2F;releases&#x2F;download&#x2F;v0.5.1&#x2F;kind-windows-amd64</span><br><span class="line">$ mv .\kind-windows-amd64.exe c:\kind.exe</span><br></pre></td></tr></table></figure><p>更多平台的安装方法可参考官方文档：<a href="https://kind.sigs.k8s.io/docs/user/quick-start/" target="_blank" rel="noopener">https://kind.sigs.k8s.io/docs/user/quick-start/</a></p><ol start="2"><li>通过源码安装</li></ol><p>如果本地环境已经配置好 Golang (1.11+)  的开发环境，你也可以直接通过源码进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get sigs.k8s.io&#x2F;kind@v0.5.1</span><br></pre></td></tr></table></figure><p>运行完上述命令后，会将 <code>Kind</code> 的可执行文件放到 <code>$GOPATH/bin</code> 目录内。为了方便使用，你需要将此目录加入到 <code>$PATH</code> 中。</p><h2 id="使用-kind">使用 Kind</h2><p>安装完成之后，我们可以来看看 <code>Kind</code> 支持哪些命令行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ kind</span><br><span class="line">kind creates and manages local Kubernetes clusters using Docker container &#39;nodes&#39;</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  kind [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  build       Build one of [base-image, node-image]</span><br><span class="line">  create      Creates one of [cluster]</span><br><span class="line">  delete      Deletes one of [cluster]</span><br><span class="line">  export      exports one of [logs]</span><br><span class="line">  get         Gets one of [clusters, nodes, kubeconfig-path]</span><br><span class="line">  help        Help about any command</span><br><span class="line">  load        Loads images into nodes</span><br><span class="line">  version     prints the kind CLI version</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help              help for kind</span><br><span class="line">      --loglevel string   logrus log level [panic, fatal, error, warning, info, debug] (default &quot;warning&quot;)</span><br><span class="line">      --version           version for kind</span><br><span class="line"></span><br><span class="line">Use &quot;kind [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><p>简单说下几个比较常用选项的含义：</p><ul><li><p><code>build</code>：用来从 <code>Kubernetes</code> 源代码构建一个新的镜像。</p></li><li><p><code>create</code>：创建一个 <code>Kubernetes</code> 集群。</p></li><li><p><code>delete</code>：删除一个 <code>Kubernetes</code> 集群。</p></li><li><p><code>get</code>： 可用来查看当前集群、节点信息以及 <code>Kubectl</code> 配置文件的地址。</p></li><li><p><code>load</code>：从宿主机向 <code>Kubernetes</code> 节点内导入镜像。</p></li></ul><h2 id="使用-kind-创建-kubernetes-集群">使用 Kind 创建 Kubernetes 集群</h2><h3 id="搭建一个单节点集群">搭建一个单节点集群</h3><p>搭建单节点集群是 <code>Kind</code> 最基础的功能，当然使用起来也很简单，仅需一条指令即可完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kind create cluster --name my-cluster</span><br><span class="line">Creating cluster &quot;my-cluster&quot; ...</span><br><span class="line"> ✓ Ensuring node image (kindest&#x2F;node:v1.15.3) 🖼</span><br><span class="line"> ✓ Preparing nodes 📦</span><br><span class="line"> ✓ Creating kubeadm config 📜</span><br><span class="line"> ✓ Starting control-plane 🕹️</span><br><span class="line">Cluster creation complete. You can now use the cluster with:</span><br><span class="line"></span><br><span class="line">export KUBECONFIG&#x3D;&quot;$(kind get kubeconfig-path --name&#x3D;&quot;my-cluster&quot;)&quot;</span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><blockquote><p>以上命令中 <code>--name</code> 是可选参数。如果不指定，默认创建出来的集群名字为 <code>kind</code>。</p></blockquote><p>使用默认安装的方式时，我们没有指定任何配置文件。从安装过程的输出来看，一共分为 4 步：</p><ul><li><p>检查本地环境是否存在一个基础的安装镜像，默认是 <code>kindest/node:v1.15.3</code>，该镜像里面包含了所有需要安装的东西，包括：<code>kubectl</code>、<code>kubeadm</code>、<code>kubelet</code> 的二进制文件，以及安装对应版本 <code>Kubernetes</code> 所需要的镜像。</p></li><li><p>准备 <code>Kubernetes</code> 节点，主要就是启动容器、解压镜像这类的操作。</p></li><li><p>建立对应的 <code>kubeadm</code> 的配置，完成之后就通过 <code>kubeadm</code> 进行安装。安装完成后还会做一些清理操作，比如：删掉主节点上的污点，否则对于没有容忍的 <code>Pod</code> 无法完成部署。</p></li><li><p>上面所有操作都完成后，就成功启动了一个 <code>Kubernetes</code> 集群并输出一些操作集群的提示信息。</p></li></ul><blockquote><ol><li><p>默认情况下，<code>Kind</code> 会先下载 <code>kindest/node:v1.15.3</code> 镜像。如果你想指定不同版本，可以使用 <code>--image</code> 参数，类似这样：<code>kind create cluster --image kindest/node:v1.15.3</code></p></li><li><p><code>kindest/node</code> 这个镜像目前托管于 Docker Hub 上，下载时可能会较慢。同样的问题 <code>Kind</code> 进行集群的创建也是存在的，<code>Kind</code> 实际使用 <code>Kubeadm</code> 进行集群的创建。对 <code>Kubeadm</code> 有所了解的同学都知道它默认使用的镜像在国内是不能访问的，所以一样需要自行解决网络问题。</p></li><li><p>如果你存在上面说的网络问题，最好配置一个国内的加速器或者镜像源。如果你还不知道如何配置加速器和镜像源可以参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247488553&amp;idx=1&amp;sn=14cbe47bc50df50f536345efb4d10b5e&amp;chksm=eac53500ddb2bc16be6bbfe69917895d0feed7c4e85d40450a5adb931ff01257d9f546c58538&amp;token=687022088&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Docker / Kubernetes 镜像源不可用，教你几招搞定它！</a>」和 「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483698&amp;idx=1&amp;sn=dfb6edca74539a9a4d8228495d1c17a0&amp;chksm=eac5201bddb2a90d5f8e6d4733ed2d0ff9466474471933e4ea5d5fc1ef6be15b86470f50eccb&amp;token=21948731&amp;lang=zh_CN#rd" target="_blank" rel="noopener"> Docker 下使用 DaoCloud / 阿里云镜像加速</a>」两篇文章。</p></li></ol></blockquote><p>接下来，我们根据上面命令执行完后，输出的提示信息进行操作来验证一下集群是否部署成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 获取指定集群的配置文件所在的路径</span><br><span class="line">$ export KUBECONFIG&#x3D;&quot;$(kind get kubeconfig-path --name&#x3D;&quot;my-cluster&quot;)&quot;</span><br><span class="line">$ kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https:&#x2F;&#x2F;localhost:34458</span><br><span class="line">KubeDNS is running at https:&#x2F;&#x2F;localhost:34458&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;services&#x2F;kube-dns:dns&#x2F;proxy</span><br><span class="line">To further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.</span><br><span class="line"></span><br><span class="line">$ kubectl get nodes</span><br><span class="line">NAME                       STATUS    ROLES     AGE       VERSION</span><br><span class="line">my-cluster-control-plane   Ready     master    2m        v1.15.3</span><br><span class="line"></span><br><span class="line">$ kubectl get po -n kube-system</span><br><span class="line">NAME                                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-86c58d9df4-6g66f                              1&#x2F;1     Running   0          21m</span><br><span class="line">coredns-86c58d9df4-pqcc4                              1&#x2F;1     Running   0          21m</span><br><span class="line">etcd-my-cluster-control-plane                         1&#x2F;1     Running   0          20m</span><br><span class="line">kube-apiserver-my-cluster-control-plane               1&#x2F;1     Running   0          20m</span><br><span class="line">kube-controller-manager-my-cluster-control-plane      1&#x2F;1     Running   0          20m</span><br><span class="line">kube-proxy-cjgnt                                      1&#x2F;1     Running   0          21m</span><br><span class="line">kube-scheduler-my-cluster-control-plane               1&#x2F;1     Running   0          21m</span><br><span class="line">weave-net-ls2v8                                       2&#x2F;2     Running   1          21m</span><br></pre></td></tr></table></figure><p>从上面的输出结果，可以看到单节点的 <code>Kubernetes</code> 已经搭建成功。单节点集群默认方式启动的节点类型是 <code>control-plane</code>，该节点包含了所有的组件。这些组件分别是：<code>2*Coredns</code>、<code>Etcd</code>、<code>Api-Server</code>、<code>Controller-Manager</code>、<code>Kube-Proxy</code>、<code>Sheduler</code> 和网络插件 <code>Weave</code>，目前默认使用的网络插件也是 <code>Weave</code>。</p><h3 id="创建多节点的集群">创建多节点的集群</h3><p>默认安装的集群只部署了一个控制节点，如果需要部署多节点集群，我们可以通过配置文件的方式来创建多个容器。这样就可以达到模拟多个节点目的，并以这些节点来构建一个多节点的 <code>Kubernetes</code> 集群。</p><ol><li>创建多节点 Kubernetes 集群配置文件</li></ol><p><code>Kind</code> 在创建集群的时候，支持通过 <code>--config</code> 参数传递配置文件给 <code>Kind</code>，配置文件可修改的内容主要有 role 和 节点使用的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vim my-cluster-multi-node.yaml</span><br><span class="line"># 一共两个节点，一个主节点，一个从节点。</span><br><span class="line">kind: Cluster</span><br><span class="line">apiVersion: kind.sigs.k8s.io&#x2F;v1alpha3</span><br><span class="line">nodes:</span><br><span class="line">- role: control-plane</span><br><span class="line">- role: worker</span><br></pre></td></tr></table></figure><ol start="2"><li>创建多节点 Kubernetes 集群</li></ol><p>配置文件创建完成后，就可以使用下面的命令来完成多节点 <code>Kubernetes</code> 集群搭建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kind create cluster --config my-cluster-multi-node.yaml --name my-cluster-multi-node</span><br><span class="line">Creating cluster &quot;my-cluster-multi-node&quot; ...</span><br><span class="line"> ✓ Ensuring node image (kindest&#x2F;node:v1.15.3) 🖼</span><br><span class="line"> ✓ Preparing nodes 📦📦 </span><br><span class="line"> ✓ Creating kubeadm config 📜 </span><br><span class="line"> ✓ Starting control-plane 🕹️ </span><br><span class="line"> ✓ Joining worker nodes 🚜 </span><br><span class="line">Cluster creation complete. You can now use the cluster with:</span><br><span class="line"></span><br><span class="line">export KUBECONFIG&#x3D;&quot;$(kind get kubeconfig-path --name&#x3D;&quot;my-cluster-multi-node&quot;)&quot;</span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><p>和上面创建的单节点集群一样，我们同样根据上面命令执行完后，输出的提示信息进行操作来验证一下集群是否部署成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME                                  STATUS   ROLES    AGE     VERSION</span><br><span class="line">my-cluster-multi-node-control-plane   Ready    master   3m20s   v1.15.3</span><br><span class="line">my-cluster-multi-node-worker          Ready    &lt;none&gt;   3m8s    v1.15.3</span><br><span class="line"></span><br><span class="line">$ kubectl get po -n kube-system</span><br><span class="line">NAME                                                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-86c58d9df4-cnqhc                                      1&#x2F;1     Running   0          5m29s</span><br><span class="line">coredns-86c58d9df4-hn9mv                                      1&#x2F;1     Running   0          5m29s</span><br><span class="line">etcd-my-cluster-multi-node-control-plane                      1&#x2F;1     Running   0          4m24s</span><br><span class="line">kube-apiserver-my-cluster-multi-node-control-plane            1&#x2F;1     Running   0          4m17s</span><br><span class="line">kube-controller-manager-my-cluster-multi-node-control-plane   1&#x2F;1     Running   0          4m21s</span><br><span class="line">kube-proxy-8t4xt                                              1&#x2F;1     Running   0          5m27s</span><br><span class="line">kube-proxy-skd5v                                              1&#x2F;1     Running   0          5m29s</span><br><span class="line">kube-scheduler-my-cluster-multi-node-control-plane            1&#x2F;1     Running   0          4m18s</span><br><span class="line">weave-net-nmfq2                                               2&#x2F;2     Running   1          5m27s</span><br><span class="line">weave-net-srdfw                                               2&#x2F;2     Running   0          5m29s</span><br></pre></td></tr></table></figure><h3 id="创建高可用-kubernetes-集群">创建高可用 Kubernetes 集群</h3><p><code>Kind</code> 也支持搭建高可用的 <code>Kubernetes</code> 集群，创建方式和多节点集群类似，也是通过配置文件来实现。</p><ol><li>创建高可用 Kubernetes 集群配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ vim my-cluster-ha.yaml</span><br><span class="line"></span><br><span class="line"># 一共六个节点，三个 control-plane 节点，三个 workers 节点</span><br><span class="line">kind: Cluster</span><br><span class="line">apiVersion: kind.sigs.k8s.io&#x2F;v1alpha3</span><br><span class="line">kubeadmConfigPatches:</span><br><span class="line">- |</span><br><span class="line">  apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">  kind: ClusterConfiguration</span><br><span class="line">  metadata:</span><br><span class="line">    name: config</span><br><span class="line">  networking:</span><br><span class="line">    serviceSubnet: 10.0.0.0&#x2F;16</span><br><span class="line">  imageRepository: registry.aliyuncs.com&#x2F;google_containers</span><br><span class="line">  nodeRegistration:</span><br><span class="line">    kubeletExtraArgs:</span><br><span class="line">      pod-infra-container-image: registry.aliyuncs.com&#x2F;google_containers&#x2F;pause:3.1</span><br><span class="line">- |</span><br><span class="line">  apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">  kind: InitConfiguration</span><br><span class="line">  metadata:</span><br><span class="line">    name: config</span><br><span class="line">  networking:</span><br><span class="line">    serviceSubnet: 10.0.0.0&#x2F;16</span><br><span class="line">  imageRepository: registry.aliyuncs.com&#x2F;google_containers</span><br><span class="line">nodes:</span><br><span class="line">- role: control-plane</span><br><span class="line">- role: control-plane</span><br><span class="line">- role: control-plane</span><br><span class="line">- role: worker</span><br><span class="line">- role: worker</span><br><span class="line">- role: worker</span><br></pre></td></tr></table></figure><blockquote><p>这里，我们通过直接在配置文件里使用国内容器镜像源的方式解决了官方容器镜像源不可用的问题，同时也达到了加速集群创建的目的。</p></blockquote><ol start="2"><li>创建高可用 Kubernetes 集群</li></ol><p>配置文件创建完成后，就可以使用下面的命令来完成高可用 <code>Kubernetes</code> 集群搭建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ kind create cluster --name my-cluster-ha --config my-cluster-ha.yaml</span><br><span class="line">Creating cluster &quot;my-cluster-ha&quot; ...</span><br><span class="line"> ✓ Ensuring node image (kindest&#x2F;node:v1.15.3) 🖼</span><br><span class="line"> ✓ Preparing nodes 📦📦📦📦📦📦📦</span><br><span class="line"> ✓ Starting the external load balancer ⚖️</span><br><span class="line"> ✓ Creating kubeadm config 📜</span><br><span class="line"> ✓ Starting control-plane 🕹️</span><br><span class="line"> ✓ Joining more control-plane nodes 🎮</span><br><span class="line"> ✓ Joining worker nodes 🚜</span><br><span class="line">Cluster creation complete. You can now use the cluster with:</span><br><span class="line"></span><br><span class="line">export KUBECONFIG&#x3D;&quot;$(kind get kubeconfig-path --name&#x3D;&quot;my-cluster-ha&quot;)&quot;</span><br><span class="line">kubectl cluster-info</span><br><span class="line">master $ export KUBECONFIG&#x3D;&quot;$(kind get kubeconfig-path --name&#x3D;&quot;my-cluster-ha&quot;)&quot;</span><br><span class="line">master $ kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https:&#x2F;&#x2F;localhost:44019</span><br><span class="line">KubeDNS is running at https:&#x2F;&#x2F;localhost:44019&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;services&#x2F;kube-dns:dns&#x2F;proxy</span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.</span><br></pre></td></tr></table></figure><p>同样，我们根据上面命令执行完后，输出的提示信息进行操作来验证一下集群是否部署成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME                           STATUS   ROLES    AGE     VERSION</span><br><span class="line">my-cluster-ha-control-plane    Ready    master   3m42s   v1.15.3</span><br><span class="line">my-cluster-ha-control-plane2   Ready    master   3m24s   v1.15.3</span><br><span class="line">my-cluster-ha-control-plane3   Ready    master   2m13s   v1.15.3</span><br><span class="line">my-cluster-ha-worker           Ready    &lt;none&gt;   96s     v1.15.3</span><br><span class="line">my-cluster-ha-worker2          Ready    &lt;none&gt;   98s     v1.15.3</span><br><span class="line">my-cluster-ha-worker3          Ready    &lt;none&gt;   95s     v1.15.3</span><br></pre></td></tr></table></figure><p>从上面的输出结果，可以看到包含了多个 master 节点，说明高可用的 <code>Kubernetes</code> 集群已经搭建成功。</p><h2 id="其它相关知识">其它相关知识</h2><h3 id="kind-的镜像里的秘密">Kind 的镜像里的秘密</h3><p><code>Kind</code> 镜像一共分为两类，一类是 <code>Base</code> 镜像，另一类是 <code>Node</code> 镜像。</p><ol><li>Base 镜像</li></ol><p>Base 镜像目前使用了 <code>ubuntu:19.04</code> 作为基础镜像，并做了下面的调整：</p><ul><li><p>安装 <code>Systemd</code> 相关的包，并调整一些配置以适应在容器内运行。</p></li><li><p>安装 <code>Kubernetes</code> 运行时的依赖包，比如: <code>Conntrack</code>、<code>Socat</code>、<code>CNI</code> 等。</p></li><li><p>安装容器运行环境，比如: <code>Containerd</code>、<code>Crictl</code> 等。</p></li><li><p>配置自己的 <code>ENTRYPOINT</code> 脚本，以适应和调整容器内运行的问题。</p></li></ul><p>更多具体的构建逻辑可以参考：<a href="https://github.com/kubernetes-sigs/kind/blob/master/images/base/Dockerfile" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kind/blob/master/images/base/Dockerfile</a></p><ol start="2"><li>Node 镜像</li></ol><p><code>Node</code> 镜像的构建比较复杂，目前是通过运行 <code>Base</code> 镜像并在 <code>Base</code> 镜像内执行操作，再保存此容器内容为镜像的方式来构建的，包含的操作有：</p><ul><li><p>构建 <code>Kubernetes</code> 相关资源，比如：二进制文件和镜像。</p></li><li><p>运行一个用于构建的容器</p></li><li><p>把构建的 <code>Kubernetes</code> 相关资源复制到容器里</p></li><li><p>调整部分组件配置参数，以支持在容器内运行</p></li><li><p>预先拉去运行环境需要的镜像</p></li><li><p>通过 <code>docker commit</code> 方式保存当前的构建容器为 <code>Node</code> 镜像</p></li></ul><h3 id="如何快速删除一个集群">如何快速删除一个集群</h3><p>如果你不需要本地的集群环境，通过以下命令进行删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kind delete  cluster --name my-cluster</span><br><span class="line">Deleting cluster &quot;my-cluster&quot; ...</span><br><span class="line">$KUBECONFIG is still set to use &#x2F;root&#x2F;.kube&#x2F;kind-config-my-cluster even though that file has been deleted, remember to unset it</span><br></pre></td></tr></table></figure><p>至此，我们就演示完了如何使用 <code>Kind</code> 快速搭建一个 <code>Kubernetes</code> 集群。 不过有一个你需要注意的地方，<code>Kind</code> 搭建的集群不适用于生产环境中使用。但是如果你想在本地快速构建一个 <code>Kubernetes</code> 集群环境，并且不想占用太多的硬件资源，那么 <code>Kind</code> 会是你不错的选择。</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="http://t.cn/AiRVBwDS" target="_blank" rel="noopener">http://t.cn/AiRVBwDS</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/60464867" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60464867</a></p></li><li><p><a href="https://yeya24.github.io/post/kind/" target="_blank" rel="noopener">https://yeya24.github.io/post/kind/</a></p></li><li><p><a href="http://dockerone.com/article/8974" target="_blank" rel="noopener">http://dockerone.com/article/8974</a></p></li><li><p><a href="https://kind.sigs.k8s.io/docs/user/quick-start/" target="_blank" rel="noopener">https://kind.sigs.k8s.io/docs/user/quick-start/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Kind&quot;&gt;什么是 Kind&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Kind&lt;/code&gt;（Kubernetes in Docker） 是一个 &lt;code&gt;Kubernetes&lt;/code&gt; 孵化项目，&lt;code&gt;Kind&lt;/code&gt; 是一套开箱即用的 &lt;code&gt;Kubernetes&lt;/code&gt; 环境搭建方案。顾名思义，就是将 &lt;code&gt;Kubernetes&lt;/code&gt; 所需要的所有组件，全部部署在一个 &lt;code&gt;Docker&lt;/code&gt; 容器中，可以很方便的搭建 &lt;code&gt;Kubernetes&lt;/code&gt; 集群。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Kind&lt;/code&gt; 已经广泛的应用于 &lt;code&gt;Kubernetes&lt;/code&gt; 上游及相关项目的 &lt;code&gt;CI&lt;/code&gt; 环境中，官方文档中也把 &lt;code&gt;Kind&lt;/code&gt; 作为一种本地集群搭建的工具推荐给大家。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/kubernetes-sigs/kind&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes-sigs/kind&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Kind 可以做什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;快速创建一个或多个 &lt;code&gt;Kubernetes&lt;/code&gt; 集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持部署高可用的 &lt;code&gt;Kubernetes&lt;/code&gt; 集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持从源码构建并部署一个 &lt;code&gt;Kubernetes&lt;/code&gt; 集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以快速低成本体验一个最新的 &lt;code&gt;Kubernetes&lt;/code&gt; 集群，并支持 &lt;code&gt;Kubernetes&lt;/code&gt; 的绝大部分功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持本地离线运行一个多节点集群&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Kind 有哪些优势？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;最小的安装依赖，仅需要安装 &lt;code&gt;Docker&lt;/code&gt; 即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用方法简单，只需 &lt;code&gt;Kind Cli&lt;/code&gt; 工具即可快速创建集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用容器来模似 &lt;code&gt;Kubernetes&lt;/code&gt; 节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部使用 &lt;code&gt;Kubeadm&lt;/code&gt; 的官方主流部署工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过了 &lt;code&gt;CNCF&lt;/code&gt; 官方的 &lt;code&gt;K8S Conformance&lt;/code&gt; 测试&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>分享几个让 Linux 非 Root 用户运行的程序使用特权端口的技巧</title>
    <link href="https://www.hi-linux.com/posts/26613.html"/>
    <id>https://www.hi-linux.com/posts/26613.html</id>
    <published>2020-05-13T01:00:00.000Z</published>
    <updated>2020-05-13T04:59:42.628Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，在 <code>Linux</code> 系统下，只允许 <code>Root</code> 用户运行的程序才可以使用特权端口 ( <code>1024</code> 以下的端口 )。如果在普通用户下使用特权端口将会报错。</p><p>在一些特定的环境下，我们可能考虑到程序运行在 <code>Root</code> 帐户下，可能会给 <code>Linux</code> 系统带来安全风险。希望能让普通用户启动的程序运行在特权端口上，比如：Web 服务器。</p><p>那如何能够让普通用户启动的程序运行在特权端口呢？本文将介绍一些方法，让你能够解决这个问题。</p><h2 id="通过设置-cap_net_bind_service-实现">通过设置 CAP_NET_BIND_SERVICE 实现</h2><p><code>Linux</code> 内核从 2.6.24 版本开始就有了能力的概念，这使得普通用户也能够做只有超级用户才能完成的工作。</p><p>使用 <code>setcap</code> 命令让指定程序拥有绑定端口的能力，这样即使程序运行在普通用户下，也能够绑定到 1024 以下的特权端口上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 给指定程序设置 CAP_NET_BIND_SERVICE 能力</span><br><span class="line">$ setcap cap_net_bind_service&#x3D;+eip &#x2F;path&#x2F;to&#x2F;application</span><br></pre></td></tr></table></figure><p>下面我们来看一个实例，以 <code>Nginx</code> 为例：</p><p><img src="https://www.hi-linux.com/img/linux/setcap.jpg" alt=""></p><p>如果你的程序不再需要使用这个能力，你可以使用以下命令来清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setcap -r &#x2F;path&#x2F;to&#x2F;application</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>这个方法并不是所有 <code>Linux</code> 系统通用，<code>Linux</code> 内核在 2.6.24 之前的并没有提供此项能力，因此你需要检查要使用此方法所在系统是否支持。</p></li><li><p>另外需要注意的是，如果要运行的程序是一个脚本，这个方法是没有办法正常工作的。</p></li></ol></blockquote><a id="more"></a><h2 id="通过端口转发实现">通过端口转发实现</h2><p>如果要运行的程序有权限监听其他端口，那么这个方法是可以使用的。首先让程序运行在普通用户下，并绑定高于 1024 的端口。在确保能正常工作的时候，我们将通过端口转发将低端口的请求转到应用所在的高端口，从而实现普通用户启动的程序绑定到低端口。要使用此方法可以使用下面的方式。</p><ol><li>配置内核参数以启用转发功能</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Enable the IP FORWARD kernel parameter.</span><br><span class="line">$ sysctl -w net.ipv4.ip_forward&#x3D;1</span><br></pre></td></tr></table></figure><p>以上方法是临时性设置，重启之后将会被重置。如果你想长期保存，需要在 <code>/etc/sysctl.conf</code> 文件内修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim  &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line"># Default value is 0, need change to 1.</span><br><span class="line"># net.ipv4.ip_forward &#x3D; 0</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br></pre></td></tr></table></figure><p>然后，使用 <code>sysctl</code> 命令从文件中加载新的配置，并使其生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># load new sysctl.conf</span><br><span class="line">$ sysctl -p &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"> </span><br><span class="line"># or sysctl -p</span><br><span class="line"># default filename is &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>配置转发规则</li></ol><p>这里我们使用 <code>Iptables</code> 来配置的转发规则，以实现端口转发到程序所在的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将 80 端口转发到 8088</span><br><span class="line">$ iptables -F -t nat</span><br><span class="line">$ iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to:8088</span><br></pre></td></tr></table></figure><p>此种方法能够比较好的达到我们的目的，我们的程序可以通过普通用户来运行，并能够对外提供低端口号的服务。</p><h2 id="通过-authbind-实现">通过 authbind 实现</h2><p><code>authbind</code> 是一个支持普通用户就能绑定系统特权端口的程序，你只需要使用 <code>authbind</code> 程序来调用需要使用特权端口的程序就可以了。</p><ol><li>安装 authbind</li></ol><ul><li>Debian / Ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install authbind</span><br></pre></td></tr></table></figure><ul><li>CentOS / RHEL</li></ul><p>CentOS 系列的系统安装起来相对就要麻烦一些，因为官方仓库并没有提供编译好的软件包。不过幸运的是，已经有人编译好了对应的软件包，我们只需要直接安装就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -ivh https:&#x2F;&#x2F;s3.amazonaws.com&#x2F;aaronsilber&#x2F;public&#x2F;authbind-2.1.1-0.1.x86_64.rpm</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 authbind</li></ol><p><code>authbind</code> 默认的配置文件在 <code>/etc/authbind</code> 目录下，里面有三个目录：<code>byport</code>、<code>byaddr</code>、<code>byuid</code>。</p><p>假如我们有一个 test 的普通账号，想运行一个程序并绑定在 80 端口上。我们需要配置以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在 byport 目录下建立 80 文件</span><br><span class="line">$ sudo touch &#x2F;etc&#x2F;authbind&#x2F;byport&#x2F;80</span><br><span class="line"># 设置 test 账户有 80 文件的使用权限</span><br><span class="line">$ sudo chmod 755 &#x2F;etc&#x2F;authbind&#x2F;byport&#x2F;80</span><br><span class="line">$ sudo chown test.test &#x2F;etc&#x2F;authbind&#x2F;byport&#x2F;80</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 authbind 运行指定程序</li></ol><p>在你要启动的命令前加上 <code>authbind --deep</code> 命令即可。例如：要用 test 这个普通用户启动 <code>Nginx</code> 并绑定在 80 端口，只需执行以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ authbind --deep &quot;&#x2F;usr&#x2F;bin&#x2F;nginx&quot; -c &quot;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&quot;</span><br></pre></td></tr></table></figure><p>我们也可以直接在 IP 地址上直接绑定端口，只需在 <code>byaddr</code> 目录下建立 <code>ip:port</code> 文件就可以了。</p><h2 id="通过-setuid-实现">通过 SetUID 实现</h2><p><code>SetUID</code> 这一特性可以让只有普通用户权限的应用程序用 Root 权限来运行，我们可以看到系统下 <code>/usr/bin/passwd</code> 这个文件，就使用了 <code>SetUID</code>。这样就使得系统的每个普通用户都能用 <code>passwd</code> 来修改密码，因为修改密码需要更改 <code>/etc/passwd</code> 文件，而默认这个文件只有 Root 用户才有权限访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将程序的所有者更改为 root</span><br><span class="line">$ chown root.root &#x2F;path&#x2F;to&#x2F;application</span><br><span class="line"></span><br><span class="line"># 给程序设置 SetUID</span><br><span class="line">$ chmod u+s &#x2F;path&#x2F;to&#x2F;application</span><br></pre></td></tr></table></figure><p>既然要使用普通用户运行程序，目的就是要降低程序本身给系统带来的安全风险。因此，本方法使用的时候需要特别谨慎，特别是当要执行的程序本身存在安全风险。</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://www.cnblogs.com/chenjunjie12321/p/9226279.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenjunjie12321/p/9226279.html</a></li><li><a href="https://blog.csdn.net/Becivells/article/details/52842019" target="_blank" rel="noopener">https://blog.csdn.net/Becivells/article/details/52842019</a></li><li><a href="https://my.oschina.net/guol/blog/186430" target="_blank" rel="noopener">https://my.oschina.net/guol/blog/186430</a></li><li><a href="https://github.com/tootedom/authbind-centos-rpm" target="_blank" rel="noopener">https://github.com/tootedom/authbind-centos-rpm</a></li><li><a href="https://dzone.com/articles/running-tomcat-port-80-user" target="_blank" rel="noopener">https://dzone.com/articles/running-tomcat-port-80-user</a></li><li><a href="http://blog.useasp.net/archive/2015/07/09/non-root-user-application-bind-to-ports-less-than-1024-without-root-access.aspx" target="_blank" rel="noopener">http://blog.useasp.net/archive/2015/07/09/non-root-user-application-bind-to-ports-less-than-1024-without-root-access.aspx</a></li><li><a href="https://stackoverflow.com/questions/413807/is-there-a-way-for-non-root-processes-to-bind-to-privileged-ports-on-linux" target="_blank" rel="noopener">https://stackoverflow.com/questions/413807/is-there-a-way-for-non-root-processes-to-bind-to-privileged-ports-on-linux</a></li><li><a href="https://aaronsilber.me/2016/04/24/install-authbind-on-centos-7-x86_64-download-the-rpm/" target="_blank" rel="noopener">https://aaronsilber.me/2016/04/24/install-authbind-on-centos-7-x86_64-download-the-rpm/</a></li><li><a href="https://blog.webhosting.net/how-to-get-tomcat-running-on-centos-7-2-using-privileged-ports-1024/" target="_blank" rel="noopener">https://blog.webhosting.net/how-to-get-tomcat-running-on-centos-7-2-using-privileged-ports-1024/</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，在 &lt;code&gt;Linux&lt;/code&gt; 系统下，只允许 &lt;code&gt;Root&lt;/code&gt; 用户运行的程序才可以使用特权端口 ( &lt;code&gt;1024&lt;/code&gt; 以下的端口 )。如果在普通用户下使用特权端口将会报错。&lt;/p&gt;
&lt;p&gt;在一些特定的环境下，我们可能考虑到程序运行在 &lt;code&gt;Root&lt;/code&gt; 帐户下，可能会给 &lt;code&gt;Linux&lt;/code&gt; 系统带来安全风险。希望能让普通用户启动的程序运行在特权端口上，比如：Web 服务器。&lt;/p&gt;
&lt;p&gt;那如何能够让普通用户启动的程序运行在特权端口呢？本文将介绍一些方法，让你能够解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;通过设置-CAP-NET-BIND-SERVICE-实现&quot;&gt;通过设置 CAP_NET_BIND_SERVICE 实现&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 内核从 2.6.24 版本开始就有了能力的概念，这使得普通用户也能够做只有超级用户才能完成的工作。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;setcap&lt;/code&gt; 命令让指定程序拥有绑定端口的能力，这样即使程序运行在普通用户下，也能够绑定到 1024 以下的特权端口上。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 给指定程序设置 CAP_NET_BIND_SERVICE 能力&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ setcap cap_net_bind_service&amp;#x3D;+eip &amp;#x2F;path&amp;#x2F;to&amp;#x2F;application&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面我们来看一个实例，以 &lt;code&gt;Nginx&lt;/code&gt; 为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/setcap.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你的程序不再需要使用这个能力，你可以使用以下命令来清除。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ setcap -r &amp;#x2F;path&amp;#x2F;to&amp;#x2F;application&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这个方法并不是所有 &lt;code&gt;Linux&lt;/code&gt; 系统通用，&lt;code&gt;Linux&lt;/code&gt; 内核在 2.6.24 之前的并没有提供此项能力，因此你需要检查要使用此方法所在系统是否支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外需要注意的是，如果要运行的程序是一个脚本，这个方法是没有办法正常工作的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>巧用 GoTTY 优雅的管理 Docker 容器权限</title>
    <link href="https://www.hi-linux.com/posts/33412.html"/>
    <id>https://www.hi-linux.com/posts/33412.html</id>
    <published>2020-05-13T01:00:00.000Z</published>
    <updated>2020-05-13T05:23:34.054Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>GoTTY</code> 是一个简单的基于 <code>Go</code> 语言的命令行工具，它可以将你的终端（TTY）作为 <code>Web</code> 程序共享。<code>GoTTY</code> 的架构是基于 <code>Hterm</code> + <code>Web Socket</code> 的，它能在 <code>Web</code> 浏览器上运行一个基于 <code>JavaScript</code> 的终端，并支持通过 <code>HTTP</code> 和 <code>HTTPS</code> 访问。</p><blockquote><p>项目地址：<a href="https://github.com/yudai/gotty" target="_blank" rel="noopener">https://github.com/yudai/gotty</a></p></blockquote><p><img src="https://raw.githubusercontent.com/yudai/gotty/master/screenshot.gif" alt=""></p><h2 id="安装-gotty">安装 GoTTY</h2><p><code>GoTTY</code> 原生支持良好的跨平台性，开箱即用。只需下载对应平台的二进制包就行了，这里以 <code>Linux</code> 平台为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 下载并解压 GoTTY 安装包</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;yudai&#x2F;gotty&#x2F;releases&#x2F;download&#x2F;v1.0.1&#x2F;gotty_linux_amd64.tar.gz</span><br><span class="line">$ tar -xzvf gotty_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 复制可执行文件到指定目录并赋予执行权限</span><br><span class="line">$ sudo cp gotty &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">$ chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;gotty</span><br></pre></td></tr></table></figure><p>更多平台的二进制安装包，可自行在官方项目地址的 <a href="https://github.com/yudai/gotty/releases" target="_blank" rel="noopener">Releases</a> 页面进行下载。</p><p>如果你使用的是 Mac，也可以通过 <code>Homebrew</code> 来实现一键安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install yudai&#x2F;gotty&#x2F;gotty</span><br></pre></td></tr></table></figure><p>安装完成后，检查一下 <code>Gotty</code> 的版本，以验证是否安装正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gotty -version</span><br><span class="line">gotty version 1.0.1</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="使用-gotty">使用 GoTTY</h2><p>你可以使用任何命令来作为 <code>GoTTY</code> 的参数运行，例如：<code>gotty top</code>。</p><h3 id="gotty-语法">GoTTY 语法</h3><ol><li>GoTTY 命令的常规语法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: gotty [options] &lt;command&gt; [&lt;arguments...&gt;]</span><br></pre></td></tr></table></figure><ol start="2"><li>GoTTY 命令的常用参数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--address value, -a value     IP address to listen (default: &quot;0.0.0.0&quot;) [$GOTTY_ADDRESS]</span><br><span class="line">--port value, -p value        Port number to liten (default: &quot;8080&quot;) [$GOTTY_PORT]</span><br><span class="line">--permit-write, -w            Permit clients to write to the TTY (BE CAREFUL) [$GOTTY_PERMIT_WRITE]</span><br><span class="line">--credential value, -c value  Credential for Basic Authentication (ex: user:pass, default disabled) [$GOTTY_CREDENTIAL]</span><br><span class="line">--random-url, -r              Add a random string to the URL [$GOTTY_RANDOM_URL]</span><br><span class="line">--random-url-length value     Random URL length (default: 8) [$GOTTY_RANDOM_URL_LENGTH]</span><br><span class="line">--tls, -t                     Enable TLS&#x2F;SSL [$GOTTY_TLS]</span><br><span class="line">--tls-crt value               TLS&#x2F;SSL certificate file path (default: &quot;~&#x2F;.gotty.crt&quot;) [$GOTTY_TLS_CRT]</span><br><span class="line">--tls-key value               TLS&#x2F;SSL key file path (default: &quot;~&#x2F;.gotty.key&quot;) [$GOTTY_TLS_KEY]</span><br><span class="line">--tls-ca-crt value            TLS&#x2F;SSL CA certificate file for client certifications (default: &quot;~&#x2F;.gotty.ca.crt&quot;) [$GOTTY_TLS_CA_CRT]</span><br><span class="line">--index value                 Custom index.html file [$GOTTY_INDEX]</span><br><span class="line">--title-format value          Title format of browser window (default: &quot;&#123;&#123; .command &#125;&#125;@&#123;&#123; .hostname &#125;&#125;&quot;) [$GOTTY_TITLE_FORMAT]</span><br><span class="line">--reconnect                   Enable reconnection [$GOTTY_RECONNECT]</span><br><span class="line">--reconnect-time value        Time to reconnect (default: 10) [$GOTTY_RECONNECT_TIME]</span><br><span class="line">--max-connection value        Maximum connection to gotty (default: 0) [$GOTTY_MAX_CONNECTION]</span><br><span class="line">--once                        Accept only one client and exit on disconnection [$GOTTY_ONCE]</span><br><span class="line">--timeout value               Timeout seconds for waiting a client(0 to disable) (default: 0) [$GOTTY_TIMEOUT]</span><br><span class="line">--permit-arguments            Permit clients to send command line arguments in URL (e.g. http:&#x2F;&#x2F;example.com:8080&#x2F;?arg&#x3D;AAA&amp;arg&#x3D;BBB) [$GOTTY_PERMIT_ARGUMENTS]</span><br><span class="line">--width value                 Static width of the screen, 0(default) means dynamically resize (default: 0) [$GOTTY_WIDTH]</span><br><span class="line">--height value                Static height of the screen, 0(default) means dynamically resize (default: 0) [$GOTTY_HEIGHT]</span><br><span class="line">--ws-origin value             A regular expression that matches origin URLs to be accepted by WebSocket. No cross origin requests are acceptable by default [$GOTTY_WS_ORIGIN]</span><br><span class="line">--term value                  Terminal name to use on the browser, one of xterm or hterm. (default: &quot;xterm&quot;) [$GOTTY_TERM]</span><br><span class="line">--close-signal value          Signal sent to the command process when gotty close it (default: SIGHUP) (default: 1) [$GOTTY_CLOSE_SIGNAL]</span><br><span class="line">--close-timeout value         Time in seconds to force kill process after client is disconnected (default: -1) (default: -1) [$GOTTY_CLOSE_TIMEOUT]</span><br><span class="line">--config value                Config file path (default: &quot;~&#x2F;.gotty&quot;) [$GOTTY_CONFIG]</span><br><span class="line">--version, -v                 print the version</span><br></pre></td></tr></table></figure><ol start="3"><li>GoTTY 的配置文件</li></ol><p>除了通过命令行直接给 <code>GoTTY</code> 指定参数外，你还可以通过向 <code>GoTTY</code> 命令提供配置文件来自定义默认参数和终端的样式。默认情况下，<code>GoTTY</code> 会加载用户目录下的 <code>.gotty</code> 文件 (<code>~/.gotty</code>) 为配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~&#x2F;.gotty</span><br><span class="line">&#x2F;&#x2F; Listen at port 9000 by default</span><br><span class="line">port &#x3D; &quot;9000&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Enable TSL&#x2F;SSL by default</span><br><span class="line">enable_tls &#x3D; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; hterm preferences</span><br><span class="line">&#x2F;&#x2F; Smaller font and a little bit bluer background color</span><br><span class="line">preferences &#123;</span><br><span class="line">    font_size &#x3D; 5</span><br><span class="line">    background_color &#x3D; &quot;rgb(16, 16, 32)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用实例">使用实例</h3><p><code>GoTTY</code> 命令运行完成后，默认会在 8080 启动一个 <code>Web</code> 服务器。你只需在浏览器中打开 <code>http://127.0.0.1:8080/</code>，就会看到运行的命令，仿佛和运行在终端中一样。<code>GoTTY</code> 支持的功能相当丰富，下面我就来看几个比较常用的使用实例。</p><ol><li>通过 GoTTY 直接在 Web 端查看系统分区空间及使用率</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty df -h</span><br></pre></td></tr></table></figure><p><img src="https://www.tecmint.com/wp-content/uploads/2017/03/Gotty-Linux-Disk-Usage.png" alt=""></p><ol start="2"><li>允许在 Web 终端中运行命令</li></ol><p>默认情况下，<code>GoTTY</code> 不允许在 <code>Web</code> 终端中进行输入。但是，你可以使用 <code>-w</code> 或 <code>--permit-write</code> 选项来启用 <code>Web</code> 终端可写入 <code>TTY</code> 的特性。</p><p>下面我们演示一个用 <code>vi</code> 命令在浏览器中编辑 <code>fossmint.txt</code> 文件的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty -w vi fossmint.txt</span><br></pre></td></tr></table></figure><p>我们可以从浏览器中看到打开的 <code>vi</code> 界面和在终端打开的一模一样。</p><p><img src="https://www.tecmint.com/wp-content/uploads/2017/03/Gotty-Web-Vi-Editor.png" alt=""></p><ol start="3"><li>使用 GoTTY 对容器内部进行管理</li></ol><p>众所周知，在 <code>Kubernetes</code> / <code>Docker</code> 环境下，我们需要提供一种能力让研发或者其它相关技术人员可以在不登陆宿主机的情况下直接访问容器或者是查看容器中应用程序的当前状态。基于上面介绍的允许 <code>Web</code> 终端写入 <code>TTY</code> 的特性，我们可以灵活的将这一特性运用到容器管理中来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 Docker 命令进入容器内部</span><br><span class="line">$ gotty -w --permit-arguments docker exec -ti</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 Kubectl 命令进入容器内部</span><br><span class="line">$ gotty -w --permit-arguments kubectl exec -ti</span><br></pre></td></tr></table></figure><p>执行上面命令后，你就可以直接通过浏览器传入容器的 ID 和进入容器需要执行的命令。这里传入的命令是 <code>/bin/bash</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;172.172.241.180:8080&#x2F;?arg&#x3D;6f&amp;arg&#x3D;%2fbin%2fbash</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用浏览器频繁进入容器之后，容器内部会产生大量 <code>/bin/bash</code> 进程 ，一般不推荐直接进入容器。</p></blockquote><ol start="4"><li>给 GoTTY 加上基本的身份验证</li></ol><p>默认情况下通过浏览器访问 <code>GoTTY</code> 是不需要验证的，任何人都可以访问。为了更加的安全，我们可以给 <code>GoTTY</code> 加上基本身份验证机制。这样在通过浏览器访问时，就需要输入指定的用户名和密码才能访问到 <code>GoTTY</code> 所在的服务器。</p><p>要给 <code>GoTTY</code> 加上基本的验证，用到的是 <code>-c</code> 选项，该选项主要用来指定访问 <code>GoTTY</code> 时所需的用户名和密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用户名是：test 密码是：@67890</span><br><span class="line">$ gotty -w -p &quot;9000&quot; -c &quot;test:@67890&quot; glances</span><br></pre></td></tr></table></figure><p><img src="https://www.tecmint.com/wp-content/uploads/2017/03/Gotty-use-basic-authentication.png" alt=""></p><ol start="5"><li>给 Gotty 生成随机 URL</li></ol><p>除了身份验证外，限制访问服务器的另一种方法是使用随机 <code>URL</code>。通过 <code>GoTTY</code> 的 <code>-r</code> 选项，我们就能生成一个随机 <code>URL</code>，这样就只有知道该 <code>URL</code> 的用户才可以访问该服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty -r glances</span><br></pre></td></tr></table></figure><p>你还可以使用下面的选项来定义浏览器标题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty -r --title-format <span class="string">"GoTTY - &#123;&#123; .Command &#125;&#125; (&#123;&#123; .Hostname &#125;&#125;)"</span> glances</span><br></pre></td></tr></table></figure><p><img src="https://www.tecmint.com/wp-content/uploads/2017/03/Gotty-Random-URL-for-Glances-Linux-Monitoring.png" alt=""></p><ol start="6"><li>给 GoTTY 启用 SSL/TLS 认证</li></ol><p>默认情况下服务器和客户端之间的所有连接都不加密，当你通过 <code>GoTTY</code> 发送敏感数据时，为保证数据完全建议你启用 <code>SSL/TLS</code>。</p><p><code>GoTTY</code> 启用 <code>SSL/TLS</code> 的支持需要使用 <code>-t</code> 或 <code>--tls</code> 选项。默认情况下，<code>GoTTY</code> 会读取用户主目录下的证书文件和密钥文件 ( <code>~/.gotty.crt</code> 和 <code>~/.gotty.key</code>)。</p><p>首先，我们先创建一个自签名的证书文件以及密钥文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ~&#x2F;.gotty.key -out ~&#x2F;.gotty.crt</span><br></pre></td></tr></table></figure><p>然后，通过下面的命令启用 <code>GoTTY</code> 的 <code>SSL/TLS</code> 特性后，以达到安全访问 <code>GoTTY</code> 的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty -tr --title-format &quot;GoTTY - &#123;&#123; .Command &#125;&#125; (&#123;&#123; .Hostname &#125;&#125;)&quot; glances</span><br></pre></td></tr></table></figure><ol start="7"><li>与多个客户端同时共享终端</li></ol><p>如果你需要和多个客户端同时共享一个终端，这里你需要使用一个终端多路复用器与多个客户端共享单个进程，以下命令以 <code>tmux</code> 为例。</p><p>首先，我们先启动一个名为 <code>gotty</code> 的新 <code>tmux</code> 会话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty tmux new -A -s gotty</span><br></pre></td></tr></table></figure><p>其次，在另外一个终端上 <code>attach</code> 上这个 <code>tmux</code> 会话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tmux attach -t gotty</span><br><span class="line">$ vim test.php</span><br></pre></td></tr></table></figure><p>最后，我们通过浏览器可以实时看到在终端中所有的输入，这种场景特别适用于教学和演示。</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a></p></li><li><p><a href="https://ywnz.com/linuxrj/4060.html" target="_blank" rel="noopener">https://ywnz.com/linuxrj/4060.html</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/26590894" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26590894</a></p></li><li><p><a href="https://blog.csdn.net/cj2580/article/details/79318726" target="_blank" rel="noopener">https://blog.csdn.net/cj2580/article/details/79318726</a></p></li><li><p><a href="https://www.tecmint.com/gotty-share-linux-terminal-in-web-browser/" target="_blank" rel="noopener">https://www.tecmint.com/gotty-share-linux-terminal-in-web-browser/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;GoTTY&lt;/code&gt; 是一个简单的基于 &lt;code&gt;Go&lt;/code&gt; 语言的命令行工具，它可以将你的终端（TTY）作为 &lt;code&gt;Web&lt;/code&gt; 程序共享。&lt;code&gt;GoTTY&lt;/code&gt; 的架构是基于 &lt;code&gt;Hterm&lt;/code&gt; + &lt;code&gt;Web Socket&lt;/code&gt; 的，它能在 &lt;code&gt;Web&lt;/code&gt; 浏览器上运行一个基于 &lt;code&gt;JavaScript&lt;/code&gt; 的终端，并支持通过 &lt;code&gt;HTTP&lt;/code&gt; 和 &lt;code&gt;HTTPS&lt;/code&gt; 访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/yudai/gotty&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yudai/gotty&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yudai/gotty/master/screenshot.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装-GoTTY&quot;&gt;安装 GoTTY&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GoTTY&lt;/code&gt; 原生支持良好的跨平台性，开箱即用。只需下载对应平台的二进制包就行了，这里以 &lt;code&gt;Linux&lt;/code&gt; 平台为例。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 下载并解压 GoTTY 安装包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ wget https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;yudai&amp;#x2F;gotty&amp;#x2F;releases&amp;#x2F;download&amp;#x2F;v1.0.1&amp;#x2F;gotty_linux_amd64.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ tar -xzvf gotty_linux_amd64.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 复制可执行文件到指定目录并赋予执行权限&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo cp gotty &amp;#x2F;usr&amp;#x2F;local&amp;#x2F;bin&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ chmod +x &amp;#x2F;usr&amp;#x2F;local&amp;#x2F;bin&amp;#x2F;gotty&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更多平台的二进制安装包，可自行在官方项目地址的 &lt;a href=&quot;https://github.com/yudai/gotty/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Releases&lt;/a&gt; 页面进行下载。&lt;/p&gt;
&lt;p&gt;如果你使用的是 Mac，也可以通过 &lt;code&gt;Homebrew&lt;/code&gt; 来实现一键安装。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew install yudai&amp;#x2F;gotty&amp;#x2F;gotty&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装完成后，检查一下 &lt;code&gt;Gotty&lt;/code&gt; 的版本，以验证是否安装正确。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ gotty -version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gotty version 1.0.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>nftables 简明教程</title>
    <link href="https://www.hi-linux.com/posts/29206.html"/>
    <id>https://www.hi-linux.com/posts/29206.html</id>
    <published>2020-05-12T01:00:00.000Z</published>
    <updated>2020-05-12T05:06:03.209Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-nftables">什么是 nftables？</h2><p><code>nftables</code> 是一个新式的数据包过滤框架，旨在替代现用的 <code>iptables</code>、<code>ip6tables</code>、<code>arptables</code> 和 <code>ebtables</code> 的新的包过滤框架。<code>nftables</code> 诞生于 2008 年，2013 年底合并到 <code>Linux 内核</code>，从 <code>Linux</code> 内核 <code>3.13</code> 版本开始大多数场景下 <code>nftables</code> 已经可以使用，但是完整的支持（即：<code>nftables</code> 优先级高于 <code>iptables</code>）应该是在 Linux 内核 <code>3.15</code> 版本。</p><p><code>nftables</code> 旨在解决现有 <code>{ip/ip6}tables</code> 工具存在的诸多限制。相对于旧的 <code>iptables</code>，<code>nftables</code> 最引人注目的功能包括：改进性能、支持查询表、事务型规则更新、所有规则自动应用等等。</p><p><code>nftables</code> 主要由三个组件组成：内核实现、<code>libnl netlink</code> 通信和 <code>nftables</code> 用户空间。其中内核提供了一个 <code>netlink</code> 配置接口以及运行时规则集评估，<code>libnl</code> 包含了与内核通信的基本函数，用户空间可以通过新引入的命令行工具 <code>nft</code> 和用户进行交互。</p><p><code>nft</code> 可以通过在寄存器中储存和加载来交换数据。也就是说，它的语法与 <code>iptables</code> 不同。但 <code>nft</code> 可以利用内核提供的表达式去模拟旧的 <code>iptables</code> 命令，维持兼容性的同时获得更大的灵活性。简单来说，<code>nft</code> 是 <code>iptables</code> 及其衍生指令（<code>ip6tables</code> 和 <code>arptables</code> ）的超集。</p><h3 id="nftables-的特点">nftables 的特点</h3><ol><li><p><code>nftables</code> 拥有一些高级的类似编程语言的能力，例如：定义变量和包含外部文件，即拥有使用额外脚本的能力。<code>nftables</code> 也可以用于多种地址簇的过滤和处理。</p></li><li><p>不同于 <code>iptables</code>, <code>nftables</code> 并不包含任何的内置表，需要哪些表并在这些表中添加什么处理规则一切由管理员决定。</p></li><li><p>表包含规则链，规则链包含规则。</p></li></ol><h3 id="nftables-相较于-iptables-的优点">nftables 相较于 iptables 的优点</h3><ol><li>更新速度更快</li></ol><p>在 <code>iptables</code> 中添加一条规则，会随着规则数量增多而变得非常慢。这种状况对 <code>nftables</code> 而言就不存在了，因为 <code>nftables</code> 使用原子的快速操作来更新规则集合。</p><ol start="2"><li>内核更新更少。</li></ol><p>使用 <code>iptables</code> 时，每一个匹配或投递都需要内核模块的支持。因此，如果你忘记一些东西或者要添加新的功能时都需要重新编译内核。而在 <code>nftables</code> 中就不存在这种情况了， 因为在 <code>nftables</code> 中，大部分工作是在用户态完成的，内核只知道一些基本指令（过滤是用伪状态机实现的）。例如，<code>icmpv6</code> 支持是通过 <code>nft</code> 工具的一个简单的补丁实现的，而在 <code>iptables</code> 中这种类型的更改需要内核和 <code>iptables</code> 都升级才可以。</p><a id="more"></a><h2 id="nftables-基础操作">nftables 基础操作</h2><p><code>nftables</code> 和 <code>iptables</code> 一样，由表（table）、链（chain）和规则（rule）组成，其中表包含链，链包含规则，规则是真正的动作。</p><p>在 <code>nftables</code> 中，表是链的容器。所以开始使用 <code>nftables</code> 时你首先需要做的是添加至少一个表。然后，你可以向你的表里添加链，然后往链里添加规则。</p><h3 id="nftables-的表管理">nftables 的表管理</h3><p>与 <code>iptables</code> 中的表不同，<code>nftables</code> 中没有内置表。表的数量和名称由用户决定。但是，每个表只有一个地址簇，并且只适用于该簇的数据包。<code>nftables</code> 表可以指定为以下五个簇中的一个：</p><table><thead><tr><th>nftables 簇</th><th>对应 iptables 的命令行工具</th></tr></thead><tbody><tr><td>ip</td><td>iptables</td></tr><tr><td>ip6</td><td>ip6tables</td></tr><tr><td>inet</td><td>iptables 和 ip6tables</td></tr><tr><td>arp</td><td>arptables</td></tr><tr><td>bridge</td><td>ebtables</td></tr></tbody></table><p><code>ip</code>（即 IPv4）是默认簇，如果未指定簇，则使用该簇。如果要创建同时适用于 <code>IPv4</code> 和 <code>IPv6</code> 的规则，请使用 <code>inet</code> 簇 。<code>inet</code> 允许统一 <code>ip</code> 和 <code>ip6</code> 簇，以便更容易地定义规则。</p><blockquote><p>注意: <code>inet</code> 不能用于 <code>nat</code> 类型的链，只能用于 <code>filter</code> 类型的链。</p></blockquote><p>下面我们来看看 <code>nftables</code> 是如何进行表管理操作的，以下为 <code>nftables</code> 创建表的基本命令语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nft list tables [&lt;family&gt;]</span><br><span class="line">nft list table [&lt;family&gt;] &lt;name&gt; [-n] [-a]</span><br><span class="line">nft (add | delete | flush) table [&lt;family&gt;] &lt;name&gt;</span><br></pre></td></tr></table></figure><p>这里我们以创建一个 <code>inet</code> 簇的表为例，演示如何创建和管理一个新的表。</p><ol><li>创建表</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的表</span></span><br><span class="line">$ nft add table inet mytable</span><br></pre></td></tr></table></figure><ol start="2"><li>列出表</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有表</span></span><br><span class="line">$ nft list tables</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定族的所有表</span></span><br><span class="line">$ nft list tables inet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 inet 簇中 mytable 表中的所有规则</span></span><br><span class="line">$ nft list table inet mytable</span><br></pre></td></tr></table></figure><ol start="3"><li>删除表</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除一个表</span></span><br><span class="line">$ nft delete table inet mytable</span><br></pre></td></tr></table></figure><blockquote><p>注意：只能删除不包含链的表。</p></blockquote><ol start="4"><li>清空表</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空一个表中的所有规则</span></span><br><span class="line">$ nft flush table inet mytable</span><br></pre></td></tr></table></figure><h3 id="nftables-的链管理">nftables 的链管理</h3><p>链是用来保存规则的，与 <code>iptables</code> 中的链不同，<code>nftables</code> 没有内置链。这意味着和表一样，链也需要被显示创建。链有以下两种类型：</p><ul><li><p>常规链 : 主要用来做跳转，不需要指定钩子类型和优先级。从逻辑上对规则进行分类，支持所有的 <code>nftables</code> 簇。</p></li><li><p>基本链 : 来自网络栈数据包的入口点，需要指定钩子类型和优先级，支持 <code>ip</code> 和 <code>ip6</code> 簇。</p></li></ul><p><strong>nftables 链支持钩子的类型</strong></p><p><code>nftables</code> 和 <code>iptables</code> 类似，依然使用 <code>netfiler</code> 中的 5 个 钩子。</p><p><img src="https://i.loli.net/2019/11/11/Xk6QsDoqw7xRC21.png" alt=""></p><p>不同的是 <code>nftables</code> 在 <code>Linux Kernel 4.2</code> 中新增了 <code>ingress</code> 钩子。</p><p><img src="https://i.loli.net/2019/11/11/498zJrR27kqptXT.png" alt=""></p><p><strong>nftables 链支持钩子的作用</strong></p><ul><li><p><code>prerouting</code>：刚到达并未被 <code>nftables</code> 的其他部分所路由或处理的数据包。</p></li><li><p><code>input</code>：已经被接收并且已经经过 <code>prerouting</code> 钩子的传入数据包。</p></li><li><p><code>forward</code>：如果数据报将被发送到另一个设备，它将会通过 <code>forward</code> 钩子。</p></li><li><p><code>output</code>：从本地传出的数据包。</p></li><li><p><code>postrouting</code>：仅仅在离开系统之前，可以对数据包进行进一步处理。</p></li></ul><p><strong>nftables 链支持钩子的适用范围</strong></p><ul><li><p><code>ip</code>、<code>ip6</code> 和 <code>inet</code> 簇支持的钩子有： <code>prerouting</code>、 <code>input</code>、<code>forward</code>、 <code>output</code>、<code>postrouting</code> 。</p></li><li><p><code>arp</code> 簇支持的钩子有： <code>input</code>、<code>output</code> 。</p></li></ul><p><strong>nftables 链支持的优先级</strong></p><p>优先级采用整数值表示，数字较小的链优先处理，并且可以是负数。可以使用的值有：</p><ul><li><p>NF_IP_PRI_CONNTRACK_DEFRAG (-400)</p></li><li><p>NF_IP_PRI_RAW (-300)</p></li><li><p>NF_IP_PRI_SELINUX_FIRST (-225)</p></li><li><p>NF_IP_PRI_CONNTRACK (-200)</p></li><li><p>NF_IP_PRI_MANGLE (-150)</p></li><li><p>NF_IP_PRI_NAT_DST (-100)</p></li><li><p>NF_IP_PRI_FILTER (0)</p></li><li><p>NF_IP_PRI_SECURITY (50)</p></li><li><p>NF_IP_PRI_NAT_SRC (100)</p></li><li><p>NF_IP_PRI_SELINUX_LAST (225)</p></li><li><p>NF_IP_PRI_CONNTRACK_HELPER (300)</p></li></ul><p><strong>nftables 链对报文数据支持采取的动作</strong></p><ul><li><p>accept</p></li><li><p>drop</p></li><li><p>queue</p></li><li><p>continue</p></li><li><p>return</p></li></ul><p><strong>nftables 创建链的基本命令语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nft (add | create) chain [&lt;family&gt;] &lt;table&gt; &lt;name&gt; [ &#123; <span class="built_in">type</span> &lt;<span class="built_in">type</span>&gt; hook &lt;hook&gt; [device &lt;device&gt;] priority &lt;priority&gt; \; [policy &lt;policy&gt; \;] &#125; ]</span><br><span class="line">nft (delete | list | flush) chain [&lt;family&gt;] &lt;table&gt; &lt;name&gt;</span><br><span class="line">nft rename chain [&lt;family&gt;] &lt;table&gt; &lt;name&gt; &lt;newname&gt;</span><br></pre></td></tr></table></figure><p><strong>nftables 创建链的基本操作</strong></p><ol><li>创建链</li></ol><ul><li>创建一个常规链</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将名为 tcpchain 的常规链添加到 inet 簇中名为 mytable 的表中</span></span><br><span class="line">$ nft add chain inet mytable tcpchain</span><br></pre></td></tr></table></figure><ul><li>创建一个基本链</li></ul><p>添加一个基本链，你必需指定钩子和优先级。基本链的类型可以是 <code>filter</code>、<code>route</code> 或者 <code>nat</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一个筛选输入数据包的基本链</span></span><br><span class="line">$ nft add chain inet mytable input &#123; <span class="built_in">type</span> filter hook input priority 0\; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：命令中的反斜线 <code>（\）</code> 用来转义，这样 <code>Shell</code> 就不会将分号解释为命令的结尾。</p></blockquote><ol start="2"><li>列出规则</li></ol><p>列出一个链中的所有规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出 inet 筛中 filter 表的 input 链中的所有的规则</span></span><br><span class="line">$ nft list chain inet filter input</span><br></pre></td></tr></table></figure><ol start="3"><li>编辑链</li></ol><p>要编辑一个链，只需按名称调用并重新定义要更改的规则即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将默认表中的 input 链策略从 accept 更改为 drop</span></span><br><span class="line">$ nft chain inet mytable input &#123; policy drop \; &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>清空链中的规则</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空指定链中的规则，这里为 input</span></span><br><span class="line">$ nft flush chain inet mytable input</span><br></pre></td></tr></table></figure><ol start="5"><li>删除链</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定的链，这里为 input</span></span><br><span class="line">$ nft delete chain inet mytable input</span><br></pre></td></tr></table></figure><blockquote><p>注意：要删除的链中不能包含任何规则或者跳转目标。</p></blockquote><h3 id="nftables-的规则管理">nftables 的规则管理</h3><p><code>nftables</code> 规则由语句或表达式构成，包含在链中。以下为创建 <code>nftables</code> 规则的基本命令语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nft add rule [&lt;family&gt;] &lt;table&gt; &lt;chain&gt; &lt;matches&gt; &lt;statements&gt;</span><br><span class="line">nft insert rule [&lt;family&gt;] &lt;table&gt; &lt;chain&gt; [position &lt;position&gt;] &lt;matches&gt; &lt;statements&gt;</span><br><span class="line">nft replace rule [&lt;family&gt;] &lt;table&gt; &lt;chain&gt; [handle &lt;handle&gt;] &lt;matches&gt; &lt;statements&gt;</span><br><span class="line">nft delete rule [&lt;family&gt;] &lt;table&gt; &lt;chain&gt; [handle &lt;handle&gt;]</span><br></pre></td></tr></table></figure><p>其中 <code>matches</code> 是报文需要满足的条件。<code>matches</code> 的内容非常多，可以识别以下多种类型的报文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ip          :  ipv4 协议字段</span><br><span class="line">ip6         :  ipv6 协议字段</span><br><span class="line">tcp         :  tcp 协议字段</span><br><span class="line">udp         :  udp 协议字段</span><br><span class="line">udplite     :  udp-lite 协议</span><br><span class="line">sctp        :  sctp 协议 </span><br><span class="line">dccp</span><br><span class="line">ah</span><br><span class="line">esp</span><br><span class="line">comp</span><br><span class="line">icmp</span><br><span class="line">icmpv6</span><br><span class="line">ether       :  以太头</span><br><span class="line">dst</span><br><span class="line">frag        :</span><br><span class="line">hbh</span><br><span class="line">mh</span><br><span class="line">rt            </span><br><span class="line">vlan        :  vlan</span><br><span class="line">arp         :  arp协议</span><br><span class="line">ct          :  连接状态</span><br><span class="line">meta        :  报文的基本信息</span><br></pre></td></tr></table></figure><p>对每一种类型的报文，你又可以同时检查多个字段，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ip dscp cs1</span><br><span class="line">ip dscp != cs1</span><br><span class="line">ip dscp 0x38</span><br><span class="line">ip dscp != 0x20</span><br><span class="line">ip dscp &#123;cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, af11, af12, af13, af21, </span><br><span class="line">af22, af23, af31, af32, af33, af41, af42, af43, ef&#125;</span><br><span class="line"></span><br><span class="line">ip length 232</span><br><span class="line">ip length != 233</span><br><span class="line">ip length 333-435</span><br><span class="line">ip length != 333-453</span><br><span class="line">ip length &#123; 333, 553, 673, 838&#125;</span><br><span class="line"></span><br><span class="line">ip6 flowlabel 22</span><br><span class="line">ip6 flowlabel != 233</span><br><span class="line">ip6 flowlabel &#123; 33, 55, 67, 88 &#125;</span><br><span class="line">ip6 flowlabel &#123; 33-55 &#125;</span><br></pre></td></tr></table></figure><p>而 <code>statement</code> 是报文匹配规则时触发的操作，大致有以下几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Verdict statements :   动作</span><br><span class="line">Log                :   记录日志并继续处理请求</span><br><span class="line">Reject             :   停止处理并拒绝请求</span><br><span class="line">Counter            :   计数</span><br><span class="line">Limit              :   如果达到了接收数据包的匹配限制，则根据规则处理数据包</span><br><span class="line">Nat                :   NAT</span><br><span class="line">Queuea             :   停止处理并发送数据包到用户空间程序</span><br></pre></td></tr></table></figure><p>其中 <code>Verdict Statements</code> 是一组动作，大致有以下几种：</p><ul><li><p>accept：接受数据包并停止剩余规则评估。</p></li><li><p>drop：丢弃数据包并停止剩余规则评估。</p></li><li><p>queue：将数据包排队到用户空间并停止剩余规则评估。</p></li><li><p>continue：使用下一条规则继续进行规则评估。</p></li><li><p>return：从当前链返回并继续执行最后一条链的下一条规则。</p></li><li><p>jump <chain>：跳转到指定的规则链，当执行完成或者返回时，返回到调用的规则链。</chain></p></li><li><p>goto <chain>：类似于跳转，发送到指定规则链但不返回。</chain></p></li></ul><p>下面将以添加一条允许 <code>SSH</code> 登录的规则为例，给大家介绍下如何增加或插入一条新的规则。</p><ol><li>增加规则</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add rule inet mytable input tcp dport ssh accept</span><br></pre></td></tr></table></figure><p>默认情况下，<code>add</code> 表示将规则添加到链的末尾。如果你想从链的开头增加规则，可以使用 <code>insert</code> 来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft insert rule inet mytable input tcp dport http accept</span><br></pre></td></tr></table></figure><ol start="2"><li>列出规则</li></ol><ul><li>列出目前链中所有的规则</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ nft list ruleset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        chain input &#123;</span><br><span class="line">                <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">                tcp dport http accept</span><br><span class="line">                tcp dport ssh accept</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>列出某个表中的所有规则</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft list table inet mytable</span><br></pre></td></tr></table></figure><ul><li>列出某条链中的所有规则</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft list chain inet mytable input</span><br></pre></td></tr></table></figure><ol start="3"><li>按指定位置增加规则</li></ol><p>无论你是使用 <code>add</code> 或者 <code>insert</code> 来增加规则，你都可以通过 <code>index</code> 或者 <code>handle</code> 来指定添加的位置。</p><ul><li>使用 index 来指定规则的索引</li></ul><p><code>index</code> 类似于 <code>iptables</code> 的 <code>-I</code> 选项， <code>add</code> 表示新规则添加在索引位置的规则后面，<code>inser</code> 表示新规则添加在索引位置的规则前面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 input 链中已有规则中的第二条规则前插入一条新的规则</span></span><br><span class="line">$ nft insert rule inet mytable input index 1 tcp dport nfs accept</span><br><span class="line">$ nft list ruleset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">     chain input &#123;</span><br><span class="line">             <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">             tcp dport http accept</span><br><span class="line">             tcp dport nfs accept</span><br><span class="line">             tcp dport ssh accept</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 input 链中已有规则中的第一条规则后插入一条新的规则</span></span><br><span class="line">$ nft add rule inet mytable input index 0 tcp dport 1234 accept</span><br><span class="line">$ nft list ruleset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">     chain input &#123;</span><br><span class="line">             <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">             tcp dport http accept</span><br><span class="line">             tcp dport 1234 accept</span><br><span class="line">             tcp dport nfs accept</span><br><span class="line">             tcp dport ssh accept</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>index</code> 的值是从 <code>0</code> 开始的，<code>index</code> 必须指向一个已存在的规则的索引。</p></blockquote><ul><li>使用 handle 来指定规则的句柄</li></ul><p>通过 <code>handle</code> 的值来指定规则添加的位置，必须先知道现有规则的句柄位置。你可以通过参数 <code>--handle</code> 来获取当前规则的句柄位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ nft --handle list ruleset</span><br><span class="line">table inet mytable &#123; <span class="comment"># handle 10</span></span><br><span class="line">     chain input &#123; <span class="comment"># handle 2</span></span><br><span class="line">             <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">             tcp dport http accept <span class="comment"># handle 4</span></span><br><span class="line">             tcp dport 1234 accept <span class="comment"># handle 6</span></span><br><span class="line">             tcp dport nfs accept <span class="comment"># handle 5</span></span><br><span class="line">             tcp dport ssh accept <span class="comment"># handle 3</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到当前规则的句柄位置后，我们就可以在指定句柄位置添加规则。下面我们以在句柄位置 4 后面和句柄位置 5 前面分别增加一条新的规则为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ nft add rule inet mytable input handle 4 tcp dport 2345 accept</span><br><span class="line">$ nft insert rule inet mytable input handle 5 tcp dport 3456 accept</span><br><span class="line">$ nft --handle list ruleset</span><br><span class="line">table inet mytable &#123; <span class="comment"># handle 10</span></span><br><span class="line">     chain input &#123; <span class="comment"># handle 2</span></span><br><span class="line">             <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">             tcp dport http accept <span class="comment"># handle 4</span></span><br><span class="line">             tcp dport 2345 accept <span class="comment"># handle 8</span></span><br><span class="line">             tcp dport 1234 accept <span class="comment"># handle 6</span></span><br><span class="line">             tcp dport 3456 accept <span class="comment"># handle 9</span></span><br><span class="line">             tcp dport nfs accept <span class="comment"># handle 5</span></span><br><span class="line">             tcp dport ssh accept <span class="comment"># handle 3</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>nftables</code> 中，句柄值是固定不变的，除非规则被删除。而 <code>index</code> 的值是可变的，只要有新规则插入，就有可能发生变化。一般建议使用 <code>handle</code> 来插入新规则。</p><p>你也可以在创建规则时就获取到规则的句柄值，只需要在创建规则时同时加上参数 <code>--echo</code> 和 <code>--handle</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nft --<span class="built_in">echo</span> --handle add rule inet mytable input udp dport 3333 accept</span><br><span class="line">add rule inet mytable input udp dport 3333 accept <span class="comment"># handle 10</span></span><br></pre></td></tr></table></figure><ol start="4"><li>删除规则</li></ol><p>单个规则只能通过句柄值删除，每个规则的句柄值可通过 <code>nft --handle list ruleset</code> 命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定句柄值对应的规则</span></span><br><span class="line">$ nft delete rule inet mytable input handle 8</span><br></pre></td></tr></table></figure><blockquote><p>小技巧：你可以使用 <code>iptables-translate</code> 实用程序将 <code>iptables</code> 规则转换成 <code>nftables</code> 格式</p></blockquote><h2 id="nftables-高级功能进阶">nftables 高级功能进阶</h2><p><code>nftables</code> 除了上面的基础功能外，还给我们额外提供了一些非常实用且功能强大的高级功能。</p><h3 id="集合">集合</h3><p><code>nftables</code> 的语法原生支持集合，可以用来匹配多个 <code>IP</code> 地址、端口号、网卡或其他任何条件。<code>nftables</code> 的集合可分为匿名集合与命名集合，相对 <code>iptables</code> 来说，<code>nftables</code> 是原生支持集合，并不需要借助 <code>ipset</code> 来实现。</p><ol><li>匿名集合</li></ol><p>匿名集合比较适合用于将来不需要更改的规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许来自源 IP 处于 10.10.10.123 ~ 10.10.10.231 这个区间内的主机的流量。</span></span><br><span class="line">$ nft add rule inet mytable input ip saddr &#123; 10.10.10.123, 10.10.10.231 &#125; accept</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许指定协义的流量通过</span></span><br><span class="line">$ nft add rule inet mytable input tcp dport &#123; http, nfs, ssh &#125; accept</span><br></pre></td></tr></table></figure><p>匿名集合的缺点是需要修改集合规则时，就得替换原规则。如果需要频繁修改的集合，推荐使用命名集合。</p><ol start="2"><li>命名集合</li></ol><p><code>nftables</code> 的命名集合是可以修改的。创建命名集合时需要指定其元素的类型，当前支持的数据类型有：</p><ul><li><p><code>ipv4_addr</code> : <code>IPv4</code> 地址</p></li><li><p><code>ipv6_addr</code> : <code>IPv6</code> 地址</p></li><li><p><code>ether_addr</code> : 以太网（Ethernet）地址</p></li><li><p><code>inet_proto</code> : 网络协议</p></li><li><p><code>inet_service</code> : 网络服务</p></li><li><p><code>mark</code> : 标记类型</p></li></ul><p>这里，我们来看一个实例。首先，创建一个空的命名集合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空的命名集合</span></span><br><span class="line">$ nft add <span class="built_in">set</span> inet mytable myset &#123; <span class="built_in">type</span> ipv4_addr \; &#125;</span><br><span class="line">$ nft list sets</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        <span class="built_in">set</span> myset &#123;</span><br><span class="line">                <span class="built_in">type</span> ipv4_addr</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们向集合中添加一些元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ nft add element inet mytable myset &#123; 10.10.10.22, 10.10.10.33 &#125;</span><br><span class="line">$ nft list <span class="built_in">set</span> inet mytable myset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        <span class="built_in">set</span> myset &#123;</span><br><span class="line">                <span class="built_in">type</span> ipv4_addr</span><br><span class="line">                elements = &#123; 10.10.10.22, 10.10.10.33 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在添加规则时引用集合，你可以使用 <code>@</code> 符号跟上集合的名字来引用命名集合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将来源为集合 myset 中的 IP 地址的请求阻止掉</span></span><br><span class="line">$ nft insert rule inet mytable input ip saddr @myset drop</span><br><span class="line">$ nft list chain inet mytable input</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        chain input &#123;</span><br><span class="line">                <span class="built_in">type</span> filter hook input priority 0; policy accept;</span><br><span class="line">                ip saddr @my_set drop</span><br><span class="line">                tcp dport http accept</span><br><span class="line">                tcp dport nfs accept</span><br><span class="line">                tcp dport ssh accept</span><br><span class="line">                ip saddr &#123; 10.10.10.123, 10.10.10.231 &#125; accept</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>支持区间</li></ol><p>从上面的例子中，我们可以看到填加元素时是使用的两个独立的 <code>IP</code> 地址，并没有直接使用 <code>10.10.10.0-10.10.10.255</code> 这样的区间段来表示。这是因为直接使用区间段会报以下类似错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nft add element inet mytable myset &#123; 10.10.10.0-10.10.10.255 &#125;</span><br><span class="line"></span><br><span class="line">Error: Set member cannot be range, missing interval flag on declaration</span><br><span class="line">add element inet mytable my_set &#123; 10.10.10.0-10.10.10.255 &#125;</span><br><span class="line">                                   ^^^^^^^^^^^^^^^^^^^^^^^</span><br></pre></td></tr></table></figure><p>如果你想在集合中使用区间，需要加上一个 <code>flag interval</code>，因为内核必须提前确认该集合存储的数据类型，以便采用适当的数据结构。我们来看一个实例吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个支持区间的命名集合</span></span><br><span class="line">$ nft add <span class="built_in">set</span> inet mytable my_rangeset &#123; <span class="built_in">type</span> ipv4_addr \; flags interval</span><br><span class="line">$ nft add element inet mytable my_rangeset &#123; 10.10.10.0/24 &#125;</span><br><span class="line">$ nft list <span class="built_in">set</span> inet mytable my_rangeset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        <span class="built_in">set</span> my_rangeset &#123;</span><br><span class="line">                <span class="built_in">type</span> ipv4_addr</span><br><span class="line">                flags interval</span><br><span class="line">                elements = &#123; 10.10.10.0/24 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中直接使用了子网掩码来表示 <code>IP</code> 地址段，它会被隐式转换为 <code>IP</code> 地址的区间，你也可以直接使用区间 <code>10.10.10.0-10.10.10.255</code> 来获得相同的效果。</p><ol start="4"><li>级联不同类型</li></ol><p>命名集合不仅支持同一类型元素，也可以支持对不同类型的元素进行级联。例如，下面的规则可以一次性匹配 <code>IP</code> 地址、协议和端口号。</p><p>首先，我们创建一个级联类型的集合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nft add <span class="built_in">set</span> inet mytable my_concatset  &#123; <span class="built_in">type</span> ipv4_addr . inet_proto . inet_service \; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同类型的元素可以通过级联操作符 . 来分隔。</span></span><br><span class="line">$ nft list <span class="built_in">set</span> inet mytable my_concatset</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">        <span class="built_in">set</span> my_concatset &#123;</span><br><span class="line">                <span class="built_in">type</span> ipv4_addr . inet_proto . inet_service</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，向集合中添加元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add element inet mytable my_concatset &#123; 10.30.30.30 . tcp . telnet &#125;</span><br></pre></td></tr></table></figure><p>最后，我们在规则中对级联类型的集合进行引用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果数据包的源 IP、协议类型、目标端口匹配 10.30.30.30、tcp、telnet 时，就会允许该数据包通过</span></span><br><span class="line">$ nft add rule inet mytable input ip saddr . meta l4proto . tcp dport @my_concatset accept</span><br></pre></td></tr></table></figure><p>除了命名集合，匿名集合也是可以使用级联元素，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add rule inet mytable input ip saddr . meta l4proto . udp dport &#123; 10.30.30.30 . udp . bootps &#125; accept</span><br></pre></td></tr></table></figure><p>在规则中引用级联类型的集合和一般类型集合的主要不同之处：主要在于需要标明集合中每个元素对应到规则中的哪个位置，这类似于 ipset 的聚合类型，例如 <code>hash:ip,port</code> 。</p><h3 id="字典">字典</h3><p>字典是 <code>nftables</code> 的又一个高级特性，它同样可以支持在一条规则上面使用不同类型的数据。</p><p>首先，我们创建一个命名字典。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add map inet mytable my_vmap &#123; <span class="built_in">type</span> inet_proto : verdict \; &#125;</span><br></pre></td></tr></table></figure><p>接着，我们向字典中添加一些元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add element inet mytable my_vmap &#123; 192.168.0.10 : drop, 192.168.0.11 : accept &#125;</span><br></pre></td></tr></table></figure><p>最后，我们就可以在规则中引用字典中的元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft add rule inet mytable input ip saddr vmap @my_vmap</span><br></pre></td></tr></table></figure><p>和集合一样，除了命名字典，你也可以创建匿名字典。例如，为了从逻辑上对 <code>TCP</code> 和 <code>UDP</code> 的数据包拆分开来用两条不同链来处理，你就可以通过使用字典来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ nft add chain inet mytable my_tcpchain</span><br><span class="line">$ nft add chain inet mytable my_udpchain</span><br><span class="line">$ nft add rule inet mytable input meta l4proto vmap &#123; tcp : jump my_tcpchain, udp : jump my_udpchain &#125;</span><br><span class="line">$ nft list chain inet mytable input</span><br><span class="line">table inet mytable &#123;</span><br><span class="line">    chain input &#123;</span><br><span class="line">    ...</span><br><span class="line">    meta nfproto ipv4 ip saddr . meta l4proto . udp dport &#123; 10.30.30.30 . udp . bootps &#125; accept</span><br><span class="line">    meta l4proto vmap &#123; tcp : jump my_tcpchain, udp : jump my_udpchain &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表与命名空间">表与命名空间</h3><p>在 <code>nftables</code> 中，每个表都是一个独立的命名空间，这就意味着不同的表中的链、集合、字典等名字可以相同。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ nft add table inet table_one</span><br><span class="line">$ nft add chain inet table_one mychain</span><br><span class="line">$ nft add table inet table_two</span><br><span class="line">$ nft add chain inet table_two mychain</span><br><span class="line">$ nft list ruleset</span><br><span class="line">...</span><br><span class="line">table inet table_one &#123;</span><br><span class="line">    chain mychain &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">table inet table_two &#123;</span><br><span class="line">    chain mychain &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个特性后，不同的应用就可以在相互不影响的情况下管理自己的表中的规则。不过使用这个特性前，你需要注意的一点是：由于 <code>nftables</code> 将每个表都被视为独立的防火墙，一个数据包必须被所有表中的规则放行才能真正通过。如果，出现两条链的优先级相同，就会进入竞争状态。</p><p>当然，你可以使用 <code>nftables</code> 优先级特性来解决这个问题。优先级值越高的链优先级越低，所以优先级值低的链会比优先级值高的链先执行。</p><h3 id="备份与恢复">备份与恢复</h3><p>默认情况下，通过 <code>nftables</code> 用户态工具 <code>nft</code> 直接在终端中加入的规则都是临时的。如果要想永久生效，我们可以将规则备份后并在开机自动加载时进行恢复。</p><ol><li>备份规则</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft list ruleset &gt; /root/nftables.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>恢复规则</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nft -f /root/nftables.conf</span><br></pre></td></tr></table></figure><p>在 <code>CentOS 8</code> 中，<code>nftables</code> 是以 <code>Systemd</code> 服务形式进行工作的。<code>nftables.service</code> 的规则被存储在 <code>/etc/nftables.conf</code> 中，其中包含了一些其他的示例规则，一般会位于 <code>/etc/sysconfig/nftables.conf</code> 文件中。如果你想开机自加载 <code>nftables</code> 规则，只需将备份规则放到 <code>/etc/sysconfig/nftables.conf</code> 文件即可。</p><h2 id="总结">总结</h2><p>至此，本文对 <code>nftables</code> 的基本功能和用法就讲解完了，更高级的用法可以在以下文档中做进一步探索。</p><blockquote><ol><li><p>Archlinux Wiki：<a href="https://wiki.archlinux.org/index.php/Nftables" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Nftables</a></p></li><li><p>nftables HOWTO：<a href="https://farkasity.gitbooks.io/nftables-howto-zh/" target="_blank" rel="noopener">https://farkasity.gitbooks.io/nftables-howto-zh/</a></p></li><li><p>nftables Wiki：<a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page" target="_blank" rel="noopener">https://wiki.nftables.org/wiki-nftables/index.php/Main_Page</a></p></li></ol></blockquote><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://url.cn/56tJkD8" target="_blank" rel="noopener">https://url.cn/56tJkD8</a></p></li><li><p><a href="http://www.freecls.com/a/2712/fc" target="_blank" rel="noopener">http://www.freecls.com/a/2712/fc</a></p></li><li><p><a href="https://blog.51cto.com/babyshen/2065749" target="_blank" rel="noopener">https://blog.51cto.com/babyshen/2065749</a></p></li><li><p><a href="https://adoyle.me/Today-I-Learned/linux/iptables.html" target="_blank" rel="noopener">https://adoyle.me/Today-I-Learned/linux/iptables.html</a></p></li><li><p><a href="https://blog.csdn.net/dog250/article/details/54170683" target="_blank" rel="noopener">https://blog.csdn.net/dog250/article/details/54170683</a></p></li><li><p><a href="https://www.yangcs.net/posts/using-nftables/" target="_blank" rel="noopener">https://www.yangcs.net/posts/using-nftables/</a></p></li><li><p><a href="https://wiki.archlinux.org/index.php/Nftables" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Nftables</a></p></li><li><p><a href="https://farkasity.gitbooks.io/nftables-howto-zh/content/" target="_blank" rel="noopener">https://farkasity.gitbooks.io/nftables-howto-zh/content/</a></p></li><li><p><a href="https://blog.omicron3069.com/post/nftablesfornode/" target="_blank" rel="noopener">https://blog.omicron3069.com/post/nftablesfornode/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-nftables？&quot;&gt;什么是 nftables？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;nftables&lt;/code&gt; 是一个新式的数据包过滤框架，旨在替代现用的 &lt;code&gt;iptables&lt;/code&gt;、&lt;code&gt;ip6tables&lt;/code&gt;、&lt;code&gt;arptables&lt;/code&gt; 和 &lt;code&gt;ebtables&lt;/code&gt; 的新的包过滤框架。&lt;code&gt;nftables&lt;/code&gt; 诞生于 2008 年，2013 年底合并到 &lt;code&gt;Linux 内核&lt;/code&gt;，从 &lt;code&gt;Linux&lt;/code&gt; 内核 &lt;code&gt;3.13&lt;/code&gt; 版本开始大多数场景下 &lt;code&gt;nftables&lt;/code&gt; 已经可以使用，但是完整的支持（即：&lt;code&gt;nftables&lt;/code&gt; 优先级高于 &lt;code&gt;iptables&lt;/code&gt;）应该是在 Linux 内核 &lt;code&gt;3.15&lt;/code&gt; 版本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nftables&lt;/code&gt; 旨在解决现有 &lt;code&gt;{ip/ip6}tables&lt;/code&gt; 工具存在的诸多限制。相对于旧的 &lt;code&gt;iptables&lt;/code&gt;，&lt;code&gt;nftables&lt;/code&gt; 最引人注目的功能包括：改进性能、支持查询表、事务型规则更新、所有规则自动应用等等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nftables&lt;/code&gt; 主要由三个组件组成：内核实现、&lt;code&gt;libnl netlink&lt;/code&gt; 通信和 &lt;code&gt;nftables&lt;/code&gt; 用户空间。其中内核提供了一个 &lt;code&gt;netlink&lt;/code&gt; 配置接口以及运行时规则集评估，&lt;code&gt;libnl&lt;/code&gt; 包含了与内核通信的基本函数，用户空间可以通过新引入的命令行工具 &lt;code&gt;nft&lt;/code&gt; 和用户进行交互。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nft&lt;/code&gt; 可以通过在寄存器中储存和加载来交换数据。也就是说，它的语法与 &lt;code&gt;iptables&lt;/code&gt; 不同。但 &lt;code&gt;nft&lt;/code&gt; 可以利用内核提供的表达式去模拟旧的 &lt;code&gt;iptables&lt;/code&gt; 命令，维持兼容性的同时获得更大的灵活性。简单来说，&lt;code&gt;nft&lt;/code&gt; 是 &lt;code&gt;iptables&lt;/code&gt; 及其衍生指令（&lt;code&gt;ip6tables&lt;/code&gt; 和 &lt;code&gt;arptables&lt;/code&gt; ）的超集。&lt;/p&gt;
&lt;h3 id=&quot;nftables-的特点&quot;&gt;nftables 的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;nftables&lt;/code&gt; 拥有一些高级的类似编程语言的能力，例如：定义变量和包含外部文件，即拥有使用额外脚本的能力。&lt;code&gt;nftables&lt;/code&gt; 也可以用于多种地址簇的过滤和处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同于 &lt;code&gt;iptables&lt;/code&gt;, &lt;code&gt;nftables&lt;/code&gt; 并不包含任何的内置表，需要哪些表并在这些表中添加什么处理规则一切由管理员决定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表包含规则链，规则链包含规则。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;nftables-相较于-iptables-的优点&quot;&gt;nftables 相较于 iptables 的优点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;更新速度更快&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 &lt;code&gt;iptables&lt;/code&gt; 中添加一条规则，会随着规则数量增多而变得非常慢。这种状况对 &lt;code&gt;nftables&lt;/code&gt; 而言就不存在了，因为 &lt;code&gt;nftables&lt;/code&gt; 使用原子的快速操作来更新规则集合。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;内核更新更少。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;iptables&lt;/code&gt; 时，每一个匹配或投递都需要内核模块的支持。因此，如果你忘记一些东西或者要添加新的功能时都需要重新编译内核。而在 &lt;code&gt;nftables&lt;/code&gt; 中就不存在这种情况了， 因为在 &lt;code&gt;nftables&lt;/code&gt; 中，大部分工作是在用户态完成的，内核只知道一些基本指令（过滤是用伪状态机实现的）。例如，&lt;code&gt;icmpv6&lt;/code&gt; 支持是通过 &lt;code&gt;nft&lt;/code&gt; 工具的一个简单的补丁实现的，而在 &lt;code&gt;iptables&lt;/code&gt; 中这种类型的更改需要内核和 &lt;code&gt;iptables&lt;/code&gt; 都升级才可以。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="nftables" scheme="https://www.hi-linux.com/tags/nftables/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款 Go 语言多版本管理利器 GVM</title>
    <link href="https://www.hi-linux.com/posts/20165.html"/>
    <id>https://www.hi-linux.com/posts/20165.html</id>
    <published>2020-05-12T01:00:00.000Z</published>
    <updated>2020-05-12T05:06:03.211Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Golang</code> 发展迅速，代码迭代非常快，想要在同一环境调试和梳理不同项目进程就成了一件相对棘手的事情。二进制文件的管理比较简单，通过链接使用不同版本的程序即可。实际上主要是一些环境变量和标准库的设置问题，偶然间发现了 <code>GVM - Go Version Manager</code>，<code>GVM</code> 实际上就是帮助我们完成这些配置工作，这算是找到了调试切换版本的福音了。</p><h2 id="什么是-gvm">什么是 GVM</h2><p><code>Go</code> 语言版本管理器（<code>GVM</code>）是管理 <code>Go</code> 语言环境的开源工具。<code>GVM 「pkgsets」</code> 支持安装多个版本的 <code>Go</code> 并管理每个项目的模块。它最初由 <code>Josh Bussdieker</code> 开发，<code>GVM</code> 与 <code>Ruby RVM</code> 类似，允许你为每个项目或一组项目创建一个开发环境，分离不同的 <code>Go</code> 版本和包依赖关系，来提供更大的灵活性，以防不同版本造成的问题。<code>GVM</code> 主要有以下几个特性：</p><ul><li><p>管理 <code>Go</code> 的多个版本，包括安装、卸载和指定使用 <code>Go</code> 的某个版本</p></li><li><p>查看官方所有可用的 <code>Go</code> 版本，同时可以查看本地已安装和默认使用的 <code>Go</code> 版本</p></li><li><p>管理多个 <code>GOPATH</code>，并可编辑 <code>Go</code> 的环境变量</p></li><li><p>可将当前目录关联到 <code>GOPATH</code></p></li><li><p>可以查看 <code>GOROOT</code> 下的文件差异</p></li><li><p>支持 <code>Go</code> 版本切换</p></li></ul><blockquote><p>项目地址：<a href="https://github.com/moovweb/gvm" target="_blank" rel="noopener">https://github.com/moovweb/gvm</a></p></blockquote><a id="more"></a><h2 id="安装-gvm">安装 GVM</h2><p><code>GVM</code> 本质上就是一个 <code>SHELL</code> 脚本，它背后做的事情是先把源码下载下来，再用 <code>C</code> 做编译。所以，安装 <code>GVM</code> 前你需要先安装一些依赖包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debian/Ubuntu</span></span><br><span class="line">$ sudo apt-get install curl git mercurial make binutils bison gcc build-essential</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redhat/Centos</span></span><br><span class="line">$ sudo yum install curl</span><br><span class="line">$ sudo yum install git</span><br><span class="line">$ sudo yum install make</span><br><span class="line">$ sudo yum install bison</span><br><span class="line">$ sudo yum install gcc</span><br><span class="line">$ sudo yum install glibc-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS</span></span><br><span class="line">$ xcode-select --install</span><br><span class="line">$ brew update</span><br><span class="line">$ brew install mercurial</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>Centos</code> 官方仓库没有 <code>mercurial</code> 软件包，如果你需要可以在 <code>mercurial</code> 官网 <code>https://www.mercurial-scm.org/downloads</code> 下载后安装。</p></blockquote><p>安装好依赖环境后， <code>GVM</code> 的安装也很简单。官方提供了一键安装脚本，你只需直接运行就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</span><br></pre></td></tr></table></figure><p>如果你使用的是 <code>zsh</code> 的话将前面的 <code>bash</code> 改为 <code>zsh</code> 即可，这条命令主要是检查相关依赖环境并下载 <code>GVM</code> 相关的文件，然后创建所需目录，并且在 <code>.bashrc</code> 或者 <code>.zshrc</code> 中加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -s <span class="string">"/home/wcl/.gvm/scripts/gvm"</span> ]] &amp;&amp; <span class="built_in">source</span> <span class="string">"/home/wcl/.gvm/scripts/gvm"</span></span><br></pre></td></tr></table></figure><p>使每次登录 <code>Shell</code> 时都可以自动生效。</p><h2 id="使用-gvm-安装和管理-go-版本">使用 GVM 安装和管理 Go 版本</h2><p>一旦安装了 <code>GVM</code>，就可以开始使用它来安装和管理不同版本的 <code>Go</code>。首先，你可以用 <code>gvm listall</code> 命令显示可以下载和编译可用的 <code>Go</code> 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gvm listall</span><br><span class="line"></span><br><span class="line">gvm gos (available)</span><br><span class="line"></span><br><span class="line">   go1</span><br><span class="line">   go1.0.1</span><br><span class="line">   go1.0.2</span><br><span class="line">   go1.0.3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>安装特定的 <code>Go</code> 版本只需运行 <code>gvm install &lt;version&gt;</code>命令，其中 <code>&lt;version&gt;</code> 是表示要安装的版本。假设你正在处理一个使用 <code>Go 1.12.8</code> 版本的项目，你就可以使用 <code>gvm install go1.12.8</code> 命令来安装这个版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gvm install go1.12.8</span><br><span class="line">Installing go1.12.8...</span><br><span class="line"> * Compiling...</span><br><span class="line">go1.12.8 successfully installed!</span><br></pre></td></tr></table></figure><p>安装完成后，输入 <code>gvm list</code> 命令后，你会看到 <code>Go 1.12.8</code> 版本与系统自带的 <code>Go</code> 版本（使用操作系统的软件包管理器打包的版本）都同时存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gvm list</span><br><span class="line">gvm gos (installed)</span><br><span class="line">   go1.12.8</span><br><span class="line">=&gt; system</span><br></pre></td></tr></table></figure><p>不过，这时 <code>GVM</code> 仍然默认使用系统的 <code>Go</code> 版本，通过它旁边的 <code>=&gt;</code> 符号来表示。你可以使用 <code>gvm use</code> 命令来切换到新安装的 <code>go 1.12.8</code> 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gvm use go1.12.8</span><br><span class="line">Now using version go1.12.8</span><br><span class="line">$ go version</span><br><span class="line">go version go1.12.8 linux/amd64</span><br></pre></td></tr></table></figure><p>如果不想每次敲 <code>gvm use</code> 指令来切换版本，你可以加上 <code>--default</code> 参数来指定默认使用这个版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gvm use go1.12.8 --default</span><br></pre></td></tr></table></figure><p>是不是，很容易呢！<code>GVM</code> 使管理已安装的 <code>Go</code> 版本变得极其简单，但它不止如此！</p><blockquote><p>由于 <code>Go 1.5</code> 使用了自举（用 <code>Go</code> 编译 <code>Go</code>），如果在系统环境完全没有 <code>Go</code> 命令的情况下，直接使用 <code>gvm install go</code> 会报错。所以，你必须先安装 <code>Go 1.4</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装 1.4 版本的，-B 表示只安装二进制包。</span></span><br><span class="line">$ gvm install go1.4 -B  </span><br><span class="line">$ gvm use go1.4  </span><br><span class="line">$ <span class="built_in">export</span> GOROOT_BOOTSTRAP=<span class="variable">$GOROOT</span>  </span><br><span class="line"><span class="comment"># 再安装 1.5+ 版本的</span></span><br><span class="line">$ gvm install go1.12.8</span><br></pre></td></tr></table></figure><h2 id="使用-gvm-pkgset">使用 GVM pkgset</h2><p>默认情况下，如果你通过 <code>go get</code> 获取一个包，它会被下载到 <code>$GOPATH</code> 目录中的 <code>src</code> 和 <code>pkg</code> 目录下。然后你可以使用 <code>import</code> 将其引入到你的 <code>Go</code> 程序中。然而，在不同的项目中管理相同包的不同版本就会变得困难。</p><p><code>GVM</code> 通过使用「<code>pkgsets</code>」将项目的新目录附加到 <code>Go</code> 安装版本的默认 <code>$GOPATH</code>，类似 <code>Linux</code> 系统上的 <code>$PATH</code>，这样就可以很好地完成了项目之间包的管理和隔离。我们来看一个实例，安装一个新版本的 <code>Go 1.12.9</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$GOPATH</span></span><br><span class="line">/home/chris/.gvm/pkgsets/go1.12.8/global</span><br><span class="line">$ gvm install go1.12.9</span><br><span class="line">Installing go1.12.9...</span><br><span class="line"> * Compiling...</span><br><span class="line">go1.12.9 successfully installed</span><br><span class="line">$ gvm use go1.12.9</span><br><span class="line">Now using version go1.12.9</span><br></pre></td></tr></table></figure><p>当 <code>GVM</code> 被告知使用一个新版本时，它将会更换一个新的 <code>$GOPATH</code>，<code>gloabl pkgset</code> 将默认使用该版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$GOPATH</span></span><br><span class="line">/home/chris/.gvm/pkgsets/go1.12.9/global</span><br><span class="line">$ gvm pkgset list</span><br><span class="line">gvm go package sets (go1.12.9)</span><br><span class="line">=&gt;  global</span><br></pre></td></tr></table></figure><blockquote><p>尽管默认情况下没有安装额外的包，但是 <code>global pkgset</code> 中的包对于使用这个特定版本 <code>Go</code> 的任何项目都是可用的。</p></blockquote><p>现在，假设你正在启动一个新项目，它需要一个特定的包。首先，使用 <code>GVM</code> 创建一个名为 <code>introToGvm</code> 的新的 <code>pkgset</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gvm pkgset create introToGvm</span><br><span class="line">$ gvm pkgset use introToGvm</span><br><span class="line">Now using version go1.12.9@introToGvm</span><br><span class="line">$ gvm pkgset list</span><br><span class="line">gvm go package sets (go1.12.9)</span><br><span class="line">    global</span><br><span class="line">=&gt;  introToGvm</span><br></pre></td></tr></table></figure><p>如上所述，一个与 <code>pkgset</code> 同名的新目录 <code>introToGvm</code> 被添加到 <code>$GOPATH</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$GOPATH</span></span><br><span class="line">/home/chris/.gvm/pkgsets/go1.12.9/introToGvm:/home/chris/.gvm/pkgsets/go1.12.9/global</span><br></pre></td></tr></table></figure><p>接下来，验证下新目录 <code>introToGvm</code> 中的目录结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> $( awk -F<span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span> &lt;&lt;&lt; <span class="variable">$GOPATH</span> )</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/chris/.gvm/pkgsets/go1.12.9/introToGvm</span><br><span class="line">$ ls</span><br><span class="line">overlay  pkg  src</span><br></pre></td></tr></table></figure><blockquote><p>注意：新目录看起来很像普通的 <code>$GOPATH</code>，新的 <code>Go</code> 包会被  <code>Go get</code> 命令下载并且被添加到 <code>pkgset</code> 中。</p></blockquote><p>最后，使用以下命令获取一个 <code>gorilla/mux</code> 包，然后检查 <code>pkgset</code> 下的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/gorilla/mux</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── overlay</span><br><span class="line">│   ├── bin</span><br><span class="line">│   └── lib</span><br><span class="line">│       └── pkgconfig</span><br><span class="line">├── pkg</span><br><span class="line">│   └── linux_amd64</span><br><span class="line">│       └── github.com</span><br><span class="line">│           └── gorilla</span><br><span class="line">│               └── mux.a</span><br><span class="line">src/</span><br><span class="line">└── github.com</span><br><span class="line">    └── gorilla</span><br><span class="line">        └── mux</span><br><span class="line">            ├── AUTHORS</span><br><span class="line">            ├── bench_test.go</span><br><span class="line">            ├── context.go</span><br><span class="line">            ├── context_test.go</span><br><span class="line">            ├── doc.go</span><br><span class="line">            ├── example_authentication_middleware_test.go</span><br><span class="line">            ├── example_cors_method_middleware_test.go</span><br><span class="line">            ├── example_route_test.go</span><br><span class="line">            ├── go.mod</span><br><span class="line">            ├── LICENSE</span><br><span class="line">            ├── middleware.go</span><br><span class="line">            ├── middleware_test.go</span><br><span class="line">            ├── mux.go</span><br><span class="line">            ├── mux_test.go</span><br><span class="line">            ├── old_test.go</span><br><span class="line">            ├── README.md</span><br><span class="line">            ├── regexp.go</span><br><span class="line">            ├── route.go</span><br><span class="line">            └── test_helpers.go</span><br></pre></td></tr></table></figure><p>如上所示，<code>gorilla/mux</code> 按照预期添加到了 <code>pkgset</code> 的 <code>$GOPATH</code> 目录，现在你就可以与使用该 <code>pkgset</code> 的项目一起使用该模块了。</p><h2 id="卸载-gvm-或指定版本-go-语言">卸载 GVM 或指定版本 Go 语言</h2><ol><li>如果你只是想卸载某个安装好的 <code>Go</code> 版本，可以使用以下指令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gvm uninstall go1.12.8</span><br></pre></td></tr></table></figure><ol start="2"><li>如果你想完全卸载掉 GVM 和 所有安装的 Go 版本，可以使用以下指令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需谨慎操作</span></span><br><span class="line">$ gvm implode</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p><code>GVM</code> 是以一种直观的、非侵入性的方式来管理 <code>Go</code> 版本和包的工具。它可以单独使用，也可以使用 <code>GVM</code> 的 <code>Go</code> 版本管理功能与其他 <code>Go</code> 模块管理技术结合使用。<code>GVM</code> 通过对 <code>Go</code> 版本和包依赖关系的隔离使项目开发更加容易，并减少了管理版本冲突的复杂性。</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://bingohuang.com/go-gvm/" target="_blank" rel="noopener">https://bingohuang.com/go-gvm/</a></p></li><li><p><a href="https://learnku.com/articles/35269" target="_blank" rel="noopener">https://learnku.com/articles/35269</a></p></li><li><p><a href="https://dryyun.com/2018/11/28/how-to-use-gvm/" target="_blank" rel="noopener">https://dryyun.com/2018/11/28/how-to-use-gvm/</a></p></li><li><p><a href="https://laucyun.com/ff3bc3db699464aa76756e41be780712.html" target="_blank" rel="noopener">https://laucyun.com/ff3bc3db699464aa76756e41be780712.html</a></p></li><li><p><a href="https://opensource.com/article/19/10/go-introduction-gvm" target="_blank" rel="noopener">https://opensource.com/article/19/10/go-introduction-gvm</a></p></li><li><p><a href="http://blog.fatedier.com/2016/07/25/use-different-go-version-by-gvm/" target="_blank" rel="noopener">http://blog.fatedier.com/2016/07/25/use-different-go-version-by-gvm/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Golang&lt;/code&gt; 发展迅速，代码迭代非常快，想要在同一环境调试和梳理不同项目进程就成了一件相对棘手的事情。二进制文件的管理比较简单，通过链接使用不同版本的程序即可。实际上主要是一些环境变量和标准库的设置问题，偶然间发现了 &lt;code&gt;GVM - Go Version Manager&lt;/code&gt;，&lt;code&gt;GVM&lt;/code&gt; 实际上就是帮助我们完成这些配置工作，这算是找到了调试切换版本的福音了。&lt;/p&gt;
&lt;h2 id=&quot;什么是-GVM&quot;&gt;什么是 GVM&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 语言版本管理器（&lt;code&gt;GVM&lt;/code&gt;）是管理 &lt;code&gt;Go&lt;/code&gt; 语言环境的开源工具。&lt;code&gt;GVM 「pkgsets」&lt;/code&gt; 支持安装多个版本的 &lt;code&gt;Go&lt;/code&gt; 并管理每个项目的模块。它最初由 &lt;code&gt;Josh Bussdieker&lt;/code&gt; 开发，&lt;code&gt;GVM&lt;/code&gt; 与 &lt;code&gt;Ruby RVM&lt;/code&gt; 类似，允许你为每个项目或一组项目创建一个开发环境，分离不同的 &lt;code&gt;Go&lt;/code&gt; 版本和包依赖关系，来提供更大的灵活性，以防不同版本造成的问题。&lt;code&gt;GVM&lt;/code&gt; 主要有以下几个特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;管理 &lt;code&gt;Go&lt;/code&gt; 的多个版本，包括安装、卸载和指定使用 &lt;code&gt;Go&lt;/code&gt; 的某个版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看官方所有可用的 &lt;code&gt;Go&lt;/code&gt; 版本，同时可以查看本地已安装和默认使用的 &lt;code&gt;Go&lt;/code&gt; 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;管理多个 &lt;code&gt;GOPATH&lt;/code&gt;，并可编辑 &lt;code&gt;Go&lt;/code&gt; 的环境变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可将当前目录关联到 &lt;code&gt;GOPATH&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以查看 &lt;code&gt;GOROOT&lt;/code&gt; 下的文件差异&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 &lt;code&gt;Go&lt;/code&gt; 版本切换&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/moovweb/gvm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/moovweb/gvm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Go" scheme="https://www.hi-linux.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>再见 XShell 和 ITerm 2，是时候拥抱全平台高颜值终端工具 Hyper 了</title>
    <link href="https://www.hi-linux.com/posts/44812.html"/>
    <id>https://www.hi-linux.com/posts/44812.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-13T05:15:00.352Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>不论是 <code>macOS</code> 还是 <code>Windows</code> 下，我们都不推荐使用系统自带终端。无论是可拓展性还是可编程性都被「系统自带」这样的特点限制。特别是 <code>Windows</code> 下的万恶之源「小黑框」，在 9012 年真的是不太好用哟！</p><p>今天我们将给大家介绍一款基于 <code>Electron</code> 的全平台高颜值的终端工具 <code>Hyper</code>。<code>Hyper</code> 支持丰富的主题和插件功能，通过强大的插件系统提供了非常丰富的自定义选项，可谓是颜值和易用并存的神器。</p><blockquote><p>官网地址：<a href="https://hyper.is" target="_blank" rel="noopener">https://hyper.is</a></p></blockquote><p>下面先放一张配置好的预览效果图，让大家先睹为快。</p><p><img src="https://img.fythonfang.com/MacScreenShot%202018-07-20-5-35-35.png" alt=""></p><p>由于 <code>Hyper</code> 是基于 <code>Electron</code> 的，所以它的插件、主题等等可拓展性都非常强大。几行简单的 <code>Javascript</code>、<code>HTML</code>、 <code>CSS</code> 代码，你就可以定制自己的插件。</p><blockquote><p><code>Electron</code> 是一个利用最新 <code>Web</code> 技术栈搭建跨平台应用的项目，比如: <code>GitHub</code> 出品的代码编辑器 <code>Atom</code> 和微软出品的 <code>VSCode</code> 都是基于 <code>Electron</code> 的。</p></blockquote><h2 id="安装-hyper">安装 Hyper</h2><p><code>Hyper</code> 的安装非常简单，只需要在官网下载对应平台二进制安装包后，直接安装就可以运行。</p><p><img src="https://cdn.sspai.com/editor/u_735639/media/15651037049805/15651047302326.jpg" alt=""></p><p>如果你是 <code>macOS</code> 平台，你还可以通过 <code>Homebrew</code> 命令来快速完成安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install hyper</span><br></pre></td></tr></table></figure><p>如果你还不知道 <code>Homebrew</code> 如何安装和使用可以参考 ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247484646&amp;idx=1&amp;sn=f73feedee278c03c6c2d138154f822fb&amp;chksm=eac525cfddb2acd964c163f6020cc1c385abc8f0680cc6086881a8093b73511db31c34e3e3fc&amp;token=985021721&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「macOS 不可或缺的套件管理器——Homebrew」</a> 和  ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247484672&amp;idx=1&amp;sn=55dc5a5b3283fe618124684d9b683a17&amp;chksm=eac52429ddb2ad3fba77229c3ffbe4c3e3cf7b6477fbc08a43232e0c67bdc367be3a293f04d5&amp;token=985021721&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「macOS小技巧 —— 如何用 Homebrew 安装指定版本软件」</a> 两篇文章先了解下。</p><a id="more"></a><h2 id="hyper-主题安装">Hyper 主题安装</h2><p><code>Hyper</code> 做为一个高颜值终端工具，自然就少不了对主题的支持。官方首页推荐了 4 种不同颜色的主题，你可以在官方主题地址 <code>https://hyper.is/themes</code> 直接查看并安装。</p><p><img src="https://www.hi-linux.com/img/linux/hyper-theme.jpg" alt=""></p><p>当然，如果上面官方推荐的主题满足不了你，你也可以去在上面的主题地址中的 <code>NEWEST</code> 页签找到更多主题，或者是去 <code>GitHub</code> 搜索更多好看的主题。</p><h2 id="善用-hyper-插件">善用 Hyper 插件</h2><p><code>Hyper</code> 本身是支持插件系统的，在安装扩展插件前，你需要先安装 <code>Hyper</code> 命令行程序。你可以点击菜单，选择 <code>Plugin</code> 选项，然后点击 <code>Install Hyper CLI command in PATH</code>。</p><p><code>Hyper</code> 命令行程序安装完成后，<code>Hyper</code> 插件安装就十分简单了，只需要打开 <code>Hyper</code> 之后一行代码就可以搞定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i verminal</span><br></pre></td></tr></table></figure><p>这样就安装了 <code>verminal</code> 这个插件。</p><p><code>Hyper</code> 官方也在首页给大家推荐了 4 个比较易用的插件，推荐大家全部都安装试试。</p><h3 id="1-hypercwd">1. hypercwd</h3><p><img src="https://raw.githubusercontent.com/hharnisc/hypercwd/master/newTabs.gif" alt=""></p><p>它可以让你的终端在新建标签页时，保持上一个终端的目录地址。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hypercwd</span><br></pre></td></tr></table></figure><h3 id="2-hyper-search">2. hyper-search</h3><p><img src="https://www.hi-linux.com/img/linux/hyper-search.jpg" alt=""></p><p>它可以让你搜索整个终端的所有文本内容。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hyper-search</span><br></pre></td></tr></table></figure><h3 id="3-hyper-pane">3. hyper-pane</h3><p><img src="https://hyper-plugin-screenshots.now.sh/hyper-pane.gif" alt=""></p><p>该插件用来增强窗口导航，对于支持多个页签的软件来说这是个利器。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hyper-pane</span><br></pre></td></tr></table></figure><h3 id="4-hyperpower">4. hyperpower</h3><p><img src="https://cloud.githubusercontent.com/assets/13041/16820268/13c9bfe6-4905-11e6-8fe4-baf8fc8d9293.gif" alt=""></p><p>这是一个让你的终端变得更加绚丽的插件，类似于 <code>Atom</code> 里面的一个叫做 <code>activate-power-mode</code> 的插件。当然这么炫酷的效果是不是会影响你的工作呢，还是要视个人情而定。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hyperpower</span><br></pre></td></tr></table></figure><p>如果你需要更多的插件和主题，你可以在官方网站以下地址中找到。</p><blockquote><ol><li><p><code>Hyper</code> 的官方主题地址：<a href="https://hyper.is/themes" target="_blank" rel="noopener">https://hyper.is/themes</a></p></li><li><p><code>Hyper</code> 的官方插件地址：<a href="https://hyper.is/plugins" target="_blank" rel="noopener">https://hyper.is/plugins</a></p></li></ol></blockquote><p>除了，官方提供的主题和插件。目前还有一个社区驱动的 <code>awesome-hyper</code> 项目，里面有着更多开源的 <code>Hyper</code> 终端插件、主题等等。如果你对不同的主题和插件有兴趣，可以去这个项目里进行探索哟！</p><blockquote><ol><li>项目地址：<a href="https://github.com/bnb/awesome-hyper" target="_blank" rel="noopener">https://github.com/bnb/awesome-hyper</a></li></ol></blockquote><h2 id="整合-zsh">整合 ZSH</h2><p>通常 <code>Linux</code> 服务器上面默认使用的 <code>SHELL</code> 是 <code>Bash</code>。其实除了 <code>Bash</code> 之外，还有很多其他的 <code>SHELL</code> 程序，比如：<code>ZSH</code>、<code>CSH</code>、<code>Fish</code> 等等。</p><p>这里我们将介绍的 <code>ZSH</code> 是我认为在类 <code>Unix</code> 系统下最优雅的 <code>Shell</code> 程序 。虽然 <code>ZSH</code> 设置复杂，但得益于开源社区，我们可以使用  <code>Oh-My-ZSH</code> 这个神器来很方便的管理和配置 <code>ZSH</code>。</p><h3 id="安装-zsh-和-oh-my-zsh">安装 ZSH 和 Oh-My-ZSH</h3><p>在使用 <code>Oh-My-ZSH</code> 之前，你需要先安装 <code>ZSH</code>。各个平台安装的方式可能不一样，这里就只简单说下比较常用的 <code>Centos</code> 和 <code>Ubuntu</code> 系统下的安装方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redhat / Centos</span></span><br><span class="line">$ yum install zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debian / Ubuntu</span></span><br><span class="line">$ apt-get install zsh</span><br></pre></td></tr></table></figure><p>更多平台的安装方法，你可以通过 ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483784&amp;idx=1&amp;sn=60aa4c40e12b0d64bf373d5606f8e2e9&amp;chksm=eac520a1ddb2a9b70ce515e9ee6f290842ef2276d0b52f620f05280b8e30f7f3c7591802ca5f&amp;token=1853415346&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「利用 Oh-My-Zsh 打造你的超级终端」</a> 这篇文章了解。</p><p>安装好 <code>ZSH</code>  后，就可以安装 <code>Oh-My-ZSH</code> 了。<code>Oh-My-ZSH</code> 的安装也是非常简单的，你只需要用下面两条指令中的任意一条就可完成安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 curl 安装</span></span><br><span class="line">$ sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 wget 安装</span></span><br><span class="line">$ sh -c <span class="string">"<span class="variable">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure><p>安装完成后，你就会发现你的终端 <code>SHELL</code> 变成了 <code>ZSH</code>。你还可以通过命令 <code>chsh -s /bin/zsh</code> 将 <code>ZSH</code> 设置为默认的 <code>Shell</code>。</p><h3 id="配置主题">配置主题</h3><p><code>Oh-My-ZSH</code> 默认也附带了大量好看的主题，你可以利用它们对终端界面做进一步增强和美化。<code>Oh-My-ZSH</code> 默认的主题存放在 <code>~/.oh-my-zsh/themes</code> 目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ls ~/.oh-my-zsh/themes</span><br><span class="line"></span><br><span class="line">3den.zsh-theme                essembeh.zsh-theme            junkfood.zsh-theme            rgm.zsh-theme</span><br><span class="line">Soliah.zsh-theme              evan.zsh-theme                kafeitu.zsh-theme             risto.zsh-theme</span><br><span class="line">adben.zsh-theme               example.zsh-theme             kardan.zsh-theme              rixius.zsh-theme</span><br><span class="line">af-magic.zsh-theme            fino-time.zsh-theme           kennethreitz.zsh-theme        rkj-repos.zsh-theme</span><br><span class="line">afowler.zsh-theme             fino.zsh-theme                kiwi.zsh-theme                rkj.zsh-theme</span><br><span class="line">agnoster.zsh-theme            fishy.zsh-theme               kolo.zsh-theme                robbyrussell.zsh-theme</span><br><span class="line">alanpeabody.zsh-theme         flazz.zsh-theme               kphoen.zsh-theme              sammy.zsh-theme</span><br><span class="line">amuse.zsh-theme               fletcherm.zsh-theme           lambda.zsh-theme              simonoff.zsh-theme</span><br><span class="line">apple.zsh-theme               fox.zsh-theme                 linuxonly.zsh-theme           simple.zsh-theme</span><br><span class="line">arrow.zsh-theme               frisk.zsh-theme               lukerandall.zsh-theme         skaro.zsh-theme</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>对于主题的启用，你只需编辑 <code>ZSH</code> 配置文件 <code>~/.zshrc</code>。并在 <code>ZSH_THEME</code> 项中直接修改主题名称为要启用的主题名称即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME&#x3D;&quot;agnoster&quot;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你安装的主题无法显示预期效果，那是因为响应的主题的系统字体没有安装。这时，你需要正确的安装了 <code>Powerline</code> 字体才会显示出来。</p><ol><li><p><code>Powerline</code> 项目地址：<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a></p></li><li><p><code>Powerline</code> 安装教程：<a href="https://powerline.readthedocs.io/en/latest/installation.html#fonts-installation" target="_blank" rel="noopener">https://powerline.readthedocs.io/en/latest/installation.html#fonts-installation</a></p></li></ol></blockquote><p>如果这些默认主题还不能满足你的需要，你还可以到下面这些地址中找到更多的 <code>ZSH</code> 主题。</p><blockquote><ol><li><p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a></p></li><li><p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes</a></p></li><li><p><a href="https://github.com/unixorn/awesome-zsh-plugins#themes" target="_blank" rel="noopener">https://github.com/unixorn/awesome-zsh-plugins#themes</a></p></li></ol></blockquote><h3 id="配置插件">配置插件</h3><p><code>Oh-My-ZSH</code> 之所以强大，其中一个原因就是支持诸多功能强大的插件，<code>Oh-My-ZSH</code> 默认自带的插件都存放在 <code>~/.oh-my-zsh/plugins</code> 目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ls ~/.oh-my-zsh/plugins</span><br><span class="line"></span><br><span class="line">adb               brew         coffee             dirpersist      fastfile         gitignore                 httpie     last-working-dir  nanoc                  pod         rebar       sprunge        terminitor  vault              zeus</span><br><span class="line">ant               brew-cask    colemak            django          fbterm           git-prompt                iwhois     lein              nmap                   postgres    redis-cli   ssh-agent      terraform   vim-interaction    zsh-navigation-tools</span><br><span class="line">apache2-macports  bundler      colored-man-pages  dnf             fedora           git-remote-branch         jake-node  lighthouse        node                   pow         repo        stack          textastic   vi-mode            zsh_reload</span><br><span class="line">archlinux         bwana        colorize           docker          forklift         glassfish                 jhbuild    lol               npm                    powder      rsync       sublime        textmate    virtualenv</span><br><span class="line">asdf              cabal        <span class="built_in">command</span>-not-found  docker-compose  frontend-search  gnu-utils                 jira       macports          nvm                    powify      ruby        sudo           thefuck     virtualenvwrapper</span><br><span class="line">autoenv           cake         common-aliases     emacs           gas              go                        jruby      man               nyan                   profiles    rvm         supervisor     themes      vundle</span><br><span class="line">autojump          cakephp3     compleat           ember-cli       geeknote         golang                    jsontools  marked2           osx                    pyenv       safe-paste  suse           thor        wakeonlan</span><br><span class="line">autopep8          capistrano   composer           emoji           gem              gpg-agent                 jump       mercurial         pass                   pylint      sbt         svn            tmux        wd</span><br><span class="line">aws               cask         copydir            emoji-clock     git              gradle                    kate       meteor            paver                  python      scala       svn-fast-info  tmux-cssh   web-search</span><br><span class="line">battery           catimg       copyfile           emotty          git-extras       grails                    kitchen    mix               pep8                   rails       scd         symfony        tmuxinator  wp-cli</span><br><span class="line">bbedit            celery       cp                 encode64        gitfast          grunt                     knife      mix-fast          per-directory-history  rake        screen      symfony2       torrent     xcode</span><br><span class="line">bgnotify          chruby       cpanm              extract         git-flow         gulp                      knife_ssh  mosh              perl                   rake-fast   scw         systemadmin    tugboat     yii</span><br><span class="line">boot2docker       chucknorris  debian             fabric          git-flow-avh     heroku                    laravel    mvn               phing                  rand-quote  sfffe       systemd        ubuntu      yii2</span><br><span class="line">bower             cloudapp     dircycle           fancy-ctrl-z    github           <span class="built_in">history</span>                   laravel4   mysql-macports    pip                    rbenv       singlechar  taskwarrior    urltools    yum</span><br><span class="line">branch            codeclimate  dirhistory         fasd            git-hubflow      <span class="built_in">history</span>-substring-search  laravel5   n98-magerun       pj                     rbfu        spring      terminalapp    vagrant     z</span><br></pre></td></tr></table></figure><p>默认情况下，<code>Oh-My-ZSH</code> 只启用 <code>Git</code> 插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 插件可以十分清晰的显示出当前代码仓库里与远程仓库是否同步，以及最新同步日期等等信息。</span></span><br><span class="line">plugins=(git)</span><br></pre></td></tr></table></figure><p>如果你需启用更多插件，只需加入要启用插件的名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=(git wd web-search <span class="built_in">history</span> <span class="built_in">history</span>-substring-search)</span><br></pre></td></tr></table></figure><p>除默认自带的插件外，你还可以在 <code>GitHub</code> 上找到更多好用的 <code>ZSH</code> 三方插件，这里推荐几个比较好用三方插件。</p><blockquote><ol><li>zsh-history-substring-search</li></ol><p>项目地址：<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/history-substring-search" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/history-substring-search</a></p><ol start="2"><li>zsh-syntax-highlighting</li></ol><p>项目地址：<a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-syntax-highlighting</a></p><ol start="3"><li>zsh-autosuggestions</li></ol><p>项目地址：<a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-autosuggestions</a></p></blockquote><p>如果你想更多了解 <code>ZSH</code> 和 <code>Oh-My-ZSH</code>，可以通过 ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483784&amp;idx=1&amp;sn=60aa4c40e12b0d64bf373d5606f8e2e9&amp;chksm=eac520a1ddb2a9b70ce515e9ee6f290842ef2276d0b52f620f05280b8e30f7f3c7591802ca5f&amp;token=1853415346&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「利用 Oh-My-Zsh 打造你的超级终端」</a> 和  ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247488164&amp;idx=1&amp;sn=4a0d6635638148684d893aa0b45b0946&amp;chksm=eac5338dddb2ba9bd8e071a5aba95697a0f7b4891087a5740cc1f0297382f9035ac9fc7895ac&amp;token=1853415346&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「让你提前体验 macOS Catalina 的 Shell — Oh My Zsh 配置指南」</a> 这两篇文章进一步探索。</p><h2 id="集成-wsl">集成 WSL</h2><p>通常在使用 <code>WSL (Windows Subsystem for Linux)</code> 工作时，我们希望启动终端时就进入 <code>WSL</code> 的 <code>SHELL</code> 内部。但默认情况下我们需要在启动终端并输入 <code>bash</code> 命令后才能进入 <code>WSL</code> 终端。</p><p>很显然有此一步操作后，我们会觉得太繁琐了。有了 <code>Hyper</code> 后，我们只需要改动一下配置文件，上面这步就可以直接省略。</p><p>现在，你只需打开 <code>Hyper</code> 设置页面文件，从菜单 <code>Edit -&gt; Preferences</code> 进入，然后编辑 <code>shell</code> 和 <code>shellArgs</code> 参数即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell: <span class="string">'C:\\Windows\\System32\\bash.exe'</span>,</span><br><span class="line">shellArgs: [],</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aHlvbmctY24tZmlsZS5vc3MtY24tc2hhbmdoYWkuYWxpeXVuY3MuY29tLzIwMTgxMi8yMDE4LTEyLTE1XzE3LTI0LTQzLnBuZw" alt=""></p><p>修改完成后，再次重新打开 <code>Hyper</code>，你会发现默认已经进入了 <code>Bash</code> 终端界面了。</p><h2 id="总结">总结</h2><p>本文讲述了如何安装和使用 <code>Hyper</code> 这个高颜值跨平台的终端软件，其中包括配置 <code>Hyper</code> 插件和主题。并讲述了如何使用 <code>ZSH</code> 来代替 <code>Bash</code> 让你的终端更加强大易用的方法。都看到这里了，你还在等什么呢？是时候放弃你的 <code>Xshell</code> 和 <code>iTerm 2</code> 吧！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://sspai.com/post/56081" target="_blank" rel="noopener">https://sspai.com/post/56081</a></p></li><li><p><a href="https://sspai.com/post/45332" target="_blank" rel="noopener">https://sspai.com/post/45332</a></p></li><li><p><a href="https://archive.spencerwoo.com/posts/2018/06/17/terminal.html" target="_blank" rel="noopener">https://archive.spencerwoo.com/posts/2018/06/17/terminal.html</a></p></li><li><p><a href="https://www.fythonfang.com/blog/post/24" target="_blank" rel="noopener">https://www.fythonfang.com/blog/post/24</a></p></li><li><p><a href="https://github.com/sindresorhus/hyper-snazzy" target="_blank" rel="noopener">https://github.com/sindresorhus/hyper-snazzy</a></p></li><li><p><a href="https://www.veinin.com/2018/11/30/hyper-windows-tutorial/" target="_blank" rel="noopener">https://www.veinin.com/2018/11/30/hyper-windows-tutorial/</a></p></li><li><p><a href="https://blog.csdn.net/was172/article/details/85016495" target="_blank" rel="noopener">https://blog.csdn.net/was172/article/details/85016495</a></p></li><li><p><a href="https://github.com/sindresorhus/pure" target="_blank" rel="noopener">https://github.com/sindresorhus/pure</a></p></li><li><p><a href="https://www.fythonfang.com/blog/post/24" target="_blank" rel="noopener">https://www.fythonfang.com/blog/post/24</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不论是 &lt;code&gt;macOS&lt;/code&gt; 还是 &lt;code&gt;Windows&lt;/code&gt; 下，我们都不推荐使用系统自带终端。无论是可拓展性还是可编程性都被「系统自带」这样的特点限制。特别是 &lt;code&gt;Windows&lt;/code&gt; 下的万恶之源「小黑框」，在 9012 年真的是不太好用哟！&lt;/p&gt;
&lt;p&gt;今天我们将给大家介绍一款基于 &lt;code&gt;Electron&lt;/code&gt; 的全平台高颜值的终端工具 &lt;code&gt;Hyper&lt;/code&gt;。&lt;code&gt;Hyper&lt;/code&gt; 支持丰富的主题和插件功能，通过强大的插件系统提供了非常丰富的自定义选项，可谓是颜值和易用并存的神器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://hyper.is&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hyper.is&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面先放一张配置好的预览效果图，让大家先睹为快。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.fythonfang.com/MacScreenShot%202018-07-20-5-35-35.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;Hyper&lt;/code&gt; 是基于 &lt;code&gt;Electron&lt;/code&gt; 的，所以它的插件、主题等等可拓展性都非常强大。几行简单的 &lt;code&gt;Javascript&lt;/code&gt;、&lt;code&gt;HTML&lt;/code&gt;、 &lt;code&gt;CSS&lt;/code&gt; 代码，你就可以定制自己的插件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Electron&lt;/code&gt; 是一个利用最新 &lt;code&gt;Web&lt;/code&gt; 技术栈搭建跨平台应用的项目，比如: &lt;code&gt;GitHub&lt;/code&gt; 出品的代码编辑器 &lt;code&gt;Atom&lt;/code&gt; 和微软出品的 &lt;code&gt;VSCode&lt;/code&gt; 都是基于 &lt;code&gt;Electron&lt;/code&gt; 的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装-Hyper&quot;&gt;安装 Hyper&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Hyper&lt;/code&gt; 的安装非常简单，只需要在官网下载对应平台二进制安装包后，直接安装就可以运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/editor/u_735639/media/15651037049805/15651047302326.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你是 &lt;code&gt;macOS&lt;/code&gt; 平台，你还可以通过 &lt;code&gt;Homebrew&lt;/code&gt; 命令来快速完成安装。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew cask install hyper&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你还不知道 &lt;code&gt;Homebrew&lt;/code&gt; 如何安装和使用可以参考 ​&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247484646&amp;amp;idx=1&amp;amp;sn=f73feedee278c03c6c2d138154f822fb&amp;amp;chksm=eac525cfddb2acd964c163f6020cc1c385abc8f0680cc6086881a8093b73511db31c34e3e3fc&amp;amp;token=985021721&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「macOS 不可或缺的套件管理器——Homebrew」&lt;/a&gt; 和  ​&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247484672&amp;amp;idx=1&amp;amp;sn=55dc5a5b3283fe618124684d9b683a17&amp;amp;chksm=eac52429ddb2ad3fba77229c3ffbe4c3e3cf7b6477fbc08a43232e0c67bdc367be3a293f04d5&amp;amp;token=985021721&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「macOS小技巧 —— 如何用 Homebrew 安装指定版本软件」&lt;/a&gt; 两篇文章先了解下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>分享一个快速获取 Nginx 客户端公网 IP 的神技</title>
    <link href="https://www.hi-linux.com/posts/4701.html"/>
    <id>https://www.hi-linux.com/posts/4701.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-11T04:51:39.272Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将给大家介绍一个 <code>Nginx</code> 的小技巧，可以在不使用任何编程语言的情况下，直接返回客户端公网 <code>IP</code> 地址。</p><p>实现方法非常的简单，你只要在 <code>Nginx</code> 中配置以下内容就可以解决问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;ip &#123;</span><br><span class="line">    default_type text&#x2F;plain;</span><br><span class="line">    return 200 $remote_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>curl</code> 命令测试一下，我们从响应结果可以看到只显示了客户端的 <code>IP</code> 地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl https:&#x2F;&#x2F;example.com&#x2F;ip</span><br><span class="line">2001:1b48:103::189</span><br></pre></td></tr></table></figure><blockquote><p><code>default_type text/plain</code> 指令除了阻止 <code>Web</code> 浏览器尝试将响应下载为文件外，并没有使用任何实用程序。即，<code>Web</code> 浏览器可以直接显示 <code>IP</code> 地址。</p></blockquote><a id="more"></a><p>如果你想将以上结果以 <code>JSON</code> 格式输出，只需做一点小修改即可实现。具体方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;json_ip &#123;</span><br><span class="line">    default_type application&#x2F;json;</span><br><span class="line">    return 200 &quot;&#123;\&quot;ip\&quot;:\&quot;$remote_addr\&quot;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，响应的就是一个漂亮的 <code>JSON</code> 格式的输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s https:&#x2F;&#x2F;example.com&#x2F;json_ip | jq</span><br><span class="line">&#123;</span><br><span class="line">    &quot;ip&quot;: &quot;2001:1b48:103::189&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，快速通过 <code>Nginx</code> 获取客户端公网 <code>IP</code> 地址的小技巧就演示完了。希望这个 <code>Nginx</code> 的小技巧可以为你节省一些维护时间。</p><blockquote><p>本文翻译至：<a href="https://url.cn/5Th0D1e%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82" target="_blank" rel="noopener">https://url.cn/5Th0D1e，版权归原作者所有。</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将给大家介绍一个 &lt;code&gt;Nginx&lt;/code&gt; 的小技巧，可以在不使用任何编程语言的情况下，直接返回客户端公网 &lt;code&gt;IP&lt;/code&gt; 地址。&lt;/p&gt;
&lt;p&gt;实现方法非常的简单，你只要在 &lt;code&gt;Nginx&lt;/code&gt; 中配置以下内容就可以解决问题。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;location &amp;#x2F;ip &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default_type text&amp;#x2F;plain;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 200 $remote_addr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用 &lt;code&gt;curl&lt;/code&gt; 命令测试一下，我们从响应结果可以看到只显示了客户端的 &lt;code&gt;IP&lt;/code&gt; 地址。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ curl https:&amp;#x2F;&amp;#x2F;example.com&amp;#x2F;ip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2001:1b48:103::189&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;default_type text/plain&lt;/code&gt; 指令除了阻止 &lt;code&gt;Web&lt;/code&gt; 浏览器尝试将响应下载为文件外，并没有使用任何实用程序。即，&lt;code&gt;Web&lt;/code&gt; 浏览器可以直接显示 &lt;code&gt;IP&lt;/code&gt; 地址。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="https://www.hi-linux.com/categories/nginx/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款史上最强跨平台、多端加密同步神器 Restic</title>
    <link href="https://www.hi-linux.com/posts/42308.html"/>
    <id>https://www.hi-linux.com/posts/42308.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-11T04:51:39.273Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-restic">什么是 Restic</h2><p><code>Restic</code> 是一款 GO 语言开发的开源免费且快速、高效和安全的跨平台备份工具。<code>Restic</code> 使用加密技术来保证你的数据安全性和完整性，可以将本地数据加密后传输到指定的存储。</p><p><code>Restic</code> 同样支持增量备份，可随时备份和恢复备份。<code>Restic</code> 支持大多数主流操作系统，比如：<code>Linux</code>、<code>macOS</code>、<code>Windows</code> 以及一些较小众的操作系统 <code>FreeBSD</code> 和 <code>OpenBSD</code> 等。</p><blockquote><p>项目地址：<a href="https://github.com/restic/restic" target="_blank" rel="noopener">https://github.com/restic/restic</a></p></blockquote><p><strong>Restic 支持的存储类型</strong></p><p><code>Restic</code> 支持的存储种类比较多，大致有如下这些类型：</p><ul><li><p>本地存储</p></li><li><p>SFTP</p></li><li><p>REST Server</p></li><li><p>Amazon S3</p></li><li><p>Minio Server</p></li><li><p>OpenStack Swift</p></li><li><p>Backblaze B2</p></li><li><p>Microsoft Azure Blob Storage</p></li><li><p>Google Cloud Storage</p></li><li><p>通过 Rclone 挂载的存储 (比如：Google Drive、OneDrive 等)</p></li></ul><p><strong>Restic 与 Rclone 的区别</strong></p><p><code>Restic</code> 与 <code>Rclone</code> 都是开源的命令行文件备份（同步）工具，但却有着很本质的区别。</p><ol><li>两者的相同点</li></ol><ul><li><p>两者都是基于命令行的开源文件同步和备份工具。</p></li><li><p>两者都支持将文件备份到本地、远程服务器或对象存储。</p></li></ul><ol start="2"><li>两者不同点</li></ol><ul><li><p>Rclone 面向的是文件同步，即保证两端文件的一致，也可以增量备份。</p></li><li><p>Restic 面向的是文件备份和加密，文件先加密再传输备份，而且是增量备份，即每次只备份变化的部分。</p></li><li><p>Rclone 仓库配置保存在本地，备份的文件会保持原样的同步于存储仓库中。</p></li><li><p>Restic 配置信息直接写在仓库，只要有仓库密码，在任何安装了 Restic 的计算机上都可以操作仓库。</p></li><li><p>Rclone 不记录文件版本，无法根据某一次备份找回特定时间点上的文件。</p></li><li><p>Restic 每次备份都会生成一个快照，记录当前时间点的文件结构，可以找回特定时间点的文件。</p></li><li><p>Rclone 可以在配置的多个存储端之间传输文件。</p></li></ul><p>总的来说，<code>Rclone</code> 和 <code>Restic</code> 各有所长，要根据不同的业务需求选择使用。比如：网站数据的增量备份，用 <code>Resitc</code> 就比较合适。而常规文件的远程备份归档，用 <code>Rclone</code> 就很合适。</p><a id="more"></a><h2 id="安装-restic">安装 Restic</h2><p><code>Restic</code> 可以通过系统软件包安装，也可以直接下载最新的二进制包方式进行安装。</p><ol><li>通过软件包安装</li></ol><ul><li>Debian &amp; Ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install restic</span><br></pre></td></tr></table></figure><ul><li>RHEL &amp; CentOS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install yum-plugin-copr</span><br><span class="line">$ yum copr enable copart&#x2F;restic</span><br><span class="line">$ yum install restic</span><br></pre></td></tr></table></figure><ul><li>Fedora</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dnf install restic</span><br></pre></td></tr></table></figure><ul><li>Arch Linux</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pacman -S restic</span><br></pre></td></tr></table></figure><ul><li>macOS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install restic</span><br></pre></td></tr></table></figure><p>更多平台的软件包安装方法可参见官方文档：<a href="https://restic.readthedocs.io/en/stable/020_installation.html" target="_blank" rel="noopener">https://restic.readthedocs.io/en/stable/020_installation.html</a></p><ol start="2"><li>通过二进制版本安装</li></ol><p>通过预编译好的二进制版本进行安装，非常的简单。只要根据自己所需的平台选择对应的版本下载即可，这里以 <code>Linux</code> 系统为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 下载指定版本的安装包</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;restic&#x2F;restic&#x2F;releases&#x2F;download&#x2F;v0.9.5&#x2F;restic_0.9.5_linux_amd64.bz2</span><br><span class="line"></span><br><span class="line"># 解压并删除压缩包</span><br><span class="line">$ bzip2 -d restic*.bz2 &amp;&amp; rm -rf restic*.bz2</span><br><span class="line"></span><br><span class="line"># 增加执行权限</span><br><span class="line">$ chmod +x restic*</span><br><span class="line"></span><br><span class="line"># 移动二进制文件到指定目录</span><br><span class="line">$ mv restic* &#x2F;usr&#x2F;local&#x2F;bin&#x2F;restic</span><br><span class="line"></span><br><span class="line"># 验证所安装的版本</span><br><span class="line">$ restic version</span><br></pre></td></tr></table></figure><p>如果以后需要更新到最新版本，只需运行以下命令就可完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接升级二进制文件到最新版本</span><br><span class="line">$ restic self-update</span><br></pre></td></tr></table></figure><ol start="3"><li>Restic 常用语法命令</li></ol><p><code>Restic</code> 支持的命令和参数比较多，你可以使用 <code>--help</code> 参数来查看它们的基本用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">$ restic --help</span><br><span class="line">restic is a backup program which allows saving multiple revisions of files and</span><br><span class="line">directories in an encrypted repository stored on different backends.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  restic [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  backup        Create a new backup of files and&#x2F;or directories</span><br><span class="line">  cache         Operate on local cache directories</span><br><span class="line">  cat           Print internal objects to stdout</span><br><span class="line">  check         Check the repository for errors</span><br><span class="line">  diff          Show differences between two snapshots</span><br><span class="line">  dump          Print a backed-up file to stdout</span><br><span class="line">  find          Find a file or directory</span><br><span class="line">  forget        Remove snapshots from the repository</span><br><span class="line">  generate      Generate manual pages and auto-completion files (bash, zsh)</span><br><span class="line">  help          Help about any command</span><br><span class="line">  init          Initialize a new repository</span><br><span class="line">  key           Manage keys (passwords)</span><br><span class="line">  list          List objects in the repository</span><br><span class="line">  ls            List files in a snapshot</span><br><span class="line">  migrate       Apply migrations</span><br><span class="line">  mount         Mount the repository</span><br><span class="line">  prune         Remove unneeded data from the repository</span><br><span class="line">  rebuild-index Build a new index file</span><br><span class="line">  restore       Extract the data from a snapshot</span><br><span class="line">  snapshots     List all snapshots</span><br><span class="line">  stats         Count up sizes and show information about repository data</span><br><span class="line">  tag           Modify tags on snapshots</span><br><span class="line">  unlock        Remove locks other processes created</span><br><span class="line">  version       Print version information</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --cacert file              file to load root certificates from (default: use system certificates)</span><br><span class="line">      --cache-dir string         set the cache directory. (default: use system default cache directory)</span><br><span class="line">      --cleanup-cache            auto remove old cache directories</span><br><span class="line">  -h, --help                     help for restic</span><br><span class="line">      --json                     set output mode to JSON for commands that support it</span><br><span class="line">      --key-hint string          key ID of key to try decrypting first (default: $RESTIC_KEY_HINT)</span><br><span class="line">      --limit-download int       limits downloads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --limit-upload int         limits uploads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --no-cache                 do not use a local cache</span><br><span class="line">      --no-lock                  do not lock the repo, this allows some operations on read-only repos</span><br><span class="line">  -o, --option key&#x3D;value         set extended option (key&#x3D;value, can be specified multiple times)</span><br><span class="line">  -p, --password-file string     read the repository password from a file (default: $RESTIC_PASSWORD_FILE)</span><br><span class="line">  -q, --quiet                    do not output comprehensive progress report</span><br><span class="line">  -r, --repo string              repository to backup to or restore from (default: $RESTIC_REPOSITORY)</span><br><span class="line">      --tls-client-cert string   path to a file containing PEM encoded TLS client certificate and private key</span><br><span class="line">  -v, --verbose n[&#x3D;-1]           be verbose (specify --verbose multiple times or level n)</span><br><span class="line"></span><br><span class="line">Use &quot;restic [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><p>与 <code>Git</code> 等程序类似 <code>Restic</code> 有许多子命令，每个子命令都有自己的命令行选项。如果你要列出每个子命令的帮助选项，可以使用类似下面的命令语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 以备份子命令为例</span><br><span class="line">$ restic backup --help</span><br><span class="line">The &quot;backup&quot; command creates a new snapshot and saves the files and directories</span><br><span class="line">given as the arguments.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  restic backup [flags] FILE&#x2F;DIR [FILE&#x2F;DIR] ...</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -e, --exclude pattern                  exclude a pattern (can be specified multiple times)</span><br><span class="line">      --exclude-caches                   excludes cache directories that are marked with a CACHEDIR.TAG file. See http:&#x2F;&#x2F;bford.info&#x2F;cachedir&#x2F;spec.html for the Cache Directory Tagging Standard</span><br><span class="line">      --exclude-file file                read exclude patterns from a file (can be specified multiple times)</span><br><span class="line">      --exclude-if-present stringArray   takes filename[:header], exclude contents of directories containing filename (except filename itself) if header of that file is as provided (can be specified multiple times)</span><br><span class="line">      --files-from string                read the files to backup from file (can be combined with file args&#x2F;can be specified multiple times)</span><br><span class="line">  -f, --force                            force re-reading the target files&#x2F;directories (overrides the &quot;parent&quot; flag)</span><br><span class="line">  -h, --help                             help for backup</span><br><span class="line">      --hostname hostname                set the hostname for the snapshot manually. To prevent an expensive rescan use the &quot;parent&quot; flag</span><br><span class="line">  -x, --one-file-system                  exclude other file systems</span><br><span class="line">      --parent string                    use this parent snapshot (default: last snapshot in the repo that has the same target files&#x2F;directories)</span><br><span class="line">      --stdin                            read backup from stdin</span><br><span class="line">      --stdin-filename string            file name to use when reading from stdin (default &quot;stdin&quot;)</span><br><span class="line">      --tag tag                          add a tag for the new snapshot (can be specified multiple times)</span><br><span class="line">      --time string                      time of the backup (ex. &#39;2012-11-01 22:08:41&#39;) (default: now)</span><br><span class="line">      --with-atime                       store the atime for all files and directories</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">      --cacert file              file to load root certificates from (default: use system certificates)</span><br><span class="line">      --cache-dir string         set the cache directory. (default: use system default cache directory)</span><br><span class="line">      --cleanup-cache            auto remove old cache directories</span><br><span class="line">      --json                     set output mode to JSON for commands that support it</span><br><span class="line">      --key-hint string          key ID of key to try decrypting first (default: $RESTIC_KEY_HINT)</span><br><span class="line">      --limit-download int       limits downloads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --limit-upload int         limits uploads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --no-cache                 do not use a local cache</span><br><span class="line">      --no-lock                  do not lock the repo, this allows some operations on read-only repos</span><br><span class="line">  -o, --option key&#x3D;value         set extended option (key&#x3D;value, can be specified multiple times)</span><br><span class="line">  -p, --password-file string     read the repository password from a file (default: $RESTIC_PASSWORD_FILE)</span><br><span class="line">  -q, --quiet                    do not output comprehensive progress report</span><br><span class="line">  -r, --repo string              repository to backup to or restore from (default: $RESTIC_REPOSITORY)</span><br><span class="line">      --tls-client-cert string   path to a file containing PEM encoded TLS client certificate and private key</span><br><span class="line">  -v, --verbose n[&#x3D;-1]           be verbose (specify --verbose multiple times or level n)</span><br></pre></td></tr></table></figure><h2 id="配置-restic-支持的存储方式">配置 Restic 支持的存储方式</h2><p>安装好 <code>Restic</code> 后，我们需要配置下存储方式。也就是你想备份数据到本地，还是其它远程服务上。</p><p>本文将主要讲讲最常用的本地、SFTP 两种备份方式，其它远程库配置方法可参考官方文档：<a href="https://restic.readthedocs.io/en/stable/030_preparing_a_new_repo.html" target="_blank" rel="noopener">https://restic.readthedocs.io/en/stable/030_preparing_a_new_repo.html</a> 。</p><ol><li>配置本地存储仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 备份到本地 &#x2F;home&#x2F;mike&#x2F;backup 文件夹</span><br><span class="line">$ restic init --repo &#x2F;home&#x2F;mike&#x2F;backup</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 SFTP 方式的存储仓库</li></ol><p>该方法适合将文件备份到另一台服务器上。首先，我们需要在两台服务器间配置免密码登录。</p><blockquote><p>注意：以下将需要备份的服务器称为 A，备份服务器称为 B。</p></blockquote><p>2.1 配置 SSH 免密码登录</p><p>这部分内容比较基础，就不在这里展开了。如果你不会配置可以参考以下两篇文章：</p><ul><li><p>「CentOS 下配置 SSH 免密码登录」：<a href="https://zhuanlan.zhihu.com/p/45025702" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45025702</a></p></li><li><p>「SSH 和 ssh-copy-id 以及批量多机无密码登陆详解」: <a href="https://www.cnblogs.com/operationhome/p/9166583.html" target="_blank" rel="noopener">https://www.cnblogs.com/operationhome/p/9166583.html</a></p></li></ul><p>2.2 在服务器 A 上进行数据备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># root 为服务器 B 的用户名，192.168.1.100 为 B 服务器 IP，端口默认为 22，&#x2F;home&#x2F;mike&#x2F;backup 为服务器 B 上的目录，如果不存在则会自动创建。</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup init</span><br></pre></td></tr></table></figure><p>如果服务器 B 的 <code>SSH</code> 默认端口不是 22，你就需要简单调整下 A 服务器上的 <code>SSH</code> 配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在服务器 A 中 ~&#x2F;.ssh 目录创建一个 config 文件，并新增如下内容。</span><br><span class="line"># 分别是 B 服务器的 IP、用户名和 SSH 的端口。</span><br><span class="line">$ vim ~&#x2F;.ssh&#x2F;config</span><br><span class="line">Host 192.168.1.100</span><br><span class="line">    User root</span><br><span class="line">    Port 2000</span><br></pre></td></tr></table></figure><p>由于上面配置了默认的 B 服务器的用户名和密码，现在就可以直接只写 B 服务器的 IP 就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup init</span><br></pre></td></tr></table></figure><blockquote><p>注意：以上配置过程中都会要求你输入密码，切记不要遗忘。</p></blockquote><h2 id="使用-restic-备份数据">使用 Restic 备份数据</h2><p>经过上面的步骤，我们已经完成了备份存储的初始化。现在我就来看几个 <code>Restic</code> 备份的例子。</p><p>以下我们所有演示的例子均是将 A 服务器上 <code>/var/www/</code> 目录下的文件备份到 B 服务器上的 <code>/home/mike/backup</code> 目录下。</p><h3 id="创建备份快照">创建备份快照</h3><p>以下命令是备份的 <code>/var/www</code> 整个目录，如果只需备份目录中单个文件，比如：<code>/var/www/mike.zip</code>，那备份内容就可以改成 <code>/var/www/mike.zip</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 本地备份</span><br><span class="line">$ restic -r &#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www</span><br><span class="line"></span><br><span class="line"># SFTP 备份</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www</span><br></pre></td></tr></table></figure><p>如果你不想备份目录下全部的内容，你还可以用以下参数排除或包含指定的备份目录或者文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--include 指定一次或多次以包含一个或者多个目录或文件</span><br><span class="line">--exclude 指定一次或多次以排除一个或多个目录或文件</span><br><span class="line">--exclude-caches 指定一次以排除包含特殊文件的目录</span><br><span class="line">--exclude-file 指定一次或多次以排除给定文件中列出的项目</span><br><span class="line">--exclude-if-present 如果目录内容包含给定文件，则指定一次或多次排除目录的内容</span><br></pre></td></tr></table></figure><p>具体用法可以参考官方文档: <a href="https://restic.readthedocs.io/en/stable/040_backup.html#including-and-excluding-files" target="_blank" rel="noopener">https://restic.readthedocs.io/en/stable/040_backup.html#including-and-excluding-files</a></p><p><code>Restic</code> 还支持直接将命令的输出进行重定向，比如：将备份好的数据库文件直接通过 <code>SFTP</code> 方式备份到另一台服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将 Wordpress 数据库备份到另一台服务器，并命名为 Wordpress_Backup.sql</span><br><span class="line">$ mysqldump -uroot -ppasswd 000000 --databases Wordpress | restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup backup --stdin --stdin-filename Wordpress_Backup.sql</span><br></pre></td></tr></table></figure><h3 id="列出备份快照">列出备份快照</h3><p>备份完成后，可以使用以下命令查看备份的快照信息。您可以看到我们在第一次备份期间的快照 ID，拍摄快照的时间戳，主机名，标签以及备份的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有备份快照</span><br><span class="line"></span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup snapshots</span><br><span class="line">ID        Time                 Host        Tags              Paths</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">ef5ff5fe  2019-08-25 17:03:57  Mike-Dev01                          &#x2F;home&#x2F;mike&#x2F;backup</span><br><span class="line">9f0bc19e  2019-08-26 17:18:57  Mike-Dev02                          &#x2F;home&#x2F;devops&#x2F;backup</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 只查看 &#x2F;home&#x2F;mike&#x2F;backup 目录的备份快照</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup snapshots --path&#x3D;&quot;&#x2F;home&#x2F;mike&#x2F;backup&quot;</span><br><span class="line">ID        Time                 Host        Tags              Paths</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">ef5ff5fe  2019-08-25 17:03:57  Mike-Dev01                          &#x2F;home&#x2F;mike&#x2F;backup</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 只查看主机名为 Mike-Dev01 的备份快照</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup snapshots --host Mike-Dev01</span><br><span class="line">ID        Time                 Host        Tags              Paths</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">ef5ff5fe  2019-08-25 17:03:57  Mike-Dev01                          &#x2F;home&#x2F;mike&#x2F;backup</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 列出某个快照中所包含的文件</span><br><span class="line">$ restic ls ef5ff5fe</span><br><span class="line">snapshot ef5ff5fe of [&#x2F;home&#x2F;mike&#x2F;backup] at 2019-08-25 20:35:39.450146467 +0800 CST):</span><br><span class="line">&#x2F;backup</span><br><span class="line">&#x2F;backup&#x2F;2019-04-19_2004334933.jpg</span><br><span class="line">&#x2F;backup&#x2F;2019-04-13_15-00-15.png</span><br><span class="line">&#x2F;backup&#x2F;2019-04-16_15-19-39.png</span><br><span class="line">&#x2F;backup&#x2F;2019-04-16_15-20-22.png</span><br><span class="line">&#x2F;backup&#x2F;2019-04-18_17-11-52.png</span><br></pre></td></tr></table></figure><p>从上面的结果，我们可以看到 <code>Tags</code> 列是空的。这是因为备份时没有使用 <code>--tag</code> 参数，下面我们演示下 <code>--tag</code> 参数的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 给备份文件指定标签</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www --tag site</span><br></pre></td></tr></table></figure><p>如果你想加入更多标签来更详细的区分备份，那就在后面多加几个 <code>--tag</code> 参数。</p><h3 id="恢复备份快照">恢复备份快照</h3><p>这里以 <code>SFTP</code> 存储仓库为例，我们将远程存储目录 <code>/home/mike/backup</code> 的备份文件恢复到本地 <code>/var/wwww</code> 文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># restore 后面指定为要恢复备份的 ID</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup restore ef5ff5fe --target &#x2F;var&#x2F;wwww</span><br><span class="line"></span><br><span class="line"># 你也可以直接使用 latest 来恢复最后一次的备份文件</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup restore latest --target &#x2F;var&#x2F;wwww</span><br></pre></td></tr></table></figure><h3 id="删除备份快照">删除备份快照</h3><p>如果你不在再要一些备份快照，你可以直接使用下面的命令删除指定的备份快照。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ef5ff5fe 为要删除文件的 ID</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup forget ef5ff5fe</span><br></pre></td></tr></table></figure><p>不过上面的命令只是将快照记录清除了，但快照中包含的文件数据仍存储在存储库中。如果要彻底清除未引用的数据，你必须运行 <code>prune</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup prune</span><br><span class="line">enter password for repository:</span><br><span class="line"></span><br><span class="line">counting files in repo</span><br><span class="line">building new index for repo</span><br><span class="line">[0:00] 100.00%  22 &#x2F; 22 files</span><br><span class="line">repository contains 22 packs (8512 blobs) with 100.092 MiB bytes</span><br><span class="line">processed 8512 blobs: 0 duplicate blobs, 0B duplicate</span><br><span class="line">load all snapshots</span><br><span class="line">find data that is still in use for 1 snapshots</span><br><span class="line">[0:00] 100.00%  1 &#x2F; 1 snapshots</span><br><span class="line">found 8433 of 8512 data blobs still in use</span><br><span class="line">will rewrite 3 packs</span><br><span class="line">creating new index</span><br><span class="line">[0:00] 86.36%  19 &#x2F; 22 files</span><br><span class="line">saved new index as 544a5084</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>清理完成后，存储库的空间就会释放出来。当然你也可以直接使用 <code>--prune</code> 参数来将上面两步合成为一步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ef5ff5fe 为要删除文件的 ID</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup forget ef5ff5fe --prune</span><br></pre></td></tr></table></figure><h2 id="使用-restic-进行自动备份">使用 Restic 进行自动备份</h2><ol><li>免密码操作存储仓库</li></ol><p>上面的备份中我们都手工输入了密码，如果需要定期备份当然是通过一个脚本来实现是最方便，但是在使用脚本备份时如果要显示输入访问存储仓库的密码肯定不适用的。这里我们就需要使用 <code>--password-file</code> 参数来达到自动读取密码的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将密码保存在 &#x2F;home&#x2F;mike&#x2F;resticpasswd 文本中</span><br><span class="line">$ echo &#39;000000&#39; &gt; &#x2F;home&#x2F;mike&#x2F;resticpasswd</span><br><span class="line"></span><br><span class="line"># 在备份命令中使用 --password-file 参数来读取文本中的密码</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www --password-file &#x2F;home&#x2F;mike&#x2F;resticpasswd</span><br></pre></td></tr></table></figure><p>除了使用 <code>--password-file</code> 参数指定密码外，你也可以使用环境变量来指定一些 <code>Restic</code> 所需的参数。例如，使用腾讯云的对象存储就可以使用下面这些环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export TencentCloud_ACCESS_KEY_ID&#x3D;&quot;your-access-key&quot;</span><br><span class="line">export TencentCloud_SECRET_ACCESS_KEY&#x3D;&quot;your-secret-key&quot;</span><br><span class="line">export RESTIC_REPOSITORY&#x3D;&quot;s3:server-url&#x2F;bucket-name&quot;</span><br><span class="line">export RESTIC_PASSWORD&#x3D;&quot;a-strong-password&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>结合 Cron 完成自动备份</li></ol><p><code>Restic</code> 中的 <code>forget</code> 命令可以帮助你来维护快照的运行存档。你可以使用 <code>restic forget --prune</code> 来设置每小时、每日、每周等保留的备份数量，任何不符合策略的备份都将从存储库中清除。</p><p>这里我们将使用 <code>Cron</code> 系统服务每 30 分钟运行一次备份任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br><span class="line">30 * * * * &#x2F;usr&#x2F;local&#x2F;bin&#x2F;restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup backup --password-file &#x2F;home&#x2F;mike&#x2F;resticpasswd -q &#x2F;var&#x2F;www; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;restic forget -q --prune --keep-hourly 24 --keep-daily 7</span><br></pre></td></tr></table></figure><p>上面的计划任务里，其中 <code>30 * * * *</code> 定义了 Cron 中任务运行的时间，这里定义为每隔 30 分钟运行。<code>--keep-hourly 24 --keep-daily 7</code> 定义了根据指定的保留标志并删除不再需要的旧快照，在这里我们是将 24 小时内的快照保留 7 天。</p><p>更多策略可参考官方文档：<a href="https://restic.readthedocs.io/en/latest/060_forget.html#removing-snapshots-according-to-a-policy" target="_blank" rel="noopener">https://restic.readthedocs.io/en/latest/060_forget.html#removing-snapshots-according-to-a-policy</a></p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://restic.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://restic.readthedocs.io/en/latest/</a></p></li><li><p><a href="https://www.moerats.com/archives/897/" target="_blank" rel="noopener">https://www.moerats.com/archives/897/</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1160729" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1160729</a></p></li><li><p><a href="https://it.ismy.fun/2018/04/22/restic-backup-to-aliyun-oss/" target="_blank" rel="noopener">https://it.ismy.fun/2018/04/22/restic-backup-to-aliyun-oss/</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/66324926" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66324926</a></p></li><li><p><a href="https://www.elasticfeed.com/e8590b1297e81b6e7ab19c66be4f037d/" target="_blank" rel="noopener">https://www.elasticfeed.com/e8590b1297e81b6e7ab19c66be4f037d/</a></p></li><li><p><a href="https://www.vmvps.com/restic-a-new-opensource-backup-free-tool-to-backup-your-vps-files.html" target="_blank" rel="noopener">https://www.vmvps.com/restic-a-new-opensource-backup-free-tool-to-backup-your-vps-files.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Restic&quot;&gt;什么是 Restic&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 是一款 GO 语言开发的开源免费且快速、高效和安全的跨平台备份工具。&lt;code&gt;Restic&lt;/code&gt; 使用加密技术来保证你的数据安全性和完整性，可以将本地数据加密后传输到指定的存储。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 同样支持增量备份，可随时备份和恢复备份。&lt;code&gt;Restic&lt;/code&gt; 支持大多数主流操作系统，比如：&lt;code&gt;Linux&lt;/code&gt;、&lt;code&gt;macOS&lt;/code&gt;、&lt;code&gt;Windows&lt;/code&gt; 以及一些较小众的操作系统 &lt;code&gt;FreeBSD&lt;/code&gt; 和 &lt;code&gt;OpenBSD&lt;/code&gt; 等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/restic/restic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/restic/restic&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Restic 支持的存储类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 支持的存储种类比较多，大致有如下这些类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SFTP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST Server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Amazon S3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Minio Server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenStack Swift&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Backblaze B2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Microsoft Azure Blob Storage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Google Cloud Storage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 Rclone 挂载的存储 (比如：Google Drive、OneDrive 等)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Restic 与 Rclone 的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 与 &lt;code&gt;Rclone&lt;/code&gt; 都是开源的命令行文件备份（同步）工具，但却有着很本质的区别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两者的相同点&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两者都是基于命令行的开源文件同步和备份工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两者都支持将文件备份到本地、远程服务器或对象存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;两者不同点&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Rclone 面向的是文件同步，即保证两端文件的一致，也可以增量备份。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restic 面向的是文件备份和加密，文件先加密再传输备份，而且是增量备份，即每次只备份变化的部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rclone 仓库配置保存在本地，备份的文件会保持原样的同步于存储仓库中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restic 配置信息直接写在仓库，只要有仓库密码，在任何安装了 Restic 的计算机上都可以操作仓库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rclone 不记录文件版本，无法根据某一次备份找回特定时间点上的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restic 每次备份都会生成一个快照，记录当前时间点的文件结构，可以找回特定时间点的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rclone 可以在配置的多个存储端之间传输文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总的来说，&lt;code&gt;Rclone&lt;/code&gt; 和 &lt;code&gt;Restic&lt;/code&gt; 各有所长，要根据不同的业务需求选择使用。比如：网站数据的增量备份，用 &lt;code&gt;Resitc&lt;/code&gt; 就比较合适。而常规文件的远程备份归档，用 &lt;code&gt;Rclone&lt;/code&gt; 就很合适。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Restic" scheme="https://www.hi-linux.com/tags/Restic/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款超实用的命令行备忘神器 Navi</title>
    <link href="https://www.hi-linux.com/posts/29102.html"/>
    <id>https://www.hi-linux.com/posts/29102.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-11T05:22:20.129Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，无论对于运维,还是开发来说，命令行工具都是非常高效的一种管理方式。但有一个很常见的现象就是，很多命令行语句比较复杂，用过一段时间后就忘记了。当然，这时我们可以通过网络搜索或者使用命令的 <code>-—help</code> 选项来快速找到答案。虽然这种常用的方法能解决问题，但是使用起来相对还是显得不那么快速高效。</p><p>之前，我们在「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487743&amp;idx=1&amp;sn=e726fa2c2b8fa0e56e5653c9aba08732&amp;chksm=eac531d6ddb2b8c06c599a1290a1fb4dd22d53855d88294a8a8b443be74a0279fdcaf912eb67&amp;token=1334996765&amp;lang=zh_CN#rd" target="_blank" rel="noopener">如何快速的回忆起遗忘的 Linux 命令</a>」 一文中介绍了如何利用 <code>Apropos</code> 命令来快速查找相应的 <code>Linux</code> 命令。今天，我们再给大家推荐另一款神器 <code>navi</code>。</p><p><code>navi</code> 是一位来自巴西的小哥哥 <code>Denis Isidoro</code> 在 <code>GitHub</code> 上开源的一个的工具 ，目前已经获得超过 4200 星。<code>navi</code> 可以在命令行里给你提供了一个很方便使用的交互式的备忘录，能够帮助你在命令行里快速查阅、调用各种复杂难记的命令行语句。</p><blockquote><p>项目地址：<a href="https://github.com/denisidoro/navi" target="_blank" rel="noopener">https://github.com/denisidoro/navi</a></p></blockquote><p>俗话说得好，不看广告看疗效。废话不多说，先看看下面的演示效果图吧！</p><p><img src="https://www.hi-linux.com/img/linux/navi1.gif" alt=""></p><p>从演示中，我们可能看到使用了 <code>navi</code> 后，只需要键入一个单词，备忘录中的相关命令以及命令用法注释都会实时显示在下方供你直接选择使用，这时我们只需找到想要的命令后即可直接运行相关命令。是不是觉得很神奇和强大呢！</p><a id="more"></a><h2 id="安装-navi">安装 Navi</h2><p><code>navi</code> 的安装还是很容易的，<code>macOS</code> 和 <code>Linux</code> 用户都可以安装。如果你已经安装了 <code>Homebrew</code> 或者 <code>Linuxbrew</code>，那么只需下面一句命令就可以安装好 <code>navi</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install denisidoro&#x2F;tools&#x2F;navi</span><br></pre></td></tr></table></figure><p>如果你没有安装 <code>Homebrew</code> 或者 <code>Linuxbrew</code> 这样的包管理器，你也可以直接通过源码安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth 1 https:&#x2F;&#x2F;github.com&#x2F;denisidoro&#x2F;navi &#x2F;opt&#x2F;navi</span><br><span class="line">$ cd &#x2F;opt&#x2F;navi</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你使用源码进行编译，你需要先安装好命令行模糊查找工具 <code>fzf</code>。 有关 <code>fzf</code> 的具体安装方法，你可以参考其官方网址：<a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">https://github.com/junegunn/fzf</a> 。</p></blockquote><h2 id="使用-navi">使用 Navi</h2><p><code>navi</code> 使用也是很简单的，你只需直接输入 <code>navi</code> 命令并回车后，即可进入交互界面进行命令查找。</p><p><img src="https://www.hi-linux.com/img/linux/navi2.jpeg" alt=""></p><p>默认情况下，选中的命令会直接执行。如果你只想将选中的命令输入到命令行上，你可以加上 <code>--print</code> 选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi --print</span><br></pre></td></tr></table></figure><p>你也可以在 <code>navi</code> 命令后直接加入 <code>query</code> 子命令来预先过滤要输出的命令结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi query &lt;cmd&gt;</span><br></pre></td></tr></table></figure><p>如果你想查找一些命令的常用语法，你也可以使用 <code>search</code> 子命令来从在线仓库中下载对应的备忘清单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi search &lt;cmd&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义备忘录">自定义备忘录</h3><p><code>navi</code> 所使用的备忘清单都是以 <code>.cheat</code> 为后缀的一些文件，<code>navi</code> 安装完后，默认包括了以下这些备忘清单。</p><p><img src="https://i.loli.net/2019/10/21/Kl1J8tBA75wbnjq.png" alt=""></p><p><code>navi</code> 之所以如此受欢迎，主要原因是它支持强大的自定义功能，而且自定义注释还支持中文哟。</p><p>要实现此功能，我们可以用 <code>--dir</code> 参数将自己定义的备忘录 ( <code>.cheat</code> 文件) 传递给 <code>navi</code> 使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi --dir &quot;&#x2F;folder&#x2F;with&#x2F;cheats&quot;</span><br></pre></td></tr></table></figure><p>如果你觉得每次都通过 <code>--dir</code> 参数过于麻烦，你也可以通过环境变量来进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export NAVI_PATH&#x3D;&quot;&#x2F;folder&#x2F;with&#x2F;cheats:&#x2F;another&#x2F;folder&quot;</span><br></pre></td></tr></table></figure><p>介绍完了如何使用自定义的备忘清单后，接下来我们看看如何自已写一个备忘清单。</p><h4 id="cheat-文件语法">.cheat 文件语法</h4><p>我们先来看一个官方给出的 <code>.cheat</code> 文件的示例内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% git, code</span><br><span class="line"></span><br><span class="line"># Change branch</span><br><span class="line">git checkout &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">$ branch: git branch | awk &#39;&#123;print $NF&#125;&#39;</span><br></pre></td></tr></table></figure><p><code>.cheat</code> 文件语法主要有以下几个注意点。</p><ul><li><p>以「<code>%</code>」开头的行定义了该文件包含的特定的标签</p></li><li><p>以「<code>#</code>」开头的行描述了该命令的作用和用法</p></li><li><p>以「<code>$</code>」开头的行定义了给定参数的可选值</p></li><li><p>其它所有的非空行都被视为可执行命令，命令中的变量以 <code>&lt;&gt;</code> 表示</p></li></ul><p>最后我们来看一个实例，我们常用到的 <code>ffmpeg</code> 处理视频的命令通常都太长，这里我们就定义一个 <code>ffmpeg.cheat</code> 文件来管理这些日常常用的命令。</p><p><img src="https://www.hi-linux.com/img/linux/navi4.gif" alt=""></p><p>从上图可以看到，我们在完成 <code>ffmpeg</code> 命令备忘清单的定义后。日常使用中再也不用输入长长的命令，只需要选中对应命令后，再输入自定义参数就可完成所有操作。这样以来，是不是大大提升了工作效率呢!</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="https://url.cn/5pyiQLg" target="_blank" rel="noopener">https://url.cn/5pyiQLg</a></li><li><a href="https://url.cn/5EE2Ejc" target="_blank" rel="noopener">https://url.cn/5EE2Ejc</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，无论对于运维,还是开发来说，命令行工具都是非常高效的一种管理方式。但有一个很常见的现象就是，很多命令行语句比较复杂，用过一段时间后就忘记了。当然，这时我们可以通过网络搜索或者使用命令的 &lt;code&gt;-—help&lt;/code&gt; 选项来快速找到答案。虽然这种常用的方法能解决问题，但是使用起来相对还是显得不那么快速高效。&lt;/p&gt;
&lt;p&gt;之前，我们在「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487743&amp;amp;idx=1&amp;amp;sn=e726fa2c2b8fa0e56e5653c9aba08732&amp;amp;chksm=eac531d6ddb2b8c06c599a1290a1fb4dd22d53855d88294a8a8b443be74a0279fdcaf912eb67&amp;amp;token=1334996765&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何快速的回忆起遗忘的 Linux 命令&lt;/a&gt;」 一文中介绍了如何利用 &lt;code&gt;Apropos&lt;/code&gt; 命令来快速查找相应的 &lt;code&gt;Linux&lt;/code&gt; 命令。今天，我们再给大家推荐另一款神器 &lt;code&gt;navi&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;navi&lt;/code&gt; 是一位来自巴西的小哥哥 &lt;code&gt;Denis Isidoro&lt;/code&gt; 在 &lt;code&gt;GitHub&lt;/code&gt; 上开源的一个的工具 ，目前已经获得超过 4200 星。&lt;code&gt;navi&lt;/code&gt; 可以在命令行里给你提供了一个很方便使用的交互式的备忘录，能够帮助你在命令行里快速查阅、调用各种复杂难记的命令行语句。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/denisidoro/navi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/denisidoro/navi&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;俗话说得好，不看广告看疗效。废话不多说，先看看下面的演示效果图吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/navi1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从演示中，我们可能看到使用了 &lt;code&gt;navi&lt;/code&gt; 后，只需要键入一个单词，备忘录中的相关命令以及命令用法注释都会实时显示在下方供你直接选择使用，这时我们只需找到想要的命令后即可直接运行相关命令。是不是觉得很神奇和强大呢！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>分享几个无需 Docker 环境拉取容器镜像的神器</title>
    <link href="https://www.hi-linux.com/posts/46425.html"/>
    <id>https://www.hi-linux.com/posts/46425.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T03:23:02.446Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>你是否曾经遇到过需要在没有安装任何 <code>Docker</code> 客户端的机器上拉取容器镜像这样变态的需求呢？如果有,你当时又是如何解决的呢？今天我们就来给大家介绍几种另辟蹊径的方法来实现这样的需求。</p><h2 id="使用-docker-drag-实现">使用 docker-drag 实现</h2><p>根据官网介绍：<code>docker-drag</code> 是一个用于与 <code>Docker Hub</code> 交互的工具，并且不需 <code>Docker</code> 客户端本身支持。它主要是通过与 <code>Docker Hub</code> 的 <code>HTTPS API</code> 进行交互来实现相应功能。</p><blockquote><p>项目地址：<a href="https://github.com/NotGlop/docker-drag" target="_blank" rel="noopener">https://github.com/NotGlop/docker-drag</a></p></blockquote><h3 id="安装-docker-drag">安装 docker-drag</h3><p><code>docker-drag</code> 其实就是一个 <code>Python</code> 脚本，目前版本总共才 168 行代码。你只需要去官网仓库直接下载就可以使用了，非常的简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;NotGlop&#x2F;docker-drag&#x2F;master&#x2F;docker_pull.py</span><br></pre></td></tr></table></figure><h3 id="使用-docker-drag">使用 docker-drag</h3><p>我们先来看一下官方给出的演示效果。</p><p><img src="https://user-images.githubusercontent.com/26483750/63388733-b419f480-c3a9-11e9-8617-7c5b47b76dbd.gif" alt=""></p><p><code>docker-drag</code> 的使用也是非常简单的，基本上和 <code>docke pull</code> 命令使用方法一致。其主要是借助 <code>Python</code> 的 <code>Request</code> 库和 <code>HTTPS API</code> 直接从仓库中拉取镜像，并保存为 <code>TAR</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在官方仓库拉取官方镜像</span></span><br><span class="line">$ python docker_pull.py nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接在官方仓库拉取三方镜像</span></span><br><span class="line">$ python docker_pull.py mysql/mysql-server:8.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接在三方仓库拉取镜像</span></span><br><span class="line">$ python docker_pull.py mcr.microsoft.com/windows/nanoserver@sha256:ae443bd9609b9ef06d21d6caab59505cb78f24a725cc24716d4427e36aedabf2</span><br></pre></td></tr></table></figure><p>镜像下载完成后，你可以直接使用 <code>docker load -i</code> 命令对 <code>TAR</code> 文件进行加载。由于不在依赖容器工具本身，在一些实际使用场景中，例如：CICD 流程。这个小工具或许能助你解决大问题哟！</p><a id="more"></a><h2 id="使用-download-frozen-image-v2-实现">使用 download-frozen-image-v2 实现</h2><p>与 <code>docker-drag</code> 类似的工具，还有一个 <code>SHELL</code> 脚本的实现 <code>download-frozen-image-v2</code>，该脚本隶属于 <code>Moby</code> 项目。</p><blockquote><p>项目地址：<a href="https://github.com/moby/moby" target="_blank" rel="noopener">https://github.com/moby/moby</a></p></blockquote><p>它的使用基本上和 <code>docker-drag</code> 类似，大致有如以下几步所示。</p><ol><li>下载对应的脚本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://raw.githubusercontent.com/moby/moby/master/contrib/download-frozen-image-v2.sh</span><br></pre></td></tr></table></figure><ol start="2"><li>download-frozen-image-v2 脚本使用语法</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">download-frozen-image-v2.sh target_dir image[:tag][@digest] ...</span><br></pre></td></tr></table></figure><ol start="3"><li>一个完整的使用实例</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 Ubuntu 容器镜像</span></span><br><span class="line">$ bash download-frozen-image-v2.sh ubuntu ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># download-frozen-image-v2 这里要稍为复杂点，需要自己手动打成 TAR 包</span></span><br><span class="line">$ tar -C <span class="string">'ubuntu'</span> -cf <span class="string">'ubuntu.tar'</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入容器镜像</span></span><br><span class="line">$ docker load -i ubuntu.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入容器镜像完成后，运一个容器</span></span><br><span class="line">$ docker run --rm -ti ubuntu bash</span><br><span class="line">root@1dd5e62113b9:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="使用-dp-实现">使用 dp 实现</h2><p><code>dp</code> 同样也是一个实现上述类似需求的小工具。<code>dp</code> 使用 <code>Go</code> 语言开发，天生具有良好的跨平台性。相对于前两个工具来说更容易在多平台上部署使用，而且 <code>dp</code> 还支持将多个镜像打包在一起。</p><blockquote><p>项目地址：<a href="https://github.com/zhangguanzhang/dp/" target="_blank" rel="noopener">https://github.com/zhangguanzhang/dp/</a></p></blockquote><h3 id="安装-dp">安装 dp</h3><p><code>dp</code> 的安装非常简单，只需在官方仓库 <code>Releases</code> 页面直接下载各平台对应的版本，解压后即可使用。</p><h3 id="使用-dp">使用 dp</h3><p><code>dp</code> 使用起来也是很容易的，下面我们就来看几个实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从官方仓库拉取一个容器镜像</span></span><br><span class="line">$ dp pull nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从官方仓库拉取一个容器镜像并打包到压缩文件</span></span><br><span class="line">$ dp pull -o nginx.tar.gz nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 sha256 拉取一个容器镜像</span></span><br><span class="line">$ dp pull mcr.microsoft.com/windows/nanoserver@sha256:ae443bd9609b9ef06d21d6caab59505cb78f24a725cc24716d4427e36aedabf2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次从官方仓库拉取多个容器镜像并打包到压缩文件</span></span><br><span class="line">$ dp pull -o project.tar.gz nginx:alpine nginx:1.17.5-alpine-perl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从三方镜像仓库拉取多个容器镜像并打包到压缩文件</span></span><br><span class="line">$ dp pull -o project.tar.gz nginx:alpine gcr.io/google_containers/pause-amd64:3.1</span><br></pre></td></tr></table></figure><p>至此，我们就演示完了如何在不需要 <code>Docker</code> 客户端的前提下拉取容器镜像的方法。如果你还有更多更好的方法，欢迎大家积极留言哟！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://xbuba.com/questions/37905763" target="_blank" rel="noopener">https://xbuba.com/questions/37905763</a></p></li><li><p><a href="https://blog.fleeto.us/post/pull-image-without-docker/" target="_blank" rel="noopener">https://blog.fleeto.us/post/pull-image-without-docker/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否曾经遇到过需要在没有安装任何 &lt;code&gt;Docker&lt;/code&gt; 客户端的机器上拉取容器镜像这样变态的需求呢？如果有,你当时又是如何解决的呢？今天我们就来给大家介绍几种另辟蹊径的方法来实现这样的需求。&lt;/p&gt;
&lt;h2 id=&quot;使用-docker-drag-实现&quot;&gt;使用 docker-drag 实现&lt;/h2&gt;
&lt;p&gt;根据官网介绍：&lt;code&gt;docker-drag&lt;/code&gt; 是一个用于与 &lt;code&gt;Docker Hub&lt;/code&gt; 交互的工具，并且不需 &lt;code&gt;Docker&lt;/code&gt; 客户端本身支持。它主要是通过与 &lt;code&gt;Docker Hub&lt;/code&gt; 的 &lt;code&gt;HTTPS API&lt;/code&gt; 进行交互来实现相应功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/NotGlop/docker-drag&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/NotGlop/docker-drag&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装-docker-drag&quot;&gt;安装 docker-drag&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker-drag&lt;/code&gt; 其实就是一个 &lt;code&gt;Python&lt;/code&gt; 脚本，目前版本总共才 168 行代码。你只需要去官网仓库直接下载就可以使用了，非常的简单。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ wget https:&amp;#x2F;&amp;#x2F;raw.githubusercontent.com&amp;#x2F;NotGlop&amp;#x2F;docker-drag&amp;#x2F;master&amp;#x2F;docker_pull.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用-docker-drag&quot;&gt;使用 docker-drag&lt;/h3&gt;
&lt;p&gt;我们先来看一下官方给出的演示效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26483750/63388733-b419f480-c3a9-11e9-8617-7c5b47b76dbd.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker-drag&lt;/code&gt; 的使用也是非常简单的，基本上和 &lt;code&gt;docke pull&lt;/code&gt; 命令使用方法一致。其主要是借助 &lt;code&gt;Python&lt;/code&gt; 的 &lt;code&gt;Request&lt;/code&gt; 库和 &lt;code&gt;HTTPS API&lt;/code&gt; 直接从仓库中拉取镜像，并保存为 &lt;code&gt;TAR&lt;/code&gt; 文件。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 直接在官方仓库拉取官方镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ python docker_pull.py nginx:alpine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 直接在官方仓库拉取三方镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ python docker_pull.py mysql/mysql-server:8.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 直接在三方仓库拉取镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ python docker_pull.py mcr.microsoft.com/windows/nanoserver@sha256:ae443bd9609b9ef06d21d6caab59505cb78f24a725cc24716d4427e36aedabf2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;镜像下载完成后，你可以直接使用 &lt;code&gt;docker load -i&lt;/code&gt; 命令对 &lt;code&gt;TAR&lt;/code&gt; 文件进行加载。由于不在依赖容器工具本身，在一些实际使用场景中，例如：CICD 流程。这个小工具或许能助你解决大问题哟！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>巧用 Cowrie 部署 SSH 蜜罐，让黑客攻击无处遁形</title>
    <link href="https://www.hi-linux.com/posts/6021.html"/>
    <id>https://www.hi-linux.com/posts/6021.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T05:08:04.782Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是蜜罐">什么是蜜罐</h2><p>蜜罐其实就是一台无人使用但却被严密监控的网络主机，里面包含着各类虚假的高价值资源和一些已知漏洞，以此吸引入侵者来入侵该主机。并且在被入侵的过程中，实时记录和审计入侵者的所有入侵攻击流量、行为和数据。以此了解入侵者的攻击方式、手段和目的，便于后期快速完成对其的溯源和取证工作。</p><p><strong>蜜罐的一些主要构成模块</strong></p><ol><li>按实现逻辑划分</li></ol><ul><li><p>控制：将入侵者牢牢控制在指定的网络范围中，使其不能再以此机器作为跳板来攻击其它的机器。</p></li><li><p>捕获：把入侵者在入侵过程中所产生的各种流量捕获住。</p></li><li><p>分析：将捕获到的各种数据存到数据库或者其它指定地方，便于后续还原其详细的入侵攻击过程。</p></li></ul><ol start="2"><li>按具体实现过程划分</li></ol><ul><li><p>监控各种主机项，如：进程、文件、注册表、网络等。</p></li><li><p>同时提交给入侵检测，以识别其更详细的入侵手段，并对整个入侵过程做详细记录。</p></li><li><p>入侵数据汇总分析，其实就是把上述两步所得到的各种数据进行集中分析，最后勾勒出完整的入侵轨迹画像。</p></li></ul><ol start="3"><li>最容易理解的说法</li></ol><ul><li><p>蜜罐环境隔离: 使用虚拟环境将物理环境和蜜罐隔绝开，防止某些敏感操作在其真实的系统环境中进行造成破坏。</p></li><li><p>敏感操作记录：把蜜罐中所有的入侵操作都写进数据库。</p></li><li><p>邮件报警系统：蜜罐被入侵后自动发送报警邮件通知相关安全应急人员。</p></li></ul><a id="more"></a><h2 id="蜜罐的分类">蜜罐的分类</h2><p><strong>1. 低交互蜜罐</strong></p><p>低交互蜜罐最大的特点是：蜜罐为攻击者展示的所有攻击弱点和攻击对象都不是真正的产品系统，而是对各种系统及其提供的服务的模拟。由于它的服务都是模拟的行为，所以蜜罐可以获得的信息非常有限，只能对攻击者进行简单的应答。不过，它也是最安全的蜜罐类型。</p><p><strong>2. 中交互蜜罐</strong></p><p>中交互蜜罐是对真正的操作系统的各种行为的模拟，它提供了更多的交互信息，同时也可以从攻击者的行为中获得更多的信息。在这个模拟行为的系统中，蜜罐此时看起来和一个真正的操作系统没有区别，它们甚至是比真正系统还诱人的攻击目标。</p><p><strong>3. 高交互蜜罐</strong></p><p>高交互蜜罐具有一个真实的操作系统，它的优点体现在对攻击者提供完全真实的系统。当攻击者获得 ROOT 权限后，受系统、数据真实性的迷惑，他的更多活动和行为将被记录下来。缺点是被入侵的可能性很高，如果整个高交互蜜罐被入侵，那么它就会成为攻击者下一步攻击的跳板，不太安全。</p><h2 id="什么是-cowrie">什么是 Cowrie</h2><p><code>Cowrie</code> 是一个具有中等交互的 <code>SSH</code> 蜜罐，它可以获取攻击者用于暴力破解的字典、输入的命令以及上传或下载的恶意文件。所有这些攻击记录都会被记载到日志中，以便日后分析。</p><blockquote><p>项目地址：<a href="https://github.com/cowrie/cowrie" target="_blank" rel="noopener">https://github.com/cowrie/cowrie</a></p></blockquote><p><img src="http://image.3001.net/images/20160816/14713421328918.png" alt=""></p><h2 id="cowrie-安装部署">Cowrie 安装部署</h2><h3 id="使用源码部署">使用源码部署</h3><p>本次搭建使用的基础环境是 <code>Ubuntu</code> ，以下步骤除切换到虚拟环境中的操作，其它均为 root 权限执行。</p><h4 id="安装必要的支持软件">安装必要的支持软件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Python 3</span><br><span class="line">$ sudo apt-get install git python-virtualenv libssl-dev libffi-dev build-essential libpython3-dev python3-minimal authbind virtualenv</span><br><span class="line"></span><br><span class="line"># Python 2</span><br><span class="line">$ sudo apt-get install git python-virtualenv libssl-dev libffi-dev build-essential libpython-dev python2.7-minimal authbind</span><br></pre></td></tr></table></figure><h4 id="添加一个普通用户">添加一个普通用户</h4><p>对外提供服务的程序均以普通用户身份运行，能更好的保证服务器安全性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser --disabled-password cowrie</span><br><span class="line">Adding user &#39;cowrie&#39; ...</span><br><span class="line">Adding new group &#39;cowrie&#39; (1002) ...</span><br><span class="line">Adding new user &#39;cowrie&#39; (1002) with group &#39;cowrie&#39; ...</span><br><span class="line">Changing the user information for cowrie</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">Full Name []:</span><br><span class="line">Room Number []:</span><br><span class="line">Work Phone []:</span><br><span class="line">Home Phone []:</span><br><span class="line">Other []:</span><br><span class="line">Is the information correct? [Y&#x2F;n]</span><br><span class="line"></span><br><span class="line">$ sudo su - cowrie</span><br></pre></td></tr></table></figure><h4 id="安装-cowire">安装 Cowire</h4><p>由于 <code>Cowire</code> 是采用 <code>Python</code> 开发，为了方便管理和安全，我们就直接将 <code>Cowire</code> 部署到 <code>Python</code> 的虚拟环境中。</p><ol><li>下载 Cowire</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;cowrie&#x2F;</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;cowrie&#x2F;cowrie.git</span><br></pre></td></tr></table></figure><ol start="2"><li>在 Python 虚拟环境中安装 Cowire</li></ol><ul><li>进入 <code>Cowrie</code> 所在目录，并安装虚拟环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;cowrie&#x2F;cowrie</span><br></pre></td></tr></table></figure><ul><li>使用 Python 3 创建虚拟环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --python&#x3D;python3 cowrie-env</span><br><span class="line">New python executable in .&#x2F;cowrie&#x2F;cowrie-env&#x2F;bin&#x2F;python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure><ul><li>使用 Python 2 创建虚拟环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --python&#x3D;python2 cowrie-env</span><br><span class="line">New python executable in .&#x2F;cowrie&#x2F;cowrie-env&#x2F;bin&#x2F;python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure><ul><li>激活 Cowrie 环境，并安装必要的软件包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ source cowrie-env&#x2F;bin&#x2F;activate</span><br><span class="line">(cowrie-env) $ pip install --upgrade pip</span><br><span class="line">(cowrie-env) $ pip install --upgrade -r requirements.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>创建并修改 Cowire 的配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(cowrie-env) $ cd etc&#x2F;</span><br><span class="line">(cowrie-env) $ cp cowrie.cfg.dist cowrie.cfg</span><br><span class="line">(cowrie-env) $ vi cowrie.cfg</span><br></pre></td></tr></table></figure><ul><li>打开 SSH 服务，并且修改监听端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ssh]</span><br><span class="line"></span><br><span class="line"># Enable SSH support</span><br><span class="line"># (default: true)</span><br><span class="line">enabled &#x3D; true</span><br><span class="line"></span><br><span class="line">listen_endpoints &#x3D; tcp:2222:interface&#x3D;0.0.0.0</span><br></pre></td></tr></table></figure><ul><li>配置日志文件输出</li></ul><p>默认情况下，<code>Cowire</code> 支持将日志输出到多个接收终端中。比如：文件文件、<code>Cucko</code>o、<code>ELK Stack</code>、<code>Graylog</code>、<code>Kippo-Graph</code>、<code>Splunk</code>、<code>SQL</code> (<code>MySQL</code>、<code>SQLite3</code>、<code>RethinkDB</code>) 等等中。这里我们就来说说最常用的文本文件和 <code>MySQL</code> 数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 保存在文本文件中，需要配置以下一些内容。</span><br><span class="line">[output_textlog]</span><br><span class="line">enabled &#x3D; true</span><br><span class="line">logfile &#x3D; $&#123;honeypot:log_path&#125;&#x2F;audit.log</span><br><span class="line">format &#x3D; text</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 保存在数据库中，需要配置以下一些内容。</span><br><span class="line">[output_mysql]</span><br><span class="line">host &#x3D; localhost</span><br><span class="line">database &#x3D; cowrie</span><br><span class="line">username &#x3D; cowrie</span><br><span class="line">password &#x3D; PASSWORD HERE</span><br><span class="line">port &#x3D; 3306</span><br><span class="line">debug &#x3D; false</span><br><span class="line">enabled &#x3D; true</span><br></pre></td></tr></table></figure><p>如果是需要保存在 <code>MySQL</code> 数据库中，当然只配置是不行的，你还得需要有一个对应的数据库。如果你没有，可以按下面的步骤进行安装。</p><ul><li>安装 MySQL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install mysql-server mysql-client libmysqlclient-dev python-mysqldb</span><br></pre></td></tr></table></figure><p>安装成功后，你可以通过下面的命令测试是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure><ul><li>在 Python 虚拟环境中安装 MySQL 依赖包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ source cowrie-env&#x2F;bin&#x2F;activate</span><br><span class="line">$ pip install mysqlclient mysql-python</span><br></pre></td></tr></table></figure><ul><li>创建名为 cowrie 的数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">mysql&gt; create database cowrie;</span><br></pre></td></tr></table></figure><ul><li>创建一个给 Cowrie 访问数据库的用户</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT INSERT, SELECT, UPDATE ON cowrie.* TO &#39;cowrie&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;PASSWORD HERE&#39;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">mysql&gt; exit</span><br></pre></td></tr></table></figure><ul><li>数据库和对应的数据库用户创建完成后，在数据库中导入初始数据的 SQL 语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;cowrie&#x2F;docs&#x2F;sql&#x2F;</span><br><span class="line">$ mysql -u cowrie -p</span><br><span class="line">mysql&gt; USE cowrie;</span><br><span class="line">mysql&gt; source mysql.sql;</span><br><span class="line">mysql&gt; exit</span><br></pre></td></tr></table></figure><ol start="4"><li>在 Python 虚拟环境下启动蜜罐</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(cowrie-env) $ bin&#x2F;cowrie start</span><br><span class="line">Activating virtualenv &quot;cowrie-env&quot;</span><br><span class="line">Starting cowrie with extra arguments [] ...</span><br></pre></td></tr></table></figure><ol start="5"><li>修改 SSH 默认的监听端口</li></ol><p>在 <code>root</code> 用户下将 <code>Ubuntu</code> 自身的 <code>SSH</code> 监听端口进行更改，并修改 <code>Iptables</code> 规则。</p><p>首先，我们验证下是否安装 <code>SSH</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep sshd</span><br><span class="line">root      2720     1  0 Nov 02 ? 00:00:00 &#x2F;usr&#x2F;sbin&#x2F;sshd</span><br></pre></td></tr></table></figure><p>如果输出结果和以上类似就证明已经安装，没有安装的话可以使用以下命令安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>安装完成后，我们可以修改 <code>sshd_config</code> 文件将默认端口改为一个较高的端口，这里为 51268 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"># Port 22</span><br><span class="line">Port 51268</span><br></pre></td></tr></table></figure><blockquote><p>注意：一定不要与 <code>cowrie.cfg</code> 文件中监听的端口一致，否则进入 <code>22</code> 端口的流量就转发到真正的 <code>SSH</code> 服务端口，蜜罐就不起作用了。</p></blockquote><ol start="6"><li>配置 Iptables 进行端口转发</li></ol><p>以上都配置好后，最后就是在 <code>Iptables</code> 中新增一条转发规则，将默认到 <code>22</code> 端口的请求转发到蜜罐中对应的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-port 2222</span><br><span class="line">$ iptables-save</span><br></pre></td></tr></table></figure><p>除了使用 <code>Iptables</code> 外，你还可以在没有 <code>Root</code> 权限的条件下使用 <code>Authbind</code> 或 <code>Setcap</code> 将蜜罐绑定到一些特权端口上，以达到伪装一些正常服务的目的。具体方法可以参见官方文档如下部分：</p><blockquote><ol><li><p><a href="https://cowrie.readthedocs.io/en/latest/INSTALL.html#authbind" target="_blank" rel="noopener">https://cowrie.readthedocs.io/en/latest/INSTALL.html#authbind</a></p></li><li><p><a href="https://cowrie.readthedocs.io/en/latest/INSTALL.html#setcap" target="_blank" rel="noopener">https://cowrie.readthedocs.io/en/latest/INSTALL.html#setcap</a></p></li></ol></blockquote><h3 id="使用-docker-部署">使用 Docker 部署</h3><p>上面讲解的通过源码安装，主要是为了演示 <code>Cowrie</code> 如何工作的，当然最方便的还是直接使用 <code>Docker</code> 部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 2222:2222 cowrie&#x2F;cowrie</span><br><span class="line">$ ssh -p 2222 root@localhost</span><br></pre></td></tr></table></figure><p>如上所示，只需一条指令，<code>Cowrie</code> 就部署完成了。剩下就只需要自己用 <code>Iptables</code> 进行端口转发就可以了。</p><h2 id="cowrie-日志分析">Cowrie 日志分析</h2><p>蜜罐系统的作用主要是用作实时记录和审计入侵者攻击行为和数据，所以最重要的还是事后的日志分析工作。</p><ol><li>如果日志记录在文本文件，你可以使用下面的命令进行一些数据统计分析。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep login &#x2F;home&#x2F;cowrie&#x2F;cowrie&#x2F;var&#x2F;log&#x2F;cowrie&#x2F;audit.log | awk &#39;&#123;print $5&#125;&#39; | sort | uniq -c</span><br></pre></td></tr></table></figure><ol start="2"><li>如果日志记录在数据库，你可以通过下面的一些方式进行一些数据统计分析。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u cowrie -p</span><br><span class="line">mysql&gt; USE cowrie;</span><br><span class="line">mysql&gt; SELECT * FROM auth;</span><br><span class="line">+----+--------------+---------+----------+-------------+---------------------+</span><br><span class="line">| id | session      | success | username | password    | timestamp           |</span><br><span class="line">+----+--------------+---------+----------+-------------+---------------------+</span><br><span class="line">|  1 | a551c0a74e06 |       0 | root     | 12345       | 2019-09-27 23:15:56 |</span><br><span class="line">|  2 | a551c0a74e06 |       0 | root     | seiko2005   | 2019-09-27 23:15:58 |</span><br><span class="line">|  3 | a551c0a74e06 |       0 | root     | anko        | 2019-09-27 23:15:59 |</span><br><span class="line">|  4 | a551c0a74e06 |       0 | root     | 123456      | 2019-09-27 23:16:00 |</span><br><span class="line">|  5 | a551c0a74e06 |       0 | root     | dreambox    | 2019-09-27 23:16:01 |</span><br></pre></td></tr></table></figure><p>当然上面只是举了一些简单的例子，更多高级玩法还等着你去探索哟！</p><h2 id="其它">其它</h2><p>目前开源的蜜罐系统有很多，除了 <code>Cowrie</code> 以外，还有 <code>Kippo</code>、<code>T-Pot</code>、<code>MHN</code>、<code>SSH-Honeypot</code> 等等。如果你对蜜罐系统很感兴趣，可以参考 <code>GitHub</code> 上以下两个开源项目。</p><blockquote><ol><li><p><a href="https://github.com/jwxa2015/honeypotcollection" target="_blank" rel="noopener">https://github.com/jwxa2015/honeypotcollection</a></p></li><li><p><a href="https://github.com/paralax/awesome-honeypots" target="_blank" rel="noopener">https://github.com/paralax/awesome-honeypots</a></p></li></ol></blockquote><p>至此，使用 <code>Cowrie</code> 快速构建一个蜜罐系统的基本方法就介绍完了。如果你对 <code>Cowrie</code> 非常的感兴趣，还可以去官网探索更多高级功能哟！</p><p>对于快速构建一个蜜罐系统，你还有哪些更好用高效的方法呢？欢迎大家在留言讨论哟！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://cowrie.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://cowrie.readthedocs.io/en/latest/</a></p></li><li><p><a href="https://www.cnblogs.com/bmjoker/p/10156220.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/10156220.html</a></p></li><li><p><a href="https://www.cnblogs.com/HacTF/p/8094516.html" target="_blank" rel="noopener">https://www.cnblogs.com/HacTF/p/8094516.html</a></p></li><li><p><a href="https://klionsec.github.io/2017/10/19/cowrie/" target="_blank" rel="noopener">https://klionsec.github.io/2017/10/19/cowrie/</a></p></li><li><p><a href="https://www.twblogs.net/a/5cb0b56bbd9eee48d788646c" target="_blank" rel="noopener">https://www.twblogs.net/a/5cb0b56bbd9eee48d788646c</a></p></li><li><p><a href="https://ama2in9.top/2019/03/12/cowrie/" target="_blank" rel="noopener">https://ama2in9.top/2019/03/12/cowrie/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是蜜罐&quot;&gt;什么是蜜罐&lt;/h2&gt;
&lt;p&gt;蜜罐其实就是一台无人使用但却被严密监控的网络主机，里面包含着各类虚假的高价值资源和一些已知漏洞，以此吸引入侵者来入侵该主机。并且在被入侵的过程中，实时记录和审计入侵者的所有入侵攻击流量、行为和数据。以此了解入侵者的攻击方式、手段和目的，便于后期快速完成对其的溯源和取证工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;蜜罐的一些主要构成模块&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按实现逻辑划分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;控制：将入侵者牢牢控制在指定的网络范围中，使其不能再以此机器作为跳板来攻击其它的机器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;捕获：把入侵者在入侵过程中所产生的各种流量捕获住。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析：将捕获到的各种数据存到数据库或者其它指定地方，便于后续还原其详细的入侵攻击过程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;按具体实现过程划分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;监控各种主机项，如：进程、文件、注册表、网络等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同时提交给入侵检测，以识别其更详细的入侵手段，并对整个入侵过程做详细记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;入侵数据汇总分析，其实就是把上述两步所得到的各种数据进行集中分析，最后勾勒出完整的入侵轨迹画像。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;最容易理解的说法&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;蜜罐环境隔离: 使用虚拟环境将物理环境和蜜罐隔绝开，防止某些敏感操作在其真实的系统环境中进行造成破坏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;敏感操作记录：把蜜罐中所有的入侵操作都写进数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;邮件报警系统：蜜罐被入侵后自动发送报警邮件通知相关安全应急人员。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="https://www.hi-linux.com/categories/SSH/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="SSH" scheme="https://www.hi-linux.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>分享一个超实用的 Web 版 SSH 工具 Sshwifty</title>
    <link href="https://www.hi-linux.com/posts/2389.html"/>
    <id>https://www.hi-linux.com/posts/2389.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T03:23:02.448Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>无论你是一名开发或者运维，相信都对 <code>SSH</code> 这个工具都不陌生。不管是开发需要访问服务器处理程序错误还是运维访问服务器处理服务异常，我们都需要通过 <code>SSH</code> 协议来远程连接到服务器。</p><p>通常我们使用 <code>SSH</code> 协议访问服务器基本都是使用 <code>SSH</code> 客户端软件，比如：<code>Xshell</code>、<code>Putty</code>、<code>SecureCRT</code>、<code>iTerm 2</code> 等。这些客户端软件虽然使用上都比较方便，但在有些场景下，我们需要在没有安装 <code>SSH</code> 客户端的环境下访问远程服务器。这时我们应该怎么办呢，当然是有办法解决的，那就是通过 <code>WebSSH</code> 这种方法来进行访问。</p><blockquote><p><code>WebSSH</code> 泛指一种可以在网页上实现一个 <code>SSH</code> 终端的技术。从而无需任何 <code>SSH</code> 客户端工具就可进行 <code>SSH</code> 连接，将 <code>SSH</code> 从 <code>C/S</code> 架构转变成了 <code>B/S</code> 架构。</p></blockquote><p>目前，可以实现 <code>WebSSH</code> 的软件有很多，比如：<code>GateOne</code>、<code>Shellinabox</code>、<code>WSSH</code>、<code>Xterm.js</code> 等，而我们今天要介绍的是一款更为强大的 <code>WebSSH</code> 软件 <code>Sshwifty</code>。<code>Sshwifty</code> 使用 <code>Go</code>、<code>Vuejs</code> 和 <code>xtermjs</code> 进行开发，几乎实现了目前所有  <code>WebSSH</code> 软件的功能。</p><blockquote><p>项目地址：<a href="https://github.com/niruix/sshwifty" target="_blank" rel="noopener">https://github.com/niruix/sshwifty</a></p></blockquote><p><img src="https://github.com/niruix/sshwifty/raw/master/Screenshot.png" alt=""></p><a id="more"></a><h2 id="安装-sshwifty">安装 Sshwifty</h2><ol><li>通过二进制包安装</li></ol><p>由于  <code>Sshwifty</code> 采用 <code>Go</code> 语言开发，良好的原生跨平台支持。安装起来非常简单，基本开箱即用。这里以 <code>Linux</code> 平台为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 下载并解压 Sshwifty 安装包</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;niruix&#x2F;sshwifty&#x2F;releases&#x2F;download&#x2F;0.1.0-beta-release-prebuild&#x2F;sshwifty_0.1.0-beta-release_linux_amd64.tar.gz</span><br><span class="line">$ tar -xzvf sshwifty_0.1.0-beta-release_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 复制可执行文件到指定目录并赋予执行权限</span><br><span class="line">$ cp sshwifty_linux_amd64 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;sshwifty</span><br><span class="line">$ chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;sshwifty</span><br><span class="line"></span><br><span class="line"># 生成默认配置文件</span><br><span class="line">$ cp sshwifty.conf.example.json &#x2F;etc&#x2F;sshwifty.conf.json</span><br><span class="line"></span><br><span class="line"># 启动 Sshwifty</span><br><span class="line">$ sshwifty</span><br></pre></td></tr></table></figure><blockquote><p>使用默认配置文件会在 <code>127.0.0.1</code> 的 <code>8182</code> 端口启动 <code>Sshwifty</code> 服务，你可以根据自行需要更改。</p></blockquote><p>更多平台的二进制安装包，可自行在官方项目地址的 <a href="https://github.com/niruix/sshwifty/releases" target="_blank" rel="noopener">Releases</a> 页面进行下载。</p><ol start="2"><li>通过 Docker 安装</li></ol><p>如果你会一点 <code>Docker</code> 的话，强烈建议使用 <code>Docker</code> 进行部署安装。通过 <code>Docker</code> 安装仅需要一条指令就可以搞定，比二进制包安装更加的简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --detach \</span><br><span class="line">  --restart&#x3D;always \</span><br><span class="line">  --publish 8182:8182 \</span><br><span class="line">  --name sshwifty \</span><br><span class="line">  niruix&#x2F;sshwifty:latest</span><br></pre></td></tr></table></figure><p>如果你想给 <code>Sshwifty</code> 部署一个 <code>HTTPS</code> 证书，可以使用以下的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --detach \</span><br><span class="line">  --restart&#x3D;always \</span><br><span class="line">  --publish 8182:8182 \</span><br><span class="line">  --env SSHWIFTY_DOCKER_TLSCERT&#x3D;&quot;$(cat &#x2F;path&#x2F;to&#x2F;domain.crt)&quot;</span><br><span class="line">  --env SSHWIFTY_DOCKER_TLSCERTKEY&#x3D;&quot;$(cat &#x2F;path&#x2F;to&#x2F;domain.key)&quot;</span><br><span class="line">  --name sshwifty \</span><br><span class="line">  niruix&#x2F;sshwifty:latest</span><br></pre></td></tr></table></figure><blockquote><p><code>/path/to/domain.crt</code> 和 <code>/path/to/domain.key</code> 是用来指定本地 <code>HTTPS</code> 证书和密钥文件所在的位置。</p></blockquote><h2 id="使用-sshwifty">使用 Sshwifty</h2><p><code>Sshwifty</code> 部署好后，直接用浏览器访问相应地址即可使用。首次访问时，会要求输入一个认证口令。</p><p><img src="https://i.loli.net/2019/09/16/DiOCrIVw6mPYEnu.png" alt=""></p><blockquote><p>默认口令为：<code>WEB_ACCESS_PASSWORD</code>，如需修改可变更配置文件中的 <code>&quot;SharedKey&quot;: &quot;WEB_ACCESS_PASSWORD&quot;</code> 配置项。</p></blockquote><p>认证完成后，成功登陆 <code>Sshwifty</code>。</p><p><img src="https://i.loli.net/2019/09/16/Uj5ClXMmyA3wLTF.png" alt=""></p><p>点击左上角 <code>+</code> 号图标后，就可新建一个访问远程服务器 <code>SSH</code> 或 <code>Telnet</code> 的连接。</p><p><img src="https://i.loli.net/2019/09/16/SgXJMa2ECVxDBfA.png" alt=""></p><p>如果你觉得自已部署还是太麻烦，也可以直接使用官方提供的演示地址进行体验哟！</p><blockquote><p>官方演示地址：<a href="https://sshwifty.herokuapp.com/" target="_blank" rel="noopener">https://sshwifty.herokuapp.com/</a></p></blockquote><p>你在这里不仅可以体验 <code>Sshwifty</code> 的强大功能，还可以在这里观看有趣的星球大战 <code>Telnet</code> 版哟！</p><p><img src="https://i.loli.net/2019/09/16/E4VAHQi9Mm8FTJw.png" alt=""></p><p>至此，<code>Sshwifty</code> 的基本使用就已经介绍完成了。如果你对它很有兴趣，可以自行去官网进行探索哟！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://github.com/niruix/sshwifty" target="_blank" rel="noopener">https://github.com/niruix/sshwifty</a></p></li><li><p><a href="https://www.cnblogs.com/franknihao/p/8963634.html" target="_blank" rel="noopener">https://www.cnblogs.com/franknihao/p/8963634.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论你是一名开发或者运维，相信都对 &lt;code&gt;SSH&lt;/code&gt; 这个工具都不陌生。不管是开发需要访问服务器处理程序错误还是运维访问服务器处理服务异常，我们都需要通过 &lt;code&gt;SSH&lt;/code&gt; 协议来远程连接到服务器。&lt;/p&gt;
&lt;p&gt;通常我们使用 &lt;code&gt;SSH&lt;/code&gt; 协议访问服务器基本都是使用 &lt;code&gt;SSH&lt;/code&gt; 客户端软件，比如：&lt;code&gt;Xshell&lt;/code&gt;、&lt;code&gt;Putty&lt;/code&gt;、&lt;code&gt;SecureCRT&lt;/code&gt;、&lt;code&gt;iTerm 2&lt;/code&gt; 等。这些客户端软件虽然使用上都比较方便，但在有些场景下，我们需要在没有安装 &lt;code&gt;SSH&lt;/code&gt; 客户端的环境下访问远程服务器。这时我们应该怎么办呢，当然是有办法解决的，那就是通过 &lt;code&gt;WebSSH&lt;/code&gt; 这种方法来进行访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;WebSSH&lt;/code&gt; 泛指一种可以在网页上实现一个 &lt;code&gt;SSH&lt;/code&gt; 终端的技术。从而无需任何 &lt;code&gt;SSH&lt;/code&gt; 客户端工具就可进行 &lt;code&gt;SSH&lt;/code&gt; 连接，将 &lt;code&gt;SSH&lt;/code&gt; 从 &lt;code&gt;C/S&lt;/code&gt; 架构转变成了 &lt;code&gt;B/S&lt;/code&gt; 架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前，可以实现 &lt;code&gt;WebSSH&lt;/code&gt; 的软件有很多，比如：&lt;code&gt;GateOne&lt;/code&gt;、&lt;code&gt;Shellinabox&lt;/code&gt;、&lt;code&gt;WSSH&lt;/code&gt;、&lt;code&gt;Xterm.js&lt;/code&gt; 等，而我们今天要介绍的是一款更为强大的 &lt;code&gt;WebSSH&lt;/code&gt; 软件 &lt;code&gt;Sshwifty&lt;/code&gt;。&lt;code&gt;Sshwifty&lt;/code&gt; 使用 &lt;code&gt;Go&lt;/code&gt;、&lt;code&gt;Vuejs&lt;/code&gt; 和 &lt;code&gt;xtermjs&lt;/code&gt; 进行开发，几乎实现了目前所有  &lt;code&gt;WebSSH&lt;/code&gt; 软件的功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/niruix/sshwifty&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/niruix/sshwifty&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/niruix/sshwifty/raw/master/Screenshot.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="https://www.hi-linux.com/categories/SSH/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="SSH" scheme="https://www.hi-linux.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>推荐一个比 Postman 更好用的接口测试神器 Postwoman</title>
    <link href="https://www.hi-linux.com/posts/31368.html"/>
    <id>https://www.hi-linux.com/posts/31368.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T03:23:02.449Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>对于经常进行接口调试的同学来说，应该是比较熟悉 <code>Postman</code> 了。<code>Postman</code> 虽然功能强大，但也有很多弊端。比如：不支持 <code>Web</code> 方式，需要安装客户端软件等。如果你只想简单地测试下接口返回，就需要安装一个客户端工具就显得比较麻烦了。</p><p>为了解决这个痛点，今天就给大家推荐一个轻量级、功能强大且颜值超高的神器 <code>Postwoman</code>。<code>Postwoman</code> 是一个 <code>HTTP API</code> 测试工具，支持 <code>REST</code>、<code>SOAP</code> 和 <code>GraphQL</code> 请求，并且可以实现自动化接口测试、接口监控、模拟接口数据、生成接口文档、多人协作等功能。简单来说，<code>Postwoman</code> 是一个好用且功能非常强大的 <code>API</code> 调试工具。</p><h2 id="什么是-postwoman">什么是 Postwoman</h2><p><code>Postwoman</code> 是一个基于 <code>Vue</code> 开发的的 <code>Web</code> 项目，功能类似 <code>Poatman</code> 的免费且美观的开源替代方案，它可以帮助开发人员更快地创建请求，提升工作效率。目前，该项目在 <code>Github</code> 上的 <code>Star</code> 数已经超过 10k 了！</p><blockquote><p>项目地址：<a href="https://github.com/liyasthomas/postwoman" target="_blank" rel="noopener">https://github.com/liyasthomas/postwoman</a></p></blockquote><p><img src="https://raw.githubusercontent.com/liyasthomas/postwoman/master/static/images/screenshot1.png" alt=""></p><h2 id="postwoman-功能介绍">Postwoman 功能介绍</h2><ol><li>Postwoman 相关特性</li></ol><ul><li><p>采用简约的 UI 设计，简单的设计是最好的设计</p></li><li><p>响应速度更快，软件使用更轻量、更简洁</p></li><li><p>实时发送请求并获取/复制响应</p></li></ul><ol start="2"><li>Postwoman 支持的方法</li></ol><ul><li><p>GET</p></li><li><p>HEAD</p></li><li><p>POST</p></li><li><p>PUT</p></li><li><p>DELETE</p></li><li><p>OPTIONS</p></li><li><p>PATCH</p></li></ul><ol start="3"><li>Postwoman 支持界面定制</li></ol><ul><li><p>支持主题选择：Kinda Dark（默认）、Clearly White、Just Black 和 System 主题</p></li><li><p>支持自定义强调颜色：绿色（默认）、黄色、粉红色、红色、紫色、橙色、青色和蓝色</p></li></ul><ol start="4"><li>其它支持的特性</li></ol><ul><li><p>支持以 <code>PWA</code> 方式进行安装</p></li><li><p>支持离线使用</p></li><li><p>内存和 <code>CPU</code> 使用率非常低</p></li><li><p>支持多平台、多设备</p></li><li><p>支持 <code>WebSocket</code></p></li><li><p>支持 <code>GraphQL</code></p></li><li><p>支持多种 <code>HTTP</code> 认证方式</p></li><li><p>…</p></li></ul><p>除此之外，<code>Postwoman</code> 还具备很多好用的特性，完整功能列表介绍可以戳「<a href="https://github.com/liyasthomas/postwoman" target="_blank" rel="noopener">这里</a>」。</p><a id="more"></a><h2 id="使用-postwoman">使用 Postwoman</h2><p><img src="https://github.com/liyasthomas/postwoman/blob/master/static/images/screenshot2.png" alt=""></p><p><code>Postwoman</code> 既然是一个 <code>Web</code> 项目，使用起来也就非常简单，你只需直接访问其官网地址即可直接使用。</p><blockquote><p>官网地址：<a href="https://postwoman.io/" target="_blank" rel="noopener">https://postwoman.io/</a></p></blockquote><p>如果你想在本地自行搭建也是可以的，大致过程如下：</p><ul><li>使用源代码进行搭建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/liyasthomas/postwoman.git</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><ul><li>使用 Docker 进行搭建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取 Postwoman 相关镜像</span></span><br><span class="line">$ docker pull liyasthomas/postwoman</span><br><span class="line"><span class="comment"># 运行一个 Postwoman 的容器</span></span><br><span class="line">$ docker run -p 3000:3000 liyasthomas/postwoman:latest</span><br></pre></td></tr></table></figure><p>不论使用以下哪种方法搭建，搭建成功后，你只需打开浏览器访问对应主机 <code>IP</code> 的 <code>3000</code> 端口即可访问本地的 <code>Postwoman</code> 环境。</p><h2 id="更多的界面截图">更多的界面截图</h2><p><img src="https://i.loli.net/2019/11/29/L9RsVMEhzUdYbPS.png" alt=""></p><p><img src="https://i.loli.net/2019/11/29/DmWaUkgT7uK5rif.png" alt=""></p><p><img src="https://i.loli.net/2019/11/29/z61X8EbiQRDFhAH.png" alt=""></p><p><img src="https://i.loli.net/2019/11/29/mkYbxGTMgesJh1B.png" alt=""></p><h2 id="总结">总结</h2><p>如果你觉得 <code>Postman</code> 不够好用或者确实是想要使用一个界面更加好看的接口调试工具，那么 <code>Postwoman</code> 将是你最佳的选择！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://github.com/liyasthomas/postwoman" target="_blank" rel="noopener">https://github.com/liyasthomas/postwoman</a></p></li><li><p><a href="https://juejin.im/post/5dca85cb6fb9a04a8953fef6" target="_blank" rel="noopener">https://juejin.im/post/5dca85cb6fb9a04a8953fef6</a></p></li><li><p><a href="http://www.xmhzd.com/study/article/view-607.html" target="_blank" rel="noopener">http://www.xmhzd.com/study/article/view-607.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于经常进行接口调试的同学来说，应该是比较熟悉 &lt;code&gt;Postman&lt;/code&gt; 了。&lt;code&gt;Postman&lt;/code&gt; 虽然功能强大，但也有很多弊端。比如：不支持 &lt;code&gt;Web&lt;/code&gt; 方式，需要安装客户端软件等。如果你只想简单地测试下接口返回，就需要安装一个客户端工具就显得比较麻烦了。&lt;/p&gt;
&lt;p&gt;为了解决这个痛点，今天就给大家推荐一个轻量级、功能强大且颜值超高的神器 &lt;code&gt;Postwoman&lt;/code&gt;。&lt;code&gt;Postwoman&lt;/code&gt; 是一个 &lt;code&gt;HTTP API&lt;/code&gt; 测试工具，支持 &lt;code&gt;REST&lt;/code&gt;、&lt;code&gt;SOAP&lt;/code&gt; 和 &lt;code&gt;GraphQL&lt;/code&gt; 请求，并且可以实现自动化接口测试、接口监控、模拟接口数据、生成接口文档、多人协作等功能。简单来说，&lt;code&gt;Postwoman&lt;/code&gt; 是一个好用且功能非常强大的 &lt;code&gt;API&lt;/code&gt; 调试工具。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Postwoman&quot;&gt;什么是 Postwoman&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Postwoman&lt;/code&gt; 是一个基于 &lt;code&gt;Vue&lt;/code&gt; 开发的的 &lt;code&gt;Web&lt;/code&gt; 项目，功能类似 &lt;code&gt;Poatman&lt;/code&gt; 的免费且美观的开源替代方案，它可以帮助开发人员更快地创建请求，提升工作效率。目前，该项目在 &lt;code&gt;Github&lt;/code&gt; 上的 &lt;code&gt;Star&lt;/code&gt; 数已经超过 10k 了！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/liyasthomas/postwoman&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/liyasthomas/postwoman&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liyasthomas/postwoman/master/static/images/screenshot1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Postwoman-功能介绍&quot;&gt;Postwoman 功能介绍&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Postwoman 相关特性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;采用简约的 UI 设计，简单的设计是最好的设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应速度更快，软件使用更轻量、更简洁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实时发送请求并获取/复制响应&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Postwoman 支持的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HEAD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PUT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DELETE&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OPTIONS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PATCH&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Postwoman 支持界面定制&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;支持主题选择：Kinda Dark（默认）、Clearly White、Just Black 和 System 主题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持自定义强调颜色：绿色（默认）、黄色、粉红色、红色、紫色、橙色、青色和蓝色&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;其它支持的特性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;支持以 &lt;code&gt;PWA&lt;/code&gt; 方式进行安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持离线使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存和 &lt;code&gt;CPU&lt;/code&gt; 使用率非常低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持多平台、多设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 &lt;code&gt;WebSocket&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 &lt;code&gt;GraphQL&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持多种 &lt;code&gt;HTTP&lt;/code&gt; 认证方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，&lt;code&gt;Postwoman&lt;/code&gt; 还具备很多好用的特性，完整功能列表介绍可以戳「&lt;a href=&quot;https://github.com/liyasthomas/postwoman&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 私有集群负载均衡器终极解决方案 MetalLB ( 贫苦 K8S 用户的 LoadBalancer )</title>
    <link href="https://www.hi-linux.com/posts/34820.html"/>
    <id>https://www.hi-linux.com/posts/34820.html</id>
    <published>2020-05-08T01:00:00.000Z</published>
    <updated>2020-05-08T05:14:23.217Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>私有云裸金属架构（这里是相对云上环境来说，不是说无操作系统）上部署的 Kubernetes 集群，通常是无法使用 LoadBalancer 类型的 Service 的。因为 Kubernetes 本身没有为裸机群集提供网络负载均衡器（类型为 LoadBalancer 的服务）的实现。如果你的 Kubernetes 集群没有在公有云的 IaaS 平台（GCP，AWS，Azure …）上运行，则 LoadBalancers 将在创建时无限期地保持 “挂起” 状态，也就是说只有公有云厂商自家的 Kubernetes 支持 LoadBalancer 。</p><p>为了从外部访问裸机 Kubernetes 群集，目前只能使用 <code>NodePort</code> 或 <code>Ingress</code> 的方法进行服务暴露。前者的缺点是每个暴露的服务需要占用所有节点的某个端口，后者的缺点是仅仅能支持 <code>HTTP</code> 协议。</p><h2 id="什么是-metallb">什么是 MetalLB</h2><p><code>MetalLB</code> 是一个负载均衡器，专门解决裸金属 Kubernetes 集群中无法使用 <code>LoadBalancer</code> 类型服务的痛点。<code>MetalLB</code> 使用标准化的路由协议，以便裸金属 Kubernetes 集群上的外部服务也尽可能地工作。即 MetalLB 能够帮助你在裸金属 Kubernetes 集群中创建 LoadBalancer 类型的 Kubernetes 服务，该项目发布于 2017 年底，当前处于 <code>Beta</code> 阶段。</p><blockquote><p>项目地址：<a href="https://github.com/danderson/metallb" target="_blank" rel="noopener">https://github.com/danderson/metallb</a></p></blockquote><h2 id="metallb-工作原理">MetalLB 工作原理</h2><p>MetalLB 会在 Kubernetes 内运行，监控服务对象的变化，一旦监测到有新的 LoadBalancer 服务运行，并且没有可申请的负载均衡器之后，就会完成地址分配和外部声明两部分的工作。</p><h3 id="地址分配">地址分配</h3><p>在云环境中，当你请求一个负载均衡器时，云平台会自动分配一个负载均衡器的 IP 地址给你，应用程序通过此 IP 来访问经过负载均衡处理的服务。</p><p>使用 MetalLB 时，MetalLB 会自己为用户的 LoadBalancer 类型 Service 分配 IP 地址，当然该 IP 地址不是凭空产生的，需要用户在配置中提供一个 IP 地址池，Metallb 将会在其中选取地址分配给服务。</p><h3 id="外部声明">外部声明</h3><p>MetalLB 将 IP 分配给某个服务后，它需要对外宣告此 IP 地址，并让外部主机可以路由到此 IP。</p><p>MetalLB 支持两种声明模式：Layer 2（ ARP / NDP ）模式或者 BGP 模式。</p><ol><li>Layer 2 模式</li></ol><p><img src="https://kubernetes.github.io/ingress-nginx/images/baremetal/metallb.jpg" alt=""></p><p>在任何以太网环境均可使用该模式。当在第二层工作时，将有一台机器获得 IP 地址（即服务的所有权）。MetalLB 使用标准的地址发现协议（对于 IPv4 是 ARP，对于 IPv6 是 NDP）宣告 IP 地址，使其在本地网路中可达。从 LAN 的角度来看，仅仅是某台机器多配置了一个 IP 地址。</p><p>Layer 2 模式下，每个 Service 会有集群中的一个 Node 来负责。服务的入口流量全部经由单个节点，然后该节点的 Kube-Proxy 会把流量再转发给服务的 Pods。也就是说，该模式下 MetalLB 并没有真正提供负载均衡器。尽管如此，MetalLB 提供了故障转移功能，如果持有 IP 的节点出现故障，则默认 10 秒后即发生故障转移，IP 会被分配给其它健康的节点。</p><p>Layer 2 模式的优缺点：</p><ul><li><p>Layer 2 模式更为通用，不需要用户有额外的设备；</p></li><li><p>Layer 2 模式下存在单点问题，服务的所有入口流量经由单点，其网络带宽可能成为瓶颈；</p></li><li><p>由于 Layer 2 模式需要 ARP/NDP 客户端配合，当故障转移发生时，MetalLB 会发送 ARP 包来宣告 MAC 地址和 IP 映射关系的变化，地址分配略为繁琐。</p></li></ul><ol start="2"><li>BGP 模式</li></ol><p>当在第三层工作时，集群中所有机器都和你控制的最接近的路由器建立 BGP 会话，此会话让路由器能学习到如何转发针对 K8S 服务 IP 的数据包。</p><p>通过使用 BGP，可以实现真正的跨多节点负载均衡（需要路由器支持 multipath），还可以基于 BGP 的策略机制实现细粒度的流量控制。</p><p>具体的负载均衡行为和路由器有关，可保证的共同行为是：每个连接（TCP 或 UDP 会话）的数据包总是路由到同一个节点上。</p><p>BGP 模式的优缺点：</p><ul><li><p>不能优雅处理故障转移，当持有服务的节点宕掉后，所有活动连接的客户端将收到 Connection reset by peer ；</p></li><li><p>BGP 路由器对数据包的源 IP、目的 IP、协议类型进行简单的哈希，并依据哈希值决定发给哪个 K8S 节点。问题是 K8S 节点集是不稳定的，一旦（参与 BGP）的节点宕掉，很大部分的活动连接都会因为 rehash 而坏掉。</p></li></ul><p>BGP 模式问题的缓和措施：</p><ul><li><p>将服务绑定到一部分固定的节点上，降低 rehash 的概率。</p></li><li><p>在流量低的时段改变服务的部署。</p></li><li><p>客户端添加透明重试逻辑，当发现连接 TCP 层错误时自动重试。</p></li></ul><a id="more"></a><h2 id="部署-metallb">部署 MetalLB</h2><h3 id="环境要求">环境要求</h3><p>根据部署模式不同，MetalLB 可能需要以下环境：</p><ol><li><p>一个 Kubernetes 集群，运行 Kubernetes 1.13.0 或更高版本。</p></li><li><p>Kubernetes 集群的网络配置可以与 MetalLB 共存。</p></li><li><p>有一些提供给 MetalLB 分发的 IPv4 地址。</p></li><li><p>根据部署模式，可能需要一个或多个 BGP 的路由器 。</p></li></ol><p>MetalLB 目前支持网络插件范围</p><table><thead><tr><th>网络插件</th><th>兼容性</th></tr></thead><tbody><tr><td>Calico</td><td>部分支持（有附加文档）</td></tr><tr><td>Flannel</td><td>支持</td></tr><tr><td>Kube-router</td><td>不支持</td></tr><tr><td>Romana</td><td>支持（有附加文档）</td></tr><tr><td>Weave Net</td><td>支持</td></tr></tbody></table><blockquote><p>从 Kubernetes 1.9 开始, Kube-Proxy 除了支持默认的 Iptables 模式之外，还支持更高效的 IPVS 模式。MetalLB 可以在Kubenetes 1.13 或更高版本的 Kube-Proxy 中使用 IPVS 模式。但是,它尚未明确测试，因此风险自负。具体内容可参考：<a href="https://github.com/google/metallb/issues/153" target="_blank" rel="noopener">https://github.com/google/metallb/issues/153</a></p></blockquote><h3 id="安装-metallb">安装 MetalLB</h3><p>安装 MetalLB 一共有两种方法：使用 Kubernetes YAML 文件或使用 Helm 包管理器。</p><h4 id="使用-yaml-文件部署">使用 YAML 文件部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 目前 MetalLB 最新版本为 0.8.1</span><br><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;google&#x2F;metallb&#x2F;v0.8.1&#x2F;manifests&#x2F;metallb.yaml</span><br></pre></td></tr></table></figure><p>部署完成后，将在 <code>metallb-system</code> 命名空间下将 MetalLB 部署到集群。YAML 文件中主要包含以下一些组件：</p><ol><li><p><code>metallb-system/controller</code>，这是处理 <code>IP</code> 地址分配的控制器。</p></li><li><p><code>metallb-system/speakerdaemonset</code> 这是支持你选择协议以使服务可达的组件。</p></li><li><p><code>Controller</code> 和 <code>Speaker</code> 的 <code>Service Accounts</code>，以及组件需要运行的 <code>RBAC</code> 权限。</p></li></ol><blockquote><p>通过 YAML 安装文件部署并不包含 MetalLB 配置文件，但 MetalLB 的组件仍能启动，但在你定义和部署 <code>configmap</code> 之前将保持空闲状态 。</p></blockquote><h4 id="使用-helm-部署">使用 Helm 部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm install --name metallb stable&#x2F;metallb</span><br></pre></td></tr></table></figure><p>如果你还不知道什么是 Helm，可以先参考 <a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486154&amp;idx=1&amp;sn=becd5dd0fadfe0b6072f5dfdc6fdf786&amp;chksm=eac52be3ddb2a2f555b8b1028db97aa3e92d0a4880b56f361e4b11cd252771147c44c08c8913&amp;token=1182029777&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「Helm 入门指南」</a> 一文。</p><h2 id="配置-metallb">配置 MetalLB</h2><p>MetalLB 安装完成后，我们还需要根据具体的地址和通告方式配置名为 <code>metallb-system/config</code> 的 ConfigMap。Controller 会读取该 ConfigMap，并重新加载配置。</p><blockquote><p>通过 Helm 安装时，MetalLB 读取的 ConfigMap 名为 metallb-config 。</p></blockquote><h3 id="配置-metallb-为二层模式">配置 MetalLB 为二层模式</h3><p>第二层模式是最简单的配置方式：在许多情况下，您不需要任何特定于协议的配置，只需要 IP 地址。</p><p>第二层模式不要求将 IP 绑定到工作节点的网络接口。它的工作原理是直接响应本地网络上的 ARP 请求，将机器的 MAC 地址提供给客户端。</p><p>下面我们来看一个实际例子，我们将配置一个由 MetalLB 二层模式控制的外部 IP 段为 192.168.1.240 - 192.168.1.250。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat MetalLB-Layer2-Config.yaml</span><br><span class="line"></span><br><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: config</span><br><span class="line">  namespace: metallb-system</span><br><span class="line">data:</span><br><span class="line">  config: |</span><br><span class="line">    address-pools:</span><br><span class="line">    - name: default</span><br><span class="line">      protocol: layer2</span><br><span class="line">      addresses:</span><br><span class="line">      - 192.168.0.10-192.168.0.100</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的 IP 地址范围需要跟集群实际情况相对应。</p></blockquote><p>首先，我们使用 <code>kubectl apply -f MetalLB-Layer2-Config.yaml</code> 命令使配置生效。如果你想看到详细配置更新过程，可以使用以下类似命令查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs -f [metallb-controller-pod]</span><br><span class="line">或者　</span><br><span class="line">$ kubectl logs -l component&#x3D;speaker -n metallb-system</span><br></pre></td></tr></table></figure><p>接下来，我们来创建一个服务类型为 LoadBalancer 的 Nginx 服务来验证下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ cat nginx-test.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps&#x2F;v1beta2</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  type: LoadBalancer</span><br></pre></td></tr></table></figure><p>服务创建完成，运行 <code>kubectl apply -f nginx-test.yaml</code> 命令后，我们可以看到对应服务信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods nginx-68995d8957-bczhf -o wide</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE       </span><br><span class="line">nginx-68995d8957-bczhf   2&#x2F;2     Running   0          19d   10.244.0.78   ubuntu-1  </span><br><span class="line"></span><br><span class="line">$ kubectl get svc</span><br><span class="line">NAME    TYPE           CLUSTER-IP      EXTERNAL-IP    PORT(S)        AGE</span><br><span class="line">nginx   LoadBalancer   10.97.187.100   192.168.0.10   80:32353&#x2F;TCP   179m</span><br></pre></td></tr></table></figure><p>从输出结果，我们可以看到 LoadBalancer 类型的服务，并且分配的外部 IP 地址是地址池中的第一个 IP <code>192.168.0.10</code>。</p><p>最后，我们通过 <code>curl http://192.168.0.10</code> 命令来验证下，发现可以正常显示 Nginx 的欢迎信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;</span><br><span class="line">................</span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>至此，<code>MetalLB Layer 2</code> 模式的配置就结束了。</p><h3 id="配置-metallb-为-bgp-模式">配置 MetalLB 为 BGP 模式</h3><p>对于配置为具有一个 <code>BGP</code> 路由器和一个 IP 地址范围的 BGP 模式，你需要先准备好以下 4 条配置信息：</p><ol><li><p>MetalLB 应连接的路由器 IP 地址。</p></li><li><p>路由器的 AS 号。</p></li><li><p>MetalLB 应该使用的 AS 编号。</p></li><li><p>IP 地址范围，表示为 CIDR 前缀。</p></li></ol><p>由于这种配置方式需要具备 BGP 功能的硬件路由器支持，目前我们环境中不具备此等条件。这里就简单说下 MetalLB 对应的配置方式，具体内容就不展开讲解了。</p><p>由于前面已经安装了 MetalLB 的 <code>Controller</code> 和 <code>Speaker</code>，只是使用的是 Layer 2 模式。这里只需要改为 BGP 模式，我们修改 Configmap 中 Config 配置就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 假如要为 MetalLB 提供范围 192.168.9.0&#x2F;24 和 AS 号 65009，并将其连接到 192.168.0.1 的 AS 号为 65000 的路由器。</span><br><span class="line">$ cat MetalLB-BGP-Config.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  namespace: metallb-system</span><br><span class="line">  name: config</span><br><span class="line">data:</span><br><span class="line">  config: |</span><br><span class="line">    peers:</span><br><span class="line">    - peer-address: 192.168.0.1</span><br><span class="line">      peer-asn: 65000</span><br><span class="line">      my-asn: 65009</span><br><span class="line">    address-pools:</span><br><span class="line">    - name: default</span><br><span class="line">      protocol: bgp</span><br><span class="line">      addresses:</span><br><span class="line">      #- 192.168.0.10-192.168.0.100</span><br><span class="line">      - 192.168.9.0&#x2F;24</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>本文简单介绍了 MetalLB 的用途以及 MetalLB 的两种部署模式：Layer 2 模式和 BGP 模式。在实际应用中，如果条件满足，推荐使用 BGP 模式。</p><h2 id="参考资料">参考资料</h2><ol><li><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a></p></li><li><p><a href="https://blog.fleeto.us/post/intro-metallb/" target="_blank" rel="noopener">https://blog.fleeto.us/post/intro-metallb/</a></p></li><li><p><a href="https://ieevee.com/tech/2019/06/30/metallb.html" target="_blank" rel="noopener">https://ieevee.com/tech/2019/06/30/metallb.html</a></p></li><li><p><a href="https://blog.csdn.net/kunyus/article/details/88616653" target="_blank" rel="noopener">https://blog.csdn.net/kunyus/article/details/88616653</a></p></li><li><p><a href="https://vqiu.cn/metallb-si-you-ji-qun-loadbalancer/amp/" target="_blank" rel="noopener">https://vqiu.cn/metallb-si-you-ji-qun-loadbalancer/amp/</a></p></li><li><p><a href="https://sre.ink/metallb-kubernetes-loadbalancer-no-ipvs/" target="_blank" rel="noopener">https://sre.ink/metallb-kubernetes-loadbalancer-no-ipvs/</a></p></li><li><p><a href="https://blog.csdn.net/networken/article/details/85928369" target="_blank" rel="noopener">https://blog.csdn.net/networken/article/details/85928369</a></p></li><li><p><a href="https://blog.gmem.cc/external-lb-for-on-premise-k8s-cluster" target="_blank" rel="noopener">https://blog.gmem.cc/external-lb-for-on-premise-k8s-cluster</a></p></li><li><p><a href="https://leeif.me/2019/02/k8s-deploy-metallb-LoadBalancer.html" target="_blank" rel="noopener">https://leeif.me/2019/02/k8s-deploy-metallb-LoadBalancer.html</a></p></li><li><p><a href="https://mshk.top/2019/04/kubernetes-metallb-loadbalancer-nginx-ingress-controller/" target="_blank" rel="noopener">https://mshk.top/2019/04/kubernetes-metallb-loadbalancer-nginx-ingress-controller/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;私有云裸金属架构（这里是相对云上环境来说，不是说无操作系统）上部署的 Kubernetes 集群，通常是无法使用 LoadBalancer 类型的 Service 的。因为 Kubernetes 本身没有为裸机群集提供网络负载均衡器（类型为 LoadBalancer 的服务）的实现。如果你的 Kubernetes 集群没有在公有云的 IaaS 平台（GCP，AWS，Azure …）上运行，则 LoadBalancers 将在创建时无限期地保持 “挂起” 状态，也就是说只有公有云厂商自家的 Kubernetes 支持 LoadBalancer 。&lt;/p&gt;
&lt;p&gt;为了从外部访问裸机 Kubernetes 群集，目前只能使用 &lt;code&gt;NodePort&lt;/code&gt; 或 &lt;code&gt;Ingress&lt;/code&gt; 的方法进行服务暴露。前者的缺点是每个暴露的服务需要占用所有节点的某个端口，后者的缺点是仅仅能支持 &lt;code&gt;HTTP&lt;/code&gt; 协议。&lt;/p&gt;
&lt;h2 id=&quot;什么是-MetalLB&quot;&gt;什么是 MetalLB&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MetalLB&lt;/code&gt; 是一个负载均衡器，专门解决裸金属 Kubernetes 集群中无法使用 &lt;code&gt;LoadBalancer&lt;/code&gt; 类型服务的痛点。&lt;code&gt;MetalLB&lt;/code&gt; 使用标准化的路由协议，以便裸金属 Kubernetes 集群上的外部服务也尽可能地工作。即 MetalLB 能够帮助你在裸金属 Kubernetes 集群中创建 LoadBalancer 类型的 Kubernetes 服务，该项目发布于 2017 年底，当前处于 &lt;code&gt;Beta&lt;/code&gt; 阶段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/danderson/metallb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/danderson/metallb&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;MetalLB-工作原理&quot;&gt;MetalLB 工作原理&lt;/h2&gt;
&lt;p&gt;MetalLB 会在 Kubernetes 内运行，监控服务对象的变化，一旦监测到有新的 LoadBalancer 服务运行，并且没有可申请的负载均衡器之后，就会完成地址分配和外部声明两部分的工作。&lt;/p&gt;
&lt;h3 id=&quot;地址分配&quot;&gt;地址分配&lt;/h3&gt;
&lt;p&gt;在云环境中，当你请求一个负载均衡器时，云平台会自动分配一个负载均衡器的 IP 地址给你，应用程序通过此 IP 来访问经过负载均衡处理的服务。&lt;/p&gt;
&lt;p&gt;使用 MetalLB 时，MetalLB 会自己为用户的 LoadBalancer 类型 Service 分配 IP 地址，当然该 IP 地址不是凭空产生的，需要用户在配置中提供一个 IP 地址池，Metallb 将会在其中选取地址分配给服务。&lt;/p&gt;
&lt;h3 id=&quot;外部声明&quot;&gt;外部声明&lt;/h3&gt;
&lt;p&gt;MetalLB 将 IP 分配给某个服务后，它需要对外宣告此 IP 地址，并让外部主机可以路由到此 IP。&lt;/p&gt;
&lt;p&gt;MetalLB 支持两种声明模式：Layer 2（ ARP / NDP ）模式或者 BGP 模式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Layer 2 模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://kubernetes.github.io/ingress-nginx/images/baremetal/metallb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在任何以太网环境均可使用该模式。当在第二层工作时，将有一台机器获得 IP 地址（即服务的所有权）。MetalLB 使用标准的地址发现协议（对于 IPv4 是 ARP，对于 IPv6 是 NDP）宣告 IP 地址，使其在本地网路中可达。从 LAN 的角度来看，仅仅是某台机器多配置了一个 IP 地址。&lt;/p&gt;
&lt;p&gt;Layer 2 模式下，每个 Service 会有集群中的一个 Node 来负责。服务的入口流量全部经由单个节点，然后该节点的 Kube-Proxy 会把流量再转发给服务的 Pods。也就是说，该模式下 MetalLB 并没有真正提供负载均衡器。尽管如此，MetalLB 提供了故障转移功能，如果持有 IP 的节点出现故障，则默认 10 秒后即发生故障转移，IP 会被分配给其它健康的节点。&lt;/p&gt;
&lt;p&gt;Layer 2 模式的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Layer 2 模式更为通用，不需要用户有额外的设备；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Layer 2 模式下存在单点问题，服务的所有入口流量经由单点，其网络带宽可能成为瓶颈；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于 Layer 2 模式需要 ARP/NDP 客户端配合，当故障转移发生时，MetalLB 会发送 ARP 包来宣告 MAC 地址和 IP 映射关系的变化，地址分配略为繁琐。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;BGP 模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当在第三层工作时，集群中所有机器都和你控制的最接近的路由器建立 BGP 会话，此会话让路由器能学习到如何转发针对 K8S 服务 IP 的数据包。&lt;/p&gt;
&lt;p&gt;通过使用 BGP，可以实现真正的跨多节点负载均衡（需要路由器支持 multipath），还可以基于 BGP 的策略机制实现细粒度的流量控制。&lt;/p&gt;
&lt;p&gt;具体的负载均衡行为和路由器有关，可保证的共同行为是：每个连接（TCP 或 UDP 会话）的数据包总是路由到同一个节点上。&lt;/p&gt;
&lt;p&gt;BGP 模式的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不能优雅处理故障转移，当持有服务的节点宕掉后，所有活动连接的客户端将收到 Connection reset by peer ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BGP 路由器对数据包的源 IP、目的 IP、协议类型进行简单的哈希，并依据哈希值决定发给哪个 K8S 节点。问题是 K8S 节点集是不稳定的，一旦（参与 BGP）的节点宕掉，很大部分的活动连接都会因为 rehash 而坏掉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BGP 模式问题的缓和措施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将服务绑定到一部分固定的节点上，降低 rehash 的概率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在流量低的时段改变服务的部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端添加透明重试逻辑，当发现连接 TCP 层错误时自动重试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
</feed>
