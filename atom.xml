<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>运维之美</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2020-05-17T07:48:06.539Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>U 盘多系统安装盘制作神器 YUMI 使用教程</title>
    <link href="https://www.hi-linux.com/posts/23035.html"/>
    <id>https://www.hi-linux.com/posts/23035.html</id>
    <published>2020-05-17T01:00:00.000Z</published>
    <updated>2020-05-17T07:48:06.539Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>通常我们一个 U 盘只能制作成一个系统安装盘，比如制作好一个 <code>Windows 10</code> 安装盘，日后想要用到 <code>Linux</code>、<code>WinPE</code> 等安装盘时，只能重新制作一遍，非常浪费时间。而且现在 U 盘容量都很大，如果只放一个系统，同样就会白白浪费 U 盘剩余的空间。</p><p>今天，我们就给大家推荐一个可以让你的 U 盘制作成多系统安装盘的神器 <code>YUMI</code>。</p><p><code>YUMI</code> (<code>Your Universal Multiboot Integrator</code>) 是一款免费便携的 <code>USB</code> 多合一启动盘制作工具！它可以让你轻松将多款不同操作系统 <code>ISO</code> 镜像装到一个 U 盘里，制作出支持 <code>Multiboot</code> (多系统引导启动) 的多合一系统引导安装盘。</p><p><code>YUMI</code> 几乎支持全系列的 <code>Windows</code> 和 <code>Linux</code> 操作系统。比如 <code>Windows 10</code>、<code>Windows 7</code>、<code>WinPE</code>、<code>Windows To Go</code> 以及 <code>Linux</code> 的各种发行版。</p><blockquote><p>官网：<a href="https://www.pendrivelinux.com/yumi-multiboot-usb-creator/" target="_blank" rel="noopener">https://www.pendrivelinux.com/yumi-multiboot-usb-creator/</a></p></blockquote><a id="more"></a><h2 id="安装-yumi">安装 YUMI</h2><p><code>YUMI</code> 目前只支持 <code>Windows</code> 和 <code>Linux</code> 平台，共分为 <code>Legacy</code> 和 <code>UEFI</code> 两个版本，请根据自己 <code>BIOS</code> 实际引导情况选择下载。</p><ol><li>Windows 平台</li></ol><p><code>Windows</code> 安装非常简单，基本开箱即用，这里就不多赘述了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Legacy 版本下载地址</span><br><span class="line">https:&#x2F;&#x2F;www.pendrivelinux.com&#x2F;downloads&#x2F;YUMI&#x2F;YUMI-2.0.6.9.exe</span><br><span class="line"></span><br><span class="line"># UEFI 版本下载地址</span><br><span class="line">https:&#x2F;&#x2F;www.pendrivelinux.com&#x2F;downloads&#x2F;YUMI&#x2F;YUMI-UEFI-0.0.1.9.exe</span><br></pre></td></tr></table></figure><ol start="2"><li>Linux 平台</li></ol><p><code>Linux</code> 下安装相对就比较麻烦了，具体可以参考下官方文档。如果没什么必要，还是建议直接在 <code>Windows</code> 平台上使用。怎么简单怎么来嘛，反正平时用得也不多，哈哈！。</p><blockquote><p><a href="https://www.pendrivelinux.com/yumi-multiboot-usb-creator#HowTo" target="_blank" rel="noopener">https://www.pendrivelinux.com/yumi-multiboot-usb-creator#HowTo</a></p></blockquote><h2 id="使用-yumi-制作多系统启动盘">使用 YUMI 制作多系统启动盘</h2><p>使用 <code>YUMI</code> 制作多合一系统安装盘非常简单。插上 U  盘，运行 <code>YUMI</code> 软件后。制作系统安装盘一共只要以下 4 步：</p><ul><li><p>第一步：选择需要制作 U 盘的盘符。</p></li><li><p>第二步：选择你将要制作安装盘系统的名称。</p></li><li><p>第三步：选择你事先下载好的该系统对应的 <code>ISO</code> 镜像的安装文件。</p></li><li><p>第四步：最后，按下 「<code>Create</code>」后即开始制作。</p></li></ul><p><img src="https://i.loli.net/2019/10/25/cxpo3CA8ETsDRKw.png" alt=""></p><blockquote><p>注意: <code>YUMI</code> 每次只能制作一个系统的安装盘，如果你要制作多个系统，只需重复执行多次上述的步骤来增加其它操作系统即可。</p></blockquote><h2 id="使用-yumi-引导多系统">使用 YUMI 引导多系统</h2><p>系统安装盘制作完成后，在电脑 <code>BIOS</code> 设置 U 盘为开机启动后，就能直接进入 <code>YUMI</code> 的 <code>Miltiboot</code> 引导界面。</p><p><img src="https://www.pendrivelinux.com/wp-content/uploads/YUMI-Boot-Menu.png" alt=""></p><p>然后，你只需要选择自己需要的系统就可以开始安装。</p><h2 id="删除已制作好的操作系统">删除已制作好的操作系统</h2><p>按上述的步骤制作好多重启动盘之后，如果你需要删除其中的一个或者多个系统，那么你只需重新运行 <code>YUMI</code>，然后勾选右上方的「<code>You're in Uninstaller Model</code>」即可在下方列表中看到当前 U 盘里的系统。</p><p><img src="https://i.loli.net/2019/10/25/yPiRChIwKEoaQcs.png" alt=""></p><p>接下来，你只需在列表中选择不想要的操作系统后，点击「Remove」就可以删除它了。如需删除多个系统，重复多遍以上操作即可。</p><h2 id="总结">总结</h2><p>对于经常需要装机、制作系统安装盘的同学来说，<code>YUMI</code> 无疑是一个相当强大好用的工具。如果你想要制作一个集 <code>Windows 10</code>、<code>WinPE</code> 和 <code>Linux</code> 系统于一身、方便用于维护和装机的多合一系统安装盘，那么操作如此简单的 <code>YUMI</code> 值得你拥有！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://www.iplaysoft.com/yumi.html" target="_blank" rel="noopener">https://www.iplaysoft.com/yumi.html</a></p></li><li><p><a href="https://blog.shiyunhong.com/3012.html" target="_blank" rel="noopener">https://blog.shiyunhong.com/3012.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常我们一个 U 盘只能制作成一个系统安装盘，比如制作好一个 &lt;code&gt;Windows 10&lt;/code&gt; 安装盘，日后想要用到 &lt;code&gt;Linux&lt;/code&gt;、&lt;code&gt;WinPE&lt;/code&gt; 等安装盘时，只能重新制作一遍，非常浪费时间。而且现在 U 盘容量都很大，如果只放一个系统，同样就会白白浪费 U 盘剩余的空间。&lt;/p&gt;
&lt;p&gt;今天，我们就给大家推荐一个可以让你的 U 盘制作成多系统安装盘的神器 &lt;code&gt;YUMI&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YUMI&lt;/code&gt; (&lt;code&gt;Your Universal Multiboot Integrator&lt;/code&gt;) 是一款免费便携的 &lt;code&gt;USB&lt;/code&gt; 多合一启动盘制作工具！它可以让你轻松将多款不同操作系统 &lt;code&gt;ISO&lt;/code&gt; 镜像装到一个 U 盘里，制作出支持 &lt;code&gt;Multiboot&lt;/code&gt; (多系统引导启动) 的多合一系统引导安装盘。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YUMI&lt;/code&gt; 几乎支持全系列的 &lt;code&gt;Windows&lt;/code&gt; 和 &lt;code&gt;Linux&lt;/code&gt; 操作系统。比如 &lt;code&gt;Windows 10&lt;/code&gt;、&lt;code&gt;Windows 7&lt;/code&gt;、&lt;code&gt;WinPE&lt;/code&gt;、&lt;code&gt;Windows To Go&lt;/code&gt; 以及 &lt;code&gt;Linux&lt;/code&gt; 的各种发行版。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://www.pendrivelinux.com/yumi-multiboot-usb-creator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.pendrivelinux.com/yumi-multiboot-usb-creator/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="YUMI" scheme="https://www.hi-linux.com/tags/YUMI/"/>
    
  </entry>
  
  <entry>
    <title>史上最全的高性能代理服务器 Envoy 中文实战教程</title>
    <link href="https://www.hi-linux.com/posts/57326.html"/>
    <id>https://www.hi-linux.com/posts/57326.html</id>
    <published>2020-05-17T01:00:00.000Z</published>
    <updated>2020-05-17T07:48:06.543Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-envoy">什么是 Envoy</h2><p><code>Envoy</code> 是一款 <code>CNCF</code> 旗下的开源项目，由 <code>Lyft</code> 开源。<code>Envoy</code> 采用 C++ 实现，是面向 <code>Service Mesh</code> 的高性能网络代理服务。它与应用程序并行运行，通过以平台无关的方式提供通用功能来抽象网络。当基础架构中的所有服务流量都通过 Envoy 网格时，通过一致的可观测性，很容易地查看问题区域，调整整体性能。</p><p><code>Envoy</code> 也是 <code>Istio Service Mesh</code> 中默认的 <code>Data Plane</code>，本文我们将讲解 <code>Envoy</code> 的一些基本概念，并采用一些实例来介绍如何在本地环境中快速使用 <code>Envoy</code> 作为 <code>Service Mesh</code> 的数据平面，以帮助读者理解 <code>Istio</code> 的 <code>Data Panel</code> 层实现。</p><blockquote><p>官网：<a href="https://www.envoyproxy.io" target="_blank" rel="noopener">https://www.envoyproxy.io</a></p></blockquote><h3 id="envoy-特性">Envoy 特性</h3><ol><li>整体架构</li></ol><p><img src="https://ws1.sinaimg.cn/large/4483e99egy1ftn7wet57fj233f1utag1.jpg" alt=""></p><ol start="2"><li>进程无关架构</li></ol><p><code>Envoy</code> 是一个自组织的模块，与应用 <code>Server</code> 并无直接依赖。所有的 <code>Envoy</code> 构建了一个透明的服务网格 <code>Service Mesh</code>，处于其中的应用只需要简单的与本地的 <code>Envoy</code> 进行收发信息，并不需要关注整个网络拓扑。这种架构对于应用通信有两大好处：</p><ul><li><p><code>Envoy</code> 可以让任何的编程语言编写的服务通信，协同工作，<code>Envoy</code> 帮你屏蔽了服务之间的沟壑。</p></li><li><p>任何曾经在大型微服务开发中工作过的人都知道发布一个库更新是多么的痛苦。<code>Envoy</code> 可以以一种透明的方式快速的发布更新整个基础架构中的版本。</p></li></ul><a id="more"></a><ol start="3"><li>高级负载均衡</li></ol><p>分布式系统中不同模块间的负载均衡是一个复杂的问题。因为 <code>Envoy</code> 是一个自组织的代理，所以它能在一个地方实现高级负载均衡技术并使他们可被访问。当前 <code>Envoy</code> 支持自动重试、断路器、全局限速、阻隔请求、异常检测，将来还会支持按计划进行请求速率控制。</p><ol start="4"><li>动态配置</li></ol><p><code>Envoy</code> 提供了可选的一系列的分层的动态配置 <code>API</code>，使用这些 <code>API</code> 可以构建出复杂的集中式部署管理。</p><ol start="5"><li>正向代理支持</li></ol><p>虽然 <code>Envoy</code> 设计初衷是服务和服务之间通信系统，得益于其监视、管理、服务发现和负载均衡算法的实现，<code>Enovy</code> 包含了足够多的特性为绝大多数 <code>Web</code> 服务做正向代理。</p><p>除了这些之外还有对 <code>HTTP/2</code> 的支持，<code>L3</code>、<code>L4</code>、<code>L7</code> 代理，可以实现 <code>TCP Proxy</code>、<code>HTTP Proxy</code> 等功能。</p><ol start="6"><li>线程模型</li></ol><p><code>Envoy</code> 使用单进程多线程架构，其中一个扮演主线程的控制各种协调任务，而一些工作线程负责监听、过滤和转发。一旦某个链接被监听器 <code>Listener</code> 接受，那么这个链接将会剩余的生命周期绑定在这个 <code>Woker</code> 线程。这种架构会使得大部分工作工作在单线程的情况下，只有少量的工作会涉及到线程间通信，<code>Envoy</code> 代码是 100% 非阻塞的。</p><ol start="7"><li>Listener 监听器</li></ol><ul><li><p>一个 <code>Envoy</code> 进程可以设置多个不同的 <code>Listener</code>，建议一台机器只使用一个 <code>Envoy</code> 实例。</p></li><li><p>每一个 <code>Listener</code> 的网络层 <code>L3/L4</code> 过滤器是独立配置的。并且一个 <code>Listener</code> 是可以通过配置来完成多种任务的，比如：访问限制、TLS 客户端校验、HTTP 链接管理等。</p></li><li><p><code>Listener</code> 也有自己的非网络层过滤器，它可以修改链接的 <code>Metadata</code> 信息，通常用来影响接下来链接是如何被网络层过滤器处理的。</p></li><li><p>无论网络层过滤器还是 <code>Listener</code> 过滤器都可以提前终止后续的过滤器链的执行。</p></li></ul><ol start="8"><li>HTTP 连接管理器</li></ol><ul><li><p><code>Envoy</code> 是完整支持 <code>HTTP/1.1</code>、<code>Websockets</code> 和 <code>HTTP/2</code>，不支持 <code>SPDY</code>。</p></li><li><p>这层过滤器主要是将原始的传递数据转变成 <code>HTTP</code> 层级的信息和事件，如收到 <code>Headers</code>、收到 <code>Body</code> 数据，同样它也可以做接入日志、<code>Request ID</code> 生成和追踪、<code>Req/Res</code> 头部修改工作、路由表管理、统计分析。</p></li><li><p>每一个 <code>HTTP</code> 链接管理器有一个相匹配的路由表，路由表可以静态指定，也可以动态地通过 <code>RDS API</code> 来设置 <code>route-dynamic</code>。</p></li><li><p>其内部还有 <code>HTTP</code> 过滤器，可以支持在 <code>HTTP</code> 层级。在无需关注使用什么协议 (<code>HTTP/1.1</code> 或 <code>HTTP/2</code>) 实现的情况下进行操作 <code>HTTP</code> 内容，支持 <code>Encode</code>、<code>Decode</code>、<code>Encode/Decode</code> 三种不同类型过滤器。</p></li></ul><ol start="9"><li>HTTP 路由器</li></ol><ul><li><p>经常用在做边缘/反向代理和构建内部 <code>Envoy Mesh</code> 发挥巨大作用。</p></li><li><p><code>HTTP</code> 路由器可以支持请求重试配置：最大重试次数和设置重试条件，比如某些 <code>5XX</code> 错误和具有幂等性操作的 <code>4XX</code> 错误。</p></li><li><p><code>Envoy</code> 自己使用 <code>HTTP/2</code> 链接管理器实现了 <code>gRPC</code> 协议，将原来官方的 <code>Google gRPC</code> 内置的很多功能，比如重试、超时、<code>Endpoint</code> 发现、负载均衡、负载报告、健康检查等功能都实现了。将来除非特殊特性必须，都可以使用 <code>Envoy gRPC</code> 来实现。</p></li></ul><ol start="10"><li>Cluster 管理器</li></ol><p><code>Cluster</code> 管理器暴露 <code>API</code> 给过滤器，并允许过滤器可以得到链接到上游集群的 <code>L3/L4</code> 链接或者维持一个抽象的 <code>HTTP</code> 连接池用来链接上游集群（上游主机支持 <code>HTTP 1.1</code> 还是 <code>HTTP 2</code> 都是被隐藏的）。过滤器决定是使用 <code>L3/L4</code> 链接还是 <code>HTTP Stream</code> 来链接上游集群。而对于集群管理器来说，它负责所有集群内主机的可用性、负载均衡、健康度、线程安全的上游链接数据，上游链接类型 <code>TCP/UP</code>、<code>UDS</code>，上游可接受的协议 <code>HTTP 1.1/2</code>。</p><p><code>Cluster</code> 管理器既可以静态配置，也可以使用 <code>CDS-Cluster-Discovery-Service API</code> 来动态配置。 集群在正式使用之前有一个 “加热” <code>Warming</code> 的过程：先做服务发现必要的初始化，比如 <code>DNS</code> 记录更新、<code>EDS</code> 更新，然后进行健康检查，当进行完上述的过程，会进入<code>Becoming available</code> 状态，这个阶段 <code>Envoy</code> 不会把流量指向它们; 在更新集群时，也不会把正在处理流量的集群处理掉，而是用新的去替换老的那些还未进行任何流量的集群。</p><ol start="11"><li>与 Nginx 的区别</li></ol><ul><li><p><code>Envoy</code> 对 <code>HTTP/2</code> 的支持比 <code>Nginx</code> 更好，支持包括 <code>upstream</code> 和 <code>downstream</code> 在内的双向通信，而 <code>Nginx</code> 只支持 <code>downstream</code> 的连接。</p></li><li><p>高级负载均衡功能是免费的，<code>Nginx</code> 的高级负载均衡功能则需要付费的 <code>Nginx Plus</code> 支持。</p></li><li><p><code>Envoy</code> 支持热更新，<code>Nginx</code> 配置更新之后需要 <code>Reload</code>。</p></li><li><p><code>Envoy</code> 更贴近 <code>Service Mesh</code> 的使用习惯，<code>Nginx</code> 更贴近传统服务的使用习惯。</p></li></ul><h3 id="envoy-术语">Envoy 术语</h3><p>要深入理解 <code>Envoy</code>，首先需要先了解一下 <code>Envoy</code> 中的一些术语。</p><p><img src="https://ws1.sinaimg.cn/large/4483e99egy1fto85kdq0wj20lo0b2wej.jpg" alt=""></p><ul><li><p><code>Host</code>：能够进行网络通信的实体（如服务器上的应用程序）。</p></li><li><p><code>Downstream</code>：下游主机连接到 <code>Envoy</code>，发送请求并接收响应。</p></li><li><p><code>Upstream</code>：上游主机接收来自 <code>Envoy</code> 连接和请求并返回响应。</p></li><li><p><code>Listener</code>：可以被下游客户端连接的命名网络（如端口、<code>Unix</code> 套接字）。一般是每台主机运行一个 <code>Envoy</code>，使用单进程运行，但是每个进程中可以启动任意数量的 <code>Listener</code>（监听器），每个监听器都独立配置一定数量的（ <code>L3/L4</code> ）网络过滤器。</p></li><li><p><code>Cluster</code>：<code>Envoy</code> 连接到的一组逻辑上相似的上游主机。</p></li><li><p><code>Mesh</code>：以提供一致的网络拓扑的一组主机。</p></li><li><p><code>Runtime Configuration</code>：与 <code>Envoy</code> 一起部署的外置实时配置系统。</p></li><li><p><code>Listener Filter</code>：<code>Listener</code> 使用 <code>Listener Filter</code>（监听器过滤器）来操作链接的元数据，它的作用是在不更改 <code>Envoy</code> 的核心功能的情况下添加更多的集成功能。</p></li><li><p><code>Http Route Table</code>：<code>HTTP</code> 的路由规则，例如请求的域名，<code>Path</code> 符合什么规则，转发给哪个 <code>Cluster</code>。</p></li></ul><h2 id="部署-envoy">部署 Envoy</h2><p>官方提供了 <code>Envoy</code> 的 <code>Docker</code> 镜像，直接下载对应镜像即可使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull envoyproxy&#x2F;envoy:latest</span><br></pre></td></tr></table></figure><p>镜像中已经将 Envoy 安装到 <code>/usr/local/bin</code> 目录下，可以先看看 <code>Envoy</code> 进程的帮助信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;usr&#x2F;local&#x2F;bin&#x2F;envoy --help</span><br><span class="line">USAGE: </span><br><span class="line">   &#x2F;usr&#x2F;local&#x2F;bin&#x2F;envoy  [--disable-hot-restart] [--max-obj-name-len</span><br><span class="line">                         &lt;uint64_t&gt;] [--max-stats &lt;uint64_t&gt;] [--mode</span><br><span class="line">                         &lt;string&gt;] [--parent-shutdown-time-s &lt;uint32_t&gt;]</span><br><span class="line">                         [--drain-time-s &lt;uint32_t&gt;]</span><br><span class="line">                         [--file-flush-interval-msec &lt;uint32_t&gt;]</span><br><span class="line">                         [--service-zone &lt;string&gt;] [--service-node</span><br><span class="line">                         &lt;string&gt;] [--service-cluster &lt;string&gt;]</span><br><span class="line">                         [--hot-restart-version] [--restart-epoch</span><br><span class="line">                         &lt;uint32_t&gt;] [--log-path &lt;string&gt;] [--log-format</span><br><span class="line">                         &lt;string&gt;] [-l &lt;string&gt;]</span><br><span class="line">                         [--local-address-ip-version &lt;string&gt;]</span><br><span class="line">                         [--admin-address-path &lt;string&gt;] [--v2-config-only]</span><br><span class="line">                         [--config-yaml &lt;string&gt;] [-c &lt;string&gt;]</span><br><span class="line">                         [--concurrency &lt;uint32_t&gt;] [--base-id &lt;uint32_t&gt;]</span><br><span class="line">                         [--] [--version] [-h]</span><br></pre></td></tr></table></figure><p><code>Envoy</code> 进程启动的时候需要指定一些参数，其中最重要的是 <code>--config-yaml</code> 参数，用于指定 <code>Envoy</code> 进程启动的时候需要读取的配置文件地址。<code>Docker</code> 中配置文件默认是放在 <code>/etc/envoy</code> 目录下，配置文件的文件名是 <code>envoy.yaml</code>。所以我们在启动容器的时候需要将自定义的 <code>envoy.yaml</code> 配置文件挂载到指定目录下替换掉默认的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;usr&#x2F;local&#x2F;bin&#x2F;envoy -c &lt;path to config&gt;.&#123;json,yaml,pb,pb_text&#125; --v2-config-only</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>Envoy</code> 默认的日志级别是 <code>info</code>，对于开发阶段需要进行调试的话，调整日志级别到 <code>Debug</code> 是非常有用的。你可以在启动参数中添加 <code>-l debug</code> 来将日志级别进行切换。</p></blockquote><h2 id="编写-envoy-配置文件">编写 Envoy 配置文件</h2><p>在介绍 <code>Envoy</code> 的配置文件之前，先介绍一下 <code>Envoy</code> 的 <code>API</code>。<code>Envoy</code> 提供了两个版本的 <code>API</code>，<code>V1</code> 和 <code>V2</code> 版本 <code>API</code>。现阶段 <code>V1</code> 版本已经不建议使用了，通常都是使用 <code>V2</code> 的 <code>API</code>。</p><p><code>V2</code> 的 <code>API</code> 提供了两种方式的访问，一种是 <code>HTTP Rest</code> 的方式访问，还有一种 <code>GRPC</code> 的访问方式。关于 <code>GRPC</code> 的介绍可以参考官方文档，在后面的文章中只实现了 <code>GRPC</code> 的 <code>API</code>。</p><p><code>Envoy</code> 的启动配置文件分为两种方式：静态配置和动态配置。</p><p>静态配置是将所有信息都放在配置文件中，启动的时候直接加载。</p><p>动态配置需要提供一个 <code>Envoy</code> 的服务端，用于动态生成 <code>Envoy</code> 需要的服务发现接口，这里叫 <code>XDS</code> ，通过发现服务来动态的调整配置信息，<code>Istio</code> 就是实现了 <code>V2</code> 的 <code>API</code>。</p><h3 id="静态配置">静态配置</h3><p>以一个最简化的静态配置来做示例，体验一下 <code>Envoy</code>。</p><p>下面是 <code>envoy.yaml</code>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">admin:</span><br><span class="line">  access_log_path: &#x2F;tmp&#x2F;admin_access.log</span><br><span class="line">  address:</span><br><span class="line">    socket_address: &#123; address: 127.0.0.1, port_value: 9901 &#125;</span><br><span class="line"></span><br><span class="line">static_resources:</span><br><span class="line">  listeners:</span><br><span class="line">  - name: listener_0</span><br><span class="line">    address:</span><br><span class="line">      socket_address: &#123; address: 0.0.0.0, port_value: 10000 &#125;</span><br><span class="line">    filter_chains:</span><br><span class="line">    - filters:</span><br><span class="line">      - name: envoy.http_connection_manager</span><br><span class="line">        config:</span><br><span class="line">          stat_prefix: ingress_http</span><br><span class="line">          codec_type: AUTO</span><br><span class="line">          route_config:</span><br><span class="line">            name: local_route</span><br><span class="line">            virtual_hosts:</span><br><span class="line">            - name: local_service</span><br><span class="line">              domains: [&quot;*&quot;]</span><br><span class="line">              routes:</span><br><span class="line">              - match: &#123; prefix: &quot;&#x2F;&quot; &#125;</span><br><span class="line">                route: &#123; cluster: some_service &#125;</span><br><span class="line">          http_filters:</span><br><span class="line">          - name: envoy.router</span><br><span class="line">  clusters:</span><br><span class="line">  - name: some_service</span><br><span class="line">    connect_timeout: 0.25s</span><br><span class="line">    type: STATIC</span><br><span class="line">    lb_policy: ROUND_ROBIN</span><br><span class="line">    hosts: [&#123; socket_address: &#123; address: 127.0.0.1, port_value: 80 &#125;&#125;]</span><br></pre></td></tr></table></figure><p>在此基础上启动两个容器，<code>envoyproxy</code> 容器和 <code>nginx</code> 容器，<code>nginx</code> 容器共享 <code>envoyproxy</code> 容器的网络，以此来模拟 <code>Sidecar</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 10000:10000 -v &#96;pwd&#96;&#x2F;envoy.yaml:&#x2F;etc&#x2F;envoy&#x2F;envoy.yaml --name envoyproxy envoyproxy&#x2F;envoy:latest</span><br><span class="line">$ docker run -d --network&#x3D;container:envoyproxy --name nginx nginx</span><br></pre></td></tr></table></figure><p>根据配置文件的规则，<code>Envoy</code> 监听在 <code>10000</code> 端口，同时该端口也在宿主机的 <code>10000</code> 端口上暴露出来。当有请求到达监听上后，<code>Envoy</code> 会对所有请求路由到 <code>some_service</code> 这个 <code>Cluster</code> 上，而该 <code>Cluster</code> 的 <code>Upstream</code> 指向本地的 <code>80</code> 端口，也就是 <code>Nginx</code> 服务上。</p><p><img src="https://upload-images.jianshu.io/upload_images/12196676-5550ffdbe14a2d0c.png" alt=""></p><h3 id="动态配置">动态配置</h3><p>动态配置可以实现全动态，即实现 <code>LDS</code> (<code>Listener Discovery Service</code>)、<code>CDS</code> (<code>Cluster Discovery Service</code>)、<code>RDS</code> (<code>Route Discovery Service</code>)、<code>EDS</code> (<code>Endpoint Discovery Service</code>)，以及 <code>ADS</code> (<code>Aggregated Discovery Service</code>)。</p><p><code>ADS</code> 不是一个实际意义上的 <code>XDS</code>，它提供了一个汇聚的功能，以实现需要多个同步 <code>XDS</code> 访问的时候可以在一个 <code>Stream</code> 中完成的作用。</p><p>下面的图通过在静态配置的基础上，比较直观的表示出各个发现服务所提供的信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/12196676-1927da1e7ee7bb65.png" alt=""></p><p>由此，典型的动态配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">admin:</span><br><span class="line">  access_log_path: &#x2F;tmp&#x2F;admin_access.log</span><br><span class="line">  address:</span><br><span class="line">    socket_address: &#123; address: 127.0.0.1, port_value: 9901 &#125;</span><br><span class="line"></span><br><span class="line">dynamic_resources:</span><br><span class="line">  cds_config:</span><br><span class="line">    ads: &#123;&#125;</span><br><span class="line">  lds_config:</span><br><span class="line">    ads: &#123;&#125;</span><br><span class="line">  ads_config:</span><br><span class="line">    api_type: GRPC</span><br><span class="line">    cluster_names: [xds_cluster]</span><br><span class="line"></span><br><span class="line">static_resources:</span><br><span class="line">  clusters:</span><br><span class="line">  - name: xds_cluster</span><br><span class="line">    connect_timeout: 0.25s</span><br><span class="line">    type: STRICT_DNS</span><br><span class="line">    lb_policy: ROUND_ROBIN</span><br><span class="line">    http2_protocol_options: &#123;&#125;</span><br><span class="line">    hosts: [&#123; socket_address: &#123; address: envoy-server, port_value: 50051 &#125;&#125;]</span><br></pre></td></tr></table></figure><blockquote><p>注意：动态配置和静态配置最大的区别在于，启动的时候一定要指定 <code>cluster</code> 和 <code>id</code>，这两个参数表示该 Envoy 进程属于哪个 <code>Cluster</code>，<code>id</code> 要求在相同的 <code>Cluster</code> 下唯一，以表示不同的指向发现服务的连接信息。这两个参数可以在 <code>Envoy</code> 的启动命令中添加<code>--service-cluster</code> 和 <code>--service-node</code> 来指定，也可以在 <code>envoy.yaml</code> 配置文件中指定 <code>node.cluster</code> 和 <code>node.id</code>。</p></blockquote><h2 id="envoy-使用实例">Envoy 使用实例</h2><h3 id="入门实例">入门实例</h3><p>了解一个开源软件，从官方实例入手再好不过了，因此下面的例子将会围绕官方仓库中的实例展开。所以在开始之前，你需要安装并配置以下工具：</p><ul><li><code>Docker</code></li><li><code>Docker Compose</code></li><li><code>Git</code></li><li><code>Curl</code></li></ul><p>我们将会使用 <code>Docker</code> 和 <code>Docker Compose</code> 来构建和运行几个 <code>Envoy</code> 示例服务，并用 <code>Curl</code> 来检测 <code>Envoy</code> 示例服务是否在运行。</p><h4 id="运行-envoy">运行 Envoy</h4><p>首先克隆 <code>Envoy</code> 官方仓库到本地,并定位到 <code>envoy/examples/front-proxy</code> 文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;envoyproxy&#x2F;envoy</span><br><span class="line">$ cd envoy&#x2F;examples&#x2F;front-proxy</span><br></pre></td></tr></table></figure><p><code>front-proxy</code> 文件夹中的服务是一个用 <code>Flask</code> 实现的后端服务，入口文件在 <code>service.py</code> 文件里面。<code>Envoy</code> 作为一个 <code>Sidecar</code> 部件，将与 <code>service.py</code> 在同一个容器中运行，并由 <code>docker-compose,.yaml</code> 文件配置。</p><p>前端代理比后端服务更简单，它使用配置文件 <code>front-envoy.yaml</code> 来运行 <code>Envoy</code>。<code>Dockerfile-frontenvoy</code> 文件则是 <code>front-envoy</code> 的 <code>Dockerfile</code>。</p><p>如果你之前没有接触过 <code>Docker</code> 的话，你可以使用以下命令在本地构建并运行 <code>front-proxy</code> 的 <code>Docker</code> 镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;path&#x2F;to&#x2F;envoy&#x2F;examples&#x2F;front-proxy</span><br><span class="line">$ docker-compose up --build -d</span><br></pre></td></tr></table></figure><p>其中的 <code>--build</code> 表示构建镜像， <code>-d</code> 表示在后台运行所有 <code>docker-compose</code> 配置文件中定义的镜像，具体可参考 <code>Docker</code> 相关文档。</p><p>命令运行成功后，将会启动一个前端代理和两个服务实例：<code>service1</code> 和 <code>service2</code>。你可以通过以下命令来验证容器是否正常运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose ps</span><br></pre></td></tr></table></figure><p>正常的话会返回以下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ front-proxy git:(master) docker-compose ps</span><br><span class="line">          Name                         Command               State                            Ports</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">front-proxy_front-envoy_1   &#x2F;usr&#x2F;bin&#x2F;dumb-init -- &#x2F;bin ...   Up      10000&#x2F;tcp, 0.0.0.0:8000-&gt;80&#x2F;tcp, 0.0.0.0:8001-&gt;8001&#x2F;tcp</span><br><span class="line">front-proxy_service1_1      &#x2F;bin&#x2F;sh -c &#x2F;usr&#x2F;local&#x2F;bin&#x2F; ...   Up      10000&#x2F;tcp, 80&#x2F;tcp</span><br><span class="line">front-proxy_service2_1      &#x2F;bin&#x2F;sh -c &#x2F;usr&#x2F;local&#x2F;bin&#x2F; ...   Up      10000&#x2F;tcp, 80&#x2F;tcp</span><br></pre></td></tr></table></figure><h4 id="测试服务是否连通">测试服务是否连通</h4><p>你可以使用 <code>curl</code> 或者浏览器来测试服务是否在正常运行</p><p>浏览器中输入 <code>http://localhost:8000/service/1</code> 或者使用以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;localhost:8000&#x2F;service&#x2F;1</span><br></pre></td></tr></table></figure><p>如果返回结果是像下面这样，则表示 <code>service1</code> 的 <code>Envoy</code> 服务正常运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello from behind Envoy (service 1)! hostname: a841ffceafd0 resolvedhostname: 172.18.0.4</span><br></pre></td></tr></table></figure><p>你也可以用同样的方法测试 <code>service 2</code> 的服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;localhost:8000&#x2F;service&#x2F;2</span><br></pre></td></tr></table></figure><p>返回的结果和 <code>service 1</code> 类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello from behind Envoy (service 2)! hostname: e83b35c6f4fe resolvedhostname: 172.18.0.3 。</span><br></pre></td></tr></table></figure><h4 id="envoy-配置">Envoy 配置</h4><p>下面我们先简单看一下 <code>Envoy</code> 的静态配置信息，之后再继续看 <code>Demo</code> 中的动态配置信息。</p><p>我们先从 <code>front-envoy.yml</code> 入手。打开文件之后，我们会发现这个 <code>yaml</code> 有两个最高的层级，分别是 <code>static_resources</code> 和 <code>admin</code> 。<code>admin</code> 的内容相对比较简单，总共只有六行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">admin:</span><br><span class="line">   access_log_path: &quot;&#x2F;dev&#x2F;null&quot;</span><br><span class="line">   address:</span><br><span class="line">     socket_address:</span><br><span class="line">       address: 0.0.0.0</span><br><span class="line">       port_value: 8001</span><br></pre></td></tr></table></figure><p>其中 <code>access_log_path</code> 字段值是 <code>/dev/null</code>，其含义是 <code>admin</code> 服务的请求日志将不会被保存。生产环境中可自行将目标目录指定到需要的地方。<code>address</code> 和 <code>port_value</code> 字段分别表示 <code>admin server</code> 运行的 <code>IP</code> 端口。</p><p><code>static_resource</code> 的内容定义了非动态管理的集群（<code>Cluster</code>）和监听器（<code>Listener</code>）相关配置。集群是 <code>Envoy</code> 连接到的一组逻辑上相似的上游主机，一个集群是一组被定义的 <code>ip/port</code> 集合，<code>Envoy</code> 将借此实现负载均衡。监听器是一组被定义的网络地址，它是可以由下游客户端连接的命名网络位置（例如，端口、<code>Unix</code> 域套接字等）。监听器是服务(程序)监听者，就是真正干活的，客户端可借此连接至服务。</p><p><code>front proxy</code> 中只有一个监听器，监听器中除了 <code>socket_address</code> 之外还有一个字段是 <code>filter_chains</code>，<code>Envoy</code> 通过此字段来管理 <code>HTTP</code> 的连接和过滤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">listeners:</span><br><span class="line">- address:</span><br><span class="line">    socket_address:</span><br><span class="line">      address: 0.0.0.0</span><br><span class="line">      port_value: 80</span><br><span class="line">  filter_chains:</span><br><span class="line">  - filters:</span><br><span class="line">    - name: envoy.http_connection_manager</span><br><span class="line">      config:</span><br><span class="line">        codec_type: auto</span><br><span class="line">        stat_prefix: ingress_http</span><br><span class="line">        route_config:</span><br><span class="line">          name: local_route</span><br></pre></td></tr></table></figure><p>其中有个配置选项是 <code>virtual_hosts</code>，该选项在 <code>HTTP</code> 连接管理过滤器中用作定义虚拟主机，并通过正则过滤允许访问服务的域名。路由也在其中配置，例子中将 <code>/service/1</code> 和 <code>/service/2</code> 的请求分别转发到了其相应的集群中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">virtual_hosts:</span><br><span class="line">- name: backend</span><br><span class="line">  domains:</span><br><span class="line">  - &quot;*&quot;</span><br><span class="line">  routes:</span><br><span class="line">  - match:</span><br><span class="line">      prefix: &quot;&#x2F;service&#x2F;1&quot;</span><br><span class="line">    route:</span><br><span class="line">      cluster: service1</span><br><span class="line">  - match:</span><br><span class="line">      prefix: &quot;&#x2F;service&#x2F;2&quot;</span><br><span class="line">    route:</span><br><span class="line">      cluster: service2</span><br></pre></td></tr></table></figure><p>接下来我们继续看静态集群的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">clusters:</span><br><span class="line">- name: service1</span><br><span class="line">  connect_timeout: 0.25s</span><br><span class="line">  type: strict_dns</span><br><span class="line">  lb_policy: round_robin</span><br><span class="line">  http2_protocol_options: &#123;&#125;</span><br><span class="line">  hosts:</span><br><span class="line">  - socket_address:</span><br><span class="line">      address: service1</span><br><span class="line">      port_value: 80</span><br><span class="line">- name: service2</span><br><span class="line">  connect_timeout: 0.25s</span><br><span class="line">  type: strict_dns</span><br><span class="line">  lb_policy: round_robin</span><br><span class="line">  http2_protocol_options: &#123;&#125;</span><br><span class="line">  hosts:</span><br><span class="line">  - socket_address:</span><br><span class="line">      address: service2</span><br><span class="line">      port_value: 80</span><br></pre></td></tr></table></figure><p>在静态集群的配置内容中，我们可以配置超时时间、熔断器、服务发现等等内容。集群由一系列端点 (<code>Endpoints</code>) 组成，端点就是一组服务集群中可以响应访问请求的网络地址。在上面的例子中，端点标准定义成 <code>DNS</code> ，除此之外，端点可以直接被定义成 <code>Socket</code> 地址，或者是可动态读取的服务发现机制。</p><p><strong>尝试动手修改配置</strong></p><p>我们可以在本地尝试自己修改配置，重建镜像，测试修改后的配置。监听过滤器是 <code>Envoy</code> 为监听器提供的附加功能。比方说，想要增加访问日志到我们的 <code>HTTP</code> 过滤器中，只要增加 <code>access_log</code> 字段到配置文件中即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- filters:</span><br><span class="line">  - name: envoy.http_connection_manager</span><br><span class="line">    config:</span><br><span class="line">      codec_type: auto</span><br><span class="line">      stat_prefix: ingress_http</span><br><span class="line">      access_log:</span><br><span class="line">        - name: envoy.file_access_log</span><br><span class="line">          config:</span><br><span class="line">            path: &quot;&#x2F;var&#x2F;log&#x2F;access.log&quot;</span><br><span class="line">      route_config:</span><br></pre></td></tr></table></figure><p>修改之后，先通过 <code>docker-compose down</code> 命令关闭 <code>docker-compose</code> 容器组，然后使用 <code>docker-compose up --build -d</code> 命令重新构建镜像并运行容器组即可。</p><p>为了验证我们新增的 <code>access_log</code> 字段是否生效，我们可以模拟几次请求。然后通过命令 <code>docker-compose exec front-envoy /bin/bash</code> 手动进入容器内部查看访问日志是否在相应的目录中，你会看到 <code>/var/log/access.log</code> 文件记录着你的请求结果。</p><h4 id="管理页面">管理页面</h4><p>Envoy 的一大特色是内置了管理页面，你可以通过 <code>http://localhost:8001</code> 访问。管理页面中 <code>/cluster</code> 菜单展示了上游 (<code>Upstream</code>) 集群端口的统计内容，<code>stats</code> 菜单则显示了更多端口的统计内容。</p><p><img src="https://i.loli.net/2019/10/23/TowFauBL4Ae6Yz8.png" alt=""></p><p>更多管理页面的内容你可以直接访问帮助页面 <code>http://localhost:8001/help</code> 来查看。</p><h3 id="请求处理流程">请求处理流程</h3><p><code>Envoy</code> 中对访问请求的处理流程大致如下，先将请求数据预处理，转成 <code>Envoy</code> 中的 <code>Filter</code>， 读写请求的 <code>filter</code> 分别是 <code>ReadFilter</code> 和 <code>WriteFiler</code>，对每个网络层也有各自的 <code>filter</code> ，<code>TCP</code> 的是 <code>TcpProxyFilter</code>, <code>HTTP</code> 的是 <code>ConnectionManager</code>，都由读 <code>filter ReadFilter</code> 继承而来。各个 <code>filter</code> 预处理完成之后就会组织成上面示例配置文件中有提到的 <code>FilterChain</code>， 收到 <code>FilterChain</code> 之后会将其路由到指定的集群中，并根据负载均衡获取到相应的地址，然后将请求转发出去。</p><h3 id="进阶实例">进阶实例</h3><p>接下来的实验主要以动态配置的方式来实现一个简单的需求，首先描述一下需求场景：有两个微服务，一个是 <code>envoy-web</code>，一个 <code>envoy-server</code>。</p><ul><li><p><code>envoy-web</code> 相当于下图中的 <code>front-envoy</code> 作为对外访问的入口。</p></li><li><p><code>envoy-server</code> 相当于下图中的 <code>service_1</code> 和 <code>service_2</code>，是内部的一个微服务，部署 <code>2</code> 个实例。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/12196676-2a45b1388924b33a.png" alt=""></p><p><code>envoy-server</code> 有 3 个 <code>API</code>，分别是 <code>/envoy-server/hello</code>、<code>/envoy-server/hi</code>、<code>/envoy-server/self</code>，目的是测试 <code>Envoy</code> 对于流入 <code>envoy-server</code> 的流量控制，对外只允许访问 <code>/envoy-server/hello</code> 和 <code>/envoy-server/hi</code> 两个 <code>API</code>，<code>/envoy-server/self</code> 不对外暴露服务。</p><p><code>envoy-web</code> 也有 3 个 <code>API</code>，分别是 <code>/envoy-web/hello</code>、<code>/envoy-web/hi</code>、<code>/envoy-web/self</code>，目的是测试 <code>Envoy</code> 对于流出 <code>envoy-web</code> 的流量控制，出口流量只允许 <code>/envoy-web/hello</code> 和 <code>/envoy-web/self</code> 两个访问出去。</p><p>最终的实验：外部只能访问 <code>envoy-web</code> 暴露的接口</p><ul><li><p>当访问 <code>/envoy-web/hello</code> 接口时返回 <code>envoy-server</code> 的 <code>/hello</code> 接口的数据，表示 <code>envoy-web</code> 作为客户端访问 <code>envoy-server</code> 返回服务响应的结果。</p></li><li><p>当访问 <code>/envoy-web/hi</code> 接口时，<code>envoy-web</code> 的 <code>envoy</code> 拦截住出口流量，限制 <code>envoy-web</code> 向 <code>envoy-server</code> 发送请求，对于前端用户返回 <code>mock</code> 数据。</p></li><li><p>当访问 <code>/envoy-web/self</code> 接口时，<code>envoy-web</code> 出口流量可以到达 <code>envoy-server</code> 容器，但是 <code>envoy-server</code> 在入口流量处控制住了此次请求，拒绝访问 <code>envoy-server</code>服务，对于前端用户返回 <code>mock</code> 数据。</p></li></ul><h3 id="静态配置">静态配置</h3><p>首先，以静态配置的方式先实现功能。</p><h4 id="编写服务代码">编写服务代码</h4><p>服务代码分为 <code>envoy-web</code> 和 <code>envoy-server</code> 两个服务，采用 <code>SpringBoot</code> 的方式，下面记录一些重要的代码片段。</p><ul><li>envoy-server</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloRest &#123;</span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(HelloRest.class);</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;envoy-server&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        LOGGER.info(&quot;get request from remote, send response, say hello&quot;);</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;envoy-server&#x2F;hi&quot;)</span><br><span class="line">    public String hi() &#123;</span><br><span class="line">        LOGGER.info(&quot;get request from remote, send response, say hi&quot;);</span><br><span class="line">        return &quot;hi&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;envoy-server&#x2F;self&quot;)</span><br><span class="line">    public String self() &#123;</span><br><span class="line">        LOGGER.info(&quot;get request from remote, send response, say self&quot;);</span><br><span class="line">        return &quot;self&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>envoy-web</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(HelloController.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate template;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;envoy-web&#x2F;local&quot;)</span><br><span class="line">    public String sayLocal() &#123;</span><br><span class="line">        LOGGER.info(&quot;get request, send response&quot;);</span><br><span class="line">        return &quot;local&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;envoy-web&#x2F;hello&quot;)</span><br><span class="line">    public String sayHello() &#123;</span><br><span class="line">        String url &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:10000&#x2F;envoy-server&#x2F;hello&quot;;</span><br><span class="line">        LOGGER.info(&quot;get request, send rest template to &#123;&#125;&quot;, url);</span><br><span class="line">        return getRemote(url, &quot;mock value for hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;envoy-web&#x2F;hi&quot;)</span><br><span class="line">    public String sayHi() &#123;</span><br><span class="line">        String url &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:10000&#x2F;envoy-server&#x2F;hi&quot;;</span><br><span class="line">        LOGGER.info(&quot;get request, send rest template to &#123;&#125;&quot;, url);</span><br><span class="line">        return getRemote(url, &quot;mock value for hi&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;envoy-web&#x2F;self&quot;)</span><br><span class="line">    public String saySelf() &#123;</span><br><span class="line">        String url &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:10000&#x2F;envoy-server&#x2F;self&quot;;</span><br><span class="line">        LOGGER.info(&quot;get request, send rest template to &#123;&#125;&quot;, url);</span><br><span class="line">        return getRemote(url, &quot;mock value for self&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getRemote(String url, String mock) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ResponseEntity&lt;String&gt; response &#x3D; template.getForEntity(url, String.class);</span><br><span class="line">            return response.getBody();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            LOGGER.error(&quot;error happens: &#123;&#125;&quot;, e);</span><br><span class="line">            return mock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：为简化起见，代码只是介绍对出入流量的控制，直接在 <code>envoy-web</code> 上访问了本地的 <code>Envoy</code> 端口进行转发流量，实际代码中可以用服务名:服务端口号访问，而此时为了使得 <code>Envoy</code> 仍然可以拦截入和出的流量，可以配置 <code>Iptables</code>（<code>Istio</code> 的实现中也是使用了 <code>Iptables</code>）。</p></blockquote><h4 id="编写配置文件">编写配置文件</h4><p>针对不同的服务，也配置了两份 <code>envoy.yaml</code> 配置文件。</p><ul><li>envoy-server</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">admin:</span><br><span class="line">  access_log_path: &#x2F;tmp&#x2F;admin_access.log</span><br><span class="line">  address:</span><br><span class="line">    socket_address: &#123; address: 0.0.0.0, port_value: 9900 &#125;</span><br><span class="line">static_resources:</span><br><span class="line">  listeners:</span><br><span class="line">  - name: listener_ingress</span><br><span class="line">    address:</span><br><span class="line">      socket_address: &#123; address: 0.0.0.0, port_value: 10000 &#125;</span><br><span class="line">    filter_chains:</span><br><span class="line">    - filters:</span><br><span class="line">      - name: envoy.http_connection_manager</span><br><span class="line">        config:</span><br><span class="line">          stat_prefix: ingress_http</span><br><span class="line">          codec_type: AUTO</span><br><span class="line">          route_config:</span><br><span class="line">            name: local_route</span><br><span class="line">            virtual_hosts:</span><br><span class="line">            - name: local_service</span><br><span class="line">              domains: [&quot;*&quot;]</span><br><span class="line">              routes:</span><br><span class="line">              - match: &#123; prefix: &quot;&#x2F;envoy-server&#x2F;hello&quot; &#125;</span><br><span class="line">                route: &#123; cluster: cluster_server &#125;</span><br><span class="line">              - match: &#123; prefix: &quot;&#x2F;envoy-server&#x2F;hi&quot; &#125;</span><br><span class="line">                route: &#123; cluster: cluster_server &#125;</span><br><span class="line">          http_filters:</span><br><span class="line">          - name: envoy.router</span><br><span class="line">  clusters:</span><br><span class="line">  - name: cluster_server</span><br><span class="line">    connect_timeout: 0.5s</span><br><span class="line">    type: STATIC</span><br><span class="line">    lb_policy: ROUND_ROBIN</span><br><span class="line">    hosts: </span><br><span class="line">    - &#123; socket_address: &#123; address: 127.0.0.1, port_value: 8081 &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>envoy-web</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">admin:</span><br><span class="line">  access_log_path: &#x2F;tmp&#x2F;admin_access.log</span><br><span class="line">  address:</span><br><span class="line">    socket_address: &#123; address: 0.0.0.0, port_value: 9900 &#125;</span><br><span class="line">static_resources:</span><br><span class="line">  listeners:</span><br><span class="line">  - name: listener_ingress</span><br><span class="line">    address:</span><br><span class="line">      socket_address: &#123; address: 0.0.0.0, port_value: 10000 &#125;</span><br><span class="line">    filter_chains:</span><br><span class="line">    - filters:</span><br><span class="line">      - name: envoy.http_connection_manager</span><br><span class="line">        config:</span><br><span class="line">          stat_prefix: ingress_http</span><br><span class="line">          codec_type: AUTO</span><br><span class="line">          route_config:</span><br><span class="line">            name: local_route</span><br><span class="line">            virtual_hosts:</span><br><span class="line">            - name: local_service</span><br><span class="line">              domains: [&quot;*&quot;]</span><br><span class="line">              routes:</span><br><span class="line">              - match: &#123; prefix: &quot;&#x2F;envoy-web&#x2F;&quot; &#125;</span><br><span class="line">                route: &#123; cluster: cluster_ingress &#125;</span><br><span class="line">              - match: &#123; prefix: &quot;&#x2F;envoy-server&#x2F;hello&quot; &#125;</span><br><span class="line">                route: &#123; cluster: cluster_egress &#125;</span><br><span class="line">              - match: &#123; prefix: &quot;&#x2F;envoy-server&#x2F;self&quot; &#125;</span><br><span class="line">                route: &#123; cluster: cluster_egress &#125;</span><br><span class="line">          http_filters:</span><br><span class="line">          - name: envoy.router</span><br><span class="line">  clusters:</span><br><span class="line">  - name: cluster_ingress</span><br><span class="line">    connect_timeout: 0.5s</span><br><span class="line">    type: STATIC</span><br><span class="line">    lb_policy: ROUND_ROBIN</span><br><span class="line">    hosts:</span><br><span class="line">    - &#123; socket_address: &#123; address: 127.0.0.1, port_value: 8080 &#125;&#125;</span><br><span class="line">  - name: cluster_egress</span><br><span class="line">    connect_timeout: 0.5s</span><br><span class="line">    type: STATIC</span><br><span class="line">    lb_policy: ROUND_ROBIN</span><br><span class="line">    hosts:</span><br><span class="line">    - &#123; socket_address: &#123; address: 172.17.0.2, port_value: 10000 &#125;&#125;</span><br><span class="line">    - &#123; socket_address: &#123; address: 172.17.0.3, port_value: 10000 &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="启动测试">启动测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># envoy-server1</span><br><span class="line">$ docker run -d -v &#96;pwd&#96;&#x2F;envoy-server.yaml:&#x2F;etc&#x2F;envoy&#x2F;envoy.yaml --name envoyproxy-server1 envoyproxy&#x2F;envoy:latest &#x2F;usr&#x2F;local&#x2F;bin&#x2F;envoy --service-cluster envoy-server --service-node 1 -c &#x2F;etc&#x2F;envoy&#x2F;envoy.yaml --v2-config-only</span><br><span class="line">$ docker run -d --network&#x3D;container:envoyproxy-server1 --name envoy-server1 envoy-server:1.1</span><br><span class="line"></span><br><span class="line"># envoy-server2</span><br><span class="line">$ docker run -d -v &#96;pwd&#96;&#x2F;envoy-server.yaml:&#x2F;etc&#x2F;envoy&#x2F;envoy.yaml --name envoyproxy-server2 envoyproxy&#x2F;envoy:latest &#x2F;usr&#x2F;local&#x2F;bin&#x2F;envoy --service-cluster envoy-server --service-node 2 -c &#x2F;etc&#x2F;envoy&#x2F;envoy.yaml --v2-config-only</span><br><span class="line">$ docker run -d --network&#x3D;container:envoyproxy-server2 --name envoy-server2 envoy-server:1.1</span><br><span class="line"></span><br><span class="line"># envoy-web</span><br><span class="line">$ docker run -d -p 10000:10000 -v &#96;pwd&#96;&#x2F;envoy-web.yaml:&#x2F;etc&#x2F;envoy&#x2F;envoy.yaml --name envoyproxy-web envoyproxy&#x2F;envoy:latest &#x2F;usr&#x2F;local&#x2F;bin&#x2F;envoy --service-cluster envoy-web --service-node 1 -c &#x2F;etc&#x2F;envoy&#x2F;envoy.yaml --v2-config-only</span><br><span class="line">$ docker run -d --network&#x3D;container:envoyproxy-web --name envoy-web envoy-web:1.1</span><br></pre></td></tr></table></figure><p>当容器部署完毕之后，可以直接访问以下 3 个 URL ，其中 hi 和 self 的访问返回的是 mock 数据，虽然同为 mock 数据，但是这两个 <code>URL</code> 其实是不相同的，一个是在 <code>Envoy</code> 出口流量处做的控制，一个是在 <code>Envoy</code> 入口流量处做的控制，其中的细节可以再去品味品味。</p><p><img src="https://upload-images.jianshu.io/upload_images/12196676-83ac7de7c28ad6a1.png" alt=""></p><h3 id="动态配置">动态配置</h3><p>动态配置需要实现发现服务，通过 <code>GRPC</code> 的方式获取相应。</p><p>动态的配置文件在前面的内容中已经有过介绍，最重要的是需要提供一个发现服务，对外提供 <code>XDS</code> 服务，下面以其中的一个 <code>LDS</code> 作为介绍，其他 <code>XDS</code> 实现类似。</p><p>服务端：既然作为服务，就需要对外提供接口服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class GrpcService &#123;</span><br><span class="line">    private Server server;</span><br><span class="line">    private static final int PORT &#x3D; 50051;</span><br><span class="line"></span><br><span class="line">    private void start() throws IOException &#123;</span><br><span class="line">        server &#x3D; ServerBuilder.forPort(PORT)</span><br><span class="line">                .addService(new LdsService())</span><br><span class="line">                .addService(new CdsService())</span><br><span class="line">                .addService(new RdsService())</span><br><span class="line">                .addService(new EdsService())</span><br><span class="line">                .addService(new AdsService())</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        System.err.println(&quot;Server started, listening on &quot; + PORT);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;</span><br><span class="line">            System.err.println(&quot;*** shutting down gRPC server since JVM is shutting down&quot;);</span><br><span class="line">            GrpcService.this.stop();</span><br><span class="line">            System.err.println(&quot;*** server shut down&quot;);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void stop() &#123;</span><br><span class="line">        if (server !&#x3D; null) &#123;</span><br><span class="line">            server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void blockUntilShutdown() throws InterruptedException &#123;</span><br><span class="line">        if (server !&#x3D; null) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">        final GrpcService server &#x3D; new GrpcService();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>XDS</code> 通过 <code>GRPC</code> 生成服务端的 <code>stub</code> 文件，实现 <code>LdsServer</code> 继承自 <code>ListenerDiscoveryServiceGrpc.ListenerDiscoveryServiceImplBase</code>，需要实现 <code>streamListeners</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class LdsService extends ListenerDiscoveryServiceGrpc.ListenerDiscoveryServiceImplBase &#123;</span><br><span class="line">    private static final Logger LOGGER &#x3D; LogManager.getLogger();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public StreamObserver&lt;Discovery.DiscoveryRequest&gt; streamListeners(StreamObserver&lt;Discovery.DiscoveryResponse&gt; responseObserver) &#123;</span><br><span class="line">        return new StreamObserver&lt;Discovery.DiscoveryRequest&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Discovery.DiscoveryRequest request) &#123;</span><br><span class="line">                XdsHelper.getInstance().buildAndSendResult(request, responseObserver);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable throwable) &#123;</span><br><span class="line">                LOGGER.warn(&quot;Error happens&quot;, throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onCompleted() &#123;</span><br><span class="line">                LOGGER.info(&quot;LdsService completed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>至此，我们就基本介绍完 <code>Envoy</code> 使用的一些常见的使用方法，在实现的时候也会有其他一些细节需要注意。比如，<code>Envoy</code> 作为一个服务之间网络请求的代理，如何拦截全部的入和出流量？</p><p><code>Istio</code> 给了一个很好的解决方案，就是通过 <code>Iptables</code>。它会使用一个特定的 <code>uid</code>（默认 1337）用户运行 <code>Envoy</code> 进程，<code>Iptables</code> 对于 <code>1337</code> 用户的流量不做拦截。下面就是参考 <code>Istio</code> 的 <code>iptables.sh</code> 做的一个实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uname&#x3D;envoy</span><br><span class="line">uid&#x3D;1337</span><br><span class="line">iptalbes -t nat -F</span><br><span class="line">iptables -t nat -I PREROUTING -p tcp -j REDIRECT --to-ports 10000</span><br><span class="line">iptables -t nat -N ENVOY_OUTPUT</span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -j ENVOY_OUTPUT</span><br><span class="line">iptables -t nat -A ENVOY_OUTPUT -p tcp -d 127.0.0.1&#x2F;32 -j RETURN</span><br><span class="line">iptables -t nat -A ENVOY_OUTPUT -m owner --uid-owner $&#123;uid&#125; -j RETURN</span><br><span class="line">iptables -t nat -A ENVOY_OUTPUT -p tcp -j REDIRECT --to-ports 10000</span><br></pre></td></tr></table></figure><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://holajiawei.com/envoy/" target="_blank" rel="noopener">https://holajiawei.com/envoy/</a></p></li><li><p><a href="https://www.lijiaocn.com/soft/envoy/" target="_blank" rel="noopener">https://www.lijiaocn.com/soft/envoy/</a></p></li><li><p><a href="https://www.jianshu.com/p/90f9ee98ce70" target="_blank" rel="noopener">https://www.jianshu.com/p/90f9ee98ce70</a></p></li><li><p><a href="https://github.com/wellls/blog/issues/47" target="_blank" rel="noopener">https://github.com/wellls/blog/issues/47</a></p></li><li><p><a href="https://jimmysong.io/posts/envoy-as-front-proxy/" target="_blank" rel="noopener">https://jimmysong.io/posts/envoy-as-front-proxy/</a></p></li><li><p><a href="https://www.yangcs.net/posts/run-envoy-on-your-laptop/" target="_blank" rel="noopener">https://www.yangcs.net/posts/run-envoy-on-your-laptop/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Envoy&quot;&gt;什么是 Envoy&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Envoy&lt;/code&gt; 是一款 &lt;code&gt;CNCF&lt;/code&gt; 旗下的开源项目，由 &lt;code&gt;Lyft&lt;/code&gt; 开源。&lt;code&gt;Envoy&lt;/code&gt; 采用 C++ 实现，是面向 &lt;code&gt;Service Mesh&lt;/code&gt; 的高性能网络代理服务。它与应用程序并行运行，通过以平台无关的方式提供通用功能来抽象网络。当基础架构中的所有服务流量都通过 Envoy 网格时，通过一致的可观测性，很容易地查看问题区域，调整整体性能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Envoy&lt;/code&gt; 也是 &lt;code&gt;Istio Service Mesh&lt;/code&gt; 中默认的 &lt;code&gt;Data Plane&lt;/code&gt;，本文我们将讲解 &lt;code&gt;Envoy&lt;/code&gt; 的一些基本概念，并采用一些实例来介绍如何在本地环境中快速使用 &lt;code&gt;Envoy&lt;/code&gt; 作为 &lt;code&gt;Service Mesh&lt;/code&gt; 的数据平面，以帮助读者理解 &lt;code&gt;Istio&lt;/code&gt; 的 &lt;code&gt;Data Panel&lt;/code&gt; 层实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://www.envoyproxy.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.envoyproxy.io&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Envoy-特性&quot;&gt;Envoy 特性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;整体架构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/4483e99egy1ftn7wet57fj233f1utag1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;进程无关架构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Envoy&lt;/code&gt; 是一个自组织的模块，与应用 &lt;code&gt;Server&lt;/code&gt; 并无直接依赖。所有的 &lt;code&gt;Envoy&lt;/code&gt; 构建了一个透明的服务网格 &lt;code&gt;Service Mesh&lt;/code&gt;，处于其中的应用只需要简单的与本地的 &lt;code&gt;Envoy&lt;/code&gt; 进行收发信息，并不需要关注整个网络拓扑。这种架构对于应用通信有两大好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Envoy&lt;/code&gt; 可以让任何的编程语言编写的服务通信，协同工作，&lt;code&gt;Envoy&lt;/code&gt; 帮你屏蔽了服务之间的沟壑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何曾经在大型微服务开发中工作过的人都知道发布一个库更新是多么的痛苦。&lt;code&gt;Envoy&lt;/code&gt; 可以以一种透明的方式快速的发布更新整个基础架构中的版本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="Envoy" scheme="https://www.hi-linux.com/tags/Envoy/"/>
    
  </entry>
  
  <entry>
    <title>如何通过 Alertmanager 有效的给 Prometheus 添加一个警报系统</title>
    <link href="https://www.hi-linux.com/posts/23179.html"/>
    <id>https://www.hi-linux.com/posts/23179.html</id>
    <published>2020-05-17T01:00:00.000Z</published>
    <updated>2020-05-17T07:48:06.545Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>警报是监控系统中必不可少的一块, 当然了, 也是最难搞的一块. 我们乍一想, 警报似乎很简单一件事:</p><blockquote><p>假如发生了异常情况, 发送或邮件/消息通知给某人或某频道</p></blockquote><p>一把梭搞起来之后, 就不免有一些小麻烦:</p><ul><li><p>这个啊…一天中总有那么几次波动, 也难修难查了, 算了算了不看了</p></li><li><p>警报太多了, 实在看不过来, 屏蔽/归档/放生吧…</p></li><li><p>有毒吧, 这个阈值也太低了</p></li><li><p>卧槽, 这些警报啥意思啊, 发给我干嘛啊?</p></li><li><p>卧槽卧槽卧槽, 怎么一下子几十百来条警报, 哦…原来网络出问题了全崩了</p></li></ul><p>到最后我们还能总结出一个奇怪的规律:</p><blockquote><p>这世界上只有两种警报，一种是疯狂报警但是没有卵用完全没人看的警报，一种是非常有效大家都想看但在用户反馈前从来都报不出来的警报。—— 鲁迅(</p></blockquote><p>玩笑归玩笑，但至少我们能看出，警报不是一个简单的计算+通知系统。只是，”做好警报”这件事本身是个综合问题，代码能解决的也只是其中的一小部分，更多的事情要在组织、人事和管理上去做。我掰不出那么有深度的文章，这篇文章就专注一点，只讲代码部分里的通知，也就是 Prometheus 生态中的 Alertmanager 这个组件。</p><a id="more"></a><h2 id="为什么要-alertmanager">为什么要 Alertmanager？</h2><p>我们先介绍一点背景知识，Prometheus 生态中的警报是在 Prometheus Server 中计算警报规则(Alert Rule)并产生的，而所谓计算警报规则，其实就是周期性地执行一段 PromQL，得到的查询结果就是警报，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_load5 &gt; 20</span><br></pre></td></tr></table></figure><p>这个 PromQL 会查出所有”在最近一次采样中，5分钟平均 Load 大于 20”的时间序列。这些序列带上它们的标签就被转化为警报。</p><p>只是，当 Prometheus Server 计算出一些警报后，它自己并没有能力将这些警报通知出去，只能将警报推给 Alertmanager，由 Alertmanager 进行发送。</p><p>这个切分，一方面是出于单一职责的考虑，让 Prometheus “do one thing and do it well”, 另一方面则是因为警报发送确实不是一件”简单”的事，需要一个专门的系统来做好它。可以这么说，Alertmanager 的目标不是简单地”发出警报”，而是”发出高质量的警报”。它提供的高级功能包括但不限于：</p><ul><li><p>Go Template 渲染警报内容；</p></li><li><p>管理警报的重复提醒时机与消除后消除通知的发送；</p></li><li><p>根据标签定义警报路由，实现警报的优先级、接收人划分，并针对不同的优先级和接收人定制不同的发送策略；</p></li><li><p>将同类型警报打包成一条通知发送出去，降低警报通知的频率；</p></li><li><p>支持静默规则: 用户可以定义一条静默规则，在一段时间内停止发送部分特定的警报，比如已经确认是搜索集群问题，在修复搜索集群时，先静默掉搜索集群相关警报；</p></li><li><p>支持”抑制”规则(Inhibition Rule): 用户可以定义一条”抑制”规则，规定在某种警报发生时，不发送另一种警报，比如在”A 机房网络故障”这条警报发生时，不发送所有”A 机房中的警报”；</p></li></ul><p>假如你很忙，那么读到这里就完全 OK 了，反正这类文章最大的作用就是让我们”知道有 X 这回事，大概了解有啥特性，当有需求匹配时，能想到试试看 X 合不合适“，其中 X = Alertmanager。当然，假如你是个好奇宝宝，那么还可以看看下面的解析。</p><h2 id="alertmanager-内部架构">Alertmanager 内部架构</h2><p>先看官方文档中的架构图：</p><p><img src="https://aleiwu.com/img/alertmanager/alertmanager.png" alt=""></p><ol><li><p>从左上开始，Prometheus 发送的警报到 Alertmanager;</p></li><li><p>警报会被存储到 AlertProvider 中，Alertmanager 的内置实现就是包了一个 map，也就是存放在本机内存中，这里可以很容易地扩展其它 Provider;</p></li><li><p>Dispatcher 是一个单独的 goroutine，它会不断到 AlertProvider 拉新的警报，并且根据 YAML 配置的 Routing Tree 将警报路由到一个分组中;</p></li><li><p>分组会定时进行 flush (间隔为配置参数中的 group_interval), flush 后这组警报会走一个 Notification Pipeline 链式处理;</p></li><li><p>Notification Pipeline 为这组警报确定发送目标，并执行抑制逻辑，静默逻辑，去重逻辑，发送与重试逻辑，实现警报的最终投递;</p></li></ol><p>下面就分开讲一讲核心的两块：</p><ol><li><p>Dispatcher 中的 Routing Tree 的实现与设计意图</p></li><li><p>Notification Pipeline 的实现与设计意图</p></li></ol><h3 id="routing-tree">Routing Tree</h3><p>Routing Tree 的是一颗多叉树，节点的数据结构定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 节点包含警报的路由逻辑</span><br><span class="line">type Route struct &#123;</span><br><span class="line">    &#x2F;&#x2F; 父节点</span><br><span class="line">    parent *Route</span><br><span class="line">    &#x2F;&#x2F; 节点的配置，下文详解</span><br><span class="line">    RouteOpts RouteOpts</span><br><span class="line">    &#x2F;&#x2F; Matchers 是一组匹配规则，用于判断 Alert 与当前节点是否匹配</span><br><span class="line">    Matchers types.Matchers</span><br><span class="line">    &#x2F;&#x2F; 假如为 true, 那么 Alert 在匹配到一个节点后，还会继续往下匹配</span><br><span class="line">    Continue bool</span><br><span class="line">    &#x2F;&#x2F; 子节点</span><br><span class="line">    Routes []*Route</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的处理代码很简单，深度优先搜索：警报从 root 开始匹配（root 默认匹配所有警报），然后根据节点中定义的 Matchers 检测警报与节点是否匹配，匹配则继续往下搜索，默认情况下第一个”最深”的 match (也就是 DFS 回溯之前的最后一个节点)会被返回。特殊情况就是节点配置了 Continue=true，这时假如这个节点匹配上了，那不会立即返回，而是继续搜索，用于支持警报发送给多方这种场景（比如”抄送”)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 深度优先搜索</span><br><span class="line">func (r *Route) Match(lset model.LabelSet) []*Route &#123;</span><br><span class="line">    if !r.Matchers.Match(lset) &#123;</span><br><span class="line">    return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var all []*Route</span><br><span class="line">    for _, cr :&#x3D; range r.Routes &#123;</span><br><span class="line">        &#x2F;&#x2F; 递归调用子节点的 Match 方法</span><br><span class="line">        matches :&#x3D; cr.Match(lset)</span><br><span class="line"></span><br><span class="line">        all &#x3D; append(all, matches...)</span><br><span class="line"></span><br><span class="line">        if matches !&#x3D; nil &amp;&amp; !cr.Continue &#123;</span><br><span class="line">          break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 假如没有任何节点匹配上，那就匹配根节点</span><br><span class="line">    if len(all) &#x3D;&#x3D;0 &#123;</span><br><span class="line">        all &#x3D; append(all, r)</span><br><span class="line">    &#125;</span><br><span class="line">    return all</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要设计一个复杂的 Routing Tree 逻辑呢？我们看看 Prometheus 官方的配置例子： 为了简化编写，Alertmanager 的设计是根节点的所有参数都会被子节点继承（除非子节点重写了这个参数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">route:</span><br><span class="line">  # 根节点的警报会发送给默认的接收组</span><br><span class="line">  # 该节点中的警报会按’cluster’和’alertname’做 Group，每个分组中最多每5分钟发送一条警报，同样的警报最多4小时发送一次</span><br><span class="line">  receiver:’default-receiver’</span><br><span class="line">  group_wait: 30s</span><br><span class="line">  group_interval: 5m</span><br><span class="line">  repeat_interval: 4h</span><br><span class="line">  group_by: [cluster, alertname]</span><br><span class="line">  # 没有匹配到子节点的警报，会默认匹配到根节点上</span><br><span class="line">  # 接下来是子节点的配置：</span><br><span class="line">  routes:</span><br><span class="line">    # 所有 service 字段为 mysql 或 cassandra 的警报，会发送到’database-pager’这个接收组</span><br><span class="line">    # 由于继承逻辑，这个节点中的警报仍然是按’cluster’和’alertname’做 Group 的</span><br><span class="line">  - receiver:’database-pager’</span><br><span class="line">    group_wait: 10s</span><br><span class="line">    match_re:</span><br><span class="line">    service: mysql|cassandra</span><br><span class="line">    # 所有 team 字段为 fronted 的警报，会发送到’frontend-pager’这个接收组</span><br><span class="line">    # 很重要的一点是，这个组中的警报是按’product’和’environment’做分组的，因为’frontend’面向用户，更关心哪个’产品’的什么’环境’出问题了</span><br><span class="line">  - receiver:’frontend-pager’</span><br><span class="line">    group_by: [product, environment]</span><br><span class="line">    match:</span><br><span class="line">    team: frontend</span><br></pre></td></tr></table></figure><p>总结一下，Routing Tree 的设计意图是让用户能够非常自由地给警报归类，然后根据归类后的类别来配置要发送给谁以及怎么发送：</p><ul><li><p>发送给谁？上面已经做了很好的示例，’数据库警报’和’前端警报’都有特定的接收组，都没有匹配上那么就是’默认警报’, 发送给默认接收组</p></li><li><p>怎么发送？对于一类警报，有个多个字段来配置发送行为：</p><ul><li><p>group_by：决定了警报怎么分组，每个 group 只会定时产生一次通知，这就达到了降噪的效果，而不同的警报类别分组方式显然是不一样的，举个例子：</p><ul><li><p>配置中的 ‘数据库警报’ 是按 ‘集群’ 和 ‘规则名’ 分组的，这表明对于数据库警报，我们关心的是“哪个集群的哪个规则出问题了”，比如一个时间段内，’华东’集群产生了10条 ‘API响应时间过长’ 警报，这些警报就会聚合在一个通知里发出来；</p></li><li><p>配置中的 ‘前端警报’ 是按 ‘产品’ 和 ‘环境’ 分组的， 这表明对于前端警报，我们关心的是“哪个产品的哪个环境出问题了”</p></li></ul></li><li><p>group_interval 和 group_wait: 控制分组的细节，不细谈，其中 group_interval 控制了这个分组最快多久执行一次 Notification Pipeline</p></li><li><p>repeat_interval: 假如一个相同的警报一直 FIRING，Alertmanager 并不会一直发送警报，而会等待一段时间，这个等待时间就是 repeat_interval，显然，不同类型警报的发送频率也是不一样的</p></li></ul></li></ul><p>group_interval 和 repeat_interval 的区别会在下文中详述</p><h3 id="notification-pipeline">Notification Pipeline</h3><p>由 Routing Tree 分组后的警报会触发 Notification Pipeline:</p><ul><li><p>当一个 AlertGroup 新建后，它会等待一段时间（group_wait 参数)，再触发第一次 Notification Pipeline</p></li><li><p>假如这个 AlertGroup 持续存在，那么之后每隔一段时间（group_interval 参数)，都会触发一次 Notification Pipeline</p></li></ul><p>每次触发 Notification Pipeline，AlertGroup 都会将组内所有的 Alert 作为一个列表传进 Pipeline, Notification Pipeline 本身是一个按照责任链模式设计的接口，MultiStage 这个实现会链式执行所有的 Stage：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A Stage processes alerts under the constraints of the given context.</span><br><span class="line">type Stage interface &#123;</span><br><span class="line">    Exec(ctx context.Context, l log.Logger, alerts …*types.Alert) (context.Context, []*types.Alert, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A MultiStage executes a series of stages sequencially.</span><br><span class="line">type MultiStage []Stage</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Exec implements the Stage interface.</span><br><span class="line">func (ms MultiStage) Exec(ctx context.Context, l log.Logger, alerts …*types.Alert) (context.Context, []*types.Alert, error) &#123;</span><br><span class="line">    var err error</span><br><span class="line">    for _, s :&#x3D; range ms &#123;</span><br><span class="line">        if len(alerts) &#x3D;&#x3D;0&#123;</span><br><span class="line">            return ctx, nil, nil</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx, alerts, err &#x3D; s.Exec(ctx, l, alerts…)</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            return ctx, nil, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ctx, alerts, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MultiStage 里塞的就是开头架构图里画的 InhibitStage、SilenceStage…这么一条链式处理的流程，这里要提一下，官方的架构图画错了，RoutingStage 其实处在整个 Pipeline 的首位，不过这个顺序并不影响逻辑。 要重点说的是DedupStage和NotifySetStage它俩协同负责去重工作，具体做法是：</p><ul><li><p>NotifySetStage 会为发送成功的警报记录一条发送通知，key 是’接收组名字’+’GroupKey 的 key 值’，value 是当前 Stage 收到的 []Alert (这个列表和最开始进入 Notification Pipeline 的警报列表有可能是不同的，因为其中有些 Alert 可能在前置 Stage 中已经被过滤掉了)</p></li><li><p>DedupStage 中会以’接收组名字’+’GroupKey 的 key 值’为 key 查询通知记录，假如：</p><ul><li><p>查询无结果，那么这条通知没发过，为这组警报发送一条通知；</p></li><li><p>查询有结果，那么查询得到已经发送过的一组警报 S，判断当前的这组警报 A 是否为 S 的子集：</p><ul><li><p>假如 A 是 S 的子集，那么表明 A 和 S 重复，这时候要根据 repeat_interval 来决定是否再次发送：</p><ul><li><p>距离 S 的发送时间已经过去了足够久（repeat_interval)，那么我们要再发送一遍；</p></li><li><p>距离 S 的发送时间还没有达到 repeat_interval，那么为了降低警报频率，触发去重逻辑，这次我们就不发了；</p></li></ul></li><li><p>假如 A 不是 S 的子集，那么 A 和 S 不重复，需要再发送一次； 上面的表述可能有些抽象，最后表现出来的结果是：</p></li></ul></li></ul></li><li><p>假如一个 AlertGroup 里的警报一直发生变化，那么虽然每次都是新警报，不会被去重，但是由于 group_interval （假设是5分钟）存在，这个 AlertGroup 最多 5 分钟触发一次 Notification Pipeline，因此最多也只会 5 分钟发送一条通知；</p></li><li><p>假如一个 AlertGroup 里的警报一直不变化，就是那么几条一直 FIRING 着，那么虽然每个 group_interval 都会触发 Notification Pipeline，但是由于 repeate_interval（假设是1小时）存在，因此最多也只会每 1 小时为这个重复的警报发送一条通知； 再说一下 Silence 和 Inhibit，两者都是基于用户主动定义的规则的：</p></li><li><p>Silence Rule：静默规则用来关闭掉部分警报的通知，比如某个性能问题已经修复了，但需要排期上线，那么在上线前就可以把对应的警报静默掉来减少噪音；</p></li><li><p>Inhibit Rule：抑制规则用于在某类警报发生时，抑制掉另一类警报，比如某个机房宕机了，那么会影响所有上层服务，产生级联的警报洪流，反而会掩盖掉根本原因，这时候抑制规则就有用了； 因此 Notification Pipeline 的设计意图就很明确了：通过一系列逻辑（如抑制、静默、去重）来获得更高的警报质量，由于警报质量的维度很多（剔除重复、类似的警报，静默暂时无用的警报，抑制级联警报），因此 Notification Pipeline 设计成了责任链模式，以便于随时添加新的环节来优化警报质量</p></li></ul><h2 id="一个-prometheus-报警处理实例">一个 Prometheus 报警处理实例</h2><p>最近又被问到了 Prometheus 为啥不报警，恰好回忆起之前经常解答相关问题，不妨写一篇文章来解决下面两个问题：</p><ul><li><p>我的 Prometheus 为啥报警？</p></li><li><p>我的 Prometheus 为啥不报警？</p></li></ul><h3 id="从-for-参数开始">从 for 参数开始</h3><p>我们首先需要一些背景知识：Prometheus 是如何计算并产生警报的？</p><p>看一条简单的警报规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- alert: KubeAPILatencyHigh</span><br><span class="line">  annotations:</span><br><span class="line">    message: The API server has a 99th percentile latency of &#123;&#123; $value &#125;&#125; seconds</span><br><span class="line">      for &#123;&#123; $labels.verb &#125;&#125; &#123;&#123; $labels.resource &#125;&#125;.</span><br><span class="line">  expr: |</span><br><span class="line">    cluster_quantile:apiserver_request_latencies:histogram_quantile&#123;job&#x3D;&quot;apiserver&quot;,quantile&#x3D;&quot;0.99&quot;,subresource!&#x3D;&quot;log&quot;&#125; &gt; 4</span><br><span class="line">  for: 10m</span><br><span class="line">  labels:</span><br><span class="line">    severity: critical</span><br></pre></td></tr></table></figure><p>这条警报的<em>大致</em>含义是，假如 kube-apiserver 的 P99 响应时间大于 4 秒，并持续 10 分钟以上，就产生报警。</p><p>首先要注意的是由 <code>for</code> 指定的 Pending Duration。这个参数主要用于降噪，很多类似响应时间这样的指标都是有抖动的，通过指定 Pending Duration，我们可以 过滤掉这些瞬时抖动，让 on-call 人员能够把注意力放在真正有持续影响的问题上。</p><p>那么显然，下面这样的状况是不会触发这条警报规则的，因为虽然指标已经达到了警报阈值，但持续时间并不够长：</p><p><img src="https://aleiwu.com/prometheus-peaks.png" alt=""></p><p>但偶尔我们也会碰到更奇怪的事情。</p><h3 id="为什么不报警">为什么不报警？</h3><p><img src="https://aleiwu.com/no-alert.jpg" alt=""></p><p>类似上面这样持续超出阈值的场景，为什么有时候会不报警呢？</p><h3 id="为什么报警">为什么报警？</h3><p><img src="https://aleiwu.com/why-alert.jpg" alt=""></p><p>类似上面这样并未持续超出阈值的场景，为什么有时又会报警呢？</p><h3 id="采样间隔">采样间隔</h3><p>这其实都源自于 Prometheus 的数据存储方式与计算方式。</p><p>首先，Prometheus 按照配置的抓取间隔(<code>scrape_interval</code>)定时抓取指标数据，因此存储的是形如 (timestamp, value) 这样的采样点。</p><p>对于警报， Prometheus 会按固定的时间间隔重复计算每条警报规则，因此警报规则计算得到的只是稀疏的采样点，而警报持续时间是否大于 <code>for</code> 指定的 Pending Duration 则是由这些稀疏的采样点决定的。</p><p>而在 Grafana 渲染图表时，Grafana 发送给 Prometheus 的是一个 Range Query，其执行机制是从时间区间的起始点开始，每隔一定的时间点（由 Range Query 的 <code>step</code> 请求参数决定） 进行一次计算采样。</p><p>这些结合在一起，就会导致警报规则计算时“看到的内容”和我们在 Grafana 图表上观察到的内容不一致，比如下面这张示意图：</p><p><img src="https://aleiwu.com/alert-firing.jpg" alt=""></p><p>上面图中，圆点代表原始采样点：</p><ul><li><p>40s 时，第一次计算，低于阈值</p></li><li><p>80s 时，第二次计算，高于阈值，进入 Pending 状态</p></li><li><p>120s 时，第三次计算，仍然高于阈值，90s 处的原始采样点虽然低于阈值，但是警报规则计算时并没有”看到它“</p></li><li><p>160s 时，第四次计算，高于阈值，Pending 达到 2 分钟，进入 firing 状态</p></li><li><p>持续高于阈值</p></li><li><p>直到 360s 时，计算得到低于阈值，警报消除</p></li></ul><p>由于采样是稀疏的，部分采样点会出现被跳过的状况，而当 Grafana 渲染图表时，取决于 Range Query 中采样点的分布，图表则有可能捕捉到 被警报规则忽略掉的”低谷“（图三)或者也可能无法捕捉到警报规则碰到的”低谷“（图二）。如此这般，我们就被”图表“给蒙骗过去，质疑起警报来了。</p><h3 id="如何应对">如何应对</h3><p>首先嘛， Prometheus 作为一个指标系统天生就不是精确的——由于指标本身就是稀疏采样的，事实上所有的图表和警报都是”估算”，我们也就不必 太纠结于图表和警报的对应性，能够帮助我们发现问题解决问题就是一个好监控系统。当然，有时候我们也得证明这个警报确实没问题，那可以看一眼 <code>ALERTS</code> 指标。<code>ALERTS</code> 是 Prometheus 在警报计算过程中维护的内建指标，它记录每个警报从 Pending 到 Firing 的整个历史过程，拉出来一看也就清楚了。</p><p>但有时候 ALERTS 的说服力可能还不够，因为它本身并没有记录每次计算出来的值到底是啥，而在我们回头去考证警报时，又无法选取出和警报计算过程中一模一样的计算时间点， 因此也就无法还原警报计算时看到的计算值究竟是啥。这时候终极解决方案就是把警报所要计算的指标定义成一条 Recording Rule，计算出一个新指标来记录计算值，然后针对这个 新指标做阈值报警。kube-prometheus 的警报规则中就大量采用了这种技术。</p><h3 id="到此为止了吗">到此为止了吗？</h3><p>Prometheus 警报不仅包含 Prometheus 本身，还包含用于警报治理的 Alertmanager，我们可以看一看上面那张指标计算示意图的全图：</p><p><img src="https://aleiwu.com/alert-overview.jpg" alt=""></p><p>在警报产生后，还要经过 Alertmanager 的分组、抑制处理、静默处理、去重处理和降噪处理最后再发送给接收者。而这个过程也有大量的因素可能会导致警报产生了却最终没有进行通知。</p><h2 id="结语">结语</h2><p>Alertmanager 整体的设计意图就是奔着治理警报（通知）去的，首先它用 Routing Tree 来帮助用户定义警报的归类与发送逻辑，然后再用 Notification Pipeline 来做抑制、静默、去重以提升警报质量。这些功能虽然不能解决”警报”这件事中所有令人头疼的问题，但确实为我们着手去解决”警报质量”相关问题提供了趁手的工具。</p><blockquote><p>本文转载自：「Aylei’s Blog」，原文：1.<a href="https://url.cn/5Gp0VLq%E3%80%812.https://url.cn/5MEMY8K%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5Gp0VLq、2.https://url.cn/5MEMY8K，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;警报是监控系统中必不可少的一块, 当然了, 也是最难搞的一块. 我们乍一想, 警报似乎很简单一件事:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假如发生了异常情况, 发送或邮件/消息通知给某人或某频道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一把梭搞起来之后, 就不免有一些小麻烦:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这个啊…一天中总有那么几次波动, 也难修难查了, 算了算了不看了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;警报太多了, 实在看不过来, 屏蔽/归档/放生吧…&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有毒吧, 这个阈值也太低了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卧槽, 这些警报啥意思啊, 发给我干嘛啊?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卧槽卧槽卧槽, 怎么一下子几十百来条警报, 哦…原来网络出问题了全崩了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到最后我们还能总结出一个奇怪的规律:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这世界上只有两种警报，一种是疯狂报警但是没有卵用完全没人看的警报，一种是非常有效大家都想看但在用户反馈前从来都报不出来的警报。—— 鲁迅(&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;玩笑归玩笑，但至少我们能看出，警报不是一个简单的计算+通知系统。只是，”做好警报”这件事本身是个综合问题，代码能解决的也只是其中的一小部分，更多的事情要在组织、人事和管理上去做。我掰不出那么有深度的文章，这篇文章就专注一点，只讲代码部分里的通知，也就是 Prometheus 生态中的 Alertmanager 这个组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.hi-linux.com/categories/Prometheus/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="Prometheus" scheme="https://www.hi-linux.com/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款让所有终端程序轻松支持 SOCKS5 代理的神器 graftcp</title>
    <link href="https://www.hi-linux.com/posts/13318.html"/>
    <id>https://www.hi-linux.com/posts/13318.html</id>
    <published>2020-05-17T01:00:00.000Z</published>
    <updated>2020-05-17T07:48:06.547Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>你是否经常有在终端下通过一些实用程序进行工作的需求呢，比如：Git 等。但是由于这些终端程序默认并不支持 Socks 5 代理或 HTTP 代理，在访问一些需要科学上网的网络服务时速度或许会非常的慢。</p><p>通常我们的解决方法就是使用环境变量 <code>export ALL_PROXY=socks5://proxyAddress:port</code> 或者 <code>export http_proxy=http://proxyAddress:port</code> 给所有终端程序配置一个全局代理，这样做虽然有效但并不是最佳解决方案。</p><p>今天就给大家介绍一款神器 <code>graftcp</code>，<code>graftcp</code> 可以把任何指定的终端程序的 TCP 连接重定向到 SOCKS5 或 HTTP 代理，并且不会影响其它的终端程序。是不是很好的解决了你的痛点呢？</p><h2 id="简介">简介</h2><p><code>graftcp</code> 可以把任何指定程序（应用程序、脚本、shell 等）的 TCP 连接重定向到 SOCKS5 或 HTTP 代理。</p><p>对比 <a href="https://linux.die.net/man/8/tsocks" target="_blank" rel="noopener">tsocks</a>、<a href="http://proxychains.sourceforge.net/" target="_blank" rel="noopener">proxychains</a> 或 <a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">proxychains-ng</a>，<code>graftcp</code> 并不使用 <a href="https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick" target="_blank" rel="noopener">LD_PRELOAD 技巧</a>来劫持共享库的 connect()、getaddrinfo()<br>等系列函数达到重定向目的，这种方法只对使用动态链接编译的程序有效，对于静态链接编译出来的程序，例如<a href="https://golang.org/cmd/link/" target="_blank" rel="noopener">默认选项编译的 Go 程序</a>，<a href="https://github.com/rofl0r/proxychains-ng/issues/199" target="_blank" rel="noopener">proxychains-ng 就无效了</a>。<code>graftcp</code> 使用 <a href="https://en.wikipedia.org/wiki/Ptrace" target="_blank" rel="noopener"><code>ptrace(2)</code></a> 系统调用跟踪或修改任意指定程序的 connect 信息，对任何程序都有效。<a href="#principles">工作原理</a>后面将会解释。</p><blockquote><p>项目地址：<a href="https://github.com/hmgle/graftcp" target="_blank" rel="noopener">https://github.com/hmgle/graftcp</a></p></blockquote><a id="more"></a><h2 id="安装">安装</h2><p><code>graftcp</code> 在 Linux 系统内运行。 <code>graftcp-local</code> 使用 Go 编写, <a href="https://golang.org/doc/install" target="_blank" rel="noopener">Go</a> 环境是必需的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/hmgle/graftcp.git</span><br><span class="line">$ <span class="built_in">cd</span> graftcp</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>make 执行完后，即可运行 <code>graftcp-local/graftcp-local</code> 和 <code>./graftcp</code>。你也可以把它们都安装进系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>之后 <code>graftcp-local</code> 会随着系统启动而自动运行。</p><!-- more --><h2 id="用法参数">用法参数</h2><p><code>graftcp-local</code>:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> graftcp-local/graftcp-local -h</span></span><br><span class="line">Usage of graftcp-local/graftcp-local:</span><br><span class="line">  -config string</span><br><span class="line">        Path to the configuration file</span><br><span class="line">  -http_proxy string</span><br><span class="line">        http proxy address, e.g.: 127.0.0.1:8080</span><br><span class="line">  -listen string</span><br><span class="line">        Listen address (default ":2233")</span><br><span class="line">  -logfile string</span><br><span class="line">        Write logs to file</span><br><span class="line">  -loglevel value</span><br><span class="line">        Log level (0-6) (default 1)</span><br><span class="line">  -pipepath string</span><br><span class="line">        Pipe path for graftcp to send address info (default "/tmp/graftcplocal.fifo")</span><br><span class="line">  -select_proxy_mode string</span><br><span class="line">        Set the mode for select a proxy [auto | random | only_http_proxy | only_socks5] (default "auto")</span><br><span class="line">  -service string</span><br><span class="line">        Control the system service: ["start" "stop" "restart" "install" "uninstall"]</span><br><span class="line">  -socks5 string</span><br><span class="line">        SOCKS5 address (default "127.0.0.1:1080")</span><br><span class="line">  -syslog</span><br><span class="line">        Send logs to the local system logger (Eventlog on Windows, syslog on Unix)</span><br></pre></td></tr></table></figure><p><code>graftcp</code>:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> graftcp -h</span></span><br><span class="line">Usage: graftcp [options] prog [prog-args]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a --local-addr=&lt;graftcp-local-IP-addr&gt;</span><br><span class="line">                    graftcp-local's IP address. Default: localhost</span><br><span class="line">  -p --local-port=&lt;graftcp-local-port&gt;</span><br><span class="line">                    Which port is graftcp-local listening? Default: 2233</span><br><span class="line">  -f --local-fifo=&lt;fifo-path&gt;</span><br><span class="line">                    Path of fifo to communicate with graftcp-local.</span><br><span class="line">                    Default: /tmp/graftcplocal.fifo</span><br><span class="line">  -b --blackip-file=&lt;black-ip-file-path&gt;</span><br><span class="line">                    The IP in black-ip-file will connect direct</span><br><span class="line">  -w --whiteip-file=&lt;white-ip-file-path&gt;</span><br><span class="line">                    Only redirect the connect that destination ip in the</span><br><span class="line">                    white-ip-file to SOCKS5</span><br><span class="line">  -n --not-ignore-local</span><br><span class="line">                    Connecting to local is not changed by default, this</span><br><span class="line">                    option will redirect it to SOCKS5</span><br><span class="line">  -h --help</span><br><span class="line">                    Display this help and exit</span><br></pre></td></tr></table></figure><h2 id="使用示例">使用示例</h2><p>假设你正在运行默认地址 “localhost:1080” 的 SOCKS5 代理，首先启动 <code>graftcp-local</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ graftcp-local/graftcp-local</span><br></pre></td></tr></table></figure><p>通过 <code>graftcp</code> 安装来自 <a href="http://golang.org" target="_blank" rel="noopener">golang.org</a> 的 Go 包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./graftcp go get -v golang.org/x/net/proxy</span><br></pre></td></tr></table></figure><p>通过 <code>graftcp</code> 打开 <code>Chromium</code> / <code>Chrome</code> / <code>Firefox</code> 浏览器，网页的所有请求都会重定向到 SOCKS5 代理：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./graftcp chromium-browser</span><br></pre></td></tr></table></figure><p>通过 <code>graftcp</code> 启动 <code>Bash</code> / <code>Zsh</code> / <code>Fish</code>，在这个新开的 shell 里面执行的任何新命令产生的 TCP 连接都会重定向到 SOCKS5 代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% ./graftcp bash</span><br><span class="line">$ wget https://www.google.com</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/hmgle/graftcp/master/demo.gif" alt="demo"></p><h2 id="工作原理">工作原理</h2><p>要达到重定向一个 app 发起的的 TCP 连接到其他目标地址并且该 app 本身对此毫无感知的目的，大概需要这些条件：</p><ul><li><code>fork(2)</code> 一个新进程，通过 <code>execve(2)</code> 启动该 app，并使用 <code>ptrace(2)</code> 进行跟踪，在 app 执行每一次 TCP 连接前，捕获并拦截这次 <code>connect(2)</code> 系统调用，获取目标地址的参数，并通过管道传给 <code>graftcp-local</code>。</li><li>修改这次 <code>connect(2)</code> 系统调用的目标地址参数为 <code>graftcp-local</code> 的地址，然后恢复执行被中断的系统调用。返回成功后，这个程序以为自己连的是原始的地址，但其实连的是 <code>graftcp-local</code> 的地址。这个就叫“移花接木”。</li><li><code>graftcp-local</code> 根据连接信息和目标地址信息，与 SOCKS5 proxy 建立连接，把 app 的请求的数据重定向到 SOCKS5 proxy。</li></ul><p>这里可能有个疑问：既然可以修改任何系统调用的参数，那么通过修改 app 的 <code>write(2)</code> / <code>send(2)</code> 的参数，直接往 <code>buffer</code> 里面附加原始目标地址信息给 <code>graftcp-local</code> 不是更简单吗？答案是这无法做到。如果直接往运行在子进程的被跟踪程序的 <code>buffer</code> 添加信息，可能会造成缓冲区溢出，造成程序崩溃或者覆盖了其他数据。<br>另外，<a href="http://man7.org/linux/man-pages/man2/execve.2.html" target="_blank" rel="noopener"><code>execve(2)</code> 会分离所有的共享内存</a>，所以也不能通过共享内存的方式让被跟踪的 app 的 <code>write</code> buffer 携带更多的数据，因此这里采用管道方式给 <code>graftcp-local</code> 传递原始的目标地址信息。</p><p>简单的流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---------------+             +---------+         +--------+         +------+</span><br><span class="line">|   graftcp     |  dest host  |         |         |        |         |      |</span><br><span class="line">|   (tracer)    +---PIPE-----&gt;|         |         |        |         |      |</span><br><span class="line">|      ^        |  info       |         |         |        |         |      |</span><br><span class="line">|      | ptrace |             |         |         |        |         |      |</span><br><span class="line">|      v        |             |         |         |        |         |      |</span><br><span class="line">|  +---------+  |             |         |         |        |         |      |</span><br><span class="line">|  |         |  |  connect    |         | connect |        | connect |      |</span><br><span class="line">|  |         +---------------&gt;| graftcp +--------&gt;| SOCKS5 +--------&gt;| dest |</span><br><span class="line">|  |         |  |             | -local  |         |  or    |         | host |</span><br><span class="line">|  |  app    |  |  req        |         |  req    | HTTP   |  req    |      |</span><br><span class="line">|  |(tracee) +---------------&gt;|         +--------&gt;| proxy  +--------&gt;|      |</span><br><span class="line">|  |         |  |             |         |         |        |         |      |</span><br><span class="line">|  |         |  |  resp       |         |  resp   |        |  resp   |      |</span><br><span class="line">|  |         |&lt;---------------+         |&lt;--------+        |&lt;--------+      |</span><br><span class="line">|  +---------+  |             |         |         |        |         |      |</span><br><span class="line">+---------------+             +---------+         +--------+         +------+</span><br></pre></td></tr></table></figure><h2 id="常见问题解答及技巧">常见问题解答及技巧</h2><h3 id="有哪些重定向-tcp-连接的方式">有哪些重定向 TCP 连接的方式？</h3><p>主要有： 全局式、设置环境变量式和仅针对程序（或进程）式。</p><p>全局式：比如使用 <code>iptables</code> + <code>RedSocks</code> 可以把系统符合一定规则的流量转换为 SOCKS5 流量。这种方式的优点是全局有效；缺点是所有满足该规则的流量都被重定向了，影响范围较大。</p><p>设置环境变量方式：一些程序启动时会读取 proxy 相关的环境变量来决定是否将自己的数据转换为对应代理协议的流量，比如 <code>curl</code> 会<a href="https://curl.haxx.se/libcurl/c/CURLOPT_PROXY.html" target="_blank" rel="noopener">读取 <code>http_proxy</code>, <code>ftp_proxy</code>, <code>all_proxy</code> 环境变量并根据请求 scheme 来决定转换为哪种代理流量</a>。这种方法只有程序本身实现了转换的功能才有效，局限性较大。</p><p>仅针对程序方式： 这种方式可以仅针对特定的程序执行重定向，比如 <code>tsocks</code> 或 <code>proxychains</code>。如前面提到，它们之前都是使用 <code>LD_PRELOAD</code> 劫持动态库方式实现，对 <code>Go</code> 之类默认静态链接编译的程序就无效了。<code>graftcp</code> 改进了这一点，能够重定向任何程序的 TCP 连接。</p><h3 id="如果应用程序连接的目标地址是本机使用-graftcp-会把该连接重定向到-socks5-代理吗">如果应用程序连接的目标地址是本机，使用 <code>graftcp</code> 会把该连接重定向到 SOCKS5 代理吗？</h3><p>不会。默认会忽略目标地址为本地的连接，如果想重定向所有地址的话，可以使用 <code>-n</code>选项。如果想忽略更多的地址，可以把它们加入黑名单 IP 文件；如果想仅重定向某些 IP 地址，可以把这些地址加入白名单 IP 文件。使用 <code>graftcp --help</code> 获取设置参数。</p><h3 id="我的-dns-请求受到污染graftcp-会处理-dns-请求吗">我的 DNS 请求受到污染，<code>graftcp</code> 会处理 DNS 请求吗？</h3><p>不会。<code>graftcp</code> 目前仅处理 TCP 连接。建议使用 <code>dnscrypt-proxy</code> 或 <code>ChinaDNS</code> 等方式解决 DNS 污染问题。</p><h3 id="clone2-参数有个叫-clone_untraced-的标志位可以避免让父进程跟踪到自己graftcp-是如何做到强制跟踪的"><code>clone(2)</code> 参数有个叫 <code>CLONE_UNTRACED</code> 的标志位，可以避免让父进程跟踪到自己，<code>graftcp</code> 是如何做到强制跟踪的？</h3><p><code>graftcp</code> 在子进程调用 <code>clone(2)</code> 之前会把它拦截，清除这个 <code>CLONE_UNTRACED</code> 标志位，所以被跟踪的子进程最终还是难逃被跟踪的命运。另外，这个 <code>CLONE_UNTRACED</code> 标志位本意是给内核使用的，普通程序不应该去设置它。</p><p>Linux 提供了一种限制被 <code>ptrace(2)</code> 跟踪的方法：设置 <a href="https://www.kernel.org/doc/Documentation/security/Yama.txt" target="_blank" rel="noopener"><code>/proc/sys/kernel/yama/ptrace_scope</code></a> 的值，若 <code>ptrace(2)</code> 失效，请检查该值是否被修改过。</p><h3 id="支持-macos-吗">支持 macOS 吗？</h3><p>不。macOS 的 <a href="http://polarhome.com/service/man/?qf=ptrace&amp;af=0&amp;sf=0&amp;of=Darwin&amp;tf=2" target="_blank" rel="noopener"><code>ptrace(2)</code></a> 是个半残品。<s>不过理论上参考 DTrace那一套也能实现</s>，见<a href="https://github.com/hmgle/graftcp/issues/12" target="_blank" rel="noopener">issue 12</a>。或许有兴趣的同学可以趟下这趟浑水。</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://github.com/hmgle/graftcp" target="_blank" rel="noopener">https://github.com/hmgle/graftcp</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否经常有在终端下通过一些实用程序进行工作的需求呢，比如：Git 等。但是由于这些终端程序默认并不支持 Socks 5 代理或 HTTP 代理，在访问一些需要科学上网的网络服务时速度或许会非常的慢。&lt;/p&gt;
&lt;p&gt;通常我们的解决方法就是使用环境变量 &lt;code&gt;export ALL_PROXY=socks5://proxyAddress:port&lt;/code&gt; 或者 &lt;code&gt;export http_proxy=http://proxyAddress:port&lt;/code&gt; 给所有终端程序配置一个全局代理，这样做虽然有效但并不是最佳解决方案。&lt;/p&gt;
&lt;p&gt;今天就给大家介绍一款神器 &lt;code&gt;graftcp&lt;/code&gt;，&lt;code&gt;graftcp&lt;/code&gt; 可以把任何指定的终端程序的 TCP 连接重定向到 SOCKS5 或 HTTP 代理，并且不会影响其它的终端程序。是不是很好的解决了你的痛点呢？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;graftcp&lt;/code&gt; 可以把任何指定程序（应用程序、脚本、shell 等）的 TCP 连接重定向到 SOCKS5 或 HTTP 代理。&lt;/p&gt;
&lt;p&gt;对比 &lt;a href=&quot;https://linux.die.net/man/8/tsocks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tsocks&lt;/a&gt;、&lt;a href=&quot;http://proxychains.sourceforge.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proxychains&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/rofl0r/proxychains-ng&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proxychains-ng&lt;/a&gt;，&lt;code&gt;graftcp&lt;/code&gt; 并不使用 &lt;a href=&quot;https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LD_PRELOAD 技巧&lt;/a&gt;来劫持共享库的 connect()、getaddrinfo()&lt;br&gt;
等系列函数达到重定向目的，这种方法只对使用动态链接编译的程序有效，对于静态链接编译出来的程序，例如&lt;a href=&quot;https://golang.org/cmd/link/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;默认选项编译的 Go 程序&lt;/a&gt;，&lt;a href=&quot;https://github.com/rofl0r/proxychains-ng/issues/199&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proxychains-ng 就无效了&lt;/a&gt;。&lt;code&gt;graftcp&lt;/code&gt; 使用 &lt;a href=&quot;https://en.wikipedia.org/wiki/Ptrace&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;ptrace(2)&lt;/code&gt;&lt;/a&gt; 系统调用跟踪或修改任意指定程序的 connect 信息，对任何程序都有效。&lt;a href=&quot;#principles&quot;&gt;工作原理&lt;/a&gt;后面将会解释。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/hmgle/graftcp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/hmgle/graftcp&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Graftcp" scheme="https://www.hi-linux.com/tags/Graftcp/"/>
    
  </entry>
  
  <entry>
    <title>使用 Telepresence 在本地调试 Kubernetes 微服务</title>
    <link href="https://www.hi-linux.com/posts/35104.html"/>
    <id>https://www.hi-linux.com/posts/35104.html</id>
    <published>2020-05-17T01:00:00.000Z</published>
    <updated>2020-05-17T07:48:06.548Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>微服务作为一种全新的软件架构现在正变得越来越火。基本原因我觉得有两点：一方面软件系统越做越复杂，通过拆分将一个大系统解耦成一个个独立的子系统，我们就降低了整个系统的复杂性。另一方面，Kubernetes 的出现使得编排这么多子系统变得简单，可以说 Kubernetes 是目前为止微服务最好的载体。</p><p>Kubernetes 解决了微服务运行时的环境问题，但对开发环境就不那么友好了。比方说如果我们要在本地开发调试一个服务 A，但服务 A 可能依赖服务B、C，而服务 B 又有一层依赖 D，我们就需要在本地把服务 B、C、D 都搭建起来才能调试服务 A。这显然是一个很痛苦的过程。</p><p><img src="https://i.loli.net/2019/11/06/OXPumiy1AWHr3v9.png" alt=""></p><p>业界有朋友用 <code>docker-compose</code> 来模拟集群中的场景。这个方案的不足之处在于它需要把 <code>Kubernetes</code> 的那一套逻辑用 <code>docker-compose.yml</code> 文件重写一遍，这给我们带来了维护成本。另一方面，有的时候依赖树太大，本地机器完全无法同时运行这么多服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ratesvc:</span><br><span class="line">  image: kubeapps&#x2F;ratesvc:latest</span><br><span class="line">  environment:</span><br><span class="line">    - JWT_KEY&#x3D;secret  # &lt;------------------------ 手工维护</span><br><span class="line">  command:</span><br><span class="line">    - &#x2F;ratesvc</span><br><span class="line">    - --mongo-url&#x3D;mongodb:&#x2F;&#x2F;root@mongodb  # &lt;---- 手工维护</span><br><span class="line">    - --mongo-database&#x3D;ratesvc</span><br><span class="line"></span><br><span class="line">mongodb:</span><br><span class="line">  image: bitnami&#x2F;mongodb:3</span><br><span class="line">  environment:</span><br><span class="line">    - MONGODB_ROOT_PASSWORD&#x3D;password123</span><br><span class="line"></span><br><span class="line">auth:</span><br><span class="line">  image: kubeapps&#x2F;oauth2-bitnami:latest</span><br><span class="line">  volumes:</span><br><span class="line">    - .&#x2F;config.yaml:&#x2F;config&#x2F;monocular.yaml  # &lt;-- 手工维护</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">volumnes:  # &lt;----------------------------------- 手工维护</span><br><span class="line">  monocular-data:</span><br></pre></td></tr></table></figure><p>另一种解决方案就是我这里要介绍的 <code>Telepresence</code> 了，它能够在不修改程序代码的情况下，让本地应用程序无感的接入到 <code>Kubernetes</code> 集群中，这样你就可以直接在本地开发调试微服务了。</p><h2 id="telepresence-简介">Telepresence 简介</h2><p><code>Telepresence</code> 是一个 <code>CNCF</code> 基金会下的项目。它的工作原理是在本地和 <code>Kubernetes</code> 集群中搭建一个透明的双向代理，这使得我们可以在本地用熟悉的 <code>IDE</code> 和调试工具来运行一个微服务，同时该服务还可以无缝的与 <code>Kubernetes</code> 集群中的其他服务进行交互，好像它就运行在这个集群中一样。</p><p>这是一个 <code>Telepresence</code> 工作原理图，它将集群中的数据卷、环境变量、网络都代理到了本地（除了数据卷外，其他两个对应用程序来说都是透明的）：</p><p><img src="https://i.loli.net/2019/11/06/79IMTeOFfJ8p5wb.png" alt=""></p><p>有了这些代理之后：</p><ol><li><p>本地的服务就可以完整的访问到远程集群中的其他服务。</p></li><li><p>本地的服务直接访问到 Kubernetes 里的各种资源，包括环境变量、Secrets、Config map 等。</p></li><li><p>甚至集群中的服务还能直接访问到本地暴露出来的接口。</p></li></ol><h2 id="telepresence-安装">Telepresence 安装</h2><p>这里只说一下如何在 <code>macOS</code> 下进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install osxfuse  <span class="comment"># required by sshfs to mount the pod's filesystem</span></span><br><span class="line">$ brew install datawire/blackbird/telepresence</span><br></pre></td></tr></table></figure><blockquote><p>其他平台请参考：<a href="https://www.telepresence.io/reference/install" target="_blank" rel="noopener">https://www.telepresence.io/reference/install</a></p></blockquote><p>如果官方的安装包没有覆盖到你的平台，其实也可以从源代码安装，因为它本身就是用 <code>Python 3</code> 写的，熟悉 <code>Python</code> 的朋友安装这个程序应该不难，我自己就在 <code>CentOS 7</code> 上安装成功了。</p><a id="more"></a><h2 id="telepresence-使用场景">Telepresence 使用场景</h2><p>假设我们有两个服务 A 和 B，服务 A 是依赖于服务 B 的。下面分两个场景来看看如何用 Telepresence 来调试 A 和 B。</p><p><img src="https://i.loli.net/2019/11/06/Pgp2NtCk8IGvoX3.png" alt=""></p><h3 id="调试服务-a">调试服务 A</h3><p>服务 A 在本地运行，服务 B 运行在远端集群中。借助 <code>Telepresence</code> 搭建的代理，A 就能直接访问到 B。比方说我们的服务 B 是这样一个程序，它监听在 8000 端口上。每当有人访问时它就返回 <code>Hello, world!</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run service-b --image=datawire/hello-world --port=8000 --expose</span><br><span class="line">$ kubectl get service service-b</span><br><span class="line">NAME        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">service-b   10.0.0.12    &lt;none&gt;        8000/TCP   1m</span><br></pre></td></tr></table></figure><p>现在在本地用默认参数启动 <code>Telepresence</code> ，等它连接好集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ telepresence</span><br><span class="line">T: Starting proxy with method <span class="string">'vpn-tcp'</span>, <span class="built_in">which</span> has the following limitations: All processes are affected, only one telepresence can run per machine, and you</span><br><span class="line">T: can<span class="string">'t use other VPNs. You may need to add cloud hosts and headless services with --also-proxy. For a full list of method limitations see</span></span><br><span class="line"><span class="string">T: https://telepresence.io/reference/methods.html</span></span><br><span class="line"><span class="string">T: Volumes are rooted at $TELEPRESENCE_ROOT. See https://telepresence.io/howto/volumes.html for details.</span></span><br><span class="line"><span class="string">T: Starting network proxy to cluster using new Deployment telepresence-1566230249-7112632-14485</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">T: No traffic is being forwarded from the remote Deployment to your local machine. You can use the --expose option to specify which ports you want to</span></span><br><span class="line"><span class="string">T: forward.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">T: Setup complete. Launching your command.</span></span><br><span class="line"><span class="string">@test_cluster|bash-4.2#</span></span><br></pre></td></tr></table></figure><p>这时候就可以开始调试服务 A 了，因为服务 B 暴露出来的接口本地已经可以直接访问到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://service-b:8000/</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>这里要说明一下这背后发生的事情：</p><ol><li><p>当运行 <code>Telepresence</code> 命令的时候，它创建了一个 <code>Deployment</code>，这个 <code>Deployment</code> 又创建了一个用来做代理的 <code>Pod</code> ，我们可以这样查看到它 <code>kubectl get pod -l telepresence</code>。</p></li><li><p>同时它还在本地创建了一个全局的 <code>VPN</code>，使得本地的所有程序都可以访问到集群中的服务。 <code>Telepresence</code> 其实还支持其他的网络代理模式（使用 <code>--method</code> 切换），<code>vpn-tcp</code> 是默认的方式，其他的好像用处不大，<code>inject-tcp</code> 甚至要在后续的版本中取消掉。</p></li><li><p>当本地的 <code>curl</code> 访问 <code>http://service-b:8000/</code> 时，对应的 <code>DNS</code> 查询和 <code>HTTP</code> 请求都被 <code>VPN</code> 路由到集群中刚刚创建的 <code>Pod</code> 去处理。</p></li></ol><p>除此之外 <code>Telepresence</code> 还将远端的文件系统通过 <code>sshfs</code> 挂载到本地 <code>$TELEPRESENCE_ROOT</code> 下面（你也可以用参数 <code>--mount &lt;MOUNT_PATH&gt;</code> 指定挂载的路径）。这样，我们的应用程序就可以在本地访问到远程的文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls <span class="variable">$TELEPRESENCE_ROOT</span>/var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">ca.crt  namespace  token</span><br></pre></td></tr></table></figure><p>如果我们退出 <code>Telepresence</code> 对应的 Shell，它也会做一些清理工作，比如取消本地 <code>VPN</code>、删除刚刚创建的 <code>Deployment</code> 等。</p><h3 id="调试服务-b">调试服务 B</h3><p>服务 B 与刚才的不同之处在于，它是被别人访问的，要调试它，首先得要有真实的访问流量。我们如何才能做到将别人对它的访问路由到本地来，从而实现在本地捕捉到集群中的流量呢？</p><p>Telepresence 提供这样一个参数，<code>--swap-deployment &lt;DEPLOYMENT_NAME[:CONTAINER]&gt;</code>，用来将集群中的一个 <code>Deployment</code> 替换为本地的服务。对于上面的 <code>service-b</code>，我们可以这样替换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ telepresence --swap-deployment service-b --expose 8000:8000</span><br></pre></td></tr></table></figure><p>这个时候集群中的服务 A 再想访问服务 B 的 8000 端口时，<code>Telepresence</code> 就会将这个请求转发到本地的 8000 端口。它的工作原理就是将集群中的 <code>service-b</code> 替换为 <code>Telepresence</code> 创建的 Proxy ，然后这个 Proxy 再将请求转发到本地客户端。</p><p>即，将原始的网络：</p><p><img src="https://i.loli.net/2019/11/06/x6NvdWSFQK4HXCJ.png" alt=""></p><p>替换为这个结构：</p><p><img src="https://i.loli.net/2019/11/06/ATgkiv1X3jGy8Wn.png" alt=""></p><p>这样我们就有机会在本地查看具体的请求数据，调试逻辑，以及生成新的回复。</p><h2 id="总结">总结</h2><p>这篇文章里我先提出了微服务开发中一个常见的问题，然后介绍了 <code>Telepresence</code> 项目，并且举例说明了怎样用它来调试两种常见的微服务场景。当然，Telepresence 还在不断的演进，本文中使用的是 v0.101 版本，后续版本很可能有些不一样的地方，也欢迎大家不断指正。</p><blockquote><p>来源：喵叔没话说</p><p>原文：<a href="https://url.cn/5SnZHs3" target="_blank" rel="noopener">https://url.cn/5SnZHs3</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务作为一种全新的软件架构现在正变得越来越火。基本原因我觉得有两点：一方面软件系统越做越复杂，通过拆分将一个大系统解耦成一个个独立的子系统，我们就降低了整个系统的复杂性。另一方面，Kubernetes 的出现使得编排这么多子系统变得简单，可以说 Kubernetes 是目前为止微服务最好的载体。&lt;/p&gt;
&lt;p&gt;Kubernetes 解决了微服务运行时的环境问题，但对开发环境就不那么友好了。比方说如果我们要在本地开发调试一个服务 A，但服务 A 可能依赖服务B、C，而服务 B 又有一层依赖 D，我们就需要在本地把服务 B、C、D 都搭建起来才能调试服务 A。这显然是一个很痛苦的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/06/OXPumiy1AWHr3v9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;业界有朋友用 &lt;code&gt;docker-compose&lt;/code&gt; 来模拟集群中的场景。这个方案的不足之处在于它需要把 &lt;code&gt;Kubernetes&lt;/code&gt; 的那一套逻辑用 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件重写一遍，这给我们带来了维护成本。另一方面，有的时候依赖树太大，本地机器完全无法同时运行这么多服务。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ratesvc:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  image: kubeapps&amp;#x2F;ratesvc:latest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  environment:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - JWT_KEY&amp;#x3D;secret  # &amp;lt;------------------------ 手工维护&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  command:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - &amp;#x2F;ratesvc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - --mongo-url&amp;#x3D;mongodb:&amp;#x2F;&amp;#x2F;root@mongodb  # &amp;lt;---- 手工维护&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - --mongo-database&amp;#x3D;ratesvc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mongodb:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  image: bitnami&amp;#x2F;mongodb:3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  environment:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - MONGODB_ROOT_PASSWORD&amp;#x3D;password123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;auth:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  image: kubeapps&amp;#x2F;oauth2-bitnami:latest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  volumes:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - .&amp;#x2F;config.yaml:&amp;#x2F;config&amp;#x2F;monocular.yaml  # &amp;lt;-- 手工维护&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;volumnes:  # &amp;lt;----------------------------------- 手工维护&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  monocular-data:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另一种解决方案就是我这里要介绍的 &lt;code&gt;Telepresence&lt;/code&gt; 了，它能够在不修改程序代码的情况下，让本地应用程序无感的接入到 &lt;code&gt;Kubernetes&lt;/code&gt; 集群中，这样你就可以直接在本地开发调试微服务了。&lt;/p&gt;
&lt;h2 id=&quot;Telepresence-简介&quot;&gt;Telepresence 简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Telepresence&lt;/code&gt; 是一个 &lt;code&gt;CNCF&lt;/code&gt; 基金会下的项目。它的工作原理是在本地和 &lt;code&gt;Kubernetes&lt;/code&gt; 集群中搭建一个透明的双向代理，这使得我们可以在本地用熟悉的 &lt;code&gt;IDE&lt;/code&gt; 和调试工具来运行一个微服务，同时该服务还可以无缝的与 &lt;code&gt;Kubernetes&lt;/code&gt; 集群中的其他服务进行交互，好像它就运行在这个集群中一样。&lt;/p&gt;
&lt;p&gt;这是一个 &lt;code&gt;Telepresence&lt;/code&gt; 工作原理图，它将集群中的数据卷、环境变量、网络都代理到了本地（除了数据卷外，其他两个对应用程序来说都是透明的）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/06/79IMTeOFfJ8p5wb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;有了这些代理之后：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;本地的服务就可以完整的访问到远程集群中的其他服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地的服务直接访问到 Kubernetes 里的各种资源，包括环境变量、Secrets、Config map 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;甚至集群中的服务还能直接访问到本地暴露出来的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Telepresence-安装&quot;&gt;Telepresence 安装&lt;/h2&gt;
&lt;p&gt;这里只说一下如何在 &lt;code&gt;macOS&lt;/code&gt; 下进行安装。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew cask install osxfuse  &lt;span class=&quot;comment&quot;&gt;# required by sshfs to mount the pod&#39;s filesystem&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ brew install datawire/blackbird/telepresence&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;其他平台请参考：&lt;a href=&quot;https://www.telepresence.io/reference/install&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.telepresence.io/reference/install&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果官方的安装包没有覆盖到你的平台，其实也可以从源代码安装，因为它本身就是用 &lt;code&gt;Python 3&lt;/code&gt; 写的，熟悉 &lt;code&gt;Python&lt;/code&gt; 的朋友安装这个程序应该不难，我自己就在 &lt;code&gt;CentOS 7&lt;/code&gt; 上安装成功了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="Telepresence" scheme="https://www.hi-linux.com/tags/Telepresence/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂 Kubernetes 应用部署工具 Kustomize 和 Helm 的优劣势</title>
    <link href="https://www.hi-linux.com/posts/46223.html"/>
    <id>https://www.hi-linux.com/posts/46223.html</id>
    <published>2020-05-17T01:00:00.000Z</published>
    <updated>2020-05-17T07:53:44.441Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将记录为什么最终没有采用 <code>Helm</code> 而是选择了 <code>Kustomize</code> 作为 <code>Kubernetes</code> 应用的部署工具。</p><h2 id="使用各种项目管理之前的情况">使用各种项目管理之前的情况</h2><p>首先说说之前的痛点。我们虽然不是个大公司，可是这代码也是越敲越多，服务也是越做越全。零零总总也有十几个项目要管理了。然后我们同样有多套部署环境：内网环境，预生产环境，生产环境。那么针对每一个环境几乎都要有一套 <code>Kubernetes</code> 的 YAML 文件，但是各个仅仅是稍有不同。</p><p>然后我们自己的 <code>CI</code> 是将构建好的 <code>Docker</code> 镜像放到 <code>Registry</code> 里面。</p><p>那么，每次更新的镜像之后就是通过人手工去部署一下，绝大多数情况就是修改一下镜像的 <code>Tag</code>，但是由于每个环境的 YAML 略有区别，那么如果我需要在不同环境切换的时候就需要来回修改这些 YAML 文件，一不小心写错了就只能怪自己手残。然而这种部署方式虽然在 <code>Kubernetes</code> 之下就是改改 YAML 就好了，但是依然感觉很是原始。</p><h2 id="希望有什么改善">希望有什么改善</h2><p>仔细想想，自己的需求就是这么几个：</p><ol><li>有一个统一的模板可以管理一个项目的 <code>Kubernetes</code> 部署结构</li><li>有某种方式可以管理不同环境之间微小的差异</li><li>每次更新基本就是修改镜像的标签然后部署，那么有没有什么简单的办法实现之，而不是让我每次都去修改 YAML 文件</li></ol><h2 id="针对-helm-的调研">针对 Helm 的调研</h2><p>既然都说 <code>Helm</code> 是 <code>Kubernetes</code> 的包管理工具，那么我就先去尝试了一下 <code>Helm</code>。</p><p><img src="https://i.loli.net/2019/08/14/4bFXOTAy3ILzWQ1.jpg" alt=""></p><blockquote><p>Helm 是 Deis 开发的一个用于 Kubernetes 应用的包管理工具，主要用来管理 Charts。有点类似于 Ubuntu 中的 APT 或 CentOS 中的 YUM。</p><p>Helm Chart 是用来封装 Kubernetes 原生应用程序的一系列 YAML 文件。可以在你部署应用的时候自定义应用程序的一些 Metadata，以便于应用程序的分发。</p><p>对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。</p><p>对于使用者而言，使用 Helm 后不用需要编写复杂的应用部署文件，可以以简单的方式在 Kubernetes 上查找、安装、升级、回滚、卸载应用程序。</p></blockquote><p>更多 <code>Helm</code> 的介绍可参考 「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486154&amp;idx=1&amp;sn=becd5dd0fadfe0b6072f5dfdc6fdf786&amp;chksm=eac52be3ddb2a2f555b8b1028db97aa3e92d0a4880b56f361e4b11cd252771147c44c08c8913&amp;token=2022032653&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Helm 入门指南</a>」 一文。</p><p>简单的看了看，<code>Helm</code> 给我一种大而无当的感觉：它真的是一个做包管理工具的，复杂的 <code>Go Template</code> 体系以及需要单独存放的 <code>Charts</code> 让我感觉其更适合对标 <code>Ubuntu</code> 的 <code>APT</code> 或者 <code>macOS</code> 的 <code>Brew</code>。它更像是对外提供一个复杂的可以依据各种配置信息生成适合于不同环境的软件发布包，而不是用于我们这种轻量级的部署配置管理的。所以我就放弃使用 <code>Helm</code> 了。</p><a id="more"></a><h2 id="针对-kustomize-的调研">针对 Kustomize 的调研</h2><p>在这个时候我想起来了在之前 <code>Github Trending</code> 看到的另外一个用户做 <code>Kubernetes</code> 配置的工具 <code>Kustomize</code>。简单的说，它就是一个简化 <code>Kubernetes</code> YAML 编写的工具。它提供了两个重要的功能恰好满足了我的需求。</p><blockquote><p>Kustomize 是一个新晋选手，只有一个 CLI 工具。在 Kubernetes 1.14 之后，甚至这唯一的工具也成为 kubectl 的一部分。</p><p>Kustomize 放弃了对模板的要求，改用 Base + Overlay 的方式对应用的原始 YAML 进行派生。Overlay，顾名思义，就是覆盖。Kustomize 的 Overlay 可以在 Base 的基础上，通过对 resource、generator、transformer 等的定义，形成新的应用定义，不论 Base 还是 Overlay，都可以通过 kustomize build 生成有效的 YAML。</p></blockquote><h3 id="kustomize-的特色">Kustomize 的特色</h3><ol><li>功能简单清晰，kubectl 直接支持。</li><li>不考虑派生，仅作为应用的 YAML 组织方式也很有帮助。</li><li>自身支持插件。</li></ol><h3 id="继承和-patch">继承和 Patch</h3><p><code>Kustomize</code> 可以设置如下的层次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── base</span><br><span class="line">│   ├── deployment.yaml</span><br><span class="line">│   ├── kustomization.yaml</span><br><span class="line">│   └── service.yaml</span><br><span class="line">└── overlays</span><br><span class="line">    └── stg</span><br><span class="line">        ├── ingress.yaml</span><br><span class="line">        └── kustomization.yaml</span><br></pre></td></tr></table></figure><p>其中 base 里保存各个环境所有的公有配置 <code>base/kustomization.yaml</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resources:</span><br><span class="line">- deployment.yaml</span><br><span class="line">- service.yaml</span><br></pre></td></tr></table></figure><p>然后在 overlays 中可以定义子环境 <code>overlays/stg/kustomization.yaml</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bases:</span><br><span class="line">- ..&#x2F;..&#x2F;base</span><br><span class="line"></span><br><span class="line">resources:</span><br><span class="line">- ingress.yaml</span><br></pre></td></tr></table></figure><p>可以看到 stg 下继承了 base 的配置，并且添加了 ingress.yaml 配置。同时，<code>Kustomize</code> 不仅仅支持文件级别的 patch，还支持对一个文件某些字段的 patch。</p><p>如下图所示，replica_count.yaml 只包含了有关 replicas 的部分即可，在执行 <code>kustomize build</code> 之后就可以将这部分覆盖默认的配置。</p><p><img src="https://i.loli.net/2019/08/14/cFlArJSXfEj67Kp.jpg" alt=""></p><h3 id="edit-命令">edit 命令</h3><p><code>Kustomize</code> 提供了一个命令行方法对镜像 Tag 进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kustomize edit set imagetag xxx:94c269ec</span><br></pre></td></tr></table></figure><p>如果想更方便的使用，你还可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export NEWTAG&#x3D;94c269ec</span><br><span class="line">$ kustomize edit set imagetag xxx:$NEWTAG</span><br></pre></td></tr></table></figure><p>那么每次都去 <code>ctrl-r</code> 修改这个 <code>export</code> 然后再 <code>ctrl-r</code> 找到第二条命令执行一下就好了。虽然它还是修改了 kustomization.yaml 但是我觉得比打开编辑器改要舒服一些。</p><h2 id="kustomize-额外加分项">Kustomize 额外加分项</h2><h3 id="轻量级">轻量级</h3><p>相对 <code>Helm</code>，<code>Kustomize</code> 依然保留了对 <code>kubectl apply -f</code> 命令的支持，仅仅作为一个命令行工具；不像 <code>Helm</code> 还需要在 <code>K8s</code> 里面部署一个 <code>Tiller</code> 可谓是非常的轻量级了。</p><h3 id="对-secret-和-configmap-的支持">对 Secret 和 Configmap 的支持</h3><p>分别举例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bases:</span><br><span class="line">- ..&#x2F;..&#x2F;base</span><br><span class="line"></span><br><span class="line">configMapGenerator:</span><br><span class="line">- literals:</span><br><span class="line">  - STORAGE.DATASETUPLOADURL&#x3D;https:&#x2F;&#x2F;xxx&#x2F;files&#x2F;datasets</span><br><span class="line">  - STORAGE.CODEUPLOADURL&#x3D;https:&#x2F;&#x2F;xxx&#x2F;files&#x2F;codes</span><br><span class="line">  - LIVELOG_PREFIX&#x3D;https:&#x2F;&#x2F;xxx&#x2F;jobs</span><br><span class="line">  name: storage-server</span><br><span class="line"></span><br><span class="line">resources:</span><br><span class="line">- ingress.yaml</span><br><span class="line"></span><br><span class="line">imageTags:</span><br><span class="line">- name: xxx</span><br><span class="line">  newTag: dc12c4d7</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resources:</span><br><span class="line">- deployment.yaml</span><br><span class="line"></span><br><span class="line">secretGenerator:</span><br><span class="line">- name: notification-service</span><br><span class="line">  commands:</span><br><span class="line">    SHORT_MESSAGE_API_KEY: &quot;bash -c &#39;echo -n $SHORT_MESSAGE_API_KEY&#39;&quot;</span><br><span class="line">    MG_API_KEY: &quot;bash -c &#39;echo -n $MG_API_KEY&#39;&quot;</span><br><span class="line">  type: Opaque</span><br><span class="line"></span><br><span class="line">generatorOptions:</span><br><span class="line">  disableNameSuffixHash: true</span><br></pre></td></tr></table></figure><p><code>secretGenerator</code> 和 <code>configMapGenerator</code> 可以以更灵活的方式生成 <code>configmap</code> 和 <code>secret</code>，相对来说更方便吧。</p><p>然后注意看我 <code>configMapGenerator</code> 的例子，<code>echo -n $xxx</code> 是会有问题的，一定要使用 <code>&quot;bash -c 'echo -n $SHORT_MESSAGE_API_KEY'&quot;</code> 的命令。</p><h2 id="kustomize-和-helm-的区别">Kustomize 和 Helm 的区别</h2><p>我认为他们的区别主要在工作流程上：</p><ol><li><p>Helm 的基础流程比较瀑布：定义 Chart-&gt;填充-&gt;运行，在 Chart 中没有定义的内容是无法更改的；</p></li><li><p>Kustomize 的用法比较迭代：Base 和 Overlay 都是可以独立运作的，增加新对象，或者对编写 Base 时未预料的内容进行变更，都不在话下。</p></li></ol><p>例如：我们定义了一个很基础的应用，由 Deployment + Service 组成，如果后续部署中需要完成两个变更：新建 Ingress 对象和修改镜像地址/名称/TAG。</p><ol><li>使用 Helm 你需要的步骤：</li></ol><ul><li>在 Chart 中加入对 Ingress 的定义</li><li>用变量控制 Ingress 是否进行渲染</li><li>Ingress 模板应该包含特定的主机名、注解等变量</li><li>把镜像也定义成变量</li><li>在 Values.yaml 中对这些变量进行赋值。</li></ul><ol start="2"><li>使用 Kustomize 你需要的步骤：</li></ol><ul><li>无需对 Base 进行修改</li><li>直接在新的 Overlay 中写入 Ingress Resource</li><li>使用内置的 image transformer 替换原有镜像</li></ul><h2 id="结论">结论</h2><p>要公开发布一个较为复杂的应用，编写良好的 Chart 能给用户很大帮助，用户通过对 values.yaml 的阅读，就能对这种复杂的部署产生一个较为深入的认识。</p><p>如果是常见的业务应用，因为不同部署之间的差异不大，用 Kustomize 可能会是一个更好的选择。</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="https://aisensiy.github.io/2018/11/27/helm-and-kustomize/" target="_blank" rel="noopener">https://aisensiy.github.io/2018/11/27/helm-and-kustomize/</a></li><li><a href="https://blog.fleeto.us/post/helm-vs-kustomize/" target="_blank" rel="noopener">https://blog.fleeto.us/post/helm-vs-kustomize/</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录为什么最终没有采用 &lt;code&gt;Helm&lt;/code&gt; 而是选择了 &lt;code&gt;Kustomize&lt;/code&gt; 作为 &lt;code&gt;Kubernetes&lt;/code&gt; 应用的部署工具。&lt;/p&gt;
&lt;h2 id=&quot;使用各种项目管理之前的情况&quot;&gt;使用各种项目管理之前的情况&lt;/h2&gt;
&lt;p&gt;首先说说之前的痛点。我们虽然不是个大公司，可是这代码也是越敲越多，服务也是越做越全。零零总总也有十几个项目要管理了。然后我们同样有多套部署环境：内网环境，预生产环境，生产环境。那么针对每一个环境几乎都要有一套 &lt;code&gt;Kubernetes&lt;/code&gt; 的 YAML 文件，但是各个仅仅是稍有不同。&lt;/p&gt;
&lt;p&gt;然后我们自己的 &lt;code&gt;CI&lt;/code&gt; 是将构建好的 &lt;code&gt;Docker&lt;/code&gt; 镜像放到 &lt;code&gt;Registry&lt;/code&gt; 里面。&lt;/p&gt;
&lt;p&gt;那么，每次更新的镜像之后就是通过人手工去部署一下，绝大多数情况就是修改一下镜像的 &lt;code&gt;Tag&lt;/code&gt;，但是由于每个环境的 YAML 略有区别，那么如果我需要在不同环境切换的时候就需要来回修改这些 YAML 文件，一不小心写错了就只能怪自己手残。然而这种部署方式虽然在 &lt;code&gt;Kubernetes&lt;/code&gt; 之下就是改改 YAML 就好了，但是依然感觉很是原始。&lt;/p&gt;
&lt;h2 id=&quot;希望有什么改善&quot;&gt;希望有什么改善&lt;/h2&gt;
&lt;p&gt;仔细想想，自己的需求就是这么几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有一个统一的模板可以管理一个项目的 &lt;code&gt;Kubernetes&lt;/code&gt; 部署结构&lt;/li&gt;
&lt;li&gt;有某种方式可以管理不同环境之间微小的差异&lt;/li&gt;
&lt;li&gt;每次更新基本就是修改镜像的标签然后部署，那么有没有什么简单的办法实现之，而不是让我每次都去修改 YAML 文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;针对-Helm-的调研&quot;&gt;针对 Helm 的调研&lt;/h2&gt;
&lt;p&gt;既然都说 &lt;code&gt;Helm&lt;/code&gt; 是 &lt;code&gt;Kubernetes&lt;/code&gt; 的包管理工具，那么我就先去尝试了一下 &lt;code&gt;Helm&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/14/4bFXOTAy3ILzWQ1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Helm 是 Deis 开发的一个用于 Kubernetes 应用的包管理工具，主要用来管理 Charts。有点类似于 Ubuntu 中的 APT 或 CentOS 中的 YUM。&lt;/p&gt;
&lt;p&gt;Helm Chart 是用来封装 Kubernetes 原生应用程序的一系列 YAML 文件。可以在你部署应用的时候自定义应用程序的一些 Metadata，以便于应用程序的分发。&lt;/p&gt;
&lt;p&gt;对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。&lt;/p&gt;
&lt;p&gt;对于使用者而言，使用 Helm 后不用需要编写复杂的应用部署文件，可以以简单的方式在 Kubernetes 上查找、安装、升级、回滚、卸载应用程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多 &lt;code&gt;Helm&lt;/code&gt; 的介绍可参考 「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247486154&amp;amp;idx=1&amp;amp;sn=becd5dd0fadfe0b6072f5dfdc6fdf786&amp;amp;chksm=eac52be3ddb2a2f555b8b1028db97aa3e92d0a4880b56f361e4b11cd252771147c44c08c8913&amp;amp;token=2022032653&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Helm 入门指南&lt;/a&gt;」 一文。&lt;/p&gt;
&lt;p&gt;简单的看了看，&lt;code&gt;Helm&lt;/code&gt; 给我一种大而无当的感觉：它真的是一个做包管理工具的，复杂的 &lt;code&gt;Go Template&lt;/code&gt; 体系以及需要单独存放的 &lt;code&gt;Charts&lt;/code&gt; 让我感觉其更适合对标 &lt;code&gt;Ubuntu&lt;/code&gt; 的 &lt;code&gt;APT&lt;/code&gt; 或者 &lt;code&gt;macOS&lt;/code&gt; 的 &lt;code&gt;Brew&lt;/code&gt;。它更像是对外提供一个复杂的可以依据各种配置信息生成适合于不同环境的软件发布包，而不是用于我们这种轻量级的部署配置管理的。所以我就放弃使用 &lt;code&gt;Helm&lt;/code&gt; 了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="Helm" scheme="https://www.hi-linux.com/tags/Helm/"/>
    
      <category term="Kustomize" scheme="https://www.hi-linux.com/tags/Kustomize/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 1 期 )</title>
    <link href="https://www.hi-linux.com/posts/43626.html"/>
    <id>https://www.hi-linux.com/posts/43626.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T04:33:24.280Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h3 id="业界资讯">业界资讯</h3><p>1、<a href="https://www.williamlong.info/archives/5747.html" target="_blank" rel="noopener">中国设立互联网根服务器</a></p><p>近日，中国工信部官网一篇题为 “工业和信息化部关于同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及域名根服务器运行机构的批复” 的文章引起外界广泛关注。工信部当天的消息称，同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及成为域名根服务器运行机构，负责运行、维护和管理相关域名根服务器。</p><p>链接：<a href="https://www.williamlong.info/archives/5747.html" target="_blank" rel="noopener">https://www.williamlong.info/archives/5747.html</a></p><p>2、<a href="https://www.solidot.org/story?sid=61096" target="_blank" rel="noopener">微软正式发布 Windows Terminal 预览版</a></p><p>微软在 Microsoft Store 发布了 Windows Terminal 的预览版。</p><p>Windows Terminal 是微软上个月在开发者大会上宣布的新命令行终端，源代码发布在 GitHub 上。Windows Terminal 支持多标签、Unicode 和 UTF-8 字符、GPU 加速 DirectWrite/DirectX 文本渲染引擎，定制主题、样式和配置。更多特性详细介绍可参考<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487033&amp;idx=1&amp;sn=2cc918c4a2f9ddf7da341e7996183872&amp;chksm=eac52f10ddb2a606ee40e98646dc8eb8b4409ef88169c6172f5b42ead00c866c4693d7a3387f&amp;token=1817029934&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a> 。</p><p>下载安装 Windows Terminal  需要 Windows 10 version 18362.0 及更新版本。</p><p>链接：<a href="https://www.solidot.org/story?sid=61096" target="_blank" rel="noopener">https://www.solidot.org/story?sid=61096</a></p><p><img src="https://i.loli.net/2019/07/29/5d3ebfc2aaafd80489.jpg" alt=""></p><p>3、<a href="https://www.oschina.net/news/107833/dns-over-https-ga" target="_blank" rel="noopener">谷歌宣布 DNS Over HTTPS 服务普遍可用</a></p><p>谷歌于 2009 年推出 Google Public DNS，并于 2016 年在此基础上推出 DNS Over HTTPS，这是一项实验性服务，旨在加强 DNS 的安全性，此前的服务入口是 <a href="http://dns.google.com/experimental%E3%80%82" target="_blank" rel="noopener">dns.google.com/experimental。</a></p><p>现在谷歌宣布 DoH 已经正式普遍可用，并且完全支持 RFC 8484 文档，同时继续提供对 2016 年推出的 JSON API 的支持。用户可以使用 dns.google 域中的 DoH 解析 DNS，其中包含与常规 DNS 服务相同的任播地址，如 8.8.8.8。新的访问入口是：<a href="https://dns.google/dns-query" target="_blank" rel="noopener">https://dns.google/dns-query</a> ((RFC 8484) 和 <a href="https://dns.google/resolve" target="_blank" rel="noopener">https://dns.google/resolve</a> (JSON API)。</p><p>链接：<a href="https://www.oschina.net/news/107833/dns-over-https-ga" target="_blank" rel="noopener">https://www.oschina.net/news/107833/dns-over-https-ga</a></p><p><img src="https://oscimg.oschina.net/oscnet/fe994bc0e5e401523320b7953a92696045f.jpg" alt=""></p><p>4、<a href="http://news.51cto.com/art/201906/598801.htm" target="_blank" rel="noopener">Mozilla 发布下一代移动浏览器 Firefox Preview</a></p><p>Mozilla 已于近日在 Google Play 正式上架面向 Android 的全新移动浏览器 Firefox Preview。</p><p>与现已推出与大多数浏览器所采用的 Bink 渲染引擎不同，Firefox Preview 的渲染引擎 GeckoView 由 Mozilla 自己开发，这种独立性一定程度上避免了互联网被单一的科技巨头控制。</p><p>虽然已经公开发布，不过 Mozilla 表示 Firefox Preview 仍处于测试阶段，真正的大招会憋到今年秋季再放，届时将提供更丰富的功能和更精美的界面。</p><p>链接：<a href="http://news.51cto.com/art/201906/598801.htm" target="_blank" rel="noopener">http://news.51cto.com/art/201906/598801.htm</a></p><p><img src="https://s4.51cto.com/oss/201907/01/da021001f2e94c283777ac8f67a880b8.jpg-wh_651x-s_2719880675.jpg" alt=""></p><p>5、<a href="https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop" target="_blank" rel="noopener">OpenJDK Docker 镜像存在错误版本漏洞</a></p><p>OpenJDK 邮件列表确认，OpenJDK 的官方 Docker 镜像中包含错误标记版本号，这表明部分 JRE 应包含的安全补丁实际上并不存在。</p><p>该问题已经通过 OpenJDK 和 Debian 间的跨社区协作得以解决。该 “官方” 版本是由 Docker 和其他方制作的，因为 OpenJDK 社区没有创建镜像或生成构建。该 Docker 镜像已被下载超过一千万次。</p><p>链接：<a href="https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop" target="_blank" rel="noopener">https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop</a></p><p>6、<a href="https://www.oschina.net/news/107663/v-lang-source-code-released" target="_blank" rel="noopener">安全的全新编程语言 V 发布首个可用版本</a></p><p>日前，一种新的静态类型编程语言 V 语言正式开源了，并发布了首个可用版本。</p><p>据了解，V 语言全名叫：Vlang。V 语言是一个结合 Go 语言的简洁以及 Rust 的安全特性的新语言，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。</p><p>链接：<a href="https://www.oschina.net/news/107663/v-lang-source-code-released" target="_blank" rel="noopener">https://www.oschina.net/news/107663/v-lang-source-code-released</a></p><p><img src="https://raw.githubusercontent.com/vlang/v/master/examples/tetris/screenshot.png" alt=""></p><a id="more"></a><h3 id="趣站酷软">趣站酷软</h3><p>1、<a href="https://github.com/Eugeny/terminus" target="_blank" rel="noopener">Terminus</a></p><p>Terminus 是一个高度可配置的终端模拟器，适用于 Windows、macOS 和 Linux。</p><p>项目地址: <a href="https://github.com/Eugeny/terminus" target="_blank" rel="noopener">https://github.com/Eugeny/terminus</a></p><p><img src="https://raw.githubusercontent.com/Eugeny/terminus/master/docs/readme.png" alt=""></p><p>2、<a href="https://github.com/ovity/octotree" target="_blank" rel="noopener">Octotree</a></p><p>一个浏览器插件，可以将 GitHub 的仓库变成文件浏览器，提供便于查看的树状文件结构。</p><p>项目地址: <a href="https://github.com/ovity/octotree" target="_blank" rel="noopener">https://github.com/ovity/octotree</a></p><p><img src="https://raw.githubusercontent.com/ovity/octotree/v3/docs/chrome-github.png" alt=""></p><p>3、<a href="https://github.com/Peltoche/lsd" target="_blank" rel="noopener">LSD</a></p><p>文件列表命令 ls 的替代品。</p><p>项目地址: <a href="https://github.com/Peltoche/lsd" target="_blank" rel="noopener">https://github.com/Peltoche/lsd</a></p><p><img src="https://raw.githubusercontent.com/Peltoche/lsd/assets/screen_lsd.png" alt=""></p><p>4、<a href="https://github.com/marcenacp/kubeasy" target="_blank" rel="noopener">Kubeasy</a></p><p>一个用来管理 Kubernetes 集群的 CLI 工具，提供了沉浸式的命令行界面。</p><p>项目地址: <a href="https://github.com/marcenacp/kubeasy" target="_blank" rel="noopener">https://github.com/marcenacp/kubeasy</a></p><p><img src="https://raw.githubusercontent.com/marcenacp/kubeasy/master/public/kubeasy.gif" alt=""></p><p>5、<a href="https://github.com/wercker/stern" target="_blank" rel="noopener">Stern</a></p><p>Stern 是 Kubernetes 下多容器日志查看工具，如果你有需求一次看多个 Pod 的日志，Stern 这个工具可以将日志从多个 Pod 中拉出来，非常方便实用。</p><p>Stern 支持正则表达式，只需以 Pod 部署名称开头就可以跟踪所有部署 Pod 中的日志，并不需要知道每个 Pod 的确切名称。</p><p>项目地址: <a href="https://github.com/wercker/stern" target="_blank" rel="noopener">https://github.com/wercker/stern</a></p><p><img src="https://static001.infoq.cn/resource/image/b4/8a/b4b4400dc8666b0c4176871d829dcf8a.png" alt=""></p><p>6、<a href="https://github.com/wfxr/tmux-fzf-url" target="_blank" rel="noopener">tmux-fzf-url</a></p><p>tmux-fzf-url 是一个Tmux 插件，可以帮助你解放鼠标，提高工作效率的 CLI 工具。它可以从终端快速打开屏幕中的 URL，当 URL 有多个的时候，还可以通过 FZF 进行交互式地筛选，同时打开所有选中的链接，全程无需使用鼠标。（ 配合浏览器插件 cVim、Surfingkeys 等使用更佳）</p><p>项目地址: <a href="https://github.com/wfxr/tmux-fzf-url" target="_blank" rel="noopener">https://github.com/wfxr/tmux-fzf-url</a></p><p><img src="https://raw.githubusercontent.com/wfxr/i/master/tmux-fzf-url.gif" alt=""></p><p>7、<a href="https://github.com/jiansiting/Decryption-Tools" target="_blank" rel="noopener">Decryption-Tools</a></p><p>一个勒索病毒解密工具的仓库，上面收集了各种勒索病毒解密工具, 希望对大家有用。</p><p>项目地址: <a href="https://github.com/jiansiting/Decryption-Tools" target="_blank" rel="noopener">https://github.com/jiansiting/Decryption-Tools</a></p><h3 id="技术文章">技术文章</h3><p>1、<a href="https://tonybai.com/2019/06/25/using-git-with-svn-repo/" target="_blank" rel="noopener">使用 Git 操作 SVN 仓库</a></p><p>如今，虽然 Git 已经大行其道，但是仍有很多 IT 公司和组织依旧在使用集中式的版本控制系统 Subversion，尤其是一些传统软件公司，他们倾向于集中式的联网开发。</p><p>如果你是一个 Git Fans，并且你要是遇到代码仓库依旧是使用 Subversion 进行版本控制的情况，你又该如何施展呢？</p><p>本文将介绍一种如何优雅的使用 Git 对 Subversion 仓库进行操作的方法。</p><p>链接：<a href="https://tonybai.com/2019/06/25/using-git-with-svn-repo/" target="_blank" rel="noopener">https://tonybai.com/2019/06/25/using-git-with-svn-repo/</a></p><p>2、<a href="http://dockone.io/article/8832" target="_blank" rel="noopener">容器发展简史</a></p><p>在过去四年中（2015-2019），云以及分布式计算成为最受欢迎的技术之一，它们从小众技能逐渐变成更被雇主看重的突出技能。容器化技术是云经济和 IT 生态系统中最新潮的技术之一。这篇文章可能会帮助您理解有关 Docker 和容器的一些令人困惑的概念。我们还将看到容器化生态系统在 2019 年的现状以及演变方向。</p><p>链接：<a href="http://dockone.io/article/8832" target="_blank" rel="noopener">http://dockone.io/article/8832</a></p><p>3、<a href="https://zhuanlan.zhihu.com/p/69554144" target="_blank" rel="noopener">怎样去理解 Linux 用户态和内核态？</a></p><p>在 Linux 技术讨论中经常会用户态和内核态术语脱口而出，可你们想过吗？用户态和内核态代表是什么？本片文章，就来谈一谈这个话题。</p><p>链接：<a href="https://zhuanlan.zhihu.com/p/69554144" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69554144</a></p><p>4、<a href="https://www.sysgeek.cn/configure-dns-over-https-in-firefox/" target="_blank" rel="noopener">如何为 Firefox 浏览器配置 DNS Over HTTPS 支持</a></p><p>DNS 查询在当今互联网上扮演着不可或缺的重要角色，当您在浏览器地址栏中输入域名访问网站时，就是由 DNS 服务进行名称查询并解析为对应服务端的 IP 地址，这些由客户端自动发起的 DNS 查询通常都没有任何形式的加密、防偷窥或防篡改措施。</p><p>DNS over HTTPS 是一项相对较新的安全新功能，它可以提高 DNS 查询的隐私性、安全性和连接可靠性，主要由 Google、Cloudflare 和 Mozilla 等领先技术的科技公司在产品中使用。</p><p>本文将介绍如何在 Firefox 浏览器中启用 DNS Over HTTPS 的方法。</p><p>链接 1：<a href="https://www.sysgeek.cn/configure-dns-over-https-in-firefox/" target="_blank" rel="noopener">https://www.sysgeek.cn/configure-dns-over-https-in-firefox/</a><br>链接 2：<a href="https://zhuanlan.zhihu.com/p/42468805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42468805</a></p><p>5、<a href="https://www.oschina.net/news/107847/geckoview-in-2019" target="_blank" rel="noopener">聊聊 Firefox Preview 背后的渲染引擎 GeckoView</a></p><p>通过将 GeckoView 引擎与 Firefox 应用程序相分离，开发团队创建了一种更新、更快和更容易维护的方式来开发 Android 应用程序。这种方法利用了 Gecko 卓越的性能、隐私和对最新 Web 标准的支持。</p><p>本文将介绍一些关于 GeckoView 的特性和应用案例。</p><p>链接：<a href="https://www.oschina.net/news/107847/geckoview-in-2019" target="_blank" rel="noopener">https://www.oschina.net/news/107847/geckoview-in-2019</a></p><h3 id="每周观点">每周观点</h3><p>1、钓鱼的两个原则：一是在有鱼的地方钓鱼，二是不要忘记第一条原则。投资的道理也是一样的。在一些地方，无论你是多好的渔夫，你也不可能钓到很多鱼。生活是一场持久的比赛，接受生活，竭尽全力地做事。如果你能够活到很大的年纪，你会获得很多机遇，可能总共是两种机遇，但抓住其中一个机遇就好啦。—— 查理∙芒格</p><p>2、向那些狂妄之徒致敬。那些特立独行的，桀骜不驯的，那些惹是生非的，格格不入的。那些喜欢另辟蹊径，绝不墨守成规，从不安于现状的家伙。你可以赞美他们，引述他们，反对他们，质疑他们，颂扬或是诋毁他们，却惟独不能忽视他们，因为他们改变了事物。他们发明，想象，治愈，他们探索，创造，启迪，他们推动人类进步。他们或有不得不疯狂的理由。你能于白纸之上看到美妙的画作么？你能于寂静之中听见动人的乐声么？你能于星空之中想到神奇的太空轮么？我们为这些家伙制造良机。别人看到的或为疯子，我们看到的却是天才。因为，只有那些疯狂到以为自己能够改变世界的人，才能真正地改变世界。——「Think Different，1997 年 Apple 广告」</p><p>3、想换个方式喜欢你了，不追逐、不逢迎、无风雨、无喜悲。——德卡先生的信箱</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h3 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.williamlong.info/archives/5747.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中国设立互联网根服务器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，中国工信部官网一篇题为 “工业和信息化部关于同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及域名根服务器运行机构的批复” 的文章引起外界广泛关注。工信部当天的消息称，同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及成为域名根服务器运行机构，负责运行、维护和管理相关域名根服务器。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.williamlong.info/archives/5747.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.williamlong.info/archives/5747.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.solidot.org/story?sid=61096&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软正式发布 Windows Terminal 预览版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软在 Microsoft Store 发布了 Windows Terminal 的预览版。&lt;/p&gt;
&lt;p&gt;Windows Terminal 是微软上个月在开发者大会上宣布的新命令行终端，源代码发布在 GitHub 上。Windows Terminal 支持多标签、Unicode 和 UTF-8 字符、GPU 加速 DirectWrite/DirectX 文本渲染引擎，定制主题、样式和配置。更多特性详细介绍可参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487033&amp;amp;idx=1&amp;amp;sn=2cc918c4a2f9ddf7da341e7996183872&amp;amp;chksm=eac52f10ddb2a606ee40e98646dc8eb8b4409ef88169c6172f5b42ead00c866c4693d7a3387f&amp;amp;token=1817029934&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;下载安装 Windows Terminal  需要 Windows 10 version 18362.0 及更新版本。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.solidot.org/story?sid=61096&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.solidot.org/story?sid=61096&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/29/5d3ebfc2aaafd80489.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/107833/dns-over-https-ga&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谷歌宣布 DNS Over HTTPS 服务普遍可用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;谷歌于 2009 年推出 Google Public DNS，并于 2016 年在此基础上推出 DNS Over HTTPS，这是一项实验性服务，旨在加强 DNS 的安全性，此前的服务入口是 &lt;a href=&quot;http://dns.google.com/experimental%E3%80%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dns.google.com/experimental。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在谷歌宣布 DoH 已经正式普遍可用，并且完全支持 RFC 8484 文档，同时继续提供对 2016 年推出的 JSON API 的支持。用户可以使用 dns.google 域中的 DoH 解析 DNS，其中包含与常规 DNS 服务相同的任播地址，如 8.8.8.8。新的访问入口是：&lt;a href=&quot;https://dns.google/dns-query&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dns.google/dns-query&lt;/a&gt; ((RFC 8484) 和 &lt;a href=&quot;https://dns.google/resolve&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dns.google/resolve&lt;/a&gt; (JSON API)。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/107833/dns-over-https-ga&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/107833/dns-over-https-ga&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/fe994bc0e5e401523320b7953a92696045f.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;http://news.51cto.com/art/201906/598801.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mozilla 发布下一代移动浏览器 Firefox Preview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mozilla 已于近日在 Google Play 正式上架面向 Android 的全新移动浏览器 Firefox Preview。&lt;/p&gt;
&lt;p&gt;与现已推出与大多数浏览器所采用的 Bink 渲染引擎不同，Firefox Preview 的渲染引擎 GeckoView 由 Mozilla 自己开发，这种独立性一定程度上避免了互联网被单一的科技巨头控制。&lt;/p&gt;
&lt;p&gt;虽然已经公开发布，不过 Mozilla 表示 Firefox Preview 仍处于测试阶段，真正的大招会憋到今年秋季再放，届时将提供更丰富的功能和更精美的界面。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://news.51cto.com/art/201906/598801.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://news.51cto.com/art/201906/598801.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s4.51cto.com/oss/201907/01/da021001f2e94c283777ac8f67a880b8.jpg-wh_651x-s_2719880675.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenJDK Docker 镜像存在错误版本漏洞&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OpenJDK 邮件列表确认，OpenJDK 的官方 Docker 镜像中包含错误标记版本号，这表明部分 JRE 应包含的安全补丁实际上并不存在。&lt;/p&gt;
&lt;p&gt;该问题已经通过 OpenJDK 和 Debian 间的跨社区协作得以解决。该 “官方” 版本是由 Docker 和其他方制作的，因为 OpenJDK 社区没有创建镜像或生成构建。该 Docker 镜像已被下载超过一千万次。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://www.oschina.net/news/107663/v-lang-source-code-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安全的全新编程语言 V 发布首个可用版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;日前，一种新的静态类型编程语言 V 语言正式开源了，并发布了首个可用版本。&lt;/p&gt;
&lt;p&gt;据了解，V 语言全名叫：Vlang。V 语言是一个结合 Go 语言的简洁以及 Rust 的安全特性的新语言，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/107663/v-lang-source-code-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/107663/v-lang-source-code-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/vlang/v/master/examples/tetris/screenshot.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 2 期 )</title>
    <link href="https://www.hi-linux.com/posts/43609.html"/>
    <id>https://www.hi-linux.com/posts/43609.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T04:44:06.740Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你想我们一起交流，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h3 id="业界资讯">业界资讯</h3><p>1、<a href="https://www.cnbeta.com/articles/soft/862853.htm" target="_blank" rel="noopener">GitHub 官方中文文档上线</a></p><p>GitHub 推出官方中文帮助文档，这是继日文版之后第二个非英语语种的帮助文档。GitHub 希望借此能够帮助中文开发者更好的理解 GitHub 操作规范，更加熟悉对 GitHub 的操作。</p><p>链接：<a href="https://www.cnbeta.com/articles/soft/862853.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/soft/862853.htm</a></p><p><img src="https://static.cnbetacdn.com/article/2019/0701/81c468f1fc60c58.jpeg" alt=""></p><p>2、<a href="https://github.com/microsoft/WSL2-Linux-Kernel" target="_blank" rel="noopener">微软正式开源 WSL 2 内核源码</a></p><p>微软在今年 5 月举办的 Build 2019 上宣布了第二代 Windows 的 Linux 子系统 WSL 2。与第一代相比，WSL 2 重新设计了架构，使用真正的 Linux 内核，支持在 Windows 上运行 ELF64 Linux 二进制文件。</p><p>近日，微软正式开源了 WSL 2 的内核源码，并将代码托管在 GitHub 上。</p><p>链接：<a href="https://github.com/microsoft/WSL2-Linux-Kernel" target="_blank" rel="noopener">https://github.com/microsoft/WSL2-Linux-Kernel</a></p><p><img src="https://www.hi-linux.com/img/linux/wsl2.jpeg" alt=""></p><p>3、<a href="https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1" target="_blank" rel="noopener">Gitlab 从 12.1 版本开始将不再支持 MySQL</a></p><p>Gitlab 官方宣布，将从 12.1 版本开始不再支持 MySQL 数据库。</p><p>链接：<a href="https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1" target="_blank" rel="noopener">https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1</a></p><p><img src="https://about.gitlab.com/images/blogimages/gitlab-blog-cover.png" alt=""></p><p>4、<a href="https://www.oschina.net/news/108045/debian-10-released" target="_blank" rel="noopener">Debian 10 Buster 正式发布</a></p><p>经历了 25 个月的开发后，Debian 团队于 2019 年 7 月 6 日正式宣布推出代号为 「Buster」 的 Debian 10 稳定版。</p><p>Debian 10 是一个主要版本，带来了许多更新的组件和许多新功能和改进。此版本将在未来 5 年获得由 Debian 安全团队和 Debian 长期支持团队提供的技术支持。</p><p>链接：<a href="https://www.oschina.net/news/108045/debian-10-released" target="_blank" rel="noopener">https://www.oschina.net/news/108045/debian-10-released</a></p><p><img src="https://static.oschina.net/uploads/space/2019/0707/142126_FSUH_2720166.png" alt=""></p><p>5、<a href="https://www.leikeji.com/article/27315" target="_blank" rel="noopener">Chrome 代码出现广告拦截功能，谷歌或将治理网页广告乱象</a></p><p>几乎每一个网民都逃不开广告的影响，它已经深刻地进入到我们的生活之中。无论是刷新信息流还是访问某个具体的内容，广告都会在那里出现，从不在乎你是否想看到。有一部分广告明显影响到了访问网页时的体验，有的会让内容难以查看，有的则会大幅占用系统资源，甚至让电脑操作变慢。</p><p>作为当前市场占有率最大的浏览器 Chrome 打算为用户分担一部分烦恼。根据 9to5google 的报道，Chrome 浏览器的开源代码中出现了内置广告拦截功能的踪影，这项功能将帮用户屏蔽掉部分广告。</p><p>根据页面相关描述，Chrome 会对广告对系统资源的占用进行分析，然后找出那些使用了太多带宽或者 CPU 能力的广告并屏蔽掉它们。最后用户只会看到广告被屏蔽后 “该广告已经移除” 提示。</p><p>链接：<a href="https://www.leikeji.com/article/27315" target="_blank" rel="noopener">https://www.leikeji.com/article/27315</a></p><p><img src="https://www.hi-linux.com/img/linux/chrome.png" alt=""></p><p>6、<a href="https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat" target="_blank" rel="noopener">IBM 340 亿美元红帽收购案完成：定义混合云的开放未来</a></p><p>7 月 9 日晚，IBM 宣布以 340 亿美元（约合人民币 2340 亿）正式收购红帽。早在去年 10 月 29 日，IBM 和红帽就共同宣布两家公司已达成最终协议。根据协议，IBM 将收购红帽所有已发行的普通股，每股 190 美元，总企业价值约 340 亿美元。现在，这次庞大的收购终于完成。</p><p>IBM 表示，本次收购重新定义了企业级云市场。红帽开放的混合云技术，与 IBM 广泛且深入的创新和行业洞察，以及在超过 175 个国家和地区领先的销售能力相结合，通过提供下一代混合多云平台，将共同加速企业创新。基于 Linux 和 Kubernetes 等开源技术，该平台可以使企业在本地、私有云以及多个公有云平台上安全部署、运行、管理数据及应用。</p><p>链接：<a href="https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat" target="_blank" rel="noopener">https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat</a></p><p><img src="https://oscimg.oschina.net/oscnet/30975bdc2ed93d5937c918fca2f46814f05.jpg" alt=""></p><a id="more"></a><h3 id="趣站酷软">趣站酷软</h3><p>1、<a href="https://github.com/IBM/kui" target="_blank" rel="noopener">Kui</a></p><p>Kui 是一款由 IBM 开源的用来管理 Kubernetes 集群的 CLI 工具，Kui 使用 Electron 提供 GUI 能力。</p><p>Kui 结合了原有 CLI 的强大功能，并提供一种可视化的方式，方便我们对 Kubernetes 中 YAML 或者 JSON 格式数据的处理。</p><p>项目地址: <a href="https://github.com/IBM/kui" target="_blank" rel="noopener">https://github.com/IBM/kui</a></p><p><img src="https://raw.githubusercontent.com/IBM/kui/master/docs/readme/images/kubectl-examples.jpg" alt=""></p><p>2、<a href="https://github.com/sentialx/multrin" target="_blank" rel="noopener">Multrin</a></p><p>Multrin 是一个基于 Electron、React、样式组件与 TypeScript 的应用，它可以将不同应用组织在一个 tab 标签下，大大提高生产力。</p><p>目前支持 Windows 与 macOS，Linux 支持正在开发中。</p><p>项目地址: <a href="https://github.com/sentialx/multrin" target="_blank" rel="noopener">https://github.com/sentialx/multrin</a></p><p><img src="https://github.com/sentialx/multrin/raw/master/screenshots/screen1.gif" alt=""></p><p>3、<a href="https://github.com/huangjianke/Gitter" target="_blank" rel="noopener">Gitter</a></p><p>一个 GitHub 的微信小程序客户端，可能是目前颜值最高的。</p><p>项目地址: <a href="https://github.com/huangjianke/Gitter" target="_blank" rel="noopener">https://github.com/huangjianke/Gitter</a></p><p><img src="https://raw.githubusercontent.com/huangjianke/Gitter/master/images/img00.png" alt=""></p><p>4、<a href="https://github.com/derailed/popeye" target="_blank" rel="noopener">Popeye</a></p><p>Popeye 是一个 Kubernetes 集群资源清理的实用程序，它可以实时扫描 Kubernetes 集群并报告已部署资源和配置的潜在问题。</p><p>Popeye 根据部署的内容而不是磁盘上的内容来清理群集。 通过扫描您的群集，它可以检测到错误配置并确保最佳实践，从而防止潜在问题发生。</p><p>Popeye 是一个只读工具，它不会以任何方式改变你的任何 Kubernetes 资源。</p><p>项目地址: <a href="https://github.com/derailed/popeye" target="_blank" rel="noopener">https://github.com/derailed/popeye</a></p><p><img src="https://github.com/derailed/popeye/raw/master/assets/a_score.png" alt=""></p><p>5、<a href="https://github.com/hiroppy/fusuma" target="_blank" rel="noopener">Fusuma</a></p><p>Fusuma 是一个简单方便的使用 Markdown 创建幻灯片的工具。</p><p>你只需要写好想要作为幻灯片展示的 Markdown，并按照顺序整理好目录结构，再写好需要的 CSS 文件之后，这个项目就能够让你简单的使用浏览器展示它们，或者是把它整体导出为一个 PDF 文件。</p><p>项目地址: <a href="https://github.com/hiroppy/fusuma" target="_blank" rel="noopener">https://github.com/hiroppy/fusuma</a></p><p><img src="https://raw.githubusercontent.com/hiroppy/fusuma/master/site/docs/assets/live-mode-comments.png" alt=""></p><p>6、<a href="https://github.com/jesseduffield/lazydocker" target="_blank" rel="noopener">LazyDocker</a></p><p>这是一个为了能在终端中更方便管理 Docker 和 Docker-Compose 的简单终端 UI 工具。</p><p>作者表示记住 Docker 命令很难，并且在多个终端窗口中跟踪容器几乎是不可能的。LazyDocker 正是为了解决这种问题而产生的，它可以在一个终端窗口中拥有所需的所有信息，并且每个 Docker 常用命令都可以绑定快捷键，同时可以添加自定义命令。</p><p>项目地址: <a href="https://github.com/jesseduffield/lazydocker" target="_blank" rel="noopener">https://github.com/jesseduffield/lazydocker</a></p><p><img src="https://oscimg.oschina.net/oscnet/4ad1a013236976fa04761509d03d4fbeecf.jpg" alt=""></p><h3 id="技术文章">技术文章</h3><p>1、<a href="https://www.cnblogs.com/xuxinkun/p/11025020.html" target="_blank" rel="noopener">Docker/Kubernetes 国内镜像源解决方式</a></p><p>本文整理了国内的一些 Docker/Kubernetes 可用的镜像源，非常实用。</p><p>链接：<a href="https://www.cnblogs.com/xuxinkun/p/11025020.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuxinkun/p/11025020.html</a></p><p>2、<a href="https://free.com.tw/mojave-dark-menu-bar-dock/" target="_blank" rel="noopener">如何让 macOS Mojave 只有菜单列和 Dock 使用深色模式？</a></p><p>你可能觉得 macOS 浅色介面有点刺眼，但 Mojave 深色模式又太过深邃？</p><p>至少我使用起来并不是那么愉快，反而花更多时间在辨识不太清楚的文字或图标，甚至有点怀念更早之前的暗色选单（Mojave 以后已经没有这个选项），如果你跟我一样，或许可以考虑透过一个小设定来为现在的 macOS Mojave 开启深色菜单和 Dock 功能。</p><p>链接：<a href="https://free.com.tw/mojave-dark-menu-bar-dock/" target="_blank" rel="noopener">https://free.com.tw/mojave-dark-menu-bar-dock/</a></p><p>3、<a href="https://www.jianshu.com/p/68384978c0a3" target="_blank" rel="noopener">对运维开发工作的一些思考</a></p><p>运维开发这个岗位与普通的业务开发不同，与日常的运维工作也不同，要求兼顾开发与运维两种能力。既要掌握不弱于业务开发的开发技术，又要负责 SRE 同学日常的运维能力。上线之前，还要像 QA 同学一样，对自己的服务进行测试和分级变更。本文将针对运维领域「自动化平台开发」的工作对 DevOPS 进行探讨。</p><p>链接：<a href="https://www.jianshu.com/p/68384978c0a3" target="_blank" rel="noopener">https://www.jianshu.com/p/68384978c0a3</a></p><p>4、<a href="http://blog.ihipop.info/2019/07/5212.html" target="_blank" rel="noopener">记录一次磁盘镜像的 LVM 分区缩小调整过程</a></p><p>本文将分享一些 LVM 分区大小调整的技巧。</p><p>链接：<a href="http://blog.ihipop.info/2019/07/5212.html" target="_blank" rel="noopener">http://blog.ihipop.info/2019/07/5212.html</a></p><p>5、使用斐讯 N1 作为 Prometheus 监控服务器</p><p>新出的树莓派 4，性能方面可以说对于老的 3B+ 的版本可以说是有全面的提升。但价格方面 4G 内存配置的就已经需要 50$，已经逼近台 x86 的准系统。同时因为树莓派是裸板，如果想要在生产环境使用，后面还需要自己增加存储、外壳等，全套上去其实性价比已经不高。</p><p>本文作者另辟蹊径采用斐讯的 N1 来部署了一个 Prometheus 监控服务器。</p><p>链接：<a href="https://www.gracecode.com/posts/3184.html" target="_blank" rel="noopener">https://www.gracecode.com/posts/3184.html</a></p><p><img src="https://friable.rocks/_/2019_07_01/1561965398165370.png" alt=""></p><h3 id="每周观点">每周观点</h3><p>1、梦想可以天花乱坠，理想是我们一步一个脚印踩出来的坎坷道路。—— 三毛<br>2、没事早点睡，有空多挣钱。—— 佚名<br>3、在你我生命中，都不需要完美。做自己的萤火，温暖少数人就足够了。—— 佚名<br>4、人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以至始至终陪着走完，当陪你的人要下车时，即使不舍，也该心存感激，然后挥手道别。—— 宫崎骏「千与千寻」</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你想我们一起交流，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h3 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnbeta.com/articles/soft/862853.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 官方中文文档上线&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub 推出官方中文帮助文档，这是继日文版之后第二个非英语语种的帮助文档。GitHub 希望借此能够帮助中文开发者更好的理解 GitHub 操作规范，更加熟悉对 GitHub 的操作。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/soft/862853.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/soft/862853.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.cnbetacdn.com/article/2019/0701/81c468f1fc60c58.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://github.com/microsoft/WSL2-Linux-Kernel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软正式开源 WSL 2 内核源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软在今年 5 月举办的 Build 2019 上宣布了第二代 Windows 的 Linux 子系统 WSL 2。与第一代相比，WSL 2 重新设计了架构，使用真正的 Linux 内核，支持在 Windows 上运行 ELF64 Linux 二进制文件。&lt;/p&gt;
&lt;p&gt;近日，微软正式开源了 WSL 2 的内核源码，并将代码托管在 GitHub 上。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://github.com/microsoft/WSL2-Linux-Kernel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/microsoft/WSL2-Linux-Kernel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/wsl2.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gitlab 从 12.1 版本开始将不再支持 MySQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitlab 官方宣布，将从 12.1 版本开始不再支持 MySQL 数据库。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://about.gitlab.com/images/blogimages/gitlab-blog-cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.oschina.net/news/108045/debian-10-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Debian 10 Buster 正式发布&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经历了 25 个月的开发后，Debian 团队于 2019 年 7 月 6 日正式宣布推出代号为 「Buster」 的 Debian 10 稳定版。&lt;/p&gt;
&lt;p&gt;Debian 10 是一个主要版本，带来了许多更新的组件和许多新功能和改进。此版本将在未来 5 年获得由 Debian 安全团队和 Debian 长期支持团队提供的技术支持。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108045/debian-10-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108045/debian-10-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2019/0707/142126_FSUH_2720166.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.leikeji.com/article/27315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome 代码出现广告拦截功能，谷歌或将治理网页广告乱象&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;几乎每一个网民都逃不开广告的影响，它已经深刻地进入到我们的生活之中。无论是刷新信息流还是访问某个具体的内容，广告都会在那里出现，从不在乎你是否想看到。有一部分广告明显影响到了访问网页时的体验，有的会让内容难以查看，有的则会大幅占用系统资源，甚至让电脑操作变慢。&lt;/p&gt;
&lt;p&gt;作为当前市场占有率最大的浏览器 Chrome 打算为用户分担一部分烦恼。根据 9to5google 的报道，Chrome 浏览器的开源代码中出现了内置广告拦截功能的踪影，这项功能将帮用户屏蔽掉部分广告。&lt;/p&gt;
&lt;p&gt;根据页面相关描述，Chrome 会对广告对系统资源的占用进行分析，然后找出那些使用了太多带宽或者 CPU 能力的广告并屏蔽掉它们。最后用户只会看到广告被屏蔽后 “该广告已经移除” 提示。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.leikeji.com/article/27315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.leikeji.com/article/27315&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/chrome.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IBM 340 亿美元红帽收购案完成：定义混合云的开放未来&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7 月 9 日晚，IBM 宣布以 340 亿美元（约合人民币 2340 亿）正式收购红帽。早在去年 10 月 29 日，IBM 和红帽就共同宣布两家公司已达成最终协议。根据协议，IBM 将收购红帽所有已发行的普通股，每股 190 美元，总企业价值约 340 亿美元。现在，这次庞大的收购终于完成。&lt;/p&gt;
&lt;p&gt;IBM 表示，本次收购重新定义了企业级云市场。红帽开放的混合云技术，与 IBM 广泛且深入的创新和行业洞察，以及在超过 175 个国家和地区领先的销售能力相结合，通过提供下一代混合多云平台，将共同加速企业创新。基于 Linux 和 Kubernetes 等开源技术，该平台可以使企业在本地、私有云以及多个公有云平台上安全部署、运行、管理数据及应用。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/30975bdc2ed93d5937c918fca2f46814f05.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 3 期 )</title>
    <link href="https://www.hi-linux.com/posts/27209.html"/>
    <id>https://www.hi-linux.com/posts/27209.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T04:52:42.443Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.cnbeta.com/articles/soft/865277.htm" target="_blank" rel="noopener">Linux Kernel 5.2 正式版发布，代号为 Bobtail Squid</a></p><p>经历了 7 个 RC 候选版本之后，Linus Torvalds 正式宣布了 Linux Kernel 5.2 正式版。本次主要版本更新在改进驱动程序和核心组件之外，还引入了一些有趣的特性和增强功能。不过需要注意的是 Linux Kernel 5.2 并非长期支持（LTS）分支，因此推荐注重稳定的用户还是使用当前的 LTS 内核。</p><p>链接：<a href="https://www.cnbeta.com/articles/soft/865277.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/soft/865277.htm</a></p><p><img src="https://static.cnbetacdn.com/thumb/article/2019/0708/1cb25fe820d7a25.jpg" alt=""></p><p>2、<a href="https://www.cnbeta.com/articles/tech/865885.htm" target="_blank" rel="noopener">知名 DNS 解析服务商 CloudXNS 将停止免费服务</a></p><p>国内知名 DNS 解析服务商「CloudXNS」发布了 “关于停止免费用户解析服务的公告”。该公告表示：“为贯彻国家网络安全政策法规，加强监管力度，更好地服务于 VIP 客户，CloudXNS 将停止免费用户使用 CloudXNS 的解析服务。”</p><p>链接：<a href="https://www.cnbeta.com/articles/tech/865885.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/tech/865885.htm</a></p><p>3、<a href="https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html" target="_blank" rel="noopener">Google 开源 robots.txt 解析器，推动 REP 标准化</a></p><p>Google 在其博客上发布了一个重要消息，它宣布 Google 开源了存储 robots.txt 解析器的 C++ 库，以便推动 REP（Robots Exclusion Protocol，也称爬虫协议、机器人协议）成为互联网标准。</p><p>链接：<a href="https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html" target="_blank" rel="noopener">https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html</a></p><p><img src="https://static.leiphone.com/uploads/new/images/20190702/5d1b31955ff60.png" alt=""></p><p>4、<a href="https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC" target="_blank" rel="noopener">阿里云 PHP Composer 全量镜像正式上线</a></p><p>阿里云正式上线 PHP Composer 全量镜像，所有 PHP 开发者都可以通过我们的开发者社区 <a href="http://developer.aliyun.com/composer" target="_blank" rel="noopener">developer.aliyun.com/composer</a> 加速 Composer 安装器。</p><p>这款镜像工具的最大优势是快，几乎实现与 PHP Packagist 官方实时同步，每隔 30 秒刷新全国 CDN 缓存。它基于阿里云的对象存储 OSS 和 CDN 研发同步系统，通过任务分发，实现同步的快速和稳定。</p><p>链接：<a href="https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC" target="_blank" rel="noopener">https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC</a></p><p>5、 <a href="https://www.oschina.net/news/108197/coredns-1-5-2-released" target="_blank" rel="noopener">CoreDNS v1.5.2 发布</a></p><p>CoreDNS 1.5.2 发布了，该版本包含一些小的 Bug 修复。在此版本中，一个重要的变更便是移除掉了 upstream 插件相关的所有文档和说明。在此次变更之后， upstream 配置行便可直接移除。</p><p>链接：<a href="https://www.oschina.net/news/108197/coredns-1-5-2-released" target="_blank" rel="noopener">https://www.oschina.net/news/108197/coredns-1-5-2-released</a></p><p><img src="https://www.hi-linux.com/img/linux/coredns.jpeg" alt=""></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://browserframe.com/" target="_blank" rel="noopener">BrowserFrame</a></p><p>「BrowserFrame」是一个很好用的在线工具，可以将截图或任何图片加上浏览器外框。</p><p>BrowserFrame 提供了两种方式来生成截图，分别是上传本地截图和输入网址生成截图。后者输入网址生产截图由于会受到网页加载速度的影响，生成速度可能会比较慢，容易出现「生成失败」的情况，建议选择直接上传本地截图的方法。</p><p>BrowserFrame 支持多种平台的多款浏览器样式，包括 Google Chrome、Firefox、Safari、Opera、IE 和 Edge 等。你不仅可以根据自己喜好选择不同的样式，还可以自定义一些细节设置，比如：窗口顏色、宽度、高度或间距等等。</p><p>项目地址: <a href="https://browserframe.com/" target="_blank" rel="noopener">https://browserframe.com/</a></p><p><img src="https://www.hi-linux.com/img/linux/BrowserFrame.jpeg" alt=""></p><p>2、<a href="https://github.com/thegreatjavascript/FakeScreenshot" target="_blank" rel="noopener">FakeScreenshot</a></p><p>这是一个可以伪造微博、知乎、豆瓣、简书等网站界面截图的项目，该项目能够非常简单的生成一个能够以假乱真的截图。</p><p>实际上想要做一张假截图是很简单的事情，不管是模仿还是干脆 PS 合成一个，导致很多时候这些截图会被拿去传播谣言。这个项目的意义在于告诉人们看到任何截图的时候都应该保持怀疑。</p><p>项目地址: <a href="https://github.com/thegreatjavascript/FakeScreenshot" target="_blank" rel="noopener">https://github.com/thegreatjavascript/FakeScreenshot</a></p><p><img src="https://openingsource.org/wp-content/uploads/2019/06/473-1.png" alt=""></p><p>3、<a href="https://mdnice.com/" target="_blank" rel="noopener">Markdown Nice</a></p><p>Markdown Nice 是一个开源的专门针对微信公众号文章排版而设计的 Markdown 在线编辑器。编写完成即排版完成，复制到公众号文章编辑器即可，非常好用。</p><p>Markdown Nice 还有很多特色功能，比如：支持自定义样式、浏览器中实时保存和预览内容样式、支持零配置图床、脚注、代码、公式等。</p><p>项目地址: <a href="https://mdnice.com/" target="_blank" rel="noopener">https://mdnice.com/</a></p><p><img src="https://www.hi-linux.com/img/linux/mdnice.jpeg" alt=""></p><p>4、<a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a></p><p><a href="http://SM.MS" target="_blank" rel="noopener">SM.MS</a> 是由 V2EX 的 Showfom 自建的一个免费图床，图床速度还不错，已经运行四年多了。该图床免注册且永久存储，且无外链、无流量限制，支持 HTTPS。</p><p>图床图片上传限制：每个图片最大 5M，每次最多上传 10 张。</p><p>项目地址：<a href="https://sm.ms" target="_blank" rel="noopener">https://sm.ms</a></p><p><img src="https://www.hi-linux.com/img/linux/smms.jpeg" alt=""></p><p>5、<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a></p><p>PicGo 是一款开源跨平台的免费图片上传工具以及图床相册管理软件，支持 Windows、macOS 和 Linux 系统。</p><p>PicGo 使用非常简单，它能帮你快速地将图片上传到微博、又拍云、阿里云 OSS、腾讯云 COS、七牛、GitHub、<a href="http://sm.ms" target="_blank" rel="noopener">sm.ms</a>、Imgur 等常见的免费图床网站或云存储服务上，并自动复制图片的链接到剪贴板里，使用上非常高效便捷。</p><p>项目地址：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></p><p><img src="https://i.loli.net/2019/05/08/5cd2dc258f927.png" alt=""></p><p>6、<a href="https://www.pexels.com" target="_blank" rel="noopener">Pexels</a></p><p>Pexels 堪称最值得推荐的免费图库之一，它的特色是将许多大大小小图库及素材来源整合在同一网站，加入搜索、分类及标签等功能，让使用者在找图片时更快更准确。</p><p>Pexels 提供各种尺寸的相片，甚至有 HD 高画质的原始图片，无须注册就能下载，更棒的是还能依照使用者需求，设定尺寸后自动在线上裁剪，节省下载后必须自行编辑所耗费的时间。</p><p>项目地址：<a href="https://www.pexels.com/" target="_blank" rel="noopener">https://www.pexels.com/</a></p><p><img src="https://www.hi-linux.com/img/linux/Pexels.jpeg" alt=""></p><p>7、<a href="https://github.com/sxfad/porter" target="_blank" rel="noopener">Porter</a></p><p>Porter 是一款数据同步中间件，主要用于解决同构/异构数据库之间的表级别数据同步问题。</p><p>Porter 是一个插件友好型的数据聚合、分发中间件，提供源端、目标端、数据过滤等插件自定义开发的能力，能够根据场景需要轻松定制同步任务。</p><p>项目地址：<a href="https://github.com/sxfad/porter" target="_blank" rel="noopener">https://github.com/sxfad/porter</a></p><p><img src="https://raw.githubusercontent.com/sxfad/porter/master/doc/img/Home.png" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="https://cloud.tencent.com/developer/article/1448440" target="_blank" rel="noopener">如何在 MySQL 8.0.16 在组复制中启用成员自动重新加入</a></p><p>随着 MySQL 8.0.16 的发布，MGR 添加了一些功能以增强其高可用性。其中一个功能是能够在某些情况下启用已离开组的成员自动重新加入，而无需用户干预。本文将介绍这一新特性所带来的变化。</p><p>链接：<a href="https://cloud.tencent.com/developer/article/1448440" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1448440</a></p><p>2、<a href="https://www.yichya.dev/dns-poisoning-and-countering/" target="_blank" rel="noopener">DNS 污染和攻击</a></p><p>DNS 污染极为简单易行且效果极佳，这篇文章将介绍一下常见的 DNS 投毒现象，以及几种避免 DNS 攻击的解决方案。</p><p>链接：<a href="https://www.yichya.dev/dns-poisoning-and-countering/" target="_blank" rel="noopener">https://www.yichya.dev/dns-poisoning-and-countering/</a></p><p>3、<a href="https://arkingc.github.io/2018/12/11/2018-12-11-docker-storage-persist" target="_blank" rel="noopener">Docker 容器数据持久化</a></p><p>本文介绍了三种常用的 Docker 数据持久化的使用方法和适用的场景。</p><p>链接：<a href="https://arkingc.github.io/2018/12/11/2018-12-11-docker-storage-persist/" target="_blank" rel="noopener">https://arkingc.github.io/2018/12/11/2018-12-11-docker-storage-persist/</a></p><p>4、<a href="https://sspai.com/post/55703" target="_blank" rel="noopener">如何在 macOS Mojave 中将 U 盘格式化成通用格式</a></p><p>本文将介绍如何在 macOS Mojave 中将 APFS 格式的 U 盘在系统自带的磁盘工具中格式化成通用格式的方法。</p><p>链接：<a href="https://sspai.com/post/55703" target="_blank" rel="noopener">https://sspai.com/post/55703</a></p><h2 id="每周观点">每周观点</h2><p>1、人生重要的不是所站的位置，而是所朝的方向。—— 李嘉诚</p><p>2、如果不继续成长，就会开始走向死亡。—— 华特·迪士尼</p><p>3、这个世界如此美好，值得为它奋战。—— 海明威</p><p>4、这世界不缺少发现，而是缺少发现后的思考。—— 牛根生</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnbeta.com/articles/soft/865277.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux Kernel 5.2 正式版发布，代号为 Bobtail Squid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经历了 7 个 RC 候选版本之后，Linus Torvalds 正式宣布了 Linux Kernel 5.2 正式版。本次主要版本更新在改进驱动程序和核心组件之外，还引入了一些有趣的特性和增强功能。不过需要注意的是 Linux Kernel 5.2 并非长期支持（LTS）分支，因此推荐注重稳定的用户还是使用当前的 LTS 内核。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/soft/865277.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/soft/865277.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.cnbetacdn.com/thumb/article/2019/0708/1cb25fe820d7a25.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnbeta.com/articles/tech/865885.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知名 DNS 解析服务商 CloudXNS 将停止免费服务&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;国内知名 DNS 解析服务商「CloudXNS」发布了 “关于停止免费用户解析服务的公告”。该公告表示：“为贯彻国家网络安全政策法规，加强监管力度，更好地服务于 VIP 客户，CloudXNS 将停止免费用户使用 CloudXNS 的解析服务。”&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/tech/865885.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/tech/865885.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google 开源 robots.txt 解析器，推动 REP 标准化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google 在其博客上发布了一个重要消息，它宣布 Google 开源了存储 robots.txt 解析器的 C++ 库，以便推动 REP（Robots Exclusion Protocol，也称爬虫协议、机器人协议）成为互联网标准。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/images/20190702/5d1b31955ff60.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里云 PHP Composer 全量镜像正式上线&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里云正式上线 PHP Composer 全量镜像，所有 PHP 开发者都可以通过我们的开发者社区 &lt;a href=&quot;http://developer.aliyun.com/composer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;developer.aliyun.com/composer&lt;/a&gt; 加速 Composer 安装器。&lt;/p&gt;
&lt;p&gt;这款镜像工具的最大优势是快，几乎实现与 PHP Packagist 官方实时同步，每隔 30 秒刷新全国 CDN 缓存。它基于阿里云的对象存储 OSS 和 CDN 研发同步系统，通过任务分发，实现同步的快速和稳定。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、 &lt;a href=&quot;https://www.oschina.net/news/108197/coredns-1-5-2-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CoreDNS v1.5.2 发布&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CoreDNS 1.5.2 发布了，该版本包含一些小的 Bug 修复。在此版本中，一个重要的变更便是移除掉了 upstream 插件相关的所有文档和说明。在此次变更之后， upstream 配置行便可直接移除。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108197/coredns-1-5-2-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108197/coredns-1-5-2-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/coredns.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 4 期 )</title>
    <link href="https://www.hi-linux.com/posts/43583.html"/>
    <id>https://www.hi-linux.com/posts/43583.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:21:30.148Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.williamlong.info/archives/5771.html" target="_blank" rel="noopener">谷歌确认回归中国的 Dragonfly 计划彻底终止</a></p><p>近日，谷歌副总裁巴提亚（Karan Bhatia）出席美国参议院司法委员会举行的听证会时确认谷歌已经终止了在中国推出审查搜索引擎的 “蜻蜓计划”，该计划原打算推出中国定制版、通过中国法律审查的搜索引擎。</p><p>链接：<a href="https://www.williamlong.info/archives/5771.html" target="_blank" rel="noopener">https://www.williamlong.info/archives/5771.html</a></p><p><img src="https://i.loli.net/2019/07/22/5d355ee15057b67703.jpg" alt=""></p><p>2、<a href="https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code" target="_blank" rel="noopener">微软计划将 Rust 作为 C 和 C++ 的安全替代品</a></p><p>微软正在探索使用 Rust 编程语言作为 C、C++ 和其他语言的替代方案，以此来改善应用程序的安全状况。</p><p>链接：<a href="https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code" target="_blank" rel="noopener">https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code</a></p><p><img src="https://oscimg.oschina.net/oscnet/a6c6690735238bf57e020b1beb346f77686.jpg" alt=""></p><p>3、<a href="https://www.oschina.net/news/108462/develop-with-python-on-windows" target="_blank" rel="noopener">微软官方上线 Python 配置教程</a></p><p>微软近日上线了一套 Python 配置教程 《Develop with Python on Windows》，文档内容包括设置 Python 开发环境、在 Windows 与 WSL 子系统中安装相应开发工具，以及集成 VS Code 与 Git 工具并进行开发等。</p><p>链接：<a href="https://www.oschina.net/news/108462/develop-with-python-on-windows" target="_blank" rel="noopener">https://www.oschina.net/news/108462/develop-with-python-on-windows</a></p><p><img src="https://i.loli.net/2019/07/23/5d36cacdacd2d91648.jpg" alt=""></p><p>4、<a href="https://www.oschina.net/news/108481/docker-ce-19-03-0-released" target="_blank" rel="noopener">Docker CE 19.03 正式发布，无需 root 权限</a></p><p>Docker CE 19.03 和 EE 3.0 都已经正式发布，19.03 主要内容包括无需 root 权限、支持 GPU 的增强功能和 CLI 插件更新等等。Docker CE 19.03 现在是允许非 root 用户运行守护程序，启用 Rootless 模式可以防止攻击者夺取主机的 root 权限，即使 Docker 存在漏洞或设置错误。</p><p>链接：<a href="https://www.oschina.net/news/108481/docker-ce-19-03-0-released" target="_blank" rel="noopener">https://www.oschina.net/news/108481/docker-ce-19-03-0-released</a></p><p>5、<a href="https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb" target="_blank" rel="noopener">华为将开源全球首个 AI 原生数据库 GaussDB 内核</a></p><p>日前，华为在正在进行的鲲鹏计算产业论坛上宣布将开源其内部大规模使用的 GaussDB 数据库内核。该内核具备超越现有开源 MySQL、PostgreSQL 的极致性能，在鲲鹏 920 服务器上 TPC-C 性能能够达到 150 万 TPMC。并具备业内最快的故障恢复时间，完全满足各种高端企业用户的 Oracle 替代需求。</p><p>链接：<a href="https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb" target="_blank" rel="noopener">https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb</a></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://github.com/guanpengchn/markdown-resume" target="_blank" rel="noopener">Markdown-Resume</a></p><p>Markdown-Resume 是一个支持 Markdown 和富文本的在线简历排版工具，如果你想快速的制作一个好用又好看的简历，不妨试试哟~</p><p>项目地址: <a href="https://github.com/guanpengchn/markdown-resume" target="_blank" rel="noopener">https://github.com/guanpengchn/markdown-resume</a></p><p><img src="https://www.hi-linux.com/img/linux/markdown-resume.jpeg" alt=""></p><p>2、<a href="https://github.com/joeblau/gitignore.io" target="_blank" rel="noopener">gitignore.io</a></p><p>项目地址: <a href="https://github.com/joeblau/gitignore.io" target="_blank" rel="noopener">https://github.com/joeblau/gitignore.io</a></p><p>这是由 Uber 一名工程师 joeblau 所开发的 .gitignore 文件快速生成工具，开发者只需要在网站上搜索当前正在使用的操作系统、IDE、编程语言，它便会自动生成一个特定的 .gitignore 配置文件。</p><p>如果你不想用网站进行搜索，还可以安装下它的命令行工具。安装完成后，就可以使用 gi 命令来快速生成 .gitignore 配置文件啦，超级方便！</p><p><img src="https://www.hi-linux.com/img/linux/gitignore.jpeg" alt=""></p><p>3、<a href="https://github.com/crossoverJie/blog.toolbox/" target="_blank" rel="noopener">blog.toolbox</a></p><p>这是一个图床搬家工具，可以很方便的帮你将图片批量的从失效的图床搬到新的图床中。</p><p>项目地址: <a href="https://github.com/crossoverJie/blog.toolbox/" target="_blank" rel="noopener">https://github.com/crossoverJie/blog.toolbox/</a></p><p><img src="https://www.hi-linux.com/img/linux/blog-toolbox.gif" alt=""></p><p>4、<a href="https://iplist.cc" target="_blank" rel="noopener">IPList</a></p><p>IPList 是一个在线 IP、Hostname 查询工具，支持 IPv4、IPv6。只要输入查询内容就会显示出相关信息，也可看到打开网站你目前的 IP 地址。</p><p>IPList 实际上一个免费的 IP 信息查询 API，可供开发者快速取得某个 IP 或 Hostname 的信息，只要把查询的对象拼接在 <a href="https://iplist.cc/api/" target="_blank" rel="noopener">https://iplist.cc/api/</a> 网址后面就会得到结果。</p><p>项目地址: <a href="https://iplist.cc/" target="_blank" rel="noopener">https://iplist.cc/</a></p><p><img src="https://www.hi-linux.com/img/linux/iplist.jpeg" alt=""></p><p>5、<a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">Learn-Regex</a></p><p>这个项目是一个关于正则表达式的教程，不仅收录了学习资料，还提供了一个在线的学习网站帮助巩固所学，在实操中多练习一下能够让你更快的达到不需要每次使用的时候都翻开教程的境界，熟能生巧，这种东西还是全记下来用的才方便。</p><p>项目地址: <a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">https://github.com/ziishaned/learn-regex</a></p><p><img src="https://www.hi-linux.com/img/linux/Learn-Regex.png" alt=""></p><p>6、<a href="https://github.com/chubin/cheat.sh" target="_blank" rel="noopener">cheat.sh</a></p><p>一个在线查询 Linux 命令快速使用方法的网站。比如要查询 tar 命令的用法， 只需要执行 curl <a href="http://cht.sh/tar" target="_blank" rel="noopener">cht.sh/tar</a> 就可以很快得到 tar 命令的常用方法，结果比 man 命令简洁实用得多。</p><p>项目地址: <a href="https://github.com/chubin/cheat.sh" target="_blank" rel="noopener">https://github.com/chubin/cheat.sh</a></p><p><img src="https://www.hi-linux.com/img/linux/cheat.jpeg" alt=""></p><p>7、<a href="https://virtual-kubelet.io/" target="_blank" rel="noopener">Virtual Kubelet</a></p><p>Virtual Kubelet 是一个开源的 Kubernetes Kubelet 实现。它伪装成 Kubelet，目的是将 Kubernetes 连接到其他 API，这允许节点得到其他服务(如 ACI、AWS Fargate、IoT Edge 等)的支持。Virtual Kubelet 的主要场景是将Kubernetes API 扩展到无服务器的容器平台（如 ACI 和 Fargate ）。</p><p>Virtual Kubelet 提供一个库，开发者可以在项目中使用这个库来构建自定义 Kubernetes 节点代理。</p><p>项目地址: <a href="https://virtual-kubelet.io/" target="_blank" rel="noopener">https://virtual-kubelet.io/</a></p><p><img src="https://www.hi-linux.com/img/linux/Virtual-Kubelet.png" alt=""></p><p>8、<a href="https://github.com/eryajf/magic-of-sysuse-scripts" target="_blank" rel="noopener">magic-of-sysuse-scripts</a></p><p>一个可快速初始化服务器环境和安装常用软件环境的运维小工具。(@李启龙 投稿)</p><p>项目地址: <a href="https://github.com/eryajf/magic-of-sysuse-scripts" target="_blank" rel="noopener">https://github.com/eryajf/magic-of-sysuse-scripts</a></p><p><img src="https://i.loli.net/2019/07/23/5d36c5cada13b68380.gif" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="https://github.com/aCoder2013/blog/issues/35" target="_blank" rel="noopener">API 网关从入门到放弃</a></p><p>本文将以电商平台为例讲解设计 API 网关的要点和 API 网关的优劣势。</p><p>链接：<a href="https://github.com/aCoder2013/blog/issues/35" target="_blank" rel="noopener">https://github.com/aCoder2013/blog/issues/35</a></p><p><img src="https://www.hi-linux.com/img/linux/api-gateway.jpeg" alt=""></p><p>2、<a href="https://github.com/caicloud/kube-ladder" target="_blank" rel="noopener">Kubernetes 学习路径</a></p><p>本文由才云科技（Caicloud）于 2019 年内部推出，现以开源的形式进行维护。文档旨在为广大从业者提供一个 Kubernetes 学习路径，为大家提供一定的指引。我们最终的目标是让所有人剥茧抽丝般地了解 Kubernetes，不仅仅知道怎么用 Kubernetes，还知道 Kubernetes 各个功能是如何设计的。</p><p>链接：<a href="https://github.com/caicloud/kube-ladder" target="_blank" rel="noopener">https://github.com/caicloud/kube-ladder</a></p><p>3、<a href="https://github.com/blueboay/ceph-study" target="_blank" rel="noopener">Ceph-Study</a></p><p>Ceph 是一个可靠、自动均衡、自动恢复的分布式存储系统，通常可用于对象存储，块设备存储和文件系统存储。Ceph-Study 是网友整理的一份 Ceph 学习指南，写的十分详细，欢迎初学者浏览学习。</p><p>链接：<a href="https://github.com/blueboay/ceph-study" target="_blank" rel="noopener">https://github.com/blueboay/ceph-study</a></p><p><img src="https://i.loli.net/2019/07/22/5d356ee51461d56865.png" alt=""></p><p>4、<a href="https://github.com/jwasham/coding-interview-university" target="_blank" rel="noopener">Coding Interview University</a></p><p>这份指南里面包含 Google 相关的介绍视频、面试过程、教学资源，同时也有数据结构、算法、密码学等计算机专业的知识讲解。</p><p>链接：<a href="https://github.com/jwasham/coding-interview-university" target="_blank" rel="noopener">https://github.com/jwasham/coding-interview-university</a></p><p>为了便于国内开发者查看，掘金翻译团队已将该指南译为中文。</p><p>链接：<a href="https://github.com/jwasham/coding-interview-university/blob/master/translations/README-cn.md" target="_blank" rel="noopener">https://github.com/jwasham/coding-interview-university/blob/master/translations/README-cn.md</a></p><p><img src="https://i.loli.net/2019/07/23/5d366e052e79a91004.jpg" alt=""></p><p>5、<a href="https://github.com/selfteaching/the-craft-of-selfteaching" target="_blank" rel="noopener">自学是门手艺</a></p><blockquote><p>没有自学能力的人没有未来。</p></blockquote><p>「自学是门手艺」是李笑来开源的一本电子书，介绍了掌握自学能力的重要性，并以学习 Python 编程为例子讲解如何进行有效的自学的方法。</p><p>链接：<a href="https://github.com/selfteaching/the-craft-of-selfteaching" target="_blank" rel="noopener">https://github.com/selfteaching/the-craft-of-selfteaching</a></p><p>在线版链接：<a href="http://the-craft-of-selfteaching.surge.sh" target="_blank" rel="noopener">http://the-craft-of-selfteaching.surge.sh</a></p><h2 id="每周观点">每周观点</h2><p>1、美妙人生的关键在于你能迷上什么东西。——「球状闪电」</p><p>2、工作上的执着，实际上是人的一种意志。—— 张近东</p><p>3、生活是属于每个人自己的感受，不属于任何别人的看法。——「活着」</p><p>4、人生的某些障碍，你是逃不掉的。与其费尽周折绕过去，不如勇敢的地攀越，或许这会铸就你人生的高点。—— 宫崎骏「龙猫」</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.williamlong.info/archives/5771.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谷歌确认回归中国的 Dragonfly 计划彻底终止&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，谷歌副总裁巴提亚（Karan Bhatia）出席美国参议院司法委员会举行的听证会时确认谷歌已经终止了在中国推出审查搜索引擎的 “蜻蜓计划”，该计划原打算推出中国定制版、通过中国法律审查的搜索引擎。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.williamlong.info/archives/5771.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.williamlong.info/archives/5771.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/22/5d355ee15057b67703.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软计划将 Rust 作为 C 和 C++ 的安全替代品&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软正在探索使用 Rust 编程语言作为 C、C++ 和其他语言的替代方案，以此来改善应用程序的安全状况。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/a6c6690735238bf57e020b1beb346f77686.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/108462/develop-with-python-on-windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软官方上线 Python 配置教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软近日上线了一套 Python 配置教程 《Develop with Python on Windows》，文档内容包括设置 Python 开发环境、在 Windows 与 WSL 子系统中安装相应开发工具，以及集成 VS Code 与 Git 工具并进行开发等。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108462/develop-with-python-on-windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108462/develop-with-python-on-windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/23/5d36cacdacd2d91648.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.oschina.net/news/108481/docker-ce-19-03-0-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker CE 19.03 正式发布，无需 root 权限&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker CE 19.03 和 EE 3.0 都已经正式发布，19.03 主要内容包括无需 root 权限、支持 GPU 的增强功能和 CLI 插件更新等等。Docker CE 19.03 现在是允许非 root 用户运行守护程序，启用 Rootless 模式可以防止攻击者夺取主机的 root 权限，即使 Docker 存在漏洞或设置错误。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108481/docker-ce-19-03-0-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108481/docker-ce-19-03-0-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;华为将开源全球首个 AI 原生数据库 GaussDB 内核&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;日前，华为在正在进行的鲲鹏计算产业论坛上宣布将开源其内部大规模使用的 GaussDB 数据库内核。该内核具备超越现有开源 MySQL、PostgreSQL 的极致性能，在鲲鹏 920 服务器上 TPC-C 性能能够达到 150 万 TPMC。并具备业内最快的故障恢复时间，完全满足各种高端企业用户的 Oracle 替代需求。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Android Pie 私人 DNS 使用教程</title>
    <link href="https://www.hi-linux.com/posts/32399.html"/>
    <id>https://www.hi-linux.com/posts/32399.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.394Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最近手机更新到了最新的 Android Pie (9.0) 系统，随着系统的更新，就可以体验到 Android Pie 带来了一系列的新特性。比如：全新设计的导航栏以及多任务界面、数字应用、安全和隐私等新功能。其中有一项更新是非常实用的，该功能可以提升用户上网过程中的安全性，它就是：DNS over TLS，在 Android 里叫做 Private DNS（私人 DNS）。</p><p><img src="https://cdn.laod.wang/wp-content/uploads/2018/11/tls.png" alt=""></p><p>默认情况下，如果网络的 DNS 服务器支持，设备会自动使用 DNS over TLS，但如果用户不希望使用 DNS over TLS，可选择将其关闭。</p><p>Android Pie 的 新功能简化了在 Android 配置自定义安全的 DNS 解析程序。当网站提供 DNS 服务时，客户端和网站服务器就会自动进行加密，第三方无法窥视 DNS 查询。因为 Android 9 内置对 DNS over TLS 的支持。同时该 TLS 还负责自动默认 HTTPS 访问网站，在地址栏可看到绿色安全锁图标。这可确保不会被 ISP、移动运营商以及客户端与 DNS 解析程序之间的第三方篡改内容或无法解析。</p><p>在讲这个功能之前先来了解一下什么是 DNS 和 DNS 污染。</p><a id="more"></a><h3 id="原理">原理</h3><p>既然说起 DNS 和其污染问题，就不得不先看看 DNS 系统是如何工作的。</p><p>互联网所有通信都是建立在 TCP/IP 的基础上，如果想访问目标网络，就必须知道目标 IP。不过 IP 的数量有限，还有 IP 是由一串数字或十六进制组成的，不是那么好记，所以有了域名。域名本身不具有访问性，它如果想被访问，必须绑定一个或多个 IP，一个 IP 可以绑定一个或多个域名。这时候就有一个问题，如何知道域名指向的是哪个 IP。所以需要一项服务，它记载着所有域名和IP的关系，需要的时候询问它就可以了，这就是 DNS（域名系统）。</p><p>以访问 Wikipedia 网站为例。</p><p><img src="https://kyle.ai/blog/wp-content/uploads/2017/09/563px-An_example_of_theoretical_DNS_recursion.svg_.png" alt=""></p><p>DNS 解析流程图</p><p>图中可以看到我们的 ISP 的 DNS 服务器在图中叫做 DNS Recurser，在解析一个域名的时候，总共经过了以下的步骤：</p><ol><li>向 root 服务器获取该 gTLD 的管辖服务器，图中为 org 结尾的域名。</li><li>root 服务器返回 org 的管辖服务器。</li><li>向 org 的管辖服务器查询，谁来负责解析 <a href="http://wikipedia.org" target="_blank" rel="noopener">wikipedia.org</a> 这个域名的。</li><li>org 的管辖服务器返回解析 <a href="http://wikipedia.org" target="_blank" rel="noopener">wikipedia.org</a> 的服务器 IP 地址。</li><li>向 <a href="http://wikipedia.org" target="_blank" rel="noopener">wikipedia.org</a> 的解析服务器发出查询，解析 <a href="http://www.wikipedia.org" target="_blank" rel="noopener">www.wikipedia.org</a> 的 IP 地址。</li><li>拿到最终要的 IP 地址。</li></ol><p>从上面的 DNS 解析流程可以看出，解析一个域名一共要经历 6 个步骤。</p><p>由于 DNS 的数据是以明文传输，所以 DNS 服务器返回的数据在传输的过程中是有可能被篡改的，导致域名指向错误的 IP，引导用户访问错误或恶意的网站。比如：在最后一次查询的时候，有人假冒了 <a href="http://wikipedia.org" target="_blank" rel="noopener">wikipedia.org</a> 的解析服务器，则可以在中间进行欺骗攻击，致使用户最后得到的 IP 地址不是真实的地址。如图所示，</p><p><img src="https://kyle.ai/blog/wp-content/uploads/2017/09/563px-An_example_of_theoretical_DNS_recursion.svg_1.png" alt=""></p><p>解析请求被劫持</p><h3 id="为什么要使用私有-dns">为什么要使用私有 DNS？</h3><p>从上面的例子我们可以看出，DNS 是存在被劫持和污染的风险的。为了保护用户的上网安全，一些 DNS 加密查询技术因此应运而生。常见的有：DNS over HTTPS、DNSCrypt 和 DNS over TLS。这三种的技术原理大致一样，都是通过一些手段加密用户与 DNS 服务器之间的通信，避免 DNS 污染。</p><blockquote><p>TLS (Transport Layer Security，传输层安全协议)，TLS 是 IETF（Internet Engineering Task Force，Internet 工程任务组）制定的一种新的协议。TLS 是在其前身 SSL （Secure Sockets Layer，安全套接层）的基础上发展来的。SSL 也是一种安全协议，其目的是为互联网通信提供安全及数据完整性保障。TLS 它建立在 SSL 3.0 协议规范之上，是 SSL 3.0 的后续版本，可以理解为 SSL 3.1。TLS 协议由两层组成：TLS 记录层（TLS Record）和 TLS 传输层（TLS Handshake）。较低的层为 TLS 记录层协议，位于某个可靠的传输协议（例如：TCP）上面。记录层协议确定传输层数据的封装格式。传输层安全协议使用 X.509 认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p></blockquote><p>目前支持 DNS over TLS 的平台不多， Android Pie 就是其中这一。如果你的系统暂时不支持 DNS over TLS，你可以暂时使用 SmartDNS 这个程序来作为本地 DNS 服务器，它支持将 DNS over TLS 作为 DNS 上游服务器。</p><p>SmartDNS 项目地址：<a href="https://github.com/pymumu/smartdns" target="_blank" rel="noopener">https://github.com/pymumu/smartdns</a></p><h3 id="在-android-pie-上启用-dns-over-tls">在 Android Pie 上启用  DNS over TLS</h3><p>在 Android Pie 上启用  DNS over TLS 的方法非常简单。下面以一加 5 为例，大概需要如下步骤：</p><ol><li>打开 [设置] → [WLAN 和互联网] → [私人 DNS] → [私人 DNS 提供商主机名] → 输入 DNS over TLS 提供商提供的主机名 → 保存。</li></ol><p>保存以后，如果私人 DNS 下方显示主机名代表配置成功。</p><blockquote><ol><li><p>私有 DNS 字段并不接受类似 1.1.1.1 这样简单的 IP 地址，而是需要一个主机名。如：dns.google。Google 之所以要求私有 DNS 字段是主机名而非 IP 地址，这是因为考虑到移动运营商需要兼顾 IPv4 和 IPv6 共存的问题。</p></li><li><p>如果你使用原生 Android Pie 可使用 [设置] → [网络和互联网] → [高级] → [私人 DNS] 。</p></li></ol></blockquote><p>验证是否生效</p><ul><li><p>如果你使用的是 Cloudflare 提供的私人 DNS，可以访问 <a href="https://1.1.1.1/help" target="_blank" rel="noopener">https://1.1.1.1/help</a> 进行验证。如果 “使用 DNS over TLS（DoT）” 显示为 “是” 就表示配置成功了。</p></li><li><p>你也可以访问 <a href="https://whoer.net/zh" target="_blank" rel="noopener">https://whoer.net/zh</a> 这个网站来测试 DNS 匿名性。</p></li></ul><p>一些可用的 DNS over TLS 提供商</p><blockquote><p>Google: dns.google</p><p>Cloudflare: <a href="http://1dot1dot1dot1.cloudflare-dns.com" target="_blank" rel="noopener">1dot1dot1dot1.cloudflare-dns.com</a></p><p>Quad9: <a href="http://dns.quad9.net" target="_blank" rel="noopener">dns.quad9.net</a></p><p>CleanBrowsing: <a href="http://security-filter-dns.cleanbrowsing.org" target="_blank" rel="noopener">security-filter-dns.cleanbrowsing.org</a></p><p>红鱼 DNS: <a href="http://dns.rubyfish.cn" target="_blank" rel="noopener">dns.rubyfish.cn</a></p></blockquote><p>祝大家早日吃上 Andorid Pie。最后我们来搞个小投票，看看大家所使用的手机品牌和系统。</p><h3 id="参考文档">参考文档</h3><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="http://t.cn/EicGa97" target="_blank" rel="noopener">http://t.cn/EicGa97</a></li><li><a href="http://t.cn/EiVVF4K" target="_blank" rel="noopener">http://t.cn/EiVVF4K</a></li><li><a href="http://t.cn/EiVfk7i" target="_blank" rel="noopener">http://t.cn/EiVfk7i</a></li><li><a href="http://t.cn/EiVc5Uf" target="_blank" rel="noopener">http://t.cn/EiVc5Uf</a></li><li><a href="http://t.cn/E2m0Ytz" target="_blank" rel="noopener">http://t.cn/E2m0Ytz</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近手机更新到了最新的 Android Pie (9.0) 系统，随着系统的更新，就可以体验到 Android Pie 带来了一系列的新特性。比如：全新设计的导航栏以及多任务界面、数字应用、安全和隐私等新功能。其中有一项更新是非常实用的，该功能可以提升用户上网过程中的安全性，它就是：DNS over TLS，在 Android 里叫做 Private DNS（私人 DNS）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.laod.wang/wp-content/uploads/2018/11/tls.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，如果网络的 DNS 服务器支持，设备会自动使用 DNS over TLS，但如果用户不希望使用 DNS over TLS，可选择将其关闭。&lt;/p&gt;
&lt;p&gt;Android Pie 的 新功能简化了在 Android 配置自定义安全的 DNS 解析程序。当网站提供 DNS 服务时，客户端和网站服务器就会自动进行加密，第三方无法窥视 DNS 查询。因为 Android 9 内置对 DNS over TLS 的支持。同时该 TLS 还负责自动默认 HTTPS 访问网站，在地址栏可看到绿色安全锁图标。这可确保不会被 ISP、移动运营商以及客户端与 DNS 解析程序之间的第三方篡改内容或无法解析。&lt;/p&gt;
&lt;p&gt;在讲这个功能之前先来了解一下什么是 DNS 和 DNS 污染。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Android" scheme="https://www.hi-linux.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Linux 并行处理神器 GNU Parallel 简明教程</title>
    <link href="https://www.hi-linux.com/posts/32794.html"/>
    <id>https://www.hi-linux.com/posts/32794.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.396Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Bash</code> 命令通常单线程运行，这意味着所有的处理工作只在单个 CPU 上执行。随着 CPU 规模的扩大以及核心数目的增加，这意味着只有一小部分的 CPU 资源用于处理任务，这样就造成了很大的资源浪费。 这种情况在进行多媒体转换（比如：图片和视频转换）以及数据压缩中经常遇到。</p><p>本文我们将介绍如何使用 GNU Parallel 程序在所有 CPU 核上并行地执行计算任务。</p><h3 id="parallel-介绍">Parallel 介绍</h3><blockquote><p>GNU Parallel 是一种通用的并行化程序，可以在同一台机器上或在您具有 SSH 访问权限的多台机器上轻松并行运行作业。</p></blockquote><p>如果要在 4 个 CPU 上运行 32 个不同的作业，并行化的一种直接方法是在每个 CPU 上运行8个作业。</p><p><a href="https://upload-images.jianshu.io/upload_images/27460-5b784effa2396844.png" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/27460-5b784effa2396844.png</a></p><p>GNU Parallel 会在完成后生成一个新进程，并保持 CPU 处于活动状态，从而节省时间。</p><p><a href="https://upload-images.jianshu.io/upload_images/27460-2901afa31279f8ff.png" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/27460-2901afa31279f8ff.png</a></p><h3 id="parallel-安装">Parallel 安装</h3><ol><li>通过包安装</li></ol><ul><li>CentOS / RHEL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install parallel</span><br></pre></td></tr></table></figure><ul><li>Ubuntu / Debian</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install parallel</span><br></pre></td></tr></table></figure><ol start="2"><li>通过脚本安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ (wget -O - pi.dk&#x2F;3 || curl pi.dk&#x2F;3&#x2F;) | bash</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="parallel-使用">Parallel 使用</h3><h4 id="parallel-语法简介">Parallel 语法简介</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">parallel [options] [command [arguments]] &lt; list_of_arguments</span><br><span class="line">parallel [options] [command [arguments]] (::: arguments|:::: argfile(s))...</span><br><span class="line">cat ... | parallel --pipe [options] [command [arguments]]</span><br></pre></td></tr></table></figure><ul><li>Parallel 常用选项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">::: 后面接参数。</span><br><span class="line">:::: 后面接文件。</span><br><span class="line">-j、--jobs   并行任务数，不想并行执行可以设为 1。若不加 -j，则预设为每个 CPU 执行一个 job。</span><br><span class="line">-N  每次输入的参数数量。</span><br><span class="line">-L N: 一次最多读取 N 行。</span><br><span class="line">--xargs 会在一行中输入尽可能多的参数。</span><br><span class="line">-xapply 从每一个源获取一个参数（或文件一行）。</span><br><span class="line">--header  把每一行输入中的第一个值做为参数名。</span><br><span class="line">-m   表示每个 job 不重复输出“背景”（context）。</span><br><span class="line">-X   与 -m 相反，会重复输出“背景文本”。</span><br><span class="line">-q  保护后面的命令。</span><br><span class="line">--trim lr 去除参数两头的空格，只能去除空格，换行符和 tab 都不能去除。</span><br><span class="line">--keep-order&#x2F;-k   强制使输出与参数保持顺序 --keep-order&#x2F;-k。</span><br><span class="line">--tmpdir&#x2F; --results   都是保存文件，但是后者可以有结构的保存。</span><br><span class="line">--delay  延迟每个任务启动时间。</span><br><span class="line">--halt  终止任务。</span><br><span class="line">--pipe    该参数使得我们可以将输入（stdin）分为多块（block），再将 stdin 的资料分给各个 jobs。</span><br><span class="line">--block  参数可以指定每块的大小。</span><br></pre></td></tr></table></figure><h4 id="parallel-用法简介">Parallel 用法简介</h4><ol><li>输入源</li></ol><p>GNU Parallel 的输入源支持文件、命令行和标准输入（ Stdin 或 Pipe）。</p><ul><li>以命令行做为输入源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo ::: a b c d e | tee a.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><ul><li>以 Stdin（标准输入）作为输入源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat a.txt | parallel echo</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><ul><li>GNU Parallel 支持通过命令行指定多个输入源，它会生成所有的组合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo ::: A B C ::: D E F | tee b.txt</span><br><span class="line">A D</span><br><span class="line">A E</span><br><span class="line">A F</span><br><span class="line">B D</span><br><span class="line">B E</span><br><span class="line">B F</span><br><span class="line">C D</span><br><span class="line">C E</span><br><span class="line">C F</span><br></pre></td></tr></table></figure><ul><li>多个文件作为输入，此时多个文件中的内容也会像上面那样进行组合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -a a.txt -a b.txt echo</span><br></pre></td></tr></table></figure><ul><li>Stdin（标准输入）作为文件源中的一个，使用 -， 输出结果同上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat a.txt |parallel -a - -a b.txt echo</span><br></pre></td></tr></table></figure><ul><li>使用 <code>::::</code> 代替 <code>-a</code>，后面可接多个文件名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat a.txt | parallel echo :::: - b.txt</span><br></pre></td></tr></table></figure><ul><li><code>:::</code> 和 <code>::::</code> 可以同时使用，同样的输出结果也会进行组合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo ::: a b :::: b.txt</span><br></pre></td></tr></table></figure><ul><li>当然，若不想像上面那样进行组合，可使用 --xapply 参数从每一个源获取一个参数（或文件一行），这个参数有些类似 R 中的函数，具有广播作用。如果其中一个输入源的长度比较短，它的值会被重复。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --xapply echo ::: A B C ::: D E F</span><br><span class="line">A D</span><br><span class="line">B E</span><br><span class="line">C F</span><br><span class="line"></span><br><span class="line">$ parallel --xapply echo ::: A B C ::: D E F G H I</span><br><span class="line">A D</span><br><span class="line">B E</span><br><span class="line">C F</span><br><span class="line">A G</span><br><span class="line">B H</span><br><span class="line">C I</span><br></pre></td></tr></table></figure><ol start="2"><li>改变参数分隔符</li></ol><p>GNU Parallel 可以通过 <code>--arg-sep</code> 和 <code>--arg-file-sep</code> 指定分隔符替代 <code>:::</code> 或 <code>::::</code>，当这两个符号被其它命令占用的时候会特别有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -k --arg-sep ,,, echo ,,, a b ,,, c d | tee c.txt </span><br><span class="line">a c</span><br><span class="line">a d</span><br><span class="line">b c</span><br><span class="line">b d</span><br><span class="line"></span><br><span class="line">$ parallel --xapply --arg-file-sep ,,,, echo ,,,, a.txt  b.txt </span><br><span class="line"></span><br><span class="line">a A D</span><br><span class="line">b A E</span><br><span class="line">c A F</span><br><span class="line">d B D</span><br><span class="line">e B E</span><br><span class="line">a B F</span><br><span class="line">b C D</span><br><span class="line">c C E</span><br><span class="line">d C F</span><br></pre></td></tr></table></figure><ol start="3"><li>改变输入分隔符</li></ol><p>GNU Parallel 默认把一行做为一个参数。使用 <code>\n</code> 做为参数定界符，可以使用 <code>-d</code> 改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -d b echo :::: a.txt </span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><ol start="4"><li>提前结束和跳过空行</li></ol><p>GNU Parallel 支持通过 <code>-E</code> 参数指定一个值做为结束标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -E stop echo ::: A B stop C D</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>GNU Parallel 使用 <code>--no-run-if-empty</code> 来跳过空行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ (echo 1; echo; echo 2) | parallel --no-run-if-empty echo</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><ol start="5"><li>构建命令行</li></ol><p>如果 Parallel 之后没有给定命令，那么这些参数会被当做命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ parallel ::: ls &#39;echo foo&#39; pwd</span><br><span class="line">a.txt</span><br><span class="line">b.txt</span><br><span class="line">c.txt</span><br><span class="line">jianchen</span><br><span class="line">mypipe</span><br><span class="line">scripts</span><br><span class="line">snake_test</span><br><span class="line">WGS_snake</span><br><span class="line">foo</span><br><span class="line">&#x2F;home&#x2F;sxuan</span><br></pre></td></tr></table></figure><p>此外，命令还可以是一个脚本文件，一个二进制可执行文件或一个 <code>Bash</code> 的函数（须用 export -f 导出函数）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;echo \$*&quot; &gt; s.sh</span><br><span class="line">$ parallel .&#x2F;s.sh ::: &quot;a b c f&quot; &quot;1 2 3 4&quot;</span><br><span class="line">a b c f</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><ol start="6"><li>替换字符串</li></ol><p>GNU Parallel 支持多种替换字符串，默认使用 {}，使用 <code>-I</code> 改变替换字符串符号 {}。</p><p>其最常见的字符串替换包括以下几种：</p><ul><li>{.}，去掉扩展名</li><li>{/},去掉路径，只保留文件名</li><li>{//}，只保留路径</li><li>{/.}，同时去掉路径和扩展名</li><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo ::: A&#x2F;B.C ; parallel echo &#123;&#125; ::: A&#x2F;B.C ; parallel -I ,, echo ,, ::: A&#x2F;B.C</span><br><span class="line">A&#x2F;B.C</span><br><span class="line">A&#x2F;B.C</span><br><span class="line">A&#x2F;B.C</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;.&#125; ::: A&#x2F;B.C ; parallel --extensionreplace ,, echo ,, ::: A&#x2F;B.C</span><br><span class="line">A&#x2F;B</span><br><span class="line">A&#x2F;B</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;&#x2F;&#125; ::: A&#x2F;B.C ; parallel --basenamereplace ,, echo ,, ::: A&#x2F;B.C</span><br><span class="line">B.C</span><br><span class="line">B.C</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;&#x2F;&#x2F;&#125; ::: A&#x2F;B.C ; parallel --dirnamereplace ,, echo ,, ::: A&#x2F;B.C </span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;&#x2F;.&#125; ::: A&#x2F;B.C ; parallel --basenameextensionreplace ,, echo ,, ::: A&#x2F;B.C</span><br><span class="line">B</span><br><span class="line">B</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;#&#125; ::: A B C ; parallel --seqreplace ,, echo ,, ::: A B C</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>同时，如果有多个输入源时，可以通过 {编号} 指定某一个输入源的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --xapply  echo &#123;1&#125; and &#123;2&#125; ::: A B ::: C D</span><br><span class="line">A and C</span><br><span class="line">B and D</span><br></pre></td></tr></table></figure><p>可以使用 / // /. 和 . 改变指定替换字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo &#x2F;&#x3D;&#123;1&#x2F;&#125; &#x2F;&#x2F;&#x3D;&#123;1&#x2F;&#x2F;&#125; &#x2F;.&#x3D;&#123;1&#x2F;.&#125; .&#x3D;&#123;1.&#125; ::: A&#x2F;B.C D&#x2F;E.F</span><br><span class="line">&#x2F;&#x3D;B.C &#x2F;&#x2F;&#x3D;A &#x2F;.&#x3D;B .&#x3D;A&#x2F;B</span><br><span class="line">&#x2F;&#x3D;E.F &#x2F;&#x2F;&#x3D;D &#x2F;.&#x3D;E .&#x3D;D&#x2F;E</span><br></pre></td></tr></table></figure><p>位置可以是负数，表示倒着数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo 1&#x3D;&#123;1&#125; 2&#x3D;&#123;2&#125; 3&#x3D;&#123;3&#125; -1&#x3D;&#123;-1&#125; -2&#x3D;&#123;-2&#125; -3&#x3D;&#123;-3&#125; ::: A B ::: C D ::: E F</span><br><span class="line">1&#x3D;A 2&#x3D;C 3&#x3D;E -1&#x3D;E -2&#x3D;C -3&#x3D;A</span><br><span class="line">1&#x3D;A 2&#x3D;C 3&#x3D;F -1&#x3D;F -2&#x3D;C -3&#x3D;A</span><br><span class="line">1&#x3D;A 2&#x3D;D 3&#x3D;E -1&#x3D;E -2&#x3D;D -3&#x3D;A</span><br><span class="line">1&#x3D;A 2&#x3D;D 3&#x3D;F -1&#x3D;F -2&#x3D;D -3&#x3D;A</span><br><span class="line">1&#x3D;B 2&#x3D;C 3&#x3D;E -1&#x3D;E -2&#x3D;C -3&#x3D;B</span><br><span class="line">1&#x3D;B 2&#x3D;C 3&#x3D;F -1&#x3D;F -2&#x3D;C -3&#x3D;B</span><br><span class="line">1&#x3D;B 2&#x3D;D 3&#x3D;E -1&#x3D;E -2&#x3D;D -3&#x3D;B</span><br><span class="line">1&#x3D;B 2&#x3D;D 3&#x3D;F -1&#x3D;F -2&#x3D;D -3&#x3D;B</span><br></pre></td></tr></table></figure><ol start="7"><li>按列输入和指定参数名</li></ol><p>使用 <code>--header</code> 把每一行输入中的第一个值做为参数名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --xapply --header : echo f1&#x3D;&#123;f1&#125; f2&#x3D;&#123;f2&#125; ::: f1 A B ::: f2 C D | tee d.txt</span><br><span class="line">f1&#x3D;A f2&#x3D;C</span><br><span class="line">f1&#x3D;B f2&#x3D;D</span><br></pre></td></tr></table></figure><p>使用 <code>--colsep</code> 把文件中的行切分为列，做为输入参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ perl -e &#39;printf &quot;f1\tf2\nA\tB\nC\tD\n&quot;&#39; &gt; tsv-file.tsv</span><br><span class="line">$ parallel --header : --colsep &#39;\t&#39; echo f1&#x3D;&#123;f1&#125; f2&#x3D;&#123;f2&#125; :::: tsv-file.tsv </span><br><span class="line">f1&#x3D;A f2&#x3D;B</span><br><span class="line">f1&#x3D;C f2&#x3D;D</span><br></pre></td></tr></table></figure><ol start="8"><li>多参数</li></ol><p><code>--xargs</code> 会在一行中输入尽可能多的参数（与参数字符串长度有关），通过 <code>-s</code> 可指定一行中参数的上限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ perl -e &#39;for(1..30000)&#123;print &quot;$_\n&quot;&#125;&#39; &gt; num30000</span><br><span class="line">$ cat num30000 | parallel --xargs echo | wc -l</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">$ cat num30000 | parallel --xargs -s 10000 echo | wc -l</span><br><span class="line">17</span><br></pre></td></tr></table></figure><p>为了获得更好的并发性，GNU Parallel 会在文件读取结束后再分发参数。</p><p>GNU Parallel 在读取完最后一个参数之后，才开始第二个任务，此时会把所有的参数平均分配到 4 个任务（如果指定了4个任务）。</p><p>第一个任务与上面使用 <code>--xargs</code> 的例子一样，但是第二个任务会被平均的分成 4 个任务，最终一共 5 个任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat num30000 | parallel --jobs 4 -m echo | wc -l</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>将 1-10 分参数分配到4个任务可以看得更清晰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --jobs 4 -m echo ::: &#123;1..10&#125;</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>替换字符串可以是输出字符的一部分，使用 <code>-m</code> 参数表示每个 job 不重复输出 “背景”（context），<code>-X</code> 则与 <code>-m</code> 相反，会重复输出 “背景文本”，具体通过下面几个例子进行理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --jobs 4 echo pre-&#123;&#125;-post ::: A B C D E F G</span><br><span class="line">pre-A-post</span><br><span class="line">pre-B-post</span><br><span class="line">pre-C-post</span><br><span class="line">pre-D-post</span><br><span class="line">pre-E-post</span><br><span class="line">pre-F-post</span><br><span class="line">pre-G-post</span><br><span class="line"></span><br><span class="line">$ parallel --jobs 4 -m echo pre-&#123;&#125;-post ::: A B C D E F G</span><br><span class="line">pre-A B-post</span><br><span class="line">pre-C D-post</span><br><span class="line">pre-E F-post</span><br><span class="line">pre-G-post</span><br><span class="line"></span><br><span class="line">$ parallel --jobs 4 -X echo pre-&#123;&#125;-post ::: A B C D E F G</span><br><span class="line">pre-A-post pre-B-post</span><br><span class="line">pre-C-post pre-D-post</span><br><span class="line">pre-E-post pre-F-post</span><br><span class="line">pre-G-post</span><br></pre></td></tr></table></figure><p>使用 <code>-N</code> 限制每行参数的个数，其中 <code>-N0</code> 表示一次只读取一个参数，且不输入这个参数（作为计数器来使用）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -N4 echo 1&#x3D;&#123;1&#125; 2&#x3D;&#123;2&#125; 3&#x3D;&#123;3&#125; ::: A B C D E F G H</span><br><span class="line">1&#x3D;A 2&#x3D;B 3&#x3D;C</span><br><span class="line">1&#x3D;E 2&#x3D;F 3&#x3D;G</span><br><span class="line">$ parallel -N0 echo foo ::: 1 2 3</span><br><span class="line">foo</span><br><span class="line">foo</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><ol start="9"><li>引用</li></ol><p>如果命令行中包含特殊字符，就需要使用引号保护起来。</p><p>Perl 脚本 <code>'print &quot;@ARGV\n&quot;'</code> 与 Linux 的 <code>echo</code> 的功能一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ perl -e &#39;print &quot;@ARGV\n&quot;&#39; A</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>使用 GNU Parallel 运行这条命令的时候，Perl 命令需要用引号包起来，也可以使用 <code>-q</code> 保护 <code>Perl</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ parallel perl -e &#39;print &quot;@ARGV\n&quot;&#39; ::: This wont work</span><br><span class="line">$ parallel -q perl -e &#39;print &quot;@ARGV\n&quot;&#39; ::: This works</span><br><span class="line">This</span><br><span class="line">works</span><br><span class="line">$ parallel perl -e \&#39;&#39;print &quot;@ARGV\n&quot;&#39;\&#39; ::: This works, too</span><br><span class="line">This</span><br><span class="line">works,</span><br><span class="line">too</span><br></pre></td></tr></table></figure><ol start="10"><li>去除空格</li></ol><p>使用 --trim 去除参数两头的空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --trim r echo pre-&#123;&#125;-post ::: &#39; A &#39;</span><br><span class="line">pre- A-post</span><br><span class="line"></span><br><span class="line">$ parallel --trim l echo pre-&#123;&#125;-post ::: &#39; A &#39;</span><br><span class="line">pre-A -post</span><br><span class="line"></span><br><span class="line">$ parallel --trim lr echo pre-&#123;&#125;-post ::: &#39; A &#39;</span><br><span class="line">pre-A-post</span><br></pre></td></tr></table></figure><ol start="11"><li>控制输出</li></ol><p>使用 <code>--tag</code> 以参数做为输出前缀，使用 <code>--tagstring</code> 修改输出前缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --tag echo foo-&#123;&#125; ::: A B C</span><br><span class="line">A   foo-A</span><br><span class="line">B   foo-B</span><br><span class="line">C   foo-C</span><br><span class="line"></span><br><span class="line">$ parallel --tagstring &#123;&#125;-bar echo foo-&#123;&#125; ::: A B C</span><br><span class="line">A-bar   foo-A</span><br><span class="line">B-bar   foo-B</span><br><span class="line">C-bar   foo-C</span><br></pre></td></tr></table></figure><p><code>--dryrun</code> 作用类似于 echo 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --dryrun echo &#123;&#125; ::: A B C</span><br><span class="line">echo A</span><br><span class="line">echo B</span><br><span class="line">echo C</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;&#125; ::: A B C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p><code>--verbose</code> 则在运行之前先打印命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --verbose echo &#123;&#125; ::: A B C</span><br><span class="line">echo A</span><br><span class="line">echo B</span><br><span class="line">echo C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>一般来说，GNU Parallel 会延迟输出，直到一组命令执行完成。使用 <code>--ungroup</code>，可立刻打印输出已完成部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -j2 &#39;printf &quot;%s-start\n%s&quot; &#123;&#125; &#123;&#125;;sleep &#123;&#125;;printf &quot;%s\n&quot; -middle;echo &#123;&#125;-end&#39; ::: 4 2 1</span><br><span class="line">2-start</span><br><span class="line">2-middle</span><br><span class="line">2-end</span><br><span class="line">1-start</span><br><span class="line">1-middle</span><br><span class="line">1-end</span><br><span class="line">4-start</span><br><span class="line">4-middle</span><br><span class="line">4-end</span><br><span class="line"></span><br><span class="line">$ parallel -j2 --ungroup &#39;printf &quot;%s-start\n%s&quot; &#123;&#125; &#123;&#125;;sleep &#123;&#125;;printf &quot;%s\n&quot; -middle;echo &#123;&#125;-end&#39; ::: 4 2 1</span><br><span class="line">4-start</span><br><span class="line">42-start</span><br><span class="line">2-middle</span><br><span class="line">2-end</span><br><span class="line">1-start</span><br><span class="line">1-middle</span><br><span class="line">1-end</span><br><span class="line">-middle</span><br><span class="line">4-end</span><br></pre></td></tr></table></figure><p>使用 <code>--ungroup</code> 会很快，但会导致输出错乱，一个任务的行输出可能会被另一个任务的输出截断。像上例所示，第二行输出混合了两个任务：‘4-middle’ ‘2-start’。使用 <code>--linebuffer</code> 避免这个问题（稍慢一点）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4-start</span><br><span class="line">2-start</span><br><span class="line">2-middle</span><br><span class="line">2-end</span><br><span class="line">1-start</span><br><span class="line">1-middle</span><br><span class="line">1-end</span><br><span class="line">4-middle</span><br><span class="line">4-end</span><br></pre></td></tr></table></figure><p>强制使输出与参数保持顺序 <code>--keep-order/-k</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -j2 -k &#39;printf &quot;%s-start\n%s&quot; &#123;&#125; &#123;&#125;;sleep &#123;&#125;;printf &quot;%s\n&quot; -middle;echo &#123;&#125;-end&#39; ::: 4 2 1</span><br><span class="line">4-start</span><br><span class="line">4-middle</span><br><span class="line">4-end</span><br><span class="line">2-start</span><br><span class="line">2-middle</span><br><span class="line">2-end</span><br><span class="line">1-start</span><br><span class="line">1-middle</span><br><span class="line">1-end</span><br></pre></td></tr></table></figure><ol start="12"><li>将输出保存到文件</li></ol><p>GNU Parallel 可以把每一个任务的输出保存到文件中，临时文件默认保存在 /tmp 中，可以使用 <code>--tmpdir</code> 改变（或者修改 $TMPDIR）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --files ::: A B C</span><br><span class="line">&#x2F;tmp&#x2F;parfmNTJ.par</span><br><span class="line">&#x2F;tmp&#x2F;parmioFz.par</span><br><span class="line">&#x2F;tmp&#x2F;pargaTxf.par</span><br><span class="line"></span><br><span class="line">$ parallel --tmpdir ~ --files ::: A B C</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;parLEXH7.par</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;parXsKsR.par</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;parZxytI.par</span><br><span class="line"></span><br><span class="line">$ TMPDIR&#x3D;~ parallel --files ::: A B C</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;par2tX6C.par</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;parorPJy.par</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;pari5TkI.par</span><br></pre></td></tr></table></figure><p>输出文件可以有结构的保存 <code>--results</code>，输出文件不仅包含标准输出（stdout）也会包含标准错误输出（stderr）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --results outdir echo ::: A B C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line"></span><br><span class="line">$ tree outdir&#x2F;</span><br><span class="line">outdir&#x2F;</span><br><span class="line">└── 1</span><br><span class="line">    ├── A</span><br><span class="line">    │   ├── seq</span><br><span class="line">    │   ├── stderr</span><br><span class="line">    │   └── stdout</span><br><span class="line">    ├── B</span><br><span class="line">    │   ├── seq</span><br><span class="line">    │   ├── stderr</span><br><span class="line">    │   └── stdout</span><br><span class="line">    └── C</span><br><span class="line">        ├── seq</span><br><span class="line">        ├── stderr</span><br><span class="line">        └── stdout</span><br><span class="line"></span><br><span class="line">4 directories, 9 files</span><br></pre></td></tr></table></figure><p>在使用多个变量的时候会显得很有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># --header : will take the first value as name and use that in the directory structure.</span><br><span class="line"></span><br><span class="line">$ parallel --header : --results outdir echo ::: f1 A B ::: f2 C D</span><br><span class="line">A C</span><br><span class="line">A D</span><br><span class="line">B C</span><br><span class="line">B D</span><br><span class="line"></span><br><span class="line">$ tree outdir&#x2F;</span><br><span class="line">outdir&#x2F;</span><br><span class="line">└── f1</span><br><span class="line">    ├── A</span><br><span class="line">    │   └── f2</span><br><span class="line">    │       ├── C</span><br><span class="line">    │       │   ├── seq</span><br><span class="line">    │       │   ├── stderr</span><br><span class="line">    │       │   └── stdout</span><br><span class="line">    │       └── D</span><br><span class="line">    │           ├── seq</span><br><span class="line">    │           ├── stderr</span><br><span class="line">    │           └── stdout</span><br><span class="line">    └── B</span><br><span class="line">        └── f2</span><br><span class="line">            ├── C</span><br><span class="line">            │   ├── seq</span><br><span class="line">            │   ├── stderr</span><br><span class="line">            │   └── stdout</span><br><span class="line">            └── D</span><br><span class="line">                ├── seq</span><br><span class="line">                ├── stderr</span><br><span class="line">                └── stdout</span><br><span class="line"></span><br><span class="line">9 directories, 12 files</span><br></pre></td></tr></table></figure><ol start="13"><li>控制执行</li></ol><p>使用 <code>--jobs/-j</code> 指定并行任务数。</p><p>使用 64 个任务执行 128 个休眠命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ time parallel -N0 -j64 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m2.759s</span><br><span class="line">user    0m0.657s</span><br><span class="line">sys 0m1.345s</span><br></pre></td></tr></table></figure><p>默认情况下并行任务数与 Cpu 核心数相同, 所以这条命令会比每个 Cpu 两个任务的耗时多一倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ time parallel -N0 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m3.478s</span><br><span class="line">user    0m0.656s</span><br><span class="line">sys 0m1.344s</span><br><span class="line"></span><br><span class="line"># 每个 Cpu 两个任务</span><br><span class="line">$ time parallel -N0 --jobs 200% sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m2.659s</span><br><span class="line">user    0m0.734s</span><br><span class="line">sys 0m1.423s</span><br></pre></td></tr></table></figure><p>使用 <code>--jobs 0</code> 表示执行尽可能多的并行任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ time parallel -N0 --jobs 0 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m2.135s</span><br><span class="line">user    0m0.651s</span><br><span class="line">sys 0m1.477s</span><br></pre></td></tr></table></figure><p>除了基于 Cpu 使用率之外，也可以基于 Cpu 数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ time parallel --use-cpus-instead-of-cores -N0 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    1m5.499s</span><br><span class="line">user    0m0.950s</span><br><span class="line">sys 0m1.897s</span><br></pre></td></tr></table></figure><ol start="14"><li>交互</li></ol><p>通过使用 <code>--interactive</code> 在一个任务执行之前让用户决定是否执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --interactive echo ::: 1 2 3</span><br><span class="line">echo 1 ?...y</span><br><span class="line">echo 2 ?...y</span><br><span class="line">echo 3 ?...y</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><ol start="15"><li>耗时</li></ol><p>当 job 有大量的 IO 操作时，为避免“惊群效应”，可使用 <code>--delay</code> 参数指定各个 job 开始的时间间隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --delay 2.5 echo Starting &#123;&#125;\;date ::: 1 2 3</span><br><span class="line">Starting 1</span><br><span class="line">Tue Apr 17 15:21:41 CST 2018</span><br><span class="line">Starting 2</span><br><span class="line">Tue Apr 17 15:21:44 CST 2018</span><br><span class="line">Starting 3</span><br><span class="line">Tue Apr 17 15:21:46 CST 2018</span><br></pre></td></tr></table></figure><p>若已知任务超过一定时间未反应则为失败则可以通过 <code>--timeout</code> 指定等待时间避免无谓的等待。</p><p>GNU Parallel 能计算所有任务运行时间的中位数，因此可以指定时间为中位数的倍数关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --timeout 4.1 sleep &#123;&#125;\; echo &#123;&#125; ::: 2 4 6 8</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">$ parallel --timeout 200% sleep &#123;&#125;\; echo &#123;&#125; ::: 2.1 2.2 3 7 2.3</span><br><span class="line">2.1</span><br><span class="line">2.2</span><br><span class="line">2.3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><ol start="16"><li>显示任务进度信息</li></ol><p>GNU Parallel 有多种方式可用来动态的显示任务进度信息，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --eta sleep ::: 1 3 2 2 1 3 3 2 1</span><br><span class="line">$ parallel --progress sleep ::: 1 3 2 2 1 3 3 2 1</span><br><span class="line">$ seq 1000 | parallel -j10 --bar &#39;(echo -n &#123;&#125;;sleep 0.1)&#39;  2&gt; &gt;(zenity --progress --auto-kill --auto-close)</span><br></pre></td></tr></table></figure><p>使用 <code>--joblog</code> 参数能够生成各个任务的日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --joblog &#x2F;tmp&#x2F;log exit  ::: 1 2 3 0</span><br><span class="line">$ cat &#x2F;tmp&#x2F;log </span><br><span class="line">Seq Host    Starttime   JobRuntime  Send    Receive Exitval Signal  Command</span><br><span class="line">1   :   1523950890.344       0.018  0   0   1   0   exit 1</span><br><span class="line">2   :   1523950890.350       0.014  0   0   2   0   exit 2</span><br><span class="line">3   :   1523950890.357       0.006  0   0   3   0   exit 3</span><br><span class="line">4   :   1523950890.363       0.006  0   0   0   0   exit 0</span><br></pre></td></tr></table></figure><p>通过 <code>--resume-failed</code> 参数可以重新运行失败的任务。</p><p><code>--retry-failed</code> 的作用与 <code>--resume-failed</code>类似，只是 <code>--resume-failed</code> 从命令行读取失败任务，而 <code>--retry-failed</code> 则是从日志文件中读取失败任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --resume-failed --joblog &#x2F;tmp&#x2F;log exit  ::: 1 2 3 0 0 0</span><br><span class="line">$ cat &#x2F;tmp&#x2F;log</span><br><span class="line">Seq Host    Starttime   JobRuntime  Send    Receive Exitval Signal  Command</span><br><span class="line">1   :   1523950890.344       0.018  0   0   1   0   exit 1</span><br><span class="line">2   :   1523950890.350       0.014  0   0   2   0   exit 2</span><br><span class="line">3   :   1523950890.357       0.006  0   0   3   0   exit 3</span><br><span class="line">4   :   1523950890.363       0.006  0   0   0   0   exit 0</span><br><span class="line">1   :   1523951289.575       0.029  0   0   1   0   exit 1</span><br><span class="line">2   :   1523951289.580       0.025  0   0   2   0   exit 2</span><br><span class="line">3   :   1523951289.585       0.019  0   0   3   0   exit 3</span><br><span class="line">5   :   1523951289.591       0.013  0   0   0   0   exit 0</span><br><span class="line">6   :   1523951289.604       0.004  0   0   0   0   exit 0</span><br><span class="line"></span><br><span class="line">$ parallel --retry-failed --joblog &#x2F;tmp&#x2F;log</span><br><span class="line">$ cat &#x2F;tmp&#x2F;log</span><br><span class="line">Seq Host    Starttime   JobRuntime  Send    Receive Exitval Signal  Command</span><br><span class="line">1   :   1523950890.344       0.018  0   0   1   0   exit 1</span><br><span class="line">2   :   1523950890.350       0.014  0   0   2   0   exit 2</span><br><span class="line">3   :   1523950890.357       0.006  0   0   3   0   exit 3</span><br><span class="line">4   :   1523950890.363       0.006  0   0   0   0   exit 0</span><br><span class="line">1   :   1523951289.575       0.029  0   0   1   0   exit 1</span><br><span class="line">2   :   1523951289.580       0.025  0   0   2   0   exit 2</span><br><span class="line">3   :   1523951289.585       0.019  0   0   3   0   exit 3</span><br><span class="line">5   :   1523951289.591       0.013  0   0   0   0   exit 0</span><br><span class="line">6   :   1523951289.604       0.004  0   0   0   0   exit 0</span><br><span class="line">1   :   1523951445.089       0.013  0   0   1   0   exit 1</span><br><span class="line">2   :   1523951445.094       0.009  0   0   2   0   exit 2</span><br><span class="line">3   :   1523951445.102       0.007  0   0   3   0   exit 3</span><br></pre></td></tr></table></figure><ol start="17"><li>终止任务</li></ol><p>GNU Parallel 支持在某一情况下（如第一个失败或成功时，或者 20% 任务失败时）终止任务。</p><p>终止任务又有两种类型：</p><ul><li>其一为立即终止（通过 <code>--halt now</code> 指定），杀死所有正在运行的任务并停止生成新的任务。</li><li>其二为稍后终止（通过 <code>--halt soon</code> 指定），停止生成新任务并等待正在运行任务完成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -j2 --halt soon,fail&#x3D;1 echo &#123;&#125;\; exit &#123;&#125; ::: 0 0 1 2 3</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 1; exit 1</span><br><span class="line">parallel: Starting no more jobs. Waiting for 1 jobs to finish.</span><br><span class="line">2</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 2; exit 2</span><br><span class="line"></span><br><span class="line">$ parallel -j2 --halt now,fail&#x3D;1 echo &#123;&#125;\; exit &#123;&#125; ::: 0 0 1 2 3</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 1; exit 1</span><br><span class="line"></span><br><span class="line">$ parallel -j2 --halt soon,fail&#x3D;20% echo &#123;&#125;\; exit &#123;&#125; ::: 0 1 2 3 4 5 6 7 8 9</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 1; exit 1</span><br><span class="line">2</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 2; exit 2</span><br><span class="line">parallel: Starting no more jobs. Waiting for 1 jobs to finish.</span><br><span class="line">3</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 3; exit 3</span><br><span class="line"></span><br><span class="line">$ parallel -j2 --halt now,success&#x3D;1 echo &#123;&#125;\; exit &#123;&#125; ::: 1 2 3 0 4 5 6</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">parallel: This job succeeded:</span><br><span class="line">echo 0; exit 0</span><br></pre></td></tr></table></figure><p>GNU Parallel 还支持在任务失败后重试运行 <code>--retries</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -k --retries 3 &#39;echo tried &#123;&#125; &gt;&gt;&#x2F;tmp&#x2F;runs; echo completed &#123;&#125;; exit &#123;&#125;&#39; ::: 1 2 0</span><br><span class="line">completed 1</span><br><span class="line">completed 2</span><br><span class="line">completed 0</span><br><span class="line"></span><br><span class="line">$ cat &#x2F;tmp&#x2F;runs </span><br><span class="line">tried 1</span><br><span class="line">tried 2</span><br><span class="line">tried 0</span><br><span class="line">tried 1</span><br><span class="line">tried 2</span><br><span class="line">tried 1</span><br><span class="line">tried 2</span><br></pre></td></tr></table></figure><p>关于终止信号的高级用法参考官方入门文档。</p><ol start="18"><li>资源限制</li></ol><p>GNU Parallel 能够在开始一个新的任务前检查系统的负载情况防止过载（通过 <code>--load</code> 可指定负载），同时还能检查系统是否使用了交换空间 Swap（通过 <code>--noswap</code> 限制使用 Swap）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --load 100% echo load is less than &#123;&#125; job per cpu ::: 1</span><br><span class="line">load is less than 1 job per cpu</span><br><span class="line"></span><br><span class="line">$ parallel --noswap echo the system is not swapping ::: now</span><br><span class="line">the system is not swapping now</span><br></pre></td></tr></table></figure><p>同时，对于某些占用内存较多的程序，Parallel 会检查内存只有内存满足时才启动任务（通过 <code>--memfree</code> 指定需要内存大小），而且在启动任务后内存不够 50% 时会杀掉最新开始的任务，直到这个任务完成再重新开始那些杀死的任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --memfree 1G echo will run if more than 1 GB is ::: free</span><br><span class="line">will run if more than 1 GB is free</span><br></pre></td></tr></table></figure><p>还可以通过 <code>--nice</code> 来指定任务的优先级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --nice 17 echo this is being run with nice -n ::: 17</span><br><span class="line">this is being run with nice -n 17</span><br></pre></td></tr></table></figure><ol start="19"><li>远程操作</li></ol><p>可使用 <code>-S host</code>来进行远程登陆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -S username@$SERVER1 echo running on ::: username@$SERVER1</span><br></pre></td></tr></table></figure><ol start="20"><li>文件传输</li></ol><p>GNU Parallel 文件传输使用的是 Rsync。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo This is input_file &gt; input_file</span><br><span class="line">$ parallel -S $SERVER1 --transferfile &#123;&#125; cat ::: input_file</span><br></pre></td></tr></table></figure><p>更多远程操作参见官方入门文档。</p><ol start="21"><li>–pipe</li></ol><p><code>--pipe</code> 参数使得我们可以将输入（stdin）分为多块（block），然后分配给多个任务多个 Cpu 以达到负载均衡，最后的结果顺序与原始顺序一致。</p><p>使用 <code>--block</code> 参数可以指定每块的大小，默认为 1M。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ perl -e &#39;for(1..1000000)&#123;print &quot;$_\n&quot;&#125;&#39; &gt; num1000000</span><br><span class="line">$ cat num1000000 | parallel --pipe wc</span><br><span class="line"> 165668  165668 1048571</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line">  85352   85352  597465</span><br></pre></td></tr></table></figure><p>如果不关心结果顺序，只想要快速的得到结果，可使用 <code>--round-robin</code> 参数。</p><p>没有这个参数时每块文件都会启动一个命令，使用这个参数后会将这些文件块分配给 job 数任务（通过 <code>--jobs</code> 进行指定）。若想分配更为均匀还可同时指定 <code>--block</code> 参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat num1000000 | parallel --pipe -j4 --round-robin wc</span><br><span class="line"> 299592  299592 2097144</span><br><span class="line"> 315464  315464 2097143</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line"> 235148  235148 1646037</span><br><span class="line"></span><br><span class="line">$ cat num1000000 | parallel --pipe -j4 --block 2M --round-robin wc</span><br><span class="line"> 299593  299593 2097151</span><br><span class="line"> 315465  315465 2097150</span><br><span class="line"> 299593  299593 2097151</span><br><span class="line">  85349   85349  597444</span><br></pre></td></tr></table></figure><h3 id="parallel-使用实例">Parallel 使用实例</h3><p>下面这些实际的使用 Parallel 的例子可能会更容易理解一些。</p><ul><li>使用 Parallel 来进行 JPEG 压缩</li></ul><p>下面是一个普通的 <code>find</code> 命令，用来找出当前目录中的所有 .jpg 文件，然后通过 MozJPEG 包中提供的图像压缩工具 <code>cjpeg</code> 对其进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -name &quot;*.jpg&quot; -exec cjpeg -outfile LoRes&#x2F;&#123;&#125; &#123;&#125; &#39;;&#39;</span><br></pre></td></tr></table></figure><p>总共耗时 0m44.114s。从 top 运行结果可以看到，虽然有 8 个核可用，但实际只有单个线程在用单个核。</p><p><a href="https://img.linux.net.cn/data/attachment/album/201712/22/223442u13nq87a61an9z9q.png" target="_blank" rel="noopener">https://img.linux.net.cn/data/attachment/album/201712/22/223442u13nq87a61an9z9q.png</a></p><p>下面用 Parallel 来运行相同的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -name &quot;*.jpg&quot; | parallel cjpeg -outfile LoRes&#x2F;&#123;&#125; &#123;&#125;</span><br></pre></td></tr></table></figure><p>这次压缩所有图像的时间缩减到了 0m10.814s。从 top 运行结果可以看到，所有 CPU 核都满负荷运行，有 8 个线程对应使用 8 个 CPU 核。</p><p><a href="https://img.linux.net.cn/data/attachment/album/201712/22/223519h7n30u47omdqhzmu.png" target="_blank" rel="noopener">https://img.linux.net.cn/data/attachment/album/201712/22/223519h7n30u47omdqhzmu.png</a></p><h3 id="参考文档">参考文档</h3><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a><br><a href="http://t.cn/E6KnjtP" target="_blank" rel="noopener">http://t.cn/E6KnjtP</a><br><a href="http://t.cn/E6KB5Rr" target="_blank" rel="noopener">http://t.cn/E6KB5Rr</a><br><a href="http://t.cn/E69yv3g" target="_blank" rel="noopener">http://t.cn/E69yv3g</a><br><a href="http://t.cn/Rm9X2WC" target="_blank" rel="noopener">http://t.cn/Rm9X2WC</a><br><a href="http://t.cn/E6Wr74r" target="_blank" rel="noopener">http://t.cn/E6Wr74r</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Bash&lt;/code&gt; 命令通常单线程运行，这意味着所有的处理工作只在单个 CPU 上执行。随着 CPU 规模的扩大以及核心数目的增加，这意味着只有一小部分的 CPU 资源用于处理任务，这样就造成了很大的资源浪费。 这种情况在进行多媒体转换（比如：图片和视频转换）以及数据压缩中经常遇到。&lt;/p&gt;
&lt;p&gt;本文我们将介绍如何使用 GNU Parallel 程序在所有 CPU 核上并行地执行计算任务。&lt;/p&gt;
&lt;h3 id=&quot;Parallel-介绍&quot;&gt;Parallel 介绍&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;GNU Parallel 是一种通用的并行化程序，可以在同一台机器上或在您具有 SSH 访问权限的多台机器上轻松并行运行作业。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果要在 4 个 CPU 上运行 32 个不同的作业，并行化的一种直接方法是在每个 CPU 上运行8个作业。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://upload-images.jianshu.io/upload_images/27460-5b784effa2396844.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://upload-images.jianshu.io/upload_images/27460-5b784effa2396844.png&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GNU Parallel 会在完成后生成一个新进程，并保持 CPU 处于活动状态，从而节省时间。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://upload-images.jianshu.io/upload_images/27460-2901afa31279f8ff.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://upload-images.jianshu.io/upload_images/27460-2901afa31279f8ff.png&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Parallel-安装&quot;&gt;Parallel 安装&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过包安装&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;CentOS / RHEL&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ yum install parallel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu / Debian&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt install parallel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;通过脚本安装&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ (wget -O - pi.dk&amp;#x2F;3 || curl pi.dk&amp;#x2F;3&amp;#x2F;) | bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Parallel" scheme="https://www.hi-linux.com/tags/Parallel/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 5 期 )</title>
    <link href="https://www.hi-linux.com/posts/27183.html"/>
    <id>https://www.hi-linux.com/posts/27183.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.398Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019" target="_blank" rel="noopener">微软宣布 SQL Server 2019 免费支持 Java</a></p><p>近日，微软宣布SQL Server 2019 将免费支持 Java。从新发布的 SQL Server 2019 社区技术预览(CTP) 3.2 开始，包括 Azul System 的 Zulu，可以直接嵌入到 SQL Server 中使用 Java 的所有场景（ PolyBase、Apache SPark、Java 可扩展性等等）。除了为 SQL Server 支付的费用外，不用其他任何成本。</p><p>链接：<a href="https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019" target="_blank" rel="noopener">https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019</a></p><p><img src="https://cloudblogs.microsoft.com/uploads/prod/sites/32/2019/07/SQL-Server-loves-Java-white.png" alt=""></p><p>2、<a href="https://www.oschina.net/news/108643/github-account-reactivation-request-form" target="_blank" rel="noopener">GitHub 被爆开始实名制，以便于执行美国贸易制裁</a></p><p>从上周开始，GitHub 封禁部分国家、地区开发者账号的新闻持续发酵。从克里米亚地区的俄罗斯籍开发者到全部伊朗境内开发者再到定居芬兰的伊朗籍开发者，统统遭遇了账号被封无法创建私有库并且已经创建的私有库遭到关闭，且并未得到提前通知，没有给出任何缓冲备份时间。</p><p>有消息指出 “GitHub 被曝按过往登录 IP 址判定用户的国别来执行美国贸易制裁，即使只逗留，而 Account Reactivation Request Form 要求照片身份证副本（a copy of your photo identification (ID)）、自拍（a selfie）和身份号（the ID number），故 GitHub 正渐行实名制。”</p><p>链接：<a href="https://www.oschina.net/news/108643/github-account-reactivation-request-form" target="_blank" rel="noopener">https://www.oschina.net/news/108643/github-account-reactivation-request-form</a></p><p><img src="https://i.loli.net/2019/07/31/5d40f0a8c9fee14930.png" alt=""></p><p>3、<a href="https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released" target="_blank" rel="noopener">GitLab 再次发布安全补丁，受影响涉及版本 12.1.2、12.0.4 和 11.11.7</a></p><p>GitLab 再次发布了全系的安全更新补丁，这些安全问题影响 GitLab CE/EE 10.6 以及以后的版本。版本涉及 12.1.2、12.0.4 和 11.11.7，包括社区版和企业版。这些版本包含重要的安全更新，强烈建议所有 GitLab 安装立即更新！</p><p>链接：<a href="https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released" target="_blank" rel="noopener">https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released</a></p><p>4、<a href="https://www.cnbeta.com/articles/tech/873537.htm" target="_blank" rel="noopener">Ubuntu 18.04 和 16.04 LTS 迎来 Linux 内核实时补丁， 修复 5 个安全漏洞</a></p><p>Canonical 为长期支持（LTS）的 Ubuntu 18.04 和 16.04 操作系统提供了最新的 Linux 内核安全更新，Bionic Beaver 和 Xenial Xerus 用户可借助实时补丁服务（Livepatch Service）实施免重启的操作系统内核更新。本次实时补丁主要修复了五个安全问题，比如 CVE-2019-11815 竞争条件漏洞。其可能导致 Linux 内核的可靠数据包套接字（RDS）协议被攻击者利用，导致系统崩溃或执行任意代码。</p><p>链接：<a href="https://www.cnbeta.com/articles/tech/873537.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/tech/873537.htm</a></p><p><img src="https://i.loli.net/2019/07/31/5d413bb393e0497615.jpg" alt=""></p><p>5、<a href="https://www.oschina.net/news/108657/chrome-76-released" target="_blank" rel="noopener">Chrome 76 稳定版发布，默认屏蔽 Flash，禁用了隐身模式检测等</a></p><p>Google 发布了 Chrome 76，默认屏蔽 Flash，禁用了隐身模式检测。网站不再能利用脚本检测用户是否使用了隐身模式。其它功能还有简化 Progressive Web Apps 的安装、支持暗黑模式、更多开发者工具功能等等。</p><p>链接：<a href="https://www.oschina.net/news/108657/chrome-76-released" target="_blank" rel="noopener">https://www.oschina.net/news/108657/chrome-76-released</a></p><p><img src="https://i.loli.net/2019/07/31/5d413d1c5886c15984.jpg" alt=""></p><p>6、<a href="https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/" target="_blank" rel="noopener">Docker 深化与 K8s 的集成</a></p><p>Docker 宣布推出 Docker Enterprise v3.0，新版本进一步加强了应用程序平台 Docker 和容器编排标准 Kubernetes 的联系。</p><p>根据 Docker 官方博客，新版本中针对 Kubernetes 中集成的安全性和稳定性的改进，该更新还解决了企业用户将容器转移到生产中常遇到的软件错误。</p><p>链接：<a href="https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/" target="_blank" rel="noopener">https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/</a></p><p><img src="https://i.loli.net/2019/07/31/5d414134d085458878.png" alt=""></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://github.com/18601949127/DiDiCallCar" target="_blank" rel="noopener">DiDiCallCar</a></p><p>一个仿滴滴打车的 Android 出行项目，主要针对滴滴等出行平台一直饱受质疑的 “人车不符” 问题，以及当前越发火热的国际化和出海战略。</p><p>项目地址: <a href="https://github.com/18601949127/DiDiCallCar" target="_blank" rel="noopener">https://github.com/18601949127/DiDiCallCar</a></p><p><img src="https://i.loli.net/2019/07/31/5d414d9b5b0fa61934.gif" alt=""></p><p>2、<a href="https://github.com/noplay/python-mysql-replication" target="_blank" rel="noopener">Python-MySQL-Replication</a></p><p>Python-MySQL-Replication 是基于 Python 实现的 MySQL 复制协议工具。我们可以用它来解析 Binlog 获取日志的 Insert，Update，Delete 等事件 ，并基于此做其他业务需求。比如：数据更改时失效缓存，监听 DML 事件通知下游业务方做对应处理。</p><p>项目地址: <a href="https://github.com/noplay/python-mysql-replication" target="_blank" rel="noopener">https://github.com/noplay/python-mysql-replication</a></p><p>3、<a href="https://github.com/danfengcao/binlog2sql" target="_blank" rel="noopener">Binlog2SQL</a></p><p>Binlog2SQL 是大众点评开源的一款用于解析 Binlog 的工具，Binlog2SQL 解析 Binlog 的能力就是基于上面提到的 Python-MySQL-Replication 的。</p><p>Binlog2SQL 可以从 MySQL Binlog 解析出你要的 SQL。根据不同选项，你可以得到原始SQL、回滚SQL、去除主键的 INSERT SQL 等。</p><p>项目地址: <a href="https://github.com/danfengcao/binlog2sql" target="_blank" rel="noopener">https://github.com/danfengcao/binlog2sql</a></p><p>4、<a href="https://github.com/matomo-org/matomo" target="_blank" rel="noopener">Matomo</a></p><p>Matomo 的前身是 Piwik，类似 Google Analytics，是个非常出名的开源网站统计分析程序。提供了关键字和搜索引擎、首页网址、页面标题、用户国家、提供商、操作系统、浏览器市场份额、屏幕分辨率、网站停留时间、顶级入口/出口页面、下载文件等等的分析结果。</p><p>项目地址: <a href="https://github.com/matomo-org/matomo" target="_blank" rel="noopener">https://github.com/matomo-org/matomo</a></p><p><img src="https://i.loli.net/2019/07/31/5d414df75f22f24767.jpg" alt=""></p><p>5、<a href="https://github.com/elsesiy/qrgo" target="_blank" rel="noopener">qrgo</a></p><p>一个用 Go 语言开发的在命令行生成二维码的工具。</p><p>项目地址: <a href="https://github.com/elsesiy/qrgo" target="_blank" rel="noopener">https://github.com/elsesiy/qrgo</a></p><p>6、<a href="https://github.com/talos-systems/talos" target="_blank" rel="noopener">Talos</a></p><p>Talos 是一款专门用于部署 Kubernetes 的操作系统。相对于 CoreOS、RancherOS 或者 LinuxKit 这些容器操作系统，Talos 更为精简。</p><p>项目地址: <a href="https://github.com/talos-systems/talos" target="_blank" rel="noopener">https://github.com/talos-systems/talos</a></p><p><img src="https://i.loli.net/2019/07/31/5d414eafe22db50582.jpg" alt=""></p><p>7、<a href="https://github.com/Ladicle/kubectl-bindrole" target="_blank" rel="noopener">kubectl-bindrole</a></p><p>kubectl-bindrole 是一款 Kubectl 插件，可用于帮助查找 Kubernetes 集群中指定 SA/Group/User 的权限等信息。</p><p>项目地址: <a href="https://github.com/Ladicle/kubectl-bindrole" target="_blank" rel="noopener">https://github.com/Ladicle/kubectl-bindrole</a></p><p><img src="https://i.loli.net/2019/07/31/5d414f1e457da81308.jpg" alt=""></p><p>8、<a href="https://www.katacoda.com" target="_blank" rel="noopener">Katacoda</a></p><p>Katacoda 是一个在线学习平台，在 Web 上提供学习需要的服务器终端，里面包含学习所需的环境。Katacoda 包含了很多当下热门的平台，比如：Docker、Kubernetes、Prometheus、Service Meshes 等。</p><p>项目地址: <a href="https://www.katacoda.com" target="_blank" rel="noopener">https://www.katacoda.com</a></p><p><img src="https://i.loli.net/2019/07/31/5d414f63f1cba80498.jpg" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北</a></p><p>使用中文文档排版时,有许多细节是需要通过统一来实现美感，比如：中英文的空格、标点的使用、专有名词的书写等等。达成最起码的排版统一可以让团队更像一支团队，本文档将介绍一些中文文档排版时的规范和技巧。</p><p>链接：<a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">https://github.com/sparanoid/chinese-copywriting-guidelines</a></p><p><img src="https://i.loli.net/2019/07/23/5d367afed0d7d68854.jpg" alt=""></p><p>2、<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python-100-Days</a></p><p>GitHub 上非常热门的一个 Python 学习的项目。在这个项目中，作者详细给出了一个 100 天的 Python 学习计划，包括每天需要掌握的内容、学习周期、资料库等。</p><p>从怎么安装 Python 到如何使用 Django 开发一个完整项目，共 100 天，11 个阶段，每完成一个阶段，都能让你成就感爆棚！</p><p>链接：<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">https://github.com/jackfrued/Python-100-Days</a></p><p><img src="https://i.loli.net/2019/07/24/5d380876973b171503.jpg" alt=""></p><p>3、<a href="https://my.oschina.net/u/1000241/blog/3080057" target="_blank" rel="noopener">从技术平台到 aPaaS 平台</a></p><p>本文将介绍 aPaaS 平台的基本概念和使用场景，以及和 PaaS 平台的区别。</p><p>链接：<a href="https://my.oschina.net/u/1000241/blog/3080057" target="_blank" rel="noopener">https://my.oschina.net/u/1000241/blog/3080057</a></p><p><img src="https://i.loli.net/2019/07/31/5d4137e6a9c5d51924.jpg" alt=""></p><h2 id="每周观点">每周观点</h2><p>1、在你生命力最旺盛的时候，你要想清楚几件事，第一件事你要想清楚说我这辈子最喜欢的工作是什么，就我热爱什么东西，这个是最关键的事情；第二要让自己成为一个专业的人；第三你愿意用未来的二十年时间去完成，这件你喜欢的工作和你专业的事情。—— 吴晓波</p><p>2、奈何一个人随着年龄增长，梦想便不复轻盈；他开始用双手掂量生活，更看重果实而非花朵。—— 威廉.巴特勒.叶芝「凯尔特的薄暮」</p><p>3、越是试着忘记，越是记得深刻。—— 宫崎骏「天空之城」</p><p>4、当你的才华还撑不起你的野心的时候，你就应该静下心来学习；当你的能力还驾驭不了你的目标时，就应该沉下心来历练；梦想，不是浮躁，而是沉淀和积累。只有拼出来的美丽，没有等出来的辉煌。机会永远是留给最渴望的那个人，学会与内心深处的你对话，问问自己，想要怎样的人生，静心学习，耐心沉淀，送给自己，共勉。—— 莫言</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软宣布 SQL Server 2019 免费支持 Java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，微软宣布SQL Server 2019 将免费支持 Java。从新发布的 SQL Server 2019 社区技术预览(CTP) 3.2 开始，包括 Azul System 的 Zulu，可以直接嵌入到 SQL Server 中使用 Java 的所有场景（ PolyBase、Apache SPark、Java 可扩展性等等）。除了为 SQL Server 支付的费用外，不用其他任何成本。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloudblogs.microsoft.com/uploads/prod/sites/32/2019/07/SQL-Server-loves-Java-white.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.oschina.net/news/108643/github-account-reactivation-request-form&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 被爆开始实名制，以便于执行美国贸易制裁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从上周开始，GitHub 封禁部分国家、地区开发者账号的新闻持续发酵。从克里米亚地区的俄罗斯籍开发者到全部伊朗境内开发者再到定居芬兰的伊朗籍开发者，统统遭遇了账号被封无法创建私有库并且已经创建的私有库遭到关闭，且并未得到提前通知，没有给出任何缓冲备份时间。&lt;/p&gt;
&lt;p&gt;有消息指出 “GitHub 被曝按过往登录 IP 址判定用户的国别来执行美国贸易制裁，即使只逗留，而 Account Reactivation Request Form 要求照片身份证副本（a copy of your photo identification (ID)）、自拍（a selfie）和身份号（the ID number），故 GitHub 正渐行实名制。”&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108643/github-account-reactivation-request-form&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108643/github-account-reactivation-request-form&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/31/5d40f0a8c9fee14930.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitLab 再次发布安全补丁，受影响涉及版本 12.1.2、12.0.4 和 11.11.7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitLab 再次发布了全系的安全更新补丁，这些安全问题影响 GitLab CE/EE 10.6 以及以后的版本。版本涉及 12.1.2、12.0.4 和 11.11.7，包括社区版和企业版。这些版本包含重要的安全更新，强烈建议所有 GitLab 安装立即更新！&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.cnbeta.com/articles/tech/873537.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu 18.04 和 16.04 LTS 迎来 Linux 内核实时补丁， 修复 5 个安全漏洞&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Canonical 为长期支持（LTS）的 Ubuntu 18.04 和 16.04 操作系统提供了最新的 Linux 内核安全更新，Bionic Beaver 和 Xenial Xerus 用户可借助实时补丁服务（Livepatch Service）实施免重启的操作系统内核更新。本次实时补丁主要修复了五个安全问题，比如 CVE-2019-11815 竞争条件漏洞。其可能导致 Linux 内核的可靠数据包套接字（RDS）协议被攻击者利用，导致系统崩溃或执行任意代码。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/tech/873537.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/tech/873537.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/31/5d413bb393e0497615.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.oschina.net/news/108657/chrome-76-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome 76 稳定版发布，默认屏蔽 Flash，禁用了隐身模式检测等&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google 发布了 Chrome 76，默认屏蔽 Flash，禁用了隐身模式检测。网站不再能利用脚本检测用户是否使用了隐身模式。其它功能还有简化 Progressive Web Apps 的安装、支持暗黑模式、更多开发者工具功能等等。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108657/chrome-76-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108657/chrome-76-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/31/5d413d1c5886c15984.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker 深化与 K8s 的集成&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker 宣布推出 Docker Enterprise v3.0，新版本进一步加强了应用程序平台 Docker 和容器编排标准 Kubernetes 的联系。&lt;/p&gt;
&lt;p&gt;根据 Docker 官方博客，新版本中针对 Kubernetes 中集成的安全性和稳定性的改进，该更新还解决了企业用户将容器转移到生产中常遇到的软件错误。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/31/5d414134d085458878.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 7 期 )</title>
    <link href="https://www.hi-linux.com/posts/43532.html"/>
    <id>https://www.hi-linux.com/posts/43532.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.399Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.cnbeta.com/articles/tech/876919.htm" target="_blank" rel="noopener">华为正式发布自研操作系统鸿蒙 HarmonyOS</a></p><p>华为消费者业务首届的开发者大会上，华为公布了自研操作系统 “鸿蒙”。鸿蒙 OS 的英文是 “HarmonyOS”，亦可理解为和谐系统。</p><p>华为公司消费者业务 CEO 余承东表示：鸿蒙是全世界第一个面向全场景微内核的分布式 OS，鸿蒙 OS 将向全球开发者开源，并推动成立开源基金会，建立开源社区。</p><p>据华为方面介绍，将在智慧屏产品中率先使用鸿蒙 OS 1.0。未来三年，除完善相关技术外，鸿蒙 OS 会逐步应用在可穿戴、智慧屏、车机等更多智能设备中。</p><p>链接：<a href="https://www.cnbeta.com/articles/tech/876919.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/tech/876919.htm</a></p><p><img src="https://i.loli.net/2019/08/09/68uqFnrfUB9gIoz.jpg" alt=""></p><p>2、<a href="https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation" target="_blank" rel="noopener">Red Hat 加入 RISC-V 基金会</a></p><p>Red Hat 加入了 RISC-V 基金会，以帮助开发开源处理器 ISA。目前 RISC-V 成员已有谷歌、NVIDIA、高通(Qualcomm)、SiFive、WesternDigital、IBM 和三星等。</p><p>Red Hat 一直在积极推广 RISC-V 作为一种开源处理器指令集体系结构，Red Hat 开发人员已经在 Fedora 的 RISC-V 支持方面提供了帮助，该公司正通过加入 RISC-V 基金会，来提供更多的帮助并是实现他们的承诺。</p><p>链接：<a href="https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation" target="_blank" rel="noopener">https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation</a></p><p><img src="https://i.loli.net/2019/08/09/1lsCXmES7ZzBgu6.jpg" alt=""></p><p>3、<a href="https://www.oschina.net/news/108903/grafana-6-3-0-released" target="_blank" rel="noopener">Grafana 6.3.0 版本发布</a></p><p>Grafana 6.3.0 发布了，Grafana 是一个功能丰富的指标标准仪表板和图形编辑器，用于分析和监控 Graphite、Elasticsearch、OpenTSDB、Prometheus 和 InfluxDB。</p><p>链接：<a href="https://www.oschina.net/news/108903/grafana-6-3-0-released" target="_blank" rel="noopener">https://www.oschina.net/news/108903/grafana-6-3-0-released</a></p><p><img src="https://i.loli.net/2019/08/09/PpiodSvr6TCcKwh.png" alt=""></p><p>4、<a href="http://t.cn/AiHyJZCh" target="_blank" rel="noopener">GitHub Actions 集成 CI/CD 功能，所有开源项目可免费使用</a></p><p>近日，GitHub 官方博客发文称 Github Actions 已支持内置持续集成和交付 (CI/CD) 功能，并对所有开源项目免费！</p><p>目前该功能可以在 Beta 版本中测试使用，11 月 13 日 GitHub Actions 将在 GitHub Universe 上正式发布！</p><p>链接：<a href="http://t.cn/AiHyJZCh" target="_blank" rel="noopener">http://t.cn/AiHyJZCh</a></p><p><img src="https://i.loli.net/2019/08/13/yMQgZnHczPAOqpe.png" alt=""></p><p>5、<a href="http://t.cn/AiHyKWDI" target="_blank" rel="noopener">VS Code 1.37 发布，多个图标迎来全新设计</a></p><p>近日，微软发布了 Visual Studio Code 1.37 版本。多个图标迎来全新设计，此次图标更新包含了侧边栏、文件管理器、搜索、调试等区域。</p><p>链接：<a href="http://t.cn/AiHyKWDI" target="_blank" rel="noopener">http://t.cn/AiHyKWDI</a></p><p><img src="https://i.loli.net/2019/08/13/kQgqbzBd7m5XE6G.gif" alt=""></p><p>6、<a href="http://t.cn/AiHy0fzc" target="_blank" rel="noopener">Chrome 爆新特性，可在多平台上共享剪贴板</a></p><p>根据 softpedia 报道，Chrome 添加了一个新功能。不管浏览器运行在哪个平台上，允许用户在一个设备上复制内容，并将其粘贴到另一个设备上。该功能也就是一个共享剪贴板，该剪贴板将可以在 Windows、Linux、MacOS 和 Android 上的 Google Chrome 中使用。</p><p>链接：<a href="http://t.cn/AiHy0fzc" target="_blank" rel="noopener">http://t.cn/AiHy0fzc</a></p><p><img src="https://i.loli.net/2019/08/13/GKQZasf5vRInX94.png" alt=""></p><p>7、<a href="https://news.mydrivers.com/1/641/641041.htm" target="_blank" rel="noopener">全球百大流量网站榜出炉：谷歌第一，百度第四</a></p><p>通过来自 SimilarWeb 的数据，Visualcapitalist 用图标地形式列出了全球互联网上 100 个流量规模最大的网站，其中谷歌、Youtube、Facebook、百度、维基百科、Twitter、雅虎、P站、Instagram、x站排名前十。</p><p>链接：<a href="http://t.cn/AiHabsGl" target="_blank" rel="noopener">http://t.cn/AiHabsGl</a></p><p><img src="https://i.loli.net/2019/08/15/zKEn3bTc6fRDdvQ.jpg" alt=""></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://github.com/luong-komorebi/Awesome-Linux-Software" target="_blank" rel="noopener">Awesome-Linux-Software</a></p><p>该项目收集整理了一批优质的开源 Linux 软件，包含电子书工具、命令行工具、文件管理器等多个分类。</p><p>项目地址: <a href="https://github.com/luong-komorebi/Awesome-Linux-Software" target="_blank" rel="noopener">https://github.com/luong-komorebi/Awesome-Linux-Software</a></p><p><img src="https://i.loli.net/2019/08/15/6VAuw4Tl7ML1GeK.jpg" alt=""></p><p>2、<a href="https://github.com/hanchuanchuan/goInception" target="_blank" rel="noopener">goInception</a></p><p>一个集审核、执行、备份及生成回滚语句于一身的 MySQL 运维工具。</p><p>项目地址: <a href="https://github.com/hanchuanchuan/goInception" target="_blank" rel="noopener">https://github.com/hanchuanchuan/goInception</a></p><p><img src="https://i.loli.net/2019/08/15/JRICdAy4QjM5hVk.jpg" alt=""></p><p>3、<a href="https://github.com/sindresorhus/refined-github" target="_blank" rel="noopener">Refined GitHub</a></p><p>Refined GitHub 是一个简化 GitHub 界面并增加很多实用功能的浏览器扩展程序。支持 Chrome、Firefox 与 Opera。</p><p>项目地址: <a href="https://github.com/sindresorhus/refined-github" target="_blank" rel="noopener">https://github.com/sindresorhus/refined-github</a></p><p><img src="https://i.loli.net/2019/07/22/5d3561a2713da78142.png" alt=""></p><p>4、<a href="https://github.com/huashengdun/webssh" target="_blank" rel="noopener">WebSSH</a></p><p>一个开源的 Python 编写的 Web 端 SSH 工具，可以通过浏览器进行远程服务器 SSH 登录。</p><p>项目地址: <a href="https://github.com/huashengdun/webssh" target="_blank" rel="noopener">https://github.com/huashengdun/webssh</a></p><p><img src="https://i.loli.net/2019/08/15/EdksjaNlyIG7unw.png" alt=""></p><p>5、<a href="https://github.com/checkly/puppeteer-recorder" target="_blank" rel="noopener">Puppeteer Recorder</a></p><p>Puppeteer 是一个 Node 库，它提供了一个高级 API 来控制 DevTools 协议上的 Chrome 或 Chromium，常用于爬虫、自动化测试等，你在浏览器手动完成的大多数事情都可以使用它来完成。</p><p>无论是爬虫还是自动化测试，你都要先写 Puppeteer 脚本，而 Puppeteer Recorder 是 一个 Chrome 扩展程序，可录制你的浏览器交互操作并生成 Puppeteer 脚本。</p><p>项目地址: <a href="https://github.com/checkly/puppeteer-recorder" target="_blank" rel="noopener">https://github.com/checkly/puppeteer-recorder</a></p><p><img src="https://i.loli.net/2019/07/22/5d35638927ba854572.png" alt=""></p><p>6、<a href="https://github.com/ksky521/nodeppt" target="_blank" rel="noopener">NodePPT</a></p><p>一个基于 NodeJS、HTML、CSS 等技术，将 Markdown 文档转成幻灯片。在浏览器上实现类似 Power Point / KeyNote 效果的一个工具。</p><p>项目地址: <a href="https://github.com/ksky521/nodeppt" target="_blank" rel="noopener">https://github.com/ksky521/nodeppt</a></p><p><img src="https://i.loli.net/2019/07/22/5d3567df109a010849.png" alt=""></p><p>7、<a href="https://github.com/wagoodman/dive" target="_blank" rel="noopener">dive</a></p><p>这是一款用于分析 Docker 镜像的镜像层内容以及探索缩小 Docker 镜像大小方法的工具。</p><p>项目地址: <a href="https://github.com/wagoodman/dive" target="_blank" rel="noopener">https://github.com/wagoodman/dive</a></p><p><img src="https://i.loli.net/2019/07/22/5d356ace3b9b839934.gif" alt=""></p><p>8、<a href="https://github.com/vicanso/diving" target="_blank" rel="noopener">diving</a></p><p>一个基于 Dive 分析 Docker 镜像，并可以在 Web 页面上方便地浏览镜像信息。比如镜像每层的变动（增加、修改、删除等）、用户层数据大小等信息。</p><p>项目地址: <a href="https://github.com/vicanso/diving" target="_blank" rel="noopener">https://github.com/vicanso/diving</a></p><p><img src="https://i.loli.net/2019/07/22/5d35694d6a88f96238.gif" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="http://t.cn/AiHylYV7" target="_blank" rel="noopener">Kubernetes 容器运行时演进</a></p><p>Kubernetes 已经成为容器编排调度领域的事实标准，其优良的架构不仅保证了丰富的容器编排调度功能，同时也提供了各个层次的扩展接口以满足用户的定制化需求。其中，容器运行时作为 Kubernetes 管理和运行容器的关键组件，当然也提供了简便易用的扩展接口，也就是 CRI（Container Runtime Interface）。本文将介绍 CRI 的由来、演进以及未来展望，主要内容分为四个部分：Kubernetes架构简介、容器运行时接口的基本原理、容器运行时的演进以及未来的展望。</p><p>链接：<a href="http://t.cn/AiHylYV7" target="_blank" rel="noopener">http://t.cn/AiHylYV7</a></p><p>2、<a href="http://t.cn/AiHXPPm0" target="_blank" rel="noopener">Kubernetes 网络疑难杂症排查分享</a></p><p>本文分享几个比较复杂的 Kubernetes 网络方面的问题排查和解决思路，深入分析并展开相关知识，信息量巨大。当完全看懂后我相信你的功底会更加扎实，解决问题的能力会大大提升。</p><p>链接：<a href="http://t.cn/AiHXPPm0" target="_blank" rel="noopener">http://t.cn/AiHXPPm0</a></p><p>3、<a href="http://t.cn/AiHXznn0" target="_blank" rel="noopener">从大数据的角度来谈谈运维监控这件事儿</a></p><p>做运维的人对监控这件事儿都太熟悉了，但是对于监控这么一件老生常谈的事儿，本文将从大数据的角度来看看有什么新的发现。</p><p>链接：<a href="http://t.cn/AiHXznn0" target="_blank" rel="noopener">http://t.cn/AiHXznn0</a></p><h2 id="每周观点">每周观点</h2><p>1、人生的美妙之处在于迷上一样东西。人生苦短，少做些虚无缥缈的事。 —— 刘慈欣「三体」</p><p>2、有目标者，意志竟成。—— 弗兰克尔</p><p>3、竞争总是件好事，它促使我们竭尽全力。垄断使人自满，满足于做平庸之辈。—— 南希·皮尔西</p><p>4、人生的磨难是很多的，所以我们不可对于每一件轻微的伤害都过于敏感。在生活磨难面前，精神上的坚强和无动于衷是我们抵抗罪恶和人生意外的最好武器。—— 洛克</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnbeta.com/articles/tech/876919.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;华为正式发布自研操作系统鸿蒙 HarmonyOS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为消费者业务首届的开发者大会上，华为公布了自研操作系统 “鸿蒙”。鸿蒙 OS 的英文是 “HarmonyOS”，亦可理解为和谐系统。&lt;/p&gt;
&lt;p&gt;华为公司消费者业务 CEO 余承东表示：鸿蒙是全世界第一个面向全场景微内核的分布式 OS，鸿蒙 OS 将向全球开发者开源，并推动成立开源基金会，建立开源社区。&lt;/p&gt;
&lt;p&gt;据华为方面介绍，将在智慧屏产品中率先使用鸿蒙 OS 1.0。未来三年，除完善相关技术外，鸿蒙 OS 会逐步应用在可穿戴、智慧屏、车机等更多智能设备中。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/tech/876919.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/tech/876919.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/09/68uqFnrfUB9gIoz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Red Hat 加入 RISC-V 基金会&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Red Hat 加入了 RISC-V 基金会，以帮助开发开源处理器 ISA。目前 RISC-V 成员已有谷歌、NVIDIA、高通(Qualcomm)、SiFive、WesternDigital、IBM 和三星等。&lt;/p&gt;
&lt;p&gt;Red Hat 一直在积极推广 RISC-V 作为一种开源处理器指令集体系结构，Red Hat 开发人员已经在 Fedora 的 RISC-V 支持方面提供了帮助，该公司正通过加入 RISC-V 基金会，来提供更多的帮助并是实现他们的承诺。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/09/1lsCXmES7ZzBgu6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/108903/grafana-6-3-0-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Grafana 6.3.0 版本发布&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Grafana 6.3.0 发布了，Grafana 是一个功能丰富的指标标准仪表板和图形编辑器，用于分析和监控 Graphite、Elasticsearch、OpenTSDB、Prometheus 和 InfluxDB。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108903/grafana-6-3-0-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108903/grafana-6-3-0-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/09/PpiodSvr6TCcKwh.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;http://t.cn/AiHyJZCh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub Actions 集成 CI/CD 功能，所有开源项目可免费使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，GitHub 官方博客发文称 Github Actions 已支持内置持续集成和交付 (CI/CD) 功能，并对所有开源项目免费！&lt;/p&gt;
&lt;p&gt;目前该功能可以在 Beta 版本中测试使用，11 月 13 日 GitHub Actions 将在 GitHub Universe 上正式发布！&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://t.cn/AiHyJZCh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/AiHyJZCh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/yMQgZnHczPAOqpe.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;http://t.cn/AiHyKWDI&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VS Code 1.37 发布，多个图标迎来全新设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，微软发布了 Visual Studio Code 1.37 版本。多个图标迎来全新设计，此次图标更新包含了侧边栏、文件管理器、搜索、调试等区域。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://t.cn/AiHyKWDI&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/AiHyKWDI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/kQgqbzBd7m5XE6G.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;http://t.cn/AiHy0fzc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome 爆新特性，可在多平台上共享剪贴板&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据 softpedia 报道，Chrome 添加了一个新功能。不管浏览器运行在哪个平台上，允许用户在一个设备上复制内容，并将其粘贴到另一个设备上。该功能也就是一个共享剪贴板，该剪贴板将可以在 Windows、Linux、MacOS 和 Android 上的 Google Chrome 中使用。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://t.cn/AiHy0fzc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/AiHy0fzc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/GKQZasf5vRInX94.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&quot;https://news.mydrivers.com/1/641/641041.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;全球百大流量网站榜出炉：谷歌第一，百度第四&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过来自 SimilarWeb 的数据，Visualcapitalist 用图标地形式列出了全球互联网上 100 个流量规模最大的网站，其中谷歌、Youtube、Facebook、百度、维基百科、Twitter、雅虎、P站、Instagram、x站排名前十。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://t.cn/AiHabsGl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/AiHabsGl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/15/zKEn3bTc6fRDdvQ.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>使用 Mirror 协议实现 Ubuntu 访问多软件源</title>
    <link href="https://www.hi-linux.com/posts/56051.html"/>
    <id>https://www.hi-linux.com/posts/56051.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.400Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知 Ubuntu 官方软件源访问速度一直都是比较慢的，通常情况下我们为了高效的通过软件源安装软件会使用国内的镜像源。国内虽然有很多可用的镜像源，但有时某些源偶尔也会出现访问故障(比如：清华、北大等镜像源)。出现这样情况的时候通常的解决方法就是更换一个可用的镜像源，但是如果涉及的机器特别多的时候就会非常的麻烦。</p><p>难道这是一个无解的问题？当然不是，只能说你运气真好，来对了地方。你一定是上辈子拯救了银河系才有这样的好运，哈哈哈。其实 Apt 源是支持 Mirror 协议的，可以从多个镜像源中自动选择可用的一个。本文将介绍如何利用 Mirror 协议来解决类似问题。</p><h3 id="什么是-mirror-协议">什么是 Mirror 协议</h3><p>Mirror 协议的实现方法非常的简单，它通过一个 mirrors.txt 的文件对提供的多个源地址进行封装，Apt 会根据 mirror.txt 文件中自动解析并确定最合理的源地址。 以下为官方提供的  mirrors.txt 文件内容示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirror.lzu.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.cqu.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.cn99.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.yun-idc.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.njupt.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;ftp.sjtu.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.nwafu.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.sohu.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;repository&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.nju.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.shu.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="使用-mirror-协议">使用 Mirror 协议</h3><p>要使用 Mirror 协议来进行多源更新的方法其实很简单，只需将 /etc/apt/sources.list 文件中的指定的软件源地址修改为使用 Mirror 协议的地址就可以了。这里以 Ubuntu 18.04 为例：</p><p>将如下软件源地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;cn.archive.ubuntu.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>修改为以下类似即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>这里提供一个完整的使用 Mirror 协议的 Ubuntu 18.04 的软件源配置文件，有需要的同学可以直接拿去用哟~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">###### Ubuntu Main Repos</span><br><span class="line">deb mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic main restricted universe multiverse</span><br><span class="line">deb-src mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">###### Ubuntu Update Repos</span><br><span class="line">deb mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-security main restricted universe multiverse</span><br><span class="line">deb mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-updates main restricted universe multiverse</span><br><span class="line">deb mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-security main restricted universe multiverse</span><br><span class="line">deb-src mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>当使用 Mirror 协议后，执行 Apt 相关操作时会首先访问 <a href="http://mirrors.ubuntu.com/mirrors.txt" target="_blank" rel="noopener">mirrors.ubuntu.com/mirrors.txt</a> 文本中所有的可用镜像地址，得到列表后 Apt 会自动选择一个速度最快的进行下载。官方还根据所在地区不同，提供指定国家的 mirror.txt。比如：中国可以设置为 <a href="http://mirrors.ubuntu.com/CN.txt%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E9%83%BD%E6%98%AF%E5%9B%BD%E5%86%85%E7%9A%84%E9%95%9C%E5%83%8F%E6%BA%90%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E9%95%9C%E5%83%8F%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E3%80%82" target="_blank" rel="noopener">mirrors.ubuntu.com/CN.txt，这样使用的都是国内的镜像源，就可以保证镜像源的访问速度。</a></p><p>使用 Mirror 协议后由于同时存在多个可用的镜像源地址，这样就可以很好的避免某个单一镜像源临时不可用的问题。</p><h3 id="自定义-mirror-地址">自定义 Mirror 地址</h3><p>由于官方提供的 mirrors.txt 中的镜像源地址包含了很多教育站点地址，这些地址可能有时访问速度并不是很快。这时我们可以根据需要自定义 mirror.txt 这个源列表，自定义可用的源列表的方法非常的简单，只需要开启一个标准的 HTTP Server 能返回 mirror.txt 这个文本即可。</p><p>mirrors.txt 中推荐优先选阿里云、网易、华为、清华大学等比较知名的镜像源地址，比如下面这些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;repository&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.yun-idc.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.cn99.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.sohu.com&#x2F;ubuntu&#x2F;</span><br></pre></td></tr></table></figure><h3 id="参考文档">参考文档</h3><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="http://t.cn/ExNkmSY" target="_blank" rel="noopener">http://t.cn/ExNkmSY</a></li><li><a href="http://t.cn/ExpvuQ6" target="_blank" rel="noopener">http://t.cn/ExpvuQ6</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知 Ubuntu 官方软件源访问速度一直都是比较慢的，通常情况下我们为了高效的通过软件源安装软件会使用国内的镜像源。国内虽然有很多可用的镜像源，但有时某些源偶尔也会出现访问故障(比如：清华、北大等镜像源)。出现这样情况的时候通常的解决方法就是更换一个可用的镜像源，但是如果涉及的机器特别多的时候就会非常的麻烦。&lt;/p&gt;
&lt;p&gt;难道这是一个无解的问题？当然不是，只能说你运气真好，来对了地方。你一定是上辈子拯救了银河系才有这样的好运，哈哈哈。其实 Apt 源是支持 Mirror 协议的，可以从多个镜像源中自动选择可用的一个。本文将介绍如何利用 Mirror 协议来解决类似问题。&lt;/p&gt;
&lt;h3 id=&quot;什么是-Mirror-协议&quot;&gt;什么是 Mirror 协议&lt;/h3&gt;
&lt;p&gt;Mirror 协议的实现方法非常的简单，它通过一个 mirrors.txt 的文件对提供的多个源地址进行封装，Apt 会根据 mirror.txt 文件中自动解析并确定最合理的源地址。 以下为官方提供的  mirrors.txt 文件内容示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.aliyun.com&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirror.lzu.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.cqu.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.cn99.com&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.yun-idc.com&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.njupt.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;ftp.sjtu.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.nwafu.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.sohu.com&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.huaweicloud.com&amp;#x2F;repository&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.ustc.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.nju.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.tuna.tsinghua.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.shu.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;archive.ubuntu.com&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Ubuntu" scheme="https://www.hi-linux.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>使用 Sealos 在 3 分钟内快速部署一个生产级别的 Kubernetes 高可用集群</title>
    <link href="https://www.hi-linux.com/posts/18971.html"/>
    <id>https://www.hi-linux.com/posts/18971.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.401Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>前段时间，我们在 ​「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247488666&amp;idx=1&amp;sn=de46a87cf59f8564ad75337b7c0cf7f6&amp;chksm=eac535b3ddb2bca5de2a923ec6cfa427e87f0135b31193efd1b904dff4c7b473f1dc9af82903&amp;token=212816651&amp;lang=zh_CN#rd" target="_blank" rel="noopener">使用 Kind 在 5 分钟内快速部署一个 Kubernetes 高可用集群</a>」一文中介绍了如何使用 <code>Kind</code> 这个开箱即可快速部署 <code>Kubernetes</code> 高可用集群的神器，相信不少同学用上这个神器后大大的降低了 <code>Kubernetes</code> 集群的部署难度和提高了 <code>Kubernetes</code> 集群的部署速度。不过有一点比较遗憾的是 <code>Kind</code> 当前仅仅支持在本地快速构建一个开发或者测试环境，目前暂时还是不支持在生产环境中部署 <code>Kubernetes</code> 高可用集群的。</p><p>今天，我们就要给大家介绍另一款可以支持在生产环境中部署 <code>Kubernetes</code> 高可用集群的利器 <code>Sealos</code>。</p><h2 id="什么是-sealos">什么是 Sealos ？</h2><p><code>Sealos</code> 是一个 Go 语言开发的简单干净且轻量的 <code>Kubernetes</code> 集群部署工具，<code>Sealos</code> 能很好的支持在生产环境中部署高可用的 <code>Kubernetes</code> 集群。</p><p><img src="https://raw.githubusercontent.com/fanux/sealos/master/arch.png" alt=""></p><p><code>Sealos</code> 架构图</p><p><strong>Sealos 特性与优势</strong></p><ol><li><p>支持离线安装，工具与部署资源包分离，方便不同版本间快速升级。</p></li><li><p>证书有效期默认延期至 99 年。</p></li><li><p>工具使用非常简单。</p></li><li><p>支持使用自定义配置文件，可灵活完成集群环境定制。</p></li><li><p>使用内核进行本地负载，稳定性极高，故障排查也极其简单。</p></li></ol><a id="more"></a><h2 id="sealos-设计原则和工作原理">Sealos 设计原则和工作原理</h2><h3 id="1-为什么不使用-ansilbe-实现">1. 为什么不使用 Ansilbe 实现</h3><p><code>Sealos 1.0</code> 版本时是使用 <code>Ansible</code> 实现的，这样在使用时就必须先安装 <code>Ansible</code> 及一些 <code>Python</code> 的依赖包和进行一些必须的相关环境配置，使用起来还是比较复杂的。</p><p>为了解决这个问题，目前新版本的 <code>Sealos</code> 采用二进制文件方式提供。新版本 <code>Sealos</code> 没有任何依赖，开箱即用。</p><blockquote><p>文件分发与远程命令都通过调用对应 <code>SDK</code> 实现，不依赖其它任何环境。</p></blockquote><h3 id="2-为什么不用-keepalived-和-haproxy-实现集群高可用">2. 为什么不用 KeepAlived 和 HAProxy 实现集群高可用</h3><p>无论是通过 <code>KeepAlived</code> 还是 <code>HAProxy</code> 进行高可用集群调度都会存在以下一些劣势。</p><ol><li><p>软件源不一致可能导致容器中安装的软件版本也不一致，进而会引起相应检查脚本不生效等故障。</p></li><li><p>可能因为系统依赖库问题，在某些特定环境下就直接无法完成安装。</p></li><li><p>只依靠检测 <code>HAProxy</code> 进程是否存活是无法保证集群高可用的，正确的检测方式应该是判断 <code>ApiServer</code> 是否 <code>healthz</code> 状态。</p></li><li><p><code>Keepalived</code> 可能存在 <code>Cpu</code> 占满的情况。</p></li></ol><h3 id="3-本地负载为什么不使用-envoy-或者-nginx-实现">3. 本地负载为什么不使用 Envoy 或者 Nginx 实现</h3><p><code>Sealos</code> 高可用实现是通过本地负载方式完成的。本地负载实现方式有多种，比如：<code>IPVS</code>、<code>Envoy</code>、<code>Nginx</code> 等，而 <code>Sealos</code> 采用的是通过内核  <code>IPVS</code> 来实现的。</p><blockquote><p>本地负载：在每个 <code>Node</code> 节点上都启动一个负载均衡，同时监听集群中的多个 <code>Master</code> 节点。</p></blockquote><p><code>Sealos</code> 选择通过内核 <code>IPVS</code> 来实现主要有以下几个原因：</p><ul><li><p>如果使用 <code>Envoy</code> 等需要在每个节点上都跑一个进程，消耗更多资源。虽然 <code>IPVS</code> 实际上也会多跑一个 <code>lvscare</code> 进程 ，但是 <code>lvscare</code> 只是负责管理 <code>IPVS</code> 规则，原理和 <code>Kube-Proxy</code>类似。真正的流量直接从内核层面走，不需要把数据包先走到用户态中去处理。</p></li><li><p>使用 <code>Envoy</code> 存在启动优先级的问题，比如：Join 集群时，如果负载均衡没有建立，Kubelet 就会启动失败。使用 <code>IPVS</code> 则不会存在这样的问题，因为我们可以在 Join 集群前先建立好转发规则。</p></li></ul><p><strong>3.1 本地内核负载工作原理</strong></p><p><code>Sealos</code> 通过本地内核负载的方式实现每个 <code>Node</code> 节点负载均衡访问所有 <code>Master</code> 节点，具体参见下图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+----------+                       +---------------+  virturl server: 127.0.0.1:6443</span><br><span class="line">| mater0   |&lt;----------------------| ipvs nodes    |    real servers:</span><br><span class="line">+----------+                      |+---------------+            10.103.97.200:6443</span><br><span class="line">                                  |                             10.103.97.201:6443</span><br><span class="line">+----------+                      |                             10.103.97.202:6443</span><br><span class="line">| mater1   |&lt;---------------------+</span><br><span class="line">+----------+                      |</span><br><span class="line">                                  |</span><br><span class="line">+----------+                      |</span><br><span class="line">| mater2   |&lt;---------------------+</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure><p>在所有 <code>Node</code> 节点上启动一个包含 <code>lvscare</code> 进程的 <code>Static Pod</code> 对 <code>IPVS</code> 进行守护。 如果检测到 <code>ApiServer</code> 不可用时，<code>Sealos</code> 会自动清理掉所有 <code>Node</code> 节点上对应的主节点 <code>IPVS</code> 转发规则。直到 <code>Master</code> 节点恢复正常时，再自动生成对应规则。为了实现以上功能，我们在 <code>Node</code> 节点上增加了下面这些内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 增加了一个 lvscare 的 Static Pod</span><br><span class="line">$ cat &#x2F;etc&#x2F;kubernetes&#x2F;manifests</span><br><span class="line"></span><br><span class="line"># 自动创建的一些 IPVS 规则</span><br><span class="line">$ ipvsadm -Ln            </span><br><span class="line"></span><br><span class="line"># 增加了对虚拟 IP 的地址解析</span><br><span class="line">$ cat &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><h3 id="4-为什么要定制-kubeadm">4. 为什么要定制 Kubeadm</h3><ul><li><p>解决默认证书有效期只有一年的问题。</p></li><li><p>更方便的实现本地负载。</p></li><li><p>核心的功能均集成到 Kubeadm 中了，Sealos 只管分发和执行上层命令，相对就更轻量了。</p></li></ul><h3 id="5-sealos-执行流程">5. Sealos 执行流程</h3><ol><li><p>通过 <code>SFTP</code> 或者 <code>Wget</code> 命令把离线安装包拷贝到目标机器上，包括所有 <code>Master</code> 和 <code>Node</code> 节点。</p></li><li><p>在 <code>Master 0</code> 节点上执行 <code>kubeadm init</code> 命令。</p></li><li><p>在其它 <code>Master</code> 节点上执行 <code>kubeadm join</code> 命令并设置控制面。这个过程中多个 <code>Master</code> 节点上的 <code>Etcd</code> 会自动组成一个 <code>Etcd</code> 集群，并启动相应控制组件。</p></li><li><p>所有 <code>Node</code> 节点都加入到集群中，这个过程中会在 <code>Node</code> 节点上进行 <code>IPVS</code> 转发规则和 <code>/etc/hosts</code> 配置。</p></li></ol><blockquote><p><code>Node</code> 节点对 <code>ApiServer</code> 的访问均是通过域名进行的。因为 <code>Node</code> 节点需要通过 <code>虚拟 IP</code> 连接到多个 <code>Master</code> 上，但是每个 <code>Node</code> 节点的 <code>Kubelet</code> 与 <code>Kube-Proxy</code> 访问 <code>ApiServer</code> 的地址是不同的，所以这里使用域名来解析每个节点上 <code>ApiServer</code> 不同的 <code>IP</code> 地址。</p></blockquote><h2 id="使用-sealos-部署高可用-kubernetes-集群">使用 Sealos 部署高可用 Kubernetes 集群</h2><h3 id="1-安装相关环境依赖">1. 安装相关环境依赖</h3><p>通过 <code>Sealos</code> 进行 <code>Kubernetes</code> 集群部署，你需要先准备好以下环境。</p><ol><li><p>在所有要部署的机器上，先完成 <code>Docker</code> 的安装和启动。</p></li><li><p>下载 <code>Kubernetes</code> 离线安装包。</p></li><li><p>下载最新版本 <code>Sealos</code>。</p></li><li><p>对所有服务器进行时间同步。</p></li></ol><blockquote><p>Sealos 项目地址：<a href="https://github.com/fanux/sealos/releases" target="_blank" rel="noopener">https://github.com/fanux/sealos/releases</a></p><p>Kubernetes 离线安装包：<a href="https://github.com/sealstore/cloud-kernel/releases/" target="_blank" rel="noopener">https://github.com/sealstore/cloud-kernel/releases/</a></p></blockquote><h3 id="2-通过-sealos-部署高可用-kubernetes-集群">2. 通过 Sealos 部署高可用 Kubernetes 集群</h3><p>目前 <code>Sealos</code> 已经支持最新版本 <code>Kubernetes 1.16.0</code> 的高可用集群安装。</p><h4 id="21-sealos-常用参数说明">2.1 Sealos 常用参数说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--master   Master 节点服务器地址列表</span><br><span class="line">--node     Node 节点服务器地址列表</span><br><span class="line">--user     服务器 SSH 用户名</span><br><span class="line">--passwd   服务器 SSH 用户密码</span><br><span class="line">--pkg-url  离线包所在位置，可以是本地目录，也可以是一个 HTTP 地址</span><br><span class="line">--version  指定需要部署的 Kubernetes 版本</span><br><span class="line">--pk       指定 SSH 私钥所在位置，默认为 &#x2F;root&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line"></span><br><span class="line">Other flags:</span><br><span class="line"></span><br><span class="line"> --kubeadm-config string   kubeadm-config.yaml 用于指定自定义 kubeadm 配置文件</span><br><span class="line"> --vip string              virtual ip (default &quot;10.103.97.2&quot;) 本地负载时虚拟 IP ，不推荐修改，集群外不可访问</span><br></pre></td></tr></table></figure><h4 id="22-部署一个单主节点的-kubernetes-集群">2.2 部署一个单主节点的 Kubernetes 集群</h4><p>通过 <code>Sealos</code> 部署 <code>Kubernetes</code> 集群是非常简单的 ，通常只需以下两条指令就可以完成安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;fanux&#x2F;sealos&#x2F;releases&#x2F;download&#x2F;v2.0.7&#x2F;sealos &amp;&amp; \</span><br><span class="line">    chmod +x sealos &amp;&amp; mv sealos &#x2F;usr&#x2F;bin </span><br><span class="line"></span><br><span class="line">$ sealos init --passwd YOUR_SERVER_PASSWD \</span><br><span class="line">--master 192.168.0.2  --master 192.168.0.3  --master 192.168.0.4  \</span><br><span class="line">--node 192.168.0.5 \</span><br><span class="line">--pkg-url https:&#x2F;&#x2F;sealyun.oss-cn-beijing.aliyuncs.com&#x2F;cf6bece970f6dab3d8dc8bc5b588cc18-1.16.0&#x2F;kube1.16.0.tar.gz \</span><br><span class="line">--version v1.16.0</span><br></pre></td></tr></table></figure><p>如果你的服务器已经配置了 <code>SSH</code> 免密登陆，你可以直接使用对应密钥进行部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sealos init --master 192.168.0.2 \</span><br><span class="line">    --node 192.168.0.3 \</span><br><span class="line">    --pkg-url https:&#x2F;&#x2F;YOUR_HTTP_SERVER&#x2F;kube1.15.0.tar.gz \</span><br><span class="line">    --pk &#x2F;root&#x2F;kubernetes.pem \</span><br><span class="line">    --version v1.16.0</span><br></pre></td></tr></table></figure><p>如果你需要其它 <code>Kubernetes</code> 版本离线包，可到 <code>Sealos</code> 官网 <a href="http://store.lameleg.com/" target="_blank" rel="noopener">http://store.lameleg.com/</a> 进行下载。</p><h4 id="23-部署一个多主节点的高可用-kubernetes-集群">2.3 部署一个多主节点的高可用 Kubernetes 集群</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sealos init --master 192.168.0.2 \</span><br><span class="line">    --master 192.168.0.3 \</span><br><span class="line">    --master 192.168.0.4 \</span><br><span class="line">    --node 192.168.0.5 \</span><br><span class="line">    --user root \</span><br><span class="line">    --passwd your-server-password \</span><br><span class="line">    --version v1.16.0 \</span><br><span class="line">    --pkg-url &#x2F;root&#x2F;kube1.16.0.tar.gz</span><br></pre></td></tr></table></figure><h4 id="24-验证部署是否成功">2.4 验证部署是否成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get node</span><br><span class="line">NAME                      STATUS   ROLES    AGE     VERSION</span><br><span class="line">izj6cdqfqw4o4o9tc0q44rz   Ready    master   2m25s   v1.16.0</span><br><span class="line">izj6cdqfqw4o4o9tc0q44sz   Ready    master   119s    v1.16.0</span><br><span class="line">izj6cdqfqw4o4o9tc0q44tz   Ready    master   63s     v1.16.0</span><br><span class="line">izj6cdqfqw4o4o9tc0q44uz   Ready    &lt;none&gt;   38s     v1.16.0</span><br><span class="line"></span><br><span class="line">$ kubectl get pod --all-namespaces</span><br><span class="line">NAMESPACE     NAME                                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   calico-kube-controllers-5cbcccc885-9n2p8          1&#x2F;1     Running   0          3m1s</span><br><span class="line">kube-system   calico-node-656zn                                 1&#x2F;1     Running   0          93s</span><br><span class="line">kube-system   calico-node-bv5hn                                 1&#x2F;1     Running   0          2m54s</span><br><span class="line">kube-system   calico-node-f2vmd                                 1&#x2F;1     Running   0          3m1s</span><br><span class="line">kube-system   calico-node-tbd5l                                 1&#x2F;1     Running   0          118s</span><br><span class="line">kube-system   coredns-fb8b8dccf-8bnkv                           1&#x2F;1     Running   0          3m1s</span><br><span class="line">kube-system   coredns-fb8b8dccf-spq7r                           1&#x2F;1     Running   0          3m1s</span><br><span class="line">kube-system   etcd-izj6cdqfqw4o4o9tc0q44rz                      1&#x2F;1     Running   0          2m25s</span><br><span class="line">kube-system   etcd-izj6cdqfqw4o4o9tc0q44sz                      1&#x2F;1     Running   0          2m53s</span><br><span class="line">kube-system   etcd-izj6cdqfqw4o4o9tc0q44tz                      1&#x2F;1     Running   0          118s</span><br><span class="line">kube-system   kube-apiserver-izj6cdqfqw4o4o9tc0q44rz            1&#x2F;1     Running   0          2m15s</span><br><span class="line">kube-system   kube-apiserver-izj6cdqfqw4o4o9tc0q44sz            1&#x2F;1     Running   0          2m54s</span><br><span class="line">kube-system   kube-apiserver-izj6cdqfqw4o4o9tc0q44tz            1&#x2F;1     Running   1          47s</span><br><span class="line">kube-system   kube-controller-manager-izj6cdqfqw4o4o9tc0q44rz   1&#x2F;1     Running   1          2m43s</span><br><span class="line">kube-system   kube-controller-manager-izj6cdqfqw4o4o9tc0q44sz   1&#x2F;1     Running   0          2m54s</span><br><span class="line">kube-system   kube-controller-manager-izj6cdqfqw4o4o9tc0q44tz   1&#x2F;1     Running   0          63s</span><br><span class="line">kube-system   kube-proxy-b9b9z                                  1&#x2F;1     Running   0          2m54s</span><br><span class="line">kube-system   kube-proxy-nf66n                                  1&#x2F;1     Running   0          3m1s</span><br><span class="line">kube-system   kube-proxy-q2bqp                                  1&#x2F;1     Running   0          118s</span><br><span class="line">kube-system   kube-proxy-s5g2k                                  1&#x2F;1     Running   0          93s</span><br><span class="line">kube-system   kube-scheduler-izj6cdqfqw4o4o9tc0q44rz            1&#x2F;1     Running   1          2m43s</span><br><span class="line">kube-system   kube-scheduler-izj6cdqfqw4o4o9tc0q44sz            1&#x2F;1     Running   0          2m54s</span><br><span class="line">kube-system   kube-scheduler-izj6cdqfqw4o4o9tc0q44tz            1&#x2F;1     Running   0          61s</span><br><span class="line">kube-system   kube-sealyun-lvscare-izj6cdqfqw4o4o9tc0q44uz      1&#x2F;1     Running   0          86s</span><br></pre></td></tr></table></figure><h4 id="25-最简单粗暴的视频教程">2.5 最简单粗暴的视频教程</h4><p>如果你觉得上面的教程还是不够直观，现在就给你一个更简单粗暴的学习方式。猛击<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247488905&amp;idx=1&amp;sn=c42f9baeb1a48970ded0f42a520c91a5&amp;chksm=eac534a0ddb2bdb6cb072ec6e2ba60cf53a5447d7f36aa8e8b6a48ca9877ab82837213252133&amp;token=2039868521&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>的视频，开始吧！</p><h4 id="26-升级-kubernetes-集群版本">2.6 升级 Kubernetes 集群版本</h4><p><code>Kubernetes</code> 集群目前处于一个高速迭代期，每个新版本的发布都提供了不少新的特性。升级 <code>Kubernetes</code> 集群版本也就成了家常便饭，<code>Sealos</code> 也为大家提供非常方便的功能来帮助大家快速完成 <code>Kubernetes</code> 集群升级。<code>Kubernetes</code> 集群升级大致需要以下几个步骤：</p><ol><li><p>升级所有节点的 <code>Kubeadm</code> 并导入新的镜像。</p></li><li><p>升级 <code>Master</code> 节点上的 <code>Kubelet</code>。</p></li><li><p>升级其它 <code>Master</code> 节点。</p></li><li><p>升级 <code>Node</code> 节点。</p></li><li><p>验证集群状态。</p></li></ol><p><strong>2.6.1 升级 Kubeadm</strong></p><p>这一步主要用于更新 <code>Kubeadm</code>、<code>Kubectl</code>、<code>Kubelet</code> 等二进制文件，并导入新版本的镜像。升级方法很简单，只需复制离线包到所有节点并执行以下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd kube&#x2F;shell &amp;&amp; sh init.sh</span><br></pre></td></tr></table></figure><p><strong>2.6.2 升级 Master 节点上的 Kubelet</strong></p><p>升级 <code>Kubelet</code> 还是很简单的，只需要把新版本的 <code>Kubelet</code> 复制到 <code>/usr/bin</code> 目录下替换旧版本，然后重启 <code>Kubelet</code> 服务即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm upgrade plan</span><br><span class="line">$ kubeadm upgrade apply v1.16.0</span><br><span class="line"></span><br><span class="line"># 重启 Kubelet</span><br><span class="line">$ systemctl restart kubelet</span><br></pre></td></tr></table></figure><p>其中最重要的 <code>kubeadm upgrade apply</code> 命令主要完成以下一些操作。</p><ul><li><p>验证集群是否可升级并执行版本升级策略。</p></li><li><p>确认离线包中相关镜像是否可用。</p></li><li><p>对控制组件的容器进行升级，失败就回滚。</p></li><li><p>对 <code>Kube-DNS</code> 和 <code>Kube-Proxy</code> 进行升级。</p></li><li><p>创建新的证书文件并备份旧的证书文件。</p></li></ul><p><strong>2.6.3 升级其它 Master 节点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm upgrade apply</span><br></pre></td></tr></table></figure><p><strong>2.6.4 升级 Node 节点</strong></p><p>升级 <code>Node</code> 节点前，首先要驱逐节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl drain $NODE --ignore-daemonsets</span><br></pre></td></tr></table></figure><p>其次，是更新 <code>Kubelet</code> 的配置文件和升级 <code>Node</code> 节点的 <code>Kubelet</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm upgrade node config --kubelet-version v1.16.0</span><br><span class="line"></span><br><span class="line"># 同样是替换二进制文件并重启 Kubelet</span><br><span class="line">$ systemctl restart kubelet</span><br></pre></td></tr></table></figure><p>最后，恢复 <code>Node</code> 节点为可调度状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl uncordon $NODE</span><br></pre></td></tr></table></figure><p><strong>2.6.5 验证集群是否升级成功</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br></pre></td></tr></table></figure><p>如果输出的节点的版本信息是和升级的版本一致的话，一切就搞定了！</p><h3 id="3-集群清理">3. 集群清理</h3><p>如果你需要快速清理已部署的 <code>Kubernetes</code> 集群环境，你可以使用下面的命令快速完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sealos clean \</span><br><span class="line">    --master 192.168.0.2 \</span><br><span class="line">    --master 192.168.0.3 \</span><br><span class="line">    --master 192.168.0.4 \</span><br><span class="line">    --node 192.168.0.5 \</span><br><span class="line">    --user root \</span><br><span class="line">    --passwd your-server-password</span><br></pre></td></tr></table></figure><p>至此，使用 <code>Sealos</code> 快速部署一个生产级别的 <code>Kubernetes</code> 高可用集群的基本方法就介绍完了。如果你对 <code>Sealos</code> 非常的感兴趣，你还可以去官网探索更多高级功能哟！</p><p>对于在生产环境中快速部署 <code>Kubernetes</code> 高可用集群，你还有哪些更好用高效的方法呢？欢迎大家在留言讨论哟！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间，我们在 ​「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247488666&amp;amp;idx=1&amp;amp;sn=de46a87cf59f8564ad75337b7c0cf7f6&amp;amp;chksm=eac535b3ddb2bca5de2a923ec6cfa427e87f0135b31193efd1b904dff4c7b473f1dc9af82903&amp;amp;token=212816651&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用 Kind 在 5 分钟内快速部署一个 Kubernetes 高可用集群&lt;/a&gt;」一文中介绍了如何使用 &lt;code&gt;Kind&lt;/code&gt; 这个开箱即可快速部署 &lt;code&gt;Kubernetes&lt;/code&gt; 高可用集群的神器，相信不少同学用上这个神器后大大的降低了 &lt;code&gt;Kubernetes&lt;/code&gt; 集群的部署难度和提高了 &lt;code&gt;Kubernetes&lt;/code&gt; 集群的部署速度。不过有一点比较遗憾的是 &lt;code&gt;Kind&lt;/code&gt; 当前仅仅支持在本地快速构建一个开发或者测试环境，目前暂时还是不支持在生产环境中部署 &lt;code&gt;Kubernetes&lt;/code&gt; 高可用集群的。&lt;/p&gt;
&lt;p&gt;今天，我们就要给大家介绍另一款可以支持在生产环境中部署 &lt;code&gt;Kubernetes&lt;/code&gt; 高可用集群的利器 &lt;code&gt;Sealos&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Sealos-？&quot;&gt;什么是 Sealos ？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Sealos&lt;/code&gt; 是一个 Go 语言开发的简单干净且轻量的 &lt;code&gt;Kubernetes&lt;/code&gt; 集群部署工具，&lt;code&gt;Sealos&lt;/code&gt; 能很好的支持在生产环境中部署高可用的 &lt;code&gt;Kubernetes&lt;/code&gt; 集群。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fanux/sealos/master/arch.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sealos&lt;/code&gt; 架构图&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sealos 特性与优势&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;支持离线安装，工具与部署资源包分离，方便不同版本间快速升级。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;证书有效期默认延期至 99 年。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工具使用非常简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持使用自定义配置文件，可灵活完成集群环境定制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用内核进行本地负载，稳定性极高，故障排查也极其简单。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>推荐几个不追踪隐私的搜索引擎</title>
    <link href="https://www.hi-linux.com/posts/392.html"/>
    <id>https://www.hi-linux.com/posts/392.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.402Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>毫无疑问，在中文搜索领域，「百度」独占鳌头。但众所周知，至少在目前，与「百度」这个浪漫的命名截然相反的是，百度是个口碑极其糟糕的产品。但是对于大多数的用户，彻底避免使用「百度」是一件较为困难的事情。</p><p><strong>为什么不用「Google 搜索」？</strong></p><p>因为谷歌的商业模式决定了它需要收集用户隐私，当然更重要的是你在国内也是不可用的。</p><p><strong>为什么不用「百度搜索」？</strong></p><p>没有为什么，谁用谁知道百度是什么。</p><p><strong>为什么不用「 DuckDuckGo」？</strong></p><p>因为在国内同样不可用，没有其它了。</p><blockquote><p>DuckDuckGo 是一款互联网搜索引擎，其注重用户隐私以及避免个性化检索所致的过滤气泡。它与其它搜索引擎不同的地方在于其不会分析自己的用户、对所有使用同一组关键词的用户显示同样的结果。它也强调返回最佳结果，而不是最多网站链接之结果。</p></blockquote><p><strong>为什么不用其它的主流搜索引擎？</strong></p><p>必应、搜狗等搜索引擎不但也会收集用户隐私，而搜索结果也不尽如人意。</p><p>在这样的大环境下，寻找百度替代品一直是很多用户所关注的事情。因此，也应运而生了很多优秀的搜索引擎产品，今天就给大家推荐几款清爽、简洁、快速、无广告且不收集个人隐私的搜索引擎产品。</p><a id="more"></a><h2 id="多吉搜索">多吉搜索</h2><p>DogeDoge，又称多吉搜索，是国内一款个人开发者主导的搜索引擎产品，宗旨是不追踪用户隐私，不误导用户。多吉搜索的愿景是做中国的 DuckDuckGo，成为百度的替代方案之一。</p><p>多吉搜索有着极简的页面设计风格，没有热门文章推荐、没有热点新闻推送，搜索结果不添加任何广告，只专注于搜索本身！一句话形容就是 “高效、纯粹” 。</p><p>官网地址：<a href="https://dogedoge.com" target="_blank" rel="noopener">https://dogedoge.com</a></p><p><img src="https://i.loli.net/2019/08/05/rqadoExhT8uYV6J.png" alt=""></p><p>除了网页搜索之外，目前多吉搜索也支持部分即时结果 (Instant Result)，比如查询 IP、汇率转换等等。未来可能还会增加一些诸如：技术文档、天气查询、节气查询、热门人物、景点、影视等等功能。</p><p><img src="https://i.loli.net/2019/08/05/UKe7nsYo2jvwTaH.jpg" alt=""></p><h2 id="秘迹搜索">秘迹搜索</h2><p>秘迹搜索一个是基于开源项目 Searx 进行二次开发的可以保护个人隐私的网络搜索服务。</p><p>因为 Searx 采用的开源协议是 AGPL-3.0，所以秘迹搜索也严格遵守这一开源协议，秘迹搜索所有的改动也是完全开源的。如果你对网络隐私防护感兴趣也可以加入开发和维护中，其项目地址是：<a href="https://github.com/entropage/mijisou" target="_blank" rel="noopener">https://github.com/entropage/mijisou</a> 。</p><p>官网地址：<a href="https://mijisou.com/" target="_blank" rel="noopener">https://mijisou.com/</a></p><p><img src="https://i.loli.net/2019/08/06/WHuPLmAb26Yy9cT.png" alt=""></p><h3 id="秘迹搜索工作原理">秘迹搜索工作原理</h3><p>当一个用户使用秘迹搜索的时候:</p><ol><li>使用浏览器打开 <a href="https://mijisou.com" target="_blank" rel="noopener">https://mijisou.com</a>，输入查询关键字。</li><li>发起的网络请求传递到秘迹搜索的服务器上。但是秘迹搜索的服务器没有记录用户的任何信息(不光没有记录用户输入的检索词，从用户浏览器中带过来的 IP 地址、UserAgent、HTTP Header等信息，也统统没有记录)。</li><li>最后，秘迹搜索将结果数据返回给用户的浏览器。</li></ol><p><img src="https://i.loli.net/2019/08/06/ZS7oY6WBlgpKAJM.png" alt=""></p><p>秘迹搜索没有存储任何的用户信息，也没有使用任何追踪用户的黑科技(tracking scripts, tracking pixels, tracking tags)，甚至连浏览器 Cookie 都没有使用, 也就自然不会泄漏用户的隐私信息了。</p><h3 id="秘迹搜索特色功能">秘迹搜索特色功能</h3><ol><li>提供聚合和过滤功能</li></ol><p>秘迹搜索的结果聚合了各种搜索引擎的检索结果，并在后台帮助用户过滤掉一切追踪脚本和可以过滤掉的广告信息，最终提供给用户的都是干净的结果信息。</p><p><img src="https://i.loli.net/2019/08/06/Bh5gLKIX3exTDPz.png" alt=""></p><ol start="2"><li>提供匿名访问功能</li></ol><p>除了提供搜索服务外，秘迹搜索对于检索到的结果还提供匿名访问功能，见下图所示。</p><p><img src="https://i.loli.net/2019/08/06/iEgTqufB8zLkP7Y.png" alt=""></p><p>匿名访问功能本质上是一个代理服务，比如你想访问秘迹搜索结果页中的 <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a> 网站，如果通过匿名访问来浏览, 我们会通过代理服务 <a href="http://proxy.mijisou.com" target="_blank" rel="noopener">proxy.mijisou.com</a> 去获得 <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a> 网站上的有用信息，然后再把有用信息中转展示给用户。</p><blockquote><p>该代理服务是秘迹的独立服务，不会记录任何请求日志，会完全保护用户免受各种追踪和骚扰。</p></blockquote><h2 id="萌搜">萌搜</h2><p>萌搜致力于打造一款无色情、无暴力、不涉政的绿色搜索引擎，对色情内容、涉政内容等做过高度严格的完全过滤。</p><p>萌搜主要是针对技术领域的问题进行深度优化；编程程领域建议使用纯英文进行查找。</p><p>官网地址：<a href="https://mengso.com/" target="_blank" rel="noopener">https://mengso.com/</a></p><p><img src="https://i.loli.net/2019/08/06/l9q8cs5VbTAguSh.png" alt=""></p><blockquote><p>关于隐私方面，萌搜会记录您搜索的关键词。有两点原因：一是为了优化语料库；二是因为监管层需求。</p></blockquote><h2 id="如何设置成浏览器默认搜索引擎">如何设置成浏览器默认搜索引擎？</h2><p>以 Chrome 为例：一般情况下，在搜索引擎中搜索过一次以后，就能在 Chrome 的偏好设置的搜索引擎设置中选择对应搜索引擎，然后设置为默认搜索引擎即可。</p><p>当然也可以自定义添加搜索字符串，下面我们以设置多吉搜索为例：</p><ol><li>在浏览器地址栏输入 <code>chrome://settings/searchEngines</code> 打开浏览器默认搜索引擎设置界面。</li><li>输入对应搜索引擎的搜索字符串即可。</li></ol><ul><li>多吉搜索字符串：<a href="https://dogedoge.com/results?q=%25s" target="_blank" rel="noopener">https://dogedoge.com/results?q=%s</a></li><li>秘迹搜索字符串：<a href="https://mijisou.com/search?q=%25s" target="_blank" rel="noopener">https://mijisou.com/search?q=%s</a></li><li>萌搜搜索字符串：<a href="https://mengso.com/search?q=%25s" target="_blank" rel="noopener">https://mengso.com/search?q=%s</a></li></ul><p><img src="https://i.loli.net/2019/08/05/GHTqPLaf2iZ974w.png" alt=""></p><p>如果你有更好用的不追踪隐私的搜索引擎推荐，请在评论区留言分享出来吧！</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="https://liulanmi.com/zt/13243.html" target="_blank" rel="noopener">https://liulanmi.com/zt/13243.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/54285064" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54285064</a></li><li><a href="https://www.ugediao.com/dogedoge-chinese-search-engine.html" target="_blank" rel="noopener">https://www.ugediao.com/dogedoge-chinese-search-engine.html</a></li><li><a href="https://zhuanfou.com/article/77813574_063" target="_blank" rel="noopener">https://zhuanfou.com/article/77813574_063</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毫无疑问，在中文搜索领域，「百度」独占鳌头。但众所周知，至少在目前，与「百度」这个浪漫的命名截然相反的是，百度是个口碑极其糟糕的产品。但是对于大多数的用户，彻底避免使用「百度」是一件较为困难的事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不用「Google 搜索」？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为谷歌的商业模式决定了它需要收集用户隐私，当然更重要的是你在国内也是不可用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不用「百度搜索」？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没有为什么，谁用谁知道百度是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不用「 DuckDuckGo」？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为在国内同样不可用，没有其它了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DuckDuckGo 是一款互联网搜索引擎，其注重用户隐私以及避免个性化检索所致的过滤气泡。它与其它搜索引擎不同的地方在于其不会分析自己的用户、对所有使用同一组关键词的用户显示同样的结果。它也强调返回最佳结果，而不是最多网站链接之结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么不用其它的主流搜索引擎？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;必应、搜狗等搜索引擎不但也会收集用户隐私，而搜索结果也不尽如人意。&lt;/p&gt;
&lt;p&gt;在这样的大环境下，寻找百度替代品一直是很多用户所关注的事情。因此，也应运而生了很多优秀的搜索引擎产品，今天就给大家推荐几款清爽、简洁、快速、无广告且不收集个人隐私的搜索引擎产品。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款轻量级 HTTP(S) 代理 TinyProxy</title>
    <link href="https://www.hi-linux.com/posts/15200.html"/>
    <id>https://www.hi-linux.com/posts/15200.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.403Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，我们常用的 <code>Web</code> 服务器 <code>Nginx</code> / <code>Apache</code> 都可以很方便的用来做为正向或反向代理服务器使用。但是它们都并不支持 <code>HTTPS</code> 的正向代理。</p><blockquote><p>Nginx 做为正向代理不支持 HTTPS 的原因是因为 Nginx 没有实现 HTTP 1.1 Connect 方法。隧道的含义大约就是帮助无法完成 TLS 握手的代理服务器透传可以完成 TLS 握手的客户端请求，而不再解析流量中的内容。</p></blockquote><p>关于 Connect 和 隧道技术，可详见以下文章：</p><ul><li><p>RFC 2817 （<a href="http://t.cn/EaoC0qf%EF%BC%89" target="_blank" rel="noopener">http://t.cn/EaoC0qf）</a></p></li><li><p>什么是 HTTP 隧道，怎么理解 HTTP 隧道呢？ （<a href="http://t.cn/EaoCveH%EF%BC%89" target="_blank" rel="noopener">http://t.cn/EaoCveH）</a></p></li></ul><p>今天我们来介绍一款同时支持 <code>HTTP/HTTPS</code> 的轻量级代理软件 <code>TinyProxy</code>，<code>TinyProxy</code> 支持以下功能特性：</p><ul><li>支持匿名模式。</li><li>支持 HTTPS，可以通过 CONNECT 请求来转发 HTTPS 连接。</li><li>远程监视：可远程查看日志和访问信息。</li><li>负载监视：可配置成当负载达到某个程度时，拒绝新的代理请求。</li><li>访问控制：可设置特定的 IP 地址或者 IP 段才可访问。</li><li>安全：不需要 root 权限。</li><li>轻量化：只需要极小的系统资源。</li><li>支持基于 URL 的过滤。</li><li>支持透明代理。</li><li>支持多级代理。</li></ul><p>TinyProxy 项目地址：<a href="https://github.com/tinyproxy/tinyproxy" target="_blank" rel="noopener">https://github.com/tinyproxy/tinyproxy</a></p><h3 id="安装-tinyproxy">安装 TinyProxy</h3><ol><li>通过软件包安装</li></ol><p><code>TinyProxy</code> 目前已支持大多数发行版通过软件包安装，下面介绍下比较常用的几个平台的安装方式。</p><ul><li>CentOS / RHEL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 需要 EPEL 仓库</span><br><span class="line">$ yum install -y tinyproxy</span><br></pre></td></tr></table></figure><ul><li>Ubuntu / Debian</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get -y install tinyproxy</span><br></pre></td></tr></table></figure><p>如果你使用的是其它平台，更多的安装方式可直接参考官方文档：<a href="https://tinyproxy.github.io/" target="_blank" rel="noopener">https://tinyproxy.github.io/</a></p><ol start="2"><li>通过源码安装</li></ol><p>如果你使用的平台，官方还不支持通过软件包安装。你也可以通过源码进行编译安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;tinyproxy&#x2F;tinyproxy.git</span><br><span class="line">$ cd tinyproxy</span><br><span class="line">$ .&#x2F;autogen.sh</span><br><span class="line">$ .&#x2F;configure</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="配置-tinyproxy">配置 TinyProxy</h3><p><code>TinyProxy</code> 默认配置文件路径为 <code>/etc/tinyproxy/tinyproxy.conf​</code>。如果你要自定义配置文件位置，可以在启动 <code>TinyProxy</code> 时 通过 <code>-c</code> 参数来指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;tinyproxy&#x2F;tinyproxy.conf​</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## tinyproxy.conf -- tinyproxy daemon configuration file</span><br><span class="line">##</span><br><span class="line">## This example tinyproxy.conf file contains example settings</span><br><span class="line">## with explanations in comments. For decriptions of all</span><br><span class="line">## parameters, see the tinproxy.conf(5) manual page.</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># User&#x2F;Group: This allows you to set the user and group that will be</span><br><span class="line"># used for tinyproxy after the initial binding to the port has been done</span><br><span class="line"># as the root user. Either the user or group name or the UID or GID</span><br><span class="line"># number may be used.</span><br><span class="line">#</span><br><span class="line">User nobody</span><br><span class="line">Group nobody</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Port: Specify the port which tinyproxy will listen on.  Please note</span><br><span class="line"># that should you choose to run on a port lower than 1024 you will need</span><br><span class="line"># to start tinyproxy using root.</span><br><span class="line">#</span><br><span class="line">Port 8888</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Listen: If you have multiple interfaces this allows you to bind to</span><br><span class="line"># only one. If this is commented out, tinyproxy will bind to all</span><br><span class="line"># interfaces present.</span><br><span class="line">#</span><br><span class="line"># Listen 192.168.0.1</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Bind: This allows you to specify which interface will be used for</span><br><span class="line"># outgoing connections.  This is useful for multi-home&#39;d machines where</span><br><span class="line"># you want all traffic to appear outgoing from one particular interface.</span><br><span class="line">#</span><br><span class="line">#Bind 192.168.0.1</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># BindSame: If enabled, tinyproxy will bind the outgoing connection to the</span><br><span class="line"># ip address of the incoming connection.</span><br><span class="line">#</span><br><span class="line">#BindSame yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Timeout: The maximum number of seconds of inactivity a connection is</span><br><span class="line"># allowed to have before it is closed by tinyproxy.</span><br><span class="line">#</span><br><span class="line">Timeout 600</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># ErrorFile: Defines the HTML file to send when a given HTTP error</span><br><span class="line"># occurs.  You will probably need to customize the location to your</span><br><span class="line"># particular install.  The usual locations to check are:</span><br><span class="line">#   &#x2F;usr&#x2F;local&#x2F;share&#x2F;tinyproxy</span><br><span class="line">#   &#x2F;usr&#x2F;share&#x2F;tinyproxy</span><br><span class="line">#   &#x2F;etc&#x2F;tinyproxy</span><br><span class="line">#</span><br><span class="line">#ErrorFile 404 &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;404.html&quot;</span><br><span class="line">#ErrorFile 400 &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;400.html&quot;</span><br><span class="line">#ErrorFile 503 &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;503.html&quot;</span><br><span class="line">#ErrorFile 403 &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;403.html&quot;</span><br><span class="line">#ErrorFile 408 &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;408.html&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># DefaultErrorFile: The HTML file that gets sent if there is no</span><br><span class="line"># HTML file defined with an ErrorFile keyword for the HTTP error</span><br><span class="line"># that has occured.</span><br><span class="line">#</span><br><span class="line">DefaultErrorFile &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;default.html&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># StatHost: This configures the host name or IP address that is treated</span><br><span class="line"># as the stat host: Whenever a request for this host is received,</span><br><span class="line"># Tinyproxy will return an internal statistics page instead of</span><br><span class="line"># forwarding the request to that host.  The default value of StatHost is</span><br><span class="line"># tinyproxy.stats.</span><br><span class="line">#</span><br><span class="line">#StatHost &quot;tinyproxy.stats&quot;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># StatFile: The HTML file that gets sent when a request is made</span><br><span class="line"># for the stathost.  If this file doesn&#39;t exist a basic page is</span><br><span class="line"># hardcoded in tinyproxy.</span><br><span class="line">#</span><br><span class="line">StatFile &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;stats.html&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># LogFile: Allows you to specify the location where information should</span><br><span class="line"># be logged to.  If you would prefer to log to syslog, then disable this</span><br><span class="line"># and enable the Syslog directive.  These directives are mutually</span><br><span class="line"># exclusive. If neither Syslog nor LogFile are specified, output goes</span><br><span class="line"># to stdout.</span><br><span class="line">#</span><br><span class="line">LogFile &quot;&#x2F;var&#x2F;log&#x2F;tinyproxy&#x2F;tinyproxy.log&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Syslog: Tell tinyproxy to use syslog instead of a logfile.  This</span><br><span class="line"># option must not be enabled if the Logfile directive is being used.</span><br><span class="line"># These two directives are mutually exclusive.</span><br><span class="line">#</span><br><span class="line">#Syslog On</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># LogLevel: Warning</span><br><span class="line">#</span><br><span class="line"># Set the logging level. Allowed settings are:</span><br><span class="line">#Critical(least verbose)</span><br><span class="line">#Error</span><br><span class="line">#Warning</span><br><span class="line">#Notice</span><br><span class="line">#Connect(to log connections without Info&#39;s noise)</span><br><span class="line">#Info(most verbose)</span><br><span class="line">#</span><br><span class="line"># The LogLevel logs from the set level and above. For example, if the</span><br><span class="line"># LogLevel was set to Warning, then all log messages from Warning to</span><br><span class="line"># Critical would be output, but Notice and below would be suppressed.</span><br><span class="line">#</span><br><span class="line">LogLevel Info</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># PidFile: Write the PID of the main tinyproxy thread to this file so it</span><br><span class="line"># can be used for signalling purposes.</span><br><span class="line"># If not specified, no pidfile will be written.</span><br><span class="line">#</span><br><span class="line">PidFile &quot;&#x2F;var&#x2F;run&#x2F;tinyproxy&#x2F;tinyproxy.pid&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># XTinyproxy: Tell Tinyproxy to include the X-Tinyproxy header, which</span><br><span class="line"># contains the client&#39;s IP address.</span><br><span class="line">#</span><br><span class="line">#XTinyproxy Yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Upstream:</span><br><span class="line">#</span><br><span class="line"># Turns on upstream proxy support.</span><br><span class="line">#</span><br><span class="line"># The upstream rules allow you to selectively route upstream connections</span><br><span class="line"># based on the host&#x2F;domain of the site being accessed.</span><br><span class="line">#</span><br><span class="line"># Syntax: upstream type (user:pass@)ip:port (&quot;domain&quot;)</span><br><span class="line"># Or:     upstream none &quot;domain&quot;</span><br><span class="line"># The parts in parens are optional.</span><br><span class="line"># Possible types are http, socks4, socks5, none</span><br><span class="line">#</span><br><span class="line"># For example:</span><br><span class="line">#  # connection to test domain goes through testproxy</span><br><span class="line">#  upstream http testproxy:8008 &quot;.test.domain.invalid&quot;</span><br><span class="line">#  upstream http testproxy:8008 &quot;.our_testbed.example.com&quot;</span><br><span class="line">#  upstream http testproxy:8008 &quot;192.168.128.0&#x2F;255.255.254.0&quot;</span><br><span class="line">#</span><br><span class="line">#  # upstream proxy using basic authentication</span><br><span class="line">#  upstream http user:pass@testproxy:8008 &quot;.test.domain.invalid&quot;</span><br><span class="line">#</span><br><span class="line">#  # no upstream proxy for internal websites and unqualified hosts</span><br><span class="line">#  upstream none &quot;.internal.example.com&quot;</span><br><span class="line">#  upstream none &quot;www.example.com&quot;</span><br><span class="line">#  upstream none &quot;10.0.0.0&#x2F;8&quot;</span><br><span class="line">#  upstream none &quot;192.168.0.0&#x2F;255.255.254.0&quot;</span><br><span class="line">#  upstream none &quot;.&quot;</span><br><span class="line">#</span><br><span class="line">#  # connection to these boxes go through their DMZ firewalls</span><br><span class="line">#  upstream http cust1_firewall:8008 &quot;testbed_for_cust1&quot;</span><br><span class="line">#  upstream http cust2_firewall:8008 &quot;testbed_for_cust2&quot;</span><br><span class="line">#</span><br><span class="line">#  # default upstream is internet firewall</span><br><span class="line">#  upstream http firewall.internal.example.com:80</span><br><span class="line">#</span><br><span class="line"># You may also use SOCKS4&#x2F;SOCKS5 upstream proxies:</span><br><span class="line">#  upstream socks4 127.0.0.1:9050</span><br><span class="line">#  upstream socks5 socksproxy:1080</span><br><span class="line">#</span><br><span class="line"># The LAST matching rule wins the route decision.  As you can see, you</span><br><span class="line"># can use a host, or a domain:</span><br><span class="line">#  name     matches host exactly</span><br><span class="line">#  .name    matches any host in domain &quot;name&quot;</span><br><span class="line">#  .        matches any host with no domain (in &#39;empty&#39; domain)</span><br><span class="line">#  IP&#x2F;bits  matches network&#x2F;mask</span><br><span class="line">#  IP&#x2F;mask  matches network&#x2F;mask</span><br><span class="line">#</span><br><span class="line">#Upstream http some.remote.proxy:port</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># MaxClients: This is the absolute highest number of threads which will</span><br><span class="line"># be created. In other words, only MaxClients number of clients can be</span><br><span class="line"># connected at the same time.</span><br><span class="line">#</span><br><span class="line">MaxClients 100</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># MinSpareServers&#x2F;MaxSpareServers: These settings set the upper and</span><br><span class="line"># lower limit for the number of spare servers which should be available.</span><br><span class="line">#</span><br><span class="line"># If the number of spare servers falls below MinSpareServers then new</span><br><span class="line"># server processes will be spawned.  If the number of servers exceeds</span><br><span class="line"># MaxSpareServers then the extras will be killed off.</span><br><span class="line">#</span><br><span class="line">MinSpareServers 5</span><br><span class="line">MaxSpareServers 20</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># StartServers: The number of servers to start initially.</span><br><span class="line">#</span><br><span class="line">StartServers 10</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># MaxRequestsPerChild: The number of connections a thread will handle</span><br><span class="line"># before it is killed. In practise this should be set to 0, which</span><br><span class="line"># disables thread reaping. If you do notice problems with memory</span><br><span class="line"># leakage, then set this to something like 10000.</span><br><span class="line">#</span><br><span class="line">MaxRequestsPerChild 0</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Allow: Customization of authorization controls. If there are any</span><br><span class="line"># access control keywords then the default action is to DENY. Otherwise,</span><br><span class="line"># the default action is ALLOW.</span><br><span class="line">#</span><br><span class="line"># The order of the controls are important. All incoming connections are</span><br><span class="line"># tested against the controls based on order.</span><br><span class="line">#</span><br><span class="line">Allow 127.0.0.1</span><br><span class="line"></span><br><span class="line"># BasicAuth: HTTP &quot;Basic Authentication&quot; for accessing the proxy.</span><br><span class="line"># If there are any entries specified, access is only granted for authenticated</span><br><span class="line"># users.</span><br><span class="line">#BasicAuth user password</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># AddHeader: Adds the specified headers to outgoing HTTP requests that</span><br><span class="line"># Tinyproxy makes. Note that this option will not work for HTTPS</span><br><span class="line"># traffic, as Tinyproxy has no control over what headers are exchanged.</span><br><span class="line">#</span><br><span class="line">#AddHeader &quot;X-My-Header&quot; &quot;Powered by Tinyproxy&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># ViaProxyName: The &quot;Via&quot; header is required by the HTTP RFC, but using</span><br><span class="line"># the real host name is a security concern.  If the following directive</span><br><span class="line"># is enabled, the string supplied will be used as the host name in the</span><br><span class="line"># Via header; otherwise, the server&#39;s host name will be used.</span><br><span class="line">#</span><br><span class="line">ViaProxyName &quot;tinyproxy&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># DisableViaHeader: When this is set to yes, Tinyproxy does NOT add</span><br><span class="line"># the Via header to the requests. This virtually puts Tinyproxy into</span><br><span class="line"># stealth mode. Note that RFC 2616 requires proxies to set the Via</span><br><span class="line"># header, so by enabling this option, you break compliance.</span><br><span class="line"># Don&#39;t disable the Via header unless you know what you are doing...</span><br><span class="line">#</span><br><span class="line">#DisableViaHeader Yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Filter: This allows you to specify the location of the filter file.</span><br><span class="line">#</span><br><span class="line">Filter &quot;&#x2F;etc&#x2F;tinyproxy&#x2F;filter&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># FilterURLs: Filter based on URLs rather than domains.</span><br><span class="line">#</span><br><span class="line">#FilterURLs On</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># FilterExtended: Use POSIX Extended regular expressions rather than</span><br><span class="line"># basic.</span><br><span class="line">#</span><br><span class="line">#FilterExtended On</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># FilterCaseSensitive: Use case sensitive regular expressions.</span><br><span class="line">#</span><br><span class="line">#FilterCaseSensitive On</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># FilterDefaultDeny: Change the default policy of the filtering system.</span><br><span class="line"># If this directive is commented out, or is set to &quot;No&quot; then the default</span><br><span class="line"># policy is to allow everything which is not specifically denied by the</span><br><span class="line"># filter file.</span><br><span class="line">#</span><br><span class="line"># However, by setting this directive to &quot;Yes&quot; the default policy becomes</span><br><span class="line"># to deny everything which is _not_ specifically allowed by the filter</span><br><span class="line"># file.</span><br><span class="line">#</span><br><span class="line">#FilterDefaultDeny Yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Anonymous: If an Anonymous keyword is present, then anonymous proxying</span><br><span class="line"># is enabled.  The headers listed are allowed through, while all others</span><br><span class="line"># are denied. If no Anonymous keyword is present, then all headers are</span><br><span class="line"># allowed through.  You must include quotes around the headers.</span><br><span class="line">#</span><br><span class="line"># Most sites require cookies to be enabled for them to work correctly, so</span><br><span class="line"># you will need to allow Cookies through if you access those sites.</span><br><span class="line">#</span><br><span class="line">#Anonymous &quot;Host&quot;</span><br><span class="line">#Anonymous &quot;Authorization&quot;</span><br><span class="line">#Anonymous &quot;Cookie&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># ConnectPort: This is a list of ports allowed by tinyproxy when the</span><br><span class="line"># CONNECT method is used.  To disable the CONNECT method altogether, set</span><br><span class="line"># the value to 0.  If no ConnectPort line is found, all ports are</span><br><span class="line"># allowed.</span><br><span class="line">#</span><br><span class="line"># The following two ports are used by SSL.</span><br><span class="line">#</span><br><span class="line">#ConnectPort 443</span><br><span class="line">#ConnectPort 563</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Configure one or more ReversePath directives to enable reverse proxy</span><br><span class="line"># support. With reverse proxying it&#39;s possible to make a number of</span><br><span class="line"># sites appear as if they were part of a single site.</span><br><span class="line">#</span><br><span class="line"># If you uncomment the following two directives and run tinyproxy</span><br><span class="line"># on your own computer at port 8888, you can access Google using</span><br><span class="line"># http:&#x2F;&#x2F;localhost:8888&#x2F;google&#x2F; and Wired News using</span><br><span class="line"># http:&#x2F;&#x2F;localhost:8888&#x2F;wired&#x2F;news&#x2F;. Neither will actually work</span><br><span class="line"># until you uncomment ReverseMagic as they use absolute linking.</span><br><span class="line">#</span><br><span class="line">#ReversePath &quot;&#x2F;google&#x2F;&quot;&quot;http:&#x2F;&#x2F;www.google.com&#x2F;&quot;</span><br><span class="line">#ReversePath &quot;&#x2F;wired&#x2F;&quot;&quot;http:&#x2F;&#x2F;www.wired.com&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># When using tinyproxy as a reverse proxy, it is STRONGLY recommended</span><br><span class="line"># that the normal proxy is turned off by uncommenting the next directive.</span><br><span class="line">#</span><br><span class="line">#ReverseOnly Yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Use a cookie to track reverse proxy mappings. If you need to reverse</span><br><span class="line"># proxy sites which have absolute links you must uncomment this.</span><br><span class="line">#</span><br><span class="line">#ReverseMagic Yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># The URL that&#39;s used to access this reverse proxy. The URL is used to</span><br><span class="line"># rewrite HTTP redirects so that they won&#39;t escape the proxy. If you</span><br><span class="line"># have a chain of reverse proxies, you&#39;ll need to put the outermost</span><br><span class="line"># URL here (the address which the end user types into his&#x2F;her browser).</span><br><span class="line">#</span><br><span class="line"># If not set then no rewriting occurs.</span><br><span class="line">#</span><br><span class="line">#ReverseBaseURL &quot;http:&#x2F;&#x2F;localhost:8888&#x2F;&quot;</span><br></pre></td></tr></table></figure><p>下面我们来看下几个主要的配置参数：</p><ul><li>User</li></ul><p>指定运行 <code>TinyProxy</code> 的用户，默认为 nobody。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User nobody</span><br></pre></td></tr></table></figure><ul><li>Group</li></ul><p>指定运行 <code>TinyProxy</code> 的用户组，默认为 nobody。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Group nobody</span><br></pre></td></tr></table></figure><ul><li>Listen</li></ul><p>指定 <code>TinyProxy</code> 绑定的网卡接口，默认是绑定到所有可用的网卡接口的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Listen 192.168.0.1</span><br></pre></td></tr></table></figure><p>如需绑定到指定网卡接口，只需去掉对应的注释并指定网卡对应 IP 地址即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Listen 192.168.1.100</span><br></pre></td></tr></table></figure><ul><li>Port</li></ul><p>指定 <code>TinyProxy</code> 的监听端口, 默认为 8888。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Port 8888</span><br></pre></td></tr></table></figure><ul><li>Allow</li></ul><p>指定可访问 <code>TinyProxy</code> 设备的 <code>IP</code> 或网段，默认仅允许本机访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allow 127.0.0.1</span><br></pre></td></tr></table></figure><p>如果你想允许所有人使用该代理，注释 Allow 选项即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Allow 127.0.0.1</span><br></pre></td></tr></table></figure><p>如果你想增加多个可访问的网段，可以用多个 <code>Allow</code> 选项同时定义不同网段即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 添加多段 IP 地址</span><br><span class="line">Allow 10.10.6.0&#x2F;24</span><br><span class="line">Allow 192.168.8.0&#x2F;24</span><br><span class="line">Allow 172.16.1.13</span><br></pre></td></tr></table></figure><ul><li>BindSame</li></ul><p>在多网卡的情况下，设置出口 <code>IP</code> 是否与入口 <code>IP</code> 相同。默认情况下是关闭的。</p><p>例如：服务器上存在 <code>IP</code> 1.2.3.4，当你请求该 <code>IP</code> 对应的 <code>Tinyproxy</code> 代理时，<code>Tinyproxy</code> 也通过 1.2.3.4 做为出口访问目标网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#BindSame yes</span><br></pre></td></tr></table></figure><ul><li>StartServers</li></ul><p>指定 <code>TinyProxy</code> 初始启动的子进程数量， 默认是 10 个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StartServers 10</span><br></pre></td></tr></table></figure><ul><li>MaxClients</li></ul><p>设置最大客户端链接数，默认为 100。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxClients 100</span><br></pre></td></tr></table></figure><ul><li>Logfile</li></ul><p>指定日志文件位置, 默认为 /var/log/tinyproxy/tinyproxy.log。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogFile &#x2F;var&#x2F;log&#x2F;tinyproxy&#x2F;tinyproxy.log</span><br></pre></td></tr></table></figure><ul><li>Syslog</li></ul><p>指定 <code>TinyProxy</code> 是否开启 <code>Syslog</code> 来记录日志，默认为关闭的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Syslog On</span><br></pre></td></tr></table></figure><blockquote><p>注：Logfile 和 Syslog 只能同时启用一个。如果两个都不启用的话 <code>TinyProxy</code> 会将日志直接输出到终端的标准输出。</p></blockquote><ul><li>PidFile</li></ul><p>指定 <code>Pid</code> 文件位置, 默认为 /var/run/tinyproxy/tinyproxy.pid，在 <code>PidFile</code> 文件不存在时会运行失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PidFile &quot;&#x2F;var&#x2F;run&#x2F;tinyproxy&#x2F;tinyproxy.pid&quot;</span><br></pre></td></tr></table></figure><ul><li>DisableViaHeader</li></ul><p>指定是否在 Header 中显示 Tinyproxy 相关信息，默认是关闭的。如果开启将不会在 Header 中显示 Tinyproxy 相关信息，相当于 Tinyproxy 是隐身模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#DisableViaHeader Yes</span><br></pre></td></tr></table></figure><ul><li>Filter</li></ul><p>指定设置过滤内容文件的位置，默认为 /etc/tinyproxy/filter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Filter &quot;&#x2F;etc&#x2F;tinyproxy&#x2F;filter&quot;</span><br></pre></td></tr></table></figure><ul><li>FilterURLs</li></ul><p>设置使用 <code>URL</code> 或是域名方式进行过滤，默认是基于 <code>URL</code> 方式过滤的。域名过滤只检查域名段，<code>URL</code> 过滤则检查整个 <code>URL</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterURLs On</span><br></pre></td></tr></table></figure><ul><li>FilterExtended</li></ul><p>设置使用 <code>POSIX</code> 基本或者扩展的正则表达式来匹配过滤规则，默认为使用基本的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># FilterExtended On</span><br></pre></td></tr></table></figure><ul><li>FilterCaseSensitive</li></ul><p>设置是否使用区分大小写的正则表达式，默认为不区分大小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#FilterCaseSensitive On</span><br></pre></td></tr></table></figure><ul><li>FilterDefaultDeny</li></ul><p>设置默认过滤策略。如果将该指令注释掉或设为 No，过滤规则为禁止访问规则。该值默认为 Yes，过滤规则为只允许访问过滤文件中的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterDefaultDeny Yes</span><br></pre></td></tr></table></figure><p>过滤规则配置示例：</p><ol><li>在 /etc/tinyproxy/filter 文件中添加代理允许或拒绝的域名地址。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi-linux.com</span><br></pre></td></tr></table></figure><p>过滤文件中的域名地址也是支持正则表达式的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\.google\.com$</span><br><span class="line">^hi-linux\.com$</span><br></pre></td></tr></table></figure><ol start="2"><li>仅允许代理请求 <a href="http://hi-linux.com" target="_blank" rel="noopener">hi-linux.com</a> 的内容，配置如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filter &quot;&#x2F;etc&#x2F;tinyproxy&#x2F;filter&quot;</span><br><span class="line">FilterURLs On</span><br><span class="line">FilterDefaultDeny Yes</span><br></pre></td></tr></table></figure><ol start="3"><li>仅允许代理请求除 <a href="http://hi-linux.com" target="_blank" rel="noopener">hi-linux.com</a> 域名以外的内容，配置如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filter &quot;&#x2F;etc&#x2F;tinyproxy&#x2F;filter&quot;</span><br><span class="line">FilterURLs On</span><br><span class="line">FilterDefaultDeny No</span><br></pre></td></tr></table></figure><h3 id="运行-tinyproxy">运行 TinyProxy</h3><ul><li>运行 TinyProxy 非常简单，使用官方提供的脚本即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 启动 TinyProxy</span><br><span class="line">$ service tinyproxy start</span><br><span class="line"></span><br><span class="line"># 停止 TinyProxy</span><br><span class="line">$ service tinyproxy stop</span><br><span class="line"></span><br><span class="line"># 重启 TinyProxy</span><br><span class="line">$ service tinyproxy restart</span><br></pre></td></tr></table></figure><ul><li>如果服务器有启用防火墙，记得开放相应的 TinyProxy 端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -I INPUT -p tcp –dport 8888 -j ACCEPT</span><br></pre></td></tr></table></figure><ul><li>查看 TinyProxy 请求日志</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f &#x2F;var&#x2F;log&#x2F;tinyproxy&#x2F;tinyproxy.log</span><br></pre></td></tr></table></figure><ul><li>测试代理是否正常工作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --proxy 192.168.1.100:8888 -k https:&#x2F;&#x2F;www.hi-linux.com&#x2F;</span><br></pre></td></tr></table></figure><p>如果出现对应网页的源代码，则证明代理工作正常。</p><h3 id="参考文档">参考文档</h3><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a><br><a href="http://t.cn/Eaat4mz" target="_blank" rel="noopener">http://t.cn/Eaat4mz</a><br><a href="http://t.cn/EaXdVh9" target="_blank" rel="noopener">http://t.cn/EaXdVh9</a><br><a href="http://t.cn/Eao7ll2" target="_blank" rel="noopener">http://t.cn/Eao7ll2</a><br><a href="http://t.cn/EaobIbE" target="_blank" rel="noopener">http://t.cn/EaobIbE</a><br><a href="http://t.cn/EaoK33b" target="_blank" rel="noopener">http://t.cn/EaoK33b</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，我们常用的 &lt;code&gt;Web&lt;/code&gt; 服务器 &lt;code&gt;Nginx&lt;/code&gt; / &lt;code&gt;Apache&lt;/code&gt; 都可以很方便的用来做为正向或反向代理服务器使用。但是它们都并不支持 &lt;code&gt;HTTPS&lt;/code&gt; 的正向代理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nginx 做为正向代理不支持 HTTPS 的原因是因为 Nginx 没有实现 HTTP 1.1 Connect 方法。隧道的含义大约就是帮助无法完成 TLS 握手的代理服务器透传可以完成 TLS 握手的客户端请求，而不再解析流量中的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于 Connect 和 隧道技术，可详见以下文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RFC 2817 （&lt;a href=&quot;http://t.cn/EaoC0qf%EF%BC%89&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/EaoC0qf）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么是 HTTP 隧道，怎么理解 HTTP 隧道呢？ （&lt;a href=&quot;http://t.cn/EaoCveH%EF%BC%89&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/EaoCveH）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天我们来介绍一款同时支持 &lt;code&gt;HTTP/HTTPS&lt;/code&gt; 的轻量级代理软件 &lt;code&gt;TinyProxy&lt;/code&gt;，&lt;code&gt;TinyProxy&lt;/code&gt; 支持以下功能特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持匿名模式。&lt;/li&gt;
&lt;li&gt;支持 HTTPS，可以通过 CONNECT 请求来转发 HTTPS 连接。&lt;/li&gt;
&lt;li&gt;远程监视：可远程查看日志和访问信息。&lt;/li&gt;
&lt;li&gt;负载监视：可配置成当负载达到某个程度时，拒绝新的代理请求。&lt;/li&gt;
&lt;li&gt;访问控制：可设置特定的 IP 地址或者 IP 段才可访问。&lt;/li&gt;
&lt;li&gt;安全：不需要 root 权限。&lt;/li&gt;
&lt;li&gt;轻量化：只需要极小的系统资源。&lt;/li&gt;
&lt;li&gt;支持基于 URL 的过滤。&lt;/li&gt;
&lt;li&gt;支持透明代理。&lt;/li&gt;
&lt;li&gt;支持多级代理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TinyProxy 项目地址：&lt;a href=&quot;https://github.com/tinyproxy/tinyproxy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/tinyproxy/tinyproxy&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装-TinyProxy&quot;&gt;安装 TinyProxy&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过软件包安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;TinyProxy&lt;/code&gt; 目前已支持大多数发行版通过软件包安装，下面介绍下比较常用的几个平台的安装方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS / RHEL&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 需要 EPEL 仓库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ yum install -y tinyproxy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu / Debian&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-get -y install tinyproxy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你使用的是其它平台，更多的安装方式可直接参考官方文档：&lt;a href=&quot;https://tinyproxy.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tinyproxy.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;通过源码安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你使用的平台，官方还不支持通过软件包安装。你也可以通过源码进行编译安装。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;tinyproxy&amp;#x2F;tinyproxy.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd tinyproxy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ .&amp;#x2F;autogen.sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ .&amp;#x2F;configure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ make&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ make install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="代理" scheme="https://www.hi-linux.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 6 期 )</title>
    <link href="https://www.hi-linux.com/posts/27164.html"/>
    <id>https://www.hi-linux.com/posts/27164.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.404Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html" target="_blank" rel="noopener">华为正式发布方舟编译器，相关源码已开放下载</a></p><p>华为正式对外发布了此前已经对外公布的编译工具——方舟编译器。方舟编译器是基于 GCC（GNU Compiler Collection，GNU 编译器套件） 开发的交叉编译器套件，它包括了 C、C++、Fortran 的前端，也包括了这些语言的库（如 libstdc++、libgcc 等）。HCC（即华为方舟编译器） 运行在 X86 Linux 架构服务器上，生成的二进制运行在 Aarch64 架构服务器上。</p><p>链接：<a href="https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html" target="_blank" rel="noopener">https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html</a></p><p><img src="https://i.loli.net/2019/08/06/FjlqCm9bU4iWBS1.png" alt=""></p><p>2、<a href="https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release" target="_blank" rel="noopener">Windows Terminal 0.3 发布：一系列改进和错误修复</a></p><p>Windows terminal 0.3 更新已经在 Microsoft Store 发布。提供了一系列改进和错误修复，包括拖动标题栏、自定义选项卡标题等功能。</p><p>链接：<a href="https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release" target="_blank" rel="noopener">https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release</a></p><p><img src="https://i.loli.net/2019/08/06/3DCA6SmwLjbUyog.jpg" alt=""></p><p>3、<a href="https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products" target="_blank" rel="noopener">Google 更新图片搜索：全新预览设计及更多产品细节</a></p><p>Google 更新了全新的图片搜索界面，主要的改变是让比较不同的照片变得更容易。最直观的差异，就是点选图片后原本是在下面展开一个详细内容的深色横条，而现在则是被改成在右边栏展开了。如此一来，当你继续向下卷动时，之前点选的图片会继续留在右边，让你和新出现的图片做比较。</p><p>链接：<a href="https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products" target="_blank" rel="noopener">https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products</a></p><p><img src="https://i.loli.net/2019/08/07/9rTXN3E5qQAbWSu.jpg" alt=""></p><p>4、<a href="https://tech.qq.com/a/20190807/005725.htm" target="_blank" rel="noopener">支付宝/微信均上线电子结婚证</a></p><p>近日，支付宝宣布已有 5 省市上线电子结婚证。已经登记结婚的夫妻，上支付宝搜 “电子结婚证”，进入当地一网通办小程序，选择电子证件，刷脸就能领取到和实体证相对应的电子结婚证。同时也可办理补领婚姻证预约、婚姻登记信息核验等服务。福建、江西、江苏、浙江、重庆 5 省市首批支持。</p><p>链接：<a href="https://www.pingwest.com/w/192406" target="_blank" rel="noopener">https://www.pingwest.com/w/192406</a></p><p><img src="https://i.loli.net/2019/08/07/u6s9yPCTZfNaxE5.jpg" alt=""></p><p>据悉，全国 14 省市用户现已可通过 “中国政务服务平台” 微信小程序 “刷脸” 关联电子结婚证。目前支持北京、河北、上海、江苏、浙江、安徽、湖北、江西、湖南、广东、重庆、四川、贵州、福建等省市的用户。</p><p>链接：<a href="https://tech.qq.com/a/20190807/005725.htm" target="_blank" rel="noopener">https://tech.qq.com/a/20190807/005725.htm</a></p><p><img src="https://i.loli.net/2019/08/07/3s4oF8vApW1x65z.jpg" alt=""></p><p>5、<a href="https://segmentfault.com/a/1190000019975092" target="_blank" rel="noopener">灵雀云开源 Helm v3 Controller 组件 Captain，完善云原生应用管理功能</a></p><p>近日，灵雀云宣布发布 Helm v3 Controller 组件 “Captain”，并正式将其在 Github 上开源。Captain 是 Helm 官方社区发布的 Helm v3 proposal 的第一个 Controller 实现示例，帮助用户简化 Helm 资源描述，更便捷、高效地实现 K8s 应用的管理和控制，推进 Helm 项目向原生 K8s 迈进的步伐。目前 Captain 项目代码已经在Github 上开源，项目地址为：<a href="https://github.com/alauda/captain%E3%80%82" target="_blank" rel="noopener">https://github.com/alauda/captain。</a></p><p>链接：<a href="https://segmentfault.com/a/1190000019975092" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019975092</a></p><p><img src="https://i.loli.net/2019/08/08/qF5p3gyzrQ4VIRt.jpg" alt=""></p><p>6、<a href="https://www.solidot.org/story?sid=61641" target="_blank" rel="noopener">Let’s Encrypt 推出中文版</a></p><p>旨在让每个网站都能使用 HTTPS 加密的非赢利组织 Let’s Encrypt 发布了简体中文版，方便中文用户使用 Let’s Encrypt 签发的证书 。中文版主要是汉化了一下主页和文档，而文档实际上还没有完成翻译，感兴趣的志愿者可以通过 GitHub 帮助它翻译网站文档。Let’s Encrypt 目前支持包括中文在内的七种语言，它的证书已获得了主要浏览器开发商的信任。</p><p>链接：<a href="https://www.solidot.org/story?sid=61641" target="_blank" rel="noopener">https://www.solidot.org/story?sid=61641</a></p><p><img src="https://i.loli.net/2019/08/08/ptWmNUMJy5QACqB.png" alt=""></p><p>7、<a href="https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china" target="_blank" rel="noopener">中国首个开源协议诞生，比 Apache 许可证友好</a></p><p>近日，中国开源云联盟官网上线了 “木兰宽松许可证”（MulanPSL），据传这是中国首个开源协议。木兰宽松许可证第 1 版包含了版权许可、专利许可和无商标许可，可自由重新分发，但必须提供许可证的副本，并保留版权、商标、专利及免责声明。许可具体内容请查看：<a href="http://license.coscl.org.cn/MulanPSL%E3%80%82" target="_blank" rel="noopener">http://license.coscl.org.cn/MulanPSL。</a></p><p>链接：<a href="https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china" target="_blank" rel="noopener">https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china</a></p><p><img src="https://i.loli.net/2019/08/08/xAsLIPBby4zGjW7.png" alt=""></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://github.com/redhat-developer/vscode-yaml" target="_blank" rel="noopener">YAML</a></p><p>这是一个 YAML 语法高亮的 VSCode 插件，支持 Kubernetes 和 Kedge 语法，由 Red Hat 开发的。要支持 Kubernetes 语法，需要先安装 VSCode 的 Kubernetes 插件。</p><p>项目地址: <a href="https://github.com/redhat-developer/vscode-yaml" target="_blank" rel="noopener">https://github.com/redhat-developer/vscode-yaml</a></p><p><img src="https://i.loli.net/2019/08/08/bBYNMdRvFOS2uk5.jpg" alt=""></p><p>2、<a href="https://github.com/zeromake/docker-debug" target="_blank" rel="noopener">docker-debug</a></p><p>docker-debug 是一个运行中 Docker 容器的故障排除程序，它允许用户在 Docker 中运行新容器以进行调试，并将目标容器的 pid, network, uses, filesystem 和 ipc 命名空间注入到新的容器里。因此，您可以使用任意故障排除工具，而无需在生产容器镜像中预先安装额外的工具环境。</p><p>项目地址: <a href="https://github.com/zeromake/docker-debug" target="_blank" rel="noopener">https://github.com/zeromake/docker-debug</a></p><p><img src="https://i.loli.net/2019/08/08/hBAvsOcEo6ILjNR.jpg" alt=""></p><p>3、<a href="https://github.com/robscott/kube-capacity" target="_blank" rel="noopener">kube-capacity</a></p><p>kube-capacity 是一个简单的 CLI 工具，它概述了 Kubernetes 集群中的资源请求、限制和利用率。它将 kubectl top 和 kubectl describe 的最佳部分组合到一个易于使用的 CLI 中，方便集群资源的管理。</p><p>项目地址: <a href="https://github.com/robscott/kube-capacity" target="_blank" rel="noopener">https://github.com/robscott/kube-capacity</a></p><p><img src="https://i.loli.net/2019/08/08/IOjD9V8xXs1eGhN.png" alt=""></p><p>4、<a href="https://github.com/donnemartin/gitsome" target="_blank" rel="noopener">gitsome</a></p><p>一个非常实用的 GitHub 命令行工具，支持在命令行中查看 GitHub 通知、搜索创建 Issue、浏览动态、生成 LICENSE 等，功能十分强大。如果你是 GitHub 重度用户，那相信你一定会爱上这个工具。</p><p>项目地址：<a href="https://github.com/donnemartin/gitsome" target="_blank" rel="noopener">https://github.com/donnemartin/gitsome</a></p><p><img src="https://i.loli.net/2019/08/08/NtacI6Zf12kzHEK.gif" alt=""></p><p>5、<a href="https://github.com/dutchcoders/transfer.sh" target="_blank" rel="noopener">Transfer.sh</a></p><p><a href="http://Transfer.sh" target="_blank" rel="noopener">Transfer.sh</a> 是一个简单、方便快捷的命令行文件分享服务。只需要一条命令就可以将文件快速分享出去，它允许您免费上传最大 10GB 的数据，文件可以存储 14 天。</p><p>项目地址：<a href="https://github.com/dutchcoders/transfer.sh" target="_blank" rel="noopener">https://github.com/dutchcoders/transfer.sh</a></p><p><img src="https://i.loli.net/2019/08/08/WRfxCA4iXQ5vSzG.jpg" alt=""></p><p>6、<a href="https://github.com/DimitarPetrov/stegify" target="_blank" rel="noopener">stegify</a></p><p>一款神奇的命令行工具，能将任意文件隐藏到图片里面。</p><p>项目地址：<a href="https://github.com/DimitarPetrov/stegify" target="_blank" rel="noopener">https://github.com/DimitarPetrov/stegify</a></p><p>来看一个示例：第 3 张图片为 1、2 两张图片合成的，但是从视觉上却完全看不到第 2 张图片的存在。</p><p><img src="https://i.loli.net/2019/08/08/x9PgGb2AMy3D8k7.jpg" alt=""></p><p>7、<a href="https://github.com/instantbox/instantbox" target="_blank" rel="noopener">Instantbox</a></p><p>Instantbox 是一个基于 Docker 的临时 Linux 系统创建工具，它可以快速创建一个开箱即用的 Linux 系统。目前 Instantbox 支持了 Ubuntu、CentOS、Debian、Alpine 等主流系统。</p><p>项目地址：<a href="https://github.com/instantbox/instantbox" target="_blank" rel="noopener">https://github.com/instantbox/instantbox</a></p><p><img src="https://i.loli.net/2019/08/08/FGgbs1R6pAKzPoH.jpg" alt=""></p><p>8、<a href="https://github.com/vvo/gifify" target="_blank" rel="noopener">gifify</a></p><p>gifify 是一款将视频转换成 GIF 图片的工具，支持任何格式的视频以及选取某个时间段进行转换。</p><p>项目地址：<a href="https://github.com/vvo/gifify" target="_blank" rel="noopener">https://github.com/vvo/gifify</a></p><p><img src="https://i.loli.net/2019/08/08/poyJj5ZNIbWQhGz.jpg" alt=""></p><p>9、<a href="https://github.com/zdict/zdict" target="_blank" rel="noopener">zdict</a></p><p>一个运行在终端的在线字典工具，支持多款字典切换查询，并支持查询结果高亮。</p><p>项目地址：<a href="https://github.com/zdict/zdict" target="_blank" rel="noopener">https://github.com/zdict/zdict</a></p><p><img src="https://i.loli.net/2019/08/08/iKC7zIaMAog21mf.jpg" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="https://github.com/0voice/from_coder_to_expert" target="_blank" rel="noopener">2019 年各互联网大厂最新内部技术分享的文档集合</a></p><p>2019 年各互联网大厂最新内部技术分享的文档 PDF、PPT 集合。从程序员到 CTO，从专业走向卓越。</p><p>链接：<a href="https://github.com/0voice/from_coder_to_expert" target="_blank" rel="noopener">https://github.com/0voice/from_coder_to_expert</a></p><p><img src="https://i.loli.net/2019/08/01/5d42a33fbc4d259157.png" alt=""></p><p>2、<a href="http://www.tianshouzhi.com/api/tutorials/canal/404" target="_blank" rel="noopener">异地多活场景下的数据同步之道</a></p><p>在当今互联网行业，大多数人互联网从业者对&quot;单元化&quot;、&quot;异地多活&quot;这些词汇已经耳熟能详。而数据同步是异地多活的基础，所有具备数据存储能力的组件如：数据库、缓存、MQ等，数据都可以进行同步，形成一个庞大而复杂的数据同步拓扑。</p><p>本文将先从概念上介绍单元化、异地多活、就近访问等基本概念。之后，将以数据库为例，讲解在数据同步的情况下，如何解决数据回环、数据冲突、数据重复等典型问题。</p><p>链接：<a href="http://www.tianshouzhi.com/api/tutorials/canal/404" target="_blank" rel="noopener">http://www.tianshouzhi.com/api/tutorials/canal/404</a></p><p><img src="https://i.loli.net/2019/08/08/syufeXaqUDE4ISc.png" alt=""></p><p>3、<a href="https://github.com/hcymysql/mgr_failover_vip" target="_blank" rel="noopener">MySQL 8.0 MGR（组复制）高可用 VIP 切换脚本</a></p><p>MGR（组复制）官方推荐用 MySQL Router 中间件去做 MGR 高可用故障转移，但其多过了一层网络，会造成性能下降。并且需要额外维护一套中间件，运维成本过高。本文将介绍一个类似 MHA 的 master_ip_failover 脚本的方法来实现 VIP 切换。</p><p>链接：<a href="https://github.com/hcymysql/mgr_failover_vip" target="_blank" rel="noopener">https://github.com/hcymysql/mgr_failover_vip</a></p><h2 id="每周观点">每周观点</h2><p>1、知识使人自由，或者起码渴望自由。—— 特雷弗·诺亚「天生有罪」</p><p>2、失败只是给了我们一个重新开始的机会，而这次我们变得更加聪明。—— 亨利·福特</p><p>3、如果人们过度重视决策的直接结果而忽视后续和再后续的结果，他们就很难实现目标。这是因为直接结果和后续结果的值得追求性通常是相反的，这会造成决策的重大错误。—— 雷·达里欧</p><p>4、生活坏到一定程度就会好起来，因为它无法更坏。努力过后，才知道许多事情，坚持坚持就过来了。—— 宫崎骏「龙猫」</p><p>5、生命可以随心所欲，但不能随波逐流。—— 宫崎骏「猫的报恩」</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;华为正式发布方舟编译器，相关源码已开放下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为正式对外发布了此前已经对外公布的编译工具——方舟编译器。方舟编译器是基于 GCC（GNU Compiler Collection，GNU 编译器套件） 开发的交叉编译器套件，它包括了 C、C++、Fortran 的前端，也包括了这些语言的库（如 libstdc++、libgcc 等）。HCC（即华为方舟编译器） 运行在 X86 Linux 架构服务器上，生成的二进制运行在 Aarch64 架构服务器上。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/06/FjlqCm9bU4iWBS1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows Terminal 0.3 发布：一系列改进和错误修复&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows terminal 0.3 更新已经在 Microsoft Store 发布。提供了一系列改进和错误修复，包括拖动标题栏、自定义选项卡标题等功能。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/06/3DCA6SmwLjbUyog.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google 更新图片搜索：全新预览设计及更多产品细节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google 更新了全新的图片搜索界面，主要的改变是让比较不同的照片变得更容易。最直观的差异，就是点选图片后原本是在下面展开一个详细内容的深色横条，而现在则是被改成在右边栏展开了。如此一来，当你继续向下卷动时，之前点选的图片会继续留在右边，让你和新出现的图片做比较。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/07/9rTXN3E5qQAbWSu.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://tech.qq.com/a/20190807/005725.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;支付宝/微信均上线电子结婚证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，支付宝宣布已有 5 省市上线电子结婚证。已经登记结婚的夫妻，上支付宝搜 “电子结婚证”，进入当地一网通办小程序，选择电子证件，刷脸就能领取到和实体证相对应的电子结婚证。同时也可办理补领婚姻证预约、婚姻登记信息核验等服务。福建、江西、江苏、浙江、重庆 5 省市首批支持。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.pingwest.com/w/192406&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.pingwest.com/w/192406&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/07/u6s9yPCTZfNaxE5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;据悉，全国 14 省市用户现已可通过 “中国政务服务平台” 微信小程序 “刷脸” 关联电子结婚证。目前支持北京、河北、上海、江苏、浙江、安徽、湖北、江西、湖南、广东、重庆、四川、贵州、福建等省市的用户。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://tech.qq.com/a/20190807/005725.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tech.qq.com/a/20190807/005725.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/07/3s4oF8vApW1x65z.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://segmentfault.com/a/1190000019975092&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;灵雀云开源 Helm v3 Controller 组件 Captain，完善云原生应用管理功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，灵雀云宣布发布 Helm v3 Controller 组件 “Captain”，并正式将其在 Github 上开源。Captain 是 Helm 官方社区发布的 Helm v3 proposal 的第一个 Controller 实现示例，帮助用户简化 Helm 资源描述，更便捷、高效地实现 K8s 应用的管理和控制，推进 Helm 项目向原生 K8s 迈进的步伐。目前 Captain 项目代码已经在Github 上开源，项目地址为：&lt;a href=&quot;https://github.com/alauda/captain%E3%80%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/alauda/captain。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://segmentfault.com/a/1190000019975092&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000019975092&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/08/qF5p3gyzrQ4VIRt.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://www.solidot.org/story?sid=61641&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Let’s Encrypt 推出中文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;旨在让每个网站都能使用 HTTPS 加密的非赢利组织 Let’s Encrypt 发布了简体中文版，方便中文用户使用 Let’s Encrypt 签发的证书 。中文版主要是汉化了一下主页和文档，而文档实际上还没有完成翻译，感兴趣的志愿者可以通过 GitHub 帮助它翻译网站文档。Let’s Encrypt 目前支持包括中文在内的七种语言，它的证书已获得了主要浏览器开发商的信任。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.solidot.org/story?sid=61641&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.solidot.org/story?sid=61641&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/08/ptWmNUMJy5QACqB.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&quot;https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中国首个开源协议诞生，比 Apache 许可证友好&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，中国开源云联盟官网上线了 “木兰宽松许可证”（MulanPSL），据传这是中国首个开源协议。木兰宽松许可证第 1 版包含了版权许可、专利许可和无商标许可，可自由重新分发，但必须提供许可证的副本，并保留版权、商标、专利及免责声明。许可具体内容请查看：&lt;a href=&quot;http://license.coscl.org.cn/MulanPSL%E3%80%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://license.coscl.org.cn/MulanPSL。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/08/xAsLIPBby4zGjW7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>50 个你必须掌握的 Kubernetes 面试题</title>
    <link href="https://www.hi-linux.com/posts/2742.html"/>
    <id>https://www.hi-linux.com/posts/2742.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T10:16:21.956Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Kubernetes 一直是当今业界的流行语，也是最好的编排工具。它吸引了许多想要提升自己职业生涯的经验丰富的专业人士。</p><p>Huwaei、Pokemon、Box、eBay、Ing、Yahoo Japan、SAP、纽约时报、Open AI、Sound Cloud 等跨国公司也使用 Kubernetes。我相信你已经知道这些事实，这也是促使你打开这个 Kubernetes 面试问题文章原因。</p><p>在这篇关于 Kubernetes 面试问题的文章中，我将讨论在面试中提出的与 Kubernetes 相关的最重要问题。因此，为了您的理解，我将此文内容分为以下 4 个部分：</p><ul><li>Kubernetes 基本面试问题</li><li>基于架构的面试问题</li><li>基于场景的面试问题</li><li>多项选择题</li></ul><p>现在，让我们开始吧!</p><h2 id="基本的-kubernetes-面试问题">基本的 Kubernetes 面试问题</h2><p>这部分问题将包含您需要了解的与 Kubernetes 工作相关的所有基本问题。</p><p><strong>Q1、Kubernetes 与 Docker Swarm 的区别如何？</strong></p><p><img src="https://miro.medium.com/max/700/1*xzLZVPBlFvLsVPaqtracvw.png" alt=""></p><p><strong>Q2、什么是 Kubernetes？</strong></p><p><img src="https://miro.medium.com/max/321/1*jhzU7LO0pvfMJzrViu6tiA.png" alt=""></p><p>Kubernetes 是一个开源容器管理工具，负责容器部署，容器扩缩容以及负载平衡。作为 Google 的创意之作，它提供了出色的社区，并与所有云提供商合作。因此，我们可以说 Kubernetes 不是一个容器化平台，而是一个多容器管理解决方案。</p><p><strong>Q3、Kubernetes 与 Docker 有什么关系？</strong></p><p>众所周知，Docker 提供容器的生命周期管理和 Docker 镜像构建运行时容器。但是，由于这些单独的容器有时必须跨主机通信，这时我们需要使用 Kubernetes 来解决这个问题。</p><p>因此，我们说 Docker 构建容器，但这些容器通过 Kubernetes 来进行跨主机相互通信。我们还可以使用 Kubernetes 手动关联和编排在多个主机上运行的容器。</p><p><strong>Q4、在主机和容器上部署应用程序有什么区别？</strong></p><p><img src="https://miro.medium.com/max/700/1*R_5hio_I-hK4f-bOfTHstA.png" alt=""></p><p>请参考上图。左侧架构表示在主机上部署应用程序。因此，这种架构将具有操作系统，然后操作系统将具有内核，该内核将在应用程序所需的操作系统上安装各种库。因此，在这种框架中，您可以拥有 N 个应用程序，并且所有应用程序将共享该操作系统中存在的库，而在容器中部署应用程序时，体系结构则略有不同。</p><p>这种架构将有一个内核，这是唯一一个在所有应用程序之间唯一共同的东西。因此，如果有一个需要 Java 的特定应用程序，那么我们将获得访问 Java 的特定应用程序，如果有另一个需要 Python 的应用程序，则只有该特定应用程序才能访问 Python。</p><p>您可以在图表右侧看到的各个块基本上是容器化的，并且这些块与其他应用程序隔离。因此，应用程序具有与系统其余部分隔离的必要库和二进制文件，并且不能被任何其他应用程序侵占。</p><a id="more"></a><p><strong>Q5、什么是 Container Orchestration？</strong></p><p>考虑一个应用程序有 5-6 个微服务的场景。</p><p>现在，这些微服务被放在单独的容器中，但如果没有容器编排就无法进行通信。因此，由于编排意味着所有乐器在音乐中和谐共处，所以类似的容器编排意味着各个容器中的所有服务协同工作以满足单个服务器的需求。</p><p><strong>Q6、Container Orchestration 需要什么？</strong></p><p>考虑到你有 5-6 个微服务用于执行各种任务的单个应用程序，所有这些微服务都放在容器中。现在，为了确保这些容器彼此通信，我们需要容器编排。</p><p><img src="https://miro.medium.com/max/700/1*69m4EpkxBFafy7tdu6gxjA.png" alt=""></p><p>正如您在上图中所看到的，在没有使用容器编排的情况下，还存在许多挑战。因此，为了克服这些挑战，容器编排就到位了。</p><p><strong>Q7、Kubernetes 有什么特点？</strong></p><p>Kubernetes 的功能如下：</p><p><img src="https://miro.medium.com/max/700/1*MNasEMnDO45erWjsQXCJ_Q.png" alt=""></p><p><strong>Q8、Kubernetes 如何简化容器化部署？</strong></p><p>由于典型应用程序将具有跨多个主机运行的容器集群，因此所有这些容器都需要相互通信。因此，要做到这一点，你需要一些能够负载均衡、扩展和监控容器的东西。</p><p>由于 Kubernetes 与云无关并且可以在任何公共/私有提供商上运行，因此必须是您简化容器化部署的选择。</p><p><strong>Q9、您对 Kubernetes 的集群了解多少？</strong></p><p>Kubernetes 背后的基础是我们可以实施所需的状态管理，我的意思是我们可以提供特定配置的集群服务，并且集群服务将在基础架构中运行并运行该配置。</p><p><img src="https://miro.medium.com/max/700/1*FSWh9wJLuVuKcXQB97xiJA.png" alt=""></p><p>因此，正如您在上图中所看到的，部署文件将具有提供给集群服务所需的所有配置。</p><p>现在，部署文件将被提供给 API，然后由集群服务决定如何在环境中安排这些 Pod，并确保正确运行的 Pod 的数量。</p><p>因此，位于服务前面的 API，工作节点和节点运行的 Kubelet 进程，共同构成了 Kubernetes 集群。</p><p><strong>Q10、什么是 Google 容器引擎？</strong></p><p>Google Container Engine（GKE）是 Docker 容器和集群的开源管理平台。这个基于 Kubernetes 的引擎仅支持在 Google 的公共云服务中运行的群集。</p><p><strong>Q11、什么是 Heapster？</strong></p><p>Heapster 是由每个节点上运行的 Kubelet 提供的集群范围的数据聚合器。</p><p>此容器管理工具在 Kubernetes 集群上本机支持，并作为 Pod 运行，就像集群中的任何其他 Pod 一样。因此，它基本上可以发现集群中的所有节点，并通过本机上 Kubernetes 代理查询集群中 Kubernetes 节点的使用信息。</p><p><strong>Q12、什么是 Minikube？</strong></p><p>Minikube 是一种工具，可以在本地轻松运行 Kubernetes 集群。它是在虚拟机中运行一个单节点 Kubernetes 群集。</p><p><strong>Q13、什么是 Kubectl？</strong></p><p>Kubectl 是一个命令行工具，您可以使用该工具将命令传递给集群。</p><p>因此，它基本上为 CLI 提供了针对 Kubernetes 集群运行命令的方法，以及创建和管理 Kubernetes 组件的各种方法。</p><p><strong>Q14、什么是 Kubelet？</strong></p><p>这是一个代理服务，它在每个节点上运行，并使从服务器与主服务器通信。因此，Kubelet 处理 PodSpec 中提供给它的容器的描述，并确保 PodSpec 中描述的容器运行正常。</p><p><strong>Q15、你对 Kubernetes 的一个节点有什么了解？</strong></p><p><img src="https://miro.medium.com/max/700/1*zH_jWTgLYnXyOgMVF4NUqw.png" alt=""></p><h2 id="基于-kubernetes-架构的问题">基于 Kubernetes 架构的问题</h2><p>这部分问题将涉及到与 Kubernetes 架构相关的问题。</p><p><strong>Q1、Kubernetes Architecture 的不同组件有哪些？</strong></p><p>Kubernetes Architecture 主要有两个组件：主节点和工作节点。</p><p>如下图所示，Master 和 Worker 节点中包含许多内置组件。主节点具有 kube-controller-manager、kube-apiserver、kube-scheduler 等。而工作节点具有在每个节点上运行的 kubelet 和 kube-proxy。</p><p><img src="https://miro.medium.com/max/700/1*AhUFtwKbexYirzGpsig10A.png" alt=""></p><p><strong>Q2、你对 Kube-proxy 有什么了解？</strong></p><p>Kube-proxy 可以在每个节点上运行，并且可以跨后端网络服务进行简单的 TCP/UDP 数据包转发。</p><p>基本上，它是一个网络代理，它反映了每个节点上 Kubernetes API 中配置的服务。因此，Docker 可链接的兼容环境变量由代理打开的群集 IP 和端口提供。</p><p><strong>Q3、您能否介绍一下 Kubernetes 中主节点的工作情况？</strong></p><p>Kubernetes master 控制器存在的节点和节点内部。现在，这些单独的容器包含在容器内部和每个容器内部，您可以根据配置和要求拥有不同数量的容器。</p><p>因此，如果必须部署 Pod，则可以使用用户界面或命令行界面部署它们。然后，在节点上调度这些 Pod，并根据资源需求将 Pod 分配给这些节点。</p><p>Kube-apiserver 确保在 Kubernetes 节点和主要组件之间建立通信。</p><p><img src="https://miro.medium.com/max/700/1*sik3NLZD5_0ZwsVgNfgwSw.png" alt=""></p><p><strong>Q4、Kube-apiserver 和 Kube-scheduler 的作用是什么？</strong></p><p>Kube-apiserver 遵循横向扩展架构，是主节点控制面板的前端。这将公开 Kubernetes 主节点组件的所有 API，并负责在 Kubernetes 节点和 Kubernetes 主组件之间建立通信。</p><p>kube-scheduler 负责工作节点上工作负载的分配和管理。因此，它根据资源需求选择最合适的节点来运行未调度的 Pod，并跟踪资源利用率。它确保不在已满的节点上调度工作负载。</p><p><strong>Q5、你能简要介绍一下 Kubernetes 控制管理器吗？</strong></p><p>多个控制器进程在主节点上运行，但是一起编译为单个进程运行，即 Kubernetes 控制器管理器。因此，Controller Manager 是一个嵌入控制器并执行命名空间创建和垃圾收集的守护程序。它拥有与 API 服务器通信以管理端点的责任。</p><p>因此，主节点上运行的不同类型的控制器管理器是：</p><p><img src="https://miro.medium.com/max/700/1*a80TjjE7oav01nAtfW271A.png" alt=""></p><p><strong>Q6、什么是 Etcd？</strong></p><p>Etcd 是用 Go 编程语言编写的一个分布式键值存储，用于协调分布式工作的软件。因此，Etcd 用来存储 Kubernetes 集群的配置数据，这些数据代表在任何给定时间点的集群状态。</p><p><strong>Q7、Kubernetes 有哪些不同类型的服务？</strong></p><p>以下是使用的不同类型的服务：</p><p><img src="https://miro.medium.com/max/700/1*aiJ1kIkna1MP3Lcy2RqFYw.png" alt=""></p><p><strong>Q8、你对 Kubernetes 的负载均衡器有什么了解？</strong></p><p>负载均衡器是暴露服务的最常见和标准方式之一。</p><p>根据工作环境使用两种类型的负载均衡器，即内部负载均衡器或外部负载均衡器。内部负载均衡器自动平衡负载并使用所需配置分配容器，而外部负载均衡器将流量从外部负载引导至后端容器。</p><p><strong>Q9、什么是 Ingress 网络，它是如何工作的？</strong></p><p>Ingress 网络是一组规则，充当 Kubernetes 集群的入口点。</p><p>这允许入站连接，可以将其配置为通过可访问的 URL 负载平衡流量或通过提供基于名称的虚拟主机从外部提供服务。因此，Ingress 是一个API对象，通常通过 HTTP 管理集群中服务的外部访问，是暴露服务的最有效方式。</p><p>现在，让我以一个例子向您解释 Ingress 网络的工作。</p><p>有 2 个节点具有带有 Linux 桥接器的 Pod 和根网络命名空间。除此之外，还有一个名为 flannel0（网络插件）的新虚拟以太网设备被添加到根网络中。</p><p>现在，假设我们希望数据包从 Pod1 流向 Pod4。请参阅下图：</p><p><img src="https://miro.medium.com/max/700/1*9myghoRGWbV6ReilzUOuuA.png" alt=""></p><ul><li><p>因此，数据包将 Pod1 的网络保留在 eth0，并进入 veth0 的根网络。</p></li><li><p>然后它被传递给 cbr0，这使得 ARP 请求找到目的地，并且发现该节点上没有人具有目的地 IP 地址。</p></li><li><p>因此，桥接器将数据包发送到 flannel0，因为节点的路由表配置了 flannel0。</p></li><li><p>现在，flannel 守护程序与 Kubernetes 的 API 服务器通信，以了解所有 Pod IP 及其各自的节点，以创建 Pods IP 到节点 IP 的映射。</p></li><li><p>网络插件将此数据包封装在 UDP 数据包中，其中额外的标头将源和目标 IP 更改为各自的节点，并通过 eth0 发送此数据包。</p></li><li><p>现在，由于路由表已经知道如何在节点之间路由流量，因此它将数据包发送到目标节点2。</p></li><li><p>数据包到达 node2 的 eth0 并返回到 flannel0 以解封装并在根网络命名空间中将其发回。</p></li><li><p>同样，数据包被转发到 Linux 网桥以发出 ARP 请求以找出属于 veth1 的 IP。</p></li><li><p>数据包最终穿过根网络并到达目标 Pod4。</p></li></ul><p><strong>Q10、您对云控制器管理器有何了解？</strong></p><p>Cloud Controller Manager 负责持久存储、网络路由，从核心 Kubernetes 特定代码中抽象出特定于云的代码，以及管理与底层云服务的通信。</p><p>它可能会分成几个不同的容器，具体取决于您运行的是哪个云平台，然后它可以使云供应商和 Kubernetes 代码在没有任何相互依赖的情况下开发。因此，云供应商开发他们的代码并在运行 Kubernetes 时与 Kubernetes 云控制器管理器连接。</p><p>各种类型的云控制器管理器如下：</p><p><img src="https://miro.medium.com/max/700/1*dDqDw5-B23iyHX1nnmiitQ.png" alt=""></p><p><strong>Q11、什么是 Container 资源监控？</strong></p><p>对于用户而言，了解应用程序的性能和所有不同抽象层的资源利用率非常重要，Kubernetes 通过在容器、Pod、服务和整个集群等不同级别创建抽象来考虑集群的管理。现在，可以监视每个级别，这只是容器资源监视。</p><p>各种容器资源监控工具如下：</p><p><img src="https://miro.medium.com/max/700/1*kKjL4d5289z4f6jwdf9DUw.png" alt=""></p><p><strong>Q12、Replica Set 和 Replication Controller 之间有什么区别？</strong></p><p>Replica Set 和 Replication Controller 几乎完全相同。它们都确保在任何给定时间运行指定数量的 Pod 副本。不同之处在于复制 Pod 使用的选择器。Replica Set 使用基于集合的选择器，而 Replication Controller 使用基于权限的选择器。</p><ul><li><p>Equity-Based 选择器：这种类型的选择器允许按标签键和值进行过滤。因此，在外行术语中，基于 Equity 的选择器将仅查找与标签具有完全相同短语的 Pod。 示例：假设您的标签键表示 app = nginx，那么使用此选择器，您只能查找标签应用程序等于 nginx 的那些 Pod。</p></li><li><p>Selector-Based 选择器：此类型的选择器允许根据一组值过滤键。因此，换句话说，基于 Selector 的选择器将查找已在集合中提及其标签的 Pod。 示例：假设您的标签键在（nginx、NPS、Apache）中显示应用程序。然后，使用此选择器，如果您的应用程序等于任何 nginx、NPS或 Apache，则选择器将其视为真实结果。</p></li></ul><p><strong>Q13、什么是 Headless Service？</strong></p><p>Headless Service 类似于 “普通” 服务，但没有群集 IP。此服务使您可以直接访问 Pod，而无需通过代理访问它。</p><p><strong>Q14、使用 Kubernetes 时可以采取哪些最佳安全措施？</strong></p><p>以下是使用 Kubernetes 时可以遵循的最佳安全措施：</p><p><img src="https://miro.medium.com/max/700/1*YxuRlWza8917nABh6sqw2g.png" alt=""></p><p><strong>Q15、什么是集群联邦？</strong></p><p>在联邦集群的帮助下，可以将多个 Kubernetes 集群作为单个集群进行管理。因此，您可以在数据中心/云中创建多个 Kubernetes集群，并使用联邦来在一个位置控制/管理它们。</p><p>联邦集群可以通过执行以下两项操作来实现此目的。请参考下图。</p><p><img src="https://miro.medium.com/max/700/1*q5lG05884iXhzZfU15gPKA.png" alt=""></p><h2 id="基于场景的面试问题">基于场景的面试问题</h2><p>这部分问题将包含您在面试中可能遇到的各种基于场景的问题。</p><p><strong>场景1</strong></p><p>假设一家基于单一架构的公司处理众多产品。现在，随着公司在当今的扩展行业的扩展，他们的单一架构开始引发问题。</p><p>您如何看待公司从单一服务转向微服务并部署其服务容器？</p><p>解：由于公司的目标是从单一应用程序转向微服务，它们最终可以逐个构建，并行构建，只需在后台切换配置。然后他们可以将这些内置微服务放在 Kubernetes 平台上。因此，他们可以从一次或两次迁移服务开始，并监控它们以确保一切运行稳定。一旦他们觉得一切顺利，他们就可以将其余的应用程序迁移到他们的 Kubernetes 集群中。</p><p><strong>场景2</strong></p><p>考虑一家拥有分布式系统的跨国公司，拥有大量数据中心，虚拟机和许多从事各种任务的员工。</p><p>您认为这样的公司如何以 Kubernetes 一致的方式管理所有任务？</p><p>解：正如我们所有人都知道 IT 部门推出了数千个容器，其任务在分布式系统中遍布全球众多节点。在这种情况下，公司可以使用能够为基于云的应用程序提供敏捷性，横向扩展功能和 DevOps 实践的东西。因此，该公司可以使用 Kubernetes 来定制他们的调度架构并支持多种容器格式。这使得容器任务之间的亲和性成为可能，从而提供更高的效率，并为各种容器网络解决方案和容器存储提供广泛支持。</p><p><strong>场景3</strong></p><p>考虑一种情况，即公司希望通过维持最低成本来提高其效率和技术运营速度。您认为公司将如何实现这一目标？</p><p>解：公司可以通过构建 CI/CD 管道来实现 DevOps 方法，但是这里可能出现的一个问题是配置可能需要一段时间才能启动并运行。因此，在实施 CI/CD 管道之后，公司的下一步应该是在云环境中工作。一旦他们开始处理云环境，他们就可以在集群上安排容器，并可以在 Kubernetes 的帮助下进行协调。这种方法将有助于公司缩短部署时间，并在各种环境中加快速度。</p><p><strong>场景4</strong></p><p>假设一家公司想要修改它的部署方法，并希望建立一个更具可扩展性和响应性的平台。您如何看待这家公司能够实现这一目标以满足客户需求？</p><p>解：为了给数百万客户提供他们期望的数字体验，公司需要一个可扩展且响应迅速的平台，以便他们能够快速地将数据发送到客户网站。现在，要做到这一点，公司应该从他们的私有数据中心（如果他们使用任何）转移到任何云环境，如 AWS。不仅如此，他们还应该实现微服务架构，以便他们可以开始使用 Docker 容器。一旦他们准备好基础框架，他们就可以开始使用最好的编排平台，即 Kubernetes。这将使团队能够自主地构建应用程序并快速交付它们。</p><p><strong>场景5</strong></p><p>考虑一家拥有非常分散的系统的跨国公司，期待解决整体代码库问题。您认为公司如何解决他们的问题？</p><p>解：那么，为了解决这个问题，我们可以将他们的单片代码库转移到微服务设计，然后每个微服务都可以被视为一个容器。因此，所有这些容器都可以在 Kubernetes 的帮助下进行部署和协调。</p><p><strong>场景6</strong></p><p>我们所有人都知道，从单片到微服务的转变解决了开发方面的问题，但却增加了部署方面的问题。公司如何解决部署方面的问题？</p><p>解：团队可以试验容器编排平台，例如：Kubernetes，并在数据中心运行。因此，通过这种方式，公司可以生成模板化应用程序，在五分钟内部署它，并在此时将实际实例集中在暂存环境中。这种 Kubernetes 项目将有数十个并行运行的微服务，以提高生产率，即使节点出现故障，也可以立即重新安排，而不会影响性能。</p><p><strong>场景7</strong></p><p>假设一家公司希望通过采用新技术来优化其工作负载的分配。公司如何有效地实现这种资源分配？</p><p>解：这个问题的解决方案就是 Kubernetes。Kubernetes 确保资源得到有效优化，并且只使用特定应用程序所需的那些资源。因此，通过使用最佳容器编排工具，公司可以有效地实现资源分配。</p><p><strong>场景8</strong></p><p>考虑一家拼车公司希望通过同时扩展其平台来增加服务器数量。您认为公司如何处理服务器及其安装？</p><p>解：公司可以采用集装箱化的概念。一旦他们将所有应用程序部署到容器中，他们就可以使用 Kubernetes 进行编排，并使用像 Prometheus 这样的容器监视工具来监视容器中的操作。因此，利用容器的这种使用，在数据中心中为它们提供更好的容量规划，因为它们现在将受到更少的限制，因为服务和它们运行的​​硬件之间存在抽象。</p><p><strong>场景9</strong></p><p>考虑一种情况，公司希望向具有各种环境的客户提供所有必需的分发。您认为他们如何以动态的方式实现这一关键目标？</p><p>解：该公司可以使用 Docker环境，组建一个横截面团队，使用 Kubernetes 构建 Web 应用程序。这种框架将帮助公司实现在最短的时间内将所需产品投入生产的目标。因此，在这样的机器运行的情况下，公司可以向所有具有各种环境的客户发放电子邮件。</p><p><strong>场景10</strong></p><p>假设公司希望在不同的云基础架构上运行各种工作负载，从裸机到公共云。公司将如何在不同界面的存在下实现这一目标？</p><p>解：该公司可以将其基础设施分解为微服务，然后采用 Kubernetes。这将使公司在不同的云基础架构上运行各种工作负载。</p><h2 id="多项选择面试问题">多项选择面试问题</h2><p>这部分问题将包括多项选择面试问题，这些问题在面试中经常被问到。</p><p><strong>Q1、什么是 Kubernetes 集群中的 minions？</strong></p><ol><li>它们是主节点的组件。</li><li>它们是集群的工作节点。[答案]</li><li>他们正在监控 Kubernetes 中广泛使用的引擎。</li><li>他们是 Docker 容器服务。</li></ol><p><strong>Q2、Kubernetes 集群数据存储在以下哪个位置？</strong></p><ol><li>KUBE-API服务器</li><li>Kubelet</li><li>ETCD [答案]</li><li>以上都不是</li></ol><p><strong>Q3、哪个是 Kubernetes 控制器？</strong></p><ol><li>ReplicaSet</li><li>Deployment</li><li>Rolling Updates</li><li>ReplicaSet和Deployment [答案]</li></ol><p><strong>Q4、以下哪个是核心 Kubernetes 对象？</strong></p><ol><li>Pods</li><li>Services</li><li>Volumes</li><li>以上所有[答案]</li></ol><p><strong>Q5、Kubernetes Network 代理在哪个节点上运行？</strong></p><ol><li>Master Node</li><li>Worker Node</li><li>所有节点[答案]</li><li>以上都不是</li></ol><p><strong>Q6、节点控制器的职责是什么？</strong></p><ol><li>将 CIDR 块分配给节点</li><li>维护节点列表</li><li>监视节点的运行状况</li><li>以上所有[答案]</li></ol><p><strong>Q7、Replication Controller 的职责是什么？</strong></p><ol><li>使用单个命令更新或删除多个 Pod</li><li>有助于达到理想状态</li><li>如果现有 Pod 崩溃，则创建新 Pod</li><li>以上所有[答案]</li></ol><p><strong>Q8、如何在没有选择器的情况下定义服务？</strong></p><ol><li>指定外部名称[答案]</li><li>指定具有 IP 地址和端口的端点</li><li>只需指定 IP 地址即可</li><li>指定标签和 API 版本</li></ol><p><strong>Q9、1.8 版本的 Kubernetes 引入了什么？</strong></p><ol><li>Taints and Tolerations [答案]</li><li>Cluster level Logging</li><li>Secrets</li><li>Federated Clusters</li></ol><p><strong>Q10、Kubelet 调用的处理检查容器的 IP 地址是否打开的程序是？</strong></p><ol><li>HTTPGetAction</li><li>ExecAction</li><li>TCPSocketAction [答案]</li><li>以上都不是</li></ol><p><strong>译者注</strong></p><p>这篇文章不仅仅适合相关的面试者，也非常推荐 Kubernetes 的初学者或者想要了解 Kubernetes 技术的产品或管理者阅读。但是这里面还存在几点不足，例如覆盖的内容较浅显，没有非常具体的技术点，缺少大规模的经验和技术点考察等，有机会后面的文章会补充下！</p><blockquote><p>来源：知乎</p><p>原文：<a href="http://t.cn/Ailr1R3L" target="_blank" rel="noopener">http://t.cn/Ailr1R3L</a></p><p>译文：<a href="http://t.cn/Ailr1BxT" target="_blank" rel="noopener">http://t.cn/Ailr1BxT</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 一直是当今业界的流行语，也是最好的编排工具。它吸引了许多想要提升自己职业生涯的经验丰富的专业人士。&lt;/p&gt;
&lt;p&gt;Huwaei、Pokemon、Box、eBay、Ing、Yahoo Japan、SAP、纽约时报、Open AI、Sound Cloud 等跨国公司也使用 Kubernetes。我相信你已经知道这些事实，这也是促使你打开这个 Kubernetes 面试问题文章原因。&lt;/p&gt;
&lt;p&gt;在这篇关于 Kubernetes 面试问题的文章中，我将讨论在面试中提出的与 Kubernetes 相关的最重要问题。因此，为了您的理解，我将此文内容分为以下 4 个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 基本面试问题&lt;/li&gt;
&lt;li&gt;基于架构的面试问题&lt;/li&gt;
&lt;li&gt;基于场景的面试问题&lt;/li&gt;
&lt;li&gt;多项选择题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，让我们开始吧!&lt;/p&gt;
&lt;h2 id=&quot;基本的-Kubernetes-面试问题&quot;&gt;基本的 Kubernetes 面试问题&lt;/h2&gt;
&lt;p&gt;这部分问题将包含您需要了解的与 Kubernetes 工作相关的所有基本问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q1、Kubernetes 与 Docker Swarm 的区别如何？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/700/1*xzLZVPBlFvLsVPaqtracvw.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2、什么是 Kubernetes？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/321/1*jhzU7LO0pvfMJzrViu6tiA.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 是一个开源容器管理工具，负责容器部署，容器扩缩容以及负载平衡。作为 Google 的创意之作，它提供了出色的社区，并与所有云提供商合作。因此，我们可以说 Kubernetes 不是一个容器化平台，而是一个多容器管理解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q3、Kubernetes 与 Docker 有什么关系？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，Docker 提供容器的生命周期管理和 Docker 镜像构建运行时容器。但是，由于这些单独的容器有时必须跨主机通信，这时我们需要使用 Kubernetes 来解决这个问题。&lt;/p&gt;
&lt;p&gt;因此，我们说 Docker 构建容器，但这些容器通过 Kubernetes 来进行跨主机相互通信。我们还可以使用 Kubernetes 手动关联和编排在多个主机上运行的容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q4、在主机和容器上部署应用程序有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/700/1*R_5hio_I-hK4f-bOfTHstA.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;请参考上图。左侧架构表示在主机上部署应用程序。因此，这种架构将具有操作系统，然后操作系统将具有内核，该内核将在应用程序所需的操作系统上安装各种库。因此，在这种框架中，您可以拥有 N 个应用程序，并且所有应用程序将共享该操作系统中存在的库，而在容器中部署应用程序时，体系结构则略有不同。&lt;/p&gt;
&lt;p&gt;这种架构将有一个内核，这是唯一一个在所有应用程序之间唯一共同的东西。因此，如果有一个需要 Java 的特定应用程序，那么我们将获得访问 Java 的特定应用程序，如果有另一个需要 Python 的应用程序，则只有该特定应用程序才能访问 Python。&lt;/p&gt;
&lt;p&gt;您可以在图表右侧看到的各个块基本上是容器化的，并且这些块与其他应用程序隔离。因此，应用程序具有与系统其余部分隔离的必要库和二进制文件，并且不能被任何其他应用程序侵占。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
</feed>
