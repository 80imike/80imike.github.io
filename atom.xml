<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇妙的 Linux 世界</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2023-01-28T08:18:17.094Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大话 HTTP 协议的前世今生</title>
    <link href="https://www.hi-linux.com/posts/58517.html"/>
    <id>https://www.hi-linux.com/posts/58517.html</id>
    <published>2023-01-28T01:00:00.000Z</published>
    <updated>2023-01-28T08:18:17.094Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>HTTP 全称 Hypertext Transfer Protocol，中文是超文本传输协议。网上讲 HTTP 协议的资料可以说是五花八门，但大多数都在罗列 HTTP 协议具体的规定，很少有讲 HTTP 协议这样设计的原因。今天我就尝试从解决问题的角度分析 HTTP 协议主要特性，希望能帮助大家快速理解 HTTP 协议。</p><p>HTTP 是一种通过网络传输数据的协议。我们不希望数据在传输的过程中出现丢失或者损坏的问题。所以 HTTP 选用 TCP 作为底层网络协议，因为 TCP 是一种可靠的传输层协议。</p><p>通信双方就建立 TCP 连接后立马发现一个新问题：服务端要给客户端发送什么数据呢？所以客户端必需在连接建立后将自己想要的内容发送给服务端，这就是所谓的「请求」，也就 HTTP Request。由此就确立了 HTTP 协议最根本的设计，即由客户端主导的请求应答式协议。</p><a id="more"></a><p>客户端上来就给服务端发了一个「请求」。但服务端有可能收到的内容跟客户端并不完全一样。等等，TCP不是可靠传输协议吗？接收到的数据怎么会不一样？这就涉及到数据分段的问题。比如客户端发送”abcdef”，底层 TCP 协议可能分两次传输 “abc” 和 “def”，也可能分好多次传输。不论分几次，它们的顺序是固定的，跟客户端发送的顺序完全一致。服务端可能会收到多段数据，所以服务端需要把收到的数据「攒」起来，等到客户端的数据全部收到之后才能看到客户端「请求」的全貌。</p><p>那到什么时候算全部收到呢？这是 TCP 通信的一个基本问题。解决这个问题有两个流派：长度流和分隔符流。</p><p>所谓长度流就是在实际发送数据之前，先发送数据的长度。服务端先读取长度信息，然后再根据长度来「攒」后面的数据。那服务端在读取长度的时候不会碰到分段问题吗？其实不会，因为 TCP 只会对比较长的数据做分段。前面说的”abcdef”分两段只是一种极端的例子，实际上很难发生。所以，只要先发送的长度数据不要太长，服务端就能一次性收到。退一步，即便是真的会分段，这类长度流协议都会规定长度数据自身的长度。比如用两个字节表示长度，那范围就是数据长度的范围就是0-65535。服务端可以先收两个字节，然后再根据数据长度来接收后面的内容。</p><p>长度流最大的优点就是实现简单，内存效率高，服务端不用事先分配很多内存。但缺点也比较突出，长度的范围不够灵活。如果我们规定长度字段为两个字节，但就不能传输超过64k的数据。但如果规定长度字段为八个字节，那在传输比较短的数据时就造成浪费。如何设置最优长度字段，大家可以参考我的另一篇<a href="https://taoshu.in/pb-encoding.html" target="_blank" rel="noopener">文章</a>。</p><p>此外，长度流的扩展性也比较差。如果我们想在长度之外传输其他信息，比如数据类型、版本号之类，我们都需要提前规定好这些数据的长度。长度一旦定好，以后就很难扩展了。最典型的长度流协议就是 IP 报文。有兴趣的朋友可以去看看 IP 协议是怎么规定数据长度的。</p><p>有鉴于长度流的不足，人们又搞出了分割符流。简单来说就是用一个特殊的分割符表示数据的结尾。最经典的例子就是C语言的字符串，结尾用<code>\0</code>来表示。使用这个流派的服务端程序要不停地从客户端接收数据，直到收到某一个分割符，就表明已经收到了完整的「请求」。</p><p>因为不需要事先指定数据的长度，所以分割符流派一下子就解决了长度流长度范围不灵活的问题。分割符流派的协议可以接收任意长度的数据。但是，分割符流派为些也付出了代价。因为长度不固定，服务端必须分配比较大的内存或者多次动态分配内存，这会产生比较大的资源消耗。恶意用户可能通过构造很长的数据来占满服务器的内存。</p><p>但是 HTTP 协议还是加入了这个流派，它用的分割符是<code>\r\n</code>。这里的<code>\r</code>表示回车，就是让打印机把打印头回到最左边的位置。<code>\n</code>表示换行，就是让打印机把纸向上挪一行，准备打印新的实符。上古时代的电脑没用现在的液晶屏，用电传打印机来「显示」内容，所以需要传输<code>\r\n</code>两个字符。现在这些都淘汰了，理论上用<code>\n</code>也可以，像 Nginx 就支持只用<code>\n</code>。</p><p>所以，一个最简单的 HTTP 请求长这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;mypage.html\r\n</span><br></pre></td></tr></table></figure><p>这里的<code>GET</code>是一种拟人的说法，从服务拿什么东西。这也是 HTTP <strong>语义化</strong>设计的开端(所谓语义化就是普通人能看懂)。后面跟一个空格，再后面是文件的路径。最后是分割符<code>\r\n</code>。因为最后是<code>\r\n</code>，所以上面的数据也叫请求行(request line)。</p><p>客户端跟服务器建立连接后就立即发送上面的数据。服务端等收到<code>\r\n</code>后开始解析，也就是把<code>/mypage.html</code>提取出来，然后找到对应的文件，把文件内容发送给客户端。</p><p>到这里，客户端就收到了服务端发送的文件内容，也叫「响应」。但是，客户端马上面临服务端同样的问题：如何确定已经收到了 mypage.html 的完整的内容呢？服务端要不要在最后发送分割符<code>\r\n</code>呢？不能！因为 mypage.html 的内容里本身就可能包含<code>\r\n</code>。如果客户端还是以<code>\r\n</code>当作结束标记，那可能会丢失数据。</p><p>为此 Tim Berners-Lee (HTTP 协议之父) 采用了更简单的办法——关闭连接。也就是说，服务器在传输完成之后要主动关闭 TCP 连接，这样客户端就明确知道所有的内容已经传输完成了。</p><p>以上就是最原始的 HTTP 协议，大约在1990发布。现在称这个时代的 HTTP 协议为 HTTP/0.9，主要是跟后面标准化之后的 1.x 进行区分。就这样，万维网的时代开启了。</p><p>HTTP/0.9 发布后得到了广泛的应用。但它的功能太简单了，所以很多浏览器都在它的基础上做了扩展。最主要的扩展功能有如下几个：</p><ul><li>添加版本信息</li><li>添加扩展头信息</li><li>添加返回状态信息</li></ul><p>添加版本信息是为了方便客户端和服务端相互识别，这样才能开启扩展功能。添加之后的请求行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;mypage.html HTTP&#x2F;1.0\r\n</span><br></pre></td></tr></table></figure><p>添加扩展头信息是为了传递更多的扩展信息。比如，这时候不同的浏览器会在请求中标记自己的身份。为方便后续添加各种不同的扩展信息，HTTP协议继续使用「行」和分割符的概念。</p><p>首先，跟请求行保持一致，每一条扩展信息占一行，以冒号分割，以<code>\r\n</code>结尾，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: NCSA_Mosaic&#x2F;2.0 (Windows 3.1)\r\n</span><br></pre></td></tr></table></figure><p>其次，这种信息可以有多行。那服务端怎么确定到底有几行呢，这还得用到分割符<code>\r\n</code>。HTTP 协议用一个空行表示后面扩展信息都结束了。所以完整的请求是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;mypage.html HTTP&#x2F;1.0\r\n</span><br><span class="line">Host: taoshu.in\r\n</span><br><span class="line">User-Agent: NCSA_Mosaic&#x2F;2.0 (Windows 3.1)\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>服务端先接收一行，提取文件路程，然后再根据<code>\r\n</code>逐行提取扩展信息。如果收到一个空行，则说明扩展信息接收完成。</p><p>这些扩展信息也叫头信息(header)，后续 HTTP 协议的各种特性都是基于它来实现。</p><p>HTTP/0.9 收到请求后直接传输文件内容。但用些场景需要返回其他信息，比如文件不存在之类的，所以人们给它添加了返回状态信息。此外，扩展后的 HTTP 协议也支持服务端在发送数据前返回多个头信息。一个典型的扩展响应为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">200 OK\r\n</span><br><span class="line">Date: Tue, 15 Nov 1994 08:12:32 GMT\r\n</span><br><span class="line">Server: CERN&#x2F;3.0 libwww&#x2F;2.17\r\n</span><br><span class="line">Content-Type: image&#x2F;gif\r\n</span><br><span class="line">\r\n</span><br><span class="line">(image content)</span><br></pre></td></tr></table></figure><p>服务器首先会发一行数据<code>200 OK\r\n</code>。这里的<code>200</code>是状态码，表示成功。后面的<code>OK</code>是给人看的语义部分。这一行也叫 status code line。紧接着就是扩展信息，形式跟请求里的一模一样，每行一条，以空行表示结束。最后才是文件内容。</p><p>因为有了头信息，HTTP协议的扩展性直接起飞。人们不断给 HTTP 协议添加各种种样的特性。</p><p>HTTP/0.9 只能传输纯文本文件。因为有了 Header，我们可以传输更多的描述信息，比如文件在的类型、长度、更新时间等等。这些传输数据的描述信息也被称为 Entity Header，数据本身称为 Entiy。</p><p>常见的 Entiy Header 有:</p><ul><li>Content-Type 内容类型</li><li>Content-Length 内容长度</li><li>Content-Encoding 数据编码</li></ul><p>Content-Type 表示数据类型，比如 gif 的类型是<code>image/gif</code>。类型的取值最终被标准化为 Multipurpose Internet Mail Extensions(MIME)。</p><p>Content-Length 表示数据长度。但我们前面说过，HTTP/0.9 的服务器不需要返回文件长度，等传输完毕后关闭 TCP 连接就好了。为什么又要定义长度信息呢？</p><p>这里有两个问题。第一个是在请求里支持上传内容，第二个是连接优化问题。</p><p>HTTP/0.9 只有一种 GET 请求。显然光下载是不够的。人们陆续引入了 HEAD 和 POST 等请求，用来给服务器提交数据。一但要提交数据，光用分割符就不够了。因为提交的数据本身就可能包含分割符。所以需要事先指定数据的长度。这个长度用的就是 Content-Length 头来指定。</p><p>另外一个是连接优化问题。其实 HTTP 协议的发展史很大程度上就是传输性能的优化史。</p><p>HTTP/0.9每次请求都会创建一个 TCP 连接，读取结束后连接就会被关闭。如果一次只下载一个文件也没什么问题。但后来 HTML 页面支持嵌入图片等内容，一个页面可能有多个图片。这样浏览器打开一个 HTML 页面的时候就需要发起多次 HTTP 请求，每次请求都要反复建立和关闭 TCP 连接。不但浪费服务器资源，还会拖慢页面的加载速度。</p><p>所以，大家就想办法复用底层的 TCP 连接。简单来说就是服务器在内容发送完成后不主动关闭连接。但不关闭就会出现前面说的问题，客户端不知道响应内容什么时候传输完毕。所以需要事先指定数据的长度。因为 HTTP 协议已经有了 header 机制，所以添加 Content-Length 就是最自然的办法。</p><p>这里还有一个兼容性问题。如果客户端不支持复用 TCP 连接，那服务端不关闭连接的话客户端就会一直在等待。所以复用 TCP 连接这个功能不能默认开启，而是应该由客户端决定要不要使用。这就引出了<code>Connection:Keep-Alive</code>这个头信息。如果客户在请求中指定 Keep-Alive，服务端才不会主动关闭 TCP 连接。</p><p>除了复用 TCP 连接之外，HTTP/0.9 另一个值得优化的地方就是数据压缩。那个时代网速很慢，如果能把数据压缩之后再传输可以显著降低传输耗时。服务端不能随意压缩，因为有的客户端可能不支持。所以就先引入了<code>Accept-Encoding</code>这个头，可能的取值如<code>compress</code>或者<code>gzip</code>。服务端收到这个请求之后才对内容做压缩。因为浏览器可能支持多种压缩算法，浏览器需要选择一种自己也支持的来压缩数据，所以就需要在返回内容的时候指定自己用了哪种算法。这就是<code>Content-Encoding</code>头的用途。</p><p>不论是前面的 Connection 还是后面的 Accept-Encoding，为了尽可能地兼容不同客户端，HTTP 协议会通过添加新的 header 来协商是否使用扩展特性。<strong>这种协商由客户端来主导</strong>，服务器需要根据客户端的请求来配合完成。</p><p>还是因为网络比较慢而且成本很高，HTTP协议需要进一步优化数据传输效率。一个典型的场景是客户端已经下载过某文件内容。当客户端再次请求的时候，服务端还要不要返回。如果不返回，则客户端拿不到最新的内容；如果返回，当服务端的文件没有变化的时候，客户端会花很长时间加载一个已经下载过的文件。怎么优化这个问题呢？</p><p>人们引入了如下 Entity Header：</p><ul><li>Last-Modified 最近修改时间</li><li>Expires 过期时间</li></ul><p>如果文件不经常改动，服务器可以对过 Last-Modified 把最近修改时间发送给浏览器。浏览器如果支持，可以在下次请求该资源的时候带上这个时间，也就是在请求里添加下面的头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\r\n</span><br></pre></td></tr></table></figure><p>服务器收到后会跟文件的当前修改时间做对比，如果没有修改则直接返回304：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">304 Not Modified\r\n</span><br></pre></td></tr></table></figure><p>这种叫作条件请求，可以显著减少不必要的网络传输。</p><p>即使如此，客户端还是发起一次 HTTP 请求才能拿到 304 响应，也会产生网络传输和服务端开销。为了进一步优化，HTTP又引入了 Expires 头，它的含义是一个未来的过期时间。在这个时间之前浏览器可以安全使用本地缓存的副本，不需要从服务器下载。这样连条件请求都不需要发起了。</p><p>不过 Expires 特性有一个副作用，文件一旦下发，在过期之前根本无法修改。</p><p>大约是在1991-1995这个时间，各浏览器厂商陆续实现了上述功能。但不同浏览器和服务端软件支持的功能不同，带来各种兼容问题。于是到 1996 年，IETF 发布 <a href="https://datatracker.ietf.org/doc/html/rfc1945" target="_blank" rel="noopener">RFC1945</a>。RFC1945 只能说是当前最佳实践的总结，并不是推荐标准。但人们还是称它为 HTTP/1.0。</p><p>没过一年，也就是1997年，IETF就发布了<a href="https://datatracker.ietf.org/doc/html/rfc2068" target="_blank" rel="noopener">RFC2068</a>，也就是大名鼎鼎的 HTTP/1.1 协议规范。</p><p>HTTP/1.1 是对 HTTP/1.0 的梳理和扩展。核心的改动有：</p><ul><li>默认开启 TCP 连接复用，客户端不需要再发送 Connection:Keep-Alive</li><li>添加了所谓 pipeline 特性，进一步优化传输效率</li><li>支持 chunked 传输编码</li><li>扩展缓存控制</li><li>内容协商，包括语言、传输编码、类型等</li><li>在同一IP上建立多个 HTTP 网站</li></ul><p>所谓的 pipeline 特性是对 HTTP 协议传输效率的进一步优化，但最终失败了。</p><p>HTTP 协议是请求应答式协议。客户端发一个请求，然后等待服务端返回内容。虽然在 HTTP/1.0 时代就有了 TCP 连接复用、内容压缩和条件请求等优化机制，但客户端发起新请求之前必须等待服务器返回内容。换言之就是客户端无法在一个连接上并行发起多个请求。为此，HTTP/1.1 的 pipeline 就规定客户端可以依次发起多个 HTTP 请求，然后等待服务器返回结果。服务器需要按照请求顺序依次返回对应的响应内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  c        s              c        s</span><br><span class="line">  |  req1  |              |  req1  |</span><br><span class="line">  |-------&gt;|              |-------&gt;|</span><br><span class="line">  |  resp1 |              |  req2  |</span><br><span class="line">  |&lt;-------|              |-------&gt;|</span><br><span class="line">  |  req2  |              |  req3  |</span><br><span class="line">  |-------&gt;|              |-------&gt;|</span><br><span class="line">  |  resp2 |              |  resp1 |</span><br><span class="line">  |&lt;-------|              |&lt;-------|</span><br><span class="line">  |  req3  |              |  resp2 |</span><br><span class="line">  |-------&gt;|              |&lt;-------|</span><br><span class="line">  |  resp3 |              |  resp3 |</span><br><span class="line">  |&lt;-------|              |&lt;-------|</span><br><span class="line">  </span><br><span class="line">without pipeline         with pipeline</span><br></pre></td></tr></table></figure><p>虽然服务器收到多个请求的时候可以并发处理，这种并发带来的优化有限，而且 pipeline 特性并没有减少实际的网络传输。几乎没有软件实现 pipeline 特性，所以这个优化设计以失败告终。</p><p>chunked 编码是一项非常成功的优化，主要解决服务端动态生成响应内容的情况。</p><p>HTTP/1.0 只能使用 Content-Length 指定内容长度，而且是先发送 header 再发送 body。这就要求必须在传输内容之前确定内容的长度。对于静态文件，这当然不是问题。但如果要加载一个由 PHP 动态渲染的 HTML 就有问题了。因为 HTML 是程序动态生成的，没法事先确定内容长度。如果还用原来的办法，只能先把内容生成好保存到一个临时文件，再发送给客户端。显然这种性能太差。</p><p>为了解决这个问题，HTTP/1.1 引入 chunked 编码。简单来说就是回到之前的长度流，将数据逐段发送给客户端，每一段前面加上长度信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK\r\n</span><br><span class="line">Content-Type: text&#x2F;plain\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line"></span><br><span class="line">7\r\n</span><br><span class="line">Mozilla\r\n</span><br><span class="line">9\r\n</span><br><span class="line">Developer\r\n</span><br><span class="line">7\r\n</span><br><span class="line">Network\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>Transfer-Encoding 指定为 chunked。接下来的数据也是分行传输。一行长度，一行数据。结束的时候长度指定为零，然后再加一个空行。这样服务端就不需要事先确定响应内容的长度，PHP 就可以有边渲染一边发送。这个特性还是 WebSocket 没有普及的年代被用于实现消息推送。大家可以搜索 Comet 或者 HTTP 长轮询了解更多信息。</p><p>HTTP/1.1 对缓存做了更粗细化的定义，引入了 Cache-Control 扩展信息。这一部分内容比较复杂，除了会影响浏览器的缓存行为之外，还会影响 CDN 节点的行为。部分 CDN 厂商还会扩展 标准缓存指令的语义。限于篇幅，在此就不展开了。</p><p>但 HTTP/1.1 对条件请求做了扩展，可以说一下。</p><p>操作系统会自动记录文件的修改时间，读取该时间也非常方便，但 Last-Modified 不能覆盖所有情况。有时候我们需要用程序定时生成某些文件，它的修改时间会周期性变化，但内容不一定有改变。所以光用 Last-Modified 还是可能产生不必要的网络传输。于是 HTTP 协议引入了一个新的头信息 Etag。</p><p>Etag 的语义是根据文件内容计算一个值，只有在修改内容的时候才会产生新的 Etag。客户端每次请求的时候把上一次的 Etag 带回来，也就是添加下面的头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;c3piozzzz&quot;\r\n</span><br></pre></td></tr></table></figure><p>服务端收到后会对比 Etag，只有发生变化的时候才会返回新的文件内容。</p><p>那个时候的网络很不稳定，断网是家常便饭。想想一个文件下载到99%然后断网了是一种怎样的体验。为了减少不必要的数据传输，人们很快就给 HTTP 协议添加了「断点续传」功能。其实断点续传是从客户端视角来看的。从协议角度来看，需要添加的功能是根据指定范围传输数据。也就是说原来的文件是100字节，客户端可以指定只下载最后的10字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes 91-100&#x2F;100\r\n</span><br></pre></td></tr></table></figure><p>这里的<code>91-100</code>表示要下载的范围，后面的100表示整个文件的长度。如果服务器支持，则会返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 206 Partial content\r\n</span><br><span class="line">Date: Wed, 15 Nov 1995 06:25:24 GMT\r\n</span><br><span class="line">Last-modified: Wed, 15 Nov 1995 04:58:08 GMT\r\n</span><br><span class="line">Content-Range: bytes 91-100&#x2F;100\r\n</span><br><span class="line">Content-Length: 10\r\n</span><br><span class="line">Content-Type: image&#x2F;gif\r\n</span><br><span class="line">\r\n</span><br><span class="line">(image data)</span><br></pre></td></tr></table></figure><p>该功能除了用于断点续传外，还可以实现并行下载加速。客户端可以起多个线程，建立多条 TCP 连接，每个线程下载一部分，最后把有的内容连到一直。就这么简单。</p><p>另外，HTTP/1.1 还要求客户端在请求的时候必须发送 Host 头信息。这里面保存着当前请求对应的网站域名。服务器收到请求后会根据 Host 里的域名和请求行里的路径来确定需要返回的内容。这样就能实现在同一个 IP 上搭建不同域名的网站，也就是所谓的虚拟主机。这大大降低了网站的建设成本，对 Web 生态的发展起到了至关重要的作用。</p><p>除了扩展 HTTP/1.0 原来的功能外，HTTP/1.1 还引入了连接升级功能。其实这个功能后面用的不多，但有一个重量级的协议 WebSocket 在用，所以不得不说。</p><p>所以连接升级就是把当前用于 HTTP 会话的 TCP 连接切换到其他协议。以 WebSocket 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: taoshu.in</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>这里把 Connection 设成了 Upgrade，表示希望切换协议。而 Upgrade:websocket 表示要切换到 websocket 协议。在切换之前，这还是一个普通的 HTTP 请求。服务器可以对该请求做各种鉴权等 HTTP 动作。服务器如果接受用户的请求，则会返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>从这一该起，双方就不能在该 TCP 连接上发送 HTTP 协议数据了。因为协议已经切换到 WebSocket。</p><p>从 1999 年开始，到 2015 年 HTTP/2 发布，HTTP 协议有15年的时候没有大的变化。与此同时，互联网蓬勃发展，从 Web 1.0 过渡到 Web 2.0，从 PC 互联网发展到移动互联网，从明文 HTTP 也切换到加密 HTTPS。整个过程 HTTP 协议都发挥了核心作用。这从侧面也说明 HTTP 协议是一种扩展性非常好的协议。</p><p>但 HTTP/1.1 毕竟是九十年代设计的协议。2010年之后，移动互联网兴起，业界希望对 HTTP 的问题做够进一步优化。那还有哪些问题可以优化呢？主要有几个方面：</p><ol><li>协议使用文本格式，传输和解析效率都比较低</li><li>Header 部分信息无法压缩，但现实情况是 Header 体积也不小（比如 cookie）</li><li>无法在单一 TCP 连接上并发请求资源（pipeline 失败了）</li><li>服务端无法主动给客户发送内容</li></ol><p>文本格式其实是 HTTP 的一大特色。我们在调试的时候可以直接使用 telnet 连接服务器，然后用肉眼看服务器的返回结果。但对人类友好的设计对机器一定不友好。HTTP协议使用<code>\r\n</code>作为分割符，双不限制头信息的数量，这必然导致解析的时候需要动态分配内存。而且还要把数字、日期等信息转换成对应的二进制格式，这都需要额外的解析成本。</p><p>HTTP/1.x 支持压缩数据内容，而且使用头信息保存压缩算法。所以就不能用相同的算法压缩头信息了。只能另辟蹊径。</p><p>HTTP/1.1 的 pipeline 已然失败，无法充分复用 TCP 连接。HTTP 从一开始就是请求应答式的设计，服务器没办法主动推送内容到客户端。</p><p>为了解决这几个问题，Google 挟 YouTube 和 Chrome 两大杀器，推出了 SPDY 协议。该协议有两个特点：</p><ol><li>兼容 HTTP 语义</li><li>使用二进行格式传输数据</li></ol><p>SPDY 引入了帧做为最小的传输单位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------+</span><br><span class="line">|                 Length (24)                   |</span><br><span class="line">+---------------+---------------+---------------+</span><br><span class="line">|   Type (8)    |   Flags (8)   |</span><br><span class="line">+-+-------------+---------------+-------------------------------+</span><br><span class="line">|R|                 Stream Identifier (31)                      |</span><br><span class="line">+&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+</span><br><span class="line">|                   Frame Payload (0...)                      ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">                      Figure 1: Frame Layout</span><br></pre></td></tr></table></figure><p>每一帧前三个字节表示数据长度，然后用一个字节表示类型，再用一个字节保存一些扩展标记。然后就是四个字节的 stream ID，最后是真正的数据。这其实就表明 HTTP 协议从分割符流转向了长度流。</p><p>在同一个 TCP 连接上，数据帧可以交替发送，不再受请求应答模式制约。也就是说服务端也可以主动给客户端发消息了。同一个请求的 header 和数据部分也可以分开发送，不再要求先发 header 再发 body。也正是因为数据帧交错传输，同一个会话下的数据需要能关联起来，所以 SPDY 给每一帧添加了 stram ID。换句话说 SPDY 在一个 TCP 连接上虚拟出了多个 stream，每一个 stream 从效果看都是一个 TCP 连接。不同的 HTTP 请求和响应数据可以使用自己的 stream 并发传输，互不影响。这样一下子就解决了上面的一、三和四这三个问题。</p><p>第二个问题比较麻烦。但解决思路也很简单。HTTP/1.x 的头信息都是 K-V 型的，而且都是字符串。这里的 K-V 都很少变化。比如只要是访问我的博客，不论有多少请求，都得发送 <code>Host: taoshu.in</code>。对于这种不变的，我们完全可以在两端各保存一张映射表，给每个 Key 和 Value 都指定一个编号。这样后续的请求只要传 Key 和 Value 的编号就行了，从而实现压缩的效果。单看 Host 可能不觉得有多少进步。但大家想想自己的 cookie，里面有登录会话信息，每次都重复发送浪费相当惊人。所以压缩头信息带来的优化还是惊人的。</p><p>因为谷歌一边控制着市场份额最大的 Chrome 浏览器，另一边又控制像 Google/YouTube 这样的内容服务，所以开发下一代 HTTP 协议便一件非常容易的事情。SPDY 于 2012 年发布，最终在 IETF 完成标准化，并于 2015 年发布，也就是<a href="https://datatracker.ietf.org/doc/html/rfc7540" target="_blank" rel="noopener">RFC7540</a>。</p><p>随着社会的发展，隐私保护成了人们关注的重要课题。为了保护用户信息，业界一真在推动 HTTP + TLS 也就是 HTTPS 的普及。HTTPS 服务使用 443 端口。我们前面讲过，HTTP/2 使用二进制编码，跟 HTTP/1.x 并不兼容。但客户端又不会一夜之间都升级的 HTTP/2。那怎么才能在一个端口上同时支持两种 HTTP 协议呢？这就用到了 TLS 协议的 ALPN 扩展。简单来说就是客户端在发起 TLS 会话的时候会通过 ALPN 扩展附带自己支持的应用层协议，比如 http/1.1 和 h2。服务端收到后会把自己支持的应用层协议返回给客户端。这样双方就能确定接下来在 TLS 会话是使用什么协议。</p><p>理论上 HTTP/2 可以通过 HTTP/1.1 的升级机制来协商，这样也能解决两个版本共用 TLS 会话的问题。但这种升级会再来额外的延迟，所以主流的浏览器都不支持。</p><p>HTTP/2 发布之后，整个业界都在积极迁移到新的协议。但实践证明，HTTP/2并没有想象中的那么好。为什么呢？因为对于同一个域名，浏览器默认只会开一个连接，所有请求都使用一个TCP连接收发。虽然不同的请求使用不同的 stream，但底层的连接只有一个。如果网络出现抖动，不论是哪一个请求的数据需要重传，其他请求的数据都必须等待。这就是所谓的 Head of Line blocking 问题。HTTP/2 非但没有优化，甚至还比 HTTP/1.x 还要差。因为在 HTTP/1.x 时代，浏览器自知 HTTP 无法复用连接，所以会为同一个域名创建多个 TCP 连接。不同的请求可能会分布到不同的连接上，出现网络抖动的影响比只用一个连接要好一点。</p><p>HTTP/2 的另一个问题就是功能太复杂。比如它支持在服务器主动推送资源（比如 CSS 文件）到浏览器，这样客户端在加载的时候就需要等待网络传输。但该功能非常复杂，而且效果有限，最终连 Chrome 自己都放弃支持该功能了。这部分功能被 HTTP 103 Early Hints 状态码代替，具体可以参考<a href="https://www.rfc-editor.org/rfc/rfc8297.html" target="_blank" rel="noopener">RFC8297</a>。</p><p>一计不成，再生一计。谷歌的工程师跟 Head of Line blocking 问题死磕。这次他们把矛头指向了问题的根源 TCP 协议。因为 TCP 是可靠传输协议，数据必须按顺序收发，而且要边确认边发送。如果底层用 TCP 连接，就不可能解决 Head of Line blocking 问题。为此，他们基于 UDP 协议设计了 QUIC 协议。</p><p>QUIC 协议简单来说就是一种面向消息的传输协议（TCP 是面向数据流的传输协议）。QUIC 也有 stream 的概念，每个会话可以有多个流。不同的流的数据都使用 UDP 收发，互不干扰。跟 TCP 一样，数据发出后也需要对方确认。然后再把 QUIC 跟 HTTP/2 的帧映射到一起，最终形成 HTTP/3 协议，也就是<a href="https://datatracker.ietf.org/doc/html/rfc9114" target="_blank" rel="noopener">RFC9114</a>。</p><p>那 QUIC 有没有问题呢？也有，但基本都不是设计上的问题。</p><p>第一个问题就是运营商可能对 UDP 流量做限流，很多防火墙可能会阻止 QUIC 流量。这是之前 UDP 通信使用不广泛导致的。 随着 HTTP/3 技术的普及，这些问题会逐渐改善。</p><p>第二个问题是 HTTP/3 启动延迟的问题。HTTP/3 使用 UDP 通信，跟 HTTP/1.x 和 HTTP/2 不兼容，所以浏览器没法判断服务器是否支持 HTTP/3。</p><p>目前主流的做法是网站同时支持 HTTP/2 和 HTTP/3。浏览器先通过过 TCP 连接访问服务器。服务器在第一个响应中返回一个特殊的 Header：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alt-Svc: h3&#x3D;&quot;:4430&quot;; ma&#x3D;3600</span><br></pre></td></tr></table></figure><p>这里的意思是在 UDP 的 4430 端口提供 HTTP/3 服务，该信息的有效时间为 3600 秒。后面浏览器就可以使用 QUIC 连接 4430 端口了。</p><p>明眼人一看就知道这里有问题，建立 HTTP/3 会话之前还得先用一下 HTTP/2 启动有把。这不科学🔬而且这会带来额外的耗时。为此，人们又开始想别的办法，这就是 DNS SVCB/HTTPS 记录。</p><p>DNS SVCB/HTTPS 简单来说就是用一种特殊的 DNS 记录把前面的 Alt-Svc 信息曝露出来。浏览器在访问网站之前先通过 DNS 查询是否支持 HTTP/3 以及对应的 UDP 端口，然后就直接发起 HTTP/3 会话就好。这样就完全不依赖 TCP 连接了。关于 DNS SVCB/HTTPS 记录的更多信息请看我的专门<a href="https://taoshu.in/dns-svcb-https.html" target="_blank" rel="noopener">文章</a>。</p><p>顺便说一句，HTTP/3 默认可以工作在任意 UDP 端口，不像 HTTPS 那样默认工作在 443 端口。如果运营商封掉 443 就没法对外服务。等 HTTP/3 普及了，所有人都可以使用自家的宽带搭建网站😄具体做法可以参考我的这篇<a href="https://taoshu.in/http3-port.html" target="_blank" rel="noopener">文章</a>。</p><p>好了，到现在快肝了一万字了。我认为基本讲清楚了 HTTP 协议的发展脉络。现于篇幅，没能详细讨论 HTTP/2 和 HTTP/3 的技术细节，不能说不是个遗憾。先开个坑，后面有时间再补上。希望本文能帮助你更好地理解 HTTP 协议。</p><p>参考链接：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP</a></li></ul><blockquote><p>本文转载自：「涛叔」，原文：<a href="https://url.hi-linux.com/Tf6qB%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.hi-linux.com/Tf6qB，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP 全称 Hypertext Transfer Protocol，中文是超文本传输协议。网上讲 HTTP 协议的资料可以说是五花八门，但大多数都在罗列 HTTP 协议具体的规定，很少有讲 HTTP 协议这样设计的原因。今天我就尝试从解决问题的角度分析 HTTP 协议主要特性，希望能帮助大家快速理解 HTTP 协议。&lt;/p&gt;
&lt;p&gt;HTTP 是一种通过网络传输数据的协议。我们不希望数据在传输的过程中出现丢失或者损坏的问题。所以 HTTP 选用 TCP 作为底层网络协议，因为 TCP 是一种可靠的传输层协议。&lt;/p&gt;
&lt;p&gt;通信双方就建立 TCP 连接后立马发现一个新问题：服务端要给客户端发送什么数据呢？所以客户端必需在连接建立后将自己想要的内容发送给服务端，这就是所谓的「请求」，也就 HTTP Request。由此就确立了 HTTP 协议最根本的设计，即由客户端主导的请求应答式协议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="HTTP" scheme="https://www.hi-linux.com/tags/HTTP/"/>
    
      <category term="TCP" scheme="https://www.hi-linux.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>如何快速批量修改 Git 提交记录中的用户信息</title>
    <link href="https://www.hi-linux.com/posts/45540.html"/>
    <id>https://www.hi-linux.com/posts/45540.html</id>
    <published>2023-01-28T01:00:00.000Z</published>
    <updated>2023-01-28T08:18:17.096Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>内网提交需要校验企业邮箱，但有时邮箱设置错误导致 <code>commit</code> 的邮箱有问题，此时可以通过修改已提交记录中的邮箱来修复，无需重新提交。</p><p>经过检索，发现两种方法，分别适用于修改一次和修改多次，引文在最后都有注明。</p><a id="more"></a><h2><span id="修改最近一次提交的邮箱">修改最近一次提交的邮箱</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend --author&#x3D;&quot;NewAuthor &lt;NewEmail@address.com&gt;&quot;</span><br></pre></td></tr></table></figure><h2><span id="批量修改邮箱">批量修改邮箱</span></h2><p>使用该脚本，替换其中 <code>[Your Old Email]</code> <code>[Your New Author Name]</code> <code>[Your New Email]</code> 之后在 git 目录中执行即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">git filter-branch --env-filter &#39;</span><br><span class="line"></span><br><span class="line">an&#x3D;&quot;$GIT_AUTHOR_NAME&quot;</span><br><span class="line">am&#x3D;&quot;$GIT_AUTHOR_EMAIL&quot;</span><br><span class="line">cn&#x3D;&quot;$GIT_COMMITTER_NAME&quot;</span><br><span class="line">cm&#x3D;&quot;$GIT_COMMITTER_EMAIL&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; &#x3D; &quot;[Your Old Email]&quot; ]</span><br><span class="line">then</span><br><span class="line">    cn&#x3D;&quot;[Your New Author Name]&quot;</span><br><span class="line">    cm&#x3D;&quot;[Your New Email]&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; &#x3D; &quot;[Your Old Email]&quot; ]</span><br><span class="line">then</span><br><span class="line">    an&#x3D;&quot;[Your New Author Name]&quot;</span><br><span class="line">    am&#x3D;&quot;[Your New Email]&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export GIT_AUTHOR_NAME&#x3D;&quot;$an&quot;</span><br><span class="line">export GIT_AUTHOR_EMAIL&#x3D;&quot;$am&quot;</span><br><span class="line">export GIT_COMMITTER_NAME&#x3D;&quot;$cn&quot;</span><br><span class="line">export GIT_COMMITTER_EMAIL&#x3D;&quot;$cm&quot;</span><br></pre></td></tr></table></figure><h2><span id="qampa">Q&amp;A</span></h2><ul><li><code>A previous backup already exists in refs/original/</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cannot create a new backup.</span><br><span class="line">A previous backup already exists in refs&#x2F;original&#x2F;</span><br><span class="line">Force overwriting the backup with -f</span><br></pre></td></tr></table></figure><p>出现这一句说明之前曾经执行过 <code>git filter-branch</code> ，在 <code>refs/original/</code> 有一个备份，这个时候只要删掉那个备份即可，删除备份命令为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref -d refs&#x2F;original&#x2F;refs&#x2F;heads&#x2F;master</span><br><span class="line"># 或</span><br><span class="line">$ git filter-branch -f --tree-filter -f &#39;rm -f test&#39; -- --all</span><br></pre></td></tr></table></figure><h2><span id="参考文献">参考文献</span></h2><ul><li><a href="https://blog.csdn.net/diu_brother/article/details/51982993" target="_blank" rel="noopener">git 修改提交作者和邮箱</a></li><li><a href="https://blog.csdn.net/u013202238/article/details/81557710" target="_blank" rel="noopener">git 修改历史提交的用户名和邮箱</a></li></ul><blockquote><p>本文转载自：「Frytea’s Blog」，原文：<a href="https://url.hi-linux.com/MEm0k/" target="_blank" rel="noopener">https://url.hi-linux.com/MEm0k/</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内网提交需要校验企业邮箱，但有时邮箱设置错误导致 &lt;code&gt;commit&lt;/code&gt; 的邮箱有问题，此时可以通过修改已提交记录中的邮箱来修复，无需重新提交。&lt;/p&gt;
&lt;p&gt;经过检索，发现两种方法，分别适用于修改一次和修改多次，引文在最后都有注明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Git" scheme="https://www.hi-linux.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>五分钟带你了解 Web 3.0 与云原生</title>
    <link href="https://www.hi-linux.com/posts/49204.html"/>
    <id>https://www.hi-linux.com/posts/49204.html</id>
    <published>2023-01-28T01:00:00.000Z</published>
    <updated>2023-01-28T08:21:43.416Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="什么是-web-30">什么是 Web 3.0</span></h2><h3><span id="1-概念">1. 概念</span></h3><p>Web 3.0 并不是什么新鲜词，参考<a href="https://zh.wikipedia.org/zh-my/Web3" target="_blank" rel="noopener">维基百科</a>和<a href="https://baike.baidu.com/item/web3.0/4873257" target="_blank" rel="noopener">百度百科</a>上的描述。总结下个人理解。</p><p>Web 3.0 并没有一个非常明确的定义，Web 3.0 概念从 2016 年提出，随着技术的不断变化，一直在调整和延伸其定义。以下列举三个比较说明性的定义：</p><ul><li><p>Netflix 创始人 Reed Hastings 于 2016 年 11 月的 Technet 峰会上提出：Web 1.0 是拨号上网，50K 平均带宽，Web 2.0 是 1M 平均带宽那 Web 3.0 就该是 10M 带宽，全影像的网络，这才感觉像 Web 3.0。</p></li><li><p>以太坊联合创始人 Gavin Wood（加文·伍德）提出的定义：主要与基于区块链的去中心化、加密货币以及非同质化代币有关。Web 3.0 被用来描述互联网潜在的下一阶段，一个运行在“区块链”技术之上的“去中心化”的互联网。</p></li><li><p>美国企业家兼风险投资家诺瓦·斯皮瓦克建议将 Web 3.0 的定义延伸至当前各大技术潮流迈向新的成熟阶段的具体体现：</p><p><strong>无处不联网</strong>：宽带网普及和发展，移动通信设备的互联网介入。(例如：平板电脑)<br><strong>网络计算</strong>：“软件即服务”的商业模型，Web服务互用性，分布式计算，网格计算和效用计算（又称“云端计算”）。<br><strong>开放技术</strong>：开放API和协议，开放数据格式，开源软件平台和开放数据（如创作共用、开放数据许可）。<br><strong>开放身份</strong>：OpenID，开放名声，跨域身份和个人数据。<br><strong>智能网络</strong>：语义网技术比如：资源描述框架，网络本体语言，SWRL，SPARQL，语义应用程序平台和基于声明的数据储备。<br><strong>分布式数据库</strong>：万维数据库（“World Wide Database”，由语义网的技术实现）。<br><strong>智能应用程序</strong>：普通语言的处理，机器学习，机器推理，自主代理。</p></li></ul><a id="more"></a><h3><span id="2-价值">2. 价值</span></h3><p><img src="https://img.hi-linux.com/staticfile/webv1-2-3-2022-09-21-abiIWn.png" alt></p><p>这是比较老的一张图，但很能形象的说明问题：</p><ul><li><p>Web 1.0 下用户无法主动创建内容，不享有网络发言权，只是把传统的纸媒搬上了网络，典型的就是yahoo、新浪、网易这类门户网站，数据的交互是单向的；</p></li><li><p>Web 2.0 时代伴随着智能手机的普及、社交网络的兴起和云计算的发展而到来，所有用户都可以在社交媒体分享自己的所思所想并和他人交互，互联网世界的话语权从商业巨头转移到每一位终端用户手中。典型的就是 Facebook、QQ 这种社交媒体类应用，其是一个“可读+可写”的双向交互时代；</p></li><li><p>Web 3.0 相较 Web 2.0 出现了更多的内容创建者，出现了更多的信息交互。在物联网、人工智能、AR等新技术出现后，在新的概念里就提出了<strong>人与人、物与人、物与物信息交互</strong>，这个对应上面诺瓦·斯皮瓦克提出的无处不联网的概念（万物互联）。其大概率是去中心化，多向交互式的。</p></li></ul><table><thead><tr><th></th><th>web1.0</th><th>web2.0</th><th>web3.0</th></tr></thead><tbody><tr><td>信息互动方式</td><td>只读</td><td>交互</td><td>去中心化</td></tr><tr><td>描述</td><td>网站提供内容，用户阅读内容</td><td>用户可生成内容，与他人、网站交互</td><td>（数字）身份、资产和数据回归个人</td></tr><tr><td>典型代表</td><td>yahoo、新浪等门户网站</td><td>facebook、QQ等社交平台</td><td>各类Dapp</td></tr></tbody></table><p>由于 Web 3.0 的定义还是模糊的，我们只能大致的推断 Web 3.0 应该是如下的架构：</p><p><img src="https://img.hi-linux.com/staticfile/web3-information-2022-09-21-c3Fu8v.png" alt></p><p>Web 1.0 的本质是联合，那么 Web 2.0 的本质就是互动，它让网民更多地参与信息产品的创造、传播和分享，而这个过程是有价值的。Web 2.0 的缺点是没有体现出网民劳动的价值，所以 2.0 很脆弱，缺乏商业价值。Web 3.0 是在 Web 2.0 的基础上发展起来的能够更好地体现网民的劳动价值，并且能够实现价值均衡分配的一种互联网方式。（抖音和头条代表的自媒体时代多少有点这个意思了，实现了网民劳动价值的分配，不过这还是中心化的，另外对于创造的数字资产也未能利用区块链技术实现版权的强保护。）</p><h3><span id="3-生态">3. 生态</span></h3><p>按照普适各种技术的 Web 3.0的定义，在 3D 维度上的 Web 3.0 的生态见下图：</p><p><img src="https://img.hi-linux.com/staticfile/web3-ecology-2022-09-21-8zgIP1.png" alt></p><p>Web 3.0主要辐射的赛道包括 “应用层”、“交互层”、“软件层” 三个维度。其分别对应 “NFT数字藏品、游戏、社交等应用”、“可穿戴设备或者操控设备等硬件设备” 和 “人工智能和操作系统”。</p><p>Web3.0 造富创作者，整个 Web 3.0 生态就是对数据、所有权和用户关系的改革。Web 3.0 能够更明确的确权和分润，即，所有使用内容的用户都需要用虚拟货币或者 NFT 等工具向作者进行 ‘支付’，创作者也保留作品 100% 的所有权。</p><h2><span id="web30-与-云原生">web3.0 与 云原生</span></h2><ul><li>Web 3.0 的基础是云原生和区块链。</li><li>电是电气时代的基础，交流电是电大规模远距离传输的基础。</li><li>云计算是 Web 3.0 的技术基础，云原生是未来云计算的主要表现形式（就像交流电）。</li></ul><p>未来云基础设施是面向应用快速落地的，人们不用再去关心底层是如何实现的。就像有人买了电器，只用关心插上插头能不能用，不会关心电是怎么过来的。不需要再自己生产电，拉电线进到屋子里，这是基础设施，买或租了房子后，天然具备的。（云原生类比 Web 3.0，Web 3.0 就是冰箱、彩电、洗衣机，云原生就是房子里的电插头。）</p><p>在 Web 3.0 时代，云计算会以云原生的方式出现。当电灯出现时，用电的主要目的是照明，后面人们发现电的用途还可以更多，于是出现了冰箱、彩电、洗衣机等家用电器。因为有了电，我们开始创造发明各种终端的用电工具。</p><p>云计算也一样。云计算原本是为数据存储和终端提供平台，但当云计算平台系统和生态建立起来时，大量的应用基于云计算发生。也就是说，云计算的出现会激发更多的基于云计算的应用出现。云计算应用大规模兴起后，数据和计算还在云计算平台。所以，云计算会变成原生的应用平台，帮助元宇宙的应用广泛发展。所以，元宇宙的世界一定是由云计算承载的云原生世界。</p><h2><span id="写在最后">写在最后</span></h2><p>触碰到红利天花板的互联网大厂们已经走到了一个时代的路口，从今年 Facebook(Meta)、腾讯、阿里、美团等大厂下滑的财报数据也能窥见一二。互联网巨头们需要一个新的故事来引领一个新的时代 — Web 3.0。</p><p>Web 3.0 想要较好的发展，需要先解决三个重要的基础设施建设主题——隐私计算、元宇宙和可编程金融，基于这些主题，Web 3.0的内涵和外延能得以不断丰富和拓展，使互联网更加开放、普惠和安全，向更高阶发展。</p><blockquote><p>本文转载自：「 云原生之路 」，原文：<a href="https://url.hi-linux.com/JcHqB" target="_blank" rel="noopener">https://url.hi-linux.com/JcHqB</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Web-3-0&quot;&gt;什么是 Web 3.0&lt;/h2&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;1. 概念&lt;/h3&gt;
&lt;p&gt;Web 3.0 并不是什么新鲜词，参考&lt;a href=&quot;https://zh.wikipedia.org/zh-my/Web3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/web3.0/4873257&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度百科&lt;/a&gt;上的描述。总结下个人理解。&lt;/p&gt;
&lt;p&gt;Web 3.0 并没有一个非常明确的定义，Web 3.0 概念从 2016 年提出，随着技术的不断变化，一直在调整和延伸其定义。以下列举三个比较说明性的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Netflix 创始人 Reed Hastings 于 2016 年 11 月的 Technet 峰会上提出：Web 1.0 是拨号上网，50K 平均带宽，Web 2.0 是 1M 平均带宽那 Web 3.0 就该是 10M 带宽，全影像的网络，这才感觉像 Web 3.0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以太坊联合创始人 Gavin Wood（加文·伍德）提出的定义：主要与基于区块链的去中心化、加密货币以及非同质化代币有关。Web 3.0 被用来描述互联网潜在的下一阶段，一个运行在“区块链”技术之上的“去中心化”的互联网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;美国企业家兼风险投资家诺瓦·斯皮瓦克建议将 Web 3.0 的定义延伸至当前各大技术潮流迈向新的成熟阶段的具体体现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无处不联网&lt;/strong&gt;：宽带网普及和发展，移动通信设备的互联网介入。(例如：平板电脑)&lt;br&gt;
&lt;strong&gt;网络计算&lt;/strong&gt;：“软件即服务”的商业模型，Web服务互用性，分布式计算，网格计算和效用计算（又称“云端计算”）。&lt;br&gt;
&lt;strong&gt;开放技术&lt;/strong&gt;：开放API和协议，开放数据格式，开源软件平台和开放数据（如创作共用、开放数据许可）。&lt;br&gt;
&lt;strong&gt;开放身份&lt;/strong&gt;：OpenID，开放名声，跨域身份和个人数据。&lt;br&gt;
&lt;strong&gt;智能网络&lt;/strong&gt;：语义网技术比如：资源描述框架，网络本体语言，SWRL，SPARQL，语义应用程序平台和基于声明的数据储备。&lt;br&gt;
&lt;strong&gt;分布式数据库&lt;/strong&gt;：万维数据库（“World Wide Database”，由语义网的技术实现）。&lt;br&gt;
&lt;strong&gt;智能应用程序&lt;/strong&gt;：普通语言的处理，机器学习，机器推理，自主代理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="云原生" scheme="https://www.hi-linux.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>实战 Kubernetes 的 hostNetwork 和 NetworkPolicy (网络策略)</title>
    <link href="https://www.hi-linux.com/posts/42597.html"/>
    <id>https://www.hi-linux.com/posts/42597.html</id>
    <published>2023-01-11T01:00:00.000Z</published>
    <updated>2023-01-11T08:39:38.064Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="1-hostnetwork-介绍">1. hostNetwork 介绍</span></h2><blockquote><p>在 k8s 中，若 <strong>pod 使用主机网络</strong>，也就是<code>hostNetwork=true</code>。则该pod会使用主机的dns以及所有网络配置，<strong>默认情况下是无法使用 k8s 自带的 dns 解析服务</strong>，但是可以修改 DNS 策略或者修改主机上的域名解析（<code>/etc/resolv.conf</code>），使主机可以用 k8s 自身的 dns 服务。一般通过 DNS 策略（<code>ClusterFirstWithHostNet</code>）来使用 k8s DNS 内部域名解析，k8s DNS 策略如下：</p></blockquote><ul><li><code>Default</code>： 继承 Pod 所在宿主机的 DNS 设置，hostNetwork 的默认策略。</li><li><code>ClusterFirst（默认DNS策略）</code>：优先使用 kubernetes 环境的 dns 服务，将无法解析的域名转发到从宿主机继承的 dns 服务器。</li><li><code>ClusterFirstWithHostNet</code>：和 ClusterFirst 类似，对于以 <code>hostNetwork</code> 模式运行的 Pod 应明确知道使用该策略。也是可以同时解析内部和外部的域名。</li><li><code>None</code>： 忽略 kubernetes 环境的 dns 配置，通过 spec.dnsConfig 自定义 DNS 配置。</li></ul><a id="more"></a><p>想了解更多的 k8s DNS 可以参考我这篇文章：<a href="https://www.cnblogs.com/liugp/p/16387457.html" target="_blank" rel="noopener">Kubernetes（k8s）DNS（CoreDNS）介绍</a></p><p>一般使用主机网络就增加如下几行即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostNetwork: <span class="literal">true</span></span><br><span class="line">dnsPolicy: <span class="string">"ClusterFirstWithHostNet"</span></span><br></pre></td></tr></table></figure><p><strong>『示例』：<code>hostNetwork.yaml</code></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="comment"># 使用主机网络</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 该设置是使POD使用k8s的dns，dns配置在/etc/resolv.conf文件中</span></span><br><span class="line">      <span class="comment"># 如果不加，pod默认使用所在宿主主机使用的DNS，这样会导致容器</span></span><br><span class="line">      <span class="comment"># 内不能通过service name访问k8s集群中其他POD</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirstWithHostNet</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">metrics</span></span><br><span class="line">          <span class="comment"># 如果hostNetwork: true，hostPort必须跟containerPort一样，所以hostPort一般不写，端口也是占用宿主机上的端口。</span></span><br><span class="line">          <span class="attr">hostPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31280</span></span><br></pre></td></tr></table></figure><p><strong>hostPort 和 NodePort的区别：</strong></p><blockquote><p><code>hostPort</code> 只会在运行机器上开启端口， <code>NodePort</code> 是所有 Node 上都会开启端口。</p></blockquote><ul><li>hostPort 是由 portmap 这个 cni 提供 portMapping 能力，同时如果想使用这个能力，在配置文件中一定需要开启 portmap。</li><li>使用 hostPort 后，会在 iptables 的 nat 链中插入相应的规则，而且这些规则是在 KUBE-SERVICES 规则之前插入的，也就是说会优先匹配 hostPort 的规则，我们常用的 NodePort 规则其实是在 KUBE-SERVICES 之中，也排在其后。</li><li>hostport 可以通过 iptables 命令查看到， 但是无法在 ipvsadm 中查看到。</li><li>使用 lsof/netstat 也查看不到这个端口,这是因为 hostport 是通过 iptables 对请求中的目的端口进行转发的，并不是在主机上通过端口监听。</li><li><strong>在生产环境中不建议使用 hostPort</strong>。</li></ul><h2><span id="2-k8s-网络策略-networkpolicy">2. K8s 网络策略 NetworkPolicy</span></h2><p><img src="https://img.hi-linux.com/staticfile/409c96c58d2f43dabcd61638f24baa71-2022-11-23-j52bB4.png" alt></p><blockquote><p>如果你希望在 IP 地址或端口层面（OSI 第 3 层或第 4 层）控制网络流量， 则你可以考虑为集群中特定应用使用 Kubernetes 网络策略（<code>NetworkPolicy</code>）。 <strong><code>NetworkPolicy</code> 是一种以应用为中心的结构，允许你设置如何允许 Pod 与网络上的各类网络“实体”</strong> 通信。<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/" target="_blank" rel="noopener">官方文档</a></p></blockquote><p>网络策略是通过<strong>网络插件</strong>来实现，常用的网络插件<code>Flannel</code>和<code>Calico</code>：</p><ul><li><code>Flannel</code>：只能提供网络通讯，<strong>不提供网络策略</strong>，如果需要使用网络策略，建议使用下面的 Calico，关于 Flannel 更详细的介绍和安装可以参考我这篇文章：<a href="https://www.cnblogs.com/liugp/p/16388870.html" target="_blank" rel="noopener">Kubernetes（k8s）CNI（flannel）网络模型原理</a>。</li><li><code>Calico</code>：<strong>支持丰富的网络策略</strong>，Calico以其性能、灵活性而闻名。后面也会出相关文章详细介绍 Calico。</li></ul><p>更多了解更多的网络策略，可以参考官方文档：<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a></p><p>Pod 可以通信的 Pod 是通过如下三个标识符的组合来辩识的：</p><ul><li>其他被允许的 Pods（例外：Pod 无法阻塞对自身的访问）</li><li>被允许的名字空间</li><li>IP 组块（例外：与 Pod 运行所在的节点的通信总是被允许的， 无论 Pod 或节点的 IP 地址）</li></ul><h2><span id="3-pod-隔离的两种类型">3. Pod 隔离的两种类型</span></h2><p>Pod 有两种隔离: <strong>出口的隔离</strong>和<strong>入口的隔离</strong>。默认情况下，出口和入口都是非隔离的。</p><ul><li><strong>网络策略是相加的</strong>，所以不会产生冲突。如果策略适用于 Pod 某一特定方向的流量， Pod 在对应方向所允许的连接是适用的网络策略所允许的集合。 因此，评估的顺序不影响策略的结果。</li><li>要允许从源 Pod 到目的 Pod 的连接，源 Pod 的出口策略和目的 Pod 的入口策略都需要允许连接。 如果任何一方不允许连接，建立连接将会失败。</li></ul><h2><span id="4-networkpolicy-资源">4. NetworkPolicy 资源</span></h2><h3><span id="41-networkpolicy-示例演示">4.1 NetworkPolicy 示例演示</span></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-network-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">        <span class="attr">except:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">project:</span> <span class="string">myproject</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">role:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">5978</span></span><br></pre></td></tr></table></figure><p>必需字段：与所有其他的 Kubernetes 配置一样，NetworkPolicy 需要 apiVersion、 kind 和 metadata 字段。关于配置文件操作的一般信息， 请参考配置 Pod 以使用 ConfigMap 和对象管理。</p><ul><li><code>spec</code>：NetworkPolicy 规约 中包含了在一个名字空间中定义特定网络策略所需的所有信息。</li><li><code>podSelector</code>：每个 NetworkPolicy 都包括一个 podSelector， 它对该策略所适用的一组 Pod 进行选择。示例中的策略选择带有 “role=db” 标签的 Pod。 空的 podSelector 选择名字空间下的所有 Pod。</li><li><code>policyTypes</code>：每个 NetworkPolicy 都包含一个 policyTypes 列表，其中包含 Ingress 或 Egress 或两者兼具。policyTypes 字段表示给定的策略是应用于进入所选 Pod 的入站流量还是来自所选 Pod 的出站流量，或两者兼有。 如果 NetworkPolicy 未指定 policyTypes 则默认情况下始终设置 Ingress； 如果 NetworkPolicy 有任何出口规则的话则设置 Egress。</li><li><code>ingress</code>：每个 NetworkPolicy 可包含一个 ingress 规则的白名单列表。 每个规则都允许同时匹配 from 和 ports 部分的流量。示例策略中包含一条简单的规则： 它匹配某个特定端口，来自三个来源中的一个，第一个通过 ipBlock 指定，第二个通过 namespaceSelector 指定，第三个通过 podSelector 指定。</li><li><code>egress</code>：每个 NetworkPolicy 可包含一个 egress 规则的白名单列表。 每个规则都允许匹配 to 和 port 部分的流量。该示例策略包含一条规则， 该规则将指定端口上的流量匹配到 10.0.0.0/24 中的任何目的地。</li></ul><p>所以，该网络策略示例:</p><ul><li>隔离 “default” 名字空间下 “role=db” 的 Pod （如果它们不是已经被隔离的话）。</li><li>（Ingress 规则）允许以下 Pod 连接到 “default” 名字空间下的带有 “role=db” 标签的所有 Pod 的 6379 TCP 端口：<ul><li>“default” 名字空间下带有 “role=frontend” 标签的所有 Pod</li><li>带有 “project=myproject” 标签的所有名字空间中的 Pod</li><li>IP 地址范围为 172.17.0.0–172.17.0.255 和 172.17.2.0–172.17.255.255 （即，除了 172.17.1.0/24 之外的所有 172.17.0.0/16）</li></ul></li><li>（Egress 规则）允许 “default” 命名空间中任何带有标签 “role=db” 的 Pod 到 CIDR 10.0.0.0/24 下 5978 TCP 端口的连接。</li></ul><h3><span id="42-选择器-to-和-from-的行为">4.2 选择器 to 和 from 的行为</span></h3><p>可以在 ingress 的 from 部分或 egress 的 to 部分中指定四种选择器：</p><ul><li><code>podSelector</code>：此选择器将在与 NetworkPolicy 相同的名字空间中选择特定的 Pod，应将其允许作为入站流量来源或出站流量目的地。</li><li><code>namespaceSelector</code>：此选择器将选择特定的名字空间，应将所有 Pod 用作其入站流量来源或出站流量目的地。</li><li><code>namespaceSelector</code> 和 <code>podSelector</code>：一个指定 namespaceSelector 和 podSelector 的 to/from 条目选择特定名字空间中的特定 Pod。 注意使用正确的 YAML 语法；下面的策略：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">      <span class="attr">matchLabels:</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">alice</span></span><br><span class="line">    <span class="attr">podSelector:</span></span><br><span class="line">      <span class="attr">matchLabels:</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">client</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>在 from 数组中仅包含一个元素，只允许来自标有 role=client 的 Pod 且该 Pod 所在的名字空间中标有 user=alice 的连接。但是 这项 策略：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"> <span class="attr">ingress:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">       <span class="attr">matchLabels:</span></span><br><span class="line">         <span class="attr">user:</span> <span class="string">alice</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">       <span class="attr">matchLabels:</span></span><br><span class="line">         <span class="attr">role:</span> <span class="string">client</span></span><br><span class="line"> <span class="string">...</span></span><br></pre></td></tr></table></figure><p>这里只是把官网的摘了一部分，官网介绍的比较清楚，这里就不粘贴复制了，小伙伴可以参考官方文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/</a></p><h2><span id="5总结">5.总结</span></h2><ul><li>在 k8s 上网络策略是<strong>白名单机制</strong>，所谓白名单机制是指，只有明确定义的策略才会被允许放行，默认没有指定的规则就是拒绝的，即条件不匹配的都会被拒绝。</li><li>其次对于 ingress 或 egress 来说，对应的 <code>from</code> 或 <code>to</code> 都是用来指定访问端或被访问端的信息。</li><li>如果我们在对应的字段中<strong>没有定义 namespaceSelector 字段</strong>，<strong>默认 ingress 或 egrss 会匹配当前 netpol 所在名称空间</strong>，即在没有明确指定 namespaceSelector 字段时，对应的其他条件都是针对当前 netpol 所在名称空间。</li><li><strong>多个条件组合</strong>使用，如果多个条件都在一个列表中，则表示多个条件间是与关系，即指定的条件需要同时满足对应策略才会放行。</li><li>如果<strong>多个条件不再同一个列表中</strong>，则多个条件之间是或关系，即满足其中一个条件都会被对应策略放行。</li></ul><blockquote><p>本文转载自：「博客园」，原文：<a href="https://url.hi-linux.com/M2zXe" target="_blank" rel="noopener">https://url.hi-linux.com/M2zXe</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-hostNetwork-介绍&quot;&gt;1. hostNetwork 介绍&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在 k8s 中，若 &lt;strong&gt;pod 使用主机网络&lt;/strong&gt;，也就是&lt;code&gt;hostNetwork=true&lt;/code&gt;。则该pod会使用主机的dns以及所有网络配置，&lt;strong&gt;默认情况下是无法使用 k8s 自带的 dns 解析服务&lt;/strong&gt;，但是可以修改 DNS 策略或者修改主机上的域名解析（&lt;code&gt;/etc/resolv.conf&lt;/code&gt;），使主机可以用 k8s 自身的 dns 服务。一般通过 DNS 策略（&lt;code&gt;ClusterFirstWithHostNet&lt;/code&gt;）来使用 k8s DNS 内部域名解析，k8s DNS 策略如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Default&lt;/code&gt;： 继承 Pod 所在宿主机的 DNS 设置，hostNetwork 的默认策略。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ClusterFirst（默认DNS策略）&lt;/code&gt;：优先使用 kubernetes 环境的 dns 服务，将无法解析的域名转发到从宿主机继承的 dns 服务器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ClusterFirstWithHostNet&lt;/code&gt;：和 ClusterFirst 类似，对于以 &lt;code&gt;hostNetwork&lt;/code&gt; 模式运行的 Pod 应明确知道使用该策略。也是可以同时解析内部和外部的域名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;None&lt;/code&gt;： 忽略 kubernetes 环境的 dns 配置，通过 spec.dnsConfig 自定义 DNS 配置。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>善用 GitHub</title>
    <link href="https://www.hi-linux.com/posts/43115.html"/>
    <id>https://www.hi-linux.com/posts/43115.html</id>
    <published>2022-12-21T01:00:00.000Z</published>
    <updated>2022-12-21T09:37:05.281Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>是微软旗下的一个在线软件源代码托管服务平台，也是一个拥有八千多万开发者用户的社区。很多开发者应该对GitHub有一定的了解，但非技术人员大多可能并不会去使用它。本文更多是想给非技术人员来介绍这个平台，看完这篇文章，希望能让更多人在上面来学习、创作与展示自己的作品。</p><a id="more"></a><h2><span id="github-是好的学习平台">GitHub 是好的学习平台</span></h2><p>GitHub拥有非常多的开源项目，这些开源项目中的一些已经成为了 IT 行业的软件基石，比如<a href="https://github.com/torvalds/linux" target="_blank" rel="noopener">Linux</a>内核项目。</p><p>如果你想学一门软件开发的技术，比如学会用 Python 做一些数据分析，那 GitHub 就是这方面最好的一个学习平台。为什么这么说？</p><p>学习首先是需要找一个好的教程，在 GitHub 上最不缺的就是教程类的项目。以 Python 为例，通过在 GitHub 上搜索，可以很容易找到这个<a href="https://github.com/vinta/awesome-python" target="_blank" rel="noopener">Awesome Python</a>的项目，它收集了很多 Python 相关的教程、项目、库等等，你可以在这个项目中找到你想要的学习资料。而且因为它是一个 Star 数近十五万的明星项目，被很多开发者认可，所以上面推荐的资料质量也是非常高的。</p><p>当然 GitHub 并不完全是英文的，中文资料也很多，不过我还是推荐尽可能使用英文的资料，如果你要走技术之路，英文是必须的。</p><p>找到教程学习后，接下来就是去开发一个真正的项目了。按正常的流程，我们需要在我们的电脑上配置复杂的软件开发环境，就这一步已经让很多人望而却步了。但是在GitHub上，你可以直接在网页上编辑代码，然后提交到 GitHub 上，这样你就可以在任何一台电脑上开发你的项目了。这个功能叫做<a href="https://github.com/features/codespaces" target="_blank" rel="noopener">GitHub Codespaces</a>。</p><p>比如下面就是我在开发的一个开源项目，其是一个基于 Python 的项目，我可以在网页上直接编辑代码，然后提交到 GitHub上。</p><p><img src="https://img.hi-linux.com/staticfile/4XsPCg-2022-11-17-NDYpAf.jpg" alt></p><p>在上图红框部分可以创建一个免费在线的开发环境，打开后就是一个网页版的 VSCode。也就是说 GitHub 给了你一个云端开发环境（一个拥有Root用户权限的Linux系统，可以配置安装任何软件）！这个开发环境可以一直存储在云端，在任何时候打开就可以继续开发，保存在上面的文件也不会被删除。</p><p><img src="https://img.hi-linux.com/staticfile/c96cab40-57fd-8c1c-2db8-60fa489be2db-2022-11-17-XySznz.png" alt></p><p>有时候当你只想阅读其他人的代码时，在 GitHub 网页上按下 <code>.</code> 键就会自动打开一个在线 VSCode 的开发环境，相比网页可以更方面的阅读与搜索代码。</p><p>GitHub 还提供了强大的代码搜索功能，除了在 <code>GitHub.com</code> 上搜索外，还可以在<a href="https://cs.github.com/" target="_blank" rel="noopener">GitHub code search</a>上搜索，这个搜索引擎可以搜索 GitHub 上的所有的公开仓库代码。我觉得它提供了类似<a href="https://sourcegraph.com/search" target="_blank" rel="noopener">sourcegraph</a>的体验，包括更好的代码符号跳转功能。</p><p>在一个浏览器内搞定代码的搜索、阅读与开发功能，我觉得这是非常震撼的，起码在十几年前是不可能的。</p><p>如果你并不想写代码，只想写点文字，GitHub也能给你带来非常好的写作体验。</p><h2><span id="github-是好的写作平台">GitHub 是好的写作平台</span></h2><p>基于<a href="https://www.bmpi.dev/tags/markdown/" target="_blank" rel="noopener">Markdown</a>的写作一直是我推崇的，早在十年前，我在<a href="https://wordpress.com/" target="_blank" rel="noopener">Wordpress</a>上写作，Wordpress 提供了最简单的网站搭建体验，以至于全球有超过四成的网站都是用 Wordpress 搭建的，包括个人博客。但 Wordpress 的搭建还是太麻烦了，虽然现在很多国内的云服务商都提供了一键搭建 Wordpress 的功能，但还是有很多限制，比如不是免费的，需要备案，需要维护服务器等。</p><p>在 GitHub 上写作非常简单，只需要一个 GitHub 账号，然后在 GitHub 上创建一个仓库，然后在仓库里创建一个 Markdown 文件，就可以开始写作了。写作的内容就是 Markdown 格式的文本，GitHub 会自动将 Markdown 转换为 HTML，然后在浏览器上显示出来。</p><p>除了这种方式，还可以使用<a href="https://pages.cloudflare.com/" target="_blank" rel="noopener">Cloudflare Pages</a>，它可以将GitHub仓库里的内容自动部署到 Cloudflare 的 CDN 上，这样就可以使用自定义域名了。</p><p>如果你想要更好的写作体验，还可以使用这个<a href="https://vuepress-theme-hope.github.io/v2/zh/" target="_blank" rel="noopener">vuepress-theme-hope</a>的开源项目，它提供了非常强大的定制能力，使用方式却很简单，比如我用它在 GitHub 上搭建了一个文档网站：<a href="https://dev-notes.free4.chat/" target="_blank" rel="noopener">free4chat开发手记</a>。在每个页面的底部都有一个 <code>在GitHub上编辑此页</code> 的按钮，点击后就可以直接在 GitHub 上修改这个页面，修改后提交，GitHub 会自动重新构建网站，然后你就可以在网站上看到修改后的内容了。</p><p>由于 GitHub 的仓库会自动保存每次修订的历史记录，如果出错也可以回退到之前的版本，再也不担心数据丢失的问题了。</p><p>当然这个博客也是在 GitHub 上搭建的，你可以在这个仓库查看到它的原始文件：<a href="https://github.com/bmpi-dev/bmpi.dev" target="_blank" rel="noopener">bmpi-dev/bmpi.dev</a>。</p><p>如果想给网站添加评论功能，可以使用<a href="https://giscus.app/" target="_blank" rel="noopener">giscus</a>，它会自动将评论保存到 GitHub 仓库的 Discussions 里，这样就不用担心评论数据丢失的问题了。比如本博客的评论数据都在这里：<a href="https://github.com/bmpi-dev/bmpi.dev/discussions/categories/announcements" target="_blank" rel="noopener">bmpi-dev/bmpi.dev/discussions</a>。</p><h2><span id="github-是好的开发平台">GitHub 是好的开发平台</span></h2><p>GitHub 是<strong>最好</strong>的开发平台。从上面的内容相信你可以看出来，GitHub 围绕软件的搜索、阅读与开发体验方面做了很多改进。甚至用一个浏览器就可以完成软件产品的开发、测试与部署。本文不会详细的介绍 GitHub 的全部功能，但以下这些功能是我感觉非常值得尝试的：</p><ul><li><a href="https://github.com/features/codespaces" target="_blank" rel="noopener">GitHub Codespaces</a>：提供一个在线的<a href="https://www.bmpi.dev/dev/vscode-on-cloud/" target="_blank" rel="noopener">云端IDE</a>，可以在浏览器里直接编辑代码，然后在云端编译、运行、调试代码，非常方便。</li><li><a href="https://github.com/features/copilot" target="_blank" rel="noopener">GitHub Copilot</a>：提供一个在线的AI代码自动补全功能，可以根据上下文对你的代码自动补全，甚至包括<a href="https://twitter.com/madawei2699/status/1458313535792955393" target="_blank" rel="noopener">写博客</a>！（这篇文章的一部分就是这个AI小助手自动撰写的，你能看出来吗？）</li><li><a href="https://github.com/features/actions" target="_blank" rel="noopener">GitHub Actions</a>：提供一个 <code>Pipeline as Code</code> 的 <code>CI/CD</code> 服务。比如可以实现，当博客文章更新时，自动发送通知给订阅者，我的博客就实现了类似的功能，具体的实现可以看这个文件：<a href="https://github.com/bmpi-dev/bmpi.dev/blob/master/.github/workflows/gh-pages.yml" target="_blank" rel="noopener">.github/workflows/gh-pages.yml</a>。</li><li><a href="https://github.com/features/packages" target="_blank" rel="noopener">GitHub Packages</a>：提供类似Docker Hub的软件包管理功能。</li></ul><p>最重要的是，这些功能很多都提供了免费的额度，足够日常使用了，你要做的就是去创作，利用<a href="https://www.bmpi.dev/self/how-to-get-rich/#%E9%80%89%E6%8B%A9%E5%B8%A6%E6%9D%A0%E6%9D%86%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">技术杠杆</a>去实现自己的想法。</p><h2><span id="利用-github-打造个人技术影响力">利用 GitHub 打造个人技术影响力</span></h2><p>打造个人技术影响力，可能是很多开发者无偿在 GitHub 上创造各种开源项目的一个主要原因。而技术影响力又可以让开发者能获得更多的机会，比如获得更多的工作机会，影响更多的人等。</p><p>在 GitHub 上你可以找到很多很厉害的人，比如前端大佬<a href="https://github.com/antfu" target="_blank" rel="noopener">antfu</a>，Elixir 的作者<a href="https://github.com/josevalim" target="_blank" rel="noopener">José Valim</a>，通过关注这些人的动态，了解最新的技术趋势，不断提高自己的技术能力。</p><p>GitHub 也是一个很好的技术展示平台，你可以通过创建自己的 GitHub Profile 来展示自己的技术栈，比如我的<a href="https://github.com/madawei2699" target="_blank" rel="noopener">GitHub Profile</a>。也可以用这个工具<a href="https://rahuldkjain.github.io/gh-profile-readme-generator/" target="_blank" rel="noopener">GitHub Profile README Generator</a>来生成自己的 GitHub Profile。</p><p><img src="https://img.hi-linux.com/staticfile/09976689-173e-3fbf-66ca-03ef5a9716df-2022-11-17-ee6Tw1.png" alt></p><h2><span id="基于-github-的生态">基于 GitHub 的生态</span></h2><p>GitHub 的生态系统非常庞大，有很多 SaaS 服务可以与其集成，从而提供完美的开发体验，比如：</p><ul><li><a href="https://www.bmpi.dev/dev/distributed-system/authentication-and-authorization/#%E8%AE%A4%E8%AF%81" target="_blank" rel="noopener">SSO</a>：很多技术网站都提供了 GitHub 的 SSO 集成，尤其是和开发者 SaaS 服务相关的网站，如果要使用这些服务，则必须要有一个 GitHub 账号。</li><li><a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare</a>：全球最流行的 CDN，和 GitHub 集成后，Cloudflare Pages 可以实现自动部署，当代码 push 到 GitHub 后，Cloudflare 会自动将网站发布到 Cloudflare 的全球网络节点中。</li><li><a href="https://vercel.com/" target="_blank" rel="noopener">Vercel</a>：和 Cloudflare Pages 一样，集成 GitHub 后，可以自动部署网站到 Vercel 的 CDN 网络中。我的一些<a href="https://www.bmpi.dev/tool/" target="_blank" rel="noopener">小工具</a>就是部署到 Vercel 上的。</li><li><a href="https://railway.app/" target="_blank" rel="noopener">Railway</a>：提供了后端服务包括数据库的托管，集成 GitHub 后，可以自动部署应用到 Railway 的服务器上。</li></ul><p>这些 SaaS 服务同样都提供了一些免费额度，轻度使用，可以免费做很多小项目。</p><h2><span id="github-next">GitHub Next</span></h2><p><a href="https://githubnext.com/" target="_blank" rel="noopener">GitHub Next</a>正在探索一些能影响软件开发未来的方向，目前有几个方向挺有意思的：</p><ul><li>AI：或者说深度学习模型，正在逐渐的<a href="https://twitter.com/madawei2699/status/1586313511973838848" target="_blank" rel="noopener">改变世界</a>，比如 <code>GitHub Copilot</code> 正是基于深度学习模型来实现代码自动补全的功能。未来基于 <code>GitHub Copilot</code> 的代码重构、写自动化测试、与开发者结对编程也不是不可能的事情，当然让 AI 帮我们写文章，或者合写文章也是一件自然而然的事情。</li><li>语音编程：如果能通过自然语言与 <code>GitHub Copilot</code> 沟通，那编程将会变成搭积木一样的简单，一些基本的功能就可以通过语音来实现，而不需要写代码。这事想想就觉得不可思议，甚至有种托尼·斯塔克与贾维斯对话去制造钢铁侠战甲的感觉。</li><li>协作：由于疫情的出现，远程工作正变得越来越流行（或者说需要），远程结对编写代码目前还没有什么比较好的方式，解决多人如何在同一个代码库实时协作是个有意思的领域。</li><li>可交互文档：虽然 <code>GitHub</code> 现在对 <code>Markdown</code> 的支持已经非常好了，但这种支持还仅限静态的，如何让文档变得可交互，让文档更有表达性，也是一个值得进一步挖掘的方向。</li></ul><p><img src="https://img.hi-linux.com/staticfile/b4ec85ea-e0c8-7713-0d18-dee1797d9e87-2022-11-17-jmUk0e.png" alt></p><p>虽然我注册 <code>GitHub</code> 有很多年了，但逐渐投入越来越多的时间在上面还是在这几年。尤其是这两年来，我愈发觉得GitHub正在逐渐改变软件开发的常规模式，尤其是 <code>GitHub Copilot</code> 的出现，以及一条龙式的开发体验，甚至以后从代码的设计、开发、测试到部署都可以在GitHub网页上完成，这些都是我之前想象不到的。</p><p>希望这篇文章能让读者对 <code>GitHub</code> 有个全新的了解，如果你还没有注册 <code>GitHub</code>，那就赶紧去注册一个吧。</p><blockquote><p>本文转载自：「 构建我的被动收入 」，原文：<a href="https://url.hi-linux.com/iAiiN" target="_blank" rel="noopener">https://url.hi-linux.com/iAiiN</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;是微软旗下的一个在线软件源代码托管服务平台，也是一个拥有八千多万开发者用户的社区。很多开发者应该对GitHub有一定的了解，但非技术人员大多可能并不会去使用它。本文更多是想给非技术人员来介绍这个平台，看完这篇文章，希望能让更多人在上面来学习、创作与展示自己的作品。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="GitHub" scheme="https://www.hi-linux.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>最懂中文的人工智能聊天机器人 ChatGPT 国内用户注册攻略（内附万能接码神技）</title>
    <link href="https://www.hi-linux.com/posts/31674.html"/>
    <id>https://www.hi-linux.com/posts/31674.html</id>
    <published>2022-12-09T01:00:00.000Z</published>
    <updated>2022-12-09T08:12:20.612Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>近日 <code>OpenAI</code> 又发布了一个新玩具「ChatGPT」，一石激起千层浪，很多人开始都加入了对它的热烈讨论当中。就连马斯克也在谈论这个事儿。</p><blockquote><p><code>ChatGPT</code> 是一个训练有素的语言模型，由 <code>OpenAI</code> 公司训练而成。目的是帮助回答问题，提供信息和支持，但不具备人类的感知能力，也不会回答所有问题。 – 以上介绍内容来自 ChatGPT 回答</p></blockquote><a id="more"></a><h2><span id="chatgpt-能做什么">ChatGPT 能做什么</span></h2><p>平时遇到新问题，你一般会怎么找寻答案？很多人的选择主要是问答网站，或者干脆利用自己的社交网络吧？而现在你可以先用 <code>AI</code> 来查查看了，你可以把问题抛给 <code>ChatGPT</code>，告诉它：</p><p><img src="https://img.hi-linux.com/staticfile/1670296059648643-20221208114148030-2022-12-08-5Bt6if.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/1670296067990453-20221208132900257-2022-12-08-SeXulz.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/1670296120964797-2022-12-08-kRzEP9.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/1670296225948232-20221208132852375-2022-12-08-6wlFtE.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/1670296259250217-2022-12-08-HcCvfw.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/1670296270628611-20221208132631640-2022-12-08-FqYrNn.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/1670296285261985-20221208132840907-2022-12-08-r1QJcU.png" alt></p><p>虽然这一切看上去很美，但是因为一些原因，大部分人无法体验到。本文将介绍如何在国内进行 <code>ChatGPT</code> 注册。</p><h2><span id="chatgpt-注册攻略">ChatGPT 注册攻略</span></h2><h3><span id="准备">准备</span></h3><ul><li>首先，你能具备正常上网能力，能够访问谷歌</li><li>其次，你得有一个国外手机号。如果没有，推荐使用 <code>sms-activate</code> 或者 <code>sms-man</code></li></ul><h3><span id="注册短信平台并充值">注册短信平台并充值</span></h3><ul><li>sms-activate</li></ul><blockquote><p>官方网址: <a href="https://sms-activate.org/cn" target="_blank" rel="noopener">https://sms-activate.org/cn</a></p></blockquote><p>完成注册后，进行相应的充值。接码 <code>OpenAI</code> 的一次费用是大概 11 卢布，人民币 1 块钱左右。因为充值默认为美元，可以先充 1 美元。</p><ul><li>sms-man</li></ul><blockquote><p>官方网址：<a href="https://sms-man.com/" target="_blank" rel="noopener">https://sms-man.com/</a></p></blockquote><p>使用 <code>sms-man</code> 接短信验证码，一次只需几美分，失败可退款重试。</p><p>充值有最低值限制，可用于注册各种平台，如 <code>Apple ID</code>， <code>PayPal</code> 等。</p><h3><span id="注册-openai-账号">注册 OpenAI 账号</span></h3><p>打开 <code>ChatGPT</code> 的账户注册页面：<code>https://beta.openai.com/signup</code> 进行相应的注册。你可以用谷歌帐号或者邮箱注册。</p><blockquote><p>注：这里需要你访问公网的 IP 是美国、新加坡、韩国等，不然会提示不能在当前国家服务。</p></blockquote><p>注册成功后，会进入填写手机号页面：</p><p><img src="https://img.hi-linux.com/staticfile/1670295790169397-2022-12-08-hs0NA7.png" alt></p><p>这时，需要在短信验证码平台申请一个国外手机号。这里以 <code>sms-activate</code> 为例。我们在 <code>sms-activate</code> 网站左侧搜索 <code>OpenAI</code> 服务，并选择对应的国家为印度。</p><p><img src="https://img.hi-linux.com/staticfile/1670295819997151-20221208132909031-2022-12-08-IoCNqK.png" alt></p><p>完成手机号购买后，再在上面 <code>OpenAI</code> 网站注册流程的填写手机号码页面填入这里新申请的手机号码，并在这里准备接收短信。</p><p><img src="https://img.hi-linux.com/staticfile/1670295833287760-20221208132915380-2022-12-08-U5nbKa.png" alt></p><p>填完正确验证码后，你就成功完成了 <code>OpenAI</code> 账号注册。</p><blockquote><p>需要注意的是 sms-activate 目前只支持巴西和印度。</p></blockquote><h3><span id="开始使用-chatgpt">开始使用 ChatGPT</span></h3><p>注册完后，我们访问 ChatGPT 官方网站 <code>https://chat.openai.com/auth/login</code> 就可以正常使用了。</p><p>你可以用它帮忙写文章：</p><p><img src="https://img.hi-linux.com/staticfile/202212060931664fbb8483e57edceac-2022-12-08-x5Wxn3.png" alt></p><p>也可以实现常见算法：</p><p><img src="https://img.hi-linux.com/staticfile/20221206093534074dfe18aff23a8fc-2022-12-08-rTjDzU.png" alt></p><blockquote><p>最最后，很明显上面的注册方法对各方面门槛都有一定要求。如果你只是想尝尝鲜，当然也可以使用终极大招：直接在某宝上购买一个帐号即可开始体验。</p></blockquote><h2><span id="参考文档">参考文档</span></h2><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="https://juejin.cn/post/7173447848292253704" target="_blank" rel="noopener">https://juejin.cn/post/7173447848292253704</a></li><li><a href="https://blog.frytea.com/archives/671/" target="_blank" rel="noopener">https://blog.frytea.com/archives/671/</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日 &lt;code&gt;OpenAI&lt;/code&gt; 又发布了一个新玩具「ChatGPT」，一石激起千层浪，很多人开始都加入了对它的热烈讨论当中。就连马斯克也在谈论这个事儿。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ChatGPT&lt;/code&gt; 是一个训练有素的语言模型，由 &lt;code&gt;OpenAI&lt;/code&gt; 公司训练而成。目的是帮助回答问题，提供信息和支持，但不具备人类的感知能力，也不会回答所有问题。 – 以上介绍内容来自 ChatGPT 回答&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="AI" scheme="https://www.hi-linux.com/tags/AI/"/>
    
      <category term="ChatGPT" scheme="https://www.hi-linux.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>关于疫情有感：『日子还要继续，请继续加油』</title>
    <link href="https://www.hi-linux.com/posts/12138.html"/>
    <id>https://www.hi-linux.com/posts/12138.html</id>
    <published>2022-12-06T01:00:00.000Z</published>
    <updated>2022-12-06T09:24:33.357Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最近所在的城市魔幻解封。</p><p>对于网上的各类传言，持观望态度。解封与否，我持中立态度，跟我有关，但不是我所能决定的，我需将注意力放在自己所能决定的事情之上。</p><p>作为一名普通的打工人，我所能做的就是苟住发育，能上工就好好赚钱，需要配合就按照规定来办。我相信大部分事情都能够通过合理正规的手段得到解决，大部份情况下不需要搞特殊化。</p><a id="more"></a><p><strong>我喜欢低头做事，闷头研究，适时抬头仰望，不断积累，与有价值的人来往。</strong></p><p>我不喜欢网络上那些吵吵嚷嚷的事情，这样解决不了问题。摆在台面上，还是需要沉下心来才真能够解决问题。</p><p><strong>不知道明天会是怎样，不求大富大贵，不求顺风顺水，只求劳有所得，努力有所回音。</strong></p><p>这个世界没有想像中的那么好，同样也没有一些人说的那么糟。</p><p>日子还要继续，风雨总会过去，请继续加油。</p><blockquote><p>本文转载自：「Frytea’s Blog」，原文：<a href="https://url.hi-linux.com/LCLze" target="_blank" rel="noopener">https://url.hi-linux.com/LCLze</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近所在的城市魔幻解封。&lt;/p&gt;
&lt;p&gt;对于网上的各类传言，持观望态度。解封与否，我持中立态度，跟我有关，但不是我所能决定的，我需将注意力放在自己所能决定的事情之上。&lt;/p&gt;
&lt;p&gt;作为一名普通的打工人，我所能做的就是苟住发育，能上工就好好赚钱，需要配合就按照规定来办。我相信大部分事情都能够通过合理正规的手段得到解决，大部份情况下不需要搞特殊化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="疫情" scheme="https://www.hi-linux.com/tags/%E7%96%AB%E6%83%85/"/>
    
      <category term="人生" scheme="https://www.hi-linux.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="感悟" scheme="https://www.hi-linux.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linux 下 使用 Progress 显示命令执行进度</title>
    <link href="https://www.hi-linux.com/posts/57106.html"/>
    <id>https://www.hi-linux.com/posts/57106.html</id>
    <published>2022-11-21T01:00:00.000Z</published>
    <updated>2022-11-23T10:06:55.096Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Linux 下的命令高效简洁，但同时很多命令进度显示不是很友好，比如：<code>mv</code>、<code>cp</code>、<code>dd</code> 等命令。</p><p>在没有进度显示的情况下，我们就无法判断是正在执行、还是执行缓慢，<code>Progress</code> 命令很好的解决了这个问题。</p><p>Progress 进度查看器是一个简单的程序，它可用于显示命令的进度。它使用来自文件描述符的信息来确定命令的进度。<code>Progress</code> 的优点在于它可以与其他 <code>Linux</code> 命令一起使用，比如 <code>watch</code>。</p><a id="more"></a><ul><li>Progress 支持的命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp、mv、dd、tar、cat、rsync、grep、fgrep、egrep、cut、sort、md5sum、sha1sum、sha224sum、sha256sum、sha384sum、sha512sum、adb、gzip、gunzip、bzip2、bunzip2、xz、unxz、lzma、unlzma、7z、7za、zcat、bzcat、lzcat、split、gpg、rclone、ffmpeg</span><br></pre></td></tr></table></figure><h2><span id="1-安装-progress">1. 安装 Progress</span></h2><p>项目地址：<a href="https://github.com/Xfennec/progress" target="_blank" rel="noopener">https://github.com/Xfennec/progress</a></p><h3><span id="11-安装编译所需依赖">1.1 安装编译所需依赖</span></h3><ul><li>Debian/Ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 高版本可直接安装 Progress</span><br><span class="line">$ apt install progress</span><br></pre></td></tr></table></figure><ul><li>Centos</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install ncurses-devel</span><br></pre></td></tr></table></figure><h3><span id="12-下载源码">1.2 下载源码</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/Xfennec/progress.git</span><br></pre></td></tr></table></figure><h3><span id="13-编译安装">1.3 编译安装</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd progress</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2><span id="2-progress-使用举例">2. progress 使用举例</span></h2><h3><span id="21-显示默认支持命令的执行进度">2.1 显示默认支持命令的执行进度</span></h3><ul><li>单次显示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ progress</span><br></pre></td></tr></table></figure><ul><li>持续显示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ progress -M</span><br></pre></td></tr></table></figure><h3><span id="22-显示指定命令的执行进度">2.2 显示指定命令的执行进度</span></h3><ul><li>单次显示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ progress -c ffmpeg</span><br></pre></td></tr></table></figure><ul><li>持续显示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ progress -M -c ffmpeg</span><br></pre></td></tr></table></figure><p>如果你想监控其它命令，只需将 <code>ffmpeg</code> 换成你想监控的命令即可。你也可以连续使用多个 <code>-c</code> 同时监控多个命令的执行进度。</p><h3><span id="23-显示指定-pid-的执行进度">2.3 显示指定 PID 的执行进度</span></h3><ul><li>单次显示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ progress -p 进程号</span><br></pre></td></tr></table></figure><ul><li>持续显示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ progress -M -p 进程号</span><br></pre></td></tr></table></figure><ul><li>Progress 一些其它操作方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ watch progress -wq</span><br><span class="line">$ watch progress -wc firefox</span><br><span class="line">$ progress -c httpd</span><br><span class="line">$ cp bigfile newfile &amp; progress -mp $!</span><br></pre></td></tr></table></figure><p>更多监控显示方案可自行组合发掘。</p><blockquote><p>本文转载自：「 Sunsea’s Blog 」，原文：<a href="https://url.hi-linux.com/gT1Y4" target="_blank" rel="noopener">https://url.hi-linux.com/gT1Y4</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 下的命令高效简洁，但同时很多命令进度显示不是很友好，比如：&lt;code&gt;mv&lt;/code&gt;、&lt;code&gt;cp&lt;/code&gt;、&lt;code&gt;dd&lt;/code&gt; 等命令。&lt;/p&gt;
&lt;p&gt;在没有进度显示的情况下，我们就无法判断是正在执行、还是执行缓慢，&lt;code&gt;Progress&lt;/code&gt; 命令很好的解决了这个问题。&lt;/p&gt;
&lt;p&gt;Progress 进度查看器是一个简单的程序，它可用于显示命令的进度。它使用来自文件描述符的信息来确定命令的进度。&lt;code&gt;Progress&lt;/code&gt; 的优点在于它可以与其他 &lt;code&gt;Linux&lt;/code&gt; 命令一起使用，比如 &lt;code&gt;watch&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>善用 GitHub</title>
    <link href="https://www.hi-linux.com/posts/43115.html"/>
    <id>https://www.hi-linux.com/posts/43115.html</id>
    <published>2022-11-20T01:00:00.000Z</published>
    <updated>2022-11-23T10:06:55.098Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>是微软旗下的一个在线软件源代码托管服务平台，也是一个拥有八千多万开发者用户的社区。很多开发者应该对GitHub有一定的了解，但非技术人员大多可能并不会去使用它。本文更多是想给非技术人员来介绍这个平台，看完这篇文章，希望能让更多人在上面来学习、创作与展示自己的作品。</p><a id="more"></a><h2><span id="github-是好的学习平台">GitHub 是好的学习平台</span></h2><p>GitHub拥有非常多的开源项目，这些开源项目中的一些已经成为了 IT 行业的软件基石，比如<a href="https://github.com/torvalds/linux" target="_blank" rel="noopener">Linux</a>内核项目。</p><p>如果你想学一门软件开发的技术，比如学会用 Python 做一些数据分析，那 GitHub 就是这方面最好的一个学习平台。为什么这么说？</p><p>学习首先是需要找一个好的教程，在 GitHub 上最不缺的就是教程类的项目。以 Python 为例，通过在 GitHub 上搜索，可以很容易找到这个<a href="https://github.com/vinta/awesome-python" target="_blank" rel="noopener">Awesome Python</a>的项目，它收集了很多 Python 相关的教程、项目、库等等，你可以在这个项目中找到你想要的学习资料。而且因为它是一个 Star 数近十五万的明星项目，被很多开发者认可，所以上面推荐的资料质量也是非常高的。</p><p>当然 GitHub 并不完全是英文的，中文资料也很多，不过我还是推荐尽可能使用英文的资料，如果你要走技术之路，英文是必须的。</p><p>找到教程学习后，接下来就是去开发一个真正的项目了。按正常的流程，我们需要在我们的电脑上配置复杂的软件开发环境，就这一步已经让很多人望而却步了。但是在GitHub上，你可以直接在网页上编辑代码，然后提交到 GitHub 上，这样你就可以在任何一台电脑上开发你的项目了。这个功能叫做<a href="https://github.com/features/codespaces" target="_blank" rel="noopener">GitHub Codespaces</a>。</p><p>比如下面就是我在开发的一个开源项目，其是一个基于 Python 的项目，我可以在网页上直接编辑代码，然后提交到 GitHub上。</p><p><img src="https://img.hi-linux.com/staticfile/4XsPCg-2022-11-17-NDYpAf.jpg" alt></p><p>在上图红框部分可以创建一个免费在线的开发环境，打开后就是一个网页版的 VSCode。也就是说 GitHub 给了你一个云端开发环境（一个拥有Root用户权限的Linux系统，可以配置安装任何软件）！这个开发环境可以一直存储在云端，在任何时候打开就可以继续开发，保存在上面的文件也不会被删除。</p><p><img src="https://img.hi-linux.com/staticfile/c96cab40-57fd-8c1c-2db8-60fa489be2db-2022-11-17-XySznz.png" alt></p><p>有时候当你只想阅读其他人的代码时，在 GitHub 网页上按下 <code>.</code> 键就会自动打开一个在线 VSCode 的开发环境，相比网页可以更方面的阅读与搜索代码。</p><p>GitHub 还提供了强大的代码搜索功能，除了在 <code>GitHub.com</code> 上搜索外，还可以在<a href="https://cs.github.com/" target="_blank" rel="noopener">GitHub code search</a>上搜索，这个搜索引擎可以搜索 GitHub 上的所有的公开仓库代码。我觉得它提供了类似<a href="https://sourcegraph.com/search" target="_blank" rel="noopener">sourcegraph</a>的体验，包括更好的代码符号跳转功能。</p><p>在一个浏览器内搞定代码的搜索、阅读与开发功能，我觉得这是非常震撼的，起码在十几年前是不可能的。</p><p>如果你并不想写代码，只想写点文字，GitHub也能给你带来非常好的写作体验。</p><h2><span id="github-是好的写作平台">GitHub 是好的写作平台</span></h2><p>基于<a href="https://www.bmpi.dev/tags/markdown/" target="_blank" rel="noopener">Markdown</a>的写作一直是我推崇的，早在十年前，我在<a href="https://wordpress.com/" target="_blank" rel="noopener">Wordpress</a>上写作，Wordpress 提供了最简单的网站搭建体验，以至于全球有超过四成的网站都是用 Wordpress 搭建的，包括个人博客。但 Wordpress 的搭建还是太麻烦了，虽然现在很多国内的云服务商都提供了一键搭建 Wordpress 的功能，但还是有很多限制，比如不是免费的，需要备案，需要维护服务器等。</p><p>在 GitHub 上写作非常简单，只需要一个 GitHub 账号，然后在 GitHub 上创建一个仓库，然后在仓库里创建一个 Markdown 文件，就可以开始写作了。写作的内容就是 Markdown 格式的文本，GitHub 会自动将 Markdown 转换为 HTML，然后在浏览器上显示出来。</p><p>除了这种方式，还可以使用<a href="https://pages.cloudflare.com/" target="_blank" rel="noopener">Cloudflare Pages</a>，它可以将GitHub仓库里的内容自动部署到 Cloudflare 的 CDN 上，这样就可以使用自定义域名了。</p><p>如果你想要更好的写作体验，还可以使用这个<a href="https://vuepress-theme-hope.github.io/v2/zh/" target="_blank" rel="noopener">vuepress-theme-hope</a>的开源项目，它提供了非常强大的定制能力，使用方式却很简单，比如我用它在 GitHub 上搭建了一个文档网站：<a href="https://dev-notes.free4.chat/" target="_blank" rel="noopener">free4chat开发手记</a>。在每个页面的底部都有一个 <code>在GitHub上编辑此页</code> 的按钮，点击后就可以直接在 GitHub 上修改这个页面，修改后提交，GitHub 会自动重新构建网站，然后你就可以在网站上看到修改后的内容了。</p><p>由于 GitHub 的仓库会自动保存每次修订的历史记录，如果出错也可以回退到之前的版本，再也不担心数据丢失的问题了。</p><p>当然这个博客也是在 GitHub 上搭建的，你可以在这个仓库查看到它的原始文件：<a href="https://github.com/bmpi-dev/bmpi.dev" target="_blank" rel="noopener">bmpi-dev/bmpi.dev</a>。</p><p>如果想给网站添加评论功能，可以使用<a href="https://giscus.app/" target="_blank" rel="noopener">giscus</a>，它会自动将评论保存到 GitHub 仓库的 Discussions 里，这样就不用担心评论数据丢失的问题了。比如本博客的评论数据都在这里：<a href="https://github.com/bmpi-dev/bmpi.dev/discussions/categories/announcements" target="_blank" rel="noopener">bmpi-dev/bmpi.dev/discussions</a>。</p><h2><span id="github-是好的开发平台">GitHub 是好的开发平台</span></h2><p>GitHub 是<strong>最好</strong>的开发平台。从上面的内容相信你可以看出来，GitHub 围绕软件的搜索、阅读与开发体验方面做了很多改进。甚至用一个浏览器就可以完成软件产品的开发、测试与部署。本文不会详细的介绍 GitHub 的全部功能，但以下这些功能是我感觉非常值得尝试的：</p><ul><li><a href="https://github.com/features/codespaces" target="_blank" rel="noopener">GitHub Codespaces</a>：提供一个在线的<a href="https://www.bmpi.dev/dev/vscode-on-cloud/" target="_blank" rel="noopener">云端IDE</a>，可以在浏览器里直接编辑代码，然后在云端编译、运行、调试代码，非常方便。</li><li><a href="https://github.com/features/copilot" target="_blank" rel="noopener">GitHub Copilot</a>：提供一个在线的AI代码自动补全功能，可以根据上下文对你的代码自动补全，甚至包括<a href="https://twitter.com/madawei2699/status/1458313535792955393" target="_blank" rel="noopener">写博客</a>！（这篇文章的一部分就是这个AI小助手自动撰写的，你能看出来吗？）</li><li><a href="https://github.com/features/actions" target="_blank" rel="noopener">GitHub Actions</a>：提供一个 <code>Pipeline as Code</code> 的 <code>CI/CD</code> 服务。比如可以实现，当博客文章更新时，自动发送通知给订阅者，我的博客就实现了类似的功能，具体的实现可以看这个文件：<a href="https://github.com/bmpi-dev/bmpi.dev/blob/master/.github/workflows/gh-pages.yml" target="_blank" rel="noopener">.github/workflows/gh-pages.yml</a>。</li><li><a href="https://github.com/features/packages" target="_blank" rel="noopener">GitHub Packages</a>：提供类似Docker Hub的软件包管理功能。</li></ul><p>最重要的是，这些功能很多都提供了免费的额度，足够日常使用了，你要做的就是去创作，利用<a href="https://www.bmpi.dev/self/how-to-get-rich/#%E9%80%89%E6%8B%A9%E5%B8%A6%E6%9D%A0%E6%9D%86%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">技术杠杆</a>去实现自己的想法。</p><h2><span id="利用-github-打造个人技术影响力">利用 GitHub 打造个人技术影响力</span></h2><p>打造个人技术影响力，可能是很多开发者无偿在 GitHub 上创造各种开源项目的一个主要原因。而技术影响力又可以让开发者能获得更多的机会，比如获得更多的工作机会，影响更多的人等。</p><p>在 GitHub 上你可以找到很多很厉害的人，比如前端大佬<a href="https://github.com/antfu" target="_blank" rel="noopener">antfu</a>，Elixir 的作者<a href="https://github.com/josevalim" target="_blank" rel="noopener">José Valim</a>，通过关注这些人的动态，了解最新的技术趋势，不断提高自己的技术能力。</p><p>GitHub 也是一个很好的技术展示平台，你可以通过创建自己的 GitHub Profile 来展示自己的技术栈，比如我的<a href="https://github.com/madawei2699" target="_blank" rel="noopener">GitHub Profile</a>。也可以用这个工具<a href="https://rahuldkjain.github.io/gh-profile-readme-generator/" target="_blank" rel="noopener">GitHub Profile README Generator</a>来生成自己的 GitHub Profile。</p><p><img src="https://img.hi-linux.com/staticfile/09976689-173e-3fbf-66ca-03ef5a9716df-2022-11-17-ee6Tw1.png" alt></p><h2><span id="基于-github-的生态">基于 GitHub 的生态</span></h2><p>GitHub 的生态系统非常庞大，有很多 SaaS 服务可以与其集成，从而提供完美的开发体验，比如：</p><ul><li><a href="https://www.bmpi.dev/dev/distributed-system/authentication-and-authorization/#%E8%AE%A4%E8%AF%81" target="_blank" rel="noopener">SSO</a>：很多技术网站都提供了 GitHub 的 SSO 集成，尤其是和开发者 SaaS 服务相关的网站，如果要使用这些服务，则必须要有一个 GitHub 账号。</li><li><a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare</a>：全球最流行的 CDN，和 GitHub 集成后，Cloudflare Pages 可以实现自动部署，当代码 push 到 GitHub 后，Cloudflare 会自动将网站发布到 Cloudflare 的全球网络节点中。</li><li><a href="https://vercel.com/" target="_blank" rel="noopener">Vercel</a>：和 Cloudflare Pages 一样，集成 GitHub 后，可以自动部署网站到 Vercel 的 CDN 网络中。我的一些<a href="https://www.bmpi.dev/tool/" target="_blank" rel="noopener">小工具</a>就是部署到 Vercel 上的。</li><li><a href="https://railway.app/" target="_blank" rel="noopener">Railway</a>：提供了后端服务包括数据库的托管，集成 GitHub 后，可以自动部署应用到 Railway 的服务器上。</li></ul><p>这些 SaaS 服务同样都提供了一些免费额度，轻度使用，可以免费做很多小项目。</p><h2><span id="github-next">GitHub Next</span></h2><p><a href="https://githubnext.com/" target="_blank" rel="noopener">GitHub Next</a>正在探索一些能影响软件开发未来的方向，目前有几个方向挺有意思的：</p><ul><li>AI：或者说深度学习模型，正在逐渐的<a href="https://twitter.com/madawei2699/status/1586313511973838848" target="_blank" rel="noopener">改变世界</a>，比如 <code>GitHub Copilot</code> 正是基于深度学习模型来实现代码自动补全的功能。未来基于 <code>GitHub Copilot</code> 的代码重构、写自动化测试、与开发者结对编程也不是不可能的事情，当然让 AI 帮我们写文章，或者合写文章也是一件自然而然的事情。</li><li>语音编程：如果能通过自然语言与 <code>GitHub Copilot</code> 沟通，那编程将会变成搭积木一样的简单，一些基本的功能就可以通过语音来实现，而不需要写代码。这事想想就觉得不可思议，甚至有种托尼·斯塔克与贾维斯对话去制造钢铁侠战甲的感觉。</li><li>协作：由于疫情的出现，远程工作正变得越来越流行（或者说需要），远程结对编写代码目前还没有什么比较好的方式，解决多人如何在同一个代码库实时协作是个有意思的领域。</li><li>可交互文档：虽然 <code>GitHub</code> 现在对 <code>Markdown</code> 的支持已经非常好了，但这种支持还仅限静态的，如何让文档变得可交互，让文档更有表达性，也是一个值得进一步挖掘的方向。</li></ul><p><img src="https://img.hi-linux.com/staticfile/b4ec85ea-e0c8-7713-0d18-dee1797d9e87-2022-11-17-jmUk0e.png" alt></p><p>虽然我注册 <code>GitHub</code> 有很多年了，但逐渐投入越来越多的时间在上面还是在这几年。尤其是这两年来，我愈发觉得GitHub正在逐渐改变软件开发的常规模式，尤其是 <code>GitHub Copilot</code> 的出现，以及一条龙式的开发体验，甚至以后从代码的设计、开发、测试到部署都可以在GitHub网页上完成，这些都是我之前想象不到的。</p><p>希望这篇文章能让读者对 <code>GitHub</code> 有个全新的了解，如果你还没有注册 <code>GitHub</code>，那就赶紧去注册一个吧。</p><blockquote><p>本文转载自：「 构建我的被动收入 」，原文：<a href="https://url.hi-linux.com/iAiiN" target="_blank" rel="noopener">https://url.hi-linux.com/iAiiN</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;是微软旗下的一个在线软件源代码托管服务平台，也是一个拥有八千多万开发者用户的社区。很多开发者应该对GitHub有一定的了解，但非技术人员大多可能并不会去使用它。本文更多是想给非技术人员来介绍这个平台，看完这篇文章，希望能让更多人在上面来学习、创作与展示自己的作品。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="GitHub" scheme="https://www.hi-linux.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>互联网时代的大容量数据备份方案</title>
    <link href="https://www.hi-linux.com/posts/16568.html"/>
    <id>https://www.hi-linux.com/posts/16568.html</id>
    <published>2022-11-15T01:00:00.000Z</published>
    <updated>2022-11-18T12:25:09.888Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="0前言">0.前言</span></h2><p>在互联网时代之前，“数据”这个概念似乎并不算抽象。无论是文字、照片还是磁带光盘，想要对他们进行备份不外乎复印、拷贝和储存这些手段。然而进入互联网时代之后（或者说是计算机时代），“数据”这一概念慢慢的开始抽象起来，不再与实体相关联。与此同时，数据的持久化储存也不再像往日那般依靠物理的方式来进行，转而便成了0和1的组合在各种存储介质中流动。</p><p>然而各类存储介质故障的不可预知性让人们开始重新审视数据备份这件小事。俗话说鸡蛋不要放在同一个篮子里，对于备份而言亦是如此。无论本地如何进行备份和冗余，一份远程副本都是非常必要的。本文将尝试收集市面较为知名的存储服务商，并进行比较以供参考。考虑到稳定性、隐私等方面的原因，国内网盘类服务商将不予考虑。</p><p>本文与所提及的任何服务商均无利益关系，请放心食用。相关价格均为常规正价，不含闪促、秒杀等。</p><a id="more"></a><h2><span id="1国内对象存储">1.国内·对象存储</span></h2><p>有关于什么是对象存储，之前的<a href="https://roov.org/2021/11/backup-nas-using-cos/" target="_blank" rel="noopener">这篇文章</a>中已经有过介绍，这里便不再重复说明。通常而言对象存储类服务的计费模式为：容量费用+操作费用+下载费用。对于个人数据备份而言，操作费用几乎可以忽略。而下载费用本文中按照5年全量取回一次的价格，均摊到月来计算。</p><p>由于国内服务商各类型的促销活动较多，实际成本可能更低。</p><h3><span id="11-腾讯云cos">1.1 腾讯云COS</span></h3><p><img src="https://img.hi-linux.com/staticfile/16a166fd39131aa120eae50ab366697b970ac4b444b0-So1nR8-20221116120602037-2022-11-16-v7m4lc.webp" alt></p><p><a href="https://cloud.tencent.com/act/cps/redirect?redirect=10042&amp;cps_key=25c451b71f39a37c7941e062fc1fb2f3" target="_blank" rel="noopener">链接直达</a>（含AFF）</p><p>腾讯云 COS 目前国内涵盖了北京、上海，广州等七个地域以及海外的十三个地域，不过国内和海外为分别计费。存储等级分为：标准、低频，归档和深度归档等，价格依次降低。但除标准存储外，其他等级均有额外的数据取回费用和一定的存储限制，具体可以参见官网。</p><p>按照预先购买标准存储资源包的存储成本：</p><ul><li>500G：￥39.53/月，￥42.32/月（五年全量取回一次平均到月，下同）</li><li>1T：￥79.75/月，￥85.25/月</li><li>2T：￥157.08/月，￥167.91/月</li><li>5T：￥386.66/月，￥413.33/月</li></ul><h3><span id="12-阿里云oss">1.2 阿里云OSS</span></h3><p><img src="https://img.hi-linux.com/staticfile/aliyun-2022-11-16-u1qNxE.webp" alt></p><p><a href="https://www.aliyun.com/product/oss?userCode=pmweg1o2" target="_blank" rel="noopener">链接直达</a>（含AFF）</p><p>阿里云 OSS 同样也是国内和国外地域分别计费，存储等级分为：标准、低频，归档以及冷归档。与腾讯云 COS 不同，阿里云允许用户在本地冗余和同城冗余之间进行选择，相应的价格也有少许差别。</p><p>按照预先购买标准存储（本地冗余）资源包的存储成本：</p><ul><li>500G：￥54/月，￥58.12/月（五年全量取回一次平均到月，下同）</li><li>1T：￥111/月，￥118.92/月</li><li>2T：￥221/月，￥236.5/月</li><li>5T：￥523/月，￥562.58/月</li></ul><h3><span id="13-京东云">1.3 京东云</span></h3><p><img src="https://img.hi-linux.com/staticfile/nIVAgx-2022-11-16-7Vkj2r.jpg" alt></p><p><a href="https://www.jdcloud.com/cn/products/object-storage-service" target="_blank" rel="noopener">链接直达</a>（不含AFF）</p><p>京东云对象存储目前仅有国内四个地域，但是兼容 S3 协议，与各类 NAS 系统和同步软件都能良好适配。</p><p>预付费资源包没有单独的 1T ，2T 选项，故直接按照 500G 的倍率来计算。</p><ul><li>500G：￥56/月，￥59.22/月（五年全量取回一次平均到月，下同）</li><li>1T：￥112/月，￥118.43/月</li><li>2T：￥224/月，￥236.83/月</li><li>5T：￥550/月，￥582.17/月</li></ul><h3><span id="14-百度云">1.4 百度云</span></h3><p><img src="https://img.hi-linux.com/staticfile/cloudbaidu-20221116120607418-2022-11-16-HcXATX.webp" alt></p><p><a href="https://cloud.baidu.com/product/bos.html" target="_blank" rel="noopener">链接直达</a>（不含AFF）</p><p>此处所提到的百度云并非“百度云盘”，而是百度智能云所提供的对象存储 BOS 服务。百度云 BOS 也兼容 S3 协议。考虑到综合口碑和声誉，个人不推荐。</p><p>需要注意百度云 BOS 的预付费资源包各地域不通用，需要单独购买。</p><ul><li>500G：￥53.8/月，￥57.8/月（五年全量取回一次平均到月，下同）</li><li>1T：￥110/月，￥118.18/月</li><li>2T：￥220/月，￥236.37/月</li><li>5T：￥550/月，￥590.92/月</li></ul><h3><span id="15-小结">1.5 小结</span></h3><p>作为面向商业用户为主的对象存储服务，在国内的商业环境下总体价格并不便宜，价格完全无法与面向个人用户为主的网盘相比较。但在稳定性、速度、可靠性方面对象存储无疑是远超各种网盘的。对于个人用户而言，500G 以内的备份需求可以首选考虑国内厂商的对象存储服务，在成本可控的前提下获得最好的速度和体验。</p><p>腾讯云无论是预付费资源包还是按量计费的价格均显著低于其他厂商，建议可以优先考虑。</p><h2><span id="2国外对象存储">2.国外对象存储</span></h2><p>虽然国外服务商的对象存储服务在速度上无法和国内相提并论，但价格更加亲民，可谓是便宜大碗。并且不像国内厂商喜欢玩各种促销套路，一般直接明盘实价。考虑到速度上的短板，价格高于 $10/TB 每月的本文就不做收录了。</p><p>以下服务商均兼容 S3 协议。</p><h3><span id="21-backblaze-b2">2.1 Backblaze B2</span></h3><p><img src="https://img.hi-linux.com/staticfile/JFlJmD-2022-11-16-qcixZJ.jpg" alt></p><p><a href="https://www.backblaze.com/b2/cloud-storage.html" target="_blank" rel="noopener">链接直达</a>（不含AFF）</p><p>老牌数据服务商 Backblaze 很多人应该都不陌生，他每年都会发布自己的硬盘统计报告。Backblaze B2 便是其下的对象存储服务，有美国西海岸和荷兰两个存储地域，用户在注册时会自动进行分配。</p><p>如果使用 Cloudflare CDN 进行数据下载、取回则流量费为0。</p><ul><li>存储：$0.005/GB/Month 下载：$0.01/GB</li><li>500G：$2.5/月，$2.58/月（五年全量取回一次平均到月，下同）</li><li>1T：$5/月，$5.17/月</li><li>2T：$10/月，$10.33/月</li><li>5T：$25/月，$25.83/月</li></ul><h3><span id="22-wasabi">2.2 Wasabi</span></h3><p><img src="https://img.hi-linux.com/staticfile/Wasabi_Logo-1-2022-11-16-hgOSK5.webp" alt></p><p><a href="https://wasabi.com/cloud-storage-pricing/#three-info" target="_blank" rel="noopener">链接直达</a>（不含AFF）</p><p>Wasabi 是一家成立于2017年的美国公司，目前估值超过11亿美元。其对象存储服务在北美、欧洲，亚太各有四个地域可选，但价格略有波动。</p><p>Wasabi 对下载流量执行有限免费模式：每月的下载量如果不超过数据总储量是可被接受的，反之则可能会被限制或暂停服务。除此之外 Wasabi 还有最短储存期限为90天的限定，即存储 1GB 随即删除也会被收取90天 * 1GB 的存储费用。</p><ul><li>存储：$0.0059 GB/mo（北美、欧洲）$0.0068 GB/mo（亚太）</li><li>500G：$2.95/月，$3.4/月（亚太，下同）</li><li>1T：$5.99/月，$6.99/月</li><li>2T：$11.98/月，$13.98/月</li><li>5T：$29.95/月，$34.95/月</li></ul><h3><span id="23-scaleway">2.3 Scaleway</span></h3><p><img src="https://img.hi-linux.com/staticfile/csbh2-122f8-20221116120624790-2022-11-16-mTZv9Z.png" alt></p><p><a href="https://www.scaleway.com/en/object-storage/" target="_blank" rel="noopener">链接直达</a>（不含AFF）</p><p>Scaleway 前身为 <a href="http://online.net" target="_blank" rel="noopener">online.net</a> ，是一家1999年成立于法国的公司，主营业务有计算和存储等。其对象存储服务目前仅有欧洲的三个地域可选，但低频存储等级（Scaleway Glacier）不额外收取取回费用，也没有最短存储时间限制。但申请取回最长需要等待24小时。</p><ul><li>存储：€0.0127/GB/month（标准）€0.002/GB/month（低频）</li><li>500G：$6.35/月，$1/月（低频，下同）</li><li>1T：$12.7/月，$2/月</li><li>2T：$25.4/月，$4/月</li><li>5T：$63.5/月，$10/月</li></ul><h3><span id="24-ovh">2.4 OVH</span></h3><p><img src="https://img.hi-linux.com/staticfile/OVH-Logo-2022-11-16-M5wsQy.webp" alt></p><p><a href="https://www.ovhcloud.com/en-au/public-cloud/object-storage/" target="_blank" rel="noopener">链接直达</a>（不含AFF）</p><p>虽然之前经历了机房起火事件，不过 OVH 的业务似乎并没有受到多大影响。其下对象存储服务仅提供法国地域，价格未含税。</p><ul><li>存储：$0.008 /month/GB（标准）下载：$0.011 /GB</li><li>500G：$4/月，$4.09/月（五年全量取回一次平均到月，下同）</li><li>1T：$8/月，$8.18/月</li><li>2T：$16/月，$16.37/月</li><li>5T：$40/月，$40.92/月</li></ul><h3><span id="25-小结">2.5 小结</span></h3><p>部分国外服务商的对象存储服务价格确实不错，如果数据量大或者担心隐私问题的话也可以考虑。</p><h2><span id="3国外存储类产品">3.国外存储类产品</span></h2><p>除了对象存储之外，这里也收集列出一些存储类的产品作为对比和参考。其中部分产品可能并不是为数据备份所设计，本身并没有冗余和高可靠性，需要多加留意。</p><h3><span id="31-hetzner">3.1 Hetzner</span></h3><p><img src="https://img.hi-linux.com/staticfile/ChdrpN-2022-11-16-f0Swit.jpg" alt></p><p><a href="https://www.hetzner.com/storage/storage-box" target="_blank" rel="noopener">链接直达</a>（不含AFF）</p><p>Hetzner 旗下专门的存储类产品有两个，分别是 <a href="https://roov.org/2022/02/hetzner-storage-box-review/" target="_blank" rel="noopener">Storage box</a> 和 Storage share 。前者 reizhi 之前有做过评测，性价比相当出众。后者则更多的是面向多人团队协作共享，价格稍高一些。</p><p>以下为 Storage box 的价格：</p><ul><li>1T：$3.2/月</li><li>5T：$10.9/月</li></ul><p>如果你恰巧财力雄厚而又需要巨量的存储容量，也可以考虑拍卖服务器。通常 4x10TB 服务器价格在51欧元附近，即便组 RAID5 后单位容量价格依然无可匹敌。</p><h3><span id="32-microsoft-365-family">3.2 Microsoft 365 Family</span></h3><p><img src="https://img.hi-linux.com/staticfile/Untitled-Header-1-2022-11-16-IZLbH6.webp" alt></p><p><a href="https://www.microsoft.com/en-us/microsoft-365/p/microsoft-365-family/cfq7ttc0k5dm" target="_blank" rel="noopener">链接直达</a>（不含AFF）</p><p>Microsoft 365 前身是 Office 365，其中家庭方案价格为$9.99/月，支持创建6个子账号，每个子账号拥有 1TB OneDrive 容量。除此之外还带有 Office 三件套授权，如果正好有需要的话还是非常划算的。</p><p>Onedrive 官方客户端虽然不怎么好用，但好在可以通过 rclone 进行挂载，在 Linux 下使用也很方便。唯独不方便的是 6TB 需要拆分到六个账号，无法一号独占。</p><h3><span id="33-google-workspace">3.3 Google workspace</span></h3><p><img src="https://img.hi-linux.com/staticfile/VFC7iD-2022-11-16-BpDtYM.jpg" alt></p><p><a href="https://workspace.google.com/intl/tr/" target="_blank" rel="noopener">链接直达</a>（不含AFF）</p><p>Google workspace 是 Google 旗下的云协作办公解决方案，其中随附的一项功能便是 Google Drive。由于里拉汇率走低，土耳其区企业标准版 workspace 的价格目前相当不错。但未来是否能够继续保持低价位尚不可知。</p><ul><li>商务标准版：₺94/2TB，发文时约合$5.05</li><li>企业标准版：₺156/5TB，发文时约合$8.38</li></ul><h3><span id="34-各类存储vps">3.4 各类存储VPS</span></h3><p><img src="https://img.hi-linux.com/staticfile/33U3Fu-2022-11-16-CZckXK.jpg" alt></p><p>如果使用 VPS 进行数据备份则需要使用者具有一定的 Linux 操作知识，门槛相对较高。此外 VPS 服务本身的稳定性难以和大型厂商的云服务相提并论，仅少量收录但并不作为推荐。</p><p>当然，有能力的话也可以使用 MinIO 自行搭建多机灾备对象存储系统。</p><ul><li>hosthatch: $5/1TB/month $9/2TB/month $20/5TB/month</li><li>servarica: $10/3TB/month</li><li>leveloneservers: $4.25/1TB/month $8.5/2TB/month</li><li>time4vps: €3.99/1TB/month €6.49/2TB/month</li><li>buyvm: $5/1TB/month $10/2TB/month （单独存储块价格）</li><li>等等</li></ul><h3><span id="35-小结">3.5 小结</span></h3><p>第三部分所提到的服务商除了各类 VPS 之外，也都算是行业巨头。虽然网盘本身并不对数据安全做任何保证，但根据以往历史经验来看应该不存在特别高的风险，对于个人备份来说问题不大。此外 Onedrive 和 Google Drive 都支持通过 rclone 对接，无论 NAS 还是 Linux 均可以比较方便的接入。</p><h2><span id="4总结">4.总结</span></h2><p>对于个人用户而言异地备份的选择依据无非两点：使用成本和易用性（包括连接速度），而前者与存储容量直接相关。根据对备份容量的需求，reizhi 个人给出如下建议：</p><ul><li>100 ~ 500G ：如不排斥国内服务商直接选择腾讯云即可，如果遇到活动大促，年付或半年付还能够以更低的价格成交；</li><li>500G ~ 1T：容量从 500G 往上之后国外对象存储服务的价格开始显现出优势，建议可以优先考虑 Backblaze，Hetzner 可以作为备选。</li><li>2T ~ 5T：以目前的汇率来计算 Google workspace 无疑是最优选择，但缺点是国内无法直连，需要科学。Microsoft 365 可以作为备选，但多账号需要切换略为不便。</li><li>5T 以上：这应该超出了个人用户正常所需的备份容量范围，但如果确实有需要的话，可以考虑 Scaleway Glacier。</li></ul><blockquote><p>本文转载自：「 reizhi 」，原文：<a href="https://url.hi-linux.com/NyGpo" target="_blank" rel="noopener">https://url.hi-linux.com/NyGpo</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;0.前言&lt;/h2&gt;
&lt;p&gt;在互联网时代之前，“数据”这个概念似乎并不算抽象。无论是文字、照片还是磁带光盘，想要对他们进行备份不外乎复印、拷贝和储存这些手段。然而进入互联网时代之后（或者说是计算机时代），“数据”这一概念慢慢的开始抽象起来，不再与实体相关联。与此同时，数据的持久化储存也不再像往日那般依靠物理的方式来进行，转而便成了0和1的组合在各种存储介质中流动。&lt;/p&gt;
&lt;p&gt;然而各类存储介质故障的不可预知性让人们开始重新审视数据备份这件小事。俗话说鸡蛋不要放在同一个篮子里，对于备份而言亦是如此。无论本地如何进行备份和冗余，一份远程副本都是非常必要的。本文将尝试收集市面较为知名的存储服务商，并进行比较以供参考。考虑到稳定性、隐私等方面的原因，国内网盘类服务商将不予考虑。&lt;/p&gt;
&lt;p&gt;本文与所提及的任何服务商均无利益关系，请放心食用。相关价格均为常规正价，不含闪促、秒杀等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="备份" scheme="https://www.hi-linux.com/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>12 个超好用网站在线测速、路由追踪和 Ping 工具</title>
    <link href="https://www.hi-linux.com/posts/29415.html"/>
    <id>https://www.hi-linux.com/posts/29415.html</id>
    <published>2022-11-09T01:00:00.000Z</published>
    <updated>2022-11-16T03:38:20.964Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>我们在日常的建站中，经常要用到对网站加载速度测试服务。如遇到服务器自身的故障或是网络问题，可能还需要要对服务器的 IP 进行 Ping 测试或是进行路由追踪。</p><p>这篇文章我们就分享一些国内外比较好用的服务器和网站在线测速和 Ping 工具，主要是以国内的在线工具为主。国外的有一些在线测速工具提供了国内节点的也汇集在内，主要功能就是电信、联通和移动三网在线 Ping 响应、网页加载速度测试和服务器 IP 路由追踪。</p><p><img src="https://img.hi-linux.com/staticfile/cesu-gongju_00-680x366.png-2022-10-31-5EwRzy.webp" alt></p><a id="more"></a><h2><span id="1-chinaz-站长工具">1. Chinaz 站长工具</span></h2><blockquote><p>网址：<a href="https://ping.chinaz.com" target="_blank" rel="noopener">https://ping.chinaz.com</a></p></blockquote><p>Chinaz 站长工具提供了 Ping 检测、国内测速、国际测速、网站速度对比，国内测速有电信、多线、联通、移动等。</p><p><img src="https://img.hi-linux.com/staticfile/cesu-gongju_01.png-20221031160918137-2022-10-31-sDdYQe.webp" alt></p><h2><span id="2pingpe"></span></h2><blockquote><p>网址：<a href="https://ping.pe" target="_blank" rel="noopener">https://ping.pe</a></p></blockquote><p><a href="http://Ping.PE" target="_blank" rel="noopener">Ping.PE</a> 是国外一个专注于 Ping 响应监控的在线网页工具，国内与国外的节点都有，但是国内的节点比较少。</p><p><img src="https://img.hi-linux.com/staticfile/cesu-gongju_02.png-20221031160810757-2022-10-31-ra5Mm0.webp" alt></p><h2><span id="3-17ce">3. 17CE</span></h2><blockquote><p>网址：<a href="https://www.17ce.com/" target="_blank" rel="noopener">https://www.17ce.com/</a></p></blockquote><p>17CE 是国内一个专业的测速在线工具，有 Get、Ping 和路由追踪测速，测速的结果还是比较靠谱的。</p><p><img src="https://img.hi-linux.com/staticfile/cesu-gongju_03.png-20221031160924983-2022-10-31-fgbMp5.webp" alt></p><h2><span id="4-pagespeedinsights">4. PageSpeedInsights</span></h2><blockquote><p>网址：<a href="https://developers.google.com/speed/pagespeed/insights" target="_blank" rel="noopener">https://developers.google.com/speed/pagespeed/insights</a></p></blockquote><p>PageSpeedInsights 是谷歌开发的一个在线分析网页加载速度的工具，优势在于可以帮助你快速找到拖慢网页打开速度的文件，并且提出符合要求的优化建议，缺点就是国内打不开，适合国外的网站使用。</p><p><img src="https://img.hi-linux.com/staticfile/cesu-gongju_04.png-20221031160825209-2022-10-31-jVsVdp.webp" alt></p><h2><span id="5-ipipnet">5. </span></h2><blockquote><p>网址：<a href="https://tools.ipip.net/ping.php" target="_blank" rel="noopener">https://tools.ipip.net/ping.php</a></p></blockquote><p>基于 <a href="http://IPIP.net" target="_blank" rel="noopener">IPIP.net</a> 的 IP 库的在线 ping 和路由追踪服务，特点是 IP 比较精准。</p><p><img src="https://img.hi-linux.com/staticfile/cesu-gongju_05.png-20221031160829640-2022-10-31-NTCKqu.webp" alt></p><h2><span id="6-阿里云网站运维检测平台">6. 阿里云网站运维检测平台</span></h2><blockquote><p>网址：<a href="https://zijian.aliyun.com/detect/http/" target="_blank" rel="noopener">https://zijian.aliyun.com/detect/http/</a></p></blockquote><p>阿里云网站运维检测平台包括了 HTTP 检测、Ping 检测、DNS 检测、路由追踪检测。可以分地区，例如：东北、华南、华北、华东、华中、西南、西北，运营商分为电信、联通、移动等。</p><p><img src="https://img.hi-linux.com/staticfile/cesu-gongju_06.png-20221031160835384-2022-10-31-NvsYvv.webp" alt></p><h2><span id="7-boce">7. BOCE</span></h2><blockquote><p>网址：<a href="https://www.boce.com" target="_blank" rel="noopener">https://www.boce.com</a></p></blockquote><p>BOCE 提供了网站测速、 PING 检测、 DNS 查询、 路由跟踪查询、 IPv6 检测等，可以指定运营商节点：电信 、移动 、联通 、教育网等，提供的节点还是挺多的。</p><p><img src="https://img.hi-linux.com/staticfile/cesu-gongju_07.png-20221031160931578-2022-10-31-cyVjgc.webp" alt></p><h2><span id="8-webkaka">8. Webkaka</span></h2><blockquote><p>网址：<a href="http://www.webkaka.com/" target="_blank" rel="noopener">http://www.webkaka.com/</a></p></blockquote><p>Webkaka 是一个老牌的在线网站测试工具了，页面比较难看，而且广告也巨大，优点就是 Webkaka 提供了测速节点比较多，包括了国内网站测速、全球网站测速、本地网站测速、网站速度诊断、网站优化工具、Ping 测试、路由追踪、DNS 查询等等。</p><p><img src="https://img.hi-linux.com/staticfile/cesu-gongju_8.png-20221031160848094-2022-10-31-yfyx6C.webp" alt></p><h2><span id="9-爱站网-ping">9. 爱站网 Ping</span></h2><blockquote><p>网址：<a href="https://ping.aizhan.com/" target="_blank" rel="noopener">https://ping.aizhan.com/</a></p></blockquote><p>爱站网提供的一个比较简单的在线 Ping 工具。</p><p><img src="https://img.hi-linux.com/staticfile/cesu-gongju_9.png-20221031160858650-2022-10-31-yo1I0T.webp" alt></p><h2><span id="10-dotcom-tools">10. Dotcom-Tools</span></h2><blockquote><p>网址：<a href="https://www.dotcom-tools.com/website-speed-test" target="_blank" rel="noopener">https://www.dotcom-tools.com/website-speed-test</a></p></blockquote><p>Dotcom-Tools Website Speed Test 是一个国外的网站测速和在线 Ping 工具，虽然是一个国外的网站，但是测速的节点有国内的，在全球有三十多个测速节点。</p><p><img src="https://img.hi-linux.com/staticfile/cesu-gongju_10.png-2022-10-31-wZe3OW.webp" alt></p><h2><span id="11-it狗">11. IT狗</span></h2><blockquote><p>网址：<a href="https://www.itdog.cn/" target="_blank" rel="noopener">https://www.itdog.cn/</a></p></blockquote><p>IT 狗为用户提供在线 Ping、在线 tcping、在线路由追踪、域名被墙检测、域名被污染检测等实用工具。IT 狗 Ping 工具可持续的进行一段时间的 Ping 测试，并生成更为直观的网络质量柱状图，让用户更容易掌握服务器在各地区、各线路的网络状态。</p><p>路由追踪工具相比其他同类网站，通过多线程处理方式，可更快速，更准确的获取测试结果（平均 5秒 返回结果），返回的数据中，除了原生的路由记录，还包含节点的 PTR 记录、IP 地理位置、IP 所属 AS 号，IP 所属 AS 信息。</p><p><img src="https://img.hi-linux.com/staticfile/itdog.png-20221031160904827-2022-10-31-B6xeYD.webp" alt></p><h2><span id="12-pingsx">12、</span></h2><blockquote><p>网址：<a href="https://ping.sx/ping" target="_blank" rel="noopener">https://ping.sx/ping</a></p></blockquote><p>这是一家国外的 Ping 检测网站，有国内多个地方的节点，同时包含了大量的国外节点。</p><p><img src="https://img.hi-linux.com/staticfile/pingsx.png-20221031160909980-2022-10-31-vWXdLI.webp" alt></p><blockquote><p>本文转载自：「挖站否」，原文：<a href="https://url.hi-linux.com/LR6dX" target="_blank" rel="noopener">https://url.hi-linux.com/LR6dX</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在日常的建站中，经常要用到对网站加载速度测试服务。如遇到服务器自身的故障或是网络问题，可能还需要要对服务器的 IP 进行 Ping 测试或是进行路由追踪。&lt;/p&gt;
&lt;p&gt;这篇文章我们就分享一些国内外比较好用的服务器和网站在线测速和 Ping 工具，主要是以国内的在线工具为主。国外的有一些在线测速工具提供了国内节点的也汇集在内，主要功能就是电信、联通和移动三网在线 Ping 响应、网页加载速度测试和服务器 IP 路由追踪。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/cesu-gongju_00-680x366.png-2022-10-31-5EwRzy.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅关闭与重启生产级 Kubernetes 集群</title>
    <link href="https://www.hi-linux.com/posts/17602.html"/>
    <id>https://www.hi-linux.com/posts/17602.html</id>
    <published>2022-11-09T01:00:00.000Z</published>
    <updated>2022-11-16T03:38:20.962Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="前言">前言</span></h2><p>在日常对 Kubernetes 集群运行维护的过程中，您可能需要临时的关闭或者是重启 Kubernetes 集群对集群进行维护，本文将介绍如何去安全的关闭 K8s 集群以及如何重新启动集群。</p><h2><span id="日常节点运维方式">日常节点运维方式</span></h2><p>关闭 K8s 集群是个危险的操作！在关闭集群之前，您必须完全了解这个操作所带来的后果。首先，我们要对集群内的应用、客户定义资源 CRD 和 Etcd 进行备份，然后再进行重启或关闭集群的操作。在通常运维的情况下，建议您驱逐维护节点，而非重启整个集群。在这里，我们也把驱逐维护节点命令放在下面供您参考。</p><a id="more"></a><p>首先，确定想要移出的节点的名称。可以用以下命令列出集群中的所有节点:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br></pre></td></tr></table></figure><p>接下来，告诉 Kubernetes 需要移出的节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl drain &lt;node name&gt;</span><br></pre></td></tr></table></figure><p>一旦它返回（没有报错）， 你就可以下线此节点（或者等价地在云平台上，删除支持该节点的虚拟机）。如果要在维护操作期间将节点留在集群中，则需要运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl uncordon &lt;node name&gt;</span><br></pre></td></tr></table></figure><p>然后告诉 Kubernetes，它可以继续在此节点上调度新的 Pods。</p><h2><span id="在进行集群关闭前的准备工作">在进行集群关闭前的准备工作</span></h2><p>备份是最最重要的准备工作，保障应用可以重新正常服务为目的各种操作都是必须的。做一个你自己的计划清单，在重要的步骤之前确认好。</p><ul><li>主机之间已经设置 SSH 免密登录</li><li>集群内应用的备份</li><li>集群内客户自定义资源的备份</li><li>集群内 Etcd 的备份</li></ul><h2><span id="关闭-kubernetes-集群">关闭 Kubernetes 集群</span></h2><blockquote><p><strong>再次提示</strong><br>在关闭集群前，请您务按照我们推荐的方法备份集群的数据与应用，以便在重新启动集群时如果遇到任何问题，可以通过备份还原集群与应用。<br>使用本教程中的方法可以平稳关闭集群，但数据损坏的可能性仍然存在。</p></blockquote><p>首先，我们要获取节点列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k8snodes=$(kubectl get nodes -o name)</span><br></pre></td></tr></table></figure><p>然后,我们就要关闭节点了，您可以可一台一台的关闭。或运行以下脚本关闭节点:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> <span class="variable">$&#123;k8snodes[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"==== Shut down <span class="variable">$node</span> ===="</span></span><br><span class="line">    ssh <span class="variable">$node</span> sudo shutdown -h 1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>注意: 前提条件是主机之间已经设置 SSH 免密登录。</p></blockquote><p>此时，您就可以关闭其他的集群依赖项，对集群进行维护操作啦。</p><h2><span id="kubernetes-集群重启">Kubernetes 集群重启</span></h2><p>在重启后，我们需要仔细检查所有节点和核心组件的状态，并确保一切就绪。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes -o wide</span><br><span class="line">NAME        STATUS   ROLES                  AGE   VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME</span><br><span class="line">mars-k8s1   Ready    control-plane,master   17d   v1.21.0   172.16.60.60   &lt;none&gt;        Ubuntu 20.04.1 LTS   5.11.0-40-generic   docker://20.10.10</span><br><span class="line">mars-k8s2   Ready    &lt;none&gt;                 17d   v1.21.0   172.16.60.61   &lt;none&gt;        Ubuntu 20.04.1 LTS   5.11.0-40-generic   docker://20.10.10</span><br><span class="line">mars-k8s3   Ready    &lt;none&gt;                 17d   v1.21.0   172.16.60.62   &lt;none&gt;        Ubuntu 20.04.1 LTS   5.11.0-40-generic   docker://20.10.10</span><br><span class="line"></span><br><span class="line">$ kubectl get svc -n kube-system</span><br><span class="line">NAME             TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns         ClusterIP   10.96.0.10       &lt;none&gt;        53/UDP,53/TCP,9153/TCP   17d</span><br><span class="line">metrics-server   ClusterIP   10.111.227.248   &lt;none&gt;        443/TCP                  17d</span><br><span class="line"></span><br><span class="line">$ kubectl get pod -n kube-system</span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-558bd4d5db-h7jqc            1/1     Running   2          17d</span><br><span class="line">coredns-558bd4d5db-wj4bn            1/1     Running   2          17d</span><br><span class="line">etcd-mars-k8s1                      1/1     Running   2          17d</span><br><span class="line">kube-apiserver-mars-k8s1            1/1     Running   3          17d</span><br><span class="line">kube-controller-manager-mars-k8s1   1/1     Running   2          17d</span><br><span class="line">kube-flannel-ds-677dg               1/1     Running   2          17d</span><br><span class="line">kube-flannel-ds-bxhx6               1/1     Running   3          17d</span><br><span class="line">kube-flannel-ds-r5pqf               1/1     Running   2          17d</span><br><span class="line">kube-proxy-6w52h                    1/1     Running   2          17d</span><br><span class="line">kube-proxy-p8zfp                    1/1     Running   2          17d</span><br><span class="line">kube-proxy-v8t7j                    1/1     Running   2          17d</span><br><span class="line">kube-scheduler-mars-k8s1            1/1     Running   2          17d</span><br><span class="line">metrics-server-5f9459b95c-dtzbf     1/1     Running   2          17d</span><br></pre></td></tr></table></figure><h2><span id="kubernetes-集群重启维护避坑指南">Kubernetes 集群重启维护避坑指南</span></h2><p>说点儿心里话，运维有时要看运气，这不是开玩笑，在我的职业生涯中看到了也学到了很多，在过去我有幸支持了多个国家的数据灾备业务。包括：韩国，日本，中港台，及东南亚各个 Region 的客户公司，在运维做 IT 架构变更的时候，买烧猪祭奠关二爷有时真的需要，我们不了解的事情还有很多，要保持敬畏。所以备份吧，多备份几次！！！</p><p>在我们这个时代人定胜天的神迹比比皆是。但是所谓割接，割下来，接不上的情况也屡见不鲜。通常情况下，重新启动 Kubernetes 集群后就可以继续正常使用，但是由于意外情况，该集群可能不可用。例如：</p><ul><li>关闭集群过程中 Etcd 数据损坏或是节点故障，这在 Bare Metal K8s Node 上很常见。</li><li>网络错误，这就需要检查所有集群依赖项的状态，一定用好监控工具，一步一步的查，别怕麻烦，要确保所有集群依赖项均已就绪。</li><li>应用的问题，节点是启动了，K8s 也好好的，应用不能对外提供服务，这时一系列的排错是最考验人的，所以备份恢复吧。这样可以确保 RTO。</li></ul><h2><span id="参考链接">参考链接</span></h2><ol><li><a href="https://www.data2clouds.com/?p=118" target="_blank" rel="noopener">Kasten 实战系列备份K8S云原生应用</a></li><li><a href="https://www.data2clouds.com/?p=205" target="_blank" rel="noopener">Kasten k10 提高系列 02 - 用 Kasten 备份 kubernates etcd 数据库</a></li></ol><blockquote><p>本文转载自：「云端数据管理」，原文：<a href="https://url.hi-linux.com/YIzIq" target="_blank" rel="noopener">https://url.hi-linux.com/YIzIq</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在日常对 Kubernetes 集群运行维护的过程中，您可能需要临时的关闭或者是重启 Kubernetes 集群对集群进行维护，本文将介绍如何去安全的关闭 K8s 集群以及如何重新启动集群。&lt;/p&gt;
&lt;h2 id=&quot;日常节点运维方式&quot;&gt;日常节点运维方式&lt;/h2&gt;
&lt;p&gt;关闭 K8s 集群是个危险的操作！在关闭集群之前，您必须完全了解这个操作所带来的后果。首先，我们要对集群内的应用、客户定义资源 CRD 和 Etcd 进行备份，然后再进行重启或关闭集群的操作。在通常运维的情况下，建议您驱逐维护节点，而非重启整个集群。在这里，我们也把驱逐维护节点命令放在下面供您参考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>老板永远是对的？</title>
    <link href="https://www.hi-linux.com/posts/36229.html"/>
    <id>https://www.hi-linux.com/posts/36229.html</id>
    <published>2022-11-03T01:00:00.000Z</published>
    <updated>2022-11-03T02:15:10.715Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>曾经在企业工作的时候，我们经常有一句话：老板是不会有错的。老板是公司创始人，天马行空很多想法，时不时就会搞出一些想法，并且很快就要求下面的员工们执行，雷厉风行。</p><p>但对于一线的员工，经常会觉得这些想法根本就不现实，也就是无法执行，思想上不认可，导致行动上难以配合，甚至消极怠工。聪明的公司总裁在开会时，对员工们说：老板的指示，不理解也要先执行，在执行中理解。他从来都不会说老板的想法有问题。</p><a id="more"></a><p>更为有意思的事情。有一次内部培训上，有员工问高管们：</p><blockquote><p>老板说每个项目要开发一幢楼做大平层户型，但销售数据显示并不好，为什么老板强行这样要求呢？</p></blockquote><p>这位高管也确实了得，他如此回复我们：</p><blockquote><p>老板是说要开发大户型，但老板没有说让你马上配建啊！</p></blockquote><p>久而久之，我们都明白了，老板是不会有错的。公司都是他的，他的失败成本比我们这些流水的打工人大多了。要错的只能是打工人。何况老板站的高度那么高，格局那么宽，掌握的信息那么多，我们这些基层员工简直就是井底之蛙，错的只能是打工人。</p><p>现在回想起来，我倒对这种做法有了新的认识。商业老板们的想法固然会很多，他们不像学校里的教授那么有条有理，老板们更多的可能是一种感觉，就把想法提出来了。他们也不必每个想法都实现成功，只要有那么几个想法成功就会让老板们实现所有，一俊遮百丑。</p><p>因此，当老板们有了新想法后，他们要求员工立马落实，这样做还可以实现以下几个目的：</p><ol><li>狠抓公司高管和员工的执行力，没有执行力，一切等于零，再好的想法也没有用；</li><li>测试公司高管和员工的忠诚度，忠诚不绝对，就是绝对不忠诚，谁执行了老板的指示，就表明了对他的效忠。</li><li>通过高管和员工对指示的执行情况，可以测试出他们到底有多大的忍耐度，也就是对员工们的管理难易程度。</li></ol><p>这也就不奇怪总裁和高管们为老板的指示做出的表态和解释。只是我们这些低情商的员工们，还在苦苦思辨老板的想法是不是合理，从而错失一次又一次机会。</p><p>不过，老板他经常标榜他的开明之处，他说：</p><blockquote><p>只有真理可以在公司横着走。</p></blockquote><p>可能是大家都没有胆量吃螃蟹，所以一直没有见过有人横着走，而我想了很久才明白过来，也许“真理”就是老板，所以他怎么会有错呢？</p><p>对此，你怎么看呢？欢迎大家留言讨论！</p><blockquote><p>本文转载自：「 土木坛子 」，原文：<a href="https://url.hi-linux.com/gV4M5" target="_blank" rel="noopener">https://url.hi-linux.com/gV4M5</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;曾经在企业工作的时候，我们经常有一句话：老板是不会有错的。老板是公司创始人，天马行空很多想法，时不时就会搞出一些想法，并且很快就要求下面的员工们执行，雷厉风行。&lt;/p&gt;
&lt;p&gt;但对于一线的员工，经常会觉得这些想法根本就不现实，也就是无法执行，思想上不认可，导致行动上难以配合，甚至消极怠工。聪明的公司总裁在开会时，对员工们说：老板的指示，不理解也要先执行，在执行中理解。他从来都不会说老板的想法有问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="职场" scheme="https://www.hi-linux.com/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Headscale ( Tailscale 开源版 ) 快速搭建一个私有专属的 P2P 内网穿透网络</title>
    <link href="https://www.hi-linux.com/posts/33684.html"/>
    <id>https://www.hi-linux.com/posts/33684.html</id>
    <published>2022-10-26T01:00:00.000Z</published>
    <updated>2022-10-26T01:58:08.007Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="一-内网穿透简述">一、内网穿透简述</span></h2><p>由于国内网络环境问题, 普遍家庭用户宽带都没有分配到公网 IP(我有固定公网 IP, 嘿嘿); 这时候一般我们需要从外部访问家庭网络时就需要通过一些魔法手段, 比如 VPN、远程软件(向日葵…)等; 但是这些工具都有一个普遍存在的问题: 慢+卡!</p><h3><span id="11-传统星型拓扑">1.1、传统星型拓扑</span></h3><p>究其根本因素在于, 在传统架构中如果两个位于多层 NAT(简单理解为多个路由器)之后的设备, 只能通过一些中央(VPN/远程软件)中转服务器进行链接, 这时网络连接速度取决于中央服务器带宽和速度; 这种网络架构我这里简称为: 星型拓扑</p><p><img src="https://img.hi-linux.com/staticfile/MKn6bf-20221025104144038-2022-10-25-vuD5sk.png" alt></p><p>从这张图上可以看出, <strong>你的 “工作笔记本” 和 “家庭 NAS” 之间通讯的最大传输速度为 <code>Up/Down: 512K/s</code></strong>; 因为流量经过了中央服务器中转, 由于网络木桶效应存在, 即使你两侧的网络速度再高也没用, 整体的速度取决于这个链路中最低的一个设备网速而不是你两端的设备.</p><p><strong>在这种拓扑下, 想提高速度只有一个办法: 加钱!</strong> 在不使用 “钞能力” 的情况下, 普遍免费的软件提供商不可能给予过多的资源来让用户白嫖, 而自己弄大带宽的中央服务器成本又过高.</p><a id="more"></a><h3><span id="12-nat-穿透与网状拓扑">1.2、NAT 穿透与网状拓扑</span></h3><blockquote><p>本部分只做简述, 具体里面有大量细节和规则可能描述不准确, 细节部分推荐阅读 <a href="https://tailscale.com/blog/how-nat-traversal-works/" target="_blank" rel="noopener">How NAT traversal works</a>.</p></blockquote><p>既然传统的星型拓扑有这么多问题, 那么有没有其他骚操作可以解决呢? 答案是有的, 简单来说就是利用 NAT 穿透原理. NAT 穿透简单理解如下: <strong>在 A 设备主动向 B 设备发送流量后, 整个链路上的防火墙会短时间打开一个映射规则, 该规则允许 B 设备短暂的从这个路径上反向向 A 设备发送流量.</strong> 更通俗的讲大概就是所谓的: <strong>“顺着网线来打你”</strong></p><p><img src="https://img.hi-linux.com/staticfile/by4z9m-2022-10-25-VhDRc6.png" alt></p><p>搞清了这个规则以后, 我们就可以<strong>弄一台 “低配” 的中央服务器</strong>, 让中央服务器来<strong>帮助我们协商</strong>两边的设备谁先访问谁(或者说是访问规则); 两个设备一起无脑访问对方, 然后触发防火墙的 NAT 穿透规则(防火墙打开), 此后两个设备就可以不通过中央服务器源源不断的通讯了. 在这种架构下我们的设备其实就组成了一个非标准的网状拓扑:</p><p><img src="https://img.hi-linux.com/staticfile/MrF6yn-2022-10-25-sXBQjt.png" alt></p><p>在这种拓扑下, 两个设备之间的通讯速度已经不在取决于中央服务器, 而是直接取决于两端设备的带宽, 也就是说达到了设备网络带宽峰值. <strong>当然 NAT 穿透也不是百分百能够成功的, 在复杂网络情况下有些防火墙不会按照预期工作或者说有更严格的限制;</strong> 比如 IP、端口、协议限制等等, 所以为了保证可靠性可以让中央服务器中转做后备方案, 即尽量尝试 NAT 穿透, 如果不行走中央服务器中继.</p><h2><span id="二-tailscale-简介">二、Tailscale 简介</span></h2><blockquote><p>第一部分是为了方便读者理解一些新型内网穿透的大致基本原理, 现在回到本文重点: Tailscale</p></blockquote><p>Tailscale 就是一种利用 NAT 穿透(aka: P2P 穿透)技术的 VPN 工具. Tailscale 客户端等是开源的, 不过遗憾的是中央控制服务器目前并不开源; Tailscale 目前也提供免费的额度给用户使用, 在 NAT 穿透成功的情况下也能保证满速运行.</p><p>不过一旦无法 NAT 穿透需要做中转时, Tailscale 官方的服务器由于众所周知的原因在国内访问速度很拉胯; 不过万幸的是开源社区大佬们搓了一个开源版本的中央控制服务器(Headscale), 也就是说: <strong>我们可以自己搭建中央服务器啦, 完全 “自主可控” 啦.</strong></p><h2><span id="三-搭建-headscale-服务端">三、搭建 Headscale 服务端</span></h2><blockquote><p>以下命令假设安装系统为 Ubuntu 22.04, 其他系统请自行调整.</p></blockquote><h3><span id="31-宿主机安装">3.1、宿主机安装</span></h3><p>Headscale 是采用 Go 语言编写的, 所以只有一个二进制文件, 在 <a href="https://github.com/juanfont/headscale/releases" target="_blank" rel="noopener">Github Releases</a> 页面下载最新版本即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;juanfont&#x2F;headscale&#x2F;releases&#x2F;download&#x2F;v0.16.4&#x2F;headscale_0.16.4_linux_amd64 -O &#x2F;usr&#x2F;local&#x2F;bin&#x2F;headscale</span><br><span class="line"></span><br><span class="line"># 增加可执行权限</span><br><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;headscale</span><br></pre></td></tr></table></figure><p>下载完成后为了安全性我们需要创建单独的用户和目录用于 Headscale 运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 配置目录</span><br><span class="line">mkdir -p &#x2F;etc&#x2F;headscale</span><br><span class="line"></span><br><span class="line"># 创建用户</span><br><span class="line">useradd \</span><br><span class="line">--create-home \</span><br><span class="line">--home-dir &#x2F;var&#x2F;lib&#x2F;headscale&#x2F; \</span><br><span class="line">--system \</span><br><span class="line">--user-group \</span><br><span class="line">--shell &#x2F;usr&#x2F;sbin&#x2F;nologin \</span><br><span class="line">headscale</span><br></pre></td></tr></table></figure><p>为了保证 Headscale 能持久运行, 我们需要创建 SystemD 配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;headscale.service</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;headscale controller</span><br><span class="line">After&#x3D;syslog.target</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">User&#x3D;headscale</span><br><span class="line">Group&#x3D;headscale</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;headscale serve</span><br><span class="line">Restart&#x3D;always</span><br><span class="line">RestartSec&#x3D;5</span><br><span class="line"></span><br><span class="line"># Optional security enhancements</span><br><span class="line">NoNewPrivileges&#x3D;yes</span><br><span class="line">PrivateTmp&#x3D;yes</span><br><span class="line">ProtectSystem&#x3D;strict</span><br><span class="line">ProtectHome&#x3D;yes</span><br><span class="line">ReadWritePaths&#x3D;&#x2F;var&#x2F;lib&#x2F;headscale &#x2F;var&#x2F;run&#x2F;headscale</span><br><span class="line">AmbientCapabilities&#x3D;CAP_NET_BIND_SERVICE</span><br><span class="line">RuntimeDirectory&#x3D;headscale</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><h3><span id="32-配置-headscale">3.2、配置 Headscale</span></h3><p>安装完成以后我们需要在 <code>/etc/headscale/config.yaml</code> 中配置 Headscale 的启动配置, 以下为配置样例以及解释(仅列出重要配置):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"># Headscale 服务器的访问地址</span><br><span class="line"># </span><br><span class="line"># 这个地址是告诉客户端需要访问的地址, 即使你需要在跑在</span><br><span class="line"># 负载均衡器之后这个地址也必须写成负载均衡器的访问地址</span><br><span class="line">server_url: https:&#x2F;&#x2F;your.domain.com</span><br><span class="line"></span><br><span class="line"># Headscale 实际监听的地址</span><br><span class="line">listen_addr: 0.0.0.0:8080</span><br><span class="line"></span><br><span class="line"># 监控地址</span><br><span class="line">metrics_listen_addr: 127.0.0.1:9090</span><br><span class="line"></span><br><span class="line"># grpc 监听地址</span><br><span class="line">grpc_listen_addr: 0.0.0.0:50443</span><br><span class="line"></span><br><span class="line"># 是否允许不安全的 grpc 连接(非 TLS)</span><br><span class="line">grpc_allow_insecure: false</span><br><span class="line"></span><br><span class="line"># 客户端分配的内网网段</span><br><span class="line">ip_prefixes:</span><br><span class="line">  - fd7a:115c:a1e0::&#x2F;48</span><br><span class="line">  - 100.64.0.0&#x2F;10</span><br><span class="line"></span><br><span class="line"># 中继服务器相关配置</span><br><span class="line">derp:</span><br><span class="line">  server:</span><br><span class="line">    # 关闭内嵌的 derper 中继服务(可能不安全, 还没去看代码)</span><br><span class="line">    enabled: false</span><br><span class="line"></span><br><span class="line">  # 下发给客户端的中继服务器列表(默认走官方的中继节点)</span><br><span class="line">  urls:</span><br><span class="line">    - https:&#x2F;&#x2F;controlplane.tailscale.com&#x2F;derpmap&#x2F;default</span><br><span class="line"></span><br><span class="line">  # 可以在本地通过 yaml 配置定义自己的中继接待你</span><br><span class="line">  paths: []</span><br><span class="line"></span><br><span class="line"># SQLite config</span><br><span class="line">db_type: sqlite3</span><br><span class="line">db_path: &#x2F;var&#x2F;lib&#x2F;headscale&#x2F;db.sqlite</span><br><span class="line"></span><br><span class="line"># 使用自动签发证书是的域名</span><br><span class="line">tls_letsencrypt_hostname: &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 使用自定义证书时的证书路径</span><br><span class="line">tls_cert_path: &quot;&quot;</span><br><span class="line">tls_key_path: &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 是否让客户端使用随机端口, 默认使用 41641&#x2F;UDP</span><br><span class="line">randomize_client_port: false</span><br></pre></td></tr></table></figure><h3><span id="33-证书及反向代理">3.3、证书及反向代理</span></h3><p>可能很多人和我一样, 希望使用 ACME 自动证书, 又不想占用 80/443 端口, 又想通过负载均衡器负载, 配置又看的一头雾水; 所以这里详细说明一下 Headscale 证书相关配置和工作逻辑:</p><ul><li>1、Headscale 的 ACME 只支持 HTTP/TLS 挑战, 所以使用后必定占用 80/443</li><li>2、当配置了 <code>tls_letsencrypt_hostname</code> 时一定会进行 ACME 申请</li><li>3、在不配置 <code>tls_letsencrypt_hostname</code> 时如果配置了 <code>tls_cert_path</code> 则使用自定义证书</li><li>4、两者都不配置则不使用任何证书, 服务端监听 HTTP 请求</li><li>5、三种情况下(ACME 证书、自定义证书、无证书)主服务都只监听 <code>listen_addr</code> 地址, 与 <code>server_url</code> 没半毛钱关系</li><li>6、只有在有证书(ACME 证书或自定义证书)的情况下或者手动开启了 <code>grpc_allow_insecure</code> 才会监听 grpc 远程调用服务</li></ul><p>综上所述, 如果你想通过 Nginx、Caddy 反向代理 Headscale, 则你需要满足以下配置:</p><ul><li>1、删除掉 <code>tls_letsencrypt_hostname</code> 或留空, 防止 ACME 启动</li><li>2、删除掉 <code>tls_cert_path</code> 或留空, 防止加载自定义证书</li><li>3、<code>server_url</code> 填写 Nginx 或 Caddy 被访问的 HTTPS 地址</li><li>4、在你的 Nginx 或 Caddy 中反向代理填写 <code>listen_addr</code> 的 HTTP 地址</li></ul><p>Nginx 配置参考 <a href="https://github.com/juanfont/headscale/wiki/nginx-configuration" target="_blank" rel="noopener">官方 Wiki</a>, Caddy 只需要一行 <code>reverse_proxy headscale:8080</code> 即可(地址自行替换).</p><p>至于 ACME 证书你可以通过使用 <code>acme.sh</code> 自动配置 Nginx 或者使用 Caddy 自动申请等方式, 这些已经与 Headscale 无关了, 不在本文探讨范围内.</p><h3><span id="34-内网地址分配">3.4、内网地址分配</span></h3><p>请尽量不要将 <code>ip_prefixes</code> 配置为默认的 <code>100.64.0.0/10</code> 网段, 如果你有兴趣查询了该地址段, 那么你应该明白它叫 CGNAT; 很不幸的是例如 Aliyun 底层的 apt 源等都在这个范围内, 可能会有一些奇怪问题.</p><h3><span id="35-启动-headscale">3.5、启动 Headscale</span></h3><p>在处理完证书等配置后, 只需要愉快的启动一下即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 开机自启动 并 立即启动</span><br><span class="line">systemctl enable headscale --now</span><br></pre></td></tr></table></figure><p>再啰嗦一嘴, 如果你期望使用 Headscale ACME 自动申请证书, 你的关键配置应该像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server_url: https:&#x2F;&#x2F;your.domain.com</span><br><span class="line">listen_addr: 0.0.0.0:443</span><br><span class="line">tls_letsencrypt_hostname: &quot;your.domain.com&quot;</span><br><span class="line">tls_cert_path: &quot;&quot;</span><br><span class="line">tls_key_path: &quot;&quot;</span><br></pre></td></tr></table></figure><p>如果你期望使用自定义证书, 则你的关键配置应该像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server_url: https:&#x2F;&#x2F;your.domain.com</span><br><span class="line">listen_addr: 0.0.0.0:443</span><br><span class="line">tls_letsencrypt_hostname: &quot;&quot;</span><br><span class="line">tls_cert_path: &quot;&#x2F;path&#x2F;to&#x2F;cert&quot;</span><br><span class="line">tls_key_path: &quot;&#x2F;path&#x2F;to&#x2F;key&quot;</span><br></pre></td></tr></table></figure><p>如果你期望使用负载均衡器, 那么你的关键配置应该像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server_url: https:&#x2F;&#x2F;your.domain.com</span><br><span class="line">listen_addr: 0.0.0.0:8080</span><br><span class="line">tls_letsencrypt_hostname: &quot;&quot;</span><br><span class="line">tls_cert_path: &quot;&quot;</span><br><span class="line">tls_key_path: &quot;&quot;</span><br></pre></td></tr></table></figure><p>在使用负载均衡器配置时, 启动后会有一行警告日志, 忽略即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-09-18T07:57:36Z WRN Listening without TLS but ServerURL does not start with http:&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><h3><span id="36-docker-compose-安装">3.6、Docker Compose 安装</span></h3><p>Compose 配置样例文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># docker-compose.yaml</span><br><span class="line">version: &quot;3.9&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  headscale:</span><br><span class="line">    container_name: headscale</span><br><span class="line">    image: headscale&#x2F;headscale:0.16.4</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    cap_add:</span><br><span class="line">      - NET_ADMIN</span><br><span class="line">      - NET_RAW</span><br><span class="line">      - SYS_MODULE</span><br><span class="line">    sysctls:</span><br><span class="line">      - net.ipv4.ip_forward&#x3D;1</span><br><span class="line">      - net.ipv6.conf.all.forwarding&#x3D;1</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;conf:&#x2F;etc&#x2F;headscale</span><br><span class="line">      - data:&#x2F;var&#x2F;lib&#x2F;headscale</span><br><span class="line">    command: [&quot;headscale&quot;, &quot;serve&quot;]</span><br><span class="line">volumes:</span><br><span class="line">  config:</span><br><span class="line">  data:</span><br></pre></td></tr></table></figure><p>你需要在与 <code>docker-compose.yaml</code> 同级目录下创建 <code>conf</code> 目录用于存储配置文件; 具体配置请参考上面的配置详解等部分, 最后不要忘记你的 Compose 文件端口映射需要和配置文件保持一致.</p><h2><span id="四-客户端安装">四、客户端安装</span></h2><p>对于客户端来说, Tailscale 提供了多个平台和发行版的预编译安装包, 并且部分客户端直接支持设置自定义的中央控制服务器.</p><h3><span id="41-linux-客户端">4.1、Linux 客户端</span></h3><p>Linux 用户目前只需要使用以下命令安装即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;tailscale.com&#x2F;install.sh | sh</span><br></pre></td></tr></table></figure><p>默认该脚本会检测相关的 Linux 系统发行版并使用对应的包管理器安装 Tailscale, 安装完成后使用以下命令启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tailscale up --login-server https:&#x2F;&#x2F;your.domain.com --advertise-routes&#x3D;192.168.11.0&#x2F;24 --accept-routes&#x3D;true --accept-dns&#x3D;false</span><br></pre></td></tr></table></figure><p>关于选项设置:</p><ul><li><code>--login-server</code>: 指定使用的中央服务器地址(必填)</li><li><code>--advertise-routes</code>: 向中央服务器报告当前客户端处于哪个内网网段下, 便于中央服务器让同内网设备直接内网直连(可选的)或者将其他设备指定流量路由到当前内网(可选)</li><li><code>--accept-routes</code>: 是否接受中央服务器下发的用于路由到其他客户端内网的路由规则(可选)</li><li><code>--accept-dns</code>: 是否使用中央服务器下发的 DNS 相关配置(可选, 推荐关闭)</li></ul><p>启动完成后, <strong><code>tailscale</code> 将会卡住, 并打印一个你的服务器访问地址; 浏览器访问该地址后将会得到一条命令:</strong></p><p><img src="https://img.hi-linux.com/staticfile/l2zjmV-2022-10-25-U5QXXT.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/JU8BVZ-20221025104046371-2022-10-25-MKL0fj.png" alt></p><p><strong>注意: 浏览器上显示的命令需要在中央控制服务器执行(Headscale), <code>NAMESAPCE</code> 位置应该替换为一个具体的 Namespace, 可以使用以下命令创建 Namespace (名字随意)并让设备加入:</strong></p><p><img src="https://img.hi-linux.com/staticfile/x9tA4A-2022-10-25-QqSXMn.png" alt></p><p>在 Headscale 服务器上执行命令成功后客户端命令行在稍等片刻便会执行完成, 此时该客户端已经被加入 Headscale 网络并分配了特定的内网 IP; 多个客户端加入后在 NAT 穿透成功时就可以互相 ping 通, 如果出现问题请阅读后面的调试细节, 只要能注册成功就算是成功了一半, 暂时不要慌.</p><h3><span id="42-macos-客户端">4.2、MacOS 客户端</span></h3><p>MacOS 客户端安装目前有两种方式, 一种是使用标准的 AppStore 版本(好像还有一个可以直接下载的), 需要先设置服务器地址然后再启动 App:</p><p>首先访问你的 Headscale 地址 <code>https://your.domain.com/apple</code>:</p><p><img src="https://img.hi-linux.com/staticfile/Y1cXjS-20221025104153717-2022-10-25-krooqA.png" alt></p><p>复制倒数第二行命令到命令行执行(可能需要 sudo 执行), 然后去 AppStore 搜索 Hailscale 安装并启动; 启动后会自动打开浏览器页面, 与 Linux 安装类似, 复制命令到 Headscale 服务器执行即可(Namespace 创建一次就行).</p><p><strong>第二种方式也是比较推荐的方式, 直接编译客户端源码安装, 体验与 Linux 版本一致:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装 go</span><br><span class="line">brew install go</span><br><span class="line"></span><br><span class="line"># 编译命令行客户端</span><br><span class="line">go install tailscale.com&#x2F;cmd&#x2F;tailscale&#123;,d&#125;@main</span><br><span class="line"></span><br><span class="line"># 安装为系统服务</span><br><span class="line">sudo tailscaled install-system-daemon</span><br></pre></td></tr></table></figure><p>安装完成后同样通过 <code>tailscale up</code> 命令启动并注册即可, 具体请参考 Linux 客户端安装部分.</p><h3><span id="43-其他客户端">4.3、其他客户端</span></h3><p>关于 Windows 客户端大致流程就是创建一个注册表, 然后同样安装官方 App 启动, 接着浏览器复制命令注册即可. 至于移动端本人没有需求, 所以暂未研究. <strong>Windows 具体的安装流程请访问 <code>https://your.domain.com/windows</code> 地址查看(基本与 MacOS AppStore 版本安装类似).</strong></p><h2><span id="五-中继服务器搭建">五、中继服务器搭建</span></h2><p>在上面的 Headscale 搭建完成并添加客户端后, 某些客户端可能无法联通; 这是由于网络复杂情况下导致了 NAT 穿透失败; 为此我们可以搭建一个中继服务器来进行传统的星型拓扑通信.</p><h3><span id="51-搭建-derp-server">5.1、搭建 DERP Server</span></h3><p>首先需要注意的是, 在需要搭建 DERP Server 的服务器上, 请先安装一个 Tailscale 客户端并注册到 Headscale; <strong>这样做的目的是让搭建的 DERP Server 开启客户端认证, 否则你的 DERP Server 可以被任何人白嫖.</strong></p><p>目前 Tailscale 官方并未提供 DERP Server 的安装包, 所以需要我们自行编译安装; 在编译之前请确保安装了最新版本的 Go 语言及其编译环境.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 编译 DERP Server</span><br><span class="line">go install tailscale.com&#x2F;cmd&#x2F;derper@main</span><br><span class="line"></span><br><span class="line"># 复制到系统可执行目录</span><br><span class="line">mv $&#123;GOPATH&#125;&#x2F;bin&#x2F;derper &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line"></span><br><span class="line"># 创建用户和运行目录</span><br><span class="line">useradd \</span><br><span class="line">        --create-home \</span><br><span class="line">        --home-dir &#x2F;var&#x2F;lib&#x2F;derper&#x2F; \</span><br><span class="line">        --system \</span><br><span class="line">        --user-group \</span><br><span class="line">        --shell &#x2F;usr&#x2F;sbin&#x2F;nologin \</span><br><span class="line">        derper</span><br></pre></td></tr></table></figure><p>接下来创建一个 SystemD 配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;derper.service</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;tailscale derper server</span><br><span class="line">After&#x3D;syslog.target</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">User&#x3D;derper</span><br><span class="line">Group&#x3D;derper</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;derper -c&#x3D;&#x2F;var&#x2F;lib&#x2F;derper&#x2F;private.key -a&#x3D;:8989 -stun-port&#x3D;3456 -verify-clients</span><br><span class="line">Restart&#x3D;always</span><br><span class="line">RestartSec&#x3D;5</span><br><span class="line"></span><br><span class="line"># Optional security enhancements</span><br><span class="line">NoNewPrivileges&#x3D;yes</span><br><span class="line">PrivateTmp&#x3D;yes</span><br><span class="line">ProtectSystem&#x3D;strict</span><br><span class="line">ProtectHome&#x3D;yes</span><br><span class="line">ReadWritePaths&#x3D;&#x2F;var&#x2F;lib&#x2F;derper &#x2F;var&#x2F;run&#x2F;derper</span><br><span class="line">AmbientCapabilities&#x3D;CAP_NET_BIND_SERVICE</span><br><span class="line">RuntimeDirectory&#x3D;derper</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>最后使用以下命令启动 Derper Server 即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable derper --now</span><br></pre></td></tr></table></figure><p><strong>注意: 默认情况下 Derper Server 会监听在 <code>:443</code> 上, 同时会触发自动 ACME 申请证书. 关于证书逻辑如下:</strong></p><ul><li>1、如果不指定 <code>-a</code> 参数, 则默认监听 <code>:443</code></li><li>2、如果监听 <code>:443</code> 并且未指定 <code>--certmode=manual</code> 则会强制使用 <code>--hostname</code> 指定的域名进行 ACME 申请证书</li><li>3、如果指定了 <code>--certmode=manual</code> 则会使用 <code>--certmode</code> 指定目录下的证书开启 HTTPS</li><li>4、如果指定了 <code>-a</code> 为非 <code>:443</code> 端口, 且没有指定 <code>--certmode=manual</code> 则只监听 HTTP</li></ul><p><strong>如果期望使用 ACME 自动申请只需要不增加 <code>-a</code> 选项即可(占用 443 端口), 如果期望通过负载均衡器负载, 则需要将 <code>-a</code> 选项指定到非 443 端口, 然后配置 Nginx、Caddy 等 LB 软件即可. 最后一点 <code>stun</code> 监听的是 UDP 端口, 请确保防火墙打开此端口.</strong></p><h3><span id="52-配置-headscale">5.2、配置 Headscale</span></h3><p>在创建完 Derper 中继服务器后, 我们还需要配置 Headscale 来告诉所有客户端在必要时可以使用此中继节点进行通信; 为了达到这个目的, 我们需要在 Headscale 服务器上创建以下配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;headscale&#x2F;derper.yaml</span><br><span class="line"></span><br><span class="line">regions:</span><br><span class="line">  901:</span><br><span class="line">    regionid: 901</span><br><span class="line">    regioncode: private-derper</span><br><span class="line">    regionname: &quot;My Private Derper Server&quot;</span><br><span class="line">    nodes:</span><br><span class="line">      - name: private-derper</span><br><span class="line">        regionid: 901</span><br><span class="line">        # 自行更改为自己的域名</span><br><span class="line">        hostname: derper.xxxxx.com</span><br><span class="line">        # Derper 节点的 IP</span><br><span class="line">        ipv4: 123.123.123.123</span><br><span class="line">        # Derper 设置的 STUN 端口</span><br><span class="line">        stunport: 3456</span><br></pre></td></tr></table></figure><p>在创建好基本的 Derper Server 节点信息配置后, 我们需要调整主配置来让 Headscale 加载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">derp:</span><br><span class="line">  server:</span><br><span class="line">    # 这里关闭 Headscale 默认的 Derper Server</span><br><span class="line">    enabled: false</span><br><span class="line">  # urls 留空, 保证不加载官方的默认 Derper</span><br><span class="line">  urls: []</span><br><span class="line">  # 这里填写 Derper 节点信息配置的绝对路径</span><br><span class="line">  paths:</span><br><span class="line">  - &#x2F;etc&#x2F;headscale&#x2F;derper.yaml</span><br><span class="line"></span><br><span class="line">  # If enabled, a worker will be set up to periodically</span><br><span class="line">  # refresh the given sources and update the derpmap</span><br><span class="line">  # will be set up.</span><br><span class="line">  auto_update_enabled: true</span><br><span class="line"></span><br><span class="line">  # How often should we check for DERP updates?</span><br><span class="line">  update_frequency: 24h</span><br></pre></td></tr></table></figure><p>接下来重启 Headscale 并重启 client 上的 tailscale 即可看到中继节点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~ ❯❯❯ tailscale netcheck</span><br><span class="line"></span><br><span class="line">Report:</span><br><span class="line">        * UDP: true</span><br><span class="line">        * IPv4: yes, 124.111.111.111:58630</span><br><span class="line">        * IPv6: no, but OS has support</span><br><span class="line">        * MappingVariesByDestIP: false</span><br><span class="line">        * HairPinning: false</span><br><span class="line">        * PortMapping: UPnP, NAT-PMP, PCP</span><br><span class="line">        * CaptivePortal: true</span><br><span class="line">        * Nearest DERP: XXXX Derper Server</span><br><span class="line">        * DERP latency:</span><br><span class="line">                - XXXX: 10.1ms  (XXXX Derper Server)</span><br></pre></td></tr></table></figure><p>到此中继节点搭建完成.</p><h3><span id="53-docker-compose-安装">5.3、Docker Compose 安装</span></h3><p>目前官方似乎也没有提供 Docker 镜像, 我自己通过 GitHub Action 编译了一个 Docker 镜像, 以下是使用此镜像的 Compose 文件样例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;3.9&#39;</span><br><span class="line">services:</span><br><span class="line">  derper:</span><br><span class="line">    image: mritd&#x2F;derper</span><br><span class="line">    container_name: derper</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&#x2F;tcp&quot;</span><br><span class="line">      - &quot;3456:3456&#x2F;udp&quot;</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia&#x2F;Shanghai</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;etc&#x2F;timezone:&#x2F;etc&#x2F;timezone</span><br><span class="line">      - &#x2F;var&#x2F;run&#x2F;tailscale:&#x2F;var&#x2F;run&#x2F;tailscale</span><br><span class="line">      - data:&#x2F;var&#x2F;lib&#x2F;derper</span><br><span class="line">volumes:</span><br><span class="line">  data:</span><br></pre></td></tr></table></figure><p><strong>该镜像默认开启了客户端验证, 所以请确保 <code>/var/run/tailscale</code> 内存在已加入 Headscale 成功的 tailscaled 实例的 sock 文件. 其他具体环境变量等参数配置请参考 <a href="https://github.com/mritd/autobuild/blob/main/derper/Earthfile" target="_blank" rel="noopener">Earthfile</a>.</strong></p><h2><span id="六-客户端网络调试">六、客户端网络调试</span></h2><blockquote><p>在调试中继节点或者不确定网络情况时, 可以使用一些 Tailscale 内置的命令来调试网络.</p></blockquote><h3><span id="61-ping-命令">6.1、Ping 命令</span></h3><p><code>tailscale ping</code> 命令可以用于测试 IP 连通性, 同时可以看到时如何连接目标节点的. <strong>默认情况下 Ping 命令首先会使用 Derper 中继节点通信, 然后尝试 P2P 连接; 一旦 P2P 连接成功则自动停止 Ping:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~ ❯❯❯ tailscale ping 10.24.0.5</span><br><span class="line">pong from k8s13 (10.24.0.5) via DERP(XXXXX) in 14ms</span><br><span class="line">pong from k8s13 (10.24.0.5) via DERP(XXXXX) in 13ms</span><br><span class="line">pong from k8s13 (10.24.0.5) via DERP(XXXXX) in 14ms</span><br><span class="line">pong from k8s13 (10.24.0.5) via DERP(XXXXX) in 12ms</span><br><span class="line">pong from k8s13 (10.24.0.5) via DERP(XXXXX) in 12ms</span><br><span class="line">pong from k8s13 (10.24.0.5) via 3.4.170.23:2495 in 9ms</span><br></pre></td></tr></table></figure><p>由于其先走 Derper 的特性也可以用来测试 Derper 连通性.</p><h3><span id="62-status-命令">6.2、Status 命令</span></h3><p>通过 <code>tailscale status</code> 命令可以查看当前节点与其他对等节点的连接方式, 通过此命令可以查看到当前节点可连接的节点以及是否走了 Derper 中继:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~ ❯❯❯ tailscale status</span><br><span class="line">10.24.0.8       xmac                 kovacs       macOS   -</span><br><span class="line">                alivpn               kovacs       linux   active; direct 4.3.4.5:41644, tx 1264 rx 944</span><br><span class="line">                aliyun               kovacs       linux   -</span><br><span class="line">                bob                  kovacs       macOS   offline</span><br><span class="line">                bob-imac             kovacs       macOS   offline</span><br><span class="line">                company              kovacs       linux   active; direct 114.114.114.114:41642, tx 1296 rx 880</span><br></pre></td></tr></table></figure><h3><span id="63-netcheck-命令">6.3、NetCheck 命令</span></h3><p>有些情况下我们可以确认是当前主机的网络问题导致没法走 P2P 连接, 但是我们又想了解一下当前的网络环境; 此时可以使用 <code>tailscale netcheck</code> 命令来检测当前的网络环境, 此命令将会打印出详细的网络环境报告:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">~ ❯❯❯ tailscale netcheck</span><br><span class="line">2022&#x2F;10&#x2F;19 21:15:27 portmap: [v1] Got PMP response; IP: 123.123.123.123, epoch: 297671</span><br><span class="line">2022&#x2F;10&#x2F;19 21:15:27 portmap: [v1] Got PCP response: epoch: 297671</span><br><span class="line">2022&#x2F;10&#x2F;19 21:15:27 portmap: [v1] UPnP reply &#123;Location:http:&#x2F;&#x2F;192.168.11.1:39735&#x2F;rootDesc.xml Server:AsusWRT&#x2F;386 UPnP&#x2F;1.1 MiniUPnPd&#x2F;2.2.0 USN:uuid:23345-2380-45f5-34534-04421abwb7cf0::urn:schemas-upnp-org:device:InternetGatewayDevice:1&#125;, &quot;HTTP&#x2F;1.1 200 OK\r\nCACHE-CONTROL: max-age&#x3D;120\r\nST: urn:schemas-upnp-org:device:InternetGatewayDevice:1\r\nUSN: uuid:34564645-2380-45f5-b069-sdfdght3245.....&quot;</span><br><span class="line">2022&#x2F;10&#x2F;19 21:15:27 portmap: UPnP meta changed: &#123;Location:http:&#x2F;&#x2F;192.168.11.1:39735&#x2F;rootDesc.xml Server:AsusWRT&#x2F;386 UPnP&#x2F;1.1 MiniUPnPd&#x2F;2.2.0 USN:uuid:23345-2380-45f5-b069-04421abwb7cf0::urn:schemas-upnp-org:device:InternetGatewayDevice:1&#125;</span><br><span class="line"></span><br><span class="line">Report:</span><br><span class="line">        * UDP: true</span><br><span class="line">        * IPv4: yes, 123.123.123.123:5935</span><br><span class="line">        * IPv6: no, but OS has support</span><br><span class="line">        * MappingVariesByDestIP: false</span><br><span class="line">        * HairPinning: true</span><br><span class="line">        * PortMapping: UPnP, NAT-PMP, PCP</span><br><span class="line">        * CaptivePortal: true</span><br><span class="line">        * Nearest DERP: XXXXX Aliyun</span><br><span class="line">        * DERP latency:</span><br><span class="line">                - XXXXX: 9.5ms   (XXXXX Aliyun)</span><br><span class="line">                - XXXXX: 53.1ms  (XXXXX BandwagonHost)</span><br></pre></td></tr></table></figure><h2><span id="七-其他补充">七、其他补充</span></h2><h3><span id="71-某些代理工具兼容性">7.1、某些代理工具兼容性</span></h3><p>MacOS 下使用一些增强代理工具时, 如果安装 App Store 的官方图形化客户端, 则可能与这些软件冲突, 推荐使用纯命令行版本<strong>并添加进程规则匹配 <code>tailscale</code> 和 <code>tailscaled</code> 两个进程, 让它们始终走 <code>DIRECT</code> 规则即可.</strong></p><h3><span id="72-macos-下-cpu-占用突然起飞">7.2、MacOS 下 CPU 占用突然起飞</span></h3><p>在使用一些网络代理工具时, 网络工具会设置默认路由; 这可能导致 <code>tailscaled</code> 无法获取到默认路由接口, 然后进入死循环并把 CPU 吃满, 同时会与 Derper 服务器产生大量上传流量. <strong>截止本文发布此问题已修复, 请使用 <code>mian</code> 分支编译安装, 具体见 <a href="https://github.com/tailscale/tailscale/issues/5879" target="_blank" rel="noopener">ISSUE/5879</a>.</strong></p><h3><span id="73-阿里云安装客户端后无法更新软件">7.3、阿里云安装客户端后无法更新软件</span></h3><p>Tailscale 默认使用 CGNAT(<code>100.64.0.0/10</code>) 网段作为内部地址分配网段, <strong>目前 Tailscale 仅允许自己的接口使用此网段, 不巧的是阿里云的 DNS、Apt 源等也采用此网段.</strong> 这会导致阿里云服务器安装客户端后 DNS、Apt 等不可用, 解决方案目前只能修改源码删除掉这两个 DROP 规则并重新编译.</p><p><img src="https://img.hi-linux.com/staticfile/Nnv35j-20221025104030679-2022-10-25-rWqjrm.png" alt></p><h3><span id="74-开启路由转发">7.4、开启路由转发</span></h3><p>大多数时候我们可能并不会在每个服务器上都安装 Tailscale 客户端, 通常只安装 2、3 台, 然后想通过这两三台转发该内网的所有流量. <strong>此时你需要</strong></p><ul><li>启动 tailscale 时设置正确的路由提示 <code>--advertise-routes=192.168.1.0/24</code> 来告诉 Headscale 服务器 “我这个节点可以转发这些地址的路由”</li><li>其他节点启动时需要增加 <code>--accept-routes=true</code> 选项来声明 “我接受外部其他节点发布的路由”</li></ul><p><strong>以上两个选项配置后, 只需要 Headscale 服务器上使用 <code>headscale node route enable -a -i XX(ID)</code> 开启即可. 开启后目标节点(ID)的路由就会发布到接受外部路由的所有节点, 想要关闭的话去掉 <code>-a</code> 即可.</strong></p><h3><span id="75-其他问题">7.5、其他问题</span></h3><p>以上也只是我个人遇到的一些问题, 如果有其他问题推荐先搜索然后查看 ISSUE, 最后不行可以看看源码. 目前来说 Tailscale 很多选项很模糊, 可能需要阅读源码以后才能知道到底应该怎么做.</p><blockquote><p>本文转载自：「 bleem 」，原文：<a href="https://url.hi-linux.com/M3tzx" target="_blank" rel="noopener">https://url.hi-linux.com/M3tzx</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、内网穿透简述&quot;&gt;一、内网穿透简述&lt;/h2&gt;
&lt;p&gt;由于国内网络环境问题, 普遍家庭用户宽带都没有分配到公网 IP(我有固定公网 IP, 嘿嘿); 这时候一般我们需要从外部访问家庭网络时就需要通过一些魔法手段, 比如 VPN、远程软件(向日葵…)等; 但是这些工具都有一个普遍存在的问题: 慢+卡!&lt;/p&gt;
&lt;h3 id=&quot;1-1、传统星型拓扑&quot;&gt;1.1、传统星型拓扑&lt;/h3&gt;
&lt;p&gt;究其根本因素在于, 在传统架构中如果两个位于多层 NAT(简单理解为多个路由器)之后的设备, 只能通过一些中央(VPN/远程软件)中转服务器进行链接, 这时网络连接速度取决于中央服务器带宽和速度; 这种网络架构我这里简称为: 星型拓扑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/MKn6bf-20221025104144038-2022-10-25-vuD5sk.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从这张图上可以看出, &lt;strong&gt;你的 “工作笔记本” 和 “家庭 NAS” 之间通讯的最大传输速度为 &lt;code&gt;Up/Down: 512K/s&lt;/code&gt;&lt;/strong&gt;; 因为流量经过了中央服务器中转, 由于网络木桶效应存在, 即使你两侧的网络速度再高也没用, 整体的速度取决于这个链路中最低的一个设备网速而不是你两端的设备.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在这种拓扑下, 想提高速度只有一个办法: 加钱!&lt;/strong&gt; 在不使用 “钞能力” 的情况下, 普遍免费的软件提供商不可能给予过多的资源来让用户白嫖, 而自己弄大带宽的中央服务器成本又过高.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Tailscale" scheme="https://www.hi-linux.com/tags/Tailscale/"/>
    
      <category term="Headscale" scheme="https://www.hi-linux.com/tags/Headscale/"/>
    
      <category term="VPN" scheme="https://www.hi-linux.com/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>保姆级零信任容器应用平台 Kasm 使用指南（全网最详细中文教程）</title>
    <link href="https://www.hi-linux.com/posts/19718.html"/>
    <id>https://www.hi-linux.com/posts/19718.html</id>
    <published>2022-10-14T01:00:00.000Z</published>
    <updated>2022-10-14T01:48:45.274Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="kasm-介绍">Kasm 介绍</span></h2><p><code>Kasm</code> 是一款基于 <code>Docker</code> 的容器应用平台，它提供企业级编排、数据丢失防护和 <code>Web</code> 流技术，以支持将容器化工作负载交付到你的浏览器。</p><p><code>Kasm</code> 可以在浏览器內运行各种应用，比如：<code>Linux</code> 桌面、浏览器、聊天工具、办公软件、多媒体工具等。</p><p><code>Kasm</code> 将这些应用隔离在独立的 <code>Docker</code> 容器内，在里面做的任何行为不会影响真实的主机，并且具备一次性特点、用完即删，保证了数据的安全性。</p><p><code>Kasm</code> 是个开源项目，你可以在个人及非营利条件下免费使用。</p><ul><li><code>Kasm</code> 官方网站: <a href="https://www.kasmweb.com/" target="_blank" rel="noopener">https://www.kasmweb.com/</a></li><li><code>Kasm Github</code>: <a href="https://github.com/kasmtech" target="_blank" rel="noopener">https://github.com/kasmtech</a></li></ul><p>简单来说 <code>Kasm</code> 可以让用户在浏览器（即开即用）使用各种（容器化）的软件和操作系统。</p><a id="more"></a><p><img src="https://img.hi-linux.com/staticfile/mobile01-d19f67c7496a3cb9062a1e9e43c0cdb3-2022-10-12-uKWaTN.gif" alt="在浏览器内运行 Chrome、Edge"></p><p><code>Kasm</code> 支持常用的主流浏览器：<code>Chrome</code>、<code>Edge</code>、<code>FireFox</code>、<code>Tor</code> 等。</p><p><img src="https://img.hi-linux.com/staticfile/mobile01-dd91659a413738e9545b76829c03a3b3-2022-10-12-iZyrRL.gif" alt="在浏览器内运行 Ubuntu 桌面"></p><p><code>Kasm</code> 支持常用的 <code>Linux</code> 桌面：<code>Ubuntu</code>、<code>CentOS</code>、<code>OPenSUSE</code>、<code>Kali Linux</code> 等。</p><h3><span id="kasm-优点"><code>Kasm</code> 优点:</span></h3><ul><li>支持受隔离保护的浏览器</li><li>支持受隔离保护的 <code>Linux</code> 桌面</li><li>支持受隔离保护的多种应用</li><li>在数秒间快速启动应用</li><li>使用完毕瞬间删除应用，不留痕迹</li><li>容器闲置超过指定时间自动删除应用，不留痕迹</li></ul><h3><span id="kasm-缺点"><code>Kasm</code> 缺点:</span></h3><ul><li>目前中文支持不友好，在部分应用内没有中文输入法。</li></ul><p>下表我们将比较下几种常用虚拟化服务 <code>VM</code>、<code>Docker</code>、<code>Kasm</code> 间的区别</p><table><thead><tr><th>VM</th><th>Docker</th><th>Kasm</th></tr></thead><tbody><tr><td>虚拟操作系统</td><td>虚拟容器</td><td>虚拟容器</td></tr><tr><td>硬件资源占用率高</td><td>👑硬件资源占用率最低</td><td>硬件资源占用率较低</td></tr><tr><td>需要安装专用应用程序</td><td>使用终端程序，图形操作不友好</td><td>👑使用网页浏览器，介面友好</td></tr><tr><td>安装操作系统耗时</td><td>部署容器快速</td><td>👑鼠标一键瞬间启动，支持多任务</td></tr><tr><td>虚拟机内的浏览器会储存 Cookie，无法达到完全的隐匿性</td><td>虽然可透过删除容器及重新部署来达到即开即用，但步骤较为繁琐</td><td>👑应用的启动或删除只需鼠标点击，真正实现即开即用。</td></tr><tr><td>👑中文支持度高</td><td>中文支持度低</td><td>中文支持度低</td></tr></tbody></table><h2><span id="部署-kasm">部署 Kasm</span></h2><ul><li>硬件要求</li></ul><table><thead><tr><th>硬件类型</th><th>配置规格</th></tr></thead><tbody><tr><td><strong>CPU</strong></td><td>2 cores</td></tr><tr><td><strong>Memory</strong></td><td>4GB</td></tr><tr><td><strong>Storage</strong></td><td>50GB (SSD)</td></tr></tbody></table><ul><li>操作系统要求</li></ul><table><thead><tr><th>支持的操作系统</th></tr></thead><tbody><tr><td>Ubuntu 18.04 / 20.04 / 22.04 (amd64/arm64)</td></tr><tr><td>Debian 9 / 10 / 11 (amd64/arm64)</td></tr><tr><td>CentOS 7 / 8 (amd64/arm64)</td></tr><tr><td>Oracle Linux 7 / 8 (amd64/arm64)</td></tr><tr><td>Raspberry Pi OS (Debian) 10 / 11 (arm64)</td></tr><tr><td><a href="https://www.kasmweb.com/docs/latest/how_to/other_operating_systems.html" target="_blank" rel="noopener">Other</a></td></tr></tbody></table><p><code>Kasm</code> 部署还是很容易的，基本只需执行以下几条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;tmp</span><br><span class="line">$ curl -O https:&#x2F;&#x2F;kasm-static-content.s3.amazonaws.com&#x2F;kasm_release_1.11.0.18142e.tar.gz</span><br><span class="line">$ tar -xvf kasm_release*.tar.gz</span><br><span class="line">$ sudo bash kasm_release&#x2F;install.sh</span><br></pre></td></tr></table></figure><p>执行完成后，安装脚本会询问『是否接受协议』和『是否启用交换分区』。你可以根据实际情况回答，当然协议是必须接受的。</p><p><img src="https://img.hi-linux.com/staticfile/WX20221012-153755-2022-10-12-TrB2Oe.png" alt></p><p>默认情况下，<code>Kasm</code> 安装脚本会去 <code>Github</code> 下载 <code>Docker-Compose V2</code> 的执行文件。如果你的网络环境不能正常访问 <code>Github</code>，安装脚本就无法正常执行。</p><p>这时你可以提前使用以下命令，先手动完成 <code>Docker-Compose V2</code> 的安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https:&#x2F;&#x2F;download.fastgit.org&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;v2.5.0&#x2F;docker-compose-linux-x86_64 -o &#x2F;usr&#x2F;local&#x2F;lib&#x2F;docker&#x2F;cli-plugins&#x2F;docker-compose</span><br><span class="line">$ chmod +x &#x2F;usr&#x2F;local&#x2F;lib&#x2F;docker&#x2F;cli-plugins&#x2F;docker-compose</span><br></pre></td></tr></table></figure><p>然后，等待脚本拉取完相应的 <code>Docker</code> 镜像。首次下载的镜像比较多，需要一定时间，请耐心等待。</p><p><img src="https://img.hi-linux.com/staticfile/WX20221012-160149-2022-10-12-ruVMVR.png" alt></p><p>最后，脚本安装完成后，会生成 <code>Kasm</code> 各组件默认的认证信息。（只显示一次，请注意保存。）</p><p><img src="https://img.hi-linux.com/staticfile/WX20221012-155525-2022-10-12-A4b779.png" alt></p><blockquote><p>注意：默认情况下，<code>Kasm Web</code> 应用程序是运行在 443 端口的，你需要在防火墙上对外开放此端口。如果你想在其他端口上运行 <code>Kasm Web</code> 应用程序，可在调用安装程序时通过 <code>-L</code> 参数指定。例如：<code>sudo bash kasm_release/install.sh -L 8443</code></p></blockquote><p>更详细官方安装教程可以查看：<a href="https://www.kasmweb.com/docs/latest/install/single_server_install.html" target="_blank" rel="noopener">Standard Installation</a>。</p><p>上面的方法是将所有 <code>Kasm</code> 服务组件部署到同一台机器上的。当然，你也可以将不同的 <code>Kasm</code> 服务角色分开安装到不同机器。具体可以参考: <a href="https://www.kasmweb.com/docs/latest/install/multi_server_install.html" target="_blank" rel="noopener">Multi Server Installation</a></p><h3><span id="访问-kasm">访问 Kasm</span></h3><p>默认情况下，你可以使用 <code>https://server_ip</code> 访问的 <code>Kasm</code> 的 Web 页面。</p><p>登陆信息就是上面安装过程中自动生成的默认凭据。</p><p><img src="https://img.hi-linux.com/staticfile/lFMyKV-2022-10-12-mb3ObR.png" alt></p><p><code>Kasm</code> 内置了很多常用的应用：</p><p><img src="https://img.hi-linux.com/staticfile/NlAxM0-2022-10-12-LNPZtO.png" alt></p><p>现在，我们来启动一个 <code>Chrome</code> 试试：</p><p><img src="https://img.hi-linux.com/staticfile/YWo2ol-2022-10-12-OvAv84.png" alt></p><p>点击一下图标后，就秒启动完成一个全新的 <code>Chrome</code> 环境。</p><p><img src="https://img.hi-linux.com/staticfile/Ycqfe7-2022-10-12-KZ0dut.png" alt></p><p>你还可以点击左面的键头图标，来使用一些辅助功能。比如：启用声音、剪贴板等。</p><p><img src="https://img.hi-linux.com/staticfile/myjMye-2022-10-12-8T0NdF.png" alt></p><p>简单体验了下，各种输入输出都很快，播放视频也是非常流畅的。接下来，再启动一个 <code>Ubuntu</code> 看看：</p><p><img src="https://img.hi-linux.com/staticfile/cZZ5O7-2022-10-12-R2qshk.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/fA7mpX-2022-10-12-n4XsEm.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/XhiYno-2022-10-12-TUEO7T.png" alt></p><p>太赞了，<code>Linux</code> 桌面应用，运行起来也是一样的丝般顺滑。</p><p><code>Kasm</code> 的强大功能远远不止这些，它还支持多用户、<code>LDAP</code>、<code>OpenID</code> 等三方认证、自定义容器应用等高级功能。有兴趣的同学可以到官网自行探索哟！</p><h2><span id="参考文档">参考文档</span></h2><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="https://www.mobile01.com/topicdetail.php?f=508&amp;t=6573952" target="_blank" rel="noopener">https://www.mobile01.com/topicdetail.php?f=508&amp;t=6573952</a></li><li><a href="https://www.kasmweb.com/docs/latest/index.html" target="_blank" rel="noopener">https://www.kasmweb.com/docs/latest/index.html</a></li><li><a href="https://www.kasmweb.com/docs/latest/install/single_server_install.html" target="_blank" rel="noopener">https://www.kasmweb.com/docs/latest/install/single_server_install.html</a></li><li><a href="https://www.kasmweb.com/docs/latest/install/multi_server_install.html" target="_blank" rel="noopener">https://www.kasmweb.com/docs/latest/install/multi_server_install.html</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kasm-介绍&quot;&gt;Kasm 介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Kasm&lt;/code&gt; 是一款基于 &lt;code&gt;Docker&lt;/code&gt; 的容器应用平台，它提供企业级编排、数据丢失防护和 &lt;code&gt;Web&lt;/code&gt; 流技术，以支持将容器化工作负载交付到你的浏览器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Kasm&lt;/code&gt; 可以在浏览器內运行各种应用，比如：&lt;code&gt;Linux&lt;/code&gt; 桌面、浏览器、聊天工具、办公软件、多媒体工具等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Kasm&lt;/code&gt; 将这些应用隔离在独立的 &lt;code&gt;Docker&lt;/code&gt; 容器内，在里面做的任何行为不会影响真实的主机，并且具备一次性特点、用完即删，保证了数据的安全性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Kasm&lt;/code&gt; 是个开源项目，你可以在个人及非营利条件下免费使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Kasm&lt;/code&gt; 官方网站: &lt;a href=&quot;https://www.kasmweb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.kasmweb.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Kasm Github&lt;/code&gt;: &lt;a href=&quot;https://github.com/kasmtech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kasmtech&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说 &lt;code&gt;Kasm&lt;/code&gt; 可以让用户在浏览器（即开即用）使用各种（容器化）的软件和操作系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>谷歌翻译停服？别慌，手把手教你一招修复 Chrome 浏览器无法翻译网页的问题</title>
    <link href="https://www.hi-linux.com/posts/43698.html"/>
    <id>https://www.hi-linux.com/posts/43698.html</id>
    <published>2022-10-09T01:00:00.000Z</published>
    <updated>2022-10-09T03:38:47.693Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最近 Google 突然关停了「谷歌翻译中国版」以及「谷歌地图中国版」两大重磅产品，让无数人惊讶！官方称原因是用户使用率太低。这次关停不单是网页版，依靠其服务的相关功能也会受到影响。</p><p>比如谷歌浏览器「Google Chrome」目前是国内使用率最高的浏览器之一，此次停服则直接影响了浏览器内置的 「<strong>自动网页翻译</strong>」功能。由于很多用户访问英文或其他语言网页的时候，都常要用到谷歌浏览器网页翻译功能。</p><a id="more"></a><p>这里我们就介绍一下解决办法：通过修改 <code>hosts</code> 文件，将谷歌翻译 API 的域名解析到能正常访问的 IP 地址。</p><p><code>hosts</code> 是一个没有扩展名的系统文件，主要作用是定义 IP 地址和主机名的映射关系。</p><p>首先，找到 Hosts 文件所在路径：</p><ul><li>Windows 系统 Hosts 文件路径：<code>C:\Windows\System32\drivers\etc\hosts</code></li><li>Mac 或 Linux 系统 Hosts 文件路径：<code>/etc/hosts</code></li><li>Android 系统 Hosts 文件路径：<code>/system/etc/hosts</code></li></ul><p>然后，你可以用任何文本编辑器工具打开 hosts 文件进行修改。在 <code>macOS</code> 或 <code>Linux</code> 下可以使用 <code>sudo vi /etc/hosts</code> 命令进行编辑，在其末尾添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 谷歌翻译服务 IP</span><br><span class="line">113.108.239.162 translate.google.com</span><br><span class="line">113.108.239.162 translate.googleapis.com</span><br></pre></td></tr></table></figure><p>将以上内容加入 <code>hosts</code> 文件后，谷歌浏览器 <code>Chrome</code> 的翻译功能就可以正常使用了。</p><p>为防止不可用，下面再提供一些备选的 IP 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 备选谷歌翻译服务 IP</span><br><span class="line">203.208.39.226</span><br><span class="line">120.253.253.34</span><br><span class="line">142.250.66.138</span><br><span class="line">142.250.0.90</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，这种修改只能恢复 <code>Chrome</code> 浏览器的内置翻译功能，并不能恢复 Web 版谷歌翻译 <code>translate.google.com</code> 的访问。</p></blockquote><p><strong>参考文档</strong></p><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="https://www.williamlong.info/archives/6947.html" target="_blank" rel="noopener">https://www.williamlong.info/archives/6947.html</a></li><li><a href="https://www.iplaysoft.com/fix-chrome-translate.html" target="_blank" rel="noopener">https://www.iplaysoft.com/fix-chrome-translate.html</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近 Google 突然关停了「谷歌翻译中国版」以及「谷歌地图中国版」两大重磅产品，让无数人惊讶！官方称原因是用户使用率太低。这次关停不单是网页版，依靠其服务的相关功能也会受到影响。&lt;/p&gt;
&lt;p&gt;比如谷歌浏览器「Google Chrome」目前是国内使用率最高的浏览器之一，此次停服则直接影响了浏览器内置的 「&lt;strong&gt;自动网页翻译&lt;/strong&gt;」功能。由于很多用户访问英文或其他语言网页的时候，都常要用到谷歌浏览器网页翻译功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Chrome" scheme="https://www.hi-linux.com/tags/Chrome/"/>
    
      <category term="Google" scheme="https://www.hi-linux.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>阿里开源，超强大的 Kubernetes 本地调试工具 Kt-Connect 使用指南</title>
    <link href="https://www.hi-linux.com/posts/39758.html"/>
    <id>https://www.hi-linux.com/posts/39758.html</id>
    <published>2022-09-27T01:00:00.000Z</published>
    <updated>2022-09-27T09:27:35.918Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="背景">背景</span></h2><blockquote><p>注：背景有点啰嗦，讲讲一路走来研发本地调试的变化，嫌烦的可以直接跳过，不影响阅读。</p></blockquote><h3><span id="2019年">2019年</span></h3><p>我在的公司当时是个什么情况，只有两个Java应用，还都跑在一个Tomcat Servlet容器。</p><p><img src="https://img.hi-linux.com/staticfile/1557258-20220819114243341-1314582490-2022-09-19-XCWjyz.png" alt></p><p>当时是如何本地调试？都是研发自己电脑装个 Mysql，装个 Tomcat，自己电脑运行调试，好处嘛就是后端研发互不干扰，想怎么改就怎么改，APP端研发就直连后端的笔记本调试。上线部署嘛就是一个研发手动编译个 Jar 包丢到云服务器上面，大体就是个草台班子，能干活，但是也就那样。</p><a id="more"></a><h3><span id="2020年">2020年</span></h3><p>到了 2020 年，公司买了一台服务器，Centos 的系统，给装上了 Mysql、Tomcat，用上了 Redis 缓存，RabbitMQ 消息队列，有了独立的测试环境，用上了 Jenkins 自动打包并部署应用，也算鸟枪换炮，起码不用自己打包了。</p><p><img src="https://img.hi-linux.com/staticfile/1557258-20220819134321534-273144804-2022-09-19-VC1hNI.png" alt></p><p>这个时候是如何本地调试呢？起码不用自己电脑装 Mysql 了，后面框架由 SpringMVC 和 Struts2 都改成 Spring Boot，外置的 Tomcat 也可以去掉了。后端研发本地运行 Spring Boot 时直连服务器的 Mysql 进行调试，APP 端再也不用连后端研发的笔记本了，有了相对稳定的调试环境。代价就是各个后端的数据库更新结构要保持兼容性，避免影响他人。</p><h3><span id="2021年">2021年</span></h3><p>随着业务增长，后端框架由 Spring Boot 进化为 Spring Cloud 全家桶，应用运行环境由 Linux 直接运行改为了 Docker 镜像部署，各类中间件同样也使用了 Docker 镜像。产品线增加，单一的开发分支已经不能满足需求，为此又开辟了另外一条后端代码分支，同样的开发测试环境也多了一份。</p><p><img src="https://img.hi-linux.com/staticfile/1557258-20220819135628647-203858289-20220919103031822-2022-09-19-26hYPm.png" alt></p><p>这个时候的本地调试，对于 APP 端来说变化不大，区别连接后端不同环境使用不同域名而已。对于后端的研发同学就不一样了，每次本地调试自己电脑要常驻一个 Eureka 和一个 Config Server，如果本地调试的微服务依赖比较多，没个大内存真是顶不住。</p><h3><span id="2022年">2022年</span></h3><p>业务量继续增加，产品同事数量增加了，那个需求量真是堆积如山，两个分支已经不能满足要求了，又开了第三个分支，还是不够。每次增加新的分支运行环境，后端研发同学也很痛苦，一堆环境和第三方平台回调需要配置。为了能动态扩容缩容，Spring Cloud 全家桶继续演进，抛弃了 Zuul 网关和 Eureka，改为使用 Spring Cloud Kubernetes，运行环境全面向 K8S 靠拢。在此期间公司又采购了一台服务器用于开发测试，内存 CPU 磁盘满上!</p><p><img src="https://img.hi-linux.com/staticfile/1557258-20220819153015204-416674218-20220919103037001-2022-09-19-BkYrUI.png" alt></p><p>进入 K8S 时代，后端研发本地的电脑没办法随意连接 Linux 服务器上面的各种中间件，每个新分支环境里面的每个 POD 都是一个新的 IP，也不可能像之前那样开放指定几个中间件的端口给后端连接，那么多环境每个都做设置的话，运维同学整天不用干别的事了。也由此引出了今天要说的 kt-connect 工具，通过这个工具，后端研发本地的电脑可以代理访问到各个分支环境，也就是 K8S 里面的命名空间的所有服务，并且只需要启动需要调试的服务，大大节省了电脑 CPU 内存占用。</p><h2><span id="选型">选型</span></h2><p>在选择代理访问 K8S 环境以便于本地调试的工具中，网上有几种。</p><h3><span id="1-端口转发">1. 端口转发</span></h3><p>使用 Ingress、NodePort、LoadBalancer 之类的将流量转发到指定端口，如上文所说，会让运维同学工作量比较大，也不便于分支环境的自动创建和回收，只适合需要暴露端口数量不多的场景。</p><h3><span id="2-vpn">2. VPN</span></h3><p>通过在 K8S 每个命名空间里面设置一个运行有 VPN 服务的 POD，后端研发笔记本通过 VPN 客户端连接代理进入到指定命名空间，可以正常访问和解析集群内各类服务，基本能满足日常的要求，缺点是每个命名空间都常驻了一个 VPN 服务的运行资源。</p><h3><span id="3-telepresence">3. Telepresence</span></h3><p>在搜索的过程中发现了这个代理工具，几乎可以说 9 成的中英文技术文章都推荐使用这个工具，功能非常强大，不但提供了 VPN 所具有的代理功能，可以访问到命名空间内所有服务，还能指定各种规则拦截指定服务的流量到本地机器，相当于本地机器也能作为一个普通的 POD 提供对外服务。大体设计原理如下：</p><p><img src="https://img.hi-linux.com/staticfile/1557258-20220825171140771-1117068712-2022-09-19-Gz6nqH.png" alt></p><p>在研发本地电脑执行如下命令</p><blockquote><p>telepresence helm install --kubeconfig .\kubeconfig<br>telepresence connect —kubeconfig .\kubeconfig</p></blockquote><p>就会自动在 K8S 集群创建一个命名空间 ambassador，并且部署一个 traffic-manager 的 Pod，用于流量管理，而在研发笔记本本地则会启动 2 个 Daemon 服务，其中一个叫 Root Daemon，用于建立一条双向代理通道，并管理本地电脑与 K8S 集群之间的流量，另外一个 User Daemon 则是负责与 Traffic Manager 通信，设置拦截规则，如果登录后还负责与 Ambassador Cloud 进行通信。</p><p>通过配置拦截规则，拦截的 Pod 里面会安装一个 traffic-agent，官方文档说明是类似 K8S 集群的 sidecar 模式，对注入 POD 进行流量劫持，所有流量出入通过 traffic-manager 进行重新路由。</p><blockquote><p>The Traffic Agent is a sidecar container that facilitates intercepts. When an intercept is first started, the Traffic Agent container is injected into the workload’s pod(s).</p></blockquote><p>虽然他的功能很强大，但是在目前 2.5 版本的使用过程中，为了使用他的拦截和 Preview Url 功能必须在他家的商业云平台 Ambassador Cloud 进行注册登陆(注：不知道为什么网上技术文章都没提到这点，测试的时候非得要登录他家云平台)，并且拦截规则的配置是通过云平台的网页进行操作的，联网的要求，包括可能存在的安全，泄露之类的隐患，我觉得是不可接受，也因此不得不放弃使用这个工具。</p><p>还有一个不得不说的缺点就是，老版本使用后可以清理掉自动创建的命名空间（namespace）和 Pod、拦截 Agent 的功能（telepresence uninstall）也没了，在 2.5 版本的命令参数里面完全消失了，这就导致每次使用后，如果想保持环境干净，还得麻烦运维同学去清理掉，非常麻烦，简直逼死洁癖患者。</p><h3><span id="4-kt-connect">4. kt-connect</span></h3><p>所幸开源社区又找到了另外一款类似 Telepresence 的工具，名为<a href="https://github.com/alibaba/kt-connect" target="_blank" rel="noopener">kt-connect</a>，使用版本为 v0.3.6（顺便说下我们使用的 K8S 版本是 1.24），并且它无需联网登陆什么账号，结束命令执行默认还会自动清理。阿里出品，不确定是不是又一个 KPI 开源项目，但是至少这一刻我对这个工具是非常满意的。</p><h2><span id="原理">原理</span></h2><p>同 Telepresence 类似，但不同的是，kt-connect 只会在指定连接的命名空间（namespace）里面新建一个自用的 Pod，然后部署一个 kt-connect-shadow 的镜像。相比 Telepresence，它在模式进行了细分扩展，分为四大模式：</p><h3><span id="1-connect模式">1. Connect模式</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ktctl.exe connect --kubeconfig .\kubeconfig --namespace feature-N --debug</span><br></pre></td></tr></table></figure><p>这个模式下，kt-connect 起到的是一个类似于VPN的作用，研发本地电脑可以访问到连接的命名空间(namespace)内的所有服务，但是并没有加到集群里面其他服务里面，其他服务的流量并不会转发到本地电脑。</p><blockquote><p>注1：与 telepresence 类似，kt-connect 所有命令都要带上 <code>--kubeconfig</code> ，确保有足够权限和能正确连接 K8S 集群的 API Server，很多文章都很少提到这点，假如K8S集群限制权限，或者与研发不在同一个网络，必须确保使用运维同学提供的有足够权限的授权文件 kubeconfig 来进行连接。</p></blockquote><blockquote><p>注2：</p><p>Failed to setup port forward local:28344 -&gt; pod kt-connect-shadow-gseak:53 error=“error upgrading connection: error sending request: Post “<a href="https://10.0.8.101:8443/api/v1/namespaces/feature-N/pods/kt-connect-shadow-gseak/portforward" target="_blank" rel="noopener">https://10.0.8.101:8443/api/v1/namespaces/feature-N/pods/kt-connect-shadow-gseak/portforward</a>”: dial tcp 10.0.8.101:8443: connectex: A socket operation was attempted to an unreachable host.”，</p></blockquote><p>如果出现以上报错的话，有可能是 kt-connect 路由 BUG，可能本地电脑的路由与新加的通往 API Server 的路由有冲突，增加参数 <code>--excludeIps 10.0.8.101/32</code> 即可，如果网段冲突比较多，可以扩大网段范围，例如<code>--excludeIps 10.0.8.0/24</code> 参考 <a href="https://github.com/alibaba/kt-connect/issues/302" target="_blank" rel="noopener">issue-302</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ktctl.exe connect --kubeconfig .\kubeconfig --namespace feature-N --excludeIps 10.0.8.101&#x2F;32 --debug</span><br></pre></td></tr></table></figure><h3><span id="2-exchange模式">2. Exchange模式</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ktctl.exe exchange serviceA --kubeconfig .\kubeconfig --namespace feature-N --expose 12001 --debug</span><br></pre></td></tr></table></figure><p>这个模式类似于 Telepresence 拦截模式，将指定服务的所有流量拦截下来转发到研发本地电脑的端口，使用这个模式能对环境里的访问请求直接进行调试。</p><p>具体原理就是将 service 里面的 Pod 替换成一个 <code>serviceA-kt-exchange</code> 的 Pod。</p><blockquote><p>注1：Exchange 模式的流量方向是单向的，并不会将本地电脑主动发起的请求代理过去，如果K8S集群跟研发本地电脑不在一个网段内，需要另外开一个命令行运行 Connect 模式，确保本地服务可以正常连接 K8S 集群的其他服务，参考<a href="https://github.com/alibaba/kt-connect/issues/216" target="_blank" rel="noopener">issue-216</a>。</p></blockquote><blockquote><p>注2：Exchange 模式是通过拦截 service 进行流量转发，假如集群的请求没有经过 service，例如直接解析到 Pod 类，可能就会出现拦截失败的情况（同理 Mesh 模式也是如此），所以出现问题记得跟运维同学确认K8S集群内的路由情况。</p></blockquote><h3><span id="3-mesh模式">3. Mesh模式</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kctl.exe mesh serviceA --kubeconfig .\kubeconfig --namespace feature-N --expose 12001 --debug</span><br></pre></td></tr></table></figure><p>执行命令后可以看到输出日志里面包含类似文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2:30PM INF Now you can access your service by header &#39;VERSION: xxxxx&#39;</span><br></pre></td></tr></table></figure><p>这个模式本地电脑的服务和 K8S 集群里面相同的服务同时对外响应请求，但是只有通过指定的 http 请求头 VERSION: xxxx 的请求才会转发到本地电脑，相比 Exchange 模式，保证了其他人服务正常使用，同时研发又能进行本地调试。每次生成的请求头 VERSION 的值都是动态生成的，如果要固定这个值，可以通过参数 <code>--versionMark</code> 写死，例如固定值为 test-version，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kctl.exe mesh serviceA --kubeconfig .\kubeconfig --namespace feature-N --expose 12001 --debug --versionMark test-version</span><br></pre></td></tr></table></figure><p>具体原理就是将 serviceA 里面的 Pod 替换成一个 serviceA-kt-router 的路由镜像，负责根据请求头进行流量代理转发，另外生成一个 serviceA-kt-stuntman 服务，这个就是线上正常运行的 serviceA，还有一个serviceA-kt-mesh-xxxxx 服务，这个就负责将代理流量到本地电脑。</p><h3><span id="4-preview模式">4. Preview模式</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kctl.exe preview serviceB --kubeconfig .\kubeconfig --namespace feature-N --expose 12001</span><br></pre></td></tr></table></figure><p>不同于 Exchange 和 Mesh 模式要求 K8S 集群有一个在运行的服务，Preview 模式可以将本地电脑运行的程序部署到 K8S 集群中作为一个全新的 Service 对外提供服务，非常便于新建服务的开发调试、预览等作用。</p><blockquote><p>本文转载自：「 博客园 」，原文：<a href="https://url.hi-linux.com/9JmW5%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.hi-linux.com/9JmW5，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;注：背景有点啰嗦，讲讲一路走来研发本地调试的变化，嫌烦的可以直接跳过，不影响阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2019年&quot;&gt;2019年&lt;/h3&gt;
&lt;p&gt;我在的公司当时是个什么情况，只有两个Java应用，还都跑在一个Tomcat Servlet容器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/1557258-20220819114243341-1314582490-2022-09-19-XCWjyz.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当时是如何本地调试？都是研发自己电脑装个 Mysql，装个 Tomcat，自己电脑运行调试，好处嘛就是后端研发互不干扰，想怎么改就怎么改，APP端研发就直连后端的笔记本调试。上线部署嘛就是一个研发手动编译个 Jar 包丢到云服务器上面，大体就是个草台班子，能干活，但是也就那样。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 KubeSeal 高效加密和管理 Kubernetes 集群的 Secret</title>
    <link href="https://www.hi-linux.com/posts/35875.html"/>
    <id>https://www.hi-linux.com/posts/35875.html</id>
    <published>2022-09-23T01:00:00.000Z</published>
    <updated>2022-09-23T01:21:21.530Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在 K8s 的管理过程中，像 Secret 这种资源并不好维护，KubeSeal 提供了一种相对简单的方式来对原始 Secret 资源进行加密，并通过控制器进行解密，以此来规避 Secret 泄露风险。</p><a id="more"></a><h2><span id="安装">安装</span></h2><h3><span id="安装-kubeseal">安装 <code>KubeSeal</code></span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.18.0/kubeseal-0.18.0-linux-amd64.tar.gz</span><br><span class="line">$ tar -xvf kubeseal-0.18.0-linux-amd64.tar.gz</span><br><span class="line">$ cp kubeseal /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">$ kubeseal --version</span><br></pre></td></tr></table></figure><h3><span id="安装controller">安装<code>controller</code></span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.18.0/controller.yaml</span><br></pre></td></tr></table></figure><p>执行上述命令之后会在 <code>kube-system</code> 命名空间下启动一个控制器 Pod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ k get pod -n kube-system |grep seal</span><br><span class="line">sealed-secrets-controller-b9fb75d85-k4csm    1/1     Running   0          7h28m</span><br></pre></td></tr></table></figure><p>Pod 启动之后，使用端口转发映射到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-system port-forward svc/sealed-secrets-controller 8080:8080</span><br></pre></td></tr></table></figure><h2><span id="使用方式">使用方式</span></h2><h3><span id="生成加密文件">生成加密文件</span></h3><p>首先在本地创建一个名为 <code>secret-example.yaml</code> 的文件，编码前的 <code>secret</code> 字段为：<code>mysupersecret</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-example</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="string">bXlzdXBlcnNlY3JldAo=</span></span><br></pre></td></tr></table></figure><p>使用如下命令将 <code>secret-example.yaml</code>，转换为加密后的文件 <code>sealed-secret-example.yaml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeseal --secret-file secret-example.yaml --sealed-secret-file sealed-secret-example.yaml</span><br></pre></td></tr></table></figure><p><code>sealed-secret-example.yaml</code> 的内容如下，<code>spec.encryptedData.secret</code> 就是加密后的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">bitnami.com/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">SealedSecret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">encryptedData:</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="string">AgB1ZZg8+J+0HLymOQZdTfWVQZiNkhm5X6WULJuBAAEaQQNhM8i2TV2I1SgKT4sUOCRv90XA1oeFld3XoGPjvYE3leOD1cvK1dDVqno6mNLRziokISk/9fB3cVE2GVgyCud//M53xNpVemDufgsJS2q/KGIOeNEijk9ZM2FaKoLDwtPaVNL0NfmC2xne2XtWJp+/eMOREhbubQhnj5M/Se75axazviuDNf6Ss9fAuR38Msd5DXnKBtyrckEHSa8TDn8ErssOh0ogX14e0/ThN3EWJecSBtx7Xfd0m90+vjmvWevMag442349aquR/qLo0mg40mhcCqSBw/MjaIGZ2F5XRufG1WEP43OgLMTixN2lLSU3eYTrv5t075taI9WJgoOl0DD8UA74EMpX7RMKTiXD6C0XngKmMKg5fUK7JNLFfwHMRPi4zNTwJa9ViDyD0iAJrGGbmMso/nHEtwOtrLE5Rrf0kLQ5N6Lj57gOBdqu903/vDM4Jm695GvEWL2aR3ShOxasHCuZeXj8Q5+KYWeF9sySiJH8bwEtaw6x7j9AxBOwjxWYD0Jvj9KhtlqBa4okSDc3bcgRKGhsSXQx6jOumI5rj+V542hkB6Z8JOtJ17VmzR6XDQDmqSl1FqqwKD5n5yUy5Kf6pJYBnsgKn3TzesQ6JfQbyRLTh1Pn3odOYCnp+Ixbd0Tgn0n5m0KO3RX0hiwGoe0hObIZcsF36g==</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">data:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">secret-example</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure><p>可以将加密后的文件保存到 Gitlab。</p><p>创建加密文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ k create -f sealed-secret-example.yaml</span><br><span class="line">sealedsecret.bitnami.com/secret-example created</span><br><span class="line"></span><br><span class="line">$ k get sealedsecrets.bitnami.com</span><br><span class="line">NAME             AGE</span><br><span class="line">secret-example   6s</span><br></pre></td></tr></table></figure><p>在创建完加密文件之后，Controller 会解密并生成对应的 <code>secret</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ k get secrets |grep secret-example</span><br><span class="line">secret-example                                   Opaque                                1      2m15s</span><br></pre></td></tr></table></figure><p>查看由 Controller 生成的 <code>secret</code> 资源内容，可以看到 <code>data.secret</code> 与上面创建的 <code>secret-example.yaml</code> 文件内容一致：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">k</span> <span class="string">get</span> <span class="string">secret</span> <span class="string">secret-example</span> <span class="string">-oyaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="string">bXlzdXBlcnNlY3JldAo=</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2022-06-10T00:50:40Z"</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">bitnami.com/v1alpha1</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">SealedSecret</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">secret-example</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">57a5b691-9bb5-4dac-800a-1a1baa878299</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"675560"</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">e0db31ad-082b-4596-9fd0-28cc810d86f4</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br></pre></td></tr></table></figure><blockquote><p>注：<code>SealedSecret</code> 和对应的 <code>secret</code> 资源必须位于相同的命名空间</p></blockquote><h3><span id="tips">TIPs</span></h3><ul><li><p><code>kubeseal</code> 支持如下<a href="https://github.com/bitnami-labs/sealed-secrets/blob/main/cmd/controller/server.go#L40" target="_blank" rel="noopener">API</a>：</p><table><thead><tr><th>Route</th><th>Description</th></tr></thead><tbody><tr><td>/healthz</td><td>Health check route useful for the readiness and liveness probes and for creating an external probe; for example with blackbox exporter.</td></tr><tr><td>/metrics</td><td>Endpoint for the Prometheus to retrieve the controller’s metrics.</td></tr><tr><td>/v1/verify</td><td>Validates a secret.</td></tr><tr><td>/v1/rotate</td><td>Rotates the secret.</td></tr><tr><td>/v1/cert.pem</td><td>Retrieves the public certificate.</td></tr></tbody></table></li><li><p>上例中 Controller 用的证书是自己生成的，还可以<a href="https://github.com/bitnami-labs/sealed-secrets/blob/main/docs/bring-your-own-certificates.md" target="_blank" rel="noopener">指定自己的证书</a>，更方便迁移和管理</p></li><li><p>使用 <code>KubeSeal</code> 可能会有一种困惑，如果用户直接挂载其他命名空间的 secret，那么这样可能会导致 secret 泄露。官方对此有作<a href="https://github.com/bitnami-labs/sealed-secrets#scopes" target="_blank" rel="noopener">解释</a>，如可以通过 RBAC 限制用户可以访问的命名空间以及资源类型。更多参见<a href="https://github.com/bitnami-labs/sealed-secrets#sealed-secrets-for-kubernetes" target="_blank" rel="noopener">README</a></p></li></ul><h3><span id="参考">参考</span></h3><ul><li><a href="https://carlosalca.medium.com/how-to-manage-all-my-k8s-secrets-in-git-securely-with-bitnami-sealed-secrets-43580b8fa0c7" target="_blank" rel="noopener">How to manage all my K8s secrets in git securely with Bitnami Sealed Secrets</a></li></ul><blockquote><p>本文转载自：「 博客园 」，原文：<a href="https://url.hi-linux.com/vakJR" target="_blank" rel="noopener">https://url.hi-linux.com/vakJR</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 K8s 的管理过程中，像 Secret 这种资源并不好维护，KubeSeal 提供了一种相对简单的方式来对原始 Secret 资源进行加密，并通过控制器进行解密，以此来规避 Secret 泄露风险。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>图解 Kubernetes 网络流量流转路径</title>
    <link href="https://www.hi-linux.com/posts/13487.html"/>
    <id>https://www.hi-linux.com/posts/13487.html</id>
    <published>2022-09-20T01:00:00.000Z</published>
    <updated>2022-09-20T06:07:22.929Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>本文翻译自 <a href="https://learnk8s.io/kubernetes-network-packets%EF%BC%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E9%80%90%E5%AD%97%E7%BF%BB%E8%AF%91%EF%BC%8C%E5%B8%A6%E5%85%A5%E4%BA%86%E4%BA%9B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82" target="_blank" rel="noopener">https://learnk8s.io/kubernetes-network-packets，并没有逐字翻译，带入了些自己的理解。</a></p></blockquote><p><img src="https://img.hi-linux.com/staticfile/k8s-network-1-2022-09-19-c7m4AB.svg" alt></p><p>阅读本文，你可以了解在 Kubernetes 内外，数据包是如何转发的，从原始的 Web 请求开始，到托管应用程序的容器。</p><h2><span id="kubernetes-网络要求">Kubernetes 网络要求</span></h2><p>在深入了解在 Kubernetes 集群中数据包如何流转的细节之前，先明确一下 Kubernetes 对网络的要求。</p><p>Kubernetes 网络模型定义了一组基本规则：</p><ul><li>在不使用网络地址转换 (NAT) 的情况下，集群中的 Pod 能够与任意其他 Pod 进行通信。</li><li>在不使用网络地址转换 (NAT) 的情况下，在集群节点上运行的程序能与同一节点上的任何 Pod 进行通信。</li><li>每个 Pod 都有自己的 IP 地址（IP-per-Pod），并且任意其他 Pod 都可以通过相同的这个地址访问它。</li></ul><p>这些要求，不会将具体实现限制在某种解决方案上。</p><a id="more"></a><p>相反，它们笼统地描述了集群网络的特性。</p><p>为了满足这些限制，你必须解决以下挑战:</p><ol><li>如何确保同一个 Pod 中的容器行为就像它们在同一个主机上一样？</li><li>集群中的 Pod 能否访问其他 Pod？</li><li>Pod 可以访问服务吗？服务是负载均衡的吗？</li><li>Pod 可以接收集群外部的流量吗？</li></ol><p>在本文中，将重点关注前三点，从 Pod 内的网络，容器到容器的通信说起。</p><h2><span id="linux-网络命名空间如何在-pod-中工作">Linux 网络命名空间如何在 Pod 中工作</span></h2><p>让我们来看一个运行应用的主容器和伴随一起的另一个容器。</p><p>在示例中，有一个带有 nginx 和 busybox 容器的 Pod:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: multi-container-Pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: container-1</span><br><span class="line">      image: busybox</span><br><span class="line">      command: [&#39;&#x2F;bin&#x2F;sh&#39;, &#39;-c&#39;, &#39;sleep 1d&#39;]</span><br><span class="line">    - name: container-2</span><br><span class="line">      image: nginx</span><br></pre></td></tr></table></figure><p>部署时，会发生以下事情：</p><ol><li>Pod 在节点上拥有独立的网络命名空间。</li><li>分配一个 IP 地址给 Pod ，两个容器之间共享端口。</li><li>两个容器共享相同的网络命名空间，并在本地彼此可见。</li></ol><p>网络配置在后台迅速完成。</p><p>但是，让我们退后一步，尝试理解为什么运行容器需要上述动作。</p><p><a href="https://iximiuz.com/en/posts/container-networking-is-simple/" target="_blank" rel="noopener">在 Linux 中，网络命名空间是独立的、隔离的逻辑空间。</a></p><p>你可以将网络命名空间视为，将物理网络接口分割小块之后的独立部分。</p><p>每个部分都可以单独配置，并拥有自己的网络规则和资源。</p><p>这些包括防火墙规则、接口（虚拟的或物理的）、路由以及与网络相关的所有内容。</p><ol><li>物理网络接口持有根网络命名空间。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-2-2022-09-19-2lGj37.svg" alt></p><ol start="2"><li>你可以使用 Linux 网络命名空间来创建独立的网络。每个网络都是独立的，除非你进行配置，默认不会与其他网络互通。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-3-2022-09-19-0Iv3p7.svg" alt></p><p>但最终，还是需要物理接口处理所有真实的数据包，所有虚拟接口都是基于物理接口创建的。</p><p>网络命名空间可以通过 <a href="https://man7.org/linux/man-pages/man8/ip-netns.8.html" target="_blank" rel="noopener">ip-netns</a> 进行管理，使用 <code>ip netns list</code> 可以列出主机上的命名空间。</p><blockquote><p>需要注意的是，创建的网络命名空间会出现在 <code>/var/run/netns</code> 下面，但 Docker 并没有遵循这一规则。</p></blockquote><p>例如，这是 Kubernetes 节点的一些命名空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns list</span><br><span class="line"></span><br><span class="line">cni-0f226515-e28b-df13-9f16-dd79456825ac (id: 3)</span><br><span class="line">cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd (id: 4)</span><br><span class="line">cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e (id: 2)</span><br><span class="line">cni-7619c818-5b66-5d45-91c1-1c516f559291 (id: 1)</span><br><span class="line">cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8 (id: 0)</span><br></pre></td></tr></table></figure><blockquote><p>注意 cni- 前缀；这意味着命名空间是由 CNI 插件创建的。</p></blockquote><p>当你创建一个 Pod，Pod 被分配给一个节点后，CNI 将：</p><ol><li>分配 IP 地址。</li><li>将容器连接到网络。</li></ol><p>如果 Pod 包含多个容器，那么这些容器都将被放在同一个命名空间中。</p><ol><li>当创建 Pod 时，容器运行时会给容器创建一个网络命名空间。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-4-20220919141522939-2022-09-19-nMCwoz.svg" alt></p><ol start="2"><li>然后 CNI 负责给 Pod 分配一个 IP 地址。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-5-2022-09-19-sBtEl3.svg" alt></p><ol start="3"><li>最后 CNI 将容器连接到网络的其余部分。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-6-2022-09-19-MiJzyw.svg" alt></p><p>那么，当你列出节点上的容器的命名空间会发生什么呢？</p><p>你可以通过 SSH 连接到 Kubernetes 节点并查看命名空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ lsns -t net</span><br><span class="line"></span><br><span class="line">        NS TYPE NPROCS   PID USER     NETNSID NSFS                           COMMAND</span><br><span class="line">4026531992 net     171     1 root  unassigned &#x2F;run&#x2F;docker&#x2F;netns&#x2F;default      &#x2F;sbin&#x2F;init noembed norestore</span><br><span class="line">4026532286 net       2  4808 65535          0 &#x2F;run&#x2F;docker&#x2F;netns&#x2F;56c020051c3b &#x2F;pause</span><br><span class="line">4026532414 net       5  5489 65535          1 &#x2F;run&#x2F;docker&#x2F;netns&#x2F;7db647b9b187 &#x2F;pause</span><br></pre></td></tr></table></figure><p><code>lsns</code> 是一个用于列出主机上所有可用命名空间的命令。</p><blockquote><p>请记住，Linux 中有<a href="https://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener">多种命名空间类型</a>。</p></blockquote><p>Nginx 容器在哪里？</p><p>那些 pause 容器是什么？</p><h2><span id="在-pod-中pause-容器创建了网络命名空间">在 Pod 中，pause 容器创建了网络命名空间</span></h2><p>先列出节点上的所有命名空间，看看能否找到 Nginx 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ lsns</span><br><span class="line">        NS TYPE   NPROCS   PID USER            COMMAND</span><br><span class="line"># truncated output</span><br><span class="line">4026532414 net         5  5489 65535           &#x2F;pause</span><br><span class="line">4026532513 mnt         1  5599 root            sleep 1d</span><br><span class="line">4026532514 uts         1  5599 root            sleep 1d</span><br><span class="line">4026532515 pid         1  5599 root            sleep 1d</span><br><span class="line">4026532516 mnt         3  5777 root            nginx: master process nginx -g daemon off;</span><br><span class="line">4026532517 uts         3  5777 root            nginx: master process nginx -g daemon off;</span><br><span class="line">4026532518 pid         3  5777 root            nginx: master process nginx -g daemon off;</span><br></pre></td></tr></table></figure><p>Nginx 容器在挂载 (<code>mnt</code>)、Unix time-sharing (<code>uts</code>) 和 PID (<code>pid</code>) 命名空间中，但不在网络命名空间 (<code>net</code>) 中。</p><p>不幸的是，<code>lsns</code> 只显示每个进程最小的 PID，但你可以根据这个进程 ID 进一步过滤。</p><p>使用以下命令，在所有命名空间中检索 Nginx 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo lsns -p 5777</span><br><span class="line"></span><br><span class="line">       NS TYPE   NPROCS   PID USER  COMMAND</span><br><span class="line">4026531835 cgroup    178     1 root  &#x2F;sbin&#x2F;init noembed norestore</span><br><span class="line">4026531837 user      178     1 root  &#x2F;sbin&#x2F;init noembed norestore</span><br><span class="line">4026532411 ipc         5  5489 65535 &#x2F;pause</span><br><span class="line">4026532414 net         5  5489 65535 &#x2F;pause</span><br><span class="line">4026532516 mnt         3  5777 root  nginx: master process nginx -g daemon off;</span><br><span class="line">4026532517 uts         3  5777 root  nginx: master process nginx -g daemon off;</span><br><span class="line">4026532518 pid         3  5777 root  nginx: master process nginx -g daemon off;</span><br></pre></td></tr></table></figure><p><code>pause</code> 进程再次出现，它劫持了网络命名空间。</p><p>这是怎么回事？</p><p><em><strong>集群中的每个 Pod 都有一个额外的隐藏容器在后台运行，称为 pause 容器。</strong></em></p><p>列出在节点上运行的容器并获取 pause 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps | grep pause</span><br><span class="line"></span><br><span class="line">fa9666c1d9c6   k8s.gcr.io&#x2F;pause:3.4.1  &quot;&#x2F;pause&quot;  k8s_POD_kube-dns-599484b884-sv2js…</span><br><span class="line">44218e010aeb   k8s.gcr.io&#x2F;pause:3.4.1  &quot;&#x2F;pause&quot;  k8s_POD_blackbox-exporter-55c457d…</span><br><span class="line">5fb4b5942c66   k8s.gcr.io&#x2F;pause:3.4.1  &quot;&#x2F;pause&quot;  k8s_POD_kube-dns-599484b884-cq99x…</span><br><span class="line">8007db79dcf2   k8s.gcr.io&#x2F;pause:3.4.1  &quot;&#x2F;pause&quot;  k8s_POD_konnectivity-agent-84f87c…</span><br></pre></td></tr></table></figure><p>可以看到，节点上的每一个 Pod 都会有一个对应的 pause 容器。</p><p>这个 <code>pause</code> 容器负责创建和维持网络命名空间。</p><p><a href="https://www.aquasec.com/cloud-native-academy/container-security/container-runtime/" target="_blank" rel="noopener">底层容器运行时</a>会完成网络命名空间的创建，通常是由 <code>containerd</code> 或 <code>CRI-O</code> 完成。</p><p>在部署 Pod 和创建容器之前，由运行时创建网络命名空间。</p><p>容器运行时会自动完成这些，不需要手工执行 <code>ip netns</code> 创建命名空间。</p><p>话题回到 pause 容器。</p><p>它包含非常少的代码，并且在部署后立即进入睡眠状态。</p><p>但是，<a href="https://www.ianlewis.org/en/almighty-pause-container" target="_blank" rel="noopener">它是必不可少的，并且在 Kubernetes 生态系统中起着至关重要的作用</a>。</p><ol><li>创建 Pod 时，容器运行时会创建一个带有睡眠容器的网络命名空间。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-7-20220919141528218-2022-09-19-7EsuRT.svg" alt></p><ol start="2"><li>Pod 中的其他容器都会加入由 pause 容器创建的网络名称空间。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-8-20220919141535160-2022-09-19-JOFs8C.svg" alt></p><ol start="3"><li>此时，CNI 分配 IP 地址并将容器连接到网络。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-9-2022-09-19-Wxey6q.svg" alt></p><p>一个进入睡眠状态的容器有什么用？</p><p>为了理解它的用途，让我们想象一个 Pod 有两个容器，就像前面的例子一样，但没有 pause 容器。</p><p>一旦容器启动，CNI 将会：</p><ol><li>使 busybox 容器加入之前的网络命名空间。</li><li>分配 IP 地址。</li><li>将容器连接到网络。</li></ol><p>如果 Nginx 崩溃了怎么办？</p><p>CNI 将不得不再次执行所有步骤，并且两个容器的网络都将中断。</p><p>由于睡眠容器不太可能有任何错误，因此创建网络命名空间通常是一种更安全、更健壮的选择。</p><blockquote><p>如果 Pod 中的一个容器崩溃了，剩下的仍然可以回复其他网络请求。</p></blockquote><h2><span id="分配一个-ip-地址给-pod">分配一个 IP 地址给 Pod</span></h2><p>前面我提到 Pod 和两个容器将具有同一个 IP 地址。</p><p>那是怎样配置的呢？</p><blockquote><p>在 Pod 网络命名空间内，创建了一个接口，并分配了一个 IP 地址。</p></blockquote><p>让我们验证一下。</p><p>首先，找到 Pod 的 IP 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get Pod multi-container-Pod -o jsonpath&#x3D;&#123;.status.PodIP&#125;</span><br><span class="line"></span><br><span class="line">10.244.4.40</span><br></pre></td></tr></table></figure><p>接下来，找到相关的网络命名空间。</p><p>由于网络命名空间是从物理接口创建的，需要先访问集群节点。</p><blockquote><p>如果你运行的是 minikube，使用 <code>minikube ssh</code> 访问节点。如果在云厂中运行，那么应该有某种方法可以通过 SSH 访问节点。</p></blockquote><p>进入后，找到最新创建的命名网络命名空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lt &#x2F;var&#x2F;run&#x2F;netns</span><br><span class="line"></span><br><span class="line">total 0</span><br><span class="line">-r--r--r-- 1 root root 0 Sep 25 13:34 cni-0f226515-e28b-df13-9f16-dd79456825ac</span><br><span class="line">-r--r--r-- 1 root root 0 Sep 24 09:39 cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd</span><br><span class="line">-r--r--r-- 1 root root 0 Sep 24 09:39 cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e</span><br><span class="line">-r--r--r-- 1 root root 0 Sep 24 09:39 cni-7619c818-5b66-5d45-91c1-1c516f559291</span><br><span class="line">-r--r--r-- 1 root root 0 Sep 24 09:39 cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8</span><br></pre></td></tr></table></figure><p>在示例中，就是 <code>cni-0f226515-e28b-df13-9f16-dd79456825ac</code>。然后，可以在该命名空间内运行 <code>exec</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac ip a</span><br><span class="line"></span><br><span class="line"># output truncated</span><br><span class="line">3: eth0@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.244.4.40&#x2F;32 brd 10.244.4.40 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::14a4:f8ff:fe4f:5677&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>这个 IP 就是 Pod 的 IP 地址！通过查找 @if12 中的 12 找到网络接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip link | grep -A1 ^12</span><br><span class="line"></span><br><span class="line">12: vethweplb3f36a0@if16: mtu 1376 qdisc noqueue master weave state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 72:1c:73:d9:d9:f6 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure><p>你还可以验证 Nginx 容器是否监听了来自该命名空间内的 HTTP 流量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac netstat -lnp</span><br><span class="line"></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      692698&#x2F;nginx: master</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      692698&#x2F;nginx: master</span><br></pre></td></tr></table></figure><blockquote><p>如果你无法通过 SSH 访问集群中的工作节点，你可以使用 <code>kubectl exec</code> 获取到 busybox 容器的 shell 并直接在内部使用 <code>ip</code> 和 <code>netstat</code> 命令。</p></blockquote><p>刚刚我们介绍了容器之间的通信，再来看看如何建立 Pod 到 Pod 的通信吧。</p><h2><span id="查看集群中-pod-到-pod-的流量">查看集群中 Pod 到 Pod 的流量</span></h2><p>Pod 到 Pod 的通信有两种可能的情况：</p><ol><li>Pod 流量的目的地是同一节点上的 Pod。</li><li>Pod 流量的目的地是在不同节点上的 Pod。</li></ol><p>整个工作流依赖于虚拟接口对和网桥，下面先来了解一下这部分的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了让一个 Pod 与其他 Pod 通信，它必须先访问节点的根命名空间。</span><br></pre></td></tr></table></figure><p>通过虚拟以太网对来实现 Pod 和根命名空间的连接。</p><p>这些虚拟接口设备（veth 中的 v）连接并充当两个命名空间之间的隧道。</p><p>使用此 <code>veth</code> 设备，你将一端连接到 Pod 的命名空间，另一端连接到根命名空间。</p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-10-2022-09-19-zqzPW6.svg" alt></p><p>CNI 可以帮你执行这些操作，但你也可以手动执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip link add veth1 netns Pod-namespace type veth peer veth2 netns root</span><br></pre></td></tr></table></figure><p>现在 Pod 的命名空间有一个可以访问根命名空间的 <code>隧道</code>。</p><p>节点上，新建的每一个 Pod 都会设置这样的 <code>veth</code> 对。</p><p>一个是，创建接口对；另一个是为以太网设备分配地址并配置默认路由。</p><p>下面看看如何在 Pod 的命名空间中设置 <code>veth1</code> 接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac ip addr add 10.244.4.40&#x2F;24 dev veth1</span><br><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac ip link set veth1 up</span><br><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac ip route add default via 10.244.4.40</span><br></pre></td></tr></table></figure><p>在节点上，让我们创建另一个 <code>veth2</code> 对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr add 169.254.132.141&#x2F;16 dev veth2</span><br><span class="line">$ ip link set veth2 up</span><br></pre></td></tr></table></figure><p>可以像前面一样检查现有的 <code>veth</code> 对。</p><p>在 Pod 的命名空间中，检索 <code>eth0</code> 接口的后缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac ip link show type veth</span><br><span class="line"></span><br><span class="line">3: eth0@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure><p>在这种情况下，可以使用命令 <code>grep -A1 ^12</code> 查找（或滚动到目标所在处）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip link show type veth</span><br><span class="line"></span><br><span class="line"># output truncated</span><br><span class="line">12: cali97e50e215bd@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netns cni-0f226515-e28b-df13-9f16-dd79456825ac</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用 <code>ip -n cni-0f226515-e28b-df13-9f16-dd79456825ac link show type veth</code>.命令</p></blockquote><p>注意 <code>3: eth0@if12和12: cali97e50e215bd@if3</code> 接口上的符号。</p><p>从 Pod 命名空间，该 <code>eth0</code> 接口连接到根命名空间的 12 号接口，因此是 <code>@if12</code>.</p><p>在 <code>veth</code> 对的另一端，根命名空间连接到 Pod 命名空间的 3 号接口。</p><p>接下来是连接 <code>veth</code> 对两端的桥接器。</p><h2><span id="pod-网络命名空间连接到以太网桥">Pod 网络命名空间连接到以太网桥</span></h2><p>网桥会汇聚位于根命名空间中的每一个虚拟接口。这个网桥允许虚拟 pair 之间的流量，也允许穿过公共根命名空间的流量。</p><p>补充一下相关原理。</p><p>以太网桥位于 <a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener">OSI 网络模型</a> 的第 2 层。</p><p>你可以将网桥视为接受来自不同命名空间和接口的连接的虚拟交换机。</p><p><a href="https://ops.tips/blog/using-network-namespaces-and-bridge-to-isolate-servers/" target="_blank" rel="noopener">以太网桥可以连接节点上的多个可用网络。</a></p><p>因此，可以使用网桥连接两个接口，即 Pod 命名空间的 <code>veth</code> 连接到同一节点上另一个 Pod 的 <code>veth</code>。</p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-11-20220919141543937-2022-09-19-lVtOgN.svg" alt></p><p>接下来，继续看网桥和 veth 对的用途。</p><h2><span id="跟踪在同一节点上-pod-到-pod-的流量">跟踪在同一节点上 Pod 到 Pod 的流量</span></h2><p>假设同一个节点上有两个 Pod，Pod-A 向 Pod-B 发送消息。</p><ol><li>由于访问目标不在同一个命名空间，Pod-A 将数据包发送到其默认接口 eth0。 这个接口与 veth 对的一端绑定，作为隧道。这样，数据包会被转发到节点上的根命名空间。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-12-20220919141632527-2022-09-19-NRPgWl.svg" alt></p><ol start="2"><li>以太网网桥作为一个虚拟交换机，需要目标 Pod-B 的 MAC 地址才能工作。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-13-2022-09-19-M7QRru.svg" alt></p><ol start="3"><li>ARP 协议会解决这个问题。当帧到达网桥时，会向所有连接的设备发送 ARP 广播。网桥广播询问持有 Pod-B 的 IP 地址</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-14-2022-09-19-Ibitey.svg" alt></p><ol start="4"><li>此时会收到一个带有 Pod-B IP 的 MAC 地址应答，这条消息会被存储在桥接 ARP 缓存(查找表)中。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-15-2022-09-19-y5ldCP.svg" alt></p><ol start="5"><li>IP 地址和 MAC 地址的映射关系存储之后，网桥就在表中查找，并将数据包转发到正确的端点。数据包到达根命名空间内 Pod-B 的 veth 之后，很快又到达 Pod-B 命名空间内的 eth0 接口。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-16-20220919141551029-2022-09-19-DusApt.svg" alt></p><p>至此，Pod-A 和 Pod-B 之间的通信就成功了。</p><h2><span id="跟踪不同节点上的-pod-到-pod-通信">跟踪不同节点上的 Pod 到 Pod 通信</span></h2><p>对于跨节点 Pod 之间的通信，会经过额外的通信跳跃。</p><ol><li>前几个步骤保持不变，直到数据包到达根命名空间并需要发送到 Pod-B。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-17-2022-09-19-xXNQzL.svg" alt></p><ol start="2"><li>当目的 IP 不在本地网络中时，报文被转发到节点的默认网关。节点的出口网关或默认网关，通常位于节点与网络相连的物理接口 eth0 上。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-18-2022-09-19-h2DI4L.svg" alt></p><p>此时 不会发生 ARP 解析，因为源 IP 和目标 IP 不在同一个网段中。</p><p>网段的检查是使用按位运算完成的。</p><p>当目的 IP 不在当前网络段时，数据包被转发到节点的默认网关。</p><h2><span id="按位运算的工作原理">按位运算的工作原理</span></h2><p>在确定数据包的转发位置时，源节点必须执行位运算</p><p><a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND" target="_blank" rel="noopener">这也称为与操作。</a></p><p>复习一下，按位与运算的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 AND 0 &#x3D; 0</span><br><span class="line">0 AND 1 &#x3D; 0</span><br><span class="line">1 AND 0 &#x3D; 0</span><br><span class="line">1 AND 1 &#x3D; 1</span><br></pre></td></tr></table></figure><p>除了 1 与 1 以外的都是 false。</p><p>如果源节点的 IP 为 192.168.1.1，子网掩码为 /24，目标 IP 为 172.16.1.1/16，则按位与运算将得知它们位于不同的网段上。</p><p>这意味着目标 IP 与数据包的源不在同一个网络上，数据包将通过默认网关转发。</p><p>数学时间。</p><p>我们必须从二进制的 32 位地址开始进行 AND 操作。</p><p>先找出源 IP 网络和目标 IP 网段。</p><table><thead><tr><th style="text-align:left">Type</th><th style="text-align:left">Binary</th><th style="text-align:left">Converted</th></tr></thead><tbody><tr><td style="text-align:left">Src. IP Address</td><td style="text-align:left">11000000.10101000.00000001.00000001</td><td style="text-align:left">192.168.1.1</td></tr><tr><td style="text-align:left">Src. Subnet Mask</td><td style="text-align:left">11111111.11111111.11111111.00000000</td><td style="text-align:left">255.255.255.0(/24)</td></tr><tr><td style="text-align:left">Src. Network</td><td style="text-align:left">11000000.10101000.00000001.00000000</td><td style="text-align:left">192.168.1.0</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Dst. IP Address</td><td style="text-align:left">10101100.00010000.00000001.00000001</td><td style="text-align:left">172.16.1.1</td></tr><tr><td style="text-align:left">Dst. Subnet Mask</td><td style="text-align:left">11111111.11111111.00000000.00000000</td><td style="text-align:left">255.255.0.0(/16)</td></tr><tr><td style="text-align:left">Dst. Network</td><td style="text-align:left">10101100.00010000.00000000.00000000</td><td style="text-align:left">172.16.0.0</td></tr></tbody></table><p>按位运算之后，需要将目标 IP 与数据包源节点的子网进行比较。</p><table><thead><tr><th style="text-align:left">Type</th><th style="text-align:left">Binary</th><th style="text-align:left">Converted</th></tr></thead><tbody><tr><td style="text-align:left">Dst. IP Address</td><td style="text-align:left">10101100.00010000.00000001.00000001</td><td style="text-align:left">172.16.1.1</td></tr><tr><td style="text-align:left">Src. Subnet Mask</td><td style="text-align:left">11111111.11111111.11111111.00000000</td><td style="text-align:left">255.255.255.0(/24)</td></tr><tr><td style="text-align:left">Network Result</td><td style="text-align:left">10101100.00010000.00000001.00000000</td><td style="text-align:left">172.16.1.0</td></tr></tbody></table><p>运算的结果是 172.16.1.0，不等于 192.168.1.0（源节点的网络）。说明源 IP 地址和目标 IP 地址不在同一个网络上。</p><p>如果目标 IP 是 192.168.1.2，即与发送 IP 在同一子网中，则 AND 操作将得到节点的本地网络。</p><table><thead><tr><th style="text-align:left">Type</th><th style="text-align:left">Binary</th><th style="text-align:left">Converted</th></tr></thead><tbody><tr><td style="text-align:left">Dst. IP Address</td><td style="text-align:left">11000000.10101000.00000001.00000010</td><td style="text-align:left">192.168.1.2</td></tr><tr><td style="text-align:left">Src. Subnet Mask</td><td style="text-align:left">11111111.11111111.11111111.00000000</td><td style="text-align:left">255.255.255.0(/24)</td></tr><tr><td style="text-align:left">Network</td><td style="text-align:left">11000000.10101000.00000001.00000000</td><td style="text-align:left">192.168.1.0</td></tr></tbody></table><p>进行逐位比较后，ARP 通过查找表查找默认网关的 MAC 地址。</p><p>如果有条目，将立即转发数据包。</p><p>否则，先进行广播以找到网关的 MAC 地址。</p><ol><li>现在，数据包路由到另一个节点的默认接口，我们称为 Node-B。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-19-2022-09-19-O2NAMf.svg" alt></p><ol start="2"><li>以相反的顺序。现在，数据包位于 Node-B 的根命名空间，并到达网桥，这里会进行 ARP 解析。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-20-2022-09-19-sncbQT.svg" alt></p><ol start="3"><li>路由系统将返回与 Pod-B 相连的接口的 MAC 地址。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-21-2022-09-19-l9iVbm.svg" alt></p><ol start="4"><li>网桥通过 Pod-B 的 <code>veth</code> 设备转发帧，并到达 Pod-B 的命名空间。</li></ol><p><img src="https://img.hi-linux.com/staticfile/k8s-network-22-20220919141556537-2022-09-19-8ckOcx.svg" alt></p><p>至此，你应该已经熟悉了 Pod 之间的流量是如何流转的。下面，让我们花点时间来看看 CNI 如何管理上诉内容。</p><h2><span id="容器网络接口-cni">容器网络接口 - CNI</span></h2><p><a href="https://github.com/containernetworking/cni/blob/main/SPEC.md" target="_blank" rel="noopener">容器网络接口（CNI）主要关注的是当前节点中的网络。</a></p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-23-2022-09-19-PBGpbi.svg" alt></p><p>可以将 CNI 看作为解决 Kubernetes 网络需求，而遵循的一组规则。</p><p>有这些 CNI 实现可供使用：</p><ul><li><a href="https://www.tigera.io/project-calico/" target="_blank" rel="noopener">Calico</a></li><li><a href="https://cilium.io/" target="_blank" rel="noopener">Cillium</a></li><li><a href="https://github.com/flannel-io/flannel" target="_blank" rel="noopener">Flannel</a></li><li><a href="https://www.weave.works/docs/net/latest/overview/" target="_blank" rel="noopener">Weave Net</a></li><li>其他网络插件</li></ul><p>他们都遵循相同的 CNI 标准。</p><p>如果没有 CNI，你需要人工完成如下操作：</p><ul><li>创建接口。</li><li>创建 veth 对。</li><li>设置网络命名空间。</li><li>设置静态路由。</li><li>配置以太网桥。</li><li>分配 IP 地址。</li><li>创建 NAT 规则。</li><li>还有其他大量事情。</li></ul><p>这还不包括，在删除或重启 Pod 时，需要进行类似的全部操作。</p><p>CNI 必须支持<a href="https://github.com/containernetworking/cni/blob/main/SPEC.md#cni-operations" target="_blank" rel="noopener">四种不同的操作</a>：</p><ul><li>ADD - 向网络添加一个容器。</li><li>DEL - 从网络中删除一个容器。</li><li>CHECK - 如果容器的网络出现问题，则返回错误。</li><li>VERSION - 显示插件的版本。</li></ul><p>我们一起看下，CNI 是如何工作的。</p><p>当 Pod 被分配到特定节点时，Kubelet 自身不会初始化网络。</p><p>相反，Kubelet 将这个任务交给 CNI。</p><p><em>但是，Kubelet 以 JSON 格式指定配置并发送至 CNI 插件。</em></p><p>你可以进入节点上的 <code>/etc/cni/net.d</code> 文件夹，使用以下命令查看当前的 CNI 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ cat 10-calico.conflist</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;k8s-Pod-network&quot;,</span><br><span class="line">  &quot;cniVersion&quot;: &quot;0.3.1&quot;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;calico&quot;,</span><br><span class="line">      &quot;datastore_type&quot;: &quot;kubernetes&quot;,</span><br><span class="line">      &quot;mtu&quot;: 0,</span><br><span class="line">      &quot;nodename_file_optional&quot;: false,</span><br><span class="line">      &quot;log_level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;log_file_path&quot;: &quot;&#x2F;var&#x2F;log&#x2F;calico&#x2F;cni&#x2F;cni.log&quot;,</span><br><span class="line">      &quot;ipam&quot;: &#123; &quot;type&quot;: &quot;calico-ipam&quot;, &quot;assign_ipv4&quot; : &quot;true&quot;, &quot;assign_ipv6&quot; : &quot;false&quot;&#125;,</span><br><span class="line">      &quot;container_settings&quot;: &#123;</span><br><span class="line">          &quot;allow_ip_forwarding&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;policy&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;k8s&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;kubernetes&quot;: &#123;</span><br><span class="line">          &quot;k8s_api_root&quot;:&quot;https:&#x2F;&#x2F;10.96.0.1:443&quot;,</span><br><span class="line">          &quot;kubeconfig&quot;: &quot;&#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;calico-kubeconfig&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;bandwidth&quot;,</span><br><span class="line">      &quot;capabilities&quot;: &#123;&quot;bandwidth&quot;: true&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;&quot;type&quot;: &quot;portmap&quot;, &quot;snat&quot;: true, &quot;capabilities&quot;: &#123;&quot;portMappings&quot;: true&#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 CNI 插件都会使用不同类型的网络配置。</p><p>例如，Calico 使用基于 BGP 的三层网络连接 Pod</p><p>Cilium 从三层到七层使用的是基于 eBPF 的 overlay 网络</p><p>与 Calico 一样，Cilium 也支持通过配置网络策略来限制流量。</p><p>那么你应该使用哪一个呢？主要有两类 CNI。</p><p>在第一类中，使用基本网络设置（也称为平面网络），从集群的 IP 池为 Pod 分配 IP 地址的 CNI。</p><p>这种方式可能很快耗尽 IP 地址，而成为负担。</p><p>相反，另一类是使用 overlay 网络。</p><p>简单来说，overlay 网络是主（底层）网络之上的重建网络。</p><p>overlay 网络通过封装来自底层网络的数据包工作，这些数据包被发送到另一个节点上的 Pod。</p><p>overlay 网络的一种流行技术是 VXLAN，它可以在 L3 网络上建立 L2 域的隧道。</p><p>那么哪个更好呢？</p><p>没有单一的答案，这取决于你的需求。</p><p>你是否正在构建具有数万个节点的大型集群？</p><p>也许 overlay 网络更好。</p><p>你是否在意更简单的配置和审查网络流量，而不会愿意在复杂网络中丢失这种能力？</p><p>扁平网络更适合你。</p><p>现在我们讨论完了 CNI，接着让我们来看看 Pod 到服务的通信是如何连接的。</p><h2><span id="检查-pod-到-service-的流量">检查 Pod 到 Service 的流量</span></h2><p>由于 Pod 在 Kubernetes 中是动态的，分配给 Pod 的 IP 地址不是静态的。</p><p>Pod 的 IP 是短暂的，每次创建或删除 Pod 时都会发生变化。</p><p>Kubernetes 中的 Service 解决了这个问题，为连接一组 Pod 提供了可靠的机制。</p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-24-2022-09-19-8P1MI3.svg" alt></p><p>默认情况下，在 Kubernetes 中创建 Service 时，<a href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies" target="_blank" rel="noopener">被分配一个虚拟 IP</a>。</p><p>在 Service 中，可以使用选择器将 Service 与目标 Pod 相关联。</p><p>当删除或添加一个 Pod 时会发生什么呢？</p><blockquote><p>Service 的虚拟 IP 保持静态不变。</p></blockquote><p>但流量可以再无需干预的情况下，到达新创建的 Pod。</p><p>换句话说，Kubernetes 中的 Service 类似于负载均衡器。</p><p>但它们是如何工作的？</p><h2><span id="使用-netfilter-和-iptables-拦截和重写流量">使用 Netfilter 和 Iptables 拦截和重写流量</span></h2><p>Kubernetes 中的 Service 是基于 Linux 内核中的两个组件构建的：</p><ol><li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">网络过滤器</a></li><li><a href="https://en.wikipedia.org/wiki/Iptables" target="_blank" rel="noopener">iptables</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Netfilter 是一个可以配置数据包过滤、创建 NAT 、端口转发规则以及管理网络中流量的框架</span><br></pre></td></tr></table></figure><p>此外，它可以屏蔽和禁止未经同意的访问。</p><p>另一方面，iptables 是一个用户态程序，可以用来配置 Linux 内核防火墙的 IP 数据包过滤规则。</p><p>iptables 是作为不同的 Netfilter 模块实现的。</p><p>可以使用 iptables CLI 即时修改过滤规则，并将它们插入 netfilters 挂载点。</p><p>过滤器配置在不同的表中，其中包含用于处理网络流量数据包的链。</p><p>不同的协议使用不同的内核模块和程序。</p><blockquote><p>当提到 iptables 时，通常指的是 IPv4。对于 IPv6 ，终端工具是 ip6tables。</p></blockquote><p>iptables 有五种链，每一种链都直接映射到 Netfilter 的钩子上。</p><p>从 iptables 的角度来看，它们是：</p><ul><li><code>PRE_ROUTING</code></li><li><code>INPUT</code></li><li><code>FORWARD</code></li><li><code>OUTPUT</code></li><li><code>POST_ROUTING</code></li></ul><p>它们对应地映射到 Netfilter 钩子：</p><ul><li><code>NF_IP_PRE_ROUTING</code></li><li><code>NF_IP_LOCAL_IN</code></li><li><code>NF_IP_FORWARD</code></li><li><code>NF_IP_LOCAL_OUT</code></li><li><code>NF_IP_POST_ROUTING</code></li></ul><p>当一个数据包到达时，根据它所处的阶段，将 “触发” 一个 Netfilter 钩子。这个钩子会执行特定的 iptables 过滤规则。</p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-25-20220919141602921-2022-09-19-tsberQ.svg" alt></p><p>哎呀！看起来很复杂！</p><p>不过没什么好担心的。</p><p>这就是我们使用 Kubernetes 的原因，以上所有内容都是通过使用 Service 抽象出来的，并且一个简单的 YAML 定义可以自动设置这些规则。</p><p>如果你有兴趣查看 iptables 规则，可以连接到节点并运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables-save</span><br></pre></td></tr></table></figure><p>你还可以使用<a href="https://github.com/Nudin/iptable_vis" target="_blank" rel="noopener">这个工具来可视化</a>节点上的 iptables 链。</p><p>这是来自 GKE 节点上的可视化 iptables 链的示例图：</p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-26-2022-09-19-GirLZG.svg" alt></p><p>注意，这里可能配置了几百条规则，想想一下自己动手怎么配置！</p><p>至此，我们已经了解了，相同节点上的 Pod 和不同节点上 Pod 之间是如何通信的。</p><p>在 Pod 与 Service 的通信中，链路的前半部分是一样的。</p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-27-2022-09-19-zcNnij.svg" alt></p><p>当请求从 Pod-A 走向 Pod-B 时，由于 Pod-B 在 Service 的 “后面”，在传输的过程中，会有一些不一样。</p><p>原始的请求，在 Pod-A 命名空间的 eth0 接口发出。</p><p>接着，请求通过 <code>veth</code>到达根名称空间的网桥。</p><p>一旦到达网桥，数据包就会立即通过默认网关转发。</p><p>与 Pod-to-Pod 部分一样，主机进行按位比较。由于服务的虚拟 IP 不是节点 CIDR 的一部分，因此数据包将立即通过默认网关转发。</p><p>如果默认网关的 MAC 地址尚未出现在查找表中，则会进行 ARP 解析找出默认网关的 MAC 地址。</p><p>现在神奇的事情发生了。</p><p>在数据包通过节点的路由之前，Netfilter 的 <code>NF_IP_PRE_ROUTING</code> 挂钩被触发，并执行 iptables 规则。这个规则会修改 Pod-A 数据包的目标 IP 地址 DNAT。</p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-28-2022-09-19-xAplcC.svg" alt></p><p>前面服务的虚拟 IP 地址被重写为 Pod-B 的 IP 地址。</p><p>接下来，数据包路由过程与 Pod 到 Pod 的通信一样。</p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-29-2022-09-19-7aqxsB.svg" alt></p><p>数据包重写后，通信是 Pod 到 Pod。</p><p>然而，在所有这些通信中，使用了一个第三方的功能。</p><p><a href="https://www.linuxtopia.org/Linux_Firewall_iptables/x1298.html" target="_blank" rel="noopener">此功能称为 conntrack</a> 或链路跟踪。</p><p>当 Pod-B 发回响应时，conntrack 会将数据包与链路相关联，并跟踪其来源。</p><p>NAT 严重依赖于 conntrack。</p><p>如果没有链路跟踪，将不知道将包含响应的数据包发回何处。</p><p>使用 conntrack 时，数据包的返回路径很容易设置为相同的源或目标 NAT 更改。</p><p>通信的另一部分与现在的链路相反。</p><p>Pod-B 接收并处理了请求，现在将数据发送回 Pod-A。</p><p>现在会发生什么呢？</p><h2><span id="检查来自服务的响应">检查来自服务的响应</span></h2><p>Pod-B 发送响应，将其 IP 地址设置为源地址，并将 Pod-A 的 IP 地址设置为目标地址。</p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-30-20220919141614676-2022-09-19-4nUE8X.svg" alt></p><p>当数据包到达 Pod-A 所在节点的接口时，会发生另一个 NAT。</p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-31-2022-09-19-PS5DQz.svg" alt></p><p>这时，conntrack 开始工作，修改源 IP 地址，iptables 规则执行 SNAT，并将 Pod-B 的源 IP 地址修改为原始服务的虚拟 IP。</p><p><img src="https://img.hi-linux.com/staticfile/k8s-network-32-2022-09-19-bQ6FAb.svg" alt></p><p>对于 Pod-A 来说，响应是来自于 Service 而不是 Pod-B。</p><p>其余的都是一样的。一旦 SNAT 完成，数据包就会到达根命名空间中的网桥，并通过 <code>veth</code> 对转发到 <code>Pod-A</code>。</p><h2><span id="总结一下">总结一下</span></h2><p>让我们一起回顾下本文相关要点</p><ul><li>容器如何在本地或 Pod 内通信。</li><li>在相同节点和不同节点上的 Pod 如何通信。</li><li>Pod-to-Service - Pod 如何将流量发送到 Kubernetes 中服务后面的 Pod 时。</li><li>什么是命名空间、veth、iptables、chains、conntrack、Netfilter、CNI、overlay 网络，以及 Kubernetes 网络工具箱中所需的一切。</li></ul><blockquote><p>本文转载自：「 陈少文的博客 」，原文：<a href="https://url.hi-linux.com/GQueR" target="_blank" rel="noopener">https://url.hi-linux.com/GQueR</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://learnk8s.io/kubernetes-network-packets%EF%BC%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E9%80%90%E5%AD%97%E7%BF%BB%E8%AF%91%EF%BC%8C%E5%B8%A6%E5%85%A5%E4%BA%86%E4%BA%9B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://learnk8s.io/kubernetes-network-packets，并没有逐字翻译，带入了些自己的理解。&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/k8s-network-1-2022-09-19-c7m4AB.svg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;阅读本文，你可以了解在 Kubernetes 内外，数据包是如何转发的，从原始的 Web 请求开始，到托管应用程序的容器。&lt;/p&gt;
&lt;h2 id=&quot;Kubernetes-网络要求&quot;&gt;Kubernetes 网络要求&lt;/h2&gt;
&lt;p&gt;在深入了解在 Kubernetes 集群中数据包如何流转的细节之前，先明确一下 Kubernetes 对网络的要求。&lt;/p&gt;
&lt;p&gt;Kubernetes 网络模型定义了一组基本规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在不使用网络地址转换 (NAT) 的情况下，集群中的 Pod 能够与任意其他 Pod 进行通信。&lt;/li&gt;
&lt;li&gt;在不使用网络地址转换 (NAT) 的情况下，在集群节点上运行的程序能与同一节点上的任何 Pod 进行通信。&lt;/li&gt;
&lt;li&gt;每个 Pod 都有自己的 IP 地址（IP-per-Pod），并且任意其他 Pod 都可以通过相同的这个地址访问它。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些要求，不会将具体实现限制在某种解决方案上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 cri-docker 解决 Kubernetes 1.24 不支持 Docker 的问题</title>
    <link href="https://www.hi-linux.com/posts/20680.html"/>
    <id>https://www.hi-linux.com/posts/20680.html</id>
    <published>2022-09-13T01:00:00.000Z</published>
    <updated>2022-09-13T05:38:43.480Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>从 Kubernetes 1.24 开始，dockershim 已经从 kubelet 中移除，但因为历史问题 Docker 却不支持 Kubernetes 主推的 CRI（容器运行时接口）标准，所以 Docker 不能再作为 Kubernetes 的容器运行时了，即从Kubernetes v1.24 开始不再使用 Docker了。</p><p>但是如果想继续使用 Docker 的话，可以在 Kubelet 和 Docker 之间加上一个中间层 cri-docker。cri-docker 是一个支持 CRI 标准的 shim（垫片）。一头通过 CRI 跟 Kubelet 交互，另一头跟 Docker Api 交互，从而间接的实现了 Kubernetes 以 Docker 作为容器运行时。但是这种架构缺点也很明显，调用链更长，效率更低。</p><a id="more"></a><p>虽然本文演示了 cri-docker 的使用，但是更推荐使用 Containerd 作为 Kubernetes 的容器运行时。</p><h2><span id="实验环境">实验环境</span></h2><ul><li>两台机器，vms41 和 vms42</li><li>系统：centos7.4</li><li>vms41 为 master，vms42 是worker</li></ul><h3><span id="1-所有节点的基本设置">1. 所有节点的基本设置</span></h3><p>1.1 所有节点设置好 /etc/hosts ,使它们之间能互相解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@vms4X ~]# cat &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.26.41 vms41.rhce.cc vms41</span><br><span class="line">192.168.26.42 vms42.rhce.cc vms42</span><br><span class="line">[root@vms4X ~]#</span><br></pre></td></tr></table></figure><p>1.2 在所有节点上关闭swap分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vms4X ~]# swapoff -a ; sed -i &#39;&#x2F;fstab&#x2F;d&#39; &#x2F;etc&#x2F;fstab </span><br><span class="line">[root@vms4X ~]#</span><br></pre></td></tr></table></figure><p>1.3.在所有节点上更新yum源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vms4X ~]#  rm -rf &#x2F;etc&#x2F;yum.repos.d&#x2F;*  ; wget ftp:&#x2F;&#x2F;ftp.rhce.cc&#x2F;k8s&#x2F;* -P &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">[root@vms4X ~]# yum clean all</span><br><span class="line">[root@vms4X ~]#</span><br></pre></td></tr></table></figure><p>1.4 在所有节点安装 Docker</p><ul><li>所有节点安装 docker-ce。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@vms4X ~]#  yum install docker-ce -y</span><br></pre></td></tr></table></figure><ul><li>在所有节点启动 Docker 并设置开机自动启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@vms4X ~]# systemctl enable docker --now</span><br></pre></td></tr></table></figure><ul><li>所有节点设置 Docker加速器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">   &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;frz7i079.mirror.aliyuncs.com&quot;],</span><br><span class="line">    &quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>所有节点重启 Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@vms4X ~]#  systemctl restart docker</span><br></pre></td></tr></table></figure><p>1.5 在所有节点安装 cri-docker</p><p>到下面的链接下载最新版 cri-docker</p><blockquote><p><a href="https://github.com/Mirantis/cri-dockerd/tags" target="_blank" rel="noopener">https://github.com/Mirantis/cri-dockerd/tags</a></p></blockquote><p>先在 vms41 上解压出 cri-docker，然后拷贝到 vms42 上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]# tar zxf cri-dockerd-0.2.1.amd64.tgz </span><br><span class="line">[root@vms41 ~]# cp cri-dockerd&#x2F;cri-dockerd &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">[root@vms41 ~]# scp &#x2F;usr&#x2F;bin&#x2F;cri-dockerd vms42:&#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">root@vms42&#39;s password: </span><br><span class="line">cri-dockerd         100%   50MB 117.2MB&#x2F;s   00:00    </span><br><span class="line">[root@vms41 ~]#</span><br></pre></td></tr></table></figure><p>1.6 设置系统参数</p><p>在所有机器上执行下面的命令，目的是实现重启系统后，参数也能继续生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>让上述参数立即生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vms4X ~]# sysctl -p &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</span><br><span class="line">[root@vms4X ~]#</span><br></pre></td></tr></table></figure><p>1.7 创建 cri-docker 启动文件</p><ul><li>启动文件从下面链接找到:</li></ul><blockquote><p><a href="https://github.com/Mirantis/cri-dockerd/tree/master/packaging/systemd" target="_blank" rel="noopener">https://github.com/Mirantis/cri-dockerd/tree/master/packaging/systemd</a></p></blockquote><p>创建 cri-docker 启动文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]# cat &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;cri-docker.service</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;CRI Interface for Docker Application Container Engine</span><br><span class="line">Documentation&#x3D;https:&#x2F;&#x2F;docs.mirantis.com</span><br><span class="line">After&#x3D;network-online.target firewalld.service docker.service</span><br><span class="line">Wants&#x3D;network-online.target</span><br><span class="line">Requires&#x3D;cri-docker.socket</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;notify</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;cri-dockerd --network-plugin&#x3D;cni --pod-infra-container-image&#x3D;registry.aliyuncs.com&#x2F;google_containers&#x2F;pause:3.7</span><br><span class="line">ExecReload&#x3D;&#x2F;bin&#x2F;kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec&#x3D;0</span><br><span class="line">RestartSec&#x3D;2</span><br><span class="line">Restart&#x3D;always</span><br><span class="line"></span><br><span class="line">StartLimitBurst&#x3D;3</span><br><span class="line"></span><br><span class="line">StartLimitInterval&#x3D;60s</span><br><span class="line"></span><br><span class="line">LimitNOFILE&#x3D;infinity</span><br><span class="line">LimitNPROC&#x3D;infinity</span><br><span class="line">LimitCORE&#x3D;infinity</span><br><span class="line"></span><br><span class="line">TasksMax&#x3D;infinity</span><br><span class="line">Delegate&#x3D;yes</span><br><span class="line">KillMode&#x3D;process</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line">[root@vms41 ~]#</span><br></pre></td></tr></table></figure><p>这里 <code>/usr/bin/cri-dockerd</code> 一定要加上参数 <code>-–pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.7</code>，用来指定所用的 pause 镜像是哪个，否则默认拉取 <a href="http://k8s.gcr.io/pause:3.6%EF%BC%8C%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E3%80%82" target="_blank" rel="noopener">k8s.gcr.io/pause:3.6，会导致安装失败。</a></p><ul><li>创建启动文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]# cat &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;cri-docker.socket</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;CRI Docker Socket for the API</span><br><span class="line">PartOf&#x3D;cri-docker.service</span><br><span class="line"></span><br><span class="line">[Socket]</span><br><span class="line">ListenStream&#x3D;%t&#x2F;cri-dockerd.sock</span><br><span class="line">SocketMode&#x3D;0660</span><br><span class="line">SocketUser&#x3D;root</span><br><span class="line">SocketGroup&#x3D;docker</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;sockets.target</span><br><span class="line">[root@vms41 ~]#</span><br></pre></td></tr></table></figure><p>1.8 把启动脚本拷贝到 vms42 上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]# scp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;cri-docker.socket &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;cri-docker.service vms42:&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;</span><br><span class="line">root@vms42&#39;s password: </span><br><span class="line">cri-docker.socket          100%  204   103.1KB&#x2F;s   00:00    </span><br><span class="line">cri-docker.service         100%  605   822.7KB&#x2F;s   00:00    </span><br><span class="line">[root@vms41 ~]#</span><br></pre></td></tr></table></figure><p>启动 cri-docker 并设置开机自动启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]# systemctl daemon-reload ; systemctl enable cri-docker --now</span><br><span class="line">Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;cri-docker.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;cri-docker.service.</span><br><span class="line">[root@vms41 ~]#</span><br><span class="line"></span><br><span class="line">[root@vms4X ~]# systemctl is-active cri-docker</span><br><span class="line">active</span><br><span class="line">[root@vms4X ~]#</span><br></pre></td></tr></table></figure><h2><span id="2-安装-kubernetes">2. 安装 Kubernetes</span></h2><p>2.1 查看当前源里有哪些版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]#yum list --showduplicates kubeadm --disableexcludes&#x3D;kubernetes</span><br></pre></td></tr></table></figure><p>在本试验时最新的版本是 v1.24.1，所以本次就安装 v1.24.1版本的。</p><p>2.2 所有节点上安装软件包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vms4X ~]#yum install -y kubelet-1.24.1-0 kubeadm-1.24.1-0 kubectl-1.24.1-0  --disableexcludes&#x3D;kubernetes</span><br><span class="line">[root@vms4X ~]#</span><br></pre></td></tr></table></figure><p>2.3 所有节点上启动 Kubelet 并设置开机自动启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vms4X ~]# systemctl enable kubelet --now</span><br><span class="line">Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;kubelet.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kubelet.service.</span><br><span class="line">[root@vms4X ~]#</span><br></pre></td></tr></table></figure><p>此时 Kubelet 状态是 activating 的，不是 active 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]# systemctl is-active kubelet</span><br><span class="line">activating</span><br><span class="line">[root@vms41 ~]#</span><br></pre></td></tr></table></figure><h2><span id="3初始化-kubernetes">3.初始化 Kubernetes</span></h2><p>3.1 在 master（vms41）上初始化集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]# kubeadm init --image-repository registry.aliyuncs.com&#x2F;google_containers --kubernetes-version&#x3D;v1.24.1 --pod-network-cidr&#x3D;10.244.0.0&#x2F;16 --cri-socket &#x2F;var&#x2F;run&#x2F;cri-dockerd.sock</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里需要添加选项 -–cri-socket /var/run/cri-dockerd.sock</p></blockquote><p><img src="https://img.hi-linux.com/staticfile/4969830fe751d18275b23b2d92929617-2022-09-06-TlqU5p.png" alt></p><p>按提示创建 kubeconfig 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]# mkdir -p $HOME&#x2F;.kube</span><br><span class="line">[root@vms41 ~]# sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">[root@vms41 ~]# sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">[root@vms41 ~]#</span><br></pre></td></tr></table></figure><p>3.2 把 worker 加入集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vms42 ~]# kubeadm join 192.168.26.41:6443 --token l05cgf.kj5dvy5heki3jixt --discovery-token-ca-cert-hash sha256:07c1765ff4ac6eb2e54ed69fa57ca1afc728e825a6d4a11a83c96ff60ea545cd  --cri-socket &#x2F;var&#x2F;run&#x2F;cri-dockerd.sock</span><br><span class="line">[root@vms42 ~]#</span><br></pre></td></tr></table></figure><p>注意，这里也要加上选项 <code>-–cri-socket /var/run/cri-dockerd.sock</code></p><p>切换到 master，查看节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]# kubectl get nodes</span><br><span class="line">NAME            STATUS     ROLES           AGE     VERSION</span><br><span class="line">vms41.rhce.cc   NotReady   control-plane   4m12s   v1.24.1</span><br><span class="line">vms42.rhce.cc   NotReady   &lt;none&gt;          13s     v1.24.1</span><br><span class="line">[root@vms41 ~]#</span><br></pre></td></tr></table></figure><h2><span id="4安装-calico">4.安装 Calico</span></h2><p>4.1 下载最新版的 Calico 部署文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@vms71 ~]# wget https:&#x2F;&#x2F;docs.projectcalico.org&#x2F;manifests&#x2F;calico.yaml</span><br></pre></td></tr></table></figure><p>4.2 修改相应配置</p><p>修改 calico.yaml 找到 CALICO_IPV4POOL_CIDR 按下面修改。</p><p><img src="https://img.hi-linux.com/staticfile/839e789e218a3b6255911275b52ecc15-2022-09-06-j8alQ3.png" alt></p><p>改成</p><p><img src="https://img.hi-linux.com/staticfile/5b4040098c6ae58fa203d0fcc13ac56e-2022-09-06-il9eb3.png" alt></p><p>4.3 安装 Calico</p><p>在 vms41（master）上安装 calico，不需要在 vms42 上做什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]# kubectl apply -f calico.yaml</span><br><span class="line">[root@vms41 ~]#</span><br></pre></td></tr></table></figure><h2><span id="5验证">5.验证</span></h2><p>5.1 在 vms41 上再次查看节点状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@vms41 ~]# kubectl get nodes</span><br><span class="line">NAME            STATUS   ROLES           AGE     VERSION</span><br><span class="line">vms41.rhce.cc   Ready    control-plane   11m     v1.24.1</span><br><span class="line">vms42.rhce.cc   Ready    &lt;none&gt;          7m20s   v1.24.1</span><br><span class="line">[root@vms41 ~]# </span><br><span class="line">[root@vms41 ~]# kubectl get nodes -o wide</span><br><span class="line">NAME            STATUS   ROLES           AGE     VERSION   INTERNAL-IP     EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION          CONTAINER-RUNTIME</span><br><span class="line">vms41.rhce.cc   Ready    control-plane   11m     v1.24.1   192.168.26.41   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-693.el7.x86_64   docker:&#x2F;&#x2F;20.10.17</span><br><span class="line">vms42.rhce.cc   Ready    &lt;none&gt;          7m23s   v1.24.1   192.168.26.42   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-693.el7.x86_64   docker:&#x2F;&#x2F;20.10.17</span><br><span class="line">[root@vms41 ~]#</span><br></pre></td></tr></table></figure><blockquote><p>本文转载自：「 老段工作室 」，原文：<a href="https://url.hi-linux.com/moiru%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.hi-linux.com/moiru，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 Kubernetes 1.24 开始，dockershim 已经从 kubelet 中移除，但因为历史问题 Docker 却不支持 Kubernetes 主推的 CRI（容器运行时接口）标准，所以 Docker 不能再作为 Kubernetes 的容器运行时了，即从Kubernetes v1.24 开始不再使用 Docker了。&lt;/p&gt;
&lt;p&gt;但是如果想继续使用 Docker 的话，可以在 Kubelet 和 Docker 之间加上一个中间层 cri-docker。cri-docker 是一个支持 CRI 标准的 shim（垫片）。一头通过 CRI 跟 Kubelet 交互，另一头跟 Docker Api 交互，从而间接的实现了 Kubernetes 以 Docker 作为容器运行时。但是这种架构缺点也很明显，调用链更长，效率更低。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
</feed>
