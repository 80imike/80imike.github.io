<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>运维之美</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2020-05-11T04:51:39.268Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>再见 XShell 和 ITerm 2，是时候拥抱全平台高颜值终端工具 Hyper 了</title>
    <link href="https://www.hi-linux.com/posts/44812.html"/>
    <id>https://www.hi-linux.com/posts/44812.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-11T04:51:39.268Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>不论是 <code>macOS</code> 还是 <code>Windows</code> 下，我们都不推荐使用系统自带终端。无论是可拓展性还是可编程性都被「系统自带」这样的特点限制。特别是 <code>Windows</code> 下的万恶之源「小黑框」，在 9012 年真的是不太好用哟！</p><p>今天我们将给大家介绍一款基于 <code>Electron</code> 的全平台高颜值的终端工具 <code>Hyper</code>。<code>Hyper</code> 支持丰富的主题和插件功能，通过强大的插件系统提供了非常丰富的自定义选项，可谓是颜值和易用并存的神器。</p><blockquote><p>官网地址：<a href="https://hyper.is" target="_blank" rel="noopener">https://hyper.is</a></p></blockquote><p>下面先放一张配置好的预览效果图，让大家先睹为快。</p><p><img src="https://img.fythonfang.com/MacScreenShot%202018-07-20-5-35-35.png" alt=""></p><p>由于 <code>Hyper</code> 是基于 <code>Electron</code> 的，所以它的插件、主题等等可拓展性都非常强大。几行简单的 <code>Javascript</code>、<code>HTML</code>、 <code>CSS</code> 代码，你就可以定制自己的插件。</p><blockquote><p><code>Electron</code> 是一个利用最新 <code>Web</code> 技术栈搭建跨平台应用的项目，比如: <code>GitHub</code> 出品的代码编辑器 <code>Atom</code> 和微软出品的 <code>VSCode</code> 都是基于 <code>Electron</code> 的。</p></blockquote><h2 id="安装-hyper">安装 Hyper</h2><p><code>Hyper</code> 的安装非常简单，只需要在官网下载对应平台二进制安装包后，直接安装就可以运行。</p><p><img src="https://cdn.sspai.com/editor/u_735639/media/15651037049805/15651047302326.jpg" alt=""></p><p>如果你是 <code>macOS</code> 平台，你还可以通过 <code>Homebrew</code> 命令来快速完成安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install hyper</span><br></pre></td></tr></table></figure><p>如果你还不知道 <code>Homebrew</code> 如何安装和使用可以参考 ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247484646&amp;idx=1&amp;sn=f73feedee278c03c6c2d138154f822fb&amp;chksm=eac525cfddb2acd964c163f6020cc1c385abc8f0680cc6086881a8093b73511db31c34e3e3fc&amp;token=985021721&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「macOS 不可或缺的套件管理器——Homebrew」</a> 和  ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247484672&amp;idx=1&amp;sn=55dc5a5b3283fe618124684d9b683a17&amp;chksm=eac52429ddb2ad3fba77229c3ffbe4c3e3cf7b6477fbc08a43232e0c67bdc367be3a293f04d5&amp;token=985021721&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「macOS小技巧 —— 如何用 Homebrew 安装指定版本软件」</a> 两篇文章先了解下。</p><a id="more"></a><h2 id="hyper-主题安装">Hyper 主题安装</h2><p><code>Hyper</code> 做为一个高颜值终端工具，自然就少不了对主题的支持。官方首页推荐了 4 种不同颜色的主题，你可以在官方主题地址 <code>https://hyper.is/themes</code> 直接查看并安装。</p><p><img src="https://www.veinin.com/images/hyper/themes.png" alt=""></p><p>当然，如果上面官方推荐的主题满足不了你，你也可以去在上面的主题地址中的 <code>NEWEST</code> 页签找到更多主题，或者是去 <code>GitHub</code> 搜索更多好看的主题。</p><h2 id="善用-hyper-插件">善用 Hyper 插件</h2><p><code>Hyper</code> 本身是支持插件系统的，在安装扩展插件前，你需要先安装 <code>Hyper</code> 命令行程序。你可以点击菜单，选择 <code>Plugin</code> 选项，然后点击 <code>Install Hyper CLI command in PATH</code>。</p><p><code>Hyper</code> 命令行程序安装完成后，<code>Hyper</code> 插件安装就十分简单了，只需要打开 <code>Hyper</code> 之后一行代码就可以搞定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i verminal</span><br></pre></td></tr></table></figure><p>这样就安装了 <code>verminal</code> 这个插件。</p><p><code>Hyper</code> 官方也在首页给大家推荐了 4 个比较易用的插件，推荐大家全部都安装试试。</p><h3 id="1-hypercwd">1. hypercwd</h3><p><img src="https://raw.githubusercontent.com/hharnisc/hypercwd/master/newTabs.gif" alt=""></p><p>它可以让你的终端在新建标签页时，保持上一个终端的目录地址。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hypercwd</span><br></pre></td></tr></table></figure><h3 id="2-hyper-search">2. hyper-search</h3><p><img src="https://media.giphy.com/media/xUA7aXl1VWN460yCju/giphy.gif" alt=""></p><p>它可以让你搜索整个终端的所有文本内容。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hyper-search</span><br></pre></td></tr></table></figure><h3 id="3-hyper-pane">3. hyper-pane</h3><p><img src="https://hyper-plugin-screenshots.now.sh/hyper-pane.gif" alt=""></p><p>该插件用来增强窗口导航，对于支持多个页签的软件来说这是个利器。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hyper-pane</span><br></pre></td></tr></table></figure><h3 id="4-hyperpower">4. hyperpower</h3><p><img src="https://cloud.githubusercontent.com/assets/13041/16820268/13c9bfe6-4905-11e6-8fe4-baf8fc8d9293.gif" alt=""></p><p>这是一个让你的终端变得更加绚丽的插件，类似于 <code>Atom</code> 里面的一个叫做 <code>activate-power-mode</code> 的插件。当然这么炫酷的效果是不是会影响你的工作呢，还是要视个人情而定。其安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hyper i hyperpower</span><br></pre></td></tr></table></figure><p>如果你需要更多的插件和主题，你可以在官方网站以下地址中找到。</p><blockquote><ol><li><p><code>Hyper</code> 的官方主题地址：<a href="https://hyper.is/themes" target="_blank" rel="noopener">https://hyper.is/themes</a></p></li><li><p><code>Hyper</code> 的官方插件地址：<a href="https://hyper.is/plugins" target="_blank" rel="noopener">https://hyper.is/plugins</a></p></li></ol></blockquote><p>除了，官方提供的主题和插件。目前还有一个社区驱动的 <code>awesome-hyper</code> 项目，里面有着更多开源的 <code>Hyper</code> 终端插件、主题等等。如果你对不同的主题和插件有兴趣，可以去这个项目里进行探索哟！</p><blockquote><ol><li>项目地址：<a href="https://github.com/bnb/awesome-hyper" target="_blank" rel="noopener">https://github.com/bnb/awesome-hyper</a></li></ol></blockquote><h2 id="整合-zsh">整合 ZSH</h2><p>通常 <code>Linux</code> 服务器上面默认使用的 <code>SHELL</code> 是 <code>Bash</code>。其实除了 <code>Bash</code> 之外，还有很多其他的 <code>SHELL</code> 程序，比如：<code>ZSH</code>、<code>CSH</code>、<code>Fish</code> 等等。</p><p>这里我们将介绍的 <code>ZSH</code> 是我认为在类 <code>Unix</code> 系统下最优雅的 <code>Shell</code> 程序 。虽然 <code>ZSH</code> 设置复杂，但得益于开源社区，我们可以使用  <code>Oh-My-ZSH</code> 这个神器来很方便的管理和配置 <code>ZSH</code>。</p><h3 id="安装-zsh-和-oh-my-zsh">安装 ZSH 和 Oh-My-ZSH</h3><p>在使用 <code>Oh-My-ZSH</code> 之前，你需要先安装 <code>ZSH</code>。各个平台安装的方式可能不一样，这里就只简单说下比较常用的 <code>Centos</code> 和 <code>Ubuntu</code> 系统下的安装方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redhat / Centos</span></span><br><span class="line">$ yum install zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debian / Ubuntu</span></span><br><span class="line">$ apt-get install zsh</span><br></pre></td></tr></table></figure><p>更多平台的安装方法，你可以通过 ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483784&amp;idx=1&amp;sn=60aa4c40e12b0d64bf373d5606f8e2e9&amp;chksm=eac520a1ddb2a9b70ce515e9ee6f290842ef2276d0b52f620f05280b8e30f7f3c7591802ca5f&amp;token=1853415346&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「利用 Oh-My-Zsh 打造你的超级终端」</a> 这篇文章了解。</p><p>安装好 <code>ZSH</code>  后，就可以安装 <code>Oh-My-ZSH</code> 了。<code>Oh-My-ZSH</code> 的安装也是非常简单的，你只需要用下面两条指令中的任意一条就可完成安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 curl 安装</span></span><br><span class="line">$ sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 wget 安装</span></span><br><span class="line">$ sh -c <span class="string">"<span class="variable">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure><p>安装完成后，你就会发现你的终端 <code>SHELL</code> 变成了 <code>ZSH</code>。你还可以通过命令 <code>chsh -s /bin/zsh</code> 将 <code>ZSH</code> 设置为默认的 <code>Shell</code>。</p><h3 id="配置主题">配置主题</h3><p><code>Oh-My-ZSH</code> 默认也附带了大量好看的主题，你可以利用它们对终端界面做进一步增强和美化。<code>Oh-My-ZSH</code> 默认的主题存放在 <code>~/.oh-my-zsh/themes</code> 目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ls ~/.oh-my-zsh/themes</span><br><span class="line"></span><br><span class="line">3den.zsh-theme                essembeh.zsh-theme            junkfood.zsh-theme            rgm.zsh-theme</span><br><span class="line">Soliah.zsh-theme              evan.zsh-theme                kafeitu.zsh-theme             risto.zsh-theme</span><br><span class="line">adben.zsh-theme               example.zsh-theme             kardan.zsh-theme              rixius.zsh-theme</span><br><span class="line">af-magic.zsh-theme            fino-time.zsh-theme           kennethreitz.zsh-theme        rkj-repos.zsh-theme</span><br><span class="line">afowler.zsh-theme             fino.zsh-theme                kiwi.zsh-theme                rkj.zsh-theme</span><br><span class="line">agnoster.zsh-theme            fishy.zsh-theme               kolo.zsh-theme                robbyrussell.zsh-theme</span><br><span class="line">alanpeabody.zsh-theme         flazz.zsh-theme               kphoen.zsh-theme              sammy.zsh-theme</span><br><span class="line">amuse.zsh-theme               fletcherm.zsh-theme           lambda.zsh-theme              simonoff.zsh-theme</span><br><span class="line">apple.zsh-theme               fox.zsh-theme                 linuxonly.zsh-theme           simple.zsh-theme</span><br><span class="line">arrow.zsh-theme               frisk.zsh-theme               lukerandall.zsh-theme         skaro.zsh-theme</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>对于主题的启用，你只需编辑 <code>ZSH</code> 配置文件 <code>~/.zshrc</code>。并在 <code>ZSH_THEME</code> 项中直接修改主题名称为要启用的主题名称即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME&#x3D;&quot;agnoster&quot;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你安装的主题无法显示预期效果，那是因为响应的主题的系统字体没有安装。这时，你需要正确的安装了 <code>Powerline</code> 字体才会显示出来。</p><ol><li><p><code>Powerline</code> 项目地址：<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a></p></li><li><p><code>Powerline</code> 安装教程：<a href="https://powerline.readthedocs.io/en/latest/installation.html#fonts-installation" target="_blank" rel="noopener">https://powerline.readthedocs.io/en/latest/installation.html#fonts-installation</a></p></li></ol></blockquote><p>如果这些默认主题还不能满足你的需要，你还可以到下面这些地址中找到更多的 <code>ZSH</code> 主题。</p><blockquote><ol><li><p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a></p></li><li><p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes</a></p></li><li><p><a href="https://github.com/unixorn/awesome-zsh-plugins#themes" target="_blank" rel="noopener">https://github.com/unixorn/awesome-zsh-plugins#themes</a></p></li></ol></blockquote><h3 id="配置插件">配置插件</h3><p><code>Oh-My-ZSH</code> 之所以强大，其中一个原因就是支持诸多功能强大的插件，<code>Oh-My-ZSH</code> 默认自带的插件都存放在 <code>~/.oh-my-zsh/plugins</code> 目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ls ~/.oh-my-zsh/plugins</span><br><span class="line"></span><br><span class="line">adb               brew         coffee             dirpersist      fastfile         gitignore                 httpie     last-working-dir  nanoc                  pod         rebar       sprunge        terminitor  vault              zeus</span><br><span class="line">ant               brew-cask    colemak            django          fbterm           git-prompt                iwhois     lein              nmap                   postgres    redis-cli   ssh-agent      terraform   vim-interaction    zsh-navigation-tools</span><br><span class="line">apache2-macports  bundler      colored-man-pages  dnf             fedora           git-remote-branch         jake-node  lighthouse        node                   pow         repo        stack          textastic   vi-mode            zsh_reload</span><br><span class="line">archlinux         bwana        colorize           docker          forklift         glassfish                 jhbuild    lol               npm                    powder      rsync       sublime        textmate    virtualenv</span><br><span class="line">asdf              cabal        <span class="built_in">command</span>-not-found  docker-compose  frontend-search  gnu-utils                 jira       macports          nvm                    powify      ruby        sudo           thefuck     virtualenvwrapper</span><br><span class="line">autoenv           cake         common-aliases     emacs           gas              go                        jruby      man               nyan                   profiles    rvm         supervisor     themes      vundle</span><br><span class="line">autojump          cakephp3     compleat           ember-cli       geeknote         golang                    jsontools  marked2           osx                    pyenv       safe-paste  suse           thor        wakeonlan</span><br><span class="line">autopep8          capistrano   composer           emoji           gem              gpg-agent                 jump       mercurial         pass                   pylint      sbt         svn            tmux        wd</span><br><span class="line">aws               cask         copydir            emoji-clock     git              gradle                    kate       meteor            paver                  python      scala       svn-fast-info  tmux-cssh   web-search</span><br><span class="line">battery           catimg       copyfile           emotty          git-extras       grails                    kitchen    mix               pep8                   rails       scd         symfony        tmuxinator  wp-cli</span><br><span class="line">bbedit            celery       cp                 encode64        gitfast          grunt                     knife      mix-fast          per-directory-history  rake        screen      symfony2       torrent     xcode</span><br><span class="line">bgnotify          chruby       cpanm              extract         git-flow         gulp                      knife_ssh  mosh              perl                   rake-fast   scw         systemadmin    tugboat     yii</span><br><span class="line">boot2docker       chucknorris  debian             fabric          git-flow-avh     heroku                    laravel    mvn               phing                  rand-quote  sfffe       systemd        ubuntu      yii2</span><br><span class="line">bower             cloudapp     dircycle           fancy-ctrl-z    github           <span class="built_in">history</span>                   laravel4   mysql-macports    pip                    rbenv       singlechar  taskwarrior    urltools    yum</span><br><span class="line">branch            codeclimate  dirhistory         fasd            git-hubflow      <span class="built_in">history</span>-substring-search  laravel5   n98-magerun       pj                     rbfu        spring      terminalapp    vagrant     z</span><br></pre></td></tr></table></figure><p>默认情况下，<code>Oh-My-ZSH</code> 只启用 <code>Git</code> 插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 插件可以十分清晰的显示出当前代码仓库里与远程仓库是否同步，以及最新同步日期等等信息。</span></span><br><span class="line">plugins=(git)</span><br></pre></td></tr></table></figure><p>如果你需启用更多插件，只需加入要启用插件的名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=(git wd web-search <span class="built_in">history</span> <span class="built_in">history</span>-substring-search)</span><br></pre></td></tr></table></figure><p>除默认自带的插件外，你还可以在 <code>GitHub</code> 上找到更多好用的 <code>ZSH</code> 三方插件，这里推荐几个比较好用三方插件。</p><blockquote><ol><li>zsh-history-substring-search</li></ol><p>项目地址：<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/history-substring-search" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/history-substring-search</a></p><ol start="2"><li>zsh-syntax-highlighting</li></ol><p>项目地址：<a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-syntax-highlighting</a></p><ol start="3"><li>zsh-autosuggestions</li></ol><p>项目地址：<a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-autosuggestions</a></p></blockquote><p>如果你想更多了解 <code>ZSH</code> 和 <code>Oh-My-ZSH</code>，可以通过 ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483784&amp;idx=1&amp;sn=60aa4c40e12b0d64bf373d5606f8e2e9&amp;chksm=eac520a1ddb2a9b70ce515e9ee6f290842ef2276d0b52f620f05280b8e30f7f3c7591802ca5f&amp;token=1853415346&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「利用 Oh-My-Zsh 打造你的超级终端」</a> 和  ​<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247488164&amp;idx=1&amp;sn=4a0d6635638148684d893aa0b45b0946&amp;chksm=eac5338dddb2ba9bd8e071a5aba95697a0f7b4891087a5740cc1f0297382f9035ac9fc7895ac&amp;token=1853415346&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「让你提前体验 macOS Catalina 的 Shell — Oh My Zsh 配置指南」</a> 这两篇文章进一步探索。</p><h2 id="集成-wsl">集成 WSL</h2><p>通常在使用 <code>WSL (Windows Subsystem for Linux)</code> 工作时，我们希望启动终端时就进入 <code>WSL</code> 的 <code>SHELL</code> 内部。但默认情况下我们需要在启动终端并输入 <code>bash</code> 命令后才能进入 <code>WSL</code> 终端。</p><p>很显然有此一步操作后，我们会觉得太繁琐了。有了 <code>Hyper</code> 后，我们只需要改动一下配置文件，上面这步就可以直接省略。</p><p>现在，你只需打开 <code>Hyper</code> 设置页面文件，从菜单 <code>Edit -&gt; Preferences</code> 进入，然后编辑 <code>shell</code> 和 <code>shellArgs</code> 参数即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell: <span class="string">'C:\\Windows\\System32\\bash.exe'</span>,</span><br><span class="line">shellArgs: [],</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aHlvbmctY24tZmlsZS5vc3MtY24tc2hhbmdoYWkuYWxpeXVuY3MuY29tLzIwMTgxMi8yMDE4LTEyLTE1XzE3LTI0LTQzLnBuZw" alt=""></p><p>修改完成后，再次重新打开 <code>Hyper</code>，你会发现默认已经进入了 <code>Bash</code> 终端界面了。</p><h2 id="总结">总结</h2><p>本文讲述了如何安装和使用 <code>Hyper</code> 这个高颜值跨平台的终端软件，其中包括配置 <code>Hyper</code> 插件和主题。并讲述了如何使用 <code>ZSH</code> 来代替 <code>Bash</code> 让你的终端更加强大易用的方法。都看到这里了，你还在等什么呢？是时候放弃你的 <code>Xshell</code> 和 <code>iTerm 2</code> 吧！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://sspai.com/post/56081" target="_blank" rel="noopener">https://sspai.com/post/56081</a></p></li><li><p><a href="https://sspai.com/post/45332" target="_blank" rel="noopener">https://sspai.com/post/45332</a></p></li><li><p><a href="https://archive.spencerwoo.com/posts/2018/06/17/terminal.html" target="_blank" rel="noopener">https://archive.spencerwoo.com/posts/2018/06/17/terminal.html</a></p></li><li><p><a href="https://www.fythonfang.com/blog/post/24" target="_blank" rel="noopener">https://www.fythonfang.com/blog/post/24</a></p></li><li><p><a href="https://github.com/sindresorhus/hyper-snazzy" target="_blank" rel="noopener">https://github.com/sindresorhus/hyper-snazzy</a></p></li><li><p><a href="https://www.veinin.com/2018/11/30/hyper-windows-tutorial/" target="_blank" rel="noopener">https://www.veinin.com/2018/11/30/hyper-windows-tutorial/</a></p></li><li><p><a href="https://blog.csdn.net/was172/article/details/85016495" target="_blank" rel="noopener">https://blog.csdn.net/was172/article/details/85016495</a></p></li><li><p><a href="https://github.com/sindresorhus/pure" target="_blank" rel="noopener">https://github.com/sindresorhus/pure</a></p></li><li><p><a href="https://www.fythonfang.com/blog/post/24" target="_blank" rel="noopener">https://www.fythonfang.com/blog/post/24</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不论是 &lt;code&gt;macOS&lt;/code&gt; 还是 &lt;code&gt;Windows&lt;/code&gt; 下，我们都不推荐使用系统自带终端。无论是可拓展性还是可编程性都被「系统自带」这样的特点限制。特别是 &lt;code&gt;Windows&lt;/code&gt; 下的万恶之源「小黑框」，在 9012 年真的是不太好用哟！&lt;/p&gt;
&lt;p&gt;今天我们将给大家介绍一款基于 &lt;code&gt;Electron&lt;/code&gt; 的全平台高颜值的终端工具 &lt;code&gt;Hyper&lt;/code&gt;。&lt;code&gt;Hyper&lt;/code&gt; 支持丰富的主题和插件功能，通过强大的插件系统提供了非常丰富的自定义选项，可谓是颜值和易用并存的神器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://hyper.is&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hyper.is&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面先放一张配置好的预览效果图，让大家先睹为快。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.fythonfang.com/MacScreenShot%202018-07-20-5-35-35.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;Hyper&lt;/code&gt; 是基于 &lt;code&gt;Electron&lt;/code&gt; 的，所以它的插件、主题等等可拓展性都非常强大。几行简单的 &lt;code&gt;Javascript&lt;/code&gt;、&lt;code&gt;HTML&lt;/code&gt;、 &lt;code&gt;CSS&lt;/code&gt; 代码，你就可以定制自己的插件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Electron&lt;/code&gt; 是一个利用最新 &lt;code&gt;Web&lt;/code&gt; 技术栈搭建跨平台应用的项目，比如: &lt;code&gt;GitHub&lt;/code&gt; 出品的代码编辑器 &lt;code&gt;Atom&lt;/code&gt; 和微软出品的 &lt;code&gt;VSCode&lt;/code&gt; 都是基于 &lt;code&gt;Electron&lt;/code&gt; 的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装-Hyper&quot;&gt;安装 Hyper&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Hyper&lt;/code&gt; 的安装非常简单，只需要在官网下载对应平台二进制安装包后，直接安装就可以运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/editor/u_735639/media/15651037049805/15651047302326.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你是 &lt;code&gt;macOS&lt;/code&gt; 平台，你还可以通过 &lt;code&gt;Homebrew&lt;/code&gt; 命令来快速完成安装。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew cask install hyper&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你还不知道 &lt;code&gt;Homebrew&lt;/code&gt; 如何安装和使用可以参考 ​&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247484646&amp;amp;idx=1&amp;amp;sn=f73feedee278c03c6c2d138154f822fb&amp;amp;chksm=eac525cfddb2acd964c163f6020cc1c385abc8f0680cc6086881a8093b73511db31c34e3e3fc&amp;amp;token=985021721&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「macOS 不可或缺的套件管理器——Homebrew」&lt;/a&gt; 和  ​&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247484672&amp;amp;idx=1&amp;amp;sn=55dc5a5b3283fe618124684d9b683a17&amp;amp;chksm=eac52429ddb2ad3fba77229c3ffbe4c3e3cf7b6477fbc08a43232e0c67bdc367be3a293f04d5&amp;amp;token=985021721&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「macOS小技巧 —— 如何用 Homebrew 安装指定版本软件」&lt;/a&gt; 两篇文章先了解下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款超实用的命令行备忘神器 Navi</title>
    <link href="https://www.hi-linux.com/posts/29102.html"/>
    <id>https://www.hi-linux.com/posts/29102.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-11T04:51:39.270Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，无论对于运维,还是开发来说，命令行工具都是非常高效的一种管理方式。但有一个很常见的现象就是，很多命令行语句比较复杂，用过一段时间后就忘记了。当然，这时我们可以通过网络搜索或者使用命令的 <code>-—help</code> 选项来快速找到答案。虽然这种常用的方法能解决问题，但是使用起来相对还是显得不那么快速高效。</p><p>之前，我们在「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487743&amp;idx=1&amp;sn=e726fa2c2b8fa0e56e5653c9aba08732&amp;chksm=eac531d6ddb2b8c06c599a1290a1fb4dd22d53855d88294a8a8b443be74a0279fdcaf912eb67&amp;token=1334996765&amp;lang=zh_CN#rd" target="_blank" rel="noopener">如何快速的回忆起遗忘的 Linux 命令</a>」 一文中介绍了如何利用 <code>Apropos</code> 命令来快速查找相应的 <code>Linux</code> 命令。今天，我们再给大家推荐另一款神器 <code>navi</code>。</p><p><code>navi</code> 是一位来自巴西的小哥哥 <code>Denis Isidoro</code> 在 <code>GitHub</code> 上开源的一个的工具 ，目前已经获得超过 4200 星。<code>navi</code> 可以在命令行里给你提供了一个很方便使用的交互式的备忘录，能够帮助你在命令行里快速查阅、调用各种复杂难记的命令行语句。</p><blockquote><p>项目地址：<a href="https://github.com/denisidoro/navi" target="_blank" rel="noopener">https://github.com/denisidoro/navi</a></p></blockquote><p>俗话说得好，不看广告看疗效。废话不多说，先看看下面的演示效果图吧！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWibFxicnQ872srGY3Mfa1NAolQ3R5aiatnRaHicaGwccN0wqRffAt6CFsiaicLPXT4fKFe4ze8GtDGfPRKw/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>从演示中，我们可能看到使用了 <code>navi</code> 后，只需要键入一个单词，备忘录中的相关命令以及命令用法注释都会实时显示在下方供你直接选择使用，这时我们只需找到想要的命令后即可直接运行相关命令。是不是觉得很神奇和强大呢！</p><a id="more"></a><h2 id="安装-navi">安装 Navi</h2><p><code>navi</code> 的安装还是很容易的，<code>macOS</code> 和 <code>Linux</code> 用户都可以安装。如果你已经安装了 <code>Homebrew</code> 或者 <code>Linuxbrew</code>，那么只需下面一句命令就可以安装好 <code>navi</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install denisidoro&#x2F;tools&#x2F;navi</span><br></pre></td></tr></table></figure><p>如果你没有安装 <code>Homebrew</code> 或者 <code>Linuxbrew</code> 这样的包管理器，你也可以直接通过源码安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth 1 https:&#x2F;&#x2F;github.com&#x2F;denisidoro&#x2F;navi &#x2F;opt&#x2F;navi</span><br><span class="line">$ cd &#x2F;opt&#x2F;navi</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你使用源码进行编译，你需要先安装好命令行模糊查找工具 <code>fzf</code>。 有关 <code>fzf</code> 的具体安装方法，你可以参考其官方网址：<a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">https://github.com/junegunn/fzf</a> 。</p></blockquote><h2 id="使用-navi">使用 Navi</h2><p><code>navi</code> 使用也是很简单的，你只需直接输入 <code>navi</code> 命令并回车后，即可进入交互界面进行命令查找。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWibFxicnQ872srGY3Mfa1NAolSjOwtnd9XMBfFpO1MTxDHnIzQ2TicD4PhAclcibY0Uiab9mddEj3oFicUg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>默认情况下，选中的命令会直接执行。如果你只想将选中的命令输入到命令行上，你可以加上 <code>--print</code> 选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi --print</span><br></pre></td></tr></table></figure><p>你也可以在 <code>navi</code> 命令后直接加入 <code>query</code> 子命令来预先过滤要输出的命令结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi query &lt;cmd&gt;</span><br></pre></td></tr></table></figure><p>如果你想查找一些命令的常用语法，你也可以使用 <code>search</code> 子命令来从在线仓库中下载对应的备忘清单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi search &lt;cmd&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义备忘录">自定义备忘录</h3><p><code>navi</code> 所使用的备忘清单都是以 <code>.cheat</code> 为后缀的一些文件，<code>navi</code> 安装完后，默认包括了以下这些备忘清单。</p><p><img src="https://i.loli.net/2019/10/21/Kl1J8tBA75wbnjq.png" alt=""></p><p><code>navi</code> 之所以如此受欢迎，主要原因是它支持强大的自定义功能，而且自定义注释还支持中文哟。</p><p>要实现此功能，我们可以用 <code>--dir</code> 参数将自己定义的备忘录 ( <code>.cheat</code> 文件) 传递给 <code>navi</code> 使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ navi --dir &quot;&#x2F;folder&#x2F;with&#x2F;cheats&quot;</span><br></pre></td></tr></table></figure><p>如果你觉得每次都通过 <code>--dir</code> 参数过于麻烦，你也可以通过环境变量来进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export NAVI_PATH&#x3D;&quot;&#x2F;folder&#x2F;with&#x2F;cheats:&#x2F;another&#x2F;folder&quot;</span><br></pre></td></tr></table></figure><p>介绍完了如何使用自定义的备忘清单后，接下来我们看看如何自已写一个备忘清单。</p><h4 id="cheat-文件语法">.cheat 文件语法</h4><p>我们先来看一个官方给出的 <code>.cheat</code> 文件的示例内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% git, code</span><br><span class="line"></span><br><span class="line"># Change branch</span><br><span class="line">git checkout &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">$ branch: git branch | awk &#39;&#123;print $NF&#125;&#39;</span><br></pre></td></tr></table></figure><p><code>.cheat</code> 文件语法主要有以下几个注意点。</p><ul><li><p>以「<code>%</code>」开头的行定义了该文件包含的特定的标签</p></li><li><p>以「<code>#</code>」开头的行描述了该命令的作用和用法</p></li><li><p>以「<code>$</code>」开头的行定义了给定参数的可选值</p></li><li><p>其它所有的非空行都被视为可执行命令，命令中的变量以 <code>&lt;&gt;</code> 表示</p></li></ul><p>最后我们来看一个实例，我们常用到的 <code>ffmpeg</code> 处理视频的命令通常都太长，这里我们就定义一个 <code>ffmpeg.cheat</code> 文件来管理这些日常常用的命令。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/YicUhk5aAGtD6nPkKEXmaqpLTyYphYt8k6Ya1akePwLKwanEgFvcSLQKicuvbiaX79hEV3KOOXic7qEz6yZcCMCrMA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>从上图可以看到，我们在完成 <code>ffmpeg</code> 命令备忘清单的定义后。日常使用中再也不用输入长长的命令，只需要选中对应命令后，再输入自定义参数就可完成所有操作。这样以来，是不是大大提升了工作效率呢!</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="https://url.cn/5pyiQLg" target="_blank" rel="noopener">https://url.cn/5pyiQLg</a></li><li><a href="https://url.cn/5EE2Ejc" target="_blank" rel="noopener">https://url.cn/5EE2Ejc</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，无论对于运维,还是开发来说，命令行工具都是非常高效的一种管理方式。但有一个很常见的现象就是，很多命令行语句比较复杂，用过一段时间后就忘记了。当然，这时我们可以通过网络搜索或者使用命令的 &lt;code&gt;-—help&lt;/code&gt; 选项来快速找到答案。虽然这种常用的方法能解决问题，但是使用起来相对还是显得不那么快速高效。&lt;/p&gt;
&lt;p&gt;之前，我们在「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487743&amp;amp;idx=1&amp;amp;sn=e726fa2c2b8fa0e56e5653c9aba08732&amp;amp;chksm=eac531d6ddb2b8c06c599a1290a1fb4dd22d53855d88294a8a8b443be74a0279fdcaf912eb67&amp;amp;token=1334996765&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何快速的回忆起遗忘的 Linux 命令&lt;/a&gt;」 一文中介绍了如何利用 &lt;code&gt;Apropos&lt;/code&gt; 命令来快速查找相应的 &lt;code&gt;Linux&lt;/code&gt; 命令。今天，我们再给大家推荐另一款神器 &lt;code&gt;navi&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;navi&lt;/code&gt; 是一位来自巴西的小哥哥 &lt;code&gt;Denis Isidoro&lt;/code&gt; 在 &lt;code&gt;GitHub&lt;/code&gt; 上开源的一个的工具 ，目前已经获得超过 4200 星。&lt;code&gt;navi&lt;/code&gt; 可以在命令行里给你提供了一个很方便使用的交互式的备忘录，能够帮助你在命令行里快速查阅、调用各种复杂难记的命令行语句。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/denisidoro/navi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/denisidoro/navi&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;俗话说得好，不看广告看疗效。废话不多说，先看看下面的演示效果图吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWibFxicnQ872srGY3Mfa1NAolQ3R5aiatnRaHicaGwccN0wqRffAt6CFsiaicLPXT4fKFe4ze8GtDGfPRKw/640?wx_fmt=gif&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从演示中，我们可能看到使用了 &lt;code&gt;navi&lt;/code&gt; 后，只需要键入一个单词，备忘录中的相关命令以及命令用法注释都会实时显示在下方供你直接选择使用，这时我们只需找到想要的命令后即可直接运行相关命令。是不是觉得很神奇和强大呢！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>分享一个快速获取 Nginx 客户端公网 IP 的神技</title>
    <link href="https://www.hi-linux.com/posts/4701.html"/>
    <id>https://www.hi-linux.com/posts/4701.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-11T04:51:39.272Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将给大家介绍一个 <code>Nginx</code> 的小技巧，可以在不使用任何编程语言的情况下，直接返回客户端公网 <code>IP</code> 地址。</p><p>实现方法非常的简单，你只要在 <code>Nginx</code> 中配置以下内容就可以解决问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;ip &#123;</span><br><span class="line">    default_type text&#x2F;plain;</span><br><span class="line">    return 200 $remote_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>curl</code> 命令测试一下，我们从响应结果可以看到只显示了客户端的 <code>IP</code> 地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl https:&#x2F;&#x2F;example.com&#x2F;ip</span><br><span class="line">2001:1b48:103::189</span><br></pre></td></tr></table></figure><blockquote><p><code>default_type text/plain</code> 指令除了阻止 <code>Web</code> 浏览器尝试将响应下载为文件外，并没有使用任何实用程序。即，<code>Web</code> 浏览器可以直接显示 <code>IP</code> 地址。</p></blockquote><a id="more"></a><p>如果你想将以上结果以 <code>JSON</code> 格式输出，只需做一点小修改即可实现。具体方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;json_ip &#123;</span><br><span class="line">    default_type application&#x2F;json;</span><br><span class="line">    return 200 &quot;&#123;\&quot;ip\&quot;:\&quot;$remote_addr\&quot;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，响应的就是一个漂亮的 <code>JSON</code> 格式的输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s https:&#x2F;&#x2F;example.com&#x2F;json_ip | jq</span><br><span class="line">&#123;</span><br><span class="line">    &quot;ip&quot;: &quot;2001:1b48:103::189&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，快速通过 <code>Nginx</code> 获取客户端公网 <code>IP</code> 地址的小技巧就演示完了。希望这个 <code>Nginx</code> 的小技巧可以为你节省一些维护时间。</p><blockquote><p>本文翻译至：<a href="https://url.cn/5Th0D1e%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82" target="_blank" rel="noopener">https://url.cn/5Th0D1e，版权归原作者所有。</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将给大家介绍一个 &lt;code&gt;Nginx&lt;/code&gt; 的小技巧，可以在不使用任何编程语言的情况下，直接返回客户端公网 &lt;code&gt;IP&lt;/code&gt; 地址。&lt;/p&gt;
&lt;p&gt;实现方法非常的简单，你只要在 &lt;code&gt;Nginx&lt;/code&gt; 中配置以下内容就可以解决问题。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;location &amp;#x2F;ip &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default_type text&amp;#x2F;plain;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 200 $remote_addr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用 &lt;code&gt;curl&lt;/code&gt; 命令测试一下，我们从响应结果可以看到只显示了客户端的 &lt;code&gt;IP&lt;/code&gt; 地址。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ curl https:&amp;#x2F;&amp;#x2F;example.com&amp;#x2F;ip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2001:1b48:103::189&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;default_type text/plain&lt;/code&gt; 指令除了阻止 &lt;code&gt;Web&lt;/code&gt; 浏览器尝试将响应下载为文件外，并没有使用任何实用程序。即，&lt;code&gt;Web&lt;/code&gt; 浏览器可以直接显示 &lt;code&gt;IP&lt;/code&gt; 地址。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="https://www.hi-linux.com/categories/nginx/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款史上最强跨平台、多端加密同步神器 Restic</title>
    <link href="https://www.hi-linux.com/posts/42308.html"/>
    <id>https://www.hi-linux.com/posts/42308.html</id>
    <published>2020-05-11T01:00:00.000Z</published>
    <updated>2020-05-11T04:51:39.273Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-restic">什么是 Restic</h2><p><code>Restic</code> 是一款 GO 语言开发的开源免费且快速、高效和安全的跨平台备份工具。<code>Restic</code> 使用加密技术来保证你的数据安全性和完整性，可以将本地数据加密后传输到指定的存储。</p><p><code>Restic</code> 同样支持增量备份，可随时备份和恢复备份。<code>Restic</code> 支持大多数主流操作系统，比如：<code>Linux</code>、<code>macOS</code>、<code>Windows</code> 以及一些较小众的操作系统 <code>FreeBSD</code> 和 <code>OpenBSD</code> 等。</p><blockquote><p>项目地址：<a href="https://github.com/restic/restic" target="_blank" rel="noopener">https://github.com/restic/restic</a></p></blockquote><p><strong>Restic 支持的存储类型</strong></p><p><code>Restic</code> 支持的存储种类比较多，大致有如下这些类型：</p><ul><li><p>本地存储</p></li><li><p>SFTP</p></li><li><p>REST Server</p></li><li><p>Amazon S3</p></li><li><p>Minio Server</p></li><li><p>OpenStack Swift</p></li><li><p>Backblaze B2</p></li><li><p>Microsoft Azure Blob Storage</p></li><li><p>Google Cloud Storage</p></li><li><p>通过 Rclone 挂载的存储 (比如：Google Drive、OneDrive 等)</p></li></ul><p><strong>Restic 与 Rclone 的区别</strong></p><p><code>Restic</code> 与 <code>Rclone</code> 都是开源的命令行文件备份（同步）工具，但却有着很本质的区别。</p><ol><li>两者的相同点</li></ol><ul><li><p>两者都是基于命令行的开源文件同步和备份工具。</p></li><li><p>两者都支持将文件备份到本地、远程服务器或对象存储。</p></li></ul><ol start="2"><li>两者不同点</li></ol><ul><li><p>Rclone 面向的是文件同步，即保证两端文件的一致，也可以增量备份。</p></li><li><p>Restic 面向的是文件备份和加密，文件先加密再传输备份，而且是增量备份，即每次只备份变化的部分。</p></li><li><p>Rclone 仓库配置保存在本地，备份的文件会保持原样的同步于存储仓库中。</p></li><li><p>Restic 配置信息直接写在仓库，只要有仓库密码，在任何安装了 Restic 的计算机上都可以操作仓库。</p></li><li><p>Rclone 不记录文件版本，无法根据某一次备份找回特定时间点上的文件。</p></li><li><p>Restic 每次备份都会生成一个快照，记录当前时间点的文件结构，可以找回特定时间点的文件。</p></li><li><p>Rclone 可以在配置的多个存储端之间传输文件。</p></li></ul><p>总的来说，<code>Rclone</code> 和 <code>Restic</code> 各有所长，要根据不同的业务需求选择使用。比如：网站数据的增量备份，用 <code>Resitc</code> 就比较合适。而常规文件的远程备份归档，用 <code>Rclone</code> 就很合适。</p><a id="more"></a><h2 id="安装-restic">安装 Restic</h2><p><code>Restic</code> 可以通过系统软件包安装，也可以直接下载最新的二进制包方式进行安装。</p><ol><li>通过软件包安装</li></ol><ul><li>Debian &amp; Ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install restic</span><br></pre></td></tr></table></figure><ul><li>RHEL &amp; CentOS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install yum-plugin-copr</span><br><span class="line">$ yum copr enable copart&#x2F;restic</span><br><span class="line">$ yum install restic</span><br></pre></td></tr></table></figure><ul><li>Fedora</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dnf install restic</span><br></pre></td></tr></table></figure><ul><li>Arch Linux</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pacman -S restic</span><br></pre></td></tr></table></figure><ul><li>macOS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install restic</span><br></pre></td></tr></table></figure><p>更多平台的软件包安装方法可参见官方文档：<a href="https://restic.readthedocs.io/en/stable/020_installation.html" target="_blank" rel="noopener">https://restic.readthedocs.io/en/stable/020_installation.html</a></p><ol start="2"><li>通过二进制版本安装</li></ol><p>通过预编译好的二进制版本进行安装，非常的简单。只要根据自己所需的平台选择对应的版本下载即可，这里以 <code>Linux</code> 系统为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 下载指定版本的安装包</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;restic&#x2F;restic&#x2F;releases&#x2F;download&#x2F;v0.9.5&#x2F;restic_0.9.5_linux_amd64.bz2</span><br><span class="line"></span><br><span class="line"># 解压并删除压缩包</span><br><span class="line">$ bzip2 -d restic*.bz2 &amp;&amp; rm -rf restic*.bz2</span><br><span class="line"></span><br><span class="line"># 增加执行权限</span><br><span class="line">$ chmod +x restic*</span><br><span class="line"></span><br><span class="line"># 移动二进制文件到指定目录</span><br><span class="line">$ mv restic* &#x2F;usr&#x2F;local&#x2F;bin&#x2F;restic</span><br><span class="line"></span><br><span class="line"># 验证所安装的版本</span><br><span class="line">$ restic version</span><br></pre></td></tr></table></figure><p>如果以后需要更新到最新版本，只需运行以下命令就可完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接升级二进制文件到最新版本</span><br><span class="line">$ restic self-update</span><br></pre></td></tr></table></figure><ol start="3"><li>Restic 常用语法命令</li></ol><p><code>Restic</code> 支持的命令和参数比较多，你可以使用 <code>--help</code> 参数来查看它们的基本用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">$ restic --help</span><br><span class="line">restic is a backup program which allows saving multiple revisions of files and</span><br><span class="line">directories in an encrypted repository stored on different backends.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  restic [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  backup        Create a new backup of files and&#x2F;or directories</span><br><span class="line">  cache         Operate on local cache directories</span><br><span class="line">  cat           Print internal objects to stdout</span><br><span class="line">  check         Check the repository for errors</span><br><span class="line">  diff          Show differences between two snapshots</span><br><span class="line">  dump          Print a backed-up file to stdout</span><br><span class="line">  find          Find a file or directory</span><br><span class="line">  forget        Remove snapshots from the repository</span><br><span class="line">  generate      Generate manual pages and auto-completion files (bash, zsh)</span><br><span class="line">  help          Help about any command</span><br><span class="line">  init          Initialize a new repository</span><br><span class="line">  key           Manage keys (passwords)</span><br><span class="line">  list          List objects in the repository</span><br><span class="line">  ls            List files in a snapshot</span><br><span class="line">  migrate       Apply migrations</span><br><span class="line">  mount         Mount the repository</span><br><span class="line">  prune         Remove unneeded data from the repository</span><br><span class="line">  rebuild-index Build a new index file</span><br><span class="line">  restore       Extract the data from a snapshot</span><br><span class="line">  snapshots     List all snapshots</span><br><span class="line">  stats         Count up sizes and show information about repository data</span><br><span class="line">  tag           Modify tags on snapshots</span><br><span class="line">  unlock        Remove locks other processes created</span><br><span class="line">  version       Print version information</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --cacert file              file to load root certificates from (default: use system certificates)</span><br><span class="line">      --cache-dir string         set the cache directory. (default: use system default cache directory)</span><br><span class="line">      --cleanup-cache            auto remove old cache directories</span><br><span class="line">  -h, --help                     help for restic</span><br><span class="line">      --json                     set output mode to JSON for commands that support it</span><br><span class="line">      --key-hint string          key ID of key to try decrypting first (default: $RESTIC_KEY_HINT)</span><br><span class="line">      --limit-download int       limits downloads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --limit-upload int         limits uploads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --no-cache                 do not use a local cache</span><br><span class="line">      --no-lock                  do not lock the repo, this allows some operations on read-only repos</span><br><span class="line">  -o, --option key&#x3D;value         set extended option (key&#x3D;value, can be specified multiple times)</span><br><span class="line">  -p, --password-file string     read the repository password from a file (default: $RESTIC_PASSWORD_FILE)</span><br><span class="line">  -q, --quiet                    do not output comprehensive progress report</span><br><span class="line">  -r, --repo string              repository to backup to or restore from (default: $RESTIC_REPOSITORY)</span><br><span class="line">      --tls-client-cert string   path to a file containing PEM encoded TLS client certificate and private key</span><br><span class="line">  -v, --verbose n[&#x3D;-1]           be verbose (specify --verbose multiple times or level n)</span><br><span class="line"></span><br><span class="line">Use &quot;restic [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><p>与 <code>Git</code> 等程序类似 <code>Restic</code> 有许多子命令，每个子命令都有自己的命令行选项。如果你要列出每个子命令的帮助选项，可以使用类似下面的命令语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 以备份子命令为例</span><br><span class="line">$ restic backup --help</span><br><span class="line">The &quot;backup&quot; command creates a new snapshot and saves the files and directories</span><br><span class="line">given as the arguments.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  restic backup [flags] FILE&#x2F;DIR [FILE&#x2F;DIR] ...</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -e, --exclude pattern                  exclude a pattern (can be specified multiple times)</span><br><span class="line">      --exclude-caches                   excludes cache directories that are marked with a CACHEDIR.TAG file. See http:&#x2F;&#x2F;bford.info&#x2F;cachedir&#x2F;spec.html for the Cache Directory Tagging Standard</span><br><span class="line">      --exclude-file file                read exclude patterns from a file (can be specified multiple times)</span><br><span class="line">      --exclude-if-present stringArray   takes filename[:header], exclude contents of directories containing filename (except filename itself) if header of that file is as provided (can be specified multiple times)</span><br><span class="line">      --files-from string                read the files to backup from file (can be combined with file args&#x2F;can be specified multiple times)</span><br><span class="line">  -f, --force                            force re-reading the target files&#x2F;directories (overrides the &quot;parent&quot; flag)</span><br><span class="line">  -h, --help                             help for backup</span><br><span class="line">      --hostname hostname                set the hostname for the snapshot manually. To prevent an expensive rescan use the &quot;parent&quot; flag</span><br><span class="line">  -x, --one-file-system                  exclude other file systems</span><br><span class="line">      --parent string                    use this parent snapshot (default: last snapshot in the repo that has the same target files&#x2F;directories)</span><br><span class="line">      --stdin                            read backup from stdin</span><br><span class="line">      --stdin-filename string            file name to use when reading from stdin (default &quot;stdin&quot;)</span><br><span class="line">      --tag tag                          add a tag for the new snapshot (can be specified multiple times)</span><br><span class="line">      --time string                      time of the backup (ex. &#39;2012-11-01 22:08:41&#39;) (default: now)</span><br><span class="line">      --with-atime                       store the atime for all files and directories</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">      --cacert file              file to load root certificates from (default: use system certificates)</span><br><span class="line">      --cache-dir string         set the cache directory. (default: use system default cache directory)</span><br><span class="line">      --cleanup-cache            auto remove old cache directories</span><br><span class="line">      --json                     set output mode to JSON for commands that support it</span><br><span class="line">      --key-hint string          key ID of key to try decrypting first (default: $RESTIC_KEY_HINT)</span><br><span class="line">      --limit-download int       limits downloads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --limit-upload int         limits uploads to a maximum rate in KiB&#x2F;s. (default: unlimited)</span><br><span class="line">      --no-cache                 do not use a local cache</span><br><span class="line">      --no-lock                  do not lock the repo, this allows some operations on read-only repos</span><br><span class="line">  -o, --option key&#x3D;value         set extended option (key&#x3D;value, can be specified multiple times)</span><br><span class="line">  -p, --password-file string     read the repository password from a file (default: $RESTIC_PASSWORD_FILE)</span><br><span class="line">  -q, --quiet                    do not output comprehensive progress report</span><br><span class="line">  -r, --repo string              repository to backup to or restore from (default: $RESTIC_REPOSITORY)</span><br><span class="line">      --tls-client-cert string   path to a file containing PEM encoded TLS client certificate and private key</span><br><span class="line">  -v, --verbose n[&#x3D;-1]           be verbose (specify --verbose multiple times or level n)</span><br></pre></td></tr></table></figure><h2 id="配置-restic-支持的存储方式">配置 Restic 支持的存储方式</h2><p>安装好 <code>Restic</code> 后，我们需要配置下存储方式。也就是你想备份数据到本地，还是其它远程服务上。</p><p>本文将主要讲讲最常用的本地、SFTP 两种备份方式，其它远程库配置方法可参考官方文档：<a href="https://restic.readthedocs.io/en/stable/030_preparing_a_new_repo.html" target="_blank" rel="noopener">https://restic.readthedocs.io/en/stable/030_preparing_a_new_repo.html</a> 。</p><ol><li>配置本地存储仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 备份到本地 &#x2F;home&#x2F;mike&#x2F;backup 文件夹</span><br><span class="line">$ restic init --repo &#x2F;home&#x2F;mike&#x2F;backup</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 SFTP 方式的存储仓库</li></ol><p>该方法适合将文件备份到另一台服务器上。首先，我们需要在两台服务器间配置免密码登录。</p><blockquote><p>注意：以下将需要备份的服务器称为 A，备份服务器称为 B。</p></blockquote><p>2.1 配置 SSH 免密码登录</p><p>这部分内容比较基础，就不在这里展开了。如果你不会配置可以参考以下两篇文章：</p><ul><li><p>「CentOS 下配置 SSH 免密码登录」：<a href="https://zhuanlan.zhihu.com/p/45025702" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45025702</a></p></li><li><p>「SSH 和 ssh-copy-id 以及批量多机无密码登陆详解」: <a href="https://www.cnblogs.com/operationhome/p/9166583.html" target="_blank" rel="noopener">https://www.cnblogs.com/operationhome/p/9166583.html</a></p></li></ul><p>2.2 在服务器 A 上进行数据备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># root 为服务器 B 的用户名，192.168.1.100 为 B 服务器 IP，端口默认为 22，&#x2F;home&#x2F;mike&#x2F;backup 为服务器 B 上的目录，如果不存在则会自动创建。</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup init</span><br></pre></td></tr></table></figure><p>如果服务器 B 的 <code>SSH</code> 默认端口不是 22，你就需要简单调整下 A 服务器上的 <code>SSH</code> 配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在服务器 A 中 ~&#x2F;.ssh 目录创建一个 config 文件，并新增如下内容。</span><br><span class="line"># 分别是 B 服务器的 IP、用户名和 SSH 的端口。</span><br><span class="line">$ vim ~&#x2F;.ssh&#x2F;config</span><br><span class="line">Host 192.168.1.100</span><br><span class="line">    User root</span><br><span class="line">    Port 2000</span><br></pre></td></tr></table></figure><p>由于上面配置了默认的 B 服务器的用户名和密码，现在就可以直接只写 B 服务器的 IP 就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup init</span><br></pre></td></tr></table></figure><blockquote><p>注意：以上配置过程中都会要求你输入密码，切记不要遗忘。</p></blockquote><h2 id="使用-restic-备份数据">使用 Restic 备份数据</h2><p>经过上面的步骤，我们已经完成了备份存储的初始化。现在我就来看几个 <code>Restic</code> 备份的例子。</p><p>以下我们所有演示的例子均是将 A 服务器上 <code>/var/www/</code> 目录下的文件备份到 B 服务器上的 <code>/home/mike/backup</code> 目录下。</p><h3 id="创建备份快照">创建备份快照</h3><p>以下命令是备份的 <code>/var/www</code> 整个目录，如果只需备份目录中单个文件，比如：<code>/var/www/mike.zip</code>，那备份内容就可以改成 <code>/var/www/mike.zip</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 本地备份</span><br><span class="line">$ restic -r &#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www</span><br><span class="line"></span><br><span class="line"># SFTP 备份</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www</span><br></pre></td></tr></table></figure><p>如果你不想备份目录下全部的内容，你还可以用以下参数排除或包含指定的备份目录或者文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--include 指定一次或多次以包含一个或者多个目录或文件</span><br><span class="line">--exclude 指定一次或多次以排除一个或多个目录或文件</span><br><span class="line">--exclude-caches 指定一次以排除包含特殊文件的目录</span><br><span class="line">--exclude-file 指定一次或多次以排除给定文件中列出的项目</span><br><span class="line">--exclude-if-present 如果目录内容包含给定文件，则指定一次或多次排除目录的内容</span><br></pre></td></tr></table></figure><p>具体用法可以参考官方文档: <a href="https://restic.readthedocs.io/en/stable/040_backup.html#including-and-excluding-files" target="_blank" rel="noopener">https://restic.readthedocs.io/en/stable/040_backup.html#including-and-excluding-files</a></p><p><code>Restic</code> 还支持直接将命令的输出进行重定向，比如：将备份好的数据库文件直接通过 <code>SFTP</code> 方式备份到另一台服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将 Wordpress 数据库备份到另一台服务器，并命名为 Wordpress_Backup.sql</span><br><span class="line">$ mysqldump -uroot -ppasswd 000000 --databases Wordpress | restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup backup --stdin --stdin-filename Wordpress_Backup.sql</span><br></pre></td></tr></table></figure><h3 id="列出备份快照">列出备份快照</h3><p>备份完成后，可以使用以下命令查看备份的快照信息。您可以看到我们在第一次备份期间的快照 ID，拍摄快照的时间戳，主机名，标签以及备份的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有备份快照</span><br><span class="line"></span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup snapshots</span><br><span class="line">ID        Time                 Host        Tags              Paths</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">ef5ff5fe  2019-08-25 17:03:57  Mike-Dev01                          &#x2F;home&#x2F;mike&#x2F;backup</span><br><span class="line">9f0bc19e  2019-08-26 17:18:57  Mike-Dev02                          &#x2F;home&#x2F;devops&#x2F;backup</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 只查看 &#x2F;home&#x2F;mike&#x2F;backup 目录的备份快照</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup snapshots --path&#x3D;&quot;&#x2F;home&#x2F;mike&#x2F;backup&quot;</span><br><span class="line">ID        Time                 Host        Tags              Paths</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">ef5ff5fe  2019-08-25 17:03:57  Mike-Dev01                          &#x2F;home&#x2F;mike&#x2F;backup</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 只查看主机名为 Mike-Dev01 的备份快照</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup snapshots --host Mike-Dev01</span><br><span class="line">ID        Time                 Host        Tags              Paths</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">ef5ff5fe  2019-08-25 17:03:57  Mike-Dev01                          &#x2F;home&#x2F;mike&#x2F;backup</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 列出某个快照中所包含的文件</span><br><span class="line">$ restic ls ef5ff5fe</span><br><span class="line">snapshot ef5ff5fe of [&#x2F;home&#x2F;mike&#x2F;backup] at 2019-08-25 20:35:39.450146467 +0800 CST):</span><br><span class="line">&#x2F;backup</span><br><span class="line">&#x2F;backup&#x2F;2019-04-19_2004334933.jpg</span><br><span class="line">&#x2F;backup&#x2F;2019-04-13_15-00-15.png</span><br><span class="line">&#x2F;backup&#x2F;2019-04-16_15-19-39.png</span><br><span class="line">&#x2F;backup&#x2F;2019-04-16_15-20-22.png</span><br><span class="line">&#x2F;backup&#x2F;2019-04-18_17-11-52.png</span><br></pre></td></tr></table></figure><p>从上面的结果，我们可以看到 <code>Tags</code> 列是空的。这是因为备份时没有使用 <code>--tag</code> 参数，下面我们演示下 <code>--tag</code> 参数的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 给备份文件指定标签</span><br><span class="line">$ restic -r sftp:192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www --tag site</span><br></pre></td></tr></table></figure><p>如果你想加入更多标签来更详细的区分备份，那就在后面多加几个 <code>--tag</code> 参数。</p><h3 id="恢复备份快照">恢复备份快照</h3><p>这里以 <code>SFTP</code> 存储仓库为例，我们将远程存储目录 <code>/home/mike/backup</code> 的备份文件恢复到本地 <code>/var/wwww</code> 文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># restore 后面指定为要恢复备份的 ID</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup restore ef5ff5fe --target &#x2F;var&#x2F;wwww</span><br><span class="line"></span><br><span class="line"># 你也可以直接使用 latest 来恢复最后一次的备份文件</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup restore latest --target &#x2F;var&#x2F;wwww</span><br></pre></td></tr></table></figure><h3 id="删除备份快照">删除备份快照</h3><p>如果你不在再要一些备份快照，你可以直接使用下面的命令删除指定的备份快照。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ef5ff5fe 为要删除文件的 ID</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup forget ef5ff5fe</span><br></pre></td></tr></table></figure><p>不过上面的命令只是将快照记录清除了，但快照中包含的文件数据仍存储在存储库中。如果要彻底清除未引用的数据，你必须运行 <code>prune</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup prune</span><br><span class="line">enter password for repository:</span><br><span class="line"></span><br><span class="line">counting files in repo</span><br><span class="line">building new index for repo</span><br><span class="line">[0:00] 100.00%  22 &#x2F; 22 files</span><br><span class="line">repository contains 22 packs (8512 blobs) with 100.092 MiB bytes</span><br><span class="line">processed 8512 blobs: 0 duplicate blobs, 0B duplicate</span><br><span class="line">load all snapshots</span><br><span class="line">find data that is still in use for 1 snapshots</span><br><span class="line">[0:00] 100.00%  1 &#x2F; 1 snapshots</span><br><span class="line">found 8433 of 8512 data blobs still in use</span><br><span class="line">will rewrite 3 packs</span><br><span class="line">creating new index</span><br><span class="line">[0:00] 86.36%  19 &#x2F; 22 files</span><br><span class="line">saved new index as 544a5084</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>清理完成后，存储库的空间就会释放出来。当然你也可以直接使用 <code>--prune</code> 参数来将上面两步合成为一步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ef5ff5fe 为要删除文件的 ID</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup forget ef5ff5fe --prune</span><br></pre></td></tr></table></figure><h2 id="使用-restic-进行自动备份">使用 Restic 进行自动备份</h2><ol><li>免密码操作存储仓库</li></ol><p>上面的备份中我们都手工输入了密码，如果需要定期备份当然是通过一个脚本来实现是最方便，但是在使用脚本备份时如果要显示输入访问存储仓库的密码肯定不适用的。这里我们就需要使用 <code>--password-file</code> 参数来达到自动读取密码的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将密码保存在 &#x2F;home&#x2F;mike&#x2F;resticpasswd 文本中</span><br><span class="line">$ echo &#39;000000&#39; &gt; &#x2F;home&#x2F;mike&#x2F;resticpasswd</span><br><span class="line"></span><br><span class="line"># 在备份命令中使用 --password-file 参数来读取文本中的密码</span><br><span class="line">$ restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup --verbose backup &#x2F;var&#x2F;www --password-file &#x2F;home&#x2F;mike&#x2F;resticpasswd</span><br></pre></td></tr></table></figure><p>除了使用 <code>--password-file</code> 参数指定密码外，你也可以使用环境变量来指定一些 <code>Restic</code> 所需的参数。例如，使用腾讯云的对象存储就可以使用下面这些环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export TencentCloud_ACCESS_KEY_ID&#x3D;&quot;your-access-key&quot;</span><br><span class="line">export TencentCloud_SECRET_ACCESS_KEY&#x3D;&quot;your-secret-key&quot;</span><br><span class="line">export RESTIC_REPOSITORY&#x3D;&quot;s3:server-url&#x2F;bucket-name&quot;</span><br><span class="line">export RESTIC_PASSWORD&#x3D;&quot;a-strong-password&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>结合 Cron 完成自动备份</li></ol><p><code>Restic</code> 中的 <code>forget</code> 命令可以帮助你来维护快照的运行存档。你可以使用 <code>restic forget --prune</code> 来设置每小时、每日、每周等保留的备份数量，任何不符合策略的备份都将从存储库中清除。</p><p>这里我们将使用 <code>Cron</code> 系统服务每 30 分钟运行一次备份任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br><span class="line">30 * * * * &#x2F;usr&#x2F;local&#x2F;bin&#x2F;restic -r sftp:root@192.168.1.100:&#x2F;home&#x2F;mike&#x2F;backup backup --password-file &#x2F;home&#x2F;mike&#x2F;resticpasswd -q &#x2F;var&#x2F;www; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;restic forget -q --prune --keep-hourly 24 --keep-daily 7</span><br></pre></td></tr></table></figure><p>上面的计划任务里，其中 <code>30 * * * *</code> 定义了 Cron 中任务运行的时间，这里定义为每隔 30 分钟运行。<code>--keep-hourly 24 --keep-daily 7</code> 定义了根据指定的保留标志并删除不再需要的旧快照，在这里我们是将 24 小时内的快照保留 7 天。</p><p>更多策略可参考官方文档：<a href="https://restic.readthedocs.io/en/latest/060_forget.html#removing-snapshots-according-to-a-policy" target="_blank" rel="noopener">https://restic.readthedocs.io/en/latest/060_forget.html#removing-snapshots-according-to-a-policy</a></p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://restic.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://restic.readthedocs.io/en/latest/</a></p></li><li><p><a href="https://www.moerats.com/archives/897/" target="_blank" rel="noopener">https://www.moerats.com/archives/897/</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1160729" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1160729</a></p></li><li><p><a href="https://it.ismy.fun/2018/04/22/restic-backup-to-aliyun-oss/" target="_blank" rel="noopener">https://it.ismy.fun/2018/04/22/restic-backup-to-aliyun-oss/</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/66324926" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66324926</a></p></li><li><p><a href="https://www.elasticfeed.com/e8590b1297e81b6e7ab19c66be4f037d/" target="_blank" rel="noopener">https://www.elasticfeed.com/e8590b1297e81b6e7ab19c66be4f037d/</a></p></li><li><p><a href="https://www.vmvps.com/restic-a-new-opensource-backup-free-tool-to-backup-your-vps-files.html" target="_blank" rel="noopener">https://www.vmvps.com/restic-a-new-opensource-backup-free-tool-to-backup-your-vps-files.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Restic&quot;&gt;什么是 Restic&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 是一款 GO 语言开发的开源免费且快速、高效和安全的跨平台备份工具。&lt;code&gt;Restic&lt;/code&gt; 使用加密技术来保证你的数据安全性和完整性，可以将本地数据加密后传输到指定的存储。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 同样支持增量备份，可随时备份和恢复备份。&lt;code&gt;Restic&lt;/code&gt; 支持大多数主流操作系统，比如：&lt;code&gt;Linux&lt;/code&gt;、&lt;code&gt;macOS&lt;/code&gt;、&lt;code&gt;Windows&lt;/code&gt; 以及一些较小众的操作系统 &lt;code&gt;FreeBSD&lt;/code&gt; 和 &lt;code&gt;OpenBSD&lt;/code&gt; 等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/restic/restic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/restic/restic&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Restic 支持的存储类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 支持的存储种类比较多，大致有如下这些类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SFTP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST Server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Amazon S3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Minio Server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenStack Swift&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Backblaze B2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Microsoft Azure Blob Storage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Google Cloud Storage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 Rclone 挂载的存储 (比如：Google Drive、OneDrive 等)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Restic 与 Rclone 的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Restic&lt;/code&gt; 与 &lt;code&gt;Rclone&lt;/code&gt; 都是开源的命令行文件备份（同步）工具，但却有着很本质的区别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两者的相同点&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两者都是基于命令行的开源文件同步和备份工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两者都支持将文件备份到本地、远程服务器或对象存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;两者不同点&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Rclone 面向的是文件同步，即保证两端文件的一致，也可以增量备份。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restic 面向的是文件备份和加密，文件先加密再传输备份，而且是增量备份，即每次只备份变化的部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rclone 仓库配置保存在本地，备份的文件会保持原样的同步于存储仓库中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restic 配置信息直接写在仓库，只要有仓库密码，在任何安装了 Restic 的计算机上都可以操作仓库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rclone 不记录文件版本，无法根据某一次备份找回特定时间点上的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restic 每次备份都会生成一个快照，记录当前时间点的文件结构，可以找回特定时间点的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rclone 可以在配置的多个存储端之间传输文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总的来说，&lt;code&gt;Rclone&lt;/code&gt; 和 &lt;code&gt;Restic&lt;/code&gt; 各有所长，要根据不同的业务需求选择使用。比如：网站数据的增量备份，用 &lt;code&gt;Resitc&lt;/code&gt; 就比较合适。而常规文件的远程备份归档，用 &lt;code&gt;Rclone&lt;/code&gt; 就很合适。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Restic" scheme="https://www.hi-linux.com/tags/Restic/"/>
    
  </entry>
  
  <entry>
    <title>分享几个无需 Docker 环境拉取容器镜像的神器</title>
    <link href="https://www.hi-linux.com/posts/46425.html"/>
    <id>https://www.hi-linux.com/posts/46425.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T03:23:02.446Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>你是否曾经遇到过需要在没有安装任何 <code>Docker</code> 客户端的机器上拉取容器镜像这样变态的需求呢？如果有,你当时又是如何解决的呢？今天我们就来给大家介绍几种另辟蹊径的方法来实现这样的需求。</p><h2 id="使用-docker-drag-实现">使用 docker-drag 实现</h2><p>根据官网介绍：<code>docker-drag</code> 是一个用于与 <code>Docker Hub</code> 交互的工具，并且不需 <code>Docker</code> 客户端本身支持。它主要是通过与 <code>Docker Hub</code> 的 <code>HTTPS API</code> 进行交互来实现相应功能。</p><blockquote><p>项目地址：<a href="https://github.com/NotGlop/docker-drag" target="_blank" rel="noopener">https://github.com/NotGlop/docker-drag</a></p></blockquote><h3 id="安装-docker-drag">安装 docker-drag</h3><p><code>docker-drag</code> 其实就是一个 <code>Python</code> 脚本，目前版本总共才 168 行代码。你只需要去官网仓库直接下载就可以使用了，非常的简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;NotGlop&#x2F;docker-drag&#x2F;master&#x2F;docker_pull.py</span><br></pre></td></tr></table></figure><h3 id="使用-docker-drag">使用 docker-drag</h3><p>我们先来看一下官方给出的演示效果。</p><p><img src="https://user-images.githubusercontent.com/26483750/63388733-b419f480-c3a9-11e9-8617-7c5b47b76dbd.gif" alt=""></p><p><code>docker-drag</code> 的使用也是非常简单的，基本上和 <code>docke pull</code> 命令使用方法一致。其主要是借助 <code>Python</code> 的 <code>Request</code> 库和 <code>HTTPS API</code> 直接从仓库中拉取镜像，并保存为 <code>TAR</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在官方仓库拉取官方镜像</span></span><br><span class="line">$ python docker_pull.py nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接在官方仓库拉取三方镜像</span></span><br><span class="line">$ python docker_pull.py mysql/mysql-server:8.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接在三方仓库拉取镜像</span></span><br><span class="line">$ python docker_pull.py mcr.microsoft.com/windows/nanoserver@sha256:ae443bd9609b9ef06d21d6caab59505cb78f24a725cc24716d4427e36aedabf2</span><br></pre></td></tr></table></figure><p>镜像下载完成后，你可以直接使用 <code>docker load -i</code> 命令对 <code>TAR</code> 文件进行加载。由于不在依赖容器工具本身，在一些实际使用场景中，例如：CICD 流程。这个小工具或许能助你解决大问题哟！</p><a id="more"></a><h2 id="使用-download-frozen-image-v2-实现">使用 download-frozen-image-v2 实现</h2><p>与 <code>docker-drag</code> 类似的工具，还有一个 <code>SHELL</code> 脚本的实现 <code>download-frozen-image-v2</code>，该脚本隶属于 <code>Moby</code> 项目。</p><blockquote><p>项目地址：<a href="https://github.com/moby/moby" target="_blank" rel="noopener">https://github.com/moby/moby</a></p></blockquote><p>它的使用基本上和 <code>docker-drag</code> 类似，大致有如以下几步所示。</p><ol><li>下载对应的脚本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://raw.githubusercontent.com/moby/moby/master/contrib/download-frozen-image-v2.sh</span><br></pre></td></tr></table></figure><ol start="2"><li>download-frozen-image-v2 脚本使用语法</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">download-frozen-image-v2.sh target_dir image[:tag][@digest] ...</span><br></pre></td></tr></table></figure><ol start="3"><li>一个完整的使用实例</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 Ubuntu 容器镜像</span></span><br><span class="line">$ bash download-frozen-image-v2.sh ubuntu ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># download-frozen-image-v2 这里要稍为复杂点，需要自己手动打成 TAR 包</span></span><br><span class="line">$ tar -C <span class="string">'ubuntu'</span> -cf <span class="string">'ubuntu.tar'</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入容器镜像</span></span><br><span class="line">$ docker load -i ubuntu.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入容器镜像完成后，运一个容器</span></span><br><span class="line">$ docker run --rm -ti ubuntu bash</span><br><span class="line">root@1dd5e62113b9:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="使用-dp-实现">使用 dp 实现</h2><p><code>dp</code> 同样也是一个实现上述类似需求的小工具。<code>dp</code> 使用 <code>Go</code> 语言开发，天生具有良好的跨平台性。相对于前两个工具来说更容易在多平台上部署使用，而且 <code>dp</code> 还支持将多个镜像打包在一起。</p><blockquote><p>项目地址：<a href="https://github.com/zhangguanzhang/dp/" target="_blank" rel="noopener">https://github.com/zhangguanzhang/dp/</a></p></blockquote><h3 id="安装-dp">安装 dp</h3><p><code>dp</code> 的安装非常简单，只需在官方仓库 <code>Releases</code> 页面直接下载各平台对应的版本，解压后即可使用。</p><h3 id="使用-dp">使用 dp</h3><p><code>dp</code> 使用起来也是很容易的，下面我们就来看几个实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从官方仓库拉取一个容器镜像</span></span><br><span class="line">$ dp pull nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从官方仓库拉取一个容器镜像并打包到压缩文件</span></span><br><span class="line">$ dp pull -o nginx.tar.gz nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 sha256 拉取一个容器镜像</span></span><br><span class="line">$ dp pull mcr.microsoft.com/windows/nanoserver@sha256:ae443bd9609b9ef06d21d6caab59505cb78f24a725cc24716d4427e36aedabf2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次从官方仓库拉取多个容器镜像并打包到压缩文件</span></span><br><span class="line">$ dp pull -o project.tar.gz nginx:alpine nginx:1.17.5-alpine-perl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从三方镜像仓库拉取多个容器镜像并打包到压缩文件</span></span><br><span class="line">$ dp pull -o project.tar.gz nginx:alpine gcr.io/google_containers/pause-amd64:3.1</span><br></pre></td></tr></table></figure><p>至此，我们就演示完了如何在不需要 <code>Docker</code> 客户端的前提下拉取容器镜像的方法。如果你还有更多更好的方法，欢迎大家积极留言哟！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://xbuba.com/questions/37905763" target="_blank" rel="noopener">https://xbuba.com/questions/37905763</a></p></li><li><p><a href="https://blog.fleeto.us/post/pull-image-without-docker/" target="_blank" rel="noopener">https://blog.fleeto.us/post/pull-image-without-docker/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否曾经遇到过需要在没有安装任何 &lt;code&gt;Docker&lt;/code&gt; 客户端的机器上拉取容器镜像这样变态的需求呢？如果有,你当时又是如何解决的呢？今天我们就来给大家介绍几种另辟蹊径的方法来实现这样的需求。&lt;/p&gt;
&lt;h2 id=&quot;使用-docker-drag-实现&quot;&gt;使用 docker-drag 实现&lt;/h2&gt;
&lt;p&gt;根据官网介绍：&lt;code&gt;docker-drag&lt;/code&gt; 是一个用于与 &lt;code&gt;Docker Hub&lt;/code&gt; 交互的工具，并且不需 &lt;code&gt;Docker&lt;/code&gt; 客户端本身支持。它主要是通过与 &lt;code&gt;Docker Hub&lt;/code&gt; 的 &lt;code&gt;HTTPS API&lt;/code&gt; 进行交互来实现相应功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/NotGlop/docker-drag&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/NotGlop/docker-drag&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装-docker-drag&quot;&gt;安装 docker-drag&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker-drag&lt;/code&gt; 其实就是一个 &lt;code&gt;Python&lt;/code&gt; 脚本，目前版本总共才 168 行代码。你只需要去官网仓库直接下载就可以使用了，非常的简单。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ wget https:&amp;#x2F;&amp;#x2F;raw.githubusercontent.com&amp;#x2F;NotGlop&amp;#x2F;docker-drag&amp;#x2F;master&amp;#x2F;docker_pull.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用-docker-drag&quot;&gt;使用 docker-drag&lt;/h3&gt;
&lt;p&gt;我们先来看一下官方给出的演示效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26483750/63388733-b419f480-c3a9-11e9-8617-7c5b47b76dbd.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker-drag&lt;/code&gt; 的使用也是非常简单的，基本上和 &lt;code&gt;docke pull&lt;/code&gt; 命令使用方法一致。其主要是借助 &lt;code&gt;Python&lt;/code&gt; 的 &lt;code&gt;Request&lt;/code&gt; 库和 &lt;code&gt;HTTPS API&lt;/code&gt; 直接从仓库中拉取镜像，并保存为 &lt;code&gt;TAR&lt;/code&gt; 文件。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 直接在官方仓库拉取官方镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ python docker_pull.py nginx:alpine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 直接在官方仓库拉取三方镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ python docker_pull.py mysql/mysql-server:8.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 直接在三方仓库拉取镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ python docker_pull.py mcr.microsoft.com/windows/nanoserver@sha256:ae443bd9609b9ef06d21d6caab59505cb78f24a725cc24716d4427e36aedabf2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;镜像下载完成后，你可以直接使用 &lt;code&gt;docker load -i&lt;/code&gt; 命令对 &lt;code&gt;TAR&lt;/code&gt; 文件进行加载。由于不在依赖容器工具本身，在一些实际使用场景中，例如：CICD 流程。这个小工具或许能助你解决大问题哟！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>分享一个超实用的 Web 版 SSH 工具 Sshwifty</title>
    <link href="https://www.hi-linux.com/posts/2389.html"/>
    <id>https://www.hi-linux.com/posts/2389.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T03:23:02.448Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>无论你是一名开发或者运维，相信都对 <code>SSH</code> 这个工具都不陌生。不管是开发需要访问服务器处理程序错误还是运维访问服务器处理服务异常，我们都需要通过 <code>SSH</code> 协议来远程连接到服务器。</p><p>通常我们使用 <code>SSH</code> 协议访问服务器基本都是使用 <code>SSH</code> 客户端软件，比如：<code>Xshell</code>、<code>Putty</code>、<code>SecureCRT</code>、<code>iTerm 2</code> 等。这些客户端软件虽然使用上都比较方便，但在有些场景下，我们需要在没有安装 <code>SSH</code> 客户端的环境下访问远程服务器。这时我们应该怎么办呢，当然是有办法解决的，那就是通过 <code>WebSSH</code> 这种方法来进行访问。</p><blockquote><p><code>WebSSH</code> 泛指一种可以在网页上实现一个 <code>SSH</code> 终端的技术。从而无需任何 <code>SSH</code> 客户端工具就可进行 <code>SSH</code> 连接，将 <code>SSH</code> 从 <code>C/S</code> 架构转变成了 <code>B/S</code> 架构。</p></blockquote><p>目前，可以实现 <code>WebSSH</code> 的软件有很多，比如：<code>GateOne</code>、<code>Shellinabox</code>、<code>WSSH</code>、<code>Xterm.js</code> 等，而我们今天要介绍的是一款更为强大的 <code>WebSSH</code> 软件 <code>Sshwifty</code>。<code>Sshwifty</code> 使用 <code>Go</code>、<code>Vuejs</code> 和 <code>xtermjs</code> 进行开发，几乎实现了目前所有  <code>WebSSH</code> 软件的功能。</p><blockquote><p>项目地址：<a href="https://github.com/niruix/sshwifty" target="_blank" rel="noopener">https://github.com/niruix/sshwifty</a></p></blockquote><p><img src="https://github.com/niruix/sshwifty/raw/master/Screenshot.png" alt=""></p><a id="more"></a><h2 id="安装-sshwifty">安装 Sshwifty</h2><ol><li>通过二进制包安装</li></ol><p>由于  <code>Sshwifty</code> 采用 <code>Go</code> 语言开发，良好的原生跨平台支持。安装起来非常简单，基本开箱即用。这里以 <code>Linux</code> 平台为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 下载并解压 Sshwifty 安装包</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;niruix&#x2F;sshwifty&#x2F;releases&#x2F;download&#x2F;0.1.0-beta-release-prebuild&#x2F;sshwifty_0.1.0-beta-release_linux_amd64.tar.gz</span><br><span class="line">$ tar -xzvf sshwifty_0.1.0-beta-release_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 复制可执行文件到指定目录并赋予执行权限</span><br><span class="line">$ cp sshwifty_linux_amd64 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;sshwifty</span><br><span class="line">$ chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;sshwifty</span><br><span class="line"></span><br><span class="line"># 生成默认配置文件</span><br><span class="line">$ cp sshwifty.conf.example.json &#x2F;etc&#x2F;sshwifty.conf.json</span><br><span class="line"></span><br><span class="line"># 启动 Sshwifty</span><br><span class="line">$ sshwifty</span><br></pre></td></tr></table></figure><blockquote><p>使用默认配置文件会在 <code>127.0.0.1</code> 的 <code>8182</code> 端口启动 <code>Sshwifty</code> 服务，你可以根据自行需要更改。</p></blockquote><p>更多平台的二进制安装包，可自行在官方项目地址的 <a href="https://github.com/niruix/sshwifty/releases" target="_blank" rel="noopener">Releases</a> 页面进行下载。</p><ol start="2"><li>通过 Docker 安装</li></ol><p>如果你会一点 <code>Docker</code> 的话，强烈建议使用 <code>Docker</code> 进行部署安装。通过 <code>Docker</code> 安装仅需要一条指令就可以搞定，比二进制包安装更加的简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --detach \</span><br><span class="line">  --restart&#x3D;always \</span><br><span class="line">  --publish 8182:8182 \</span><br><span class="line">  --name sshwifty \</span><br><span class="line">  niruix&#x2F;sshwifty:latest</span><br></pre></td></tr></table></figure><p>如果你想给 <code>Sshwifty</code> 部署一个 <code>HTTPS</code> 证书，可以使用以下的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --detach \</span><br><span class="line">  --restart&#x3D;always \</span><br><span class="line">  --publish 8182:8182 \</span><br><span class="line">  --env SSHWIFTY_DOCKER_TLSCERT&#x3D;&quot;$(cat &#x2F;path&#x2F;to&#x2F;domain.crt)&quot;</span><br><span class="line">  --env SSHWIFTY_DOCKER_TLSCERTKEY&#x3D;&quot;$(cat &#x2F;path&#x2F;to&#x2F;domain.key)&quot;</span><br><span class="line">  --name sshwifty \</span><br><span class="line">  niruix&#x2F;sshwifty:latest</span><br></pre></td></tr></table></figure><blockquote><p><code>/path/to/domain.crt</code> 和 <code>/path/to/domain.key</code> 是用来指定本地 <code>HTTPS</code> 证书和密钥文件所在的位置。</p></blockquote><h2 id="使用-sshwifty">使用 Sshwifty</h2><p><code>Sshwifty</code> 部署好后，直接用浏览器访问相应地址即可使用。首次访问时，会要求输入一个认证口令。</p><p><img src="https://i.loli.net/2019/09/16/DiOCrIVw6mPYEnu.png" alt=""></p><blockquote><p>默认口令为：<code>WEB_ACCESS_PASSWORD</code>，如需修改可变更配置文件中的 <code>&quot;SharedKey&quot;: &quot;WEB_ACCESS_PASSWORD&quot;</code> 配置项。</p></blockquote><p>认证完成后，成功登陆 <code>Sshwifty</code>。</p><p><img src="https://i.loli.net/2019/09/16/Uj5ClXMmyA3wLTF.png" alt=""></p><p>点击左上角 <code>+</code> 号图标后，就可新建一个访问远程服务器 <code>SSH</code> 或 <code>Telnet</code> 的连接。</p><p><img src="https://i.loli.net/2019/09/16/SgXJMa2ECVxDBfA.png" alt=""></p><p>如果你觉得自已部署还是太麻烦，也可以直接使用官方提供的演示地址进行体验哟！</p><blockquote><p>官方演示地址：<a href="https://sshwifty.herokuapp.com/" target="_blank" rel="noopener">https://sshwifty.herokuapp.com/</a></p></blockquote><p>你在这里不仅可以体验 <code>Sshwifty</code> 的强大功能，还可以在这里观看有趣的星球大战 <code>Telnet</code> 版哟！</p><p><img src="https://i.loli.net/2019/09/16/E4VAHQi9Mm8FTJw.png" alt=""></p><p>至此，<code>Sshwifty</code> 的基本使用就已经介绍完成了。如果你对它很有兴趣，可以自行去官网进行探索哟！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://github.com/niruix/sshwifty" target="_blank" rel="noopener">https://github.com/niruix/sshwifty</a></p></li><li><p><a href="https://www.cnblogs.com/franknihao/p/8963634.html" target="_blank" rel="noopener">https://www.cnblogs.com/franknihao/p/8963634.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论你是一名开发或者运维，相信都对 &lt;code&gt;SSH&lt;/code&gt; 这个工具都不陌生。不管是开发需要访问服务器处理程序错误还是运维访问服务器处理服务异常，我们都需要通过 &lt;code&gt;SSH&lt;/code&gt; 协议来远程连接到服务器。&lt;/p&gt;
&lt;p&gt;通常我们使用 &lt;code&gt;SSH&lt;/code&gt; 协议访问服务器基本都是使用 &lt;code&gt;SSH&lt;/code&gt; 客户端软件，比如：&lt;code&gt;Xshell&lt;/code&gt;、&lt;code&gt;Putty&lt;/code&gt;、&lt;code&gt;SecureCRT&lt;/code&gt;、&lt;code&gt;iTerm 2&lt;/code&gt; 等。这些客户端软件虽然使用上都比较方便，但在有些场景下，我们需要在没有安装 &lt;code&gt;SSH&lt;/code&gt; 客户端的环境下访问远程服务器。这时我们应该怎么办呢，当然是有办法解决的，那就是通过 &lt;code&gt;WebSSH&lt;/code&gt; 这种方法来进行访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;WebSSH&lt;/code&gt; 泛指一种可以在网页上实现一个 &lt;code&gt;SSH&lt;/code&gt; 终端的技术。从而无需任何 &lt;code&gt;SSH&lt;/code&gt; 客户端工具就可进行 &lt;code&gt;SSH&lt;/code&gt; 连接，将 &lt;code&gt;SSH&lt;/code&gt; 从 &lt;code&gt;C/S&lt;/code&gt; 架构转变成了 &lt;code&gt;B/S&lt;/code&gt; 架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前，可以实现 &lt;code&gt;WebSSH&lt;/code&gt; 的软件有很多，比如：&lt;code&gt;GateOne&lt;/code&gt;、&lt;code&gt;Shellinabox&lt;/code&gt;、&lt;code&gt;WSSH&lt;/code&gt;、&lt;code&gt;Xterm.js&lt;/code&gt; 等，而我们今天要介绍的是一款更为强大的 &lt;code&gt;WebSSH&lt;/code&gt; 软件 &lt;code&gt;Sshwifty&lt;/code&gt;。&lt;code&gt;Sshwifty&lt;/code&gt; 使用 &lt;code&gt;Go&lt;/code&gt;、&lt;code&gt;Vuejs&lt;/code&gt; 和 &lt;code&gt;xtermjs&lt;/code&gt; 进行开发，几乎实现了目前所有  &lt;code&gt;WebSSH&lt;/code&gt; 软件的功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/niruix/sshwifty&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/niruix/sshwifty&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/niruix/sshwifty/raw/master/Screenshot.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="https://www.hi-linux.com/categories/SSH/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="SSH" scheme="https://www.hi-linux.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>推荐一个比 Postman 更好用的接口测试神器 Postwoman</title>
    <link href="https://www.hi-linux.com/posts/31368.html"/>
    <id>https://www.hi-linux.com/posts/31368.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T03:23:02.449Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>对于经常进行接口调试的同学来说，应该是比较熟悉 <code>Postman</code> 了。<code>Postman</code> 虽然功能强大，但也有很多弊端。比如：不支持 <code>Web</code> 方式，需要安装客户端软件等。如果你只想简单地测试下接口返回，就需要安装一个客户端工具就显得比较麻烦了。</p><p>为了解决这个痛点，今天就给大家推荐一个轻量级、功能强大且颜值超高的神器 <code>Postwoman</code>。<code>Postwoman</code> 是一个 <code>HTTP API</code> 测试工具，支持 <code>REST</code>、<code>SOAP</code> 和 <code>GraphQL</code> 请求，并且可以实现自动化接口测试、接口监控、模拟接口数据、生成接口文档、多人协作等功能。简单来说，<code>Postwoman</code> 是一个好用且功能非常强大的 <code>API</code> 调试工具。</p><h2 id="什么是-postwoman">什么是 Postwoman</h2><p><code>Postwoman</code> 是一个基于 <code>Vue</code> 开发的的 <code>Web</code> 项目，功能类似 <code>Poatman</code> 的免费且美观的开源替代方案，它可以帮助开发人员更快地创建请求，提升工作效率。目前，该项目在 <code>Github</code> 上的 <code>Star</code> 数已经超过 10k 了！</p><blockquote><p>项目地址：<a href="https://github.com/liyasthomas/postwoman" target="_blank" rel="noopener">https://github.com/liyasthomas/postwoman</a></p></blockquote><p><img src="https://raw.githubusercontent.com/liyasthomas/postwoman/master/static/images/screenshot1.png" alt=""></p><h2 id="postwoman-功能介绍">Postwoman 功能介绍</h2><ol><li>Postwoman 相关特性</li></ol><ul><li><p>采用简约的 UI 设计，简单的设计是最好的设计</p></li><li><p>响应速度更快，软件使用更轻量、更简洁</p></li><li><p>实时发送请求并获取/复制响应</p></li></ul><ol start="2"><li>Postwoman 支持的方法</li></ol><ul><li><p>GET</p></li><li><p>HEAD</p></li><li><p>POST</p></li><li><p>PUT</p></li><li><p>DELETE</p></li><li><p>OPTIONS</p></li><li><p>PATCH</p></li></ul><ol start="3"><li>Postwoman 支持界面定制</li></ol><ul><li><p>支持主题选择：Kinda Dark（默认）、Clearly White、Just Black 和 System 主题</p></li><li><p>支持自定义强调颜色：绿色（默认）、黄色、粉红色、红色、紫色、橙色、青色和蓝色</p></li></ul><ol start="4"><li>其它支持的特性</li></ol><ul><li><p>支持以 <code>PWA</code> 方式进行安装</p></li><li><p>支持离线使用</p></li><li><p>内存和 <code>CPU</code> 使用率非常低</p></li><li><p>支持多平台、多设备</p></li><li><p>支持 <code>WebSocket</code></p></li><li><p>支持 <code>GraphQL</code></p></li><li><p>支持多种 <code>HTTP</code> 认证方式</p></li><li><p>…</p></li></ul><p>除此之外，<code>Postwoman</code> 还具备很多好用的特性，完整功能列表介绍可以戳「<a href="https://github.com/liyasthomas/postwoman" target="_blank" rel="noopener">这里</a>」。</p><a id="more"></a><h2 id="使用-postwoman">使用 Postwoman</h2><p><img src="https://github.com/liyasthomas/postwoman/blob/master/static/images/screenshot2.png" alt=""></p><p><code>Postwoman</code> 既然是一个 <code>Web</code> 项目，使用起来也就非常简单，你只需直接访问其官网地址即可直接使用。</p><blockquote><p>官网地址：<a href="https://postwoman.io/" target="_blank" rel="noopener">https://postwoman.io/</a></p></blockquote><p>如果你想在本地自行搭建也是可以的，大致过程如下：</p><ul><li>使用源代码进行搭建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/liyasthomas/postwoman.git</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><ul><li>使用 Docker 进行搭建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取 Postwoman 相关镜像</span></span><br><span class="line">$ docker pull liyasthomas/postwoman</span><br><span class="line"><span class="comment"># 运行一个 Postwoman 的容器</span></span><br><span class="line">$ docker run -p 3000:3000 liyasthomas/postwoman:latest</span><br></pre></td></tr></table></figure><p>不论使用以下哪种方法搭建，搭建成功后，你只需打开浏览器访问对应主机 <code>IP</code> 的 <code>3000</code> 端口即可访问本地的 <code>Postwoman</code> 环境。</p><h2 id="更多的界面截图">更多的界面截图</h2><p><img src="https://i.loli.net/2019/11/29/L9RsVMEhzUdYbPS.png" alt=""></p><p><img src="https://i.loli.net/2019/11/29/DmWaUkgT7uK5rif.png" alt=""></p><p><img src="https://i.loli.net/2019/11/29/z61X8EbiQRDFhAH.png" alt=""></p><p><img src="https://i.loli.net/2019/11/29/mkYbxGTMgesJh1B.png" alt=""></p><h2 id="总结">总结</h2><p>如果你觉得 <code>Postman</code> 不够好用或者确实是想要使用一个界面更加好看的接口调试工具，那么 <code>Postwoman</code> 将是你最佳的选择！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://github.com/liyasthomas/postwoman" target="_blank" rel="noopener">https://github.com/liyasthomas/postwoman</a></p></li><li><p><a href="https://juejin.im/post/5dca85cb6fb9a04a8953fef6" target="_blank" rel="noopener">https://juejin.im/post/5dca85cb6fb9a04a8953fef6</a></p></li><li><p><a href="http://www.xmhzd.com/study/article/view-607.html" target="_blank" rel="noopener">http://www.xmhzd.com/study/article/view-607.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于经常进行接口调试的同学来说，应该是比较熟悉 &lt;code&gt;Postman&lt;/code&gt; 了。&lt;code&gt;Postman&lt;/code&gt; 虽然功能强大，但也有很多弊端。比如：不支持 &lt;code&gt;Web&lt;/code&gt; 方式，需要安装客户端软件等。如果你只想简单地测试下接口返回，就需要安装一个客户端工具就显得比较麻烦了。&lt;/p&gt;
&lt;p&gt;为了解决这个痛点，今天就给大家推荐一个轻量级、功能强大且颜值超高的神器 &lt;code&gt;Postwoman&lt;/code&gt;。&lt;code&gt;Postwoman&lt;/code&gt; 是一个 &lt;code&gt;HTTP API&lt;/code&gt; 测试工具，支持 &lt;code&gt;REST&lt;/code&gt;、&lt;code&gt;SOAP&lt;/code&gt; 和 &lt;code&gt;GraphQL&lt;/code&gt; 请求，并且可以实现自动化接口测试、接口监控、模拟接口数据、生成接口文档、多人协作等功能。简单来说，&lt;code&gt;Postwoman&lt;/code&gt; 是一个好用且功能非常强大的 &lt;code&gt;API&lt;/code&gt; 调试工具。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Postwoman&quot;&gt;什么是 Postwoman&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Postwoman&lt;/code&gt; 是一个基于 &lt;code&gt;Vue&lt;/code&gt; 开发的的 &lt;code&gt;Web&lt;/code&gt; 项目，功能类似 &lt;code&gt;Poatman&lt;/code&gt; 的免费且美观的开源替代方案，它可以帮助开发人员更快地创建请求，提升工作效率。目前，该项目在 &lt;code&gt;Github&lt;/code&gt; 上的 &lt;code&gt;Star&lt;/code&gt; 数已经超过 10k 了！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/liyasthomas/postwoman&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/liyasthomas/postwoman&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liyasthomas/postwoman/master/static/images/screenshot1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Postwoman-功能介绍&quot;&gt;Postwoman 功能介绍&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Postwoman 相关特性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;采用简约的 UI 设计，简单的设计是最好的设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应速度更快，软件使用更轻量、更简洁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实时发送请求并获取/复制响应&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Postwoman 支持的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HEAD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PUT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DELETE&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OPTIONS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PATCH&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Postwoman 支持界面定制&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;支持主题选择：Kinda Dark（默认）、Clearly White、Just Black 和 System 主题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持自定义强调颜色：绿色（默认）、黄色、粉红色、红色、紫色、橙色、青色和蓝色&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;其它支持的特性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;支持以 &lt;code&gt;PWA&lt;/code&gt; 方式进行安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持离线使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存和 &lt;code&gt;CPU&lt;/code&gt; 使用率非常低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持多平台、多设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 &lt;code&gt;WebSocket&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 &lt;code&gt;GraphQL&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持多种 &lt;code&gt;HTTP&lt;/code&gt; 认证方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，&lt;code&gt;Postwoman&lt;/code&gt; 还具备很多好用的特性，完整功能列表介绍可以戳「&lt;a href=&quot;https://github.com/liyasthomas/postwoman&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>巧用 Cowrie 部署 SSH 蜜罐，让黑客攻击无处遁形</title>
    <link href="https://www.hi-linux.com/posts/6021.html"/>
    <id>https://www.hi-linux.com/posts/6021.html</id>
    <published>2020-05-09T01:00:00.000Z</published>
    <updated>2020-05-09T05:08:04.782Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是蜜罐">什么是蜜罐</h2><p>蜜罐其实就是一台无人使用但却被严密监控的网络主机，里面包含着各类虚假的高价值资源和一些已知漏洞，以此吸引入侵者来入侵该主机。并且在被入侵的过程中，实时记录和审计入侵者的所有入侵攻击流量、行为和数据。以此了解入侵者的攻击方式、手段和目的，便于后期快速完成对其的溯源和取证工作。</p><p><strong>蜜罐的一些主要构成模块</strong></p><ol><li>按实现逻辑划分</li></ol><ul><li><p>控制：将入侵者牢牢控制在指定的网络范围中，使其不能再以此机器作为跳板来攻击其它的机器。</p></li><li><p>捕获：把入侵者在入侵过程中所产生的各种流量捕获住。</p></li><li><p>分析：将捕获到的各种数据存到数据库或者其它指定地方，便于后续还原其详细的入侵攻击过程。</p></li></ul><ol start="2"><li>按具体实现过程划分</li></ol><ul><li><p>监控各种主机项，如：进程、文件、注册表、网络等。</p></li><li><p>同时提交给入侵检测，以识别其更详细的入侵手段，并对整个入侵过程做详细记录。</p></li><li><p>入侵数据汇总分析，其实就是把上述两步所得到的各种数据进行集中分析，最后勾勒出完整的入侵轨迹画像。</p></li></ul><ol start="3"><li>最容易理解的说法</li></ol><ul><li><p>蜜罐环境隔离: 使用虚拟环境将物理环境和蜜罐隔绝开，防止某些敏感操作在其真实的系统环境中进行造成破坏。</p></li><li><p>敏感操作记录：把蜜罐中所有的入侵操作都写进数据库。</p></li><li><p>邮件报警系统：蜜罐被入侵后自动发送报警邮件通知相关安全应急人员。</p></li></ul><a id="more"></a><h2 id="蜜罐的分类">蜜罐的分类</h2><p><strong>1. 低交互蜜罐</strong></p><p>低交互蜜罐最大的特点是：蜜罐为攻击者展示的所有攻击弱点和攻击对象都不是真正的产品系统，而是对各种系统及其提供的服务的模拟。由于它的服务都是模拟的行为，所以蜜罐可以获得的信息非常有限，只能对攻击者进行简单的应答。不过，它也是最安全的蜜罐类型。</p><p><strong>2. 中交互蜜罐</strong></p><p>中交互蜜罐是对真正的操作系统的各种行为的模拟，它提供了更多的交互信息，同时也可以从攻击者的行为中获得更多的信息。在这个模拟行为的系统中，蜜罐此时看起来和一个真正的操作系统没有区别，它们甚至是比真正系统还诱人的攻击目标。</p><p><strong>3. 高交互蜜罐</strong></p><p>高交互蜜罐具有一个真实的操作系统，它的优点体现在对攻击者提供完全真实的系统。当攻击者获得 ROOT 权限后，受系统、数据真实性的迷惑，他的更多活动和行为将被记录下来。缺点是被入侵的可能性很高，如果整个高交互蜜罐被入侵，那么它就会成为攻击者下一步攻击的跳板，不太安全。</p><h2 id="什么是-cowrie">什么是 Cowrie</h2><p><code>Cowrie</code> 是一个具有中等交互的 <code>SSH</code> 蜜罐，它可以获取攻击者用于暴力破解的字典、输入的命令以及上传或下载的恶意文件。所有这些攻击记录都会被记载到日志中，以便日后分析。</p><blockquote><p>项目地址：<a href="https://github.com/cowrie/cowrie" target="_blank" rel="noopener">https://github.com/cowrie/cowrie</a></p></blockquote><p><img src="http://image.3001.net/images/20160816/14713421328918.png" alt=""></p><h2 id="cowrie-安装部署">Cowrie 安装部署</h2><h3 id="使用源码部署">使用源码部署</h3><p>本次搭建使用的基础环境是 <code>Ubuntu</code> ，以下步骤除切换到虚拟环境中的操作，其它均为 root 权限执行。</p><h4 id="安装必要的支持软件">安装必要的支持软件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Python 3</span><br><span class="line">$ sudo apt-get install git python-virtualenv libssl-dev libffi-dev build-essential libpython3-dev python3-minimal authbind virtualenv</span><br><span class="line"></span><br><span class="line"># Python 2</span><br><span class="line">$ sudo apt-get install git python-virtualenv libssl-dev libffi-dev build-essential libpython-dev python2.7-minimal authbind</span><br></pre></td></tr></table></figure><h4 id="添加一个普通用户">添加一个普通用户</h4><p>对外提供服务的程序均以普通用户身份运行，能更好的保证服务器安全性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser --disabled-password cowrie</span><br><span class="line">Adding user &#39;cowrie&#39; ...</span><br><span class="line">Adding new group &#39;cowrie&#39; (1002) ...</span><br><span class="line">Adding new user &#39;cowrie&#39; (1002) with group &#39;cowrie&#39; ...</span><br><span class="line">Changing the user information for cowrie</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">Full Name []:</span><br><span class="line">Room Number []:</span><br><span class="line">Work Phone []:</span><br><span class="line">Home Phone []:</span><br><span class="line">Other []:</span><br><span class="line">Is the information correct? [Y&#x2F;n]</span><br><span class="line"></span><br><span class="line">$ sudo su - cowrie</span><br></pre></td></tr></table></figure><h4 id="安装-cowire">安装 Cowire</h4><p>由于 <code>Cowire</code> 是采用 <code>Python</code> 开发，为了方便管理和安全，我们就直接将 <code>Cowire</code> 部署到 <code>Python</code> 的虚拟环境中。</p><ol><li>下载 Cowire</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;cowrie&#x2F;</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;cowrie&#x2F;cowrie.git</span><br></pre></td></tr></table></figure><ol start="2"><li>在 Python 虚拟环境中安装 Cowire</li></ol><ul><li>进入 <code>Cowrie</code> 所在目录，并安装虚拟环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;cowrie&#x2F;cowrie</span><br></pre></td></tr></table></figure><ul><li>使用 Python 3 创建虚拟环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --python&#x3D;python3 cowrie-env</span><br><span class="line">New python executable in .&#x2F;cowrie&#x2F;cowrie-env&#x2F;bin&#x2F;python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure><ul><li>使用 Python 2 创建虚拟环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --python&#x3D;python2 cowrie-env</span><br><span class="line">New python executable in .&#x2F;cowrie&#x2F;cowrie-env&#x2F;bin&#x2F;python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure><ul><li>激活 Cowrie 环境，并安装必要的软件包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ source cowrie-env&#x2F;bin&#x2F;activate</span><br><span class="line">(cowrie-env) $ pip install --upgrade pip</span><br><span class="line">(cowrie-env) $ pip install --upgrade -r requirements.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>创建并修改 Cowire 的配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(cowrie-env) $ cd etc&#x2F;</span><br><span class="line">(cowrie-env) $ cp cowrie.cfg.dist cowrie.cfg</span><br><span class="line">(cowrie-env) $ vi cowrie.cfg</span><br></pre></td></tr></table></figure><ul><li>打开 SSH 服务，并且修改监听端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ssh]</span><br><span class="line"></span><br><span class="line"># Enable SSH support</span><br><span class="line"># (default: true)</span><br><span class="line">enabled &#x3D; true</span><br><span class="line"></span><br><span class="line">listen_endpoints &#x3D; tcp:2222:interface&#x3D;0.0.0.0</span><br></pre></td></tr></table></figure><ul><li>配置日志文件输出</li></ul><p>默认情况下，<code>Cowire</code> 支持将日志输出到多个接收终端中。比如：文件文件、<code>Cucko</code>o、<code>ELK Stack</code>、<code>Graylog</code>、<code>Kippo-Graph</code>、<code>Splunk</code>、<code>SQL</code> (<code>MySQL</code>、<code>SQLite3</code>、<code>RethinkDB</code>) 等等中。这里我们就来说说最常用的文本文件和 <code>MySQL</code> 数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 保存在文本文件中，需要配置以下一些内容。</span><br><span class="line">[output_textlog]</span><br><span class="line">enabled &#x3D; true</span><br><span class="line">logfile &#x3D; $&#123;honeypot:log_path&#125;&#x2F;audit.log</span><br><span class="line">format &#x3D; text</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 保存在数据库中，需要配置以下一些内容。</span><br><span class="line">[output_mysql]</span><br><span class="line">host &#x3D; localhost</span><br><span class="line">database &#x3D; cowrie</span><br><span class="line">username &#x3D; cowrie</span><br><span class="line">password &#x3D; PASSWORD HERE</span><br><span class="line">port &#x3D; 3306</span><br><span class="line">debug &#x3D; false</span><br><span class="line">enabled &#x3D; true</span><br></pre></td></tr></table></figure><p>如果是需要保存在 <code>MySQL</code> 数据库中，当然只配置是不行的，你还得需要有一个对应的数据库。如果你没有，可以按下面的步骤进行安装。</p><ul><li>安装 MySQL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install mysql-server mysql-client libmysqlclient-dev python-mysqldb</span><br></pre></td></tr></table></figure><p>安装成功后，你可以通过下面的命令测试是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure><ul><li>在 Python 虚拟环境中安装 MySQL 依赖包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ source cowrie-env&#x2F;bin&#x2F;activate</span><br><span class="line">$ pip install mysqlclient mysql-python</span><br></pre></td></tr></table></figure><ul><li>创建名为 cowrie 的数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">mysql&gt; create database cowrie;</span><br></pre></td></tr></table></figure><ul><li>创建一个给 Cowrie 访问数据库的用户</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT INSERT, SELECT, UPDATE ON cowrie.* TO &#39;cowrie&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;PASSWORD HERE&#39;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">mysql&gt; exit</span><br></pre></td></tr></table></figure><ul><li>数据库和对应的数据库用户创建完成后，在数据库中导入初始数据的 SQL 语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;cowrie&#x2F;docs&#x2F;sql&#x2F;</span><br><span class="line">$ mysql -u cowrie -p</span><br><span class="line">mysql&gt; USE cowrie;</span><br><span class="line">mysql&gt; source mysql.sql;</span><br><span class="line">mysql&gt; exit</span><br></pre></td></tr></table></figure><ol start="4"><li>在 Python 虚拟环境下启动蜜罐</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(cowrie-env) $ bin&#x2F;cowrie start</span><br><span class="line">Activating virtualenv &quot;cowrie-env&quot;</span><br><span class="line">Starting cowrie with extra arguments [] ...</span><br></pre></td></tr></table></figure><ol start="5"><li>修改 SSH 默认的监听端口</li></ol><p>在 <code>root</code> 用户下将 <code>Ubuntu</code> 自身的 <code>SSH</code> 监听端口进行更改，并修改 <code>Iptables</code> 规则。</p><p>首先，我们验证下是否安装 <code>SSH</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep sshd</span><br><span class="line">root      2720     1  0 Nov 02 ? 00:00:00 &#x2F;usr&#x2F;sbin&#x2F;sshd</span><br></pre></td></tr></table></figure><p>如果输出结果和以上类似就证明已经安装，没有安装的话可以使用以下命令安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>安装完成后，我们可以修改 <code>sshd_config</code> 文件将默认端口改为一个较高的端口，这里为 51268 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"># Port 22</span><br><span class="line">Port 51268</span><br></pre></td></tr></table></figure><blockquote><p>注意：一定不要与 <code>cowrie.cfg</code> 文件中监听的端口一致，否则进入 <code>22</code> 端口的流量就转发到真正的 <code>SSH</code> 服务端口，蜜罐就不起作用了。</p></blockquote><ol start="6"><li>配置 Iptables 进行端口转发</li></ol><p>以上都配置好后，最后就是在 <code>Iptables</code> 中新增一条转发规则，将默认到 <code>22</code> 端口的请求转发到蜜罐中对应的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-port 2222</span><br><span class="line">$ iptables-save</span><br></pre></td></tr></table></figure><p>除了使用 <code>Iptables</code> 外，你还可以在没有 <code>Root</code> 权限的条件下使用 <code>Authbind</code> 或 <code>Setcap</code> 将蜜罐绑定到一些特权端口上，以达到伪装一些正常服务的目的。具体方法可以参见官方文档如下部分：</p><blockquote><ol><li><p><a href="https://cowrie.readthedocs.io/en/latest/INSTALL.html#authbind" target="_blank" rel="noopener">https://cowrie.readthedocs.io/en/latest/INSTALL.html#authbind</a></p></li><li><p><a href="https://cowrie.readthedocs.io/en/latest/INSTALL.html#setcap" target="_blank" rel="noopener">https://cowrie.readthedocs.io/en/latest/INSTALL.html#setcap</a></p></li></ol></blockquote><h3 id="使用-docker-部署">使用 Docker 部署</h3><p>上面讲解的通过源码安装，主要是为了演示 <code>Cowrie</code> 如何工作的，当然最方便的还是直接使用 <code>Docker</code> 部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 2222:2222 cowrie&#x2F;cowrie</span><br><span class="line">$ ssh -p 2222 root@localhost</span><br></pre></td></tr></table></figure><p>如上所示，只需一条指令，<code>Cowrie</code> 就部署完成了。剩下就只需要自己用 <code>Iptables</code> 进行端口转发就可以了。</p><h2 id="cowrie-日志分析">Cowrie 日志分析</h2><p>蜜罐系统的作用主要是用作实时记录和审计入侵者攻击行为和数据，所以最重要的还是事后的日志分析工作。</p><ol><li>如果日志记录在文本文件，你可以使用下面的命令进行一些数据统计分析。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep login &#x2F;home&#x2F;cowrie&#x2F;cowrie&#x2F;var&#x2F;log&#x2F;cowrie&#x2F;audit.log | awk &#39;&#123;print $5&#125;&#39; | sort | uniq -c</span><br></pre></td></tr></table></figure><ol start="2"><li>如果日志记录在数据库，你可以通过下面的一些方式进行一些数据统计分析。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u cowrie -p</span><br><span class="line">mysql&gt; USE cowrie;</span><br><span class="line">mysql&gt; SELECT * FROM auth;</span><br><span class="line">+----+--------------+---------+----------+-------------+---------------------+</span><br><span class="line">| id | session      | success | username | password    | timestamp           |</span><br><span class="line">+----+--------------+---------+----------+-------------+---------------------+</span><br><span class="line">|  1 | a551c0a74e06 |       0 | root     | 12345       | 2019-09-27 23:15:56 |</span><br><span class="line">|  2 | a551c0a74e06 |       0 | root     | seiko2005   | 2019-09-27 23:15:58 |</span><br><span class="line">|  3 | a551c0a74e06 |       0 | root     | anko        | 2019-09-27 23:15:59 |</span><br><span class="line">|  4 | a551c0a74e06 |       0 | root     | 123456      | 2019-09-27 23:16:00 |</span><br><span class="line">|  5 | a551c0a74e06 |       0 | root     | dreambox    | 2019-09-27 23:16:01 |</span><br></pre></td></tr></table></figure><p>当然上面只是举了一些简单的例子，更多高级玩法还等着你去探索哟！</p><h2 id="其它">其它</h2><p>目前开源的蜜罐系统有很多，除了 <code>Cowrie</code> 以外，还有 <code>Kippo</code>、<code>T-Pot</code>、<code>MHN</code>、<code>SSH-Honeypot</code> 等等。如果你对蜜罐系统很感兴趣，可以参考 <code>GitHub</code> 上以下两个开源项目。</p><blockquote><ol><li><p><a href="https://github.com/jwxa2015/honeypotcollection" target="_blank" rel="noopener">https://github.com/jwxa2015/honeypotcollection</a></p></li><li><p><a href="https://github.com/paralax/awesome-honeypots" target="_blank" rel="noopener">https://github.com/paralax/awesome-honeypots</a></p></li></ol></blockquote><p>至此，使用 <code>Cowrie</code> 快速构建一个蜜罐系统的基本方法就介绍完了。如果你对 <code>Cowrie</code> 非常的感兴趣，还可以去官网探索更多高级功能哟！</p><p>对于快速构建一个蜜罐系统，你还有哪些更好用高效的方法呢？欢迎大家在留言讨论哟！</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="https://cowrie.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://cowrie.readthedocs.io/en/latest/</a></p></li><li><p><a href="https://www.cnblogs.com/bmjoker/p/10156220.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/10156220.html</a></p></li><li><p><a href="https://www.cnblogs.com/HacTF/p/8094516.html" target="_blank" rel="noopener">https://www.cnblogs.com/HacTF/p/8094516.html</a></p></li><li><p><a href="https://klionsec.github.io/2017/10/19/cowrie/" target="_blank" rel="noopener">https://klionsec.github.io/2017/10/19/cowrie/</a></p></li><li><p><a href="https://www.twblogs.net/a/5cb0b56bbd9eee48d788646c" target="_blank" rel="noopener">https://www.twblogs.net/a/5cb0b56bbd9eee48d788646c</a></p></li><li><p><a href="https://ama2in9.top/2019/03/12/cowrie/" target="_blank" rel="noopener">https://ama2in9.top/2019/03/12/cowrie/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是蜜罐&quot;&gt;什么是蜜罐&lt;/h2&gt;
&lt;p&gt;蜜罐其实就是一台无人使用但却被严密监控的网络主机，里面包含着各类虚假的高价值资源和一些已知漏洞，以此吸引入侵者来入侵该主机。并且在被入侵的过程中，实时记录和审计入侵者的所有入侵攻击流量、行为和数据。以此了解入侵者的攻击方式、手段和目的，便于后期快速完成对其的溯源和取证工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;蜜罐的一些主要构成模块&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按实现逻辑划分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;控制：将入侵者牢牢控制在指定的网络范围中，使其不能再以此机器作为跳板来攻击其它的机器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;捕获：把入侵者在入侵过程中所产生的各种流量捕获住。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析：将捕获到的各种数据存到数据库或者其它指定地方，便于后续还原其详细的入侵攻击过程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;按具体实现过程划分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;监控各种主机项，如：进程、文件、注册表、网络等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同时提交给入侵检测，以识别其更详细的入侵手段，并对整个入侵过程做详细记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;入侵数据汇总分析，其实就是把上述两步所得到的各种数据进行集中分析，最后勾勒出完整的入侵轨迹画像。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;最容易理解的说法&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;蜜罐环境隔离: 使用虚拟环境将物理环境和蜜罐隔绝开，防止某些敏感操作在其真实的系统环境中进行造成破坏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;敏感操作记录：把蜜罐中所有的入侵操作都写进数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;邮件报警系统：蜜罐被入侵后自动发送报警邮件通知相关安全应急人员。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="https://www.hi-linux.com/categories/SSH/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="SSH" scheme="https://www.hi-linux.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 私有集群负载均衡器终极解决方案 MetalLB ( 贫苦 K8S 用户的 LoadBalancer )</title>
    <link href="https://www.hi-linux.com/posts/34820.html"/>
    <id>https://www.hi-linux.com/posts/34820.html</id>
    <published>2020-05-08T01:00:00.000Z</published>
    <updated>2020-05-08T05:14:23.217Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>私有云裸金属架构（这里是相对云上环境来说，不是说无操作系统）上部署的 Kubernetes 集群，通常是无法使用 LoadBalancer 类型的 Service 的。因为 Kubernetes 本身没有为裸机群集提供网络负载均衡器（类型为 LoadBalancer 的服务）的实现。如果你的 Kubernetes 集群没有在公有云的 IaaS 平台（GCP，AWS，Azure …）上运行，则 LoadBalancers 将在创建时无限期地保持 “挂起” 状态，也就是说只有公有云厂商自家的 Kubernetes 支持 LoadBalancer 。</p><p>为了从外部访问裸机 Kubernetes 群集，目前只能使用 <code>NodePort</code> 或 <code>Ingress</code> 的方法进行服务暴露。前者的缺点是每个暴露的服务需要占用所有节点的某个端口，后者的缺点是仅仅能支持 <code>HTTP</code> 协议。</p><h2 id="什么是-metallb">什么是 MetalLB</h2><p><code>MetalLB</code> 是一个负载均衡器，专门解决裸金属 Kubernetes 集群中无法使用 <code>LoadBalancer</code> 类型服务的痛点。<code>MetalLB</code> 使用标准化的路由协议，以便裸金属 Kubernetes 集群上的外部服务也尽可能地工作。即 MetalLB 能够帮助你在裸金属 Kubernetes 集群中创建 LoadBalancer 类型的 Kubernetes 服务，该项目发布于 2017 年底，当前处于 <code>Beta</code> 阶段。</p><blockquote><p>项目地址：<a href="https://github.com/danderson/metallb" target="_blank" rel="noopener">https://github.com/danderson/metallb</a></p></blockquote><h2 id="metallb-工作原理">MetalLB 工作原理</h2><p>MetalLB 会在 Kubernetes 内运行，监控服务对象的变化，一旦监测到有新的 LoadBalancer 服务运行，并且没有可申请的负载均衡器之后，就会完成地址分配和外部声明两部分的工作。</p><h3 id="地址分配">地址分配</h3><p>在云环境中，当你请求一个负载均衡器时，云平台会自动分配一个负载均衡器的 IP 地址给你，应用程序通过此 IP 来访问经过负载均衡处理的服务。</p><p>使用 MetalLB 时，MetalLB 会自己为用户的 LoadBalancer 类型 Service 分配 IP 地址，当然该 IP 地址不是凭空产生的，需要用户在配置中提供一个 IP 地址池，Metallb 将会在其中选取地址分配给服务。</p><h3 id="外部声明">外部声明</h3><p>MetalLB 将 IP 分配给某个服务后，它需要对外宣告此 IP 地址，并让外部主机可以路由到此 IP。</p><p>MetalLB 支持两种声明模式：Layer 2（ ARP / NDP ）模式或者 BGP 模式。</p><ol><li>Layer 2 模式</li></ol><p><img src="https://kubernetes.github.io/ingress-nginx/images/baremetal/metallb.jpg" alt=""></p><p>在任何以太网环境均可使用该模式。当在第二层工作时，将有一台机器获得 IP 地址（即服务的所有权）。MetalLB 使用标准的地址发现协议（对于 IPv4 是 ARP，对于 IPv6 是 NDP）宣告 IP 地址，使其在本地网路中可达。从 LAN 的角度来看，仅仅是某台机器多配置了一个 IP 地址。</p><p>Layer 2 模式下，每个 Service 会有集群中的一个 Node 来负责。服务的入口流量全部经由单个节点，然后该节点的 Kube-Proxy 会把流量再转发给服务的 Pods。也就是说，该模式下 MetalLB 并没有真正提供负载均衡器。尽管如此，MetalLB 提供了故障转移功能，如果持有 IP 的节点出现故障，则默认 10 秒后即发生故障转移，IP 会被分配给其它健康的节点。</p><p>Layer 2 模式的优缺点：</p><ul><li><p>Layer 2 模式更为通用，不需要用户有额外的设备；</p></li><li><p>Layer 2 模式下存在单点问题，服务的所有入口流量经由单点，其网络带宽可能成为瓶颈；</p></li><li><p>由于 Layer 2 模式需要 ARP/NDP 客户端配合，当故障转移发生时，MetalLB 会发送 ARP 包来宣告 MAC 地址和 IP 映射关系的变化，地址分配略为繁琐。</p></li></ul><ol start="2"><li>BGP 模式</li></ol><p>当在第三层工作时，集群中所有机器都和你控制的最接近的路由器建立 BGP 会话，此会话让路由器能学习到如何转发针对 K8S 服务 IP 的数据包。</p><p>通过使用 BGP，可以实现真正的跨多节点负载均衡（需要路由器支持 multipath），还可以基于 BGP 的策略机制实现细粒度的流量控制。</p><p>具体的负载均衡行为和路由器有关，可保证的共同行为是：每个连接（TCP 或 UDP 会话）的数据包总是路由到同一个节点上。</p><p>BGP 模式的优缺点：</p><ul><li><p>不能优雅处理故障转移，当持有服务的节点宕掉后，所有活动连接的客户端将收到 Connection reset by peer ；</p></li><li><p>BGP 路由器对数据包的源 IP、目的 IP、协议类型进行简单的哈希，并依据哈希值决定发给哪个 K8S 节点。问题是 K8S 节点集是不稳定的，一旦（参与 BGP）的节点宕掉，很大部分的活动连接都会因为 rehash 而坏掉。</p></li></ul><p>BGP 模式问题的缓和措施：</p><ul><li><p>将服务绑定到一部分固定的节点上，降低 rehash 的概率。</p></li><li><p>在流量低的时段改变服务的部署。</p></li><li><p>客户端添加透明重试逻辑，当发现连接 TCP 层错误时自动重试。</p></li></ul><a id="more"></a><h2 id="部署-metallb">部署 MetalLB</h2><h3 id="环境要求">环境要求</h3><p>根据部署模式不同，MetalLB 可能需要以下环境：</p><ol><li><p>一个 Kubernetes 集群，运行 Kubernetes 1.13.0 或更高版本。</p></li><li><p>Kubernetes 集群的网络配置可以与 MetalLB 共存。</p></li><li><p>有一些提供给 MetalLB 分发的 IPv4 地址。</p></li><li><p>根据部署模式，可能需要一个或多个 BGP 的路由器 。</p></li></ol><p>MetalLB 目前支持网络插件范围</p><table><thead><tr><th>网络插件</th><th>兼容性</th></tr></thead><tbody><tr><td>Calico</td><td>部分支持（有附加文档）</td></tr><tr><td>Flannel</td><td>支持</td></tr><tr><td>Kube-router</td><td>不支持</td></tr><tr><td>Romana</td><td>支持（有附加文档）</td></tr><tr><td>Weave Net</td><td>支持</td></tr></tbody></table><blockquote><p>从 Kubernetes 1.9 开始, Kube-Proxy 除了支持默认的 Iptables 模式之外，还支持更高效的 IPVS 模式。MetalLB 可以在Kubenetes 1.13 或更高版本的 Kube-Proxy 中使用 IPVS 模式。但是,它尚未明确测试，因此风险自负。具体内容可参考：<a href="https://github.com/google/metallb/issues/153" target="_blank" rel="noopener">https://github.com/google/metallb/issues/153</a></p></blockquote><h3 id="安装-metallb">安装 MetalLB</h3><p>安装 MetalLB 一共有两种方法：使用 Kubernetes YAML 文件或使用 Helm 包管理器。</p><h4 id="使用-yaml-文件部署">使用 YAML 文件部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 目前 MetalLB 最新版本为 0.8.1</span><br><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;google&#x2F;metallb&#x2F;v0.8.1&#x2F;manifests&#x2F;metallb.yaml</span><br></pre></td></tr></table></figure><p>部署完成后，将在 <code>metallb-system</code> 命名空间下将 MetalLB 部署到集群。YAML 文件中主要包含以下一些组件：</p><ol><li><p><code>metallb-system/controller</code>，这是处理 <code>IP</code> 地址分配的控制器。</p></li><li><p><code>metallb-system/speakerdaemonset</code> 这是支持你选择协议以使服务可达的组件。</p></li><li><p><code>Controller</code> 和 <code>Speaker</code> 的 <code>Service Accounts</code>，以及组件需要运行的 <code>RBAC</code> 权限。</p></li></ol><blockquote><p>通过 YAML 安装文件部署并不包含 MetalLB 配置文件，但 MetalLB 的组件仍能启动，但在你定义和部署 <code>configmap</code> 之前将保持空闲状态 。</p></blockquote><h4 id="使用-helm-部署">使用 Helm 部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm install --name metallb stable&#x2F;metallb</span><br></pre></td></tr></table></figure><p>如果你还不知道什么是 Helm，可以先参考 <a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486154&amp;idx=1&amp;sn=becd5dd0fadfe0b6072f5dfdc6fdf786&amp;chksm=eac52be3ddb2a2f555b8b1028db97aa3e92d0a4880b56f361e4b11cd252771147c44c08c8913&amp;token=1182029777&amp;lang=zh_CN#rd" target="_blank" rel="noopener">「Helm 入门指南」</a> 一文。</p><h2 id="配置-metallb">配置 MetalLB</h2><p>MetalLB 安装完成后，我们还需要根据具体的地址和通告方式配置名为 <code>metallb-system/config</code> 的 ConfigMap。Controller 会读取该 ConfigMap，并重新加载配置。</p><blockquote><p>通过 Helm 安装时，MetalLB 读取的 ConfigMap 名为 metallb-config 。</p></blockquote><h3 id="配置-metallb-为二层模式">配置 MetalLB 为二层模式</h3><p>第二层模式是最简单的配置方式：在许多情况下，您不需要任何特定于协议的配置，只需要 IP 地址。</p><p>第二层模式不要求将 IP 绑定到工作节点的网络接口。它的工作原理是直接响应本地网络上的 ARP 请求，将机器的 MAC 地址提供给客户端。</p><p>下面我们来看一个实际例子，我们将配置一个由 MetalLB 二层模式控制的外部 IP 段为 192.168.1.240 - 192.168.1.250。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat MetalLB-Layer2-Config.yaml</span><br><span class="line"></span><br><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: config</span><br><span class="line">  namespace: metallb-system</span><br><span class="line">data:</span><br><span class="line">  config: |</span><br><span class="line">    address-pools:</span><br><span class="line">    - name: default</span><br><span class="line">      protocol: layer2</span><br><span class="line">      addresses:</span><br><span class="line">      - 192.168.0.10-192.168.0.100</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的 IP 地址范围需要跟集群实际情况相对应。</p></blockquote><p>首先，我们使用 <code>kubectl apply -f MetalLB-Layer2-Config.yaml</code> 命令使配置生效。如果你想看到详细配置更新过程，可以使用以下类似命令查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs -f [metallb-controller-pod]</span><br><span class="line">或者　</span><br><span class="line">$ kubectl logs -l component&#x3D;speaker -n metallb-system</span><br></pre></td></tr></table></figure><p>接下来，我们来创建一个服务类型为 LoadBalancer 的 Nginx 服务来验证下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ cat nginx-test.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps&#x2F;v1beta2</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  type: LoadBalancer</span><br></pre></td></tr></table></figure><p>服务创建完成，运行 <code>kubectl apply -f nginx-test.yaml</code> 命令后，我们可以看到对应服务信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods nginx-68995d8957-bczhf -o wide</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE       </span><br><span class="line">nginx-68995d8957-bczhf   2&#x2F;2     Running   0          19d   10.244.0.78   ubuntu-1  </span><br><span class="line"></span><br><span class="line">$ kubectl get svc</span><br><span class="line">NAME    TYPE           CLUSTER-IP      EXTERNAL-IP    PORT(S)        AGE</span><br><span class="line">nginx   LoadBalancer   10.97.187.100   192.168.0.10   80:32353&#x2F;TCP   179m</span><br></pre></td></tr></table></figure><p>从输出结果，我们可以看到 LoadBalancer 类型的服务，并且分配的外部 IP 地址是地址池中的第一个 IP <code>192.168.0.10</code>。</p><p>最后，我们通过 <code>curl http://192.168.0.10</code> 命令来验证下，发现可以正常显示 Nginx 的欢迎信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;</span><br><span class="line">................</span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>至此，<code>MetalLB Layer 2</code> 模式的配置就结束了。</p><h3 id="配置-metallb-为-bgp-模式">配置 MetalLB 为 BGP 模式</h3><p>对于配置为具有一个 <code>BGP</code> 路由器和一个 IP 地址范围的 BGP 模式，你需要先准备好以下 4 条配置信息：</p><ol><li><p>MetalLB 应连接的路由器 IP 地址。</p></li><li><p>路由器的 AS 号。</p></li><li><p>MetalLB 应该使用的 AS 编号。</p></li><li><p>IP 地址范围，表示为 CIDR 前缀。</p></li></ol><p>由于这种配置方式需要具备 BGP 功能的硬件路由器支持，目前我们环境中不具备此等条件。这里就简单说下 MetalLB 对应的配置方式，具体内容就不展开讲解了。</p><p>由于前面已经安装了 MetalLB 的 <code>Controller</code> 和 <code>Speaker</code>，只是使用的是 Layer 2 模式。这里只需要改为 BGP 模式，我们修改 Configmap 中 Config 配置就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 假如要为 MetalLB 提供范围 192.168.9.0&#x2F;24 和 AS 号 65009，并将其连接到 192.168.0.1 的 AS 号为 65000 的路由器。</span><br><span class="line">$ cat MetalLB-BGP-Config.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  namespace: metallb-system</span><br><span class="line">  name: config</span><br><span class="line">data:</span><br><span class="line">  config: |</span><br><span class="line">    peers:</span><br><span class="line">    - peer-address: 192.168.0.1</span><br><span class="line">      peer-asn: 65000</span><br><span class="line">      my-asn: 65009</span><br><span class="line">    address-pools:</span><br><span class="line">    - name: default</span><br><span class="line">      protocol: bgp</span><br><span class="line">      addresses:</span><br><span class="line">      #- 192.168.0.10-192.168.0.100</span><br><span class="line">      - 192.168.9.0&#x2F;24</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>本文简单介绍了 MetalLB 的用途以及 MetalLB 的两种部署模式：Layer 2 模式和 BGP 模式。在实际应用中，如果条件满足，推荐使用 BGP 模式。</p><h2 id="参考资料">参考资料</h2><ol><li><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a></p></li><li><p><a href="https://blog.fleeto.us/post/intro-metallb/" target="_blank" rel="noopener">https://blog.fleeto.us/post/intro-metallb/</a></p></li><li><p><a href="https://ieevee.com/tech/2019/06/30/metallb.html" target="_blank" rel="noopener">https://ieevee.com/tech/2019/06/30/metallb.html</a></p></li><li><p><a href="https://blog.csdn.net/kunyus/article/details/88616653" target="_blank" rel="noopener">https://blog.csdn.net/kunyus/article/details/88616653</a></p></li><li><p><a href="https://vqiu.cn/metallb-si-you-ji-qun-loadbalancer/amp/" target="_blank" rel="noopener">https://vqiu.cn/metallb-si-you-ji-qun-loadbalancer/amp/</a></p></li><li><p><a href="https://sre.ink/metallb-kubernetes-loadbalancer-no-ipvs/" target="_blank" rel="noopener">https://sre.ink/metallb-kubernetes-loadbalancer-no-ipvs/</a></p></li><li><p><a href="https://blog.csdn.net/networken/article/details/85928369" target="_blank" rel="noopener">https://blog.csdn.net/networken/article/details/85928369</a></p></li><li><p><a href="https://blog.gmem.cc/external-lb-for-on-premise-k8s-cluster" target="_blank" rel="noopener">https://blog.gmem.cc/external-lb-for-on-premise-k8s-cluster</a></p></li><li><p><a href="https://leeif.me/2019/02/k8s-deploy-metallb-LoadBalancer.html" target="_blank" rel="noopener">https://leeif.me/2019/02/k8s-deploy-metallb-LoadBalancer.html</a></p></li><li><p><a href="https://mshk.top/2019/04/kubernetes-metallb-loadbalancer-nginx-ingress-controller/" target="_blank" rel="noopener">https://mshk.top/2019/04/kubernetes-metallb-loadbalancer-nginx-ingress-controller/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;私有云裸金属架构（这里是相对云上环境来说，不是说无操作系统）上部署的 Kubernetes 集群，通常是无法使用 LoadBalancer 类型的 Service 的。因为 Kubernetes 本身没有为裸机群集提供网络负载均衡器（类型为 LoadBalancer 的服务）的实现。如果你的 Kubernetes 集群没有在公有云的 IaaS 平台（GCP，AWS，Azure …）上运行，则 LoadBalancers 将在创建时无限期地保持 “挂起” 状态，也就是说只有公有云厂商自家的 Kubernetes 支持 LoadBalancer 。&lt;/p&gt;
&lt;p&gt;为了从外部访问裸机 Kubernetes 群集，目前只能使用 &lt;code&gt;NodePort&lt;/code&gt; 或 &lt;code&gt;Ingress&lt;/code&gt; 的方法进行服务暴露。前者的缺点是每个暴露的服务需要占用所有节点的某个端口，后者的缺点是仅仅能支持 &lt;code&gt;HTTP&lt;/code&gt; 协议。&lt;/p&gt;
&lt;h2 id=&quot;什么是-MetalLB&quot;&gt;什么是 MetalLB&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MetalLB&lt;/code&gt; 是一个负载均衡器，专门解决裸金属 Kubernetes 集群中无法使用 &lt;code&gt;LoadBalancer&lt;/code&gt; 类型服务的痛点。&lt;code&gt;MetalLB&lt;/code&gt; 使用标准化的路由协议，以便裸金属 Kubernetes 集群上的外部服务也尽可能地工作。即 MetalLB 能够帮助你在裸金属 Kubernetes 集群中创建 LoadBalancer 类型的 Kubernetes 服务，该项目发布于 2017 年底，当前处于 &lt;code&gt;Beta&lt;/code&gt; 阶段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/danderson/metallb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/danderson/metallb&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;MetalLB-工作原理&quot;&gt;MetalLB 工作原理&lt;/h2&gt;
&lt;p&gt;MetalLB 会在 Kubernetes 内运行，监控服务对象的变化，一旦监测到有新的 LoadBalancer 服务运行，并且没有可申请的负载均衡器之后，就会完成地址分配和外部声明两部分的工作。&lt;/p&gt;
&lt;h3 id=&quot;地址分配&quot;&gt;地址分配&lt;/h3&gt;
&lt;p&gt;在云环境中，当你请求一个负载均衡器时，云平台会自动分配一个负载均衡器的 IP 地址给你，应用程序通过此 IP 来访问经过负载均衡处理的服务。&lt;/p&gt;
&lt;p&gt;使用 MetalLB 时，MetalLB 会自己为用户的 LoadBalancer 类型 Service 分配 IP 地址，当然该 IP 地址不是凭空产生的，需要用户在配置中提供一个 IP 地址池，Metallb 将会在其中选取地址分配给服务。&lt;/p&gt;
&lt;h3 id=&quot;外部声明&quot;&gt;外部声明&lt;/h3&gt;
&lt;p&gt;MetalLB 将 IP 分配给某个服务后，它需要对外宣告此 IP 地址，并让外部主机可以路由到此 IP。&lt;/p&gt;
&lt;p&gt;MetalLB 支持两种声明模式：Layer 2（ ARP / NDP ）模式或者 BGP 模式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Layer 2 模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://kubernetes.github.io/ingress-nginx/images/baremetal/metallb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在任何以太网环境均可使用该模式。当在第二层工作时，将有一台机器获得 IP 地址（即服务的所有权）。MetalLB 使用标准的地址发现协议（对于 IPv4 是 ARP，对于 IPv6 是 NDP）宣告 IP 地址，使其在本地网路中可达。从 LAN 的角度来看，仅仅是某台机器多配置了一个 IP 地址。&lt;/p&gt;
&lt;p&gt;Layer 2 模式下，每个 Service 会有集群中的一个 Node 来负责。服务的入口流量全部经由单个节点，然后该节点的 Kube-Proxy 会把流量再转发给服务的 Pods。也就是说，该模式下 MetalLB 并没有真正提供负载均衡器。尽管如此，MetalLB 提供了故障转移功能，如果持有 IP 的节点出现故障，则默认 10 秒后即发生故障转移，IP 会被分配给其它健康的节点。&lt;/p&gt;
&lt;p&gt;Layer 2 模式的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Layer 2 模式更为通用，不需要用户有额外的设备；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Layer 2 模式下存在单点问题，服务的所有入口流量经由单点，其网络带宽可能成为瓶颈；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于 Layer 2 模式需要 ARP/NDP 客户端配合，当故障转移发生时，MetalLB 会发送 ARP 包来宣告 MAC 地址和 IP 映射关系的变化，地址分配略为繁琐。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;BGP 模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当在第三层工作时，集群中所有机器都和你控制的最接近的路由器建立 BGP 会话，此会话让路由器能学习到如何转发针对 K8S 服务 IP 的数据包。&lt;/p&gt;
&lt;p&gt;通过使用 BGP，可以实现真正的跨多节点负载均衡（需要路由器支持 multipath），还可以基于 BGP 的策略机制实现细粒度的流量控制。&lt;/p&gt;
&lt;p&gt;具体的负载均衡行为和路由器有关，可保证的共同行为是：每个连接（TCP 或 UDP 会话）的数据包总是路由到同一个节点上。&lt;/p&gt;
&lt;p&gt;BGP 模式的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不能优雅处理故障转移，当持有服务的节点宕掉后，所有活动连接的客户端将收到 Connection reset by peer ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BGP 路由器对数据包的源 IP、目的 IP、协议类型进行简单的哈希，并依据哈希值决定发给哪个 K8S 节点。问题是 K8S 节点集是不稳定的，一旦（参与 BGP）的节点宕掉，很大部分的活动连接都会因为 rehash 而坏掉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BGP 模式问题的缓和措施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将服务绑定到一部分固定的节点上，降低 rehash 的概率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在流量低的时段改变服务的部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端添加透明重试逻辑，当发现连接 TCP 层错误时自动重试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>再见 Docker，是时候拥抱下一代容器工具了</title>
    <link href="https://www.hi-linux.com/posts/62714.html"/>
    <id>https://www.hi-linux.com/posts/62714.html</id>
    <published>2020-05-08T01:00:00.000Z</published>
    <updated>2020-05-08T07:01:17.891Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-linux-容器">什么是 Linux 容器？</h2><p><code>Linux</code> 容器是由 <code>Linux</code> 内核所提供的具有特定隔离功能的进程，<code>Linux</code> 容器技术能够让你对应用及其整个运行时环境（包括全部所需文件）一起进行打包或隔离。从而让你在不同环境（如开发、测试和生产等环境）之间轻松迁移应用的同时，还可保留应用的全部功能。</p><p><code>Linux</code> 容器还有利于明确划分职责范围，减少开发和运维团队间的冲突。这样，开发人员可以全心投入应用开发，而运维团队则可专注于基础架构维护。由于 <code>Linux</code> 容器基于开源技术构建，还将便于你在未来轻松采用各类更新、更强的技术产品。包括 <code>CRI-O</code>、<code>Kubernetes</code> 和 <code>Docker</code> 在内的容器技术，可帮助你的团队有效简化、加速和编排应用的开发与部署。</p><h2 id="什么是-docker">什么是 Docker？</h2><p><code>Docker</code> 是一个开源的应用容器引擎，属于 <code>Linux</code> 容器的一种封装，<code>Docker</code> 提供简单易用的容器使用接口，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 <code>Linux</code> 机器上。容器是完全使用沙箱机制，相互之间不会有任何接口。</p><p>Docker 是目前最流行的 <code>Linux</code> 容器解决方案，即使 <code>Docker</code> 是目前管理 <code>Linux</code> 容器的一个非常方便的工具，但它也有两个缺点：</p><ol><li><p><code>Docker</code> 需要在你的系统上运行一个守护进程。</p></li><li><p><code>Docker</code> 是以 <code>root</code> 身份在你的系统上运行该守护程序。</p></li></ol><p>这些缺点的存在可能有一定的安全隐患，为了解决这些问题，下一代容器化工具 <code>Podman</code> 出现了 。</p><h2 id="什么是-podman">什么是 Podman ？</h2><p><img src="https://static.oschina.net/uploads/img/201808/31192253_l67X.png" alt=""></p><p><code>Podman</code> 是一个开源的容器运行时项目，可在大多数 <code>Linux</code> 平台上使用。<code>Podman</code> 提供与 <code>Docker</code> 非常相似的功能。正如前面提到的那样，它不需要在你的系统上运行任何守护进程，并且它也可以在没有 <code>root</code> 权限的情况下运行。</p><p><code>Podman</code> 可以管理和运行任何符合 <code>OCI</code>（Open Container Initiative）规范的容器和容器镜像。<code>Podman</code> 提供了一个与 <code>Docker</code> 兼容的命令行前端来管理 <code>Docker</code> 镜像。</p><blockquote><ol><li><p>Podman 官网地址：<a href="https://podman.io/" target="_blank" rel="noopener">https://podman.io/</a></p></li><li><p>Podman 项目地址：<a href="https://github.com/containers/libpod" target="_blank" rel="noopener">https://github.com/containers/libpod</a></p></li></ol></blockquote><a id="more"></a><h2 id="安装-podman">安装 Podman</h2><p><code>Podman</code> 目前已支持大多数发行版本通过软件包来进行安装，下面我们来举几个常用发行版本的例子。</p><ul><li>Fedora / CentOS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install podman</span><br></pre></td></tr></table></figure><ul><li>Ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update -qq</span><br><span class="line">$ sudo apt-get install -qq -y software-properties-common uidmap</span><br><span class="line">$ sudo add-apt-repository -y ppa:projectatomic&#x2F;ppa</span><br><span class="line">$ sudo apt-get update -qq</span><br><span class="line">$ sudo apt-get -qq -y install podman</span><br></pre></td></tr></table></figure><ul><li>MacOS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install podman</span><br></pre></td></tr></table></figure><ul><li>RHEL 7</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo subscription-manager repos --enable&#x3D;rhel-7-server-extras-rpms</span><br><span class="line">$ sudo yum -y install podman</span><br></pre></td></tr></table></figure><ul><li>Arch Linux</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S podman</span><br></pre></td></tr></table></figure><p>更多系统的安装方法，可参考官方文档：<a href="https://github.com/containers/libpod/blob/master/install.md" target="_blank" rel="noopener">https://github.com/containers/libpod/blob/master/install.md</a></p><h2 id="使用-podman">使用 Podman</h2><p>使用 <code>Podman</code> 非常的简单，<code>Podman</code> 的指令跟 <code>Docker</code> 大多数都是相同的。下面我们来看几个常用的例子：</p><h3 id="运行一个容器">运行一个容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ podman run -dt -p 8080:8080&#x2F;tcp  \</span><br><span class="line">-e HTTPD_VAR_RUN&#x3D;&#x2F;var&#x2F;run&#x2F;httpd  \</span><br><span class="line">-e HTTPD_MAIN_CONF_D_PATH&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf.d \</span><br><span class="line">-e HTTPD_MAIN_CONF_PATH&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf \</span><br><span class="line">-e HTTPD_CONTAINER_SCRIPTS_PATH&#x3D;&#x2F;usr&#x2F;share&#x2F;container-scripts&#x2F;httpd&#x2F; \</span><br><span class="line">registry.fedoraproject.org&#x2F;f27&#x2F;httpd &#x2F;usr&#x2F;bin&#x2F;run-httpd</span><br></pre></td></tr></table></figure><h3 id="列出运行的容器">列出运行的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ podman ps -a</span><br></pre></td></tr></table></figure><h3 id="分析一个运行的容器">分析一个运行的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ podman inspect -l | grep IPAddress\&quot;:</span><br><span class="line">&quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">&quot;IPAddress&quot;: &quot;&quot;,</span><br></pre></td></tr></table></figure><h3 id="查看一个运行中容器的日志">查看一个运行中容器的日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman logs --latest</span><br><span class="line">10.88.0.1 - - [07&#x2F;Feb&#x2F;2018:15:22:11 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;curl&#x2F;7.55.1&quot; &quot;-&quot;</span><br><span class="line">10.88.0.1 - - [07&#x2F;Feb&#x2F;2018:15:22:30 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;curl&#x2F;7.55.1&quot; &quot;-&quot;</span><br><span class="line">10.88.0.1 - - [07&#x2F;Feb&#x2F;2018:15:22:30 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;curl&#x2F;7.55.1&quot; &quot;-&quot;</span><br><span class="line">10.88.0.1 - - [07&#x2F;Feb&#x2F;2018:15:22:31 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;curl&#x2F;7.55.1&quot; &quot;-&quot;</span><br><span class="line">10.88.0.1 - - [07&#x2F;Feb&#x2F;2018:15:22:31 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;curl&#x2F;7.55.1&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><h3 id="查看一个运行容器中的进程资源使用情况">查看一个运行容器中的进程资源使用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman top &lt;container_id&gt;</span><br><span class="line">  UID   PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">    0 31873 31863  0 09:21 ?        00:00:00 nginx: master process nginx -g daemon off;</span><br><span class="line">  101 31889 31873  0 09:21 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure><h3 id="停止一个运行中的容器">停止一个运行中的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman stop --latest</span><br></pre></td></tr></table></figure><h3 id="删除一个容器">删除一个容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman rm --latest</span><br></pre></td></tr></table></figure><p>以上这些特性基本上都和 <code>Docker</code> 一样，<code>Podman</code> 除了兼容这些特性外，还支持了一些新的特性。</p><h3 id="给容器设置一个检查点">给容器设置一个检查点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman container checkpoint &lt;container_id&gt;</span><br></pre></td></tr></table></figure><blockquote><p>需要 CRIU 3.11 以上版本支持，CRIU 项目地址：<a href="https://criu.org/" target="_blank" rel="noopener">https://criu.org/</a></p></blockquote><h3 id="根据检查点位置恢复容器">根据检查点位置恢复容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman container restore &lt;container_id&gt;</span><br></pre></td></tr></table></figure><h3 id="迁移容器">迁移容器</h3><p>Podman 支持将容器从一台机器迁移到另一台机器。</p><p>首先，在源机器上对容器设置检查点，并将容器打包到指定位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman container checkpoint &lt;container_id&gt; -e &#x2F;tmp&#x2F;checkpoint.tar.gz</span><br><span class="line">$ scp &#x2F;tmp&#x2F;checkpoint.tar.gz &lt;destination_system&gt;:&#x2F;tmp</span><br></pre></td></tr></table></figure><p>其次，在目标机器上使用源机器上传输过来的打包文件对容器进行恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman container restore -i &#x2F;tmp&#x2F;checkpoint.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置别名">配置别名</h3><p>如果习惯了使用 <code>Docker</code> 命令，可以直接给 <code>Podman</code> 配置一个别名来实现无缝转移。你只需要在 <code>.bashrc</code> 下加入以下行内容即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;alias docker&#x3D;podman&quot; &gt;&gt; .bashrc</span><br><span class="line">$ source .bashrc</span><br></pre></td></tr></table></figure><h3 id="podman-如何实现开机重启容器">Podman 如何实现开机重启容器</h3><p>由于 <code>Podman</code> 不再使用守护进程管理服务，所以不能通过守护进程去实现自动重启容器的功能。那如果要实现开机自动重启容器，又该如何实现呢？</p><p>其实方法很简单，现在大多数系统都已经采用 <code>Systemd</code> 作为守护进程管理工具。这里我们就可以使用 <code>Systemd</code> 来实现 <code>Podman</code> 开机重启容器，这里我们以启动一个 <code>Nginx</code> 容器为例子。</p><p>首先，我们先运行一个 <code>Nginx</code> 容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman run -t -d -p 80:80 --name nginx nginx</span><br></pre></td></tr></table></figure><p>然后，在建立一个 <code>Systemd</code> 服务配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;nginx_container.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Podman Nginx Service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">After&#x3D;network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;podman start -a nginx</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;bin&#x2F;podman stop -t 10 nginx</span><br><span class="line">Restart&#x3D;always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>接下来，启用这个 <code>Systemd</code> 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl enable nginx_container.service</span><br><span class="line">$ sudo systemctl start nginx_container.service</span><br></pre></td></tr></table></figure><p>服务启用成功后，我们可以通过 <code>systemctl status</code> 命令查看到这个服务的运行状况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status nginx_container.service</span><br><span class="line">● nginx_container.service - Podman Nginx Service</span><br><span class="line">   Loaded: loaded (&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;nginx_container.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Sat 2019-08-20 20:59:26 UTC; 1min 41s ago</span><br><span class="line"> Main PID: 845 (podman)</span><br><span class="line">    Tasks: 16 (limit: 4915)</span><br><span class="line">   Memory: 37.6M</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;nginx_container.service</span><br><span class="line">           └─845 &#x2F;usr&#x2F;bin&#x2F;podman start -a nginx</span><br><span class="line"></span><br><span class="line">Aug 20 20:59:26 Ubuntu-dev.novalocal systemd[1]: Started Podman Nginx Service.</span><br></pre></td></tr></table></figure><p>之后每次系统重启后 <code>Systemd</code> 都会自动启动这个服务所对应的容器。</p><h2 id="其它相关工具">其它相关工具</h2><p><code>Podman</code> 只是 <code>OCI</code> 容器生态系统计划中的一部分，主要专注于帮助用户维护和修改符合 <code>OCI</code> 规范容器镜像。其它的组件还有 <code>Buildah</code>、<code>Skopeo</code> 等。</p><h3 id="buildah">Buildah</h3><p><img src="https://camo.githubusercontent.com/843f7639202a27bf5b6abc2afcc405e82804156a/68747470733a2f2f63646e2e7261776769742e636f6d2f636f6e7461696e6572732f6275696c6461682f6d61737465722f6c6f676f732f6275696c6461682d6c6f676f5f6c617267652e706e67" alt=""></p><p>虽然 <code>Podman</code> 也可以支持用户构建 <code>Docker</code> 镜像，但是构建速度比较慢。并且默认情况下使用 <code>VFS</code> 存储驱动程序会消耗大量磁盘空间。</p><p><code>Buildah</code> 是一个专注于构建 <code>OCI</code> 容器镜像的工具，<code>Buildah</code> 构建速度非常快并使用覆盖存储驱动程序，可以节约大量的空间。</p><p><code>Buildah</code> 基于 <code>fork-exec</code> 模型，不以守护进程运行。<code>Buildah</code> 支持 <code>Dockerfile</code> 中的所有命令。你可以直接使用 <code>Dockerfiles</code> 来构建镜像，并且不需要任何 <code>root</code> 权限。 <code>Buildah</code> 也支持用自己的语法文件构建镜像，可以允许将其他脚本语言集成到构建过程中。</p><p>下面是一个使用 <code>Buidah</code> 自有语法构建的例子。</p><p><img src="https://i.loli.net/2019/08/23/coEdGDYeFlMquUT.png" alt=""></p><p><code>Buildah</code> 和 <code>Podman</code> 之间的一个主要区别是：<code>Podman</code> 用于运行和管理容器， 允许我们使用熟悉的容器 <code>CLI</code> 命令在生产环境中管理和维护这些镜像和容器，而 <code>Buildah</code> 主用于构建容器。</p><blockquote><p>项目地址：<a href="https://github.com/containers/buildah" target="_blank" rel="noopener">https://github.com/containers/buildah</a></p></blockquote><h3 id="skopeo">Skopeo</h3><p><img src="https://camo.githubusercontent.com/19ba0305d59474c3cada4b65d5812c8c4c59465c/68747470733a2f2f63646e2e7261776769742e636f6d2f636f6e7461696e6572732f736b6f70656f2f6d61737465722f646f63732f736b6f70656f2e737667" alt=""></p><p><code>Skopeo</code> 是一个镜像管理工具，允许我们通过 <code>Push</code>、<code>Pull</code>和复制镜像来处理 <code>Docker</code> 和符合 <code>OCI</code> 规范的镜像。</p><blockquote><p>项目地址：<a href="https://github.com/containers/skopeo" target="_blank" rel="noopener">https://github.com/containers/skopeo</a></p></blockquote><h2 id="延伸阅读">延伸阅读</h2><h3 id="什么是-oci">什么是 OCI？</h3><p><code>OCI</code> (Open Container Initiative)，是一个轻量级，开放的治理结构（项目）。在 <code>Linux</code> 基金会的支持下成立，致力于围绕容器格式和运行时创建开放的行业标准。</p><p><code>OCI</code> 项目由 <code>Docker</code>、<code>CoreOS</code> 和容器行业中的其它领导者在 2015 年 6 月的时候启动，<code>OCI</code> 的技术委员会成员包括 <code>Red Hat</code>、<code>Microsoft</code>、<code>Docker</code>、<code>Cruise</code>、<code>IBM</code>、<code>Google</code>、<code>Red Hat</code> 和 <code>SUSE</code> 等。</p><h3 id="什么是-cri">什么是 CRI？</h3><p><code>CRI</code>（Container Runtime Interface）是 <code>Kubernetes</code> v1.5 引入的容器运行时接口，它将 <code>Kubelet</code> 与容器运行时解耦，将原来完全面向 <code>Pod</code> 级别的内部接口拆分成面向 <code>Sandbox</code> 和 <code>Container</code> 的 <code>gRPC</code> 接口，并将镜像管理和容器管理分离到不同的服务。</p><p><img src="https://i.loli.net/2019/08/23/L8lM1KENGdxqmgn.png" alt=""></p><h3 id="什么是-cni">什么是 CNI？</h3><p><code>CNI</code>（Container Network Interface）是 <code>CNCF</code> 旗下的一个项目，是 <code>Google</code> 和 <code>CoreOS</code> 主导制定的容器网络标准。<code>CNI</code> 包含方法规范、参数规范等，是 <code>Linux</code> 容器网络配置的一组标准和库，用户可以根据这些标准和库来开发自己的容器网络插件。<code>CNI</code> 已经被 <code>Kubernetes</code>、<code>Mesos</code>、<code>Cloud Foundry</code>、<code>RKT</code> 等使用，同时 <code>Calico</code>、<code>Weave</code> 等项目都在为 CNI 提供插件。</p><p><img src="https://www.hi-linux.com/img/linux/cni.png" alt=""></p><h2 id="总结">总结</h2><p>本文介绍三个了符合 <code>CRI</code> 标准的容器工具 <code>Podman</code>、 <code>Buildah</code> 和 <code>Skopeo</code>。这三个工具都是基于 <code>*nix</code> 传统的 <code>fork-exec</code> 模型，解决了由于 <code>Docker</code> 守护程序导致的启动和安全问题，提高了容器的性能和安全。</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://igene.tw/podman-intro" target="_blank" rel="noopener">https://igene.tw/podman-intro</a></li><li><a href="https://zhuanlan.zhihu.com/p/77373246" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77373246</a></li><li><a href="https://zhuanlan.zhihu.com/p/47706426" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47706426</a></li><li><a href="https://xuanwo.io/2019/08/06/oci-intro/" target="_blank" rel="noopener">https://xuanwo.io/2019/08/06/oci-intro/</a></li><li><a href="https://www.jianshu.com/p/62e71584d1cb" target="_blank" rel="noopener">https://www.jianshu.com/p/62e71584d1cb</a></li><li><a href="https://kubernetes.feisky.xyz/cha-jian-kuo-zhan/cri" target="_blank" rel="noopener">https://kubernetes.feisky.xyz/cha-jian-kuo-zhan/cri</a></li><li><a href="https://blog.csdn.net/networken/article/details/98684527" target="_blank" rel="noopener">https://blog.csdn.net/networken/article/details/98684527</a></li><li><a href="https://www.zcfy.cc/article/demystifying-the-open-container-initiative-oci-specifications" target="_blank" rel="noopener">https://www.zcfy.cc/article/demystifying-the-open-container-initiative-oci-specifications</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Linux-容器？&quot;&gt;什么是 Linux 容器？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 容器是由 &lt;code&gt;Linux&lt;/code&gt; 内核所提供的具有特定隔离功能的进程，&lt;code&gt;Linux&lt;/code&gt; 容器技术能够让你对应用及其整个运行时环境（包括全部所需文件）一起进行打包或隔离。从而让你在不同环境（如开发、测试和生产等环境）之间轻松迁移应用的同时，还可保留应用的全部功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 容器还有利于明确划分职责范围，减少开发和运维团队间的冲突。这样，开发人员可以全心投入应用开发，而运维团队则可专注于基础架构维护。由于 &lt;code&gt;Linux&lt;/code&gt; 容器基于开源技术构建，还将便于你在未来轻松采用各类更新、更强的技术产品。包括 &lt;code&gt;CRI-O&lt;/code&gt;、&lt;code&gt;Kubernetes&lt;/code&gt; 和 &lt;code&gt;Docker&lt;/code&gt; 在内的容器技术，可帮助你的团队有效简化、加速和编排应用的开发与部署。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Docker？&quot;&gt;什么是 Docker？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 是一个开源的应用容器引擎，属于 &lt;code&gt;Linux&lt;/code&gt; 容器的一种封装，&lt;code&gt;Docker&lt;/code&gt; 提供简单易用的容器使用接口，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 &lt;code&gt;Linux&lt;/code&gt; 机器上。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;
&lt;p&gt;Docker 是目前最流行的 &lt;code&gt;Linux&lt;/code&gt; 容器解决方案，即使 &lt;code&gt;Docker&lt;/code&gt; 是目前管理 &lt;code&gt;Linux&lt;/code&gt; 容器的一个非常方便的工具，但它也有两个缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 需要在你的系统上运行一个守护进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 是以 &lt;code&gt;root&lt;/code&gt; 身份在你的系统上运行该守护程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些缺点的存在可能有一定的安全隐患，为了解决这些问题，下一代容器化工具 &lt;code&gt;Podman&lt;/code&gt; 出现了 。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Podman-？&quot;&gt;什么是 Podman ？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201808/31192253_l67X.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Podman&lt;/code&gt; 是一个开源的容器运行时项目，可在大多数 &lt;code&gt;Linux&lt;/code&gt; 平台上使用。&lt;code&gt;Podman&lt;/code&gt; 提供与 &lt;code&gt;Docker&lt;/code&gt; 非常相似的功能。正如前面提到的那样，它不需要在你的系统上运行任何守护进程，并且它也可以在没有 &lt;code&gt;root&lt;/code&gt; 权限的情况下运行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Podman&lt;/code&gt; 可以管理和运行任何符合 &lt;code&gt;OCI&lt;/code&gt;（Open Container Initiative）规范的容器和容器镜像。&lt;code&gt;Podman&lt;/code&gt; 提供了一个与 &lt;code&gt;Docker&lt;/code&gt; 兼容的命令行前端来管理 &lt;code&gt;Docker&lt;/code&gt; 镜像。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Podman 官网地址：&lt;a href=&quot;https://podman.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://podman.io/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Podman 项目地址：&lt;a href=&quot;https://github.com/containers/libpod&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/containers/libpod&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>再见 NTP，是时候拥抱下一代时间同步服务 Chrony 了</title>
    <link href="https://www.hi-linux.com/posts/44857.html"/>
    <id>https://www.hi-linux.com/posts/44857.html</id>
    <published>2020-05-08T01:00:00.000Z</published>
    <updated>2020-05-08T06:31:03.045Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Chrony</code> 是一个多功能的 <code>NTP (Network Time Protocol)</code> 实现，类 <code>Unix</code> 系统上 <code>NTP</code> 客户端和服务器的替代品。它可以通过 <code>NTP</code> 服务或者类似 <code>GPS</code> 时钟接收器的硬件级参考时钟来同步系统时钟，具有更好的时钟准确度，并且对于那些间歇性互联网连接的系统很有帮助。<code>Chrony</code> 是免费开源的，并且支持 <code>GNU/Linux</code> 和 <code>BSD</code> 衍生版（比如：<code>FreeBSD</code>、<code>NetBSD</code>）、<code>macOS</code> 和 <code>Solaris</code> 等。</p><p><code>Chrony</code> 有两个核心组件：一个是 <code>chronyd</code> 守护进程，主要用于调整内核中运行的系统时间和时间服务器同步。它确定计算机增减时间的比率，并对此进行调整补偿。另一个是 <code>chronyc</code>，它提供一个用户界面，用于监控性能并进行多样化的配置。<code>chronyc</code> 可以在 <code>chronyd</code> 实例控制的计算机上工作，也可以在一台不同的远程计算机上工作。</p><p><strong>Chrony 和 NTPD 精度对比测试</strong></p><p>我们可以从 <code>Chrony</code> 的官方网站上可以看到与 <code>NTPD</code> 各维度详细对比：</p><p><img src="https://www.hi-linux.com/img/linux/chrony-1.png" alt=""></p><p>从其测试结果上看似乎是各维度性能都可以吊打 <code>NTPD</code>。因此 <code>Chrony</code> 对自身的整体评价还是比较高的。</p><p><strong>Chrony 相较于 NTPD 服务的优势</strong></p><ol><li><p>更快的同步只需要数分钟而非数小时时间，从而最大程度的减少时间和频率误差，这对于并非全天运行的台式计算机或系统而言非常有用。</p></li><li><p>能够更好的响应时间频率的快速变化，这对于具备不稳定时钟的虚拟机或导致时钟频率反复变化的节能技术而言非常有用。</p></li><li><p>在初始同步后，它并不会停止时钟，以防对需要系统时间保持单调的程序造成影响。</p></li><li><p>在应对临时非对称延迟时，（例如：大规模下载造成连接饱和时）提供了更好的稳定性。</p></li><li><p>无需对服务器进行定期轮询，因此具备间歇性网络连接的系统仍然可以快速同步时钟。</p></li></ol><a id="more"></a><h2 id="安装-chrony">安装 Chrony</h2><p>从 <code>Centos 7.x</code> 开始的最小发行版中都已经预装并开启了 <code>Chrony</code>。如果你的系统上没有安装 <code>Chrony</code>，你也可以使用下面的命令轻松安装它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install chrony    <span class="comment"># [On CentOS/RHEL]</span></span><br><span class="line">$ apt install chrony       <span class="comment"># [On Debian/Ubuntu]</span></span><br><span class="line">$ dnf -y install chrony    <span class="comment"># [On Fedora 22+]</span></span><br></pre></td></tr></table></figure><p>安装完成后，你可以使用以下命令来检查 <code>chronyd</code> 的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status chronyd     <span class="comment"># [On SystemD]</span></span><br><span class="line">$ /etc/init.d/chronyd status   <span class="comment"># [On Init]</span></span><br></pre></td></tr></table></figure><p>如果要在开机引导时自动启用 <code>Chrony</code> 的守护程序，你可以使用以下命令来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> chrony       <span class="comment"># [On SystemD]</span></span><br><span class="line">$ chkconfig --add chronyd       <span class="comment"># [On Init]</span></span><br></pre></td></tr></table></figure><h2 id="配置-chrony">配置 Chrony</h2><p><code>Chrony</code> 的默认配置文件为 <code>/etc/chrony.conf</code>，下面将介绍一些常用的配置项。</p><ol><li>server hostname [option]</li></ol><p><code>server</code> 指令用于指定要同步的 <code>NTP</code> 服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server 0.centos.pool.ntp.org iburst</span><br></pre></td></tr></table></figure><p>其中的 <code>0.centos.pool.ntp.org</code> 是 <code>NTP</code> 服务器的地址，默认有四组官方的 <code>NTP</code> 服务器。你也可以修改为自定义的时间服务器，例如：<code>ntp1.aliyun.com</code>。</p><p><code>iburst</code> 是参数, 一般用此参数即可。该参数的含义是在头四次 <code>NTP</code> 请求以 <code>2s</code> 或者更短的间隔，而不是以 <code>minpoll x</code> 指定的最小间隔，这样的设置可以让 <code>chronyd</code> 启动时快速进行一次同步。</p><p>其他的参数有 <code>minpoll x</code> 默认值是 6，代表 <code>64s</code>。<code>maxpoll x</code> 默认值是 9，代表 <code>512s</code>。</p><ol start="2"><li>driftfile file</li></ol><p><code>Chrony</code> 会根据实际时间计算修正值，并将补偿参数记录在该指令指定的文件里，默认为 <code>driftfile /var/lib/chrony/drift</code>。</p><p>与 <code>ntpd</code> 或者 <code>ntpdate</code> 最大的区别就是，<code>Chrony</code> 的修正是连续的，通过减慢时钟或者加快时钟的方式连续的修正。而 <code>ntpd</code> 或者 <code>ntpdate</code> 搭配 <code>Crontab</code> 的校时工具是直接调整时间，会出现间断，并且相同时间可能会出现两次。因此，请放弃使用 <code>ntpd</code>、<code>ntpdate</code> 来校时。</p><ol start="3"><li>makestep threshold limit</li></ol><p>此指令使 <code>Chrony</code> 根据需要通过加速或减慢时钟来逐渐校正任何时间偏移。例如：<code>makestep 1.0 3</code>，就表示当头三次校时，如果时间相差 <code>1.0s</code>, 则跳跃式校时。</p><ol start="4"><li>rtcsync</li></ol><p>启用内核时间与 <code>RTC</code> 时间同步 (自动写回硬件)。</p><ol start="5"><li>logdir</li></ol><p>该参数用于指定 <code>Chrony</code> 日志文件的路径。</p><ol start="6"><li>stratumweight</li></ol><p>该参数用于设置当 <code>chronyd</code> 从可用源中选择同步源时，每个层应该添加多少距离到同步距离。默认情况下设置为 0，让 <code>chronyd</code> 在选择源时忽略源的层级。</p><p>基本上常用的参数就只有这几个了，通常默认的配置文件就可以直接使用了，下面我们来看一个修改完成后的配置文件内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里只修改了 server 中的 NTP 服务器地址，如果网络环境良好可以使用默认配置</span></span><br><span class="line">server ntp1.aliyun.com iburst</span><br><span class="line">server ntp2.aliyun.com iburst</span><br><span class="line"></span><br><span class="line">driftfile /var/lib/chrony/drift</span><br><span class="line">makestep 1.0 3</span><br><span class="line">rtcsync</span><br><span class="line">logdir /var/<span class="built_in">log</span>/chrony</span><br></pre></td></tr></table></figure><h2 id="使用-chrony-客户端程序进行管理">使用 Chrony 客户端程序进行管理</h2><ol><li>检查 Chrony 是否实际同步</li></ol><p>为了检查 <code>Chrony</code> 是否实际同步，我们将使用它的命令行程序 <code>chronyc</code> 来验证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc tracking </span><br><span class="line"></span><br><span class="line">Reference ID    : 78197314 (120.25.115.20)</span><br><span class="line">Stratum         : 3</span><br><span class="line">Ref time (UTC)  : Fri Jun 28 13:58:17 2019</span><br><span class="line">System time     : 0.000042858 seconds slow of NTP time</span><br><span class="line">Last offset     : -0.000187823 seconds</span><br><span class="line">RMS offset      : 0.001029734 seconds</span><br><span class="line">Frequency       : 17.614 ppm slow</span><br><span class="line">Residual freq   : +0.008 ppm</span><br><span class="line">Skew            : 5.552 ppm</span><br><span class="line">Root delay      : 0.034440458 seconds</span><br><span class="line">Root dispersion : 0.002149768 seconds</span><br><span class="line">Update interval : 64.1 seconds</span><br><span class="line">Leap status     : Normal</span><br></pre></td></tr></table></figure><p>这里主要关注 <code>Update interval</code> 这个参数, 说明最后两次更新的时间间隔是 <code>64.1s</code>。以上结果中的其它参数的含义分别是：</p><ul><li><p>引用 <code>ID</code> - 计算机当前同步的引用 <code>ID</code> 和名称。</p></li><li><p><code>Stratum</code> - 连接参考时钟的计算机的跳数。</p></li><li><p>参考时间 - 这是参考源的最后一次测量的 <code>UTC</code> 时间。</p></li><li><p>系统时间 - 来自同步服务器的系统时钟延迟。</p></li><li><p>最后一次偏移 - 上次时钟更新的估计偏移量。</p></li><li><p><code>RMS</code> 偏移 - 偏移值的长期平均值。</p></li><li><p>频率 - 如果 <code>chronyd</code> 没有纠正它，那么系统的时钟错误的速率。它以 <code>ppm</code> （百万分率）提供。</p></li><li><p>残余频率 - 残余频率表示参考源的测量值与当前使用的频率之间的差异。</p></li><li><p>偏斜 - 估计频率的误差界限。</p></li><li><p>根延迟 - 网络路径延迟到计算机正在同步的层计算机的总和。</p></li><li><p>跳跃状态 - 这是跳跃状态，可以具有以下值之一：正常、插入秒、删除秒或不同步。</p></li></ul><ol start="2"><li>显示所有 NTP 源服务器的信息</li></ol><p>这里需要注意的是第二个参数，<code>*</code> 代表当前同步的源，<code>-</code> 代表通过组合算法计算后排除的源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc sources -v</span><br><span class="line"></span><br><span class="line">210 Number of sources = 2</span><br><span class="line"></span><br><span class="line">  .-- Source mode  <span class="string">'^'</span> = server, <span class="string">'='</span> = peer, <span class="string">'#'</span> = <span class="built_in">local</span> clock.</span><br><span class="line"> / .- Source state <span class="string">'*'</span> = current synced, <span class="string">'+'</span> = combined , <span class="string">'-'</span> = not combined,</span><br><span class="line">| /   <span class="string">'?'</span> = unreachable, <span class="string">'x'</span> = time may be <span class="keyword">in</span> error, <span class="string">'~'</span> = time too variable.</span><br><span class="line">||                                                 .- xxxx [ yyyy ] +/- zzzz</span><br><span class="line">||      Reachability register (octal) -.           |  xxxx = adjusted offset,</span><br><span class="line">||      Log2(Polling interval) --.      |          |  yyyy = measured offset,</span><br><span class="line">||                                \     |          |  zzzz = estimated error.</span><br><span class="line">||                                 |    |           \</span><br><span class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample</span><br><span class="line">===============================================================================</span><br><span class="line">^* 120.25.115.20                 2   6    37    12    +85us[ -960us] +/-   20ms</span><br><span class="line">^- 203.107.6.88                  2   6    37    12   +262us[ +262us] +/-   21ms</span><br></pre></td></tr></table></figure><ol start="3"><li>查看 NTP 服务器的在线和离线状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc activity</span><br></pre></td></tr></table></figure><ol start="4"><li>查看 Chrony 服务的日志</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl -u chronyd</span><br></pre></td></tr></table></figure><ol start="5"><li>检查 NTP 访问是否对特定主机可用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc accheck</span><br></pre></td></tr></table></figure><ol start="6"><li>该命令会显示有多少 NTP 源在线/离线</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc activity</span><br></pre></td></tr></table></figure><ol start="7"><li>手动添加一台新的 NTP 服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc add server</span><br></pre></td></tr></table></figure><ol start="8"><li>在客户端报告已访问到服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc clients</span><br></pre></td></tr></table></figure><ol start="9"><li>手动移除 NTP 服务器或对等服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc delete</span><br></pre></td></tr></table></figure><ol start="10"><li>手动设置守护进程时间</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc settime</span><br></pre></td></tr></table></figure><ol start="11"><li>校准时间服务器，显示系统时间信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc tracking</span><br></pre></td></tr></table></figure><ol start="12"><li>检查 NTP 访问是否对特定主机可用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc accheck</span><br></pre></td></tr></table></figure><ol start="13"><li>查看时间同步源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc sources -v</span><br></pre></td></tr></table></figure><ol start="14"><li>查看时间同步源状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chronyc sourcestats -v</span><br></pre></td></tr></table></figure><p><code>Chrony</code> 客户端程序的功能非常强大，远不止上面介绍这些。不但支持命令行模式，而且还支持交互模式。如果你想了解更多 <code>Chrony</code> 客户端程序的使用方法，可以使用 <code>man  chronyc</code> 命令获取更多帮助。</p><h2 id="使用-chrony-作为-ntp-服务器">使用 Chrony 作为 NTP 服务器</h2><p>要将 <code>Chrony</code> 作为一个 <code>NTP</code> 服务器，方法很简单。</p><p>首先，你需要修改 <code>/etc/chrony.conf</code> 文件，并添加以下配置即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于安全要求比较高的，这里可以限制谁能访问本机提供的 NTP 服务。</span></span><br><span class="line">allow 192.168.1.0/24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 chronyd 监听在哪个网络接口</span></span><br><span class="line">bindcmdaddress 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个地方很重要，如果服务器本身也不能同步时间，那么就用本地时间替代，层级为 10</span></span><br><span class="line"><span class="built_in">local</span> stratum 10</span><br></pre></td></tr></table></figure><p>其次，重启 <code>Chronyd</code> 服务，以加载新的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart chronyd</span><br></pre></td></tr></table></figure><p><code>Chronyd</code> 服务启动成功后，会监听以下两个端口。</p><ul><li><p>端口 <code>123/udp</code> 为标准的 <code>NTP</code> 监听端口，如果要对外提供 <code>NTP Server</code> 功能，必须开启防火墙和监听地址为外部可访问地址。如需修改，你可以通过配置 <code>port</code> 参数来修改。</p></li><li><p>端口 <code>323/udp</code> 为默认的管理端口。如需修改，你可以通过配置 <code>cmdport</code> 参数来修改。</p></li></ul><p>最后，修改防火墙设置，以放行对 <code>123/udp</code> 的请求，这里以 <code>CentOS 7</code> 的 <code>Firewalld</code> 为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --zone=public --add-port=123/udp --permanent</span><br><span class="line">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="延伸阅读">延伸阅读</h2><h3 id="一些可用的公共-ntp-服务">一些可用的公共 NTP 服务</h3><p>公共 <code>NTP</code> 服务网上很多，但国内环境下最好用的应该还属阿里云的公网 <code>NTP</code> 服务。</p><p><img src="https://i.loli.net/2019/10/31/TKhznvkqWb3ydxr.png" alt=""></p><h3 id="一些时间相关的概念介绍">一些时间相关的概念介绍</h3><ol><li>GMT、UTC、CST、DST 时间</li></ol><ul><li><p><code>UTC</code> 整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时 (<code>UTC, Universal Time Coordinated</code>)。</p></li><li><p><code>GMT</code> 格林威治标准时间 (<code>Greenwich Mean Time</code>) 指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。( <code>UTC</code> 与 <code>GMT</code> 时间基本相同)</p></li><li><p><code>CST</code> 中国标准时间 (<code>China Standard Time</code>)</p></li><li><p><code>GMT</code> + 8 = <code>UTC</code> + 8 = <code>CST</code></p></li><li><p><code>DST</code> 夏令时 (<code>Daylight Saving Time</code>) 指在夏天太阳升起的比较早时，将时间拨快一小时，以提早日光的使用。（中国不使用）</p></li></ul><ol start="2"><li>硬件时间和系统时间</li></ol><ul><li><p>硬件时间：<code>RTC (Real-Time Clock)</code> 或 <code>CMOS</code> 时间，一般在主板上靠电池供电，服务器断电后也会继续运行。仅保存日期时间数值，无法保存时区和夏令时设置。</p></li><li><p>系统时间：一般在服务器启动时复制 <code>RTC</code> 时间，之后独立运行，保存了时间、时区和夏令时设置。</p></li></ul><h3 id="一些设置时区和时间的命令">一些设置时区和时间的命令​</h3><ol><li>查看当前系统时区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用 timedatectl 命令也等同于以下命令</span></span><br><span class="line">$ timedatectl status</span><br><span class="line">      Local time: Fri 2018-2-29 13:31:04 CST</span><br><span class="line">  Universal time: Fri 2018-2-29 05:31:04 UTC</span><br><span class="line">        RTC time: Fri 2018-2-29 08:17:20</span><br><span class="line">       Time zone: Asia/Shanghai (CST, +0800)</span><br><span class="line">     NTP enabled: yes</span><br><span class="line">NTP synchronized: yes</span><br><span class="line"> RTC <span class="keyword">in</span> <span class="built_in">local</span> TZ: no</span><br><span class="line">      DST active: n/a</span><br></pre></td></tr></table></figure><ol start="2"><li>设置当前系统时区</li></ol><p>如果你当前的时区不正确，请按照以下操作设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有可用的时区</span></span><br><span class="line">$ timedatectl list-timezones</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上海可用时区</span></span><br><span class="line">$ timedatectl list-timezones |  grep  -E <span class="string">"Asia/S.*"</span></span><br><span class="line">Asia/Sakhalin</span><br><span class="line">Asia/Samarkand</span><br><span class="line">Asia/Seoul</span><br><span class="line">Asia/Shanghai</span><br><span class="line">Asia/Singapore</span><br><span class="line">Asia/Srednekolymsk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前系统为 Asia/Shanghai 上海时区</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置完时区后，在强制同步下系统时钟</span></span><br><span class="line">$ chronyc -a makestep</span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure><ol start="3"><li>显示系统的当前时间和日期</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl <span class="built_in">set</span>-time <span class="string">"YYYY-MM-DD HH:MM:SS"</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-time <span class="string">"YYYY-MM-DD"</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-time <span class="string">"HH:MM:SS"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>修改当前日期时间</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以只修改其中一个</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-time <span class="string">"2019-10-31 15:50:00"</span></span><br></pre></td></tr></table></figure><ol start="5"><li>设置硬件时间</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 硬件时间默认为 UTC，下面两条命令效果等同</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-local-rtc 1</span><br><span class="line">$ hwclock --systohc --localtime</span><br></pre></td></tr></table></figure><ol start="6"><li>启用或者禁止 NTP 时间同步</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yes 或 no，1 或 0 也可以</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-ntp yes/no</span><br><span class="line">$ timedatectl <span class="built_in">set</span>-ntp <span class="literal">true</span>/flase</span><br></pre></td></tr></table></figure><h2 id="参考文档">参考文档</h2><ol><li><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a></p></li><li><p><a href="https://url.cn/5RYX5Ob" target="_blank" rel="noopener">https://url.cn/5RYX5Ob</a></p></li><li><p><a href="https://chegva.com/3265.html" target="_blank" rel="noopener">https://chegva.com/3265.html</a></p></li><li><p><a href="https://blog.gnuers.org/?p=1483" target="_blank" rel="noopener">https://blog.gnuers.org/?p=1483</a></p></li><li><p><a href="https://yq.aliyun.com/articles/503151" target="_blank" rel="noopener">https://yq.aliyun.com/articles/503151</a></p></li><li><p><a href="http://tswblog.com/article/linux/chrony/" target="_blank" rel="noopener">http://tswblog.com/article/linux/chrony/</a></p></li><li><p><a href="https://www.cnblogs.com/cloudos/p/NTP.html" target="_blank" rel="noopener">https://www.cnblogs.com/cloudos/p/NTP.html</a></p></li><li><p><a href="https://www.itsfun.tk/better-ntp-server-chrony/" target="_blank" rel="noopener">https://www.itsfun.tk/better-ntp-server-chrony/</a></p></li><li><p><a href="https://www.mnstory.net/2018/12/09/chrony-ntp-date-sync/" target="_blank" rel="noopener">https://www.mnstory.net/2018/12/09/chrony-ntp-date-sync/</a></p></li><li><p><a href="https://www.howtoing.com/install-chrony-in-centos-ubuntu-linux" target="_blank" rel="noopener">https://www.howtoing.com/install-chrony-in-centos-ubuntu-linux</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Chrony&lt;/code&gt; 是一个多功能的 &lt;code&gt;NTP (Network Time Protocol)&lt;/code&gt; 实现，类 &lt;code&gt;Unix&lt;/code&gt; 系统上 &lt;code&gt;NTP&lt;/code&gt; 客户端和服务器的替代品。它可以通过 &lt;code&gt;NTP&lt;/code&gt; 服务或者类似 &lt;code&gt;GPS&lt;/code&gt; 时钟接收器的硬件级参考时钟来同步系统时钟，具有更好的时钟准确度，并且对于那些间歇性互联网连接的系统很有帮助。&lt;code&gt;Chrony&lt;/code&gt; 是免费开源的，并且支持 &lt;code&gt;GNU/Linux&lt;/code&gt; 和 &lt;code&gt;BSD&lt;/code&gt; 衍生版（比如：&lt;code&gt;FreeBSD&lt;/code&gt;、&lt;code&gt;NetBSD&lt;/code&gt;）、&lt;code&gt;macOS&lt;/code&gt; 和 &lt;code&gt;Solaris&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Chrony&lt;/code&gt; 有两个核心组件：一个是 &lt;code&gt;chronyd&lt;/code&gt; 守护进程，主要用于调整内核中运行的系统时间和时间服务器同步。它确定计算机增减时间的比率，并对此进行调整补偿。另一个是 &lt;code&gt;chronyc&lt;/code&gt;，它提供一个用户界面，用于监控性能并进行多样化的配置。&lt;code&gt;chronyc&lt;/code&gt; 可以在 &lt;code&gt;chronyd&lt;/code&gt; 实例控制的计算机上工作，也可以在一台不同的远程计算机上工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chrony 和 NTPD 精度对比测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以从 &lt;code&gt;Chrony&lt;/code&gt; 的官方网站上可以看到与 &lt;code&gt;NTPD&lt;/code&gt; 各维度详细对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/chrony-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从其测试结果上看似乎是各维度性能都可以吊打 &lt;code&gt;NTPD&lt;/code&gt;。因此 &lt;code&gt;Chrony&lt;/code&gt; 对自身的整体评价还是比较高的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chrony 相较于 NTPD 服务的优势&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更快的同步只需要数分钟而非数小时时间，从而最大程度的减少时间和频率误差，这对于并非全天运行的台式计算机或系统而言非常有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能够更好的响应时间频率的快速变化，这对于具备不稳定时钟的虚拟机或导致时钟频率反复变化的节能技术而言非常有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在初始同步后，它并不会停止时钟，以防对需要系统时间保持单调的程序造成影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在应对临时非对称延迟时，（例如：大规模下载造成连接饱和时）提供了更好的稳定性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无需对服务器进行定期轮询，因此具备间歇性网络连接的系统仍然可以快速同步时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="NTP" scheme="https://www.hi-linux.com/tags/NTP/"/>
    
  </entry>
  
  <entry>
    <title>看业界大神是如何进行独立思考的！做为技术人，你具备这样的能力吗？</title>
    <link href="https://www.hi-linux.com/posts/34120.html"/>
    <id>https://www.hi-linux.com/posts/34120.html</id>
    <published>2020-05-06T01:00:00.000Z</published>
    <updated>2020-05-06T04:39:24.993Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这是一个非常复杂的世界，这个世界上有很多各式各样的观点和思维方式，作为一个程序员的我，也会有程序员的思维方式，程序员的思维方式更接近数学的思维方式，数学的思维方式让可以很容易地理清楚这个混乱的世界，其实，并不需要太复杂的数学逻辑，只需要使用一些简单的数学方法，就可以大幅提升自己的认识能力，所以，在这里，记录一篇我自己的思维方式，一方面给大家做个参考，另一方面也供更高阶的人给我进行指正。算是 “开源我的思维方式”，开放不仅仅是为了输出，更是为了看看有没有更好的方式。</p><p>我的思维方式中，使用数学逻辑的方式进行思考，通常来说，我会使用五步思考的方式：</p><h3 id="第一步信息数据可考证">第一步：信息数据可考证</h3><p>如果一个观点或是一个见解的数据是错误的，那么就会造成后面的观点全是错的，所以，首要的是要进行数据的查证或考证。一般来说，如果一篇文章的作者足够严谨的话，他的需要给他的数据建立相关的引用或是可以考证的方法方式。如果一篇文章中出现的是，“有关专家表明”、“美国科学家证明”、“经济学家指出”，但是没有任出处，也没有点明这个专家或是科学家的名字，或是，也没有说明或引用让读者可以自己去验证的方法。那么，其引用的话或是数据是无法考证的，如果是无法考证的，那么，这篇文章的水份就非常大了。一般来说，当我读到一篇文章中的东西没有可考证的来源或是方法时，通常来说，我就不会再读了，因为这篇文章的价值已经不大了，如果我关心这篇文章中的东西，我会改为自己去查找的方式，虽然变“重”了，但是很安全。（所以，像 Wikipedia 这样的网站是我经常去获得信息的地方，因为信息可以被考证是其基本价值观）</p><h3 id="第二步处理集合和其包含关系">第二步：处理集合和其包含关系</h3><p>这是一个非常简单的人人都会的数学逻辑。比如：哲学家是人，柏拉图是哲学家，所以，柏拉图是人。就是一个在包含关系下的推理。你不要小看这个简单的逻辑，其实很多人并不会很好的应用，相反，当感情支配了他们以后，他们会以点代面，以特例代替普遍性。比如，地图炮就是一种，他们看到了多个案例，他们就开始把这个案例上升上更大的范围，比如：河南人新疆人都是小偷，上海人都是小市民。日本人都是变态和反人类……等等。除了这些地图炮外，还有否定整个人的，比如一个人犯了个错或是性格上有缺陷，就会把整个人全盘否定掉，员工抢个月饼就上升到其价值观有问题……。在数学的逻辑包含中，超集的定义可以适用于子集，通过子集的特征可以对超集进行探索，但是没法定义超集。另外，集合的大小也是一个很重要的事，<a href="https://zh.wikipedia.org/wiki/%E5%80%96%E5%AD%98%E8%80%85%E5%81%8F%E5%B7%AE" target="_blank" rel="noopener">幸存者偏差</a>会是一个很容易让人掉下去的陷阱，因为可能会有很大的样本集可能在你的视线盲区。</p><a id="more"></a><h3 id="第三步处理逻辑因果关系">第三步：处理逻辑因果关系</h3><p>所谓因果关系，其实就是分辨充分条件、必要条件和充分必要条件，然后处理其中的逻辑是否有关联性，而且有非常强的因果关系。没有能力分辨充分必要条件处理因果关系是很多人的硬伤。就像我在《<a href="https://coolshell.cn/articles/19271.html" target="_blank" rel="noopener">努力就会成功</a>》中说的一样，“努力” 和 “成功”是否有因果关系？各种逻辑混淆、概念偷换、模糊因果、似是而非全是在这里。比如：掩耳盗铃、刻舟求剑就是因果关系混乱的表现。人们会经常地混淆两个看来一起发生，但是并没有关联在一起的事。因果关系是最容易被模糊和偷换的，比如：很多人都容易混淆“加班”就会有“产出”，混淆了“行动”就会有“结果”，混淆了“抵制”就会赢得“尊重”，混淆了“批评”等于“反对”……等等。除了这些以外，微信公众号里的很多时评文章，他们的文章中的结论和其论据是没有因果关系的，好多文章就是混淆、模糊、偷换……<strong>因果关系出问题的文章读多了是对大脑有损伤的，要尽量远离。</strong></p><h3 id="第四步找到靠谱的基准线">第四步：找到靠谱的基准线</h3><p>就像我们写代码一样，我们都是会去找一些最佳实践或是业内标准，原因是因为，这样的东西都是经过长时间被这个世界上很多人 Review 过的，是值得依赖和靠谱的，他们会考虑到很多你没有考虑过的问题。所以，你也会看到很多时评都会找欧美发达国家的作参考的做法，因为毕竟人家的文化是相对比较文明、科学、开放和先进的。找到世界或是国际的通行标准，会更容易让人进步。比如：以开放包容加强沟通的心态，就会比封闭抵制敌对的心态要好得多得多，智者建桥，愚者建墙。当然，我们也开始发现，有一些事上，有利于自己的就对标，不利于自己的就不对标，而且，除了好的事，不好的事也在找欧美作对标，于是开始 “多基准线” 和 “乱基准线”，这种方式需要我们小心分辨。</p><h3 id="第五步更为深入和高维的思考">第五步：更为深入和高维的思考</h3><p>如果一件事情只在表面上进行思考其实只是一种浅度思考，在 Amazon，线上系统出现故障的时候，需要写一个 Correction of Errors 的报告，其中需要Ask 5 Whys（参看 Wikipedia 的 <a href="https://en.wikipedia.org/wiki/Five_whys" target="_blank" rel="noopener">Five Whys 词条</a>），这种思考方式可以让你不断追问到深层次的本质问题，会让你自己做大量的调查和研究，让你不会成为一个只会在表面上进行思考的简单动物。比如：当你看到有出乎你意料的事件发生时（比如负面的暴力事件），你需要问一下，为什么会发生，原因是什么？然后罗列尽可能全的原因，再不断地追问并拷证下去（这跟写程序一样，需要从正向案例和负向案例进行考虑分析，才可能写出健壮性很强的代码），我们才会得出一个比较健壮的答案或结构。</p><p>需要注意的是，在上述的这五种思维方式下，你的思考是不可能快得起来的，这是一个 “慢思考”（注：如果读过《<a href="https://book.douban.com/subject/10785583/" target="_blank" rel="noopener">思考，快与慢</a>》这本书的人就知道我在说什么），独立思考是需要使用大脑中的“慢系统”，慢系统是反人性的，所以，能真正做到独立思考的人很少。更多的人的“独立思考”其实只不过是毫无章法的乱思考罢了。</p><p>通过上述的这五点，我相信你是很容易识别或是分辨出哪些信息是靠谱的，哪些信息是很扯的，甚至会改善你自己的言论和思考。但是，<strong>请注意，这些方法并不能让你获得真理或是真相。</strong></p><p>但是这也够了，一个人如果拥有了能够分辨是非的能力，也是很不错的了。虽然不知道事实是什么，但是你也不会盲从和偏信，从而不会被人煽动，而成为幕后黑手的的一只“肉鸡”。</p><p>多说两句，下面是一些我个人的一些实践：</p><ul><li><p>当新闻报道报道的不是客观事实，而是加入了很多观点，那么这篇新闻报道是不可信的。</p></li><li><p>对于评论性的文章，没有充足权威可信的论据时，不能完全相信。</p></li><li><p>不是当事人，不是见证人，还要装作自己是知情的……不知道这种人的自信怎么来的？</p></li><li><p>信息不公开的，并有意屏蔽信息的，不能作为可信的信息源。</p></li><li><p>当出现大是或是大非的事时，一定要非常小心，这个世界不存在完全的美和完全的丑，这样的观点通常来说都是危险的，此时要多看看不同角度的报道和评论，要多收集一些信息，还要多问问为什么。</p></li></ul><p>欢迎大家在评论区留言，告诉我一些你的实践和思维方式。</p><blockquote><p>本文转载自：「酷壳」，原文：<a href="https://url.cn/5MGMoTP%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5MGMoTP，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个非常复杂的世界，这个世界上有很多各式各样的观点和思维方式，作为一个程序员的我，也会有程序员的思维方式，程序员的思维方式更接近数学的思维方式，数学的思维方式让可以很容易地理清楚这个混乱的世界，其实，并不需要太复杂的数学逻辑，只需要使用一些简单的数学方法，就可以大幅提升自己的认识能力，所以，在这里，记录一篇我自己的思维方式，一方面给大家做个参考，另一方面也供更高阶的人给我进行指正。算是 “开源我的思维方式”，开放不仅仅是为了输出，更是为了看看有没有更好的方式。&lt;/p&gt;
&lt;p&gt;我的思维方式中，使用数学逻辑的方式进行思考，通常来说，我会使用五步思考的方式：&lt;/p&gt;
&lt;h3 id=&quot;第一步：信息数据可考证&quot;&gt;第一步：信息数据可考证&lt;/h3&gt;
&lt;p&gt;如果一个观点或是一个见解的数据是错误的，那么就会造成后面的观点全是错的，所以，首要的是要进行数据的查证或考证。一般来说，如果一篇文章的作者足够严谨的话，他的需要给他的数据建立相关的引用或是可以考证的方法方式。如果一篇文章中出现的是，“有关专家表明”、“美国科学家证明”、“经济学家指出”，但是没有任出处，也没有点明这个专家或是科学家的名字，或是，也没有说明或引用让读者可以自己去验证的方法。那么，其引用的话或是数据是无法考证的，如果是无法考证的，那么，这篇文章的水份就非常大了。一般来说，当我读到一篇文章中的东西没有可考证的来源或是方法时，通常来说，我就不会再读了，因为这篇文章的价值已经不大了，如果我关心这篇文章中的东西，我会改为自己去查找的方式，虽然变“重”了，但是很安全。（所以，像 Wikipedia 这样的网站是我经常去获得信息的地方，因为信息可以被考证是其基本价值观）&lt;/p&gt;
&lt;h3 id=&quot;第二步：处理集合和其包含关系&quot;&gt;第二步：处理集合和其包含关系&lt;/h3&gt;
&lt;p&gt;这是一个非常简单的人人都会的数学逻辑。比如：哲学家是人，柏拉图是哲学家，所以，柏拉图是人。就是一个在包含关系下的推理。你不要小看这个简单的逻辑，其实很多人并不会很好的应用，相反，当感情支配了他们以后，他们会以点代面，以特例代替普遍性。比如，地图炮就是一种，他们看到了多个案例，他们就开始把这个案例上升上更大的范围，比如：河南人新疆人都是小偷，上海人都是小市民。日本人都是变态和反人类……等等。除了这些地图炮外，还有否定整个人的，比如一个人犯了个错或是性格上有缺陷，就会把整个人全盘否定掉，员工抢个月饼就上升到其价值观有问题……。在数学的逻辑包含中，超集的定义可以适用于子集，通过子集的特征可以对超集进行探索，但是没法定义超集。另外，集合的大小也是一个很重要的事，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%80%96%E5%AD%98%E8%80%85%E5%81%8F%E5%B7%AE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;幸存者偏差&lt;/a&gt;会是一个很容易让人掉下去的陷阱，因为可能会有很大的样本集可能在你的视线盲区。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="思想" scheme="https://www.hi-linux.com/tags/%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款命令行下最快的文本搜索神器 RipGrep</title>
    <link href="https://www.hi-linux.com/posts/29245.html"/>
    <id>https://www.hi-linux.com/posts/29245.html</id>
    <published>2018-09-17T01:00:00.000Z</published>
    <updated>2018-09-17T02:18:53.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Ripgrep 是命令行下一个基于行的搜索工具，RipGrep 使用 Rust 开发，可以在多平台下运行，支持 Mac、Linux 和 Windows 等平台。RipGrep 与 The Silver Searcher、Ack 和 GNU Grep 的功能类似。</p><p>RipGrep 官方号称比其它类似工具在搜索速度上快上 N 倍，VSCode 也从 <a href="https://code.visualstudio.com/updates/v1_11#_text-search-improvements" target="_blank" rel="noopener">1.11 版本</a>开始默认将 RipGrep 做为其搜索工具，由此其功能强大可见一斑。</p><p>项目地址：<a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">https://github.com/BurntSushi/ripgrep</a></p><p><strong>Ripgrep 支持的一些特性</strong></p><ul><li>自动递归搜索 （grep 需要 -R）。</li><li>自动忽略 .gitignore 中的文件以及二进制文件和隐藏文件。</li><li>可以搜索指定文件类型，如：<code>rg -tpy foo</code> 则限定只搜索 Python 文件，<code>rg -Tjs foo</code> 则排除掉 JS 文件。</li><li>支持大部分 Grep 的 特性，例如：显示搜索结果的上下文、支持多个模式搜索、高亮匹配的搜索结果以及支持 Unicode 等。</li><li>支持各种文本编码格式，如：UTF-8、UTF-16、latin-1、GBK、EUC-JP、Shift_JIS 等。</li><li>支持搜索常见格式的压缩文件，如：gzip、xz、lzma、bzip2、lz4 等。</li><li>自动高亮匹配的结果。</li></ul><a id="more"></a><p><strong>Ripgrep 官方性能基准测试结果</strong></p><ul><li>搜索整个 Linux 内核源代码</li></ul><table><thead><tr><th>Tool</th><th>Command</th><th>Line count</th><th>Time</th></tr></thead><tbody><tr><td>ripgrep (Unicode)</td><td><code>rg -n -w '[A-Z]+_SUSPEND'</code></td><td>450</td><td><strong>0.106s</strong></td></tr><tr><td><a href="https://www.kernel.org/pub/software/scm/git/docs/git-grep.html" target="_blank" rel="noopener">git grep</a></td><td><code>LC_ALL=C git grep -E -n -w '[A-Z]+_SUSPEND'</code></td><td>450</td><td>0.553s</td></tr><tr><td><a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="noopener">The Silver Searcher</a></td><td><code>ag -w '[A-Z]+_SUSPEND'</code></td><td>450</td><td>0.589s</td></tr><tr><td><a href="https://www.kernel.org/pub/software/scm/git/docs/git-grep.html" target="_blank" rel="noopener">git grep (Unicode)</a></td><td><code>LC_ALL=en_US.UTF-8 git grep -E -n -w '[A-Z]+_SUSPEND'</code></td><td>450</td><td>2.266s</td></tr><tr><td><a href="https://github.com/svent/sift" target="_blank" rel="noopener">sift</a></td><td><code>sift --git -n -w '[A-Z]+_SUSPEND'</code></td><td>450</td><td>3.505s</td></tr><tr><td><a href="https://github.com/petdance/ack2" target="_blank" rel="noopener">ack</a></td><td><code>ack -w '[A-Z]+_SUSPEND'</code></td><td>1878</td><td>6.823s</td></tr><tr><td><a href="https://github.com/monochromegane/the_platinum_searcher" target="_blank" rel="noopener">The Platinum Searcher</a></td><td><code>pt -w -e '[A-Z]+_SUSPEND'</code></td><td>450</td><td>14.208s</td></tr></tbody></table><table><thead><tr><th>Tool</th><th>Command</th><th>Line count</th><th>Time</th></tr></thead><tbody><tr><td>ripgrep</td><td><code>rg -L -u -tc -n -w '[A-Z]+_SUSPEND'</code></td><td>404</td><td><strong>0.079s</strong></td></tr><tr><td><a href="https://github.com/gvansickle/ucg" target="_blank" rel="noopener">ucg</a></td><td><code>ucg --type=cc -w '[A-Z]+_SUSPEND'</code></td><td>390</td><td>0.163s</td></tr><tr><td><a href="https://www.gnu.org/software/grep/" target="_blank" rel="noopener">GNU grep</a></td><td><code>egrep -R -n --include='*.c' --include='*.h' -w '[A-Z]+_SUSPEND'</code></td><td>404</td><td>0.611s</td></tr></tbody></table><ul><li>在单个大文件上对 Ripgrep 和 GNU Grep 进行比较，文件大小大约 9.3G。</li></ul><table><thead><tr><th>Tool</th><th>Command</th><th>Line count</th><th>Time</th></tr></thead><tbody><tr><td>ripgrep</td><td><code>rg -w 'Sherlock [A-Z]\w+'</code></td><td>5268</td><td><strong>2.108s</strong></td></tr><tr><td><a href="https://www.gnu.org/software/grep/" target="_blank" rel="noopener">GNU grep</a></td><td><code>LC_ALL=C egrep -w 'Sherlock [A-Z]\w+'</code></td><td>5268</td><td>7.014s</td></tr></tbody></table><p><strong>Ripgrep 效果图</strong></p><p><img src="https://www.hi-linux.com/img/linux/ripgrep.png" alt=""></p><h3 id="安装-ripgrep">安装 Ripgrep</h3><p>Ripgrep 具有良好跨平台特性，支持在 Linux、macOS、Windows 等多种平台下安装。官方也提供了各平台对应的二进制版本，下面我们以 Linux 平台为例使用二进制版本进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget  https://github.com/BurntSushi/ripgrep/releases/download/0.10.0/ripgrep-0.10.0-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line">$ tar xzvf ripgrep-0.10.0-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line">$ cp ripgrep-0.10.0-x86_64-unknown-linux-musl/rg  /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>如果你使用其它平台，方法与其类似。你可根据实际情况在官方<a href="https://github.com/BurntSushi/ripgrep/releases" target="_blank" rel="noopener">下载页面</a>下载对应版本进行安装。当然官方也提供了其它多种多样的安装方式，具体可参考官方<a href="https://github.com/BurntSushi/ripgrep#installation" target="_blank" rel="noopener">安装文档</a>。</p><h3 id="ripgrep-语法格式">Ripgrep 语法格式</h3><ul><li>整体语法格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">USAGE:</span><br><span class="line"></span><br><span class="line">    rg [OPTIONS] PATTERN [PATH ...]</span><br><span class="line">    rg [OPTIONS] [-e PATTERN ...] [-f PATTERNFILE ...] [PATH ...]</span><br><span class="line">    rg [OPTIONS] --files [PATH ...]</span><br><span class="line">    rg [OPTIONS] --<span class="built_in">type</span>-list</span><br><span class="line">    <span class="built_in">command</span> | rg [OPTIONS] PATTERN</span><br><span class="line"></span><br><span class="line">ARGS:</span><br><span class="line">    &lt;PATTERN&gt;</span><br><span class="line">            A regular expression used <span class="keyword">for</span> searching. To match a pattern beginning with a</span><br><span class="line">            dash, use the -e/--regexp flag.</span><br><span class="line"></span><br><span class="line">            For example, to search <span class="keyword">for</span> the literal <span class="string">'-foo'</span>, you can use this flag:</span><br><span class="line"></span><br><span class="line">                rg -e -foo</span><br><span class="line"></span><br><span class="line">            You can also use the special <span class="string">'--'</span> delimiter to indicate that no more flags</span><br><span class="line">            will be provided. Namely, the following is equivalent to the above:</span><br><span class="line"></span><br><span class="line">                rg -- -foo</span><br><span class="line"></span><br><span class="line">    &lt;PATH&gt;...</span><br><span class="line">            A file or directory to search. Directories are searched recursively. Paths specified on</span><br><span class="line">            the <span class="built_in">command</span> line override glob and ignore rules.</span><br></pre></td></tr></table></figure><ul><li>支持的命令行选项</li></ul><p>这里我们把一些常用选项做下介绍。</p><table><thead><tr><th>选项</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>-A, --after-context <code>&lt;NUM&gt;</code></td><td>显示匹配内容后的 <code>&lt;NUM&gt;</code> 行。</td><td>会覆盖 <code>--context</code> 选项。</td></tr><tr><td>-B, --before-context <code>&lt;NUM&gt;</code></td><td>显示匹配内容前的 <code>&lt;NUM&gt;</code> 行。</td><td>会覆盖 <code>--context</code> 选项。</td></tr><tr><td>-b, --byte-offset</td><td>显示匹配内容在文件中的字节偏移。</td><td>和 <code>-o</code> 一起使用时只打印偏移。</td></tr><tr><td>-s, --case-sensitive</td><td>启用大小写敏感。</td><td>会覆盖 <code>-i(--ignore case)</code> 和 <code>-S(--smart case)</code> 选项。</td></tr><tr><td>–color <code>&lt;WHEN&gt;</code></td><td>什么时候使用颜色，默认值为：auto。可选值有：never、auto、always、ansi。</td><td>如果 <code>--vimgre</code> 选项被使用，那么默认值是 never。</td></tr><tr><td>–column</td><td>显示匹配所在列数 (从 1 开始)。</td><td>如果不显示列号可用 <code>--no-column</code> 取消掉。</td></tr><tr><td>-C, --context <code>&lt;NUM&gt;</code></td><td>显示匹配内容的前面和后面的 <code>&lt;NUM&gt;</code> 行。</td><td>该选项会覆盖 <code>-B</code> 和 <code>-A</code> 选项。</td></tr><tr><td>–context-separator <code>&lt;SEPARATOR&gt;</code></td><td>在输出结果中分隔非连续的输出行 。</td><td>可以使用<code>\x7F</code> 或 <code>\t</code>，默认是 <code>--</code>。</td></tr><tr><td>-c, --count</td><td>只显示匹配结果的总行数。</td><td>如果只有一个文件给 Ripgrep，那么只打印匹配结果的总行数。可以用 <code>--with-filename</code> 来强制打印文件名，该选项会覆盖 <code>--count-matches</code> 选项。</td></tr><tr><td>–count-matches</td><td>只显示匹配结果的总次数。</td><td>可以用 <code>--with-filename</code> 来强制在只有一个文件时也输出文件名。</td></tr><tr><td>–debug</td><td>显示调试信息。</td><td></td></tr><tr><td>–dfa-size-limit <code>&lt;NUM+SUFFIX?&gt;</code></td><td>指定正则表达式 DFA 的上限，默认为 10M。</td><td>该选项允许接受与 <code>--max-filesize</code> 相同大小的后缀标志。</td></tr><tr><td>-E, --encoding <code>&lt;ENCODING&gt;</code></td><td>指定文本编码格式, 默认是 auto。</td><td>更多编码格式参考：<a href="https://encoding.spec.whatwg.org/#concept-encoding-get" target="_blank" rel="noopener">https://encoding.spec.whatwg.org/#concept-encoding-get</a></td></tr><tr><td>-f, --file <code>&lt;PATTERNFILE&gt;</code>…</td><td>从文件中读入搜索模式, 一行一个模式。</td><td>结合 <code>-e/--regexp</code> 参数可多个文件一起组合使用，所有组合会被匹配。</td></tr><tr><td>–files</td><td>打印所有将被搜索的文件路径。</td><td>以 <code>rg &lt;options&gt; --files [PATH...]</code> 方式使用，不能增加搜索模式。</td></tr><tr><td>-l, --files-with-matches</td><td>只打印有匹配的文件名。</td><td>该选项会覆盖 <code>--files-without-match</code>。</td></tr><tr><td>–files-without-match</td><td>只打印无匹配的文件名。</td><td>该选项会覆盖 <code>--file-with-matches</code>。</td></tr><tr><td>-F, --fixed-strings</td><td>把搜索模式当成常规文字而非正则表达式。</td><td>该选项可以用<code>--no-fixed-strings</code> 来禁止。</td></tr><tr><td>-L, --follow</td><td>该选项会递归搜索符号链接，默认是关闭的。</td><td>该选项可以用 <code>--no-follow</code> 选项来手动关闭。</td></tr><tr><td>-g, --glob <code>&lt;GLOB&gt;</code>…</td><td>包含或排除用于搜索匹配给定的文件和目录，可以用 ! 来取反。</td><td>该选项可以多次使用，会匹配 .gitignore 中的规则。</td></tr><tr><td>-h, --help</td><td>打印帮助信息。</td><td></td></tr><tr><td>–heading</td><td>打印文件名到匹配内容的上方而不是在同一行。</td><td>该选项是默认启用的，可以用 <code>--no-heading</code> 来关闭。</td></tr><tr><td>–hidden</td><td>启用搜索隐藏文件和文件夹。</td><td>默认情况下是忽略搜索隐藏文件和文件夹的, 可用 <code>--no-hidden</code> 来关闭。</td></tr><tr><td>–iglob <code>&lt;GLOB&gt;</code>…</td><td>作用同 <code>--glob</code>, 但这个选项大小写不敏感。</td><td></td></tr><tr><td>-i, --ignore-case</td><td>指定搜索模式中的大小写不敏感。</td><td>该选项会被 <code>-s/--case-sensitive</code> 或 <code>-S/--smart-case</code> 覆盖。</td></tr><tr><td>–ignore-file <code>&lt;PATH&gt;</code>…</td><td>指定搜索时需忽略的路径，格式同 <code>.gitignore</code>, 可同时指定多个。</td><td>如果存在多个 <code>--ignore-file</code> 标记时，后面优先级会更高。</td></tr><tr><td>-v, --invert-match</td><td>反向匹配，显示与给定模式不匹配的行。</td><td></td></tr><tr><td>-n, --line-number</td><td>显示匹配内容所在文件的行数，该选项默认是打开的。</td><td></td></tr><tr><td>-x, --line-regexp</td><td>只显示整行都匹配搜索模式的行。</td><td>该选项会覆盖 <code>--word-regexp</code>。</td></tr><tr><td>-M, --max-columns <code>&lt;NUM&gt;</code></td><td>不打印长于 <code>&lt;NUM&gt;</code> 中指定节字大小的匹配行内容，只显示该行的匹配数。</td><td></td></tr><tr><td>-m, --max-count <code>&lt;NUM&gt;</code></td><td>限制一个文件中最多 <code>&lt;NUM&gt;</code> 行被匹配。</td><td></td></tr><tr><td>–max-depth <code>&lt;NUM&gt;</code></td><td>限制文件夹递归搜索深度。</td><td>如：<code>rg --max-depth 0 dir/</code> 则表示不执行任何搜索。</td></tr><tr><td>–max-filesize <code>&lt;NUM+SUFFIX?&gt;</code></td><td>搜索时忽略大于 <code>&lt;NUM&gt;</code> byte 的文件。</td><td>SUFFIX 的单位可以是：K、M、G，默认是：byte。</td></tr><tr><td>–mmap</td><td>尽量使用 Memory Maps 进行搜索，这样速度会更快。该选项是默认行为。</td><td>如果使用 <code>--mmap</code> 搜索文件时 Ripgrep 发生意外中止，可使用 <code>--no-mmap</code> 选项关闭它。</td></tr><tr><td>–no-config</td><td>不读取 configuration 文件, 并忽略 RIPGREP_CONFIG_PATH 变量。</td><td></td></tr><tr><td>–no-filename</td><td>不要打印匹配文件的文件名。</td><td></td></tr><tr><td>–no-heading</td><td>不在每个匹配行上方打印文件名，而是在匹配行的同一行上打印。</td><td></td></tr><tr><td>–no-ignore</td><td>不读取忽略文件，如：.gitignore、.ignore 等。</td><td>该选项可以用 <code>--ignore</code> 关闭。</td></tr><tr><td>–no-ignore-global</td><td>不读取全局的 ignore 文件，比如: <code>$HOME/.config/git/ignore</code>。</td><td>该选项可以用 <code>--ignore-global</code> 关闭。</td></tr><tr><td>–no-ignore-messages</td><td>取消解析 .ignroe、.gitignore 文件中相关错误信息。</td><td>该选项可通过 <code>--ignore-messages</code> 关闭。</td></tr><tr><td>–no-ignore-parent</td><td>不读取父文件夹里的 .gitignore、.ignore 文件。</td><td>该选项可通过 <code>--ignore-parent</code> 关闭。</td></tr><tr><td>–no-ignore-vcs</td><td>不读取版本控制器中的 .ignore 文件。</td><td>该选项可通过 <code>--ignore-vcs</code> 关闭。</td></tr><tr><td>-N, --no-line-number</td><td>不打印匹配行数。</td><td></td></tr><tr><td>–no-messages</td><td>不打印打开和读取文件时相关错误信息。</td><td></td></tr><tr><td>-0, --null</td><td>在打印的文件路径后加一个 NUL 字符。</td><td>这对于结合 Xargs 使用时是非常有用的。</td></tr><tr><td>-o, --only-matching</td><td>只打印匹配的内容，而不是整行。</td><td></td></tr><tr><td>–passthru</td><td>同时打印文件中匹配和不匹配的行。</td><td></td></tr><tr><td>–path-separator <code>&lt;SEPARATOR&gt;</code></td><td>路径分隔符，在 Linux 上默认是 /，Windows 上默认是 \ 。</td><td></td></tr><tr><td>–pre <code>&lt;COMMAND&gt;</code></td><td>用 <code>&lt;COMMAND&gt;</code> 处理文件后，并将结果传递给 Ripgrep。</td><td>该选项存在一定的性能损耗。</td></tr><tr><td>-p, --pretty</td><td>该选项是 <code>--color always --heading --line-number</code> 的别名。</td><td></td></tr><tr><td>-q, --quiet</td><td>该选项不会打印到标准输出, 如果匹配发现时就停止搜索。</td><td>当 RipGrep 用于 exit 代码时该选项非常有用。</td></tr><tr><td>–regex-size-limit <code>&lt;NUM+SUFFIX?&gt;</code></td><td>设置已编译正则表达式的上限，默认限制为10M。</td><td></td></tr><tr><td>-e, --regexp <code>&lt;PATTERN&gt;</code>…</td><td>使用正则来匹配搜索条件。</td><td>该选项可以多次使用，可打印匹配任何模式的行。</td></tr><tr><td>-r, --replace <code>&lt;REPLACEMENT_TEXT&gt;</code></td><td>用相应文件内容代替匹配内容打印出来。</td><td></td></tr><tr><td>-z, --search-zip</td><td>在 gz、bz2、xz、lzma、lz4 文件类型中搜索。</td><td>该选项可通过 <code>--no-search-zip</code> 关闭。</td></tr><tr><td>-S, --smart-case</td><td>如果全小写，则大小写不敏感，否则大小写敏感。</td><td>该选项可通过 <code>-s/--case-sensitive</code> 和 <code>-i/--ignore-case</code> 来关闭。</td></tr><tr><td>–sort <code>&lt;SORTBY&gt;</code></td><td>将输出结果按升序进行排序，可排序类型有：path、modified、accessed、created 。</td><td></td></tr><tr><td>–sortr <code>&lt;SORTBY&gt;</code></td><td>将输出结果按降序进行排序，可排序类型有：path、modified、accessed、created 。</td><td></td></tr><tr><td>–stats</td><td>打印出统计结果。</td><td></td></tr><tr><td>-a, --text</td><td>搜索二进制文件。</td><td>该选项可通过 <code>--no-text</code> 关闭。</td></tr><tr><td>-j, --threads <code>&lt;NUM&gt;</code></td><td>搜索时要使用的线程数。</td><td></td></tr><tr><td>-t, --type <code>&lt;TYPE&gt;</code>…</td><td>只搜索指定的文件类型。</td><td>可以通过 <code>--type-list</code> 来列出支持的文件类型。</td></tr><tr><td>–type-add <code>&lt;TYPE_SPEC&gt;</code>…</td><td>添加一种文件类型。</td><td></td></tr><tr><td>–type-clear <code>&lt;TYPE&gt;</code>…</td><td>清除默认的文件类型。</td><td></td></tr><tr><td>–type-list</td><td>列出所有内置文件类型。</td><td></td></tr><tr><td>-T, --type-not <code>&lt;TYPE&gt;</code>…</td><td>不要搜索某种文件类型。</td><td></td></tr><tr><td>-u, --unrestricted</td><td><code>-u</code> 搜索.gitignore 里的文件, <code>-uu</code> 搜索隐藏文件，<code>-uuu</code> 搜索二进制文件。</td><td></td></tr><tr><td>-V, --version</td><td>打印版本信息。</td><td></td></tr><tr><td>–vimgrep</td><td>每一次匹配都单独打印一行，如果一行有多次匹配会打印成多行。</td><td></td></tr><tr><td>-H, --with-filename</td><td>打印匹配的文件路径，该选项默认打开。</td><td>该选项可通过 <code>--no-filename</code> 关闭。</td></tr><tr><td>-w, --word-regexp</td><td>把搜索参数作为单独单词匹配。</td><td>该选项会覆盖 <code>--line-regexp</code> 选项。</td></tr></tbody></table><p>更多命令行选项，可通过 <code>rg --help</code> 自行查看。</p><h3 id="ripgrep-使用实例">Ripgrep 使用实例</h3><h4 id="搜索指定文件中包含关键字的内容">搜索指定文件中包含关键字的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'github.com'</span>  README.md</span><br><span class="line">1:&lt;h1 align=<span class="string">"center"</span>&gt;&lt;a title=<span class="string">"New «NexT» 6.0.0 version [Reloaded]"</span> href=<span class="string">"https://github.com/theme-next/hexo-theme-next"</span>&gt;NexT&lt;/a&gt;&lt;/h1&gt;</span><br><span class="line">6:[![mnt-image]](https://github.com/theme-next/hexo-theme-next)</span><br><span class="line">21:More NexT examples [here](https://github.com/iissnan/hexo-theme-next/issues/119).</span><br><span class="line">41:   $ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d <span class="string">'"'</span> -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br><span class="line">51:   $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2 | tar -zxv -C themes/next --strip-components=1</span><br><span class="line">57:   $ git <span class="built_in">clone</span> --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line">67:   $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball | tar -zxv -C themes/next --strip-components=1</span><br><span class="line">73:   $ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line">110:For those who also encounter **Error: Cannot find module <span class="string">'hexo-util'</span>** [issue](https://github.com/iissnan/hexo-theme-next/issues/1490), please check your NPM version.</span><br><span class="line">128:<span class="comment">### Theme configurations using Hexo data files ([#328](https://github.com/iissnan/hexo-theme-next/issues/328))</span></span><br><span class="line">282:NexT uses [Tomorrow Theme](https://github.com/chriskempson/tomorrow-theme) with 5 themes <span class="keyword">for</span> you to choose from.</span><br><span class="line">288:Head over to [Tomorrow Theme](https://github.com/chriskempson/tomorrow-theme) <span class="keyword">for</span> more details.</span><br><span class="line">367:[download-latest-url]: https://github.com/iissnan/hexo-theme-next/archive/master.zip</span><br><span class="line">368:[releases-latest-url]: https://github.com/iissnan/hexo-theme-next/releases/latest</span><br><span class="line">369:[releases-url]: https://github.com/iissnan/hexo-theme-next/releases</span><br><span class="line">370:[tags-url]: https://github.com/iissnan/hexo-theme-next/tags</span><br><span class="line">371:[commits-url]: https://github.com/iissnan/hexo-theme-next/commits/master</span><br></pre></td></tr></table></figure><h4 id="搜索指定文件中包含以关键字开头的单词的内容">搜索指定文件中包含以关键字开头的单词的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'lang\w+'</span> README.md</span><br><span class="line">154:<span class="comment">### Multiple languages support, including:</span></span><br><span class="line">168:Default language is English.</span><br><span class="line">171:language: en</span><br><span class="line">172:<span class="comment"># language: zh-Hans</span></span><br><span class="line">173:<span class="comment"># language: zh-hk</span></span><br><span class="line">174:<span class="comment"># language: zh-tw</span></span><br><span class="line">175:<span class="comment"># language: ru</span></span><br><span class="line">176:<span class="comment"># language: fr-FR</span></span><br><span class="line">177:<span class="comment"># language: de</span></span><br><span class="line">178:<span class="comment"># language: ja</span></span><br><span class="line">179:<span class="comment"># language: id</span></span><br><span class="line">180:<span class="comment"># language: pt</span></span><br><span class="line">181:<span class="comment"># language: pt-BR</span></span><br></pre></td></tr></table></figure><h4 id="搜索指定文件中包含以关键字开头的内容">搜索指定文件中包含以关键字开头的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'hexo\w*'</span> README.md</span><br><span class="line">1:&lt;h1 align=<span class="string">"center"</span>&gt;&lt;a title=<span class="string">"New «NexT» 6.0.0 version [Reloaded]"</span> href=<span class="string">"https://github.com/theme-next/hexo-theme-next"</span>&gt;NexT&lt;/a&gt;&lt;/h1&gt;</span><br><span class="line">3:&lt;p align=<span class="string">"center"</span>&gt;NexT is a high quality elegant &lt;a href=<span class="string">"http://hexo.io"</span>&gt;Hexo&lt;/a&gt; theme. It is crafted from scratch, with love.&lt;/p&gt;</span><br><span class="line">6:[![mnt-image]](https://github.com/theme-next/hexo-theme-next)</span><br><span class="line">9:[![hexo-image]][hexo-url]</span><br><span class="line">21:More NexT examples [here](https://github.com/iissnan/hexo-theme-next/issues/119).</span><br><span class="line">25:**1.** Change dir to **hexo root** directory. There must be `node_modules`, `<span class="built_in">source</span>`, `themes` and other directories:</span><br><span class="line">27:   $ <span class="built_in">cd</span> hexo</span><br><span class="line">41:   $ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d <span class="string">'"'</span> -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br><span class="line">51:   $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2 | tar -zxv -C themes/next --strip-components=1</span><br><span class="line">57:   $ git <span class="built_in">clone</span> --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h4 id="搜索指定目录及子目中包含关键字的内容">搜索指定目录及子目中包含关键字的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'github.com'</span> ./</span><br><span class="line">./src/scrollspy.js</span><br><span class="line">6:* Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)</span><br><span class="line"></span><br><span class="line">./src/affix.js</span><br><span class="line">6: * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)</span><br><span class="line"></span><br><span class="line">./src/js.cookie.js</span><br><span class="line">3: * https://github.com/js-cookie/js-cookie</span><br></pre></td></tr></table></figure><h4 id="搜索以关键字为独立单词的内容">搜索以关键字为独立单词的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ rg -w <span class="string">'github.com'</span> ./</span><br><span class="line">./bower.json</span><br><span class="line">36:    <span class="string">"url"</span> : <span class="string">"http://github.com/julianshapiro/velocity.git"</span></span><br><span class="line"></span><br><span class="line">./velocity.ui.js</span><br><span class="line">58:        var abortError = <span class="string">"Velocity UI Pack: You need to update Velocity (jquery.velocity.js) to a newer version. Visit http://github.com/julianshapiro/velocity."</span>;</span><br><span class="line"></span><br><span class="line">./velocity.js</span><br><span class="line">442:    /* IE detection. Gist: https://gist.github.com/julianshapiro/9098609 */</span><br><span class="line">463:    /* rAF shim. Gist: https://gist.github.com/julianshapiro/9497513 */</span><br><span class="line">472:            /* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */</span><br><span class="line">480:    /* Array compacting. Copyright Lo-Dash. MIT License: https://github.com/lodash/lodash/blob/master/LICENSE.txt */</span><br><span class="line">522:        /* Copyright Martin Bohm. MIT License: https://gist.github.com/Tomalak/818a78a226a0738eaade */</span><br></pre></td></tr></table></figure><h4 id="搜索包含关键字内容的文件并且只打印文件名">搜索包含关键字内容的文件并且只打印文件名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rg -w <span class="string">'github.com'</span> ./ -l</span><br><span class="line">./velocity.js</span><br><span class="line">./bower.json</span><br><span class="line">./velocity.ui.js</span><br><span class="line">./velocity.ui.min.js</span><br></pre></td></tr></table></figure><h4 id="在指定文件类型格式为-js-的文件中搜索包含关键字的内容">在指定文件类型格式为 JS 的文件中搜索包含关键字的内容</h4><p>RipGrep 实现的方式存在多种多样，这里介绍比较常用的两种。</p><ul><li>第一种：使用 <code>--type</code> 选项指定文件类型。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'function writeOnCanvas'</span> --<span class="built_in">type</span> js</span><br><span class="line"><span class="built_in">source</span>/lib/Han/dist/han.js</span><br><span class="line">1726:<span class="keyword">function</span> writeOnCanvas( text, font ) &#123;</span><br></pre></td></tr></table></figure><ul><li>第二种：使用 <code>--glob</code> 选项来通配需要的文件类型。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rg  <span class="string">'function writeOnCanvas'</span> -g <span class="string">'*.js'</span></span><br><span class="line"><span class="built_in">source</span>/lib/Han/dist/han.js</span><br><span class="line">1726:<span class="keyword">function</span> writeOnCanvas( text, font ) &#123;</span><br></pre></td></tr></table></figure><p>如果要同时搜索多个文件类型可以写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'Hanzi'</span> -g <span class="string">'*.&#123;js,css&#125;'</span></span><br><span class="line">han.min.js</span><br><span class="line">2:/*! Han.css: the CSS typography framework optimised <span class="keyword">for</span> Hanzi */</span><br><span class="line"></span><br><span class="line">han.js</span><br><span class="line">3: * Han.css: the CSS typography framework optimised <span class="keyword">for</span> Hanzi</span><br><span class="line">48:  // Address Hanzi and Western script mixed spacing</span><br><span class="line">426:    /* Hanzi and Western mixed spacing </span><br><span class="line"></span><br><span class="line">han.css</span><br><span class="line">4:/*! Han.css: the CSS typography framework optimised <span class="keyword">for</span> Hanzi */</span><br><span class="line"></span><br><span class="line">han.min.css</span><br><span class="line">4:/*! Han.css: the CSS typography framework optimised <span class="keyword">for</span> Hanzi */</span><br></pre></td></tr></table></figure><h4 id="在当前目下并且不包含文件类型格式为-css-的文件中搜索包含关键字的内容">在当前目下并且不包含文件类型格式为 CSS 的文件中搜索包含关键字的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ rg <span class="string">'revertVowel'</span> --<span class="built_in">type</span>-not css</span><br><span class="line"><span class="built_in">source</span>/lib/Han/dist/han.min.js</span><br><span class="line">(this[<span class="string">"comb-liga-zhuyin"</span>]=O.substZhuyinCombLiga(this.context)),this&#125;,revertVowelCombLiga:<span class="function"><span class="title">function</span></span>()&#123;try&#123;this[<span class="string">"comb-liga-vowel"</span>].revert(<span class="string">"all"</span>)&#125;catch(a)&#123;&#125;<span class="built_in">return</span> this&#125;,revertVowelICombLiga:<span class="function"><span class="title">function</span></span>()&#123;try&#123;this[<span class="string">"comb-liga-vowel-i"</span>].revert(<span class="string">"all"</span>)&#125;catch(a)&#123;&#125;<span class="built_in">return</span> this&#125;,revertZhuyinCombLiga:<span class="function"><span class="title">function</span></span>()&#123;try&#123;this[<span class="string">"comb-liga-zhuyin"</span>].revert(<span class="string">"all"</span>)&#125;catch(a)&#123;&#125;<span class="built_in">return</span> this&#125;,revertCombLigaWithPUA:<span class="function"><span class="title">function</span></span>()&#123;try&#123;this[<span class="string">"comb-liga-vowel"</span>].revert(<span class="string">"all"</span>),this[<span class="string">"comb-liga-vowel-i"</span>].revert(<span class="string">"all"</span>),this[<span class="string">"comb-liga-zhuyin"</span>].revert(<span class="string">"all"</span>)&#125;catch(a)&#123;&#125;<span class="built_in">return</span> this&#125;,substInaccurateChar:<span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> this[<span class="string">"inaccurate-char"</span>]=O.substInaccurateChar(this.context),this&#125;,revertInaccurateChar:<span class="function"><span class="title">function</span></span>()&#123;try&#123;this[<span class="string">"inaccurate-char"</span>].revert(<span class="string">"all"</span>)&#125;catch(a)&#123;&#125;<span class="built_in">return</span> this&#125;&#125;),a.addEventListener(<span class="string">"DOMContentLoaded"</span>,<span class="function"><span class="title">function</span></span>()&#123;var a;K.classList.contains(<span class="string">"han-init"</span>)?O.init():(a=J.querySelector(<span class="string">".han-init-context"</span>))&amp;&amp;(O.init=O(a).render())&#125;),(<span class="string">"undefined"</span>==typeof b||b===!1)&amp;&amp;(a.Han=O),O&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span>/lib/Han/dist/han.js</span><br><span class="line">2939:  revertVowelCombLiga: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">2946:  revertVowelICombLiga: <span class="function"><span class="title">function</span></span>() &#123;</span><br></pre></td></tr></table></figure><p>你也可以用下面的更简洁的写法来达到同样的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rg &#39;revertVowel&#39; -Tcss</span><br></pre></td></tr></table></figure><h4 id="使用正则表达式进行关键字搜索">使用正则表达式进行关键字搜索</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ rg -e <span class="string">"noConf.*lict"</span> ./</span><br><span class="line">./js.cookie.js</span><br><span class="line">21:api.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"></span><br><span class="line">./scrollspy.js</span><br><span class="line">166:  $.fn.scrollspy.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"></span><br><span class="line">./affix.js</span><br><span class="line">139:  $.fn.affix.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br></pre></td></tr></table></figure><h4 id="搜索匹配关键字的内容及显示其上下内容各两行">搜索匹配关键字的内容及显示其上下内容各两行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$  rg -e <span class="string">"noConf.*lict"</span>  -C2</span><br><span class="line">js.cookie.js</span><br><span class="line">19-var OldCookies = window.Cookies;</span><br><span class="line">20-var api = window.Cookies = factory();</span><br><span class="line">21:api.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">22-window.Cookies = OldCookies;</span><br><span class="line">23-<span class="built_in">return</span> api;</span><br><span class="line"></span><br><span class="line">scrollspy.js</span><br><span class="line">164-  // =====================</span><br><span class="line">165-</span><br><span class="line">166:  $.fn.scrollspy.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">167-    $.fn.scrollspy = old</span><br><span class="line">168-    <span class="built_in">return</span> this</span><br><span class="line"></span><br><span class="line">affix.js</span><br><span class="line">137-  // =================</span><br><span class="line">138-</span><br><span class="line">139:  $.fn.affix.noConflict = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">140-    $.fn.affix = old</span><br><span class="line">141-    <span class="built_in">return</span> this</span><br></pre></td></tr></table></figure><h4 id="搜索不包含关键字的内容">搜索不包含关键字的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ rg -v <span class="string">"hexo"</span> merge-configs.js</span><br><span class="line">2:</span><br><span class="line">3:var merge = require(<span class="string">'./merge'</span>);</span><br><span class="line">4:</span><br><span class="line">5:/**</span><br><span class="line">8: */</span><br><span class="line">12:    <span class="keyword">if</span> ( data &amp;&amp; data.next ) &#123;</span><br><span class="line">13:      <span class="keyword">if</span> ( data.next.override ) &#123;</span><br><span class="line">15:      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">17:      &#125;</span><br><span class="line">18:    &#125;</span><br><span class="line">19:  &#125;</span><br><span class="line">20:&#125;);</span><br><span class="line">21:</span><br><span class="line">30:&#125;);</span><br></pre></td></tr></table></figure><h4 id="搜索关键字并只显示关键字部分的内容">搜索关键字并只显示关键字部分的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ rg -e <span class="string">"hexo.*warn"</span> -o ./</span><br><span class="line">./tags/lazy-image.js</span><br><span class="line">12:hexo.log.warn</span><br><span class="line"></span><br><span class="line">./merge-configs.js</span><br><span class="line">23:hexo.log.warn</span><br><span class="line">24:hexo.log.warn</span><br><span class="line">25:hexo.log.warn</span><br><span class="line">26:hexo.log.warn</span><br><span class="line">27:hexo.log.warn</span><br><span class="line">28:hexo.log.warn</span><br><span class="line">29:hexo.log.warn</span><br><span class="line"></span><br><span class="line">./tags/button.js</span><br><span class="line">13:hexo.log.warn</span><br><span class="line"></span><br><span class="line">./tags/full-image.js</span><br><span class="line">12:hexo.log.warn</span><br></pre></td></tr></table></figure><h4 id="搜索关键字并忽略关键字大小写的内容">搜索关键字并忽略关键字大小写的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rg -ie &quot;Return.*&quot; merge.js</span><br><span class="line">103:var root &#x3D; freeGlobal || freeSelf || Function(&#39;return this&#39;)();</span><br><span class="line">120:    return freeProcess &amp;&amp; freeProcess.binding(&#39;util&#39;);</span><br><span class="line">134: * @returns &#123;Object&#125; Returns &#96;map&#96;.</span><br><span class="line">137:  &#x2F;&#x2F; Don&#39;t return &#96;map.set&#96; because it&#39;s not chainable in IE 11.</span><br><span class="line">139:  return map;</span><br><span class="line">148: * @returns &#123;Object&#125; Returns &#96;set&#96;.</span><br><span class="line">151:  &#x2F;&#x2F; Don&#39;t return &#96;set.add&#96; because it&#39;s not chainable in IE 11.</span><br></pre></td></tr></table></figure><h4 id="把关键字当成常量字符进行搜索">把关键字当成常量字符进行搜索</h4><p>关键字中包含 <code>.(){}*+</code> 类似字符时，不需要手动转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rg -F <span class="string">"i++)"</span> ./</span><br><span class="line">./tags/exturl.js</span><br><span class="line">27:  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">./tags/group-pictures.js</span><br><span class="line">795:    <span class="keyword">for</span> (var i = 0; i &lt; rows; i++) &#123;</span><br><span class="line">805:    <span class="keyword">for</span> (var i = 0; i &lt; rows.length; i++) &#123;</span><br><span class="line">825:    <span class="keyword">for</span> (var i = 0; i &lt; pictures.length; i++) &#123;</span><br></pre></td></tr></table></figure><p>如果要搜索的字符是以 <code>-</code> 开头时，要用 <code>--</code> 来作为分隔符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ rg -- -1 merge.js</span><br><span class="line">190:  var index &#x3D; -1,</span><br><span class="line">210:  var index &#x3D; -1,</span><br><span class="line">233:  var index &#x3D; -1,</span><br><span class="line">255:  var index &#x3D; -1,</span><br><span class="line">317:  var index &#x3D; -1,</span><br><span class="line">348:  var index &#x3D; -1,</span><br><span class="line">435:  var index &#x3D; -1,</span><br><span class="line">533:  var index &#x3D; -1,</span><br><span class="line">605:  return assocIndexOf(this.__data__, key) &gt; -1;</span><br><span class="line">645:  var index &#x3D; -1,</span><br><span class="line">889: * @returns &#123;number&#125; Returns the index of the matched value, else &#96;-1&#96;.</span><br><span class="line">898:  return -1;</span><br></pre></td></tr></table></figure><p>或者使用 <code>-e</code> 参数也可以达到类似目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rg -e <span class="string">"-1"</span> <span class="built_in">source</span>/js</span><br><span class="line"><span class="built_in">source</span>/js/src/js.cookie.js</span><br><span class="line">113:cookie = cookie.slice(1, -1);</span><br><span class="line">155:expires: -1</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span>/js/src/motion.js</span><br><span class="line">190:    cursor: -1,</span><br><span class="line">223:        getMistLineSettings(<span class="variable">$logoLineBottom</span>, <span class="string">'-100%'</span>)</span><br></pre></td></tr></table></figure><h4 id="打印当前目下所有将被搜索的文件列表">打印当前目下所有将被搜索的文件列表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ rg --files</span><br><span class="line">merge.js</span><br><span class="line">merge-configs.js</span><br><span class="line">tags/lazy-image.js</span><br><span class="line">tags/center-quote.js</span><br><span class="line">tags/tabs.js</span><br><span class="line">tags/note.js</span><br><span class="line">tags/button.js</span><br><span class="line">tags/full-image.js</span><br><span class="line">tags/group-pictures.js</span><br><span class="line">tags/label.js</span><br><span class="line">tags/exturl.js</span><br></pre></td></tr></table></figure><h4 id="输出所有内置可识别文件类型">输出所有内置可识别文件类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ rg --type-list</span><br><span class="line">agda: *.agda, *.lagda</span><br><span class="line">aidl: *.aidl</span><br><span class="line">amake: *.bp, *.mk</span><br><span class="line">asciidoc: *.adoc, *.asc, *.asciidoc</span><br><span class="line">asm: *.S, *.asm, *.s</span><br><span class="line">ats: *.ats, *.dats, *.hats, *.sats</span><br><span class="line">avro: *.avdl, *.avpr, *.avsc</span><br><span class="line">awk: *.awk</span><br><span class="line">bazel: *.bzl, BUILD, WORKSPACE</span><br><span class="line">bitbake: *.bb, *.bbappend, *.bbclass, *.conf, *.inc</span><br><span class="line">bzip2: *.bz2</span><br><span class="line">c: *.H, *.c, *.cats, *.h</span><br><span class="line">cabal: *.cabal</span><br><span class="line">cbor: *.cbor</span><br><span class="line">ceylon: *.ceylon</span><br><span class="line">clojure: *.clj, *.cljc, *.cljs, *.cljx</span><br><span class="line">cmake: *.cmake, CMakeLists.txt</span><br><span class="line">coffeescript: *.coffee</span><br><span class="line">config: *.cfg, *.conf, *.config, *.ini</span><br><span class="line">cpp: *.C, *.H, *.cc, *.cpp, *.cxx, *.h, *.hh, *.hpp, *.hxx, *.inl</span><br><span class="line">creole: *.creole</span><br><span class="line">crystal: *.cr, Projectfile</span><br><span class="line">cs: *.cs</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="自定义搜索文件类型">自定义搜索文件类型</h4><p>默认情况下，Ripgrep 附带了一堆预定义的类型。 通常，这些类型对应于众所周知的公共格式。 您也可以定义自己的类型，例如：您可能经常搜索 Web 类型文件，其中包含 Javascript、HTML 和 CSS 类型的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ rg --type-add &#39;web:*.html&#39; --type-add &#39;web:*.css&#39; --type-add &#39;web:*.js&#39; -tweb display</span><br><span class="line">han.css</span><br><span class="line">28:  display: block;</span><br><span class="line">34:  display: inline-block;</span><br><span class="line">37:  display: none;</span><br><span class="line">45:  display: none;</span><br><span class="line">174:  display: table; &#x2F;* 1 *&#x2F;</span><br><span class="line"></span><br><span class="line">han.js</span><br><span class="line">442:    &#x2F;&#x2F; The feature displays the following characters</span><br><span class="line">446:    &#39;display-as&#39;: &#123;</span><br><span class="line">1732:  canvas.style.display &#x3D; &#39;none&#39;</span><br></pre></td></tr></table></figure><p>也可以直接简写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rg --type-add &#39;web:*.&#123;html,css,js&#125;&#39; -tweb display</span><br></pre></td></tr></table></figure><p>不过有一点是要注意的，上面增加的 Web 类型文件是临时的，只对当前命令有效。如果需要长期使用自定义的类型，你可以新增一个别名来在每次运行 RipGrep 时自动增加对应的文件类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ alias rg&#x3D;&quot;rg --type-add &#39;web:*.&#123;html,css,js&#125;&#39;&quot;</span><br></pre></td></tr></table></figure><p>当然还有另一种方法来达到类似的目的，那就是使用 RipGrep 的配置文件，RipGrep 的配置文件默认为 <code>$HOME/.ripgreprc</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="variable">$HOME</span>/.ripgreprc</span><br><span class="line"><span class="comment"># Don't let ripgrep vomit really long lines to my terminal.</span></span><br><span class="line">--max-columns=150</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add my 'web' type.</span></span><br><span class="line">--<span class="built_in">type</span>-add</span><br><span class="line">web:*.&#123;html,css,js&#125;*</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using glob patterns to include/exclude files or folders</span></span><br><span class="line">--glob=!git/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">--glob</span><br><span class="line">!git/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the colors.</span></span><br><span class="line">--colors=line:none</span><br><span class="line">--colors=line:style:bold</span><br><span class="line"></span><br><span class="line"><span class="comment"># Because who cares about case!?</span></span><br><span class="line">--smart-case</span><br></pre></td></tr></table></figure><h4 id="将包含关键字的内容在查找结果中进行替换">将包含关键字的内容在查找结果中进行替换</h4><p>RipGrep 提供了一个在查找过程中直接将关键字内容进行替换的功能，下面我们来看一个将关键字中部分内容的小写字母转大写字母的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ rg browse README.md --replace Browse</span><br><span class="line">305:<span class="comment"># can be any image format supported by web Browsers (JPEG,PNG,GIF,SVG,..)</span></span><br><span class="line">322:![Browser-image]</span><br><span class="line">324:[![Browser Stack](.github/Browserstack_logo.png)](https://www.Browserstack.com/)</span><br><span class="line">325:&gt;**BrowserStack** is a cloud-based cross-Browser testing tool that enables developers to <span class="built_in">test</span> their websites across various Browsers on different operating systems and mobile devices, without requiring users to install virtual machines, devices or emulators.</span><br><span class="line">343:[Browser-image]: https://img.shields.io/badge/Browser-%20chrome%20%7C%20firefox%20%7C%20opera%20%7C%20safari%20%7C%20ie%20%3E%3D%209-lightgrey.svg</span><br><span class="line">344:[Browser-url]: https://www.Browserstack.com</span><br></pre></td></tr></table></figure><p>上面的结果实质上只是在标准输出中进行替换，并不会对实际文件进行修改。如果你需要对实际文件进行修改，你可以结合 Sed 命令来达到目的。</p><ul><li>如果你使用 GNU Sed (CentOS、Ubuntu 等各种 Linux 发行版)，可以使用以下命令。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rg browse --files-with-matches | xargs sed -i <span class="string">'s/browse/Browse/g'</span></span><br></pre></td></tr></table></figure><ul><li>如果您使用 BSD Sed（ macOS 和 FreeBSD），则必须将以上命令修改为以下命令。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rg browse --files-with-matches | xargs sed -i <span class="string">''</span> <span class="string">'s/browse/Browse/g'</span></span><br></pre></td></tr></table></figure><blockquote><p>BSD Sed 中的 -i 标志需要提供文件扩展名以对所有已修改的文件进行备份，这里指定空字符串可防止进行文件备份。</p></blockquote><ul><li>如果您的文件路径中包含空格，则需要使用 NUL 终结符分隔文件路径。这里就需要使用 <code>-0</code> 参数来告诉 Ripgrep 在每个路径之间输出 NUL 字节，并告诉 Xargs 读取由 NUL 字节分隔的路径。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rg Browse --files-with-matches -0 | xargs -0 sed -i &#39;&#39; &#39;s&#x2F;Browse&#x2F;browse&#x2F;g&#39;</span><br></pre></td></tr></table></figure><h4 id="直接在压缩文件中搜索包含关键字的内容">直接在压缩文件中搜索包含关键字的内容</h4><p>Ripgrep 目前仅支持 gzip、bzip2、lzma、lz4 和 xz 这几种压缩格式，并且需要在系统上已安装相应的 gzip，bzip2 和 xz 工具包。也就是说，Ripgrep 是通过 Shelling 到另一个进程来进行解压缩的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rg -z license UNLICENSE.gz</span><br><span class="line">24:For more information, please refer to &lt;http://unlicense.org/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Ripgrep 目前不会搜索存档格式，因此会跳过 *.tar.gz 文件。</p></blockquote><h4 id="自动补全功能">自动补全功能</h4><p>RipGrep 提供的二进制包中默认提供了 SHELL 自动补全功能，只需根据不同 SHELL 放到对应目录即可使用了。</p><ul><li>Bash</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv rg.bash <span class="variable">$XDG_CONFIG_HOME</span>/bash_completion/</span><br><span class="line">或者</span><br><span class="line">$ mv rg.bash /etc/bash_completion.d/</span><br></pre></td></tr></table></figure><ul><li>ZSH</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv _rg <span class="variable">$fpath</span>/</span><br></pre></td></tr></table></figure><ul><li>Fish</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv rg.fish <span class="variable">$HOME</span>/.config/fish/completions/</span><br></pre></td></tr></table></figure><h3 id="参考文档">参考文档</h3><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a><br><a href="http://t.cn/ROI5tMv" target="_blank" rel="noopener">http://t.cn/ROI5tMv</a><br><a href="http://t.cn/Rs3caWW" target="_blank" rel="noopener">http://t.cn/Rs3caWW</a><br><a href="http://t.cn/Rs3F6Ty" target="_blank" rel="noopener">http://t.cn/Rs3F6Ty</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ripgrep 是命令行下一个基于行的搜索工具，RipGrep 使用 Rust 开发，可以在多平台下运行，支持 Mac、Linux 和 Windows 等平台。RipGrep 与 The Silver Searcher、Ack 和 GNU Grep 的功能类似。&lt;/p&gt;
&lt;p&gt;RipGrep 官方号称比其它类似工具在搜索速度上快上 N 倍，VSCode 也从 &lt;a href=&quot;https://code.visualstudio.com/updates/v1_11#_text-search-improvements&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1.11 版本&lt;/a&gt;开始默认将 RipGrep 做为其搜索工具，由此其功能强大可见一斑。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/BurntSushi/ripgrep&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/BurntSushi/ripgrep&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ripgrep 支持的一些特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动递归搜索 （grep 需要 -R）。&lt;/li&gt;
&lt;li&gt;自动忽略 .gitignore 中的文件以及二进制文件和隐藏文件。&lt;/li&gt;
&lt;li&gt;可以搜索指定文件类型，如：&lt;code&gt;rg -tpy foo&lt;/code&gt; 则限定只搜索 Python 文件，&lt;code&gt;rg -Tjs foo&lt;/code&gt; 则排除掉 JS 文件。&lt;/li&gt;
&lt;li&gt;支持大部分 Grep 的 特性，例如：显示搜索结果的上下文、支持多个模式搜索、高亮匹配的搜索结果以及支持 Unicode 等。&lt;/li&gt;
&lt;li&gt;支持各种文本编码格式，如：UTF-8、UTF-16、latin-1、GBK、EUC-JP、Shift_JIS 等。&lt;/li&gt;
&lt;li&gt;支持搜索常见格式的压缩文件，如：gzip、xz、lzma、bzip2、lz4 等。&lt;/li&gt;
&lt;li&gt;自动高亮匹配的结果。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你打造高效的 Kubernetes 命令行终端</title>
    <link href="https://www.hi-linux.com/posts/44953.html"/>
    <id>https://www.hi-linux.com/posts/44953.html</id>
    <published>2018-09-13T01:00:00.000Z</published>
    <updated>2018-09-13T02:34:56.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Kubernetes 作为云原生时代的操作系统，熟悉和使用它是每名用户的必备技能。本文将介绍一些提高操作 Kubernetes 效率的技巧以及如何打造一个高效的 Kubernetes 命令行终端的方法。</p><h3 id="kubectl-自动补全">Kubectl 自动补全</h3><p>Kubectl 这个命令行工具非常重要，与之相关的命令也很多。我们也记不住那么多的命令，而且也会经常写错，所以命令行自动补全是很有必要的。Kubectl 工具本身就支持自动补全，只需简单设置一下即可。</p><ul><li>Bash 用户</li></ul><p>大多数用户的 Shell 使用的是 Bash，Linux 系统可以通过下面的命令来设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"source &lt;(kubectl completion bash)"</span> &gt;&gt; ~/.bashrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>如果发现不能自动补全，可以尝试安装 <code>bash-completion</code> 然后刷新即可！</p><ul><li>ZSH 用户</li></ul><p>如果你使用的 Shell 是 ZSH，可以通过下面的命令来设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"source &lt;(kubectl completion zsh)"</span> &gt;&gt; ~/.zshrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="交互式-kubernetes-客户端">交互式 Kubernetes 客户端</h3><h4 id="kube-prompt">Kube-prompt</h4><p>Kube-prompt 可以让你在命令行下接受与 Kubectl 相同的命令，并且不需要提供 Kubectl前缀。Kube-prompt 还提了交互式会话下的命令提示、自动补全等功能。</p><p>项目地址：<a href="https://github.com/c-bata/kube-prompt" target="_blank" rel="noopener">https://github.com/c-bata/kube-prompt</a></p><p><strong>安装 Kube-prompt</strong></p><p>Kube-prompt 使用 Go 语言开发，天生良好的跨平台性。安装起来非常简单，只需下载各平台对应的二进制版本就可以开箱即用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Linux</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;c-bata&#x2F;kube-prompt&#x2F;releases&#x2F;download&#x2F;v1.0.3&#x2F;kube-prompt_v1.0.3_linux_amd64.zip</span><br><span class="line">$ unzip kube-prompt_v1.0.3_linux_amd64.zip</span><br><span class="line"></span><br><span class="line"># macOS (darwin)</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;c-bata&#x2F;kube-prompt&#x2F;releases&#x2F;download&#x2F;v1.0.3&#x2F;kube-prompt_v1.0.3_darwin_amd64.zip</span><br><span class="line">$ unzip kube-prompt_v1.0.3_darwin_amd64.zip</span><br><span class="line"></span><br><span class="line"># 给 kube-prompt 加上执行权限并移动常用的可搜索路径。</span><br><span class="line">$ chmod +x kube-prompt</span><br><span class="line">$ sudo mv .&#x2F;kube-prompt &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kube-prompt</span><br></pre></td></tr></table></figure><p><strong>Kube-prompt 使用效果图</strong></p><p><img src="https://www.hi-linux.com/img/linux/kube-prompt.gif" alt=""></p><h4 id="kube-shell">Kube-shell</h4><p>Kube-shell 可以为 Kubectl 提供自动的命令提示和补全，Kube-shell 与 Kube-prompt 的使用方法类似。</p><p>项目地址：<a href="https://github.com/cloudnativelabs/kube-shell" target="_blank" rel="noopener">https://github.com/cloudnativelabs/kube-shell</a></p><p><strong>Kube-shell 特性</strong></p><ul><li>命令提示，给出命令的使用说明。</li><li>自动补全，列出可选命令并可以通过 TAB 键自动补全，支持模糊搜索。</li><li>支持语法高亮。</li><li>使用 TAB 键可以列出可选的对象。</li><li>支持 VIM 模式。</li></ul><p><strong>安装 Kube-shell</strong></p><p>Kube-shell 安装非常的简单，使用 PIP 就可以一键安装了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install kube-shell</span><br></pre></td></tr></table></figure><blockquote><p>注：kube-shell 必须用 root 用户运行。如果是普通用户运行会报 <code>/bin/sh: 1: kubectl: not found</code> 错误。即使使用了 <code>sudo  kube-shell</code> 同样也是不行的。</p></blockquote><p><strong>Kube-shell 使用效果图</strong></p><p><img src="https://www.hi-linux.com/img/linux/kube-shell.gif" alt=""></p><blockquote><p>注：Kube-prompt 和 Kube-shell 我都使用过，更推荐 Kube-prompt。Go 的原生性更好一些，并且 Kube-prompt 也不需要 root 权限。</p></blockquote><h3 id="kubectl-aliases">Kubectl Aliases</h3><p>Kubectl Aliases 是一个通过编程方式生成的 Kubectl 别名脚本。如果你需要频繁地使用 Kubectl 和 Kubernetes API 进行交互，使用别名将会为你节省大量的时间。</p><p>项目地址: <a href="https://github.com/ahmetb/kubectl-aliases" target="_blank" rel="noopener">https://github.com/ahmetb/kubectl-aliases</a></p><p><strong>安装 Kubectl Aliases</strong></p><p>Kubectl Aliases 就只是一个 SHELL 脚本，你只需直接下载 <code>.kubectl_aliases</code> 文件并将其保存在 <code>$HOME</code> 目录中，然后在 <code>SHELL</code> 配置文件中调用即可。</p><ul><li>下载脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">$ wget https://raw.githubusercontent.com/ahmetb/kubectl-alias/master/.kubectl_aliases</span><br></pre></td></tr></table></figure><ul><li>配置 SHELL</li></ul><p>Bash 用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br><span class="line"></span><br><span class="line">[ -f ~/.kubectl_aliases ] &amp;&amp; <span class="built_in">source</span> ~/.kubectl_aliases</span><br></pre></td></tr></table></figure><p>ZSH 用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.zshrc</span><br><span class="line"></span><br><span class="line">[ -f ~/.kubectl_aliases ] &amp;&amp; <span class="built_in">source</span> ~/.kubectl_aliases</span><br></pre></td></tr></table></figure><p>如果你想在运行之前打印完整的 Kubectl 命令，可以加上以下行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">kubectl</span></span>() &#123; <span class="built_in">echo</span> <span class="string">"+ kubectl <span class="variable">$@</span>"</span>; <span class="built_in">command</span> kubectl <span class="variable">$@</span>; &#125;</span><br></pre></td></tr></table></figure><p><strong>Kubectl 别名生成规则</strong></p><p><img src="https://www.hi-linux.com/img/linux/kubectl-alias.jpeg" alt=""></p><p><strong>Kubectl 别名使用示例</strong></p><ul><li>简单别名示例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kd → kubectl describe</span><br></pre></td></tr></table></figure><ul><li>高级别名示例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kgdepallw → kubectl get deployment –all-namespaces –watch</span><br></pre></td></tr></table></figure><h3 id="kubeval">Kubeval</h3><p>如果你手动写 Kubernetes manifest 文件，检查 manifest 文件的语法是否有误是很困难的，特别是当你有多个不同版本的 Kubernetes 集群时，确认配置文件语法是否正确更是难上加难。</p><p>Kubeval 是一个用于校验 Kubernetes YAML 或 JSON 配置文件的工具，支持多个 Kubernetes 版本，可以帮助我们解决不少的麻烦。</p><p>项目地址：<a href="https://github.com/garethr/kubeval" target="_blank" rel="noopener">https://github.com/garethr/kubeval</a></p><p><strong>Kubeval 安装</strong></p><p>Kubeval 同样是一款使用 Go 语言开发，天生良好的跨平台性。安装起来非常简单，只需下载各平台对应的二进制版本就可以开箱即用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Linux</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;garethr&#x2F;kubeval&#x2F;releases&#x2F;download&#x2F;0.7.1&#x2F;kubeval-linux-amd64.tar.gz</span><br><span class="line">$ tar xf kubeval-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># macOS (darwin)</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;garethr&#x2F;kubeval&#x2F;releases&#x2F;download&#x2F;0.7.1&#x2F;kubeval-darwin-amd64.tar.gz</span><br><span class="line">$ tar xf kubeval-darwin-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 给 kubeval 加上执行权限并移动常用的可搜索路径。</span><br><span class="line">$ chmod +x kubeval</span><br><span class="line">$ sudo mv kubeval &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><p><strong>Kubeval 使用示例</strong></p><ul><li>Kubernetes manifest 文件正常的情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubeval nginx-deployment.yaml</span><br><span class="line">The document nginx-deployment.yaml contains a valid Deployment</span><br></pre></td></tr></table></figure><ul><li>Kubernetes manifest 文件不正常的情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubeval nginx.yaml</span><br><span class="line"></span><br><span class="line">The document nginx.yaml contains an invalid Deployment</span><br><span class="line">---&gt; spec.replicas: Invalid type. Expected: integer, given: string</span><br></pre></td></tr></table></figure><h3 id="其它一些实用工具">其它一些实用工具</h3><p>下面这几个工具也挺不错的，使用起来都很简单。就不展开讲了，如果有兴趣可以去看下官方文档具体的使用方法。</p><ul><li>Kube-ps1</li></ul><p>该工具主要作用为命令行终端增加一个提示符。</p><p>项目地址：<a href="https://github.com/jonmosco/kube-ps1" target="_blank" rel="noopener">https://github.com/jonmosco/kube-ps1</a></p><p>Kube-ps1 使用效果图</p><p><img src="https://www.hi-linux.com/img/linux/kube-ps1.gif" alt=""></p><ul><li>Kubectx</li></ul><p>该工具主要作用是快速在多个 Kubernetes 集群中切换。</p><p>项目地址：<a href="https://github.com/ahmetb/kubectx" target="_blank" rel="noopener">https://github.com/ahmetb/kubectx</a></p><p>Kubectx 使用效果图</p><p><img src="https://www.hi-linux.com/img/linux/kubectx-demo.gif" alt=""></p><ul><li>Kubens</li></ul><p>该工具可以帮助您快速的在 Kubernetes 的多个命名空间之间切换。</p><p>项目地址：<a href="https://github.com/ahmetb/kubectx" target="_blank" rel="noopener">https://github.com/ahmetb/kubectx</a></p><p>Kubens 使用效果图</p><p><img src="https://www.hi-linux.com/img/linux/kubens-demo.gif" alt=""></p><h3 id="参考文档">参考文档</h3><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a><br><a href="http://t.cn/RD6vxGf" target="_blank" rel="noopener">http://t.cn/RD6vxGf</a><br><a href="http://t.cn/RD6vbc1" target="_blank" rel="noopener">http://t.cn/RD6vbc1</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 作为云原生时代的操作系统，熟悉和使用它是每名用户的必备技能。本文将介绍一些提高操作 Kubernetes 效率的技巧以及如何打造一个高效的 Kubernetes 命令行终端的方法。&lt;/p&gt;
&lt;h3 id=&quot;Kubectl-自动补全&quot;&gt;Kubectl 自动补全&lt;/h3&gt;
&lt;p&gt;Kubectl 这个命令行工具非常重要，与之相关的命令也很多。我们也记不住那么多的命令，而且也会经常写错，所以命令行自动补全是很有必要的。Kubectl 工具本身就支持自动补全，只需简单设置一下即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bash 用户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大多数用户的 Shell 使用的是 Bash，Linux 系统可以通过下面的命令来设置：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;source &amp;lt;(kubectl completion bash)&quot;&lt;/span&gt; &amp;gt;&amp;gt; ~/.bashrc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt; ~/.bashrc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果发现不能自动补全，可以尝试安装 &lt;code&gt;bash-completion&lt;/code&gt; 然后刷新即可！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ZSH 用户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你使用的 Shell 是 ZSH，可以通过下面的命令来设置：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;source &amp;lt;(kubectl completion zsh)&quot;&lt;/span&gt; &amp;gt;&amp;gt; ~/.zshrc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt; ~/.zshrc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>使用 TC 和 Netem 模拟网络异常</title>
    <link href="https://www.hi-linux.com/posts/35699.html"/>
    <id>https://www.hi-linux.com/posts/35699.html</id>
    <published>2018-09-10T01:00:00.000Z</published>
    <updated>2018-09-10T04:00:22.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在某些情况下，我们需要模拟网络很差的状态来测试软件能够正常工作，比如网络延迟、丢包、乱序、重复等。Linux 系统下强大的流量控制工具 TC 能很轻松地完成这个需求，TC 命令行工具是 <code>IProute2</code> 软件包中的软件，可以根据系统版本自行安装。</p><p>这篇文章介绍的功能主要是通过 <code>Netem</code> 这个内核模块来实现的。<code>Netem</code> 是 <code>Network Emulator</code> 的缩写，关于更多功能以及参数的详细解释可以参阅 <code>TC-Netem</code> 的 Man Page。</p><blockquote><p>Netem 与 TC 简要说明</p><p>Netem 是 Linux 2.6 及以上内核版本提供的一个网络模拟功能模块。该功能模块可以用来在性能良好的局域网中，模拟出复杂的互联网传输性能。例如:低带宽、传输延迟、丢包等等情况。使用 Linux 2.6 (或以上) 版本内核的很多 Linux 发行版都默认开启了该内核模块，比如：Fedora、Ubuntu、Redhat、OpenSuse、CentOS、Debian 等等。</p><p>TC 是 Linux 系统中的一个用户态工具，全名为 Traffic Control (流量控制)。TC 可以用来控制 Netem 模块的工作模式，也就是说如果想使用 Netem 需要至少两个条件，一是内核中的 Netem 模块被启用，另一个是要有对应的用户态工具 TC 。</p></blockquote><p>TC 能做的事情很多，除了本文介绍的还有带宽控制、优先级控制等等。这些功能是通过类似 Netem 的内核模块实现的。</p><a id="more"></a><h3 id="网络状况模拟">网络状况模拟</h3><p>网络状况欠佳从用户角度来说就是下载东西慢（网页一直加载、视频卡顿、图片加载很久等），从网络报文角度来看却有很多情况：比如：延迟（某个机器发送报文很慢）、丢包（发送的报文在网络中丢失需要一直重传）、乱序（报文顺序错乱，需要大量计算时间来重新排序）、重复（报文有大量重复，导致网络拥堵）、错误（接收到的报文有误只能丢弃重传）等。</p><p>对于这些情况，都可以用 Netem 来模拟。需要注意的是，Netem 是直接作用于指定网卡上的，也就是说所有从该网卡发送出去的包都会收到配置参数的影响，所以最好搭建临时的虚拟机进行测试。</p><p>在下面的例子中 <code>add</code> 表示为指定网卡添加 Netem 配置，<code>change</code> 表示修改已经存在的 Netem 配置到新的值，<code>replace</code> 表示替换已经存在的 Netem 配置的值。如果要删除网卡上的 Netem 配置可以使用 <code>del</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc del dev enp0s5 root</span><br></pre></td></tr></table></figure><h4 id="1-模拟延迟传输">1. 模拟延迟传输</h4><p>最简单的例子是所有的报文延迟 100ms 发送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc add dev enp0s5 root netem delay 100ms</span><br></pre></td></tr></table></figure><p>如果你想在一个局域网里模拟远距离传输的延迟可以用这个方法，比如实际用户访问网站延迟为 101 ms，而你测试环境网络交互只需要 1ms，那么只要添加 100ms 额外延迟就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc replace dev enp0s5 root netem delay 100ms</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;102 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;100 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;100 ms</span><br><span class="line">^C</span><br><span class="line">--- dev-node-02 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3000ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 100.293&#x2F;101.053&#x2F;102.795&#x2F;1.061 ms</span><br></pre></td></tr></table></figure><p>如果在网络中看到非常稳定的时延，很可能是某个地方加了定时器，因为网络线路很复杂，传输过程一定会有变化。因此实际情况网络延迟一定会有变化的，<code>Netem</code> 也考虑到这一点，提供了额外的参数来控制延迟的时间分布。完整的参数列表为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELAY :&#x3D; delay TIME [ JITTER [ CORRELATION ]]]</span><br><span class="line">    [ distribution &#123; uniform | normal | pareto |  paretonormal &#125; ]</span><br></pre></td></tr></table></figure><p>除了延迟时间 <code>TIME</code> 之外，还有三个可选参数：</p><ul><li><code>JITTER</code>：抖动，增加一个随机时间长度，让延迟时间出现在某个范围。</li><li><code>CORRELATION</code>：相关，下一个报文延迟时间和上一个报文的相关系数。</li><li><code>distribution</code>：分布，延迟的分布模式。可以选择的值有 <code>uniform</code>、<code>normal</code>、<code>pareto</code> 和 <code>paretonormal</code>。</li></ul><p>先说说 <code>JITTER</code>，如果设置为 <code>20ms</code>，那么报文延迟的时间在 100ms  ± 20ms 之间，具体值随机选择：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc replace dev enp0s5 root netem delay 100ms 20ms</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;108 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;107 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;92 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><code>CORRELATION</code> 指相关性，因为网络状况是平滑变化的，短时间里相邻报文的延迟应该是近似的而不是完全随机的。这个值是个百分比，如果为 <code>100%</code>，就退化到固定延迟的情况；如果是 <code>0%</code> 则退化到随机延迟的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc replace dev enp0s5 root netem delay 100ms 20ms 50%</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;104 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;109 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;5 ttl&#x3D;64 time&#x3D;101 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>报文的分布和很多现实事件一样都满足某种统计规律，比如最常用的正态分布。因此为了更逼近现实情况，可以使用 <code>distribution</code> 参数来限制它的延迟分布模型。比如让报文延迟时间满足正态分布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc replace dev enp0s5 root netem delay 100ms 20ms distribution normal</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;82.0 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;82.3 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;98.1 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这样的话，大部分的延迟会在平均值的一定范围内，而很少接近出现最大值和最小值的延迟。</p><p>其他分布方法包括：<a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)" target="_blank" rel="noopener">uniform</a>、<a href="https://en.wikipedia.org/wiki/Pareto_distribution" target="_blank" rel="noopener">pareto</a> 和 <code>paretonormal</code>，这些分布方法感兴趣的读者可以自行了解。对于大多数情况，随机在某个时间范围里延迟就能满足需求的。</p><h4 id="2-模拟丢包率">2. 模拟丢包率</h4><p>另一个常见的网络异常是因为丢包，丢包会导致重传，从而增加网络链路的流量和延迟。Netem 的 <code>loss</code> 参数可以模拟丢包率，比如发送的报文有 50% 的丢包率（为了容易用 ping 看出来，所以这个数字我选的很大，实际情况丢包率可能比这个小很多，比如 <code>0.5%</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc change dev enp0s5 root netem loss 50%</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.290 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.308 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;5 ttl&#x3D;64 time&#x3D;0.221 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;8 ttl&#x3D;64 time&#x3D;0.371 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;9 ttl&#x3D;64 time&#x3D;0.315 ms</span><br></pre></td></tr></table></figure><p>可以从 <code>icmp_seq</code> 序号看出来大约有一半的报文丢掉了，和延迟类似丢包率也可以增加一个相关系数，表示后一个报文丢包概率和它前一个报文的相关性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc change dev enp0s5 root netem loss 0.3% 25%</span><br></pre></td></tr></table></figure><p>这个命令表示，丢包率是 0.3%，并且当前报文丢弃的可能性和前一个报文有 25% 相关。默认的丢包模型为随机，loss 也支持 <code>state</code>（4-state Markov 模型） 和 <code>gemodel</code>（Gilbert-Elliot 丢包模型） 两种模型的丢包，因为两者都相对复杂，这里就不再详细介绍了。</p><p>需要注意的是，丢包信息会发送到上层协议。如果是 TCP 协议，那么 TCP 会进行重传，所以对应用来说看不到丢包。这时候要模拟丢包，需要把 loss 配置到网桥或者路由设备上。</p><h4 id="3-模拟包重复">3. 模拟包重复</h4><p>报文重复和丢包的参数类似，就是重复率和相关性两个参数，比如随机产生 50% 重复的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc change dev enp0s5 root netem duplicate 50%</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.284 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.420 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.447 ms (DUP!)</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.437 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.515 ms (DUP!)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="4-模拟包损坏">4. 模拟包损坏</h4><p>报文损坏和报文重复的参数也类似，比如随机产生 2% 损坏的报文（在报文的随机位置造成一个比特的错误）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc change dev enp0s5 root netem corrupt 2%</span><br><span class="line">$ ping dev-node-02</span><br><span class="line">......</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.362 ms</span><br><span class="line">Warning: time of day goes back (-4611686018427387574us), taking countermeasures.</span><br><span class="line">Warning: time of day goes back (-4611686018427387454us), taking countermeasures.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.000 ms</span><br><span class="line">wrong data byte #53 should be 0x35 but was 0xb5</span><br><span class="line">#1610 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f</span><br><span class="line">#4830 31 32 33 34 b5 36 37</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;5 ttl&#x3D;64 time&#x3D;0.476 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="5-模拟包乱序">5. 模拟包乱序</h4><p>网络传输并不能保证顺序，传输层 TCP 会对报文进行重组保证顺序，所以报文乱序对应用的影响比上面的几种问题要小。</p><p>报文乱序和前面的参数不太一样，因为上面的报文问题都是独立的。针对单个报文做操作就行，而乱序则牵涉到多个报文的重组。模拟报乱序一定会用到延迟（因为模拟乱序的本质就是把一些包延迟发送），Netem 有两种方法可以做。</p><p>第一种是固定的每隔一定数量的报文就乱序一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 每 5 个报文（第 5、10、15…报文）会正常发送，其他的报文延迟 100ms。</span><br><span class="line">$ tc qdisc change dev enp0s5 root netem reorder 50% gap 3 delay 100ms</span><br><span class="line">$ ping -i 0.05 dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;9 ttl&#x3D;64 time&#x3D;2.55 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;8 ttl&#x3D;64 time&#x3D;100 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;10 ttl&#x3D;64 time&#x3D;100 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;11 ttl&#x3D;64 time&#x3D;100 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;13 ttl&#x3D;64 time&#x3D;0.245 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;12 ttl&#x3D;64 time&#x3D;102 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;14 ttl&#x3D;64 time&#x3D;1.00 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>要想看到 ping 报文的乱序，我们要保证发送报文的间隔小于报文的延迟时间 <code>100ms</code>，这里用 <code>-i 0.05</code> 把发送间隔设置为 <code>50ms</code>。</p><p>第二种方法的乱序是相对随机的，使用概率来选择乱序的报文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc change dev enp0s5 root netem reorder 50% 15% delay 300ms</span><br><span class="line">$ ping -i 0.05 dev-node-02</span><br><span class="line">PING dev-node-02 (192.168.100.212) 56(84) bytes of data.</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.423 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;7 ttl&#x3D;64 time&#x3D;0.250 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;301 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;301 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;9 ttl&#x3D;64 time&#x3D;0.238 ms</span><br><span class="line">64 bytes from dev-node-02 (192.168.100.212): icmp_seq&#x3D;5 ttl&#x3D;64 time&#x3D;301 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>50% 的报文会正常发送，其他报文（1-50%）延迟 300ms 发送，这里选择的延迟很大是为了能够明显看出来乱序的结果。</p><h4 id="6-其它技巧">6. 其它技巧</h4><ul><li>查看已经配置的网络条件</li></ul><p>该命令将查看并显示 enp0s5 网卡的相关传输配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc show dev enp0s5</span><br></pre></td></tr></table></figure><h3 id="推荐两个工具">推荐两个工具</h3><p>Netem 在 TC 中算是比较简单的模块，如果要实现流量控制或者精细化的过滤需要更复杂的配置。这里推荐两个小工具，它们共同的特点是用法简单，能满足特定的需求，而不用自己去倒腾 TC 的命令。</p><h4 id="1-wondershaper">1. Wondershaper</h4><p>项目地址：<a href="https://github.com/magnific0/wondershaper" target="_blank" rel="noopener">https://github.com/magnific0/wondershaper</a></p><p>Netem 只能模拟网络状况，不能控制带宽，<a href="https://www.hecticgeek.com/2012/02/simple-traffic-shaping-ubuntu-linux/" target="_blank" rel="noopener">Wondershaper</a> 则能完美解决这个问题。Wondershaper 实际上是一个 SHELL 脚本，它使用 TC 来进行流量速率调整，使用 QoS 来处理特定的网络接口。外发流量通过放在不同优先级的队列中，来达到限制传出流量速率的目的；而传入流量通过丢包的方式来达到速率限制的目的。</p><h5 id="安装-wondershaper">安装 Wondershaper</h5><ul><li>在 Ubuntu / Debian 下安装 Wondershaper</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install wondershaper</span><br></pre></td></tr></table></figure><ul><li>在 Fdora / CentOS / RHEL 中安装 Wondershaper</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 需启用 EPEL 仓库</span><br><span class="line">$ sudo yum install wondershaper</span><br></pre></td></tr></table></figure><h5 id="使用-wondershaper">使用 Wondershaper</h5><p>Wondershaper 的使用非常简单，只有三个参数：网卡名、下行限速、上行限速。比如要设置网卡下载速度为 200kb/s，上传速度为 <code>150kb/s</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo wondershaper enp0s5 200 150</span><br></pre></td></tr></table></figure><p>如果你要将速率限制消除，可以通过运行下面的命令来达到目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo wondershaper clear enp0s5</span><br></pre></td></tr></table></figure><h4 id="2-comcast">2. Comcast</h4><p>项目地址：<a href="https://github.com/tylertreat/comcast" target="_blank" rel="noopener">https://github.com/tylertreat/comcast</a></p><p><a href="https://github.com/tylertreat/comcast" target="_blank" rel="noopener">Comcast</a> 是一个跨平台的网络模拟工具，旨在其他平台（OSX、Windows、BSD）也能提供类似网络模拟的功能。</p><p>它的使用也相对简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ comcast --device&#x3D;enp0s5 --latency&#x3D;250 \</span><br><span class="line">    --target-bw&#x3D;1000 \</span><br><span class="line">    --default-bw&#x3D;1000000 \</span><br><span class="line">    --packet-loss&#x3D;10% \</span><br><span class="line">    --target-addr&#x3D;8.8.8.8,10.0.0.0&#x2F;24 \</span><br><span class="line">    --target-proto&#x3D;tcp,udp,icmp \</span><br><span class="line">    --target-port&#x3D;80,22,1000:2000</span><br></pre></td></tr></table></figure><ul><li><code>--device</code> 说明要控制的网卡为 <code>enp0s5</code>。</li><li><code>--latency</code> 指定 250ms 的延迟。</li><li><code>--target-bw</code>指定目标带宽。</li><li><code>--default-bw</code> 指定默认带宽。</li><li><code>--packet-loss</code> 指定丢包率。</li><li><code>--target-addr</code>、<code>--target-proto</code>、<code>--target-port</code> 参数指定在满足这些条件的报文上实施上面的配置。</li></ul><h3 id="总结">总结</h3><p>可以看出，TC 的 Netem 模块主要用来模拟各种网络的异常状况，本身并没有提供宽带限制的功能，而且一旦在网卡上配置了 Netem，该网卡上所有的报文都会受影响，如果想精细地控制部分报文，需要用到 TC 的 <a href="http://lartc.org/howto/lartc.qdisc.filters.html" target="_blank" rel="noopener">filter</a> 功能。</p><h3 id="参考资料">参考资料</h3><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a><br><a href="http://t.cn/RsUAV3y" target="_blank" rel="noopener">http://t.cn/RsUAV3y</a><br><a href="http://t.cn/RsUwmQX" target="_blank" rel="noopener">http://t.cn/RsUwmQX</a><br><a href="http://t.cn/RsUVqk0" target="_blank" rel="noopener">http://t.cn/RsUVqk0</a></p><blockquote><p>本文在 「使用 tc netem 模拟网络异常」的基础上整理和修改，原文地址：<a href="http://t.cn/RsUwmQX%E3%80%82" target="_blank" rel="noopener">http://t.cn/RsUwmQX。</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某些情况下，我们需要模拟网络很差的状态来测试软件能够正常工作，比如网络延迟、丢包、乱序、重复等。Linux 系统下强大的流量控制工具 TC 能很轻松地完成这个需求，TC 命令行工具是 &lt;code&gt;IProute2&lt;/code&gt; 软件包中的软件，可以根据系统版本自行安装。&lt;/p&gt;
&lt;p&gt;这篇文章介绍的功能主要是通过 &lt;code&gt;Netem&lt;/code&gt; 这个内核模块来实现的。&lt;code&gt;Netem&lt;/code&gt; 是 &lt;code&gt;Network Emulator&lt;/code&gt; 的缩写，关于更多功能以及参数的详细解释可以参阅 &lt;code&gt;TC-Netem&lt;/code&gt; 的 Man Page。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Netem 与 TC 简要说明&lt;/p&gt;
&lt;p&gt;Netem 是 Linux 2.6 及以上内核版本提供的一个网络模拟功能模块。该功能模块可以用来在性能良好的局域网中，模拟出复杂的互联网传输性能。例如:低带宽、传输延迟、丢包等等情况。使用 Linux 2.6 (或以上) 版本内核的很多 Linux 发行版都默认开启了该内核模块，比如：Fedora、Ubuntu、Redhat、OpenSuse、CentOS、Debian 等等。&lt;/p&gt;
&lt;p&gt;TC 是 Linux 系统中的一个用户态工具，全名为 Traffic Control (流量控制)。TC 可以用来控制 Netem 模块的工作模式，也就是说如果想使用 Netem 需要至少两个条件，一是内核中的 Netem 模块被启用，另一个是要有对应的用户态工具 TC 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TC 能做的事情很多，除了本文介绍的还有带宽控制、优先级控制等等。这些功能是通过类似 Netem 的内核模块实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>关于 Kubernetes Master 高可用的一些策略</title>
    <link href="https://www.hi-linux.com/posts/2897.html"/>
    <id>https://www.hi-linux.com/posts/2897.html</id>
    <published>2018-09-05T01:00:00.000Z</published>
    <updated>2018-09-05T08:36:24.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 高可用也许是完成了初步的技术评估，打算将生产环境迁移进 Kubernetes 集群之前普遍面临的问题。 为了减少因为服务器当机引起的业务中断，生产环境中的业务系统往往已经做好了高可用，而当引入 Kubernetes 这一套新的集群管理系统之后，服务器不再是单一的个体，位于中央位置的 Kubernetes Master 一旦中断服务，将导致所有 Node 节点均不可控，有可能造成严重的事故。</p><p>总体来讲这是一个<a href="https://kubernetes.io/docs/admin/high-availability/" target="_blank" rel="noopener">被多次讨论</a>，但暂时<a href="https://kubernetes.io/docs/tasks/administer-cluster/highly-available-master/" target="_blank" rel="noopener">没有形成统一解决方案</a>的话题。今天主要介绍一些 Kubernetes Master 高可用的策略，供大家参考。</p><h3 id="一个小目标">一个小目标</h3><p>高可用是复杂的系统工程。出于篇幅的考虑以及能力的限制，今天我们先关注一个小目标：所有的 Kubernetes Master 服务器没有单点故障，任何一台服务器当机均不影响 Kubernetes 的正常工作。</p><p>实现这一目标带来的直接收益是我们可以在不影响业务正常运行的前提下实现所有服务器的滚动升级，有助于完成系统组件升级以及安全补丁的下发。</p><p>为了实现没有单点故障的目标，需要为以下几个组件建立高可用方案：</p><ul><li><a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">etcd</a></li><li><a href="https://kubernetes.io/docs/admin/kube-apiserver/" target="_blank" rel="noopener">kube-apiserver</a></li><li><a href="https://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="noopener">kube-controller-manager</a> 与 <a href="https://kubernetes.io/docs/admin/kube-scheduler/" target="_blank" rel="noopener">kube-scheduler</a></li><li><a href="https://github.com/kubernetes/dns" target="_blank" rel="noopener">kube-dns</a></li></ul><p>这些组件的关系可参考下面这张集群架构示意图。</p><p><img src="https://www.hi-linux.com/img/linux/kubernetes-architecture.png" alt=""></p><p>下面为大家逐个详细介绍各个组件的高可用策略。</p><a id="more"></a><h3 id="etcd高可用">etcd高可用</h3><p>etcd 是 Kubernetes 当中唯一带状态的服务，也是高可用的难点。Kubernetes 选用 etcd 作为它的后端数据存储仓库正是看重了其使用分布式架构，没有单点故障的特性。</p><p>虽然单节点的 etcd 也可以正常运行。但是推荐的部署方案均是采用 3 个或者 5 个节点组成 etcd 集群，供 Kubernetes 使用。</p><p>大家常使用的 <a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="noopener">kubeadm</a> 工具默认是在一个单节点上启动 etcd 以及所有的 Master 组件。虽然使用起来非常方便，但是要用到生产环境还是要注意这个节点当机的风险。</p><p>etcd 的高可用基本有三种思路：</p><p>一是使用独立的 etcd 集群，使用 3 台或者 5 台服务器只运行 etcd，独立维护和升级。甚至可以使用 CoreOS 的 update-engine 和 locksmith 让服务器完全自主的完成升级。这个 etcd 集群将作为基石用于构建整个集群。采用这项策略的主要动机是 etcd 集群的节点增减都需要显式的通知集群，保证 etcd 集群节点稳定可以更方便的用程序完成集群滚动升级，减轻维护负担。</p><p>二是在 Kubernetes Master 上用 static pod 的形式来运行 etcd，并将多台 Kubernetes Master 上的 etcd 组成集群。 在这一模式下，各个服务器的 etcd 实例被注册进了 Kubernetes 当中，虽然无法直接使用 kubectl 来管理这部分实例，但是监控以及日志搜集组件均可正常工作。在这一模式运行下的 etcd 可管理性更强。</p><p>三是使用 CoreOS 提出的 <a href="https://github.com/kubernetes-incubator/bootkube/issues/31" target="_blank" rel="noopener">self-hosted etcd</a> 方案，将本应在底层为 Kubernetes 提供服务的 etcd 运行在 Kubernetes 之上。 实现 Kubernetes 对自身依赖组件的管理。在这一模式下的 etcd 集群可以直接使用 <a href="https://github.com/coreos/etcd-operator" target="_blank" rel="noopener">etcd-operator</a> 来自动化运维，最符合 Kubernetes 的使用习惯。</p><p>这三种思路均可以实现 etcd 高可用的目标，但是在选择过程中却要根据实际情况做出一些判断。简单来讲预算充足但保守的项目选方案一， 想一步到位并愿意承担一定风险的项目选方案三。折中一点选方案二。各个方案的优劣以及做选择过程中的取舍在这里就不详细展开了，对这块有疑问的朋友可以私下联系交流。</p><h3 id="kube-apiserver-高可用">kube-apiserver 高可用</h3><p>apiserver 本身是一个无状态服务，要实现其高可用相对要容易一些，难点在于如何将运行在多台服务器上的 apiserver 用一个统一的外部入口暴露给所有 Node 节点。</p><p>说是难点，其实对于这种无状态服务的高可用，我们在设计业务系统的高可用方案时已经有了相当多的经验积累。需要注意的是 apiserver 所使用的 SSL 证书要包含外部入口的地址，不然 Node 节点无法正常访问 apiserver。</p><p>apiserver 的高可用也有三种基本思路：</p><p>一是使用外部负载均衡器，不管是使用公有云提供的负载均衡器服务或是在私有云中使用 LVS 或者 HaProxy 自建负载均衡器都可以归到这一类。 负载均衡器是非常成熟的方案，在这里略过不做过多介绍。如何保证负载均衡器的高可用，则是选择这一方案需要考虑的新问题。</p><p>二是在网络层做负载均衡。比如在 Master 节点上用 BGP 做 ECMP，或者在 Node 节点上用 iptables 做 NAT 都可以实现。采用这一方案不需要额外的外部服务，但是对网络配置有一定的要求。</p><p>三是在 Node 节点上使用反向代理对多个 Master 做负载均衡。这一方案同样不需要依赖外部的组件，但是当 Master 节点有增减时，如何动态配置 Node 节点上的负载均衡器成为了另外一个需要解决的问题。</p><p>从目前各个集群管理工具的选择来看，这三种模式都有被使用，目前还没有明确的推荐方案产生。建议在公有云上的集群多考虑第一种模式，在私有云环境中由于维护额外的负载均衡器也是一项负担，建议考虑第二种或是第三种方案。</p><h3 id="kube-controller-manager-与-kube-scheduler-高可用">kube-controller-manager 与 kube-scheduler 高可用</h3><p>这两项服务是 Master 节点的一部分，他们的高可用相对容易，仅需要运行多份实例即可。这些实例会通过向 apiserver 中的 Endpoint 加锁的方式来进行 leader election， 当目前拿到 leader 的实例无法正常工作时，别的实例会拿到锁，变为新的 leader。</p><p>目前在多个 Master 节点上采用 static pod 模式部署这两项服务的方案比较常见，激进一点也可以采用 self-hosted 的模式，在 Kubernetes 之上用 DaemonSet 或者 Deployment 来部署。</p><h3 id="kube-dns-高可用">Kube-dns 高可用</h3><p>严格来说 kube-dns 并不算是 Master 组件的一部分，因为它是可以跑在 Node 节点上，并用 Service 向集群内部提供服务的。但在实际环境中，由于默认配置只运行了一份 kube-dns 实例，在其升级或是所在节点当机时，会出现集群内部 dns 服务不可用的情况，严重时会影响到线上服务的正常运行。</p><p>为了避免故障，请将 kube-dns 的 replicas 值设为 2 或者更多，并用 anti-affinity 将他们部署在不同的 Node 节点上。这项操作比较容易被疏忽，直到出现故障时才发现原来是 kube-dns 只运行了一份实例导致的故障。</p><h3 id="总结">总结</h3><p>上面介绍了 Kubernetes Master 各个组件高可用可以采用的策略。其中 etcd 和 kube-apiserver 的高可用是整个方案的重点。由于存在多种高可用方案，集群管理员应当根据集群所处环境以及其他限制条件选择适合的方案。</p><p>这种没有绝对的通用方案，需要集群建设者根据不同的现状在多个方案中做选择的情况在 Kubernetes 集群建设过程中频频出现， 也是整个建设过程中最有挑战的一部分。容器网络方案的选型作为 Kubernetes 建设过程中需要面对的另外一个大问题也属于这种情况，今后有机会再来分享这个话题。</p><p>在实际建设过程中，在完成了上述四个组件的高可用之后，最好采取实际关机检验的方式来验证高可用方案的可靠性，并根据检验的结果不断调整和优化整个方案。</p><p>此外将高可用方案与系统自动化升级方案结合在一起考虑，实现高可用下的系统自动升级，将大大减轻集群的日常运维负担，值得投入精力去研究。</p><p>虽然本篇主要在讲 Kubernetes Master 高可用的方案，但需要指出的是高可用也并不是必须的，为了实现高可用所付出的代价并不低， 需要有相应的收益来平衡。对于大量的小规模集群来说，业务系统并没有实现高可用，贸然去做集群的高可用收益有限。这时采用单 Master 节点的方案，做好 etcd 的数据备份，不失为理性的选择。</p><blockquote><p>来源：极术<br>原文：<a href="http://t.cn/Rs72Axn" target="_blank" rel="noopener">http://t.cn/Rs72Axn</a><br>题图：来自谷歌图片搜索<br>版权：本文版权归原作者所有</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://kubernetes.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kubernetes&lt;/a&gt; 高可用也许是完成了初步的技术评估，打算将生产环境迁移进 Kubernetes 集群之前普遍面临的问题。 为了减少因为服务器当机引起的业务中断，生产环境中的业务系统往往已经做好了高可用，而当引入 Kubernetes 这一套新的集群管理系统之后，服务器不再是单一的个体，位于中央位置的 Kubernetes Master 一旦中断服务，将导致所有 Node 节点均不可控，有可能造成严重的事故。&lt;/p&gt;
&lt;p&gt;总体来讲这是一个&lt;a href=&quot;https://kubernetes.io/docs/admin/high-availability/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;被多次讨论&lt;/a&gt;，但暂时&lt;a href=&quot;https://kubernetes.io/docs/tasks/administer-cluster/highly-available-master/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;没有形成统一解决方案&lt;/a&gt;的话题。今天主要介绍一些 Kubernetes Master 高可用的策略，供大家参考。&lt;/p&gt;
&lt;h3 id=&quot;一个小目标&quot;&gt;一个小目标&lt;/h3&gt;
&lt;p&gt;高可用是复杂的系统工程。出于篇幅的考虑以及能力的限制，今天我们先关注一个小目标：所有的 Kubernetes Master 服务器没有单点故障，任何一台服务器当机均不影响 Kubernetes 的正常工作。&lt;/p&gt;
&lt;p&gt;实现这一目标带来的直接收益是我们可以在不影响业务正常运行的前提下实现所有服务器的滚动升级，有助于完成系统组件升级以及安全补丁的下发。&lt;/p&gt;
&lt;p&gt;为了实现没有单点故障的目标，需要为以下几个组件建立高可用方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/coreos/etcd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;etcd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/admin/kube-apiserver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kube-apiserver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/admin/kube-controller-manager/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kube-controller-manager&lt;/a&gt; 与 &lt;a href=&quot;https://kubernetes.io/docs/admin/kube-scheduler/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kube-scheduler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes/dns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kube-dns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些组件的关系可参考下面这张集群架构示意图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/kubernetes-architecture.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面为大家逐个详细介绍各个组件的高可用策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Docker 最佳实践之多阶段构建</title>
    <link href="https://www.hi-linux.com/posts/55545.html"/>
    <id>https://www.hi-linux.com/posts/55545.html</id>
    <published>2018-09-03T01:00:00.000Z</published>
    <updated>2018-09-03T02:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Docker 目前在容器市场可以说是占领了大部分市场，Docker 掀起了容器革命，同时也改变了现代化云平台的构建方式。尽管 Docker 很强大，但使用过程当中也遇到了一些问题。比如:我想要构建一个编译型语言镜像，需要先在一个 Dockerfile 中编译，然后再使用另外一个 Dockerfile 把编译好的文件放到镜像中。这样无形当中就增大了 CI/CD 的复杂度。</p><blockquote><p>Docker 多阶段构建是 17.05 以后引入的新特性，旨在解决编译和构建复杂的问题。因此要使用多阶段构建特性必须使用高于或等于 17.05 的 Docker。</p></blockquote><h3 id="多阶段构建出现之前">多阶段构建出现之前</h3><ul><li>构建镜像最具挑战性的一点是使镜像大小尽可能的小。Dockerfile 中的每条指令都为镜像添加了一个镜像层，您需要记住在移动到下一个镜像层之前清理任何不需要的组件。</li><li>为了编写一个真正高效的 Dockerfile，传统上需要使用 Shell 技巧和其它逻辑来保持镜像层尽可能小，并确保每个镜像层都具有前一层所需的组件而不是其它任何东西。</li></ul><p>很多时候我们用一个 Dockerfile 维护开发环境（包含构建应用程序所需的所有内容），用另一个 Dockerfile 维护生产环境（只包含您的应用程序以及运行它所需的内容）。实际上同时维护两个 Dockerfiles 并不是一种理想的构建模式，这种模式被称为建造者模式。</p><p>我们来看一个例子，这是一个 Dockerfile.build 和 Dockerfile 的例子，它遵循上面的模式。</p><p><strong>Dockerfile.build</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR &#x2F;go&#x2F;src&#x2F;github.com&#x2F;alexellis&#x2F;href-counter&#x2F;</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN go get -d -v golang.org&#x2F;x&#x2F;net&#x2F;html \</span><br><span class="line">  &amp;&amp; CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o app .</span><br></pre></td></tr></table></figure><p>请注意，此示例使用 Bash <code>&amp;&amp;</code> 运算符人为合并两个 RUN 命令，以避免在 Image 中创建出其它层。这种方法很容易出错并且难以维护。</p><a id="more"></a><p><strong>Dockerfile</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:latest  </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR &#x2F;root&#x2F;</span><br><span class="line">COPY app .</span><br><span class="line">CMD [&quot;.&#x2F;app&quot;]</span><br></pre></td></tr></table></figure><p><strong><a href="http://build.sh" target="_blank" rel="noopener">build.sh</a></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> Building alexellis2/href-counter:build</span><br><span class="line">docker build --build-arg https_proxy=<span class="variable">$https_proxy</span> --build-arg http_proxy=<span class="variable">$http_proxy</span> \  </span><br><span class="line">    -t alexellis2/href-counter:build . -f Dockerfile.build</span><br><span class="line">docker container create --name extract alexellis2/href-counter:build  </span><br><span class="line">docker container cp extract:/go/src/github.com/alexellis/href-counter/app ./app  </span><br><span class="line">docker container rm -f extract</span><br><span class="line"><span class="built_in">echo</span> Building alexellis2/href-counter:latest</span><br><span class="line">docker build --no-cache -t alexellis2/href-counter:latest .</span><br><span class="line">rm ./app</span><br></pre></td></tr></table></figure><p>当您运行 <code>build.sh</code> 脚本时，它首先会构建第一个 Image 并从创建容器中复制编译好的程序到本地。然后在第二个 Image 中将构建好的程序运行起来。</p><h3 id="使用多阶段构建">使用多阶段构建</h3><p>从上面的过程中可以看到过程是非常复杂且容易出错的，多阶段构建的出现就大大简化了这种情况！</p><p>对于多阶段构建，您可以在 Dockerfile 中使用多个 FROM 语句。每个 FROM 指令可以使用不同的基础镜像，并且每个 FROM 指令都会开始一个新的构建阶段。您可以选择性地将各构建阶段中的内容从一个阶段复制到另一个阶段，从而在最终 Image 中只留下您想要的内容。</p><p>为了说明这是如何工作的，我们调整上述示例中的 Dockerfile 使用多阶段方式来构建。</p><p><strong>Dockerfile</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR &#x2F;go&#x2F;src&#x2F;github.com&#x2F;alexellis&#x2F;href-counter&#x2F;</span><br><span class="line">RUN go get -d -v golang.org&#x2F;x&#x2F;net&#x2F;html  </span><br><span class="line">COPY app.go .</span><br><span class="line">RUN CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest  </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR &#x2F;root&#x2F;</span><br><span class="line">COPY --from&#x3D;0 &#x2F;go&#x2F;src&#x2F;github.com&#x2F;alexellis&#x2F;href-counter&#x2F;app .</span><br><span class="line">CMD [&quot;.&#x2F;app&quot;]</span><br></pre></td></tr></table></figure><p>可以看到您只需要单个 Dockerfile 并且不需要任何的单独构建脚本，就可以构建出上面相同的 Image。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t app:latest .</span><br></pre></td></tr></table></figure><p>通过 <code>docker build</code> 构建后，最终结果是产生与之前相同大小的 Image，但复杂性显著降低。您不需要创建任何中间 Image，也不需要将任何编译结果临时提取到本地系统。</p><p>哪它是如何工作的呢？关键就在 <code>COPY --from=0</code> 这个指令上。Dockerfile 中第二个 FROM 指令以 alpine:latest 为基础镜像开始了一个新的构建阶段，并通过 <code>COPY --from=0</code> 仅将前一阶段的构建文件复制到此阶段。前一构建阶段中产生的 Go SDK 和任何中间层都会在此阶段中被舍弃，而不是保存在最终 Image 中。</p><h3 id="为多构建阶段命名">为多构建阶段命名</h3><p>默认情况下，构建阶段是未命名的。您可以通过一个整数值来引用它们，默认是从第 0 个 FROM 指令开始的。 为了方便管理，您也可以通过向 FROM 指令添加 as NAME 来命名您的各个构建阶段。下面的示例就通过命名各个构建阶段并在 COPY 指令中使用名称来访问指定的构建阶段。</p><p>这样做的好处就是即使稍后重新排序 Dockerfile 中的指令，COPY 指令一样能找到对应的构建阶段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3 as builder</span><br><span class="line">WORKDIR &#x2F;go&#x2F;src&#x2F;github.com&#x2F;alexellis&#x2F;href-counter&#x2F;</span><br><span class="line">RUN go get -d -v golang.org&#x2F;x&#x2F;net&#x2F;html  </span><br><span class="line">COPY app.go    .</span><br><span class="line">RUN CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest  </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR &#x2F;root&#x2F;</span><br><span class="line">COPY --from&#x3D;builder &#x2F;go&#x2F;src&#x2F;github.com&#x2F;alexellis&#x2F;href-counter&#x2F;app .</span><br><span class="line">CMD [&quot;.&#x2F;app&quot;]</span><br></pre></td></tr></table></figure><h3 id="停在特定的构建阶段">停在特定的构建阶段</h3><p>构建镜像时，不一定需要构建整个 Dockerfile 中每个阶段，您也可以指定需要构建的阶段。比如：您只构建 Dockerfile 中名为 builder 的阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --target builder -t alexellis2&#x2F;href-counter:latest .</span><br></pre></td></tr></table></figure><p>此功能适合以下场景：</p><ul><li>调试特定的构建阶段。</li><li>在 Debug 阶段，启用所有程序调试模式或调试工具，而在生产阶段尽量精简。</li><li>在 Testing 阶段，您的应用程序使用测试数据，但在生产阶段则使用生产数据。</li></ul><h3 id="使用外部镜像作为构建阶段">使用外部镜像作为构建阶段</h3><p>使用多阶段构建时，您不仅可以从 Dockerfile 中创建的镜像中进行复制。您还可以使用 <code>COPY --from</code> 指令从单独的 Image 中复制，支持使用本地 Image 名称、本地或 Docker 注册中心可用的标记或标记 ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY --from&#x3D;nginx:latest &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;nginx.conf</span><br></pre></td></tr></table></figure><blockquote><p>本文在 「Docker 最佳实践之多阶段构建 」的基础上整理和修改，原文地址：<a href="http://t.cn/RFx6ML2" target="_blank" rel="noopener">http://t.cn/RFx6ML2</a> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 目前在容器市场可以说是占领了大部分市场，Docker 掀起了容器革命，同时也改变了现代化云平台的构建方式。尽管 Docker 很强大，但使用过程当中也遇到了一些问题。比如:我想要构建一个编译型语言镜像，需要先在一个 Dockerfile 中编译，然后再使用另外一个 Dockerfile 把编译好的文件放到镜像中。这样无形当中就增大了 CI/CD 的复杂度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker 多阶段构建是 17.05 以后引入的新特性，旨在解决编译和构建复杂的问题。因此要使用多阶段构建特性必须使用高于或等于 17.05 的 Docker。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;多阶段构建出现之前&quot;&gt;多阶段构建出现之前&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建镜像最具挑战性的一点是使镜像大小尽可能的小。Dockerfile 中的每条指令都为镜像添加了一个镜像层，您需要记住在移动到下一个镜像层之前清理任何不需要的组件。&lt;/li&gt;
&lt;li&gt;为了编写一个真正高效的 Dockerfile，传统上需要使用 Shell 技巧和其它逻辑来保持镜像层尽可能小，并确保每个镜像层都具有前一层所需的组件而不是其它任何东西。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多时候我们用一个 Dockerfile 维护开发环境（包含构建应用程序所需的所有内容），用另一个 Dockerfile 维护生产环境（只包含您的应用程序以及运行它所需的内容）。实际上同时维护两个 Dockerfiles 并不是一种理想的构建模式，这种模式被称为建造者模式。&lt;/p&gt;
&lt;p&gt;我们来看一个例子，这是一个 Dockerfile.build 和 Dockerfile 的例子，它遵循上面的模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dockerfile.build&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FROM golang:1.7.3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WORKDIR &amp;#x2F;go&amp;#x2F;src&amp;#x2F;github.com&amp;#x2F;alexellis&amp;#x2F;href-counter&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;COPY app.go .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN go get -d -v golang.org&amp;#x2F;x&amp;#x2F;net&amp;#x2F;html \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;amp;&amp;amp; CGO_ENABLED&amp;#x3D;0 GOOS&amp;#x3D;linux go build -a -installsuffix cgo -o app .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;请注意，此示例使用 Bash &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符人为合并两个 RUN 命令，以避免在 Image 中创建出其它层。这种方法很容易出错并且难以维护。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>初识 Istio</title>
    <link href="https://www.hi-linux.com/posts/28535.html"/>
    <id>https://www.hi-linux.com/posts/28535.html</id>
    <published>2018-08-28T01:00:00.000Z</published>
    <updated>2018-08-28T08:59:51.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>如果你比较关注新兴技术的话，那么很可能在不同的地方听说过 Istio，并且知道它和 Service Mesh 有着牵扯。这篇文章可以作为了解 Istio 的入门介绍。通过本文你可以了解什么是 Istio，Istio 为什么最近这么火，以及 Istio 能够我们带来什么好处。</p><h3 id="什么是-istio">什么是 Istio？</h3><p>官方对 Istio 的介绍浓缩成了一句话：</p><blockquote><p>An open platform to connect, secure, control and observe services.</p></blockquote><p>翻译过来，就是&quot;连接、安全加固、控制和观察服务的开放平台&quot;。开放平台就是指它本身是开源的，服务对应的是微服务，也可以粗略地理解为单个应用。 中间的四个动词就是 Istio 的主要功能，官方也各有一句话的说明。这里再阐释一下：</p><ul><li>连接（Connect）：智能控制服务之间的调用流量，能够实现灰度升级、AB 测试和红黑部署等功能。</li><li>安全加固（Secure）：自动为服务之间的调用提供认证、授权和加密。</li><li>控制（Control）：应用用户定义的 Policy，保证资源在消费者中公平分配。</li><li>观察（Observe）：查看服务运行期间的各种数据，比如日志、监控和 Tracing，了解服务的运行情况。</li></ul><p><img src="https://www.hi-linux.com/img/linux/istio1.jpg" alt=""></p><a id="more"></a><p>虽然听起来非常高级，功能非常强大，但是一股脑出现这么多名词，还都是非常虚的概念，说了跟没说一样。要想理解上面这几句话的含义，我们还是从头说起，先聊聊 Service Mesh。</p><blockquote><p>NOTE：其实 Istio 的源头是微服务，但这又是一个比较大的话题，目前可以参考网络上各种文章。如果有机会，我们再来聊聊微服务。</p></blockquote><h3 id="什么是-service-mesh">什么是 Service Mesh</h3><p>一般介绍 Service Mesh 的文章都会从网络层的又一个抽象说起，把 Service Mesh 看做建立在 TCP 层之上的微服务层。我这次换个思路，从 Service Mesh 的技术根基——网络代理来分析。</p><p>说起网络代理，如果对软件架构比较熟悉的会想到 Nginx 等反向代理软件。其实网络代理的范围比较广，可以肯定的说，有网络访问的地方就会有代理的存在。</p><p>Wikipedia 对代理的定义如下：</p><blockquote><p>In computer networks, a proxy server is a server (a computer system or an application) that acts as an intermediary for requests from clients seeking resources from other servers.</p></blockquote><p>NOTE：代理可以是嵌套的，也就是说通信双方 A、B 中间可以多层代理，而这些代理的存在有可能对 A、B 是透明的。</p><p>简单来说，网络代理可以简单类比成现实生活中的中介，本来需要通信的双方因为各种原因在中间再加上一道关卡。本来双方就能完成的通信，为何非要多此一举呢？那是因为代理可以为整个通信带来更多的功能，比如：</p><ul><li>拦截：代理可以选择性拦截传输的网络流量，比如：一些公司限制员工在上班的时候不能访问某些游戏或者电商网站，数据中心中拒绝恶意访问网关等。</li><li>统计：既然所有的流量都经过代理，那么代理也可以用来统计网络中的数据信息，比如了解哪些人在访问哪些网站，通信的应答延迟等。</li><li>缓存：如果通信双方比较远，访问比较慢，那么代理可以把最近访问的数据缓存在本地，后面的访问不用访问后端来做到加速。CDN 就是这个功能的典型场景。</li><li>分发：如果某个通信方有多个服务器后端，代理可以根据某些规则来选择如何把流量发送给多个服务器，也就是我们常说的负载均衡功能。比如著名的 Nginx 软件。</li><li>跳板：如果 A、B 双方因为某些原因不能直接访问，而代理可以和双方通信，那么通过代理，双方可以绕过原来的限制进行通信。这应该是国内网民比较熟悉的场景。</li><li>注入：既然代理可以看到流量，那么它也可以修改网络流量，可以自动在收到的流量中添加一些数据，比如有些宽带提供商的弹窗广告。</li><li>……</li></ul><p><img src="https://www.hi-linux.com/img/linux/istio2.jpg" alt=""></p><p>不是要讲 Service Mesh 吗？为什么扯了一堆代理的事情？因为 Service Mesh 可以看做是传统代理的升级版，用来解决现在微服务框架中出现的问题，可以把 Service Mesh 看做是分布式的微服务代理。</p><p>在传统模式下，代理一般是集中式的单独的服务器，所有的请求都要先通过代理，然后再流入转发到实际的后端。而在 Service Mesh 中，代理变成了分布式的，它常驻在了应用的身边（最常见的就是 Kubernetes Sidecar 模式，每一个应用的 Pod 中都运行着一个代理，负责流量相关的事情）。这样的话，应用所有的流量都被代理接管，那么这个代理就能做到上面提到的所有可能的事情，从而带来无限的想象力。</p><p><img src="https://www.hi-linux.com/img/linux/istio3.jpg" alt=""></p><p>此外，原来的代理都是基于网络流量的，一般都是工作在 IP 或者 TCP 层，很少关心具体的应用逻辑。但是 Service Mesh 中，代理会知道整个集群的所有应用信息，并且额外添加了热更新、注入服务发现、降级熔断、认证授权、超时重试、日志监控等功能，让这些通用的功能不必每个应用都自己实现，放在代理中即可。换句话说，Service Mesh 中的代理对微服务中的应用做了定制化的改进！</p><p><img src="https://www.hi-linux.com/img/linux/istio4.jpg" alt=""></p><p>就这样，借着微服务和容器化的东风，传统的代理摇身一变，成了如今炙手可热的 Service Mesh。应用微服务之后，每个单独的微服务都会有很多副本，而且可能会有多个版本，这么多微服务之间的相互调用和管理非常复杂，但是有了 Service Mesh，我们可以把这块内容统一在代理层。</p><p><img src="https://www.hi-linux.com/img/linux/istio5.gif" alt=""></p><p>有了看起来四通八达的分布式代理，我们还需要对这些代理进行统一的管理。手动更新每个代理的配置，对代理进行升级或者维护是个不可持续的事情，在前面的基础上，在加上一个控制中心，一个完整的 Service Mesh 就成了。管理员只需要根据控制中心的 API 来配置整个集群的应用流量、安全规则即可，代理会自动和控制中心打交道根据用户的期望改变自己的行为。</p><p><img src="https://www.hi-linux.com/img/linux/istio6.jpg" alt=""></p><blockquote><p>NOTE：所以你也可以理解 Service Mesh 中的代理会抢了 Nginx 的生意，这也是为了 Nginx 也要开始做 NginMesh 的原因。</p></blockquote><h3 id="再来看-istio">再来看 Istio</h3><p>了解了 Service Mesh 的概念，我们再来看 Istio ，也许就会清楚很多。首先来看 Istio 官方给出的架构图：</p><p><img src="https://www.hi-linux.com/img/linux/istio7.jpg" alt=""></p><p>可以看到，Istio 就是我们上述提到的 Service Mesh 架构的一种实现，服务之间的通信（比如这里的 Service A 访问 Service B）会通过代理（默认是 Envoy）来进行，而且中间的网络协议支持 HTTP/1.1、HTTP/2、gRPC 或者 TCP，可以说覆盖了主流的通信协议。控制中心做了进一步的细分，分成了 Pilot、Mixer、和 Citadel，它们的各自功能如下：</p><ul><li>Pilot：为 Envoy 提供了服务发现，流量管理和智能路由（AB测试、金丝雀发布等），以及错误处理（超时、重试、熔断）功能。用户通过 Pilot 的 API 管理网络相关的资源对象，Pilot 会根据用户的配置和服务的信息把网络流量管理变成 Envoy 能识别的格式分发到各个 Sidecar 代理中。</li><li>Mixer：为整个集群执行访问控制（哪些用户可以访问哪些服务）和 Policy 管理（Rate Limit，Quota 等），并且收集代理观察到的服务之间的流量统计数据。</li><li>Citadel：为服务之间提供认证和证书管理，可以让服务自动升级成 TLS 协议。</li></ul><p>代理会和控制中心通信，一方面可以获取需要的服务之间的信息，另一方面也可以汇报服务调用的 Metrics 数据。知道 Istio 的核心架构，再来看看它的功能描述就非常容易理解了。</p><ul><li>连接：控制中心可以从集群中获取所有服务的信息，并分发给代理，这样代理就能根据用户的期望来完成服务之间的通信（自动地服务发现、负载均衡、流量控制等）。</li><li>安全加固：因为所有的流量都是通过代理的，那么代理接收到不加密的网络流量之后，可以自动做一次封装，把它升级成安全的加密流量。</li><li>控制：用户可以配置各种规则（比如 RBAC 授权、白名单、Rate Limit 或者 Quota 等），当代理发现服务之间的访问不符合这些规则，就直接拒绝掉。</li><li>观察：所有的流量都经过代理，因此代理对整个集群的访问情况知道得一清二楚，它把这些数据上报到控制中心，那么管理员就能观察到整个集群的流量情况了。</li></ul><h3 id="istio-解决什么问题">Istio 解决什么问题</h3><p>虽然看起来非常炫酷，功能也很强大，但是一个架构和产品出来都是要解决具体的问题。所以这部分我们来看看微服务架构中的难题以及 Istio 给出的答案。</p><p>首先，原来的单个应用拆分成了许多分散的微服务，它们之间相互调用才能完成一个任务，而一旦某个过程出错（组件越多，出错的概率也就越大），就非常难以排查。</p><p>用户请求出现问题无外乎两个问题：错误和响应慢。如果请求错误，那么我们需要知道那个步骤出错了，这么多的微服务之间的调用怎么确定哪个有调用成功？哪个没有调用成功呢？如果是请求响应太慢，我们就需要知道到底哪些地方比较慢？整个链路的调用各阶段耗时是多少？哪些调用是并发执行的，哪些是串行的？这些问题需要我们能非常清楚整个集群的调用以及流量情况。</p><p><img src="https://www.hi-linux.com/img/linux/istio8.jpg" alt=""></p><p>此外，微服务拆分成这么多组件，如果单个组件出错的概率不变，那么整体有地方出错的概率就会增大。服务调用的时候如果没有错误处理机制，那么会导致非常多的问题。比如如果应用没有配置超时参数，或者配置的超时参数不对，则会导致请求的调用链超时叠加，对于用户来说就是请求卡住了；如果没有重试机制，那么因为各种原因导致的偶发故障也会导致直接返回错误给用户，造成不好的用户体验；此外，如果某些节点异常（比如网络中断，或者负载很高），也会导致应用整体的响应时间变成，集群服务应该能自动避开这些节点上的应用；最后，应用也是会出现 Bug 的，各种 Bug 会导致某些应用不可访问。这些问题需要每个应用能及时发现问题，并做好对应的处理措施。</p><p><img src="https://www.hi-linux.com/img/linux/istio9.jpg" alt=""></p><p>应用数量的增多，对于日常的应用发布来说也是个难题。应用的发布需要非常谨慎，如果应用都是一次性升级的，出现错误会导致整个线上应用不可用，影响范围太大；而且，很多情况我们需要同时存在不同的版本，使用 AB 测试验证哪个版本更好；如果版本升级改动了 API，并且互相有依赖，那么我们还希望能自动地控制发布期间不同版本访问不同的地址。这些问题都需要智能的流量控制机制。</p><p><img src="https://www.hi-linux.com/img/linux/istio10.jpg" alt=""></p><p>为了保证整个系统的安全性，每个应用都需要实现一套相似的认证、授权、HTTPS、限流等功能。一方面大多数的程序员都安全相关的功能并不擅长或者感兴趣，另外这些完全相似的内容每次都要实现一遍是非常冗余的。这个问题需要一个能自动管理安全相关内容的系统。</p><p><img src="https://www.hi-linux.com/img/linux/istio11.jpg" alt=""></p><p>上面提到的这些问题是不是非常熟悉？它们就是 istio 尝试解决的问题，如果把上面的问题和 istio 提供的功能做个映射，你会发现它们是非常匹配，毕竟 istio 就是为了解决微服务的这些问题才出现的。</p><p><img src="https://www.hi-linux.com/img/linux/istio12.gif" alt=""></p><h3 id="用什么姿势接入-istio">用什么姿势接入 Istio？</h3><p>虽然 Istio 能解决那么多的问题，但是引入 Istio 并不是没有代价的。最大的问题是 Istio 的复杂性，强大的功能也意味着 Istio 的概念和组件非常多，要想理解和掌握 Istio ，并成功在生产环境中部署需要非常详细的规划。一般情况下，集群管理团队需要对 Kubernetes 非常熟悉，了解常用的使用模式，然后采用逐步演进的方式把 Istio 的功能分批掌控下来。</p><p>第一步，自然是在测试环境搭建一套 Istio 的集群，理解所有的核心概念和组件。了解 Istio 提供的接口和资源，知道它们的用处，思考如何应用到自己的场景中，然后是熟悉 Istio 的源代码，跟进社区的 Issues，了解目前还存在的 Issues 和 Bug，思考如何规避或者修复。这一步是基础，需要积累到 Istio 安装部署、核心概念、功能和缺陷相关的知识，为后面做好准备。</p><p>第二步，可以考虑接入 Istio 的观察性功能，包括 Logging、Tracing、Metrics 数据。应用部署到集群中，选择性地（一般是流量比较小，影响范围不大的应用）为一些应用开启 Istio 自动注入功能，接管应用的流量，并安装 Prometheus 和 Zipkin 等监控组件，收集系统所有的监控数据。这一步可以试探性地了解 Istio 对应用的性能影响，同时建立服务的性能测试基准，发现服务的性能瓶颈，帮助快速定位应用可能出现的问题。此时，这些功能可以是对应用开发者透明的，只需要集群管理员感知，这样可以减少可能带来的风险。</p><p>第三步，为应用配置 Timeout 超时参数、自动重试、熔断和降级等功能，增加服务的容错性。这样可以避免某些应用错误进行这些配置导致问题的出现，这一步完成后需要通知所有的应用开发者删除掉在应用代码中对应的处理逻辑。这一步需要开发者和集群管理员同时参与。</p><p>第四步，和 Ingress、Helm、应用上架等相关组件和流程对接，使用 Istio 接管应用的升级发布流程。让开发者可以配置应用灰度发布升级的策略，支持应用的蓝绿发布、金丝雀发布以及 AB 测试。</p><p>第五步，接入安全功能。配置应用的 TLS 互信，添加 RBAC 授权，设置应用的流量限制，提升整个集群的安全性。因为安全的问题配置比较繁琐，而且优先级一般会比功能性相关的特性要低，所以这里放在了最后。</p><p>当然这个步骤只是一个参考，每个公司需要根据自己的情况、人力、时间和节奏来调整，找到适合自己的方案。</p><h3 id="总结">总结</h3><p>Istio 的架构在数据中心和集群管理中非常常见，每个 Agent 分布在各个节点上（可以是服务器、虚拟机、Pod、容器）负责接收指令并执行，以及汇报信息；控制中心负责汇聚整个集群的信息，并提供 API 让用户对集群进行管理。Kubernetes 也是类似的架构，SDN（Software Defined Network） 也是如此。相信以后会有更多类似架构的出现，这是因为数据中心要管理的节点越来越多，我们需要把任务执行分布到各节点（Agent 负责的功能），同时也需要对整个集群进行管理和控制（Control Plane 的功能），完全去中心化的架构是无法满足后面这个要求的。</p><p>Istio 的出现为负责的微服务架构减轻了很多的负担，开发者不用关心服务调用的超时、重试、Rate Limit 的实现，服务之间的安全、授权也自动得到了保证；集群管理员也能够很方便地发布应用（AB 测试和灰度发布），并且能清楚看到整个集群的运行情况。</p><p>但是这并不表明有了 Istio 就可以高枕无忧了，Istio 只是把原来分散在应用内部的复杂性统一抽象出来放到了统一的地方，并没有让原来的复杂消失不见。因此我们需要维护 Istio 整个集群，而 Istio 的架构比较复杂，尤其是它一般还需要架在 Kubernetes 之上，这两个系统都比较复杂，而且它们的稳定性和性能会影响到整个集群。因此再采用 Isito 之前，必须做好清楚的规划，权衡它带来的好处是否远大于额外维护它的花费，需要有相关的人才对整个网络、Kubernetes 和 Istio 都比较了解才行。</p><h3 id="参考资料">参考资料</h3><p><a href="https://istio.io/docs/concepts/what-is-istio/" target="_blank" rel="noopener">Istio / What is Istio?</a>：Istio 官网上对 Istio 进行介绍的文档<br><a href="http://philcalcado.com/2017/08/03/pattern_service_mesh.html" target="_blank" rel="noopener">Pattern: Service Mesh</a>：Service Mesh Pattern 详解的文章</p><blockquote><p>来源：Cizixs Writes Here<br>原文：<a href="http://t.cn/RkksFOW" target="_blank" rel="noopener">http://t.cn/RkksFOW</a><br>题图：来自谷歌图片搜索<br>版权：本文版权归原作者所有</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你比较关注新兴技术的话，那么很可能在不同的地方听说过 Istio，并且知道它和 Service Mesh 有着牵扯。这篇文章可以作为了解 Istio 的入门介绍。通过本文你可以了解什么是 Istio，Istio 为什么最近这么火，以及 Istio 能够我们带来什么好处。&lt;/p&gt;
&lt;h3 id=&quot;什么是-Istio？&quot;&gt;什么是 Istio？&lt;/h3&gt;
&lt;p&gt;官方对 Istio 的介绍浓缩成了一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An open platform to connect, secure, control and observe services.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来，就是&amp;quot;连接、安全加固、控制和观察服务的开放平台&amp;quot;。开放平台就是指它本身是开源的，服务对应的是微服务，也可以粗略地理解为单个应用。 中间的四个动词就是 Istio 的主要功能，官方也各有一句话的说明。这里再阐释一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接（Connect）：智能控制服务之间的调用流量，能够实现灰度升级、AB 测试和红黑部署等功能。&lt;/li&gt;
&lt;li&gt;安全加固（Secure）：自动为服务之间的调用提供认证、授权和加密。&lt;/li&gt;
&lt;li&gt;控制（Control）：应用用户定义的 Policy，保证资源在消费者中公平分配。&lt;/li&gt;
&lt;li&gt;观察（Observe）：查看服务运行期间的各种数据，比如日志、监控和 Tracing，了解服务的运行情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/istio1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>使用 IPVS 实现 Kubernetes 入口流量负载均衡</title>
    <link href="https://www.hi-linux.com/posts/29792.html"/>
    <id>https://www.hi-linux.com/posts/29792.html</id>
    <published>2018-08-27T01:00:00.000Z</published>
    <updated>2018-08-27T06:17:59.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>新搭建的 Kubernetes 集群如何承接外部访问的流量，是刚上手 Kubernetes 时常常会遇到的问题。 在公有云上，官方给出了比较直接的答案，使用 LoadBalancer 类型的 Service，利用公有云提供的负载均衡服务来承接流量，同时在多台服务器之间进行负载均衡。</p><p>而在私有环境中，如何正确的将外部流量引入到集群内部，却暂时没有标准的做法。 本文将介绍一种基于 IPVS 来承接流量并实现负载均衡的方法，供大家参考。在阅读本文前建议先了解文中相关基础知识点，推荐阅读下「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486130&amp;idx=1&amp;sn=41ee30f02113dac86398653f542a3c70&amp;chksm=eac52b9bddb2a28d6472d23eb764b6af0c8c290782e11c792dffde1a8f63c60ed7430445e0a3&amp;token=1694324409&amp;lang=zh_CN#rd" target="_blank" rel="noopener">浅析从外部访问 Kubernetes 集群中应用的几种方式</a>」一文。</p><h3 id="ipvs">IPVS</h3><p>IPVS 是 LVS 项目的一部分，是一款运行在 Linux kernel 当中的 4 层负载均衡器，性能异常优秀。 根据<a href="https://www.lvtao.net/server/taobao-linux-kernel.html" target="_blank" rel="noopener">这篇文章</a>的介绍，使用调优后的内核，可以轻松处理每秒 10 万次以上的转发请求。目前在中大型互联网项目中，IPVS 被广泛的使用，用于承接网站入口处的流量。</p><h3 id="kubernetes-service">Kubernetes Service</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486130&amp;idx=1&amp;sn=41ee30f02113dac86398653f542a3c70&amp;chksm=eac52b9bddb2a28d6472d23eb764b6af0c8c290782e11c792dffde1a8f63c60ed7430445e0a3&amp;token=1694324409&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Service</a> 是 Kubernetes 的基础概念之一，它将一组 Pod 抽象成为一项服务，统一的对外提供服务，在各个 Pod 之间实现负载均衡。 Service 有多种类型，最基本的 ClusterIP 类型解决了集群内部访问服务的需求，NodePort 类型通过 Node 节点的端口暴露服务， 再配合上 LoadBalancer 类型所定义的负载均衡器，实现了流量经过前端负载均衡器分发到各个 Node 节点暴露出的端口， 再通过 IPtables进行一次负载均衡，最终分发到实际的 Pod 上这个过程。</p><p>在 Service 的 Spec 中，externalIPs 字段平常鲜有人提到，当把 IP 地址填入这个字段后，Kube-Proxy 会增加对应的 IPtables 规则，当有以对应 IP 为目标的流量发送到 Node节点时，IPtables将进行 NAT，将流量转发到对应的服务上。一般情况下，很少会遇到服务器接受非自身绑定 IP 流量的情况，所以 externalIPs 不常被使用，但配合网络层的其他工具，它可以实现给 Service 绑定外部 IP 的效果。</p><p>今天我们将使用 externalIPs 配合 IPVS 的 DR(Direct Routing )模式实现将外部流量引入到集群内部，同时实现负载均衡。</p><a id="more"></a><h3 id="环境搭建">环境搭建</h3><p>为了演示，我们搭建了 4 台服务器组成的集群。一台服务器运行 IPVS，扮演负载均衡器的作用。一台服务器运行 Kubernetes Master 组件，其他两台服务器作为 Node 加入到 Kubernetes 集群当中。搭建过程这里不详细介绍，大家可以参考相关文档，比如：「<a href="https://k8s-install.opsnull.com/" target="_blank" rel="noopener">和我一步步部署 kubernetes 集群</a>」。</p><p>所有服务器在 172.17.8.0/24 这个网段中，服务的 VIP 我们设定为 172.17.8.201。整体架构如下图所示：</p><p><img src="https://www.hi-linux.com/img/linux/ipvs-kubernetes.png" alt=""></p><p>接下来让我们来配置 IPVS 和 Kubernetes。</p><h4 id="使用-externalips-暴露-kubernetes-service">使用 externalIPs 暴露 Kubernetes Service</h4><p>首先在集群内部运行 2 个 nginx Pod 用作演示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run nginx --image&#x3D;nginx --replicas&#x3D;2</span><br></pre></td></tr></table></figure><p>再将它暴露为 Service，同时设定 externalIPs 字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose deployment nginx --port 80 --external-ip 172.17.8.201</span><br></pre></td></tr></table></figure><p>查看 IPtables 配置，确认对应的 IPtables 规则已经被加入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -t nat -L KUBE-SERVICES -n</span><br><span class="line">Chain KUBE-SERVICES (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-SVC-4N57TFCL4MD7ZTDA  tcp  --  0.0.0.0&#x2F;0            10.3.0.156           &#x2F;* default&#x2F;nginx: cluster IP *&#x2F; tcp dpt:80</span><br><span class="line">KUBE-MARK-MASQ  tcp  --  0.0.0.0&#x2F;0            172.17.8.201         &#x2F;* default&#x2F;nginx: external IP *&#x2F; tcp dpt:80</span><br><span class="line">KUBE-SVC-4N57TFCL4MD7ZTDA  tcp  --  0.0.0.0&#x2F;0            172.17.8.201         &#x2F;* default&#x2F;nginx: external IP *&#x2F; tcp dpt:80 PHYSDEV match ! --physdev-is-in ADDRTYPE match src-type !LOCAL</span><br><span class="line">KUBE-SVC-4N57TFCL4MD7ZTDA  tcp  --  0.0.0.0&#x2F;0            172.17.8.201         &#x2F;* default&#x2F;nginx: external IP *&#x2F; tcp dpt:80 ADDRTYPE match dst-type LOCAL</span><br><span class="line">KUBE-SVC-NPX46M4PTMTKRN6Y  tcp  --  0.0.0.0&#x2F;0            10.3.0.1             &#x2F;* default&#x2F;kubernetes:https cluster IP *&#x2F; tcp dpt:443</span><br><span class="line">KUBE-NODEPORTS  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            &#x2F;* kubernetes service nodeports; NOTE: this must be the last rule in this chain *&#x2F; ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure><h4 id="配置-ipvs-实现流量转发">配置 IPVS 实现流量转发</h4><p>首先在 IPVS 服务器上，打开 ipv4_forward。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -w net.ipv4.ip_forward&#x3D;1</span><br></pre></td></tr></table></figure><p>接下来加载 IPVS 内核模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo modprobe ip_vs</span><br></pre></td></tr></table></figure><p>将 VIP 绑定在网卡上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig eth0:0 172.17.8.201 netmask 255.255.255.0 broadcast 172.17.8.255</span><br></pre></td></tr></table></figure><p>再使用 ipvsadm 来配置 IPVS，这里我们直接使用 Docker 镜像，避免和特定发行版绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --privileged -it --rm --net host luizbafilho&#x2F;ipvsadm</span><br><span class="line">&#x2F; # ipvsadm</span><br><span class="line">IP Virtual Server version 1.2.1 (size&#x3D;4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">&#x2F; # ipvsadm -A -t 172.17.8.201:80</span><br><span class="line">&#x2F; # ipvsadm -a -t 172.17.8.201:80 -r 172.17.8.11:80 -g</span><br><span class="line">&#x2F; # ipvsadm -a -t 172.17.8.201:80 -r 172.17.8.12:80 -g</span><br><span class="line">&#x2F; # ipvsadm</span><br><span class="line">IP Virtual Server version 1.2.1 (size&#x3D;4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  172.17.8.201:http wlc</span><br><span class="line">  -&gt; 172.17.8.11:http             Route   1      0          0</span><br><span class="line">  -&gt; 172.17.8.12:http             Route   1      0          0</span><br></pre></td></tr></table></figure><p>可以看到，我们成功建立了从 VIP 到后端服务器的转发。</p><h4 id="验证转发效果">验证转发效果</h4><p>首先使用 curl 来测试是否能够正常访问 Nginx 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;172.17.8.201</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;nginx.org&#x2F;&quot;&gt;nginx.org&lt;&#x2F;a&gt;.&lt;br&#x2F;&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;nginx.com&#x2F;&quot;&gt;nginx.com&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>接下来在 172.17.8.11 上抓包来确认 IPVS 的工作情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tcpdump -i any port 80</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</span><br><span class="line">04:09:07.503858 IP 172.17.8.1.51921 &gt; 172.17.8.201.http: Flags [S], seq 2747628840, win 65535, options [mss 1460,nop,wscale 5,nop,nop,TS val 1332071005 ecr 0,sackOK,eol], length 0</span><br><span class="line">04:09:07.504241 IP 10.2.0.1.51921 &gt; 10.2.0.3.http: Flags [S], seq 2747628840, win 65535, options [mss 1460,nop,wscale 5,nop,nop,TS val 1332071005 ecr 0,sackOK,eol], length 0</span><br><span class="line">04:09:07.504498 IP 10.2.0.1.51921 &gt; 10.2.0.3.http: Flags [S], seq 2747628840, win 65535, options [mss 1460,nop,wscale 5,nop,nop,TS val 1332071005 ecr 0,sackOK,eol], length 0</span><br><span class="line">04:09:07.504827 IP 10.2.0.3.http &gt; 10.2.0.1.51921: Flags [S.], seq 3762638044, ack 2747628841, win 28960, options [mss 1460,sackOK,TS val 153786592 ecr 1332071005,nop,wscale 7], length 0</span><br><span class="line">04:09:07.504827 IP 10.2.0.3.http &gt; 172.17.8.1.51921: Flags [S.], seq 3762638044, ack 2747628841, win 28960, options [mss 1460,sackOK,TS val 153786592 ecr 1332071005,nop,wscale 7], length 0</span><br><span class="line">04:09:07.504888 IP 172.17.8.201.http &gt; 172.17.8.1.51921: Flags [S.], seq 3762638044, ack 2747628841, win 28960, options [mss 1460,sackOK,TS val 153786592 ecr 1332071005,nop,wscale 7], length 0</span><br><span class="line">04:09:07.505599 IP 172.17.8.1.51921 &gt; 172.17.8.201.http: Flags [.], ack 1, win 4117, options [nop,nop,TS val 1332071007 ecr 153786592], length 0</span><br></pre></td></tr></table></figure><p>可以看到，由客户端 172.17.8.1 发送给 172.17.8.201 的封包，经过 IPVS 的中转发送给了 172.17.8.11 这台服务器，并经过 NAT 后发送给了 10.2.0.3 这个 Pod。返回的封包不经过 IPVS 服务器直接从 172.17.8.11 发送给了 172.17.8.1。 说明 IPVS 的 DR 模式工作正常。重复多次测试可以看到流量分别从 172.17.8.11 和 172.17.8.12 进入，再分发给不同的 Pod，说明负载均衡工作正常。</p><p>与传统的 IPVS DR 模式配置不同的是，我们并未在承接流量的服务器上执行绑定 VIP，再关闭 ARP 的操作。 那是因为对 VIP 的处理直接发生在 IPtables上，我们无需在服务器上运行程序来承接流量，IPtables 会将流量转发到对应的 Pod 上。</p><p>使用这种方法来承接流量，仅需要配置 externalIPs 为 VIP 即可，无需对服务器做任何特殊的设置，使用起来相当方便。</p><h3 id="总结">总结</h3><p>在本文中演示了使用 IPVS 配合 externalIPs 实现将外部流量导入到 Kubernetes 集群中，并实现负载均衡的方法。 希望可以帮助大家理解 IPVS 和 externalIPs 的工作原理，以便在恰当的场景下合理使用这两项技术解决问题。 实际部署时，还需要考虑后台服务器可用性检查，IPVS 节点主从备份，水平扩展等问题。在这里就不详细介绍了。</p><p>在 Kubernetes 中还有许多与 externalIPs 类似的非常用功能，有些甚至是使用 Annotation 来进行配置，将来有机会再进一步分享。</p><blockquote><p>来源：极术<br>原文：<a href="http://t.cn/RX8vzvC" target="_blank" rel="noopener">http://t.cn/RX8vzvC</a><br>题图：来自谷歌图片搜索<br>版权：本文版权归原作者所有</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新搭建的 Kubernetes 集群如何承接外部访问的流量，是刚上手 Kubernetes 时常常会遇到的问题。 在公有云上，官方给出了比较直接的答案，使用 LoadBalancer 类型的 Service，利用公有云提供的负载均衡服务来承接流量，同时在多台服务器之间进行负载均衡。&lt;/p&gt;
&lt;p&gt;而在私有环境中，如何正确的将外部流量引入到集群内部，却暂时没有标准的做法。 本文将介绍一种基于 IPVS 来承接流量并实现负载均衡的方法，供大家参考。在阅读本文前建议先了解文中相关基础知识点，推荐阅读下「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247486130&amp;amp;idx=1&amp;amp;sn=41ee30f02113dac86398653f542a3c70&amp;amp;chksm=eac52b9bddb2a28d6472d23eb764b6af0c8c290782e11c792dffde1a8f63c60ed7430445e0a3&amp;amp;token=1694324409&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浅析从外部访问 Kubernetes 集群中应用的几种方式&lt;/a&gt;」一文。&lt;/p&gt;
&lt;h3 id=&quot;IPVS&quot;&gt;IPVS&lt;/h3&gt;
&lt;p&gt;IPVS 是 LVS 项目的一部分，是一款运行在 Linux kernel 当中的 4 层负载均衡器，性能异常优秀。 根据&lt;a href=&quot;https://www.lvtao.net/server/taobao-linux-kernel.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;的介绍，使用调优后的内核，可以轻松处理每秒 10 万次以上的转发请求。目前在中大型互联网项目中，IPVS 被广泛的使用，用于承接网站入口处的流量。&lt;/p&gt;
&lt;h3 id=&quot;Kubernetes-Service&quot;&gt;Kubernetes Service&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247486130&amp;amp;idx=1&amp;amp;sn=41ee30f02113dac86398653f542a3c70&amp;amp;chksm=eac52b9bddb2a28d6472d23eb764b6af0c8c290782e11c792dffde1a8f63c60ed7430445e0a3&amp;amp;token=1694324409&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Service&lt;/a&gt; 是 Kubernetes 的基础概念之一，它将一组 Pod 抽象成为一项服务，统一的对外提供服务，在各个 Pod 之间实现负载均衡。 Service 有多种类型，最基本的 ClusterIP 类型解决了集群内部访问服务的需求，NodePort 类型通过 Node 节点的端口暴露服务， 再配合上 LoadBalancer 类型所定义的负载均衡器，实现了流量经过前端负载均衡器分发到各个 Node 节点暴露出的端口， 再通过 IPtables进行一次负载均衡，最终分发到实际的 Pod 上这个过程。&lt;/p&gt;
&lt;p&gt;在 Service 的 Spec 中，externalIPs 字段平常鲜有人提到，当把 IP 地址填入这个字段后，Kube-Proxy 会增加对应的 IPtables 规则，当有以对应 IP 为目标的流量发送到 Node节点时，IPtables将进行 NAT，将流量转发到对应的服务上。一般情况下，很少会遇到服务器接受非自身绑定 IP 流量的情况，所以 externalIPs 不常被使用，但配合网络层的其他工具，它可以实现给 Service 绑定外部 IP 的效果。&lt;/p&gt;
&lt;p&gt;今天我们将使用 externalIPs 配合 IPVS 的 DR(Direct Routing )模式实现将外部流量引入到集群内部，同时实现负载均衡。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Kubernetes 数据持久化方案</title>
    <link href="https://www.hi-linux.com/posts/14136.html"/>
    <id>https://www.hi-linux.com/posts/14136.html</id>
    <published>2018-08-25T01:00:00.000Z</published>
    <updated>2018-08-24T06:10:17.000Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="kubernetes-volume-相关概念">Kubernetes Volume 相关概念</h3><p>缺省情况下，一个运行中的容器对文件系统的写入都是发生在其分层文件系统的可写层。一旦容器运行结束，所有写入都会被丢弃。如果数据需要长期存储，那就需要对容器数据做持久化支持。</p><p>Kubernetes 和 Docker 类似，也是通过 Volume 的方式提供对存储的支持。Volume 被定义在 Pod 上，可以被 Pod 里的多个容器挂载到相同或不同的路径下。Kubernetes 中 Volume 的 概念与Docker 中的 Volume 类似，但不完全相同。具体区别如下：</p><ul><li>Kubernetes 中的 Volume 与 Pod 的生命周期相同，但与容器的生命周期不相关。当容器终止或重启时，Volume 中的数据也不会丢失。</li><li>当 Pod 被删除时，Volume 才会被清理。并且数据是否丢失取决于 Volume 的具体类型，比如：emptyDir 类型的 Volume 数据会丢失，而 PV 类型的数据则不会丢失。</li></ul><p>Volume 的核心是目录，可以通过 Pod 中的容器来访问。该目录是如何形成的、支持该目录的介质以及其内容取决于所使用的特定卷类型。要使用 Volume，需要为 Pod 指定为 Volume (<code>spec.volumes</code> 字段) 以及将它挂载到容器的位置 (<code>spec.containers.volumeMounts</code> 字段)。Kubernetes 支持多种类型的卷，一个 Pod 可以同时使用多种类型的 Volume。</p><p>容器中的进程看到的是由其 Docker 镜像和 Volume 组成的文件系统视图。 Docker 镜像位于文件系统层次结构的根目录，任何 Volume 都被挂载在镜像的指定路径中。Volume 无法挂载到其他 Volume 上或与其他 Volume 的硬连接。Pod 中的每个容器都必须独立指定每个 Volume 的挂载位置。</p><p>Kubernetes 目前支持多种 Volume 类型，大致如下：</p><ul><li>awsElasticBlockStore</li><li>azureDisk</li><li>azureFile</li><li>cephfs</li><li>csi</li><li>downwardAPI</li><li>emptyDir</li><li>fc (fibre channel)</li><li>flocker</li><li>gcePersistentDisk</li><li>gitRepo</li><li>glusterfs</li><li>hostPath</li><li>iscsi</li><li>local</li><li>nfs</li><li>persistentVolumeClaim</li><li>projected</li><li>portworxVolume</li><li>quobyte</li><li>rbd</li><li>scaleIO</li><li>secret</li><li>storageos</li><li>vsphereVolume</li></ul><blockquote><p>注：这些 Volume 并非全部都是持久化的，比如: emptyDir、secret、gitRepo 等，就会随着 Pod 的消亡而消失。</p></blockquote><a id="more"></a><h3 id="kubernetes-非持久化存储方式">Kubernetes 非持久化存储方式</h3><p>下面我们对一些常见的 Volume 做一个基本的介绍。</p><h4 id="emptrydir">emptryDir</h4><p>emptryDir，顾名思义是一个空目录，它的生命周期和所属的 Pod 是完全一致的。emptyDir 类型的 Volume 在 Pod 分配到 Node 上时会被创建，Kubernetes 会在 Node 上自动分配一个目录，因此无需指定 Node 宿主机上对应的目录文件。这个目录的初始内容为空，当 Pod 从 Node 上移除（Pod 被删除或者 Pod 发生迁移）时，emptyDir 中的数据会被永久删除。</p><p>emptyDir Volume 主要用于某些应用程序无需永久保存的临时目录，在多个容器之间共享数据等。缺省情况下，emptryDir 是使用主机磁盘进行存储的。你也可以使用其它介质作为存储，比如：网络存储、内存等。设置 <code>emptyDir.medium</code> 字段的值为 Memory 就可以使用内存进行存储，使用内存做为存储可以提高整体速度，但是要注意一旦机器重启，内容就会被清空，并且也会受到容器内存的限制。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/google_containers/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/cache</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">    <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="hostpath">hostPath</h4><p>hostPath 类型的 Volume 允许用户挂载 Node 宿主机上的文件或目录到 Pod 中。大多数 Pod 都用不到这种 Volume，其缺点比较明显，比如：</p><ul><li>由于每个节点上的文件都不同，具有相同配置（例如：从 podTemplate 创建的）的 Pod 在不同节点上的行为可能会有所不同。</li><li>在底层主机上创建的文件或目录只能由 root 写入。您需要在特权容器中以 root 身份运行进程，或修改主机上的文件权限才可以写入 hostPath 卷。</li></ul><p>当然，存在即合理。这种类型的 Volume 主要用在以下场景中：</p><ul><li>运行中的容器需要访问 Docker 内部的容器，使用 /var/lib/docker 来做为 hostPath 让容器内应用可以直接访问 Docker 的文件系统。</li><li>在容器中运行 cAdvisor，使用 /dev/cgroups 来做为 hostPath。</li><li>和 DaemonSet 搭配使用，用来操作主机文件。例如：日志采集方案 FLK 中的 FluentD 就采用这种方式来加载主机的容器日志目录，达到收集本主机所有日志的目的。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">k8s.gcr.io/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/test-pd</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="comment"># directory location on host</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/data</span></span><br><span class="line">      <span class="comment"># this field is optional</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure><h3 id="kubernetes-持久化存储方式">Kubernetes 持久化存储方式</h3><p>Kubernetes 目前可以使用 PersistentVolume、PersistentVolumeClaim、StorageClass 三种 API 资源来进行持久化存储，下面分别介绍下各种资源的概念。</p><h4 id="pv">PV</h4><p>PV 的全称是：PersistentVolume（持久化卷）。PersistentVolume 是 Volume 的一种类型，是对底层的共享存储的一种抽象。PV 由集群管理员进行创建和配置，就像节点 (Node) 是集群中的资源一样，PV 也是集群资源的一种。PV 包含存储类型、存储大小和访问模式。PV 的生命周期独立于 Pod，例如：当使用它的 Pod 销毁时对 PV 没有影响。</p><p>PersistentVolume 通过插件机制实现与共享存储的对接。Kubernetes 目前支持以下插件类型：</p><ul><li>GCEPersistentDisk</li><li>AWSElasticBlockStore</li><li>AzureFile</li><li>AzureDisk</li><li>FC (Fibre Channel)</li><li>FlexVolume</li><li>Flocker</li><li>NFS</li><li>iSCSI</li><li>RBD (Ceph Block Device)</li><li>CephFS</li><li>Cinder (OpenStack block storage)</li><li>Glusterfs</li><li>VsphereVolume</li><li>Quobyte Volumes</li><li>HostPath</li><li>VMware Photon</li><li>Portworx Volumes</li><li>ScaleIO Volumes</li><li>StorageOS</li></ul><h4 id="pvc">PVC</h4><p>PVC 的全称是：PersistentVolumeClaim（持久化卷声明），PVC 是用户对存储资源的一种请求。PVC 和 Pod 比较类似，Pod 消耗的是节点资源，PVC 消耗的是 PV 资源。Pod 可以请求 CPU 和内存，而 PVC 可以请求特定的存储空间和访问模式。对于真正使用存储的用户不需要关心底层的存储实现细节，只需要直接使用 PVC 即可。</p><h4 id="storageclass">StorageClass</h4><p>由于不同的应用程序对于存储性能的要求也不尽相同，比如：读写速度、并发性能、存储大小等。如果只能通过 PVC 对 PV 进行静态申请，显然这并不能满足任何应用对于存储的各种需求。为了解决这一问题，Kubernetes 引入了一个新的资源对象：StorageClass，通过 StorageClass 的定义，集群管理员可以先将存储资源定义为不同类型的资源，比如快速存储、慢速存储等。</p><p>当用户通过 PVC 对存储资源进行申请时，StorageClass 会使用 Provisioner（不同 Volume 对应不同的 Provisioner）来自动创建用户所需 PV。这样应用就可以随时申请到合适的存储资源，而不用担心集群管理员没有事先分配好需要的 PV。</p><ul><li>自动创建的 PV 以 <code>${namespace}-${pvcName}-${pvName}</code> 这样的命名格式创建在后端存储服务器上的共享数据目录中。</li><li>自动创建的 PV 被回收后会以 <code>archieved-${namespace}-${pvcName}-${pvName}</code> 这样的命名格式存在后端存储服务器上。</li></ul><h3 id="kubernetes-访问存储资源的方式">Kubernetes 访问存储资源的方式</h3><p>Kubernetes 目前可以使用三种方式来访问存储资源。</p><ul><li>直接访问</li></ul><p>该种方式移植性比较差，可扩展能力差。把 Volume 的基本信息完全暴露给用户，有安全隐患。</p><p><img src="https://www.hi-linux.com/img/linux/k8s-pv01.png" alt=""></p><ul><li>静态 PV</li></ul><p>集群管理员提前手动创建一些 PV。它们带有可供集群用户使用的实际存储的细节，之后便可用于 PVC 消费。</p><p><img src="https://www.hi-linux.com/img/linux/k8s-pv02.png" alt=""></p><blockquote><p>注：这种方式请求的 PVC 必须要与管理员创建的 PV 保持一致，如：存储大小和访问模式，否则不能将 PVC 绑定到 PV 上。</p></blockquote><ul><li>动态 PV</li></ul><p>当集群管理员创建的静态 PV 都不匹配用户的 PVC 时，PVC 请求存储类 StorageClass，StorageClass 动态的为 PVC 创建所需的 PV。</p><p><img src="https://www.hi-linux.com/img/linux/k8s-pv03.png" alt=""></p><blockquote><p>注：此功能需要基于 StorageClass。集群管理员必须先创建并配置好请求的 StorageClass，只有请求的 StorageClass 存在的情况下才能进行动态的创建。</p></blockquote><h3 id="使用-pv-进行持久化存储实例">使用 PV 进行持久化存储实例</h3><p>这里我们将介绍如何使用 PV 资源进行数据持久化，这也是本文的重点内容。我们将以 NFS 做为后端存储结合 PV 为例，讲解 Kubernetes 如何实现数据持久化。</p><h4 id="部署-nfs-服务器">部署 NFS 服务器</h4><h5 id="安装-nfs-服务端">安装 NFS 服务端</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Ubuntu &#x2F; Debian</span><br><span class="line">$ sudo apt install nfs-kernel-server</span><br></pre></td></tr></table></figure><h5 id="新建数据目录和设置目录权限">新建数据目录和设置目录权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">$ sudo chmod 755 &#x2F;data&#x2F;kubernetes&#x2F;</span><br></pre></td></tr></table></figure><h5 id="配置-nfs-服务端">配置 NFS 服务端</h5><p>NFS 的默认配置文件是 <code>/etc/exports</code> ，在该配置文件中添加下面的配置信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;exports</span><br><span class="line">&#x2F;data&#x2F;kubernetes  *(rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure><p>配置文件说明：</p><ul><li>/data/kubernetes  设置共享的数据的目录。</li><li><code>*</code> 表示任何人都有权限连接，当然也可以设置成是一个网段、一个 IP、或者是域名。</li><li>rw 设置共享目录的读写权限。</li><li>sync 表示文件同时写入硬盘和内存。</li><li>no_root_squash 当登录 NFS 主机使用共享目录的使用者是 root 时，其权限将被转换成为匿名使用者，通常它的 UID 与 GID，都会变成 nobody 身份。</li></ul><h5 id="启动-nfs-服务端">启动 NFS 服务端</h5><ul><li>启动 NFS 服务端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nfs-kernel-server</span><br></pre></td></tr></table></figure><ul><li>验证 NFS 服务端是否正常启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpcinfo -p|grep nfs</span><br><span class="line">100003    3   tcp   2049  nfs</span><br><span class="line">100003    4   tcp   2049  nfs</span><br><span class="line">100003    3   udp   2049  nfs</span><br></pre></td></tr></table></figure><ul><li>查看具体目录挂载权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;var&#x2F;lib&#x2F;nfs&#x2F;etab</span><br><span class="line">&#x2F;data&#x2F;kubernetes*(rw,sync,wdelay,hide,nocrossmnt,secure,no_root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid&#x3D;65534,anongid&#x3D;65534,sec&#x3D;sys,rw,secure,no_root_squash,no_all_squash)</span><br></pre></td></tr></table></figure><p>如果以上步骤都正常的话，到这里 NFS 服务端就已经正常安装完成。</p><h5 id="安装-nfs-客户端">安装 NFS 客户端</h5><ul><li>安装 NFS 客户端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install nfs-common</span><br></pre></td></tr></table></figure><blockquote><p>注：所有 Node 宿主机都需要安装 NFS 客户端。</p></blockquote><ul><li>验证 RPC 服务状态</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status rpcbind.service</span><br><span class="line">● rpcbind.service - RPC bind portmap service</span><br><span class="line">   Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;rpcbind.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Tue 2018-08-07 09:54:29 CST; 49s ago</span><br><span class="line">     Docs: man:rpcbind(8)</span><br><span class="line"> Main PID: 17501 (rpcbind)</span><br><span class="line">    Tasks: 1 (limit: 2313)</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;rpcbind.service</span><br><span class="line">           └─17501 &#x2F;sbin&#x2F;rpcbind -f -w</span><br></pre></td></tr></table></figure><ul><li>检查 NFS 服务端可用的共享目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo showmount -e 192.168.100.213</span><br><span class="line">Export list for 192.168.100.213:</span><br><span class="line">&#x2F;data&#x2F;kubernetes *</span><br></pre></td></tr></table></figure><ul><li>挂载 NFS 共享目录到本地</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">$ sudo mount -t nfs 192.168.100.213:&#x2F;data&#x2F;kubernetes&#x2F; &#x2F;data&#x2F;kubernetes&#x2F;</span><br></pre></td></tr></table></figure><ul><li>验证 NFS 客户端</li></ul><p>挂载成功后，在客户端上面的目录中新建一个文件，然后检查在 NFS 服务端的共享目录下是否也会出现该文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 在 NFS 客户端新建</span><br><span class="line">$ sudo touch &#x2F;data&#x2F;kubernetes&#x2F;test.txt</span><br><span class="line"></span><br><span class="line"># 在 NFS 服务端查看</span><br><span class="line">$ sudo ls -ls &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">total 0</span><br><span class="line">0 -rw-r--r-- 1 root root 0 Aug  7 09:59 test.txt</span><br></pre></td></tr></table></figure><h4 id="实现静态-pv">实现静态 PV</h4><h5 id="新建-pv-资源">新建 PV 资源</h5><p>完成上面的共享存储后，我们就可以来使用 PV 和 PVC 来管理和使用这些共享存储。PV 作为存储资源主要包括存储能力、访问模式、存储类型、回收策略等关键信息。</p><p>下面我们来新建一个 PV 对象并使用 NFS 做为后端存储类型，该 PV 包括 1G 的存储空间、访问模式为 ReadWriteOnce、回收策略为 Recyle。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">pv1-nfs.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv1-nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/kubernetes</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.213</span></span><br></pre></td></tr></table></figure><blockquote><p>注：Kubernetes 支持的 PV 类型有很多，比如常见的 Ceph、GlusterFs、NFS 等。更多的支持类型可以查看<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener">官方文档</a>。</p></blockquote><p>我们先使用 Kubectl 创建该 PV 资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f pv1-nfs.yaml</span><br><span class="line">persistentvolume &quot;pv1-nfs&quot; created</span><br></pre></td></tr></table></figure><p>从下面的结果，我们可以看到 pv1-nfs 已经创建成功。状态是 Available，这表示 pv1-nfs 准备就绪，可以被 PVC 申请。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Available                                      46s</span><br></pre></td></tr></table></figure><p>我们对上面的 PV 属性来做一个简单的解读。</p><p><strong>Capacity（存储能力）</strong></p><p>一般来说，一个 PV 对象都要指定一个存储能力，通过 PV 的 Capacity 属性来设置。这里的 storage=1Gi 表示设置存储空间的大小。</p><p><strong>AccessModes（访问模式）</strong></p><p>AccessModes 是用来对 PV 进行访问模式的设置，用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：</p><ul><li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载。</li><li>ReadOnlyMany（ROX）：只读权限，可以被多个节点挂载。</li><li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载。</li></ul><blockquote><p>注：一些 PV 可能支持多种访问模式，但是在挂载的时候只能使用一种访问模式，多种访问模式是不会生效的。</p></blockquote><p>下图是一些常用的 Volume 插件支持的访问模式：</p><p><img src="https://www.hi-linux.com/img/linux/k8s-pv04.png" alt=""></p><p><strong>PersistentVolumeReclaimPolicy（回收策略）</strong></p><p>当前 PV 设置的回收策略，我们这里指定的 PV 的回收策略为 Recycle。目前 PV 支持的策略有三种：</p><ul><li>Retain（保留）- 保留数据，需要管理员手工清理数据。</li><li>Recycle（回收）- 清除 PV 中的数据，效果相当于执行 <code>rm -rf /thevoluem/*</code> 。</li><li>Delete（删除）- 与 PV 相连的后端存储完成 Volume 的删除操作，这种方式常见于云服务商的存储服务，比如 ASW EBS。</li></ul><blockquote><p>注：目前只有 NFS 和 HostPath 两种类型支持回收策略。设置为 Retain 这种策略会更加保险一些。</p></blockquote><p><strong>状态</strong></p><p>一个 PV 的生命周期中，可能会处于 4 种不同的阶段。</p><ul><li>Available（可用）：表示可用状态，还未被任何 PVC 绑定。</li><li>Bound（已绑定）：表示 PV 已经被 PVC 绑定。</li><li>Released（已释放）：PVC 被删除，但是资源还未被集群重新声明。</li><li>Failed（失败）： 表示该 PV 的自动回收失败。</li></ul><h5 id="新建-pvc-资源">新建 PVC 资源</h5><p>我们平时真正使用的资源其实是 PVC，就类似于我们的服务是通过 Pod 来运行的，而不是 Node，只是 Pod 跑在 Node 上而已。</p><p>首先，我们新建一个数据卷声明，向 PV 请求 1Gi 的存储容量。其访问模式设置为 ReadWriteOnce。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">pvc1-nfs.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc1-nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure><p>在新建 PVC 之前，我们可以看下之前创建的 PV 的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Available                                      28m</span><br></pre></td></tr></table></figure><p>我们可以看到当前 pv1-nfs 是在 Available 的一个状态，所以这个时候我们的 PVC 可以和这个 PV 进行绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f pvc1-nfs.yaml</span><br><span class="line">persistentvolumeclaim &quot;pvc1-nfs&quot; created</span><br><span class="line"></span><br><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc1-nfs   Bound     pv1-nfs   1Gi        RWO                           34s</span><br></pre></td></tr></table></figure><p>从上面的结果可以看到 pvc1-nfs 创建成功了，并且状态是 Bound 状态。这个时候我们再看下 PV 的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    CLAIM              STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Bound     default&#x2F;pvc1-nfs                            31m</span><br></pre></td></tr></table></figure><p>同样我们可以看到 PV 也是 Bound 状态，对应的声明是 default/pvc1-nfs，表示 default 命名空间下面的 pvc1-nfs，表示我们刚刚新建的 pvc1-nfs 和 pv1-nfs 绑定成功。</p><p>PV 和 PVC 的绑定是系统自动完成的，不需要显示指定要绑定的 PV。系统会根据 PVC 中定义的要求去查找处于 Available 状态的 PV。</p><ul><li>如果找到合适的 PV 就完成绑定。</li><li>如果没有找到合适的 PV 那么 PVC 就会一直处于 Pending 状态，直到找到合适的 PV 完成绑定为止。</li></ul><p>下面我们来看一个例子，这里声明一个 PVC 的对象，它要求 PV 的访问模式是 ReadWriteOnce、存储容量 2Gi 和标签值为 app=nfs。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">pvc2-nfs.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc2-nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nfs</span></span><br></pre></td></tr></table></figure><p>我们先查看下当前系统的所有 PV 资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    CLAIM              STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Bound     default&#x2F;pvc1-nfs                            52m</span><br></pre></td></tr></table></figure><p>从结果可以看到，目前所有 PV 都是 Bound 状态，并没有 Available 状态的 PV。所以我们现在用上面新建的 PVC 是无法匹配到合适的 PV 的。我们来创建 PVC 看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f pvc2-nfs.yaml</span><br><span class="line">persistentvolumeclaim &quot;pvc2-nfs&quot; created</span><br><span class="line"></span><br><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc1-nfs   Bound     pv1-nfs   1Gi        RWO                           28m</span><br><span class="line">pvc2-nfs   Pending                                                      16s</span><br></pre></td></tr></table></figure><p>从结果我们可以看到 pvc2-nfs 当前就是 Pending 状态，因为并没有合适的 PV 给这个 PVC 使用。现在我们来新建一个合适该 PVC 使用的 PV。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">pv2-nfs.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv2-nfs</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.213</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/kubernetes</span></span><br></pre></td></tr></table></figure><p>使用 Kubectl 创建该 PV。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f pv2-nfs.yaml</span><br><span class="line">persistentvolume &quot;pv2-nfs&quot; created</span><br><span class="line"></span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    CLAIM              STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Bound     default&#x2F;pvc1-nfs                            1h</span><br><span class="line">pv2-nfs   2Gi        RWO            Recycle          Bound     default&#x2F;pvc2-nfs                            18s</span><br></pre></td></tr></table></figure><p>创建完 pv2-nfs 后，从上面的结果你会发现该 PV 已经是 Bound 状态了。其对应的 PVC 是 default/pvc2-nfs，这就证明 pvc2-nfs 终于找到合适的 PV 且完成了绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc1-nfs   Bound     pv1-nfs   1Gi        RWO                           36m</span><br><span class="line">pvc2-nfs   Bound     pv2-nfs   2Gi        RWO                           9m</span><br></pre></td></tr></table></figure><blockquote><p>注：如果 PVC 申请的容量大小小于 PV 提供的大小，PV 同样会分配该 PV 所有容量给 PVC，如果 PVC 申请的容量大小大于 PV 提供的大小，此次申请就会绑定失败。</p></blockquote><h5 id="使用-pvc-资源">使用 PVC 资源</h5><p>这里我们已经完成了 PV 和 PVC 创建，现在我们就可以使用这个 PVC 了。这里我们使用 Nginx 的镜像来创建一个 Deployment，将容器的 <code>/usr/share/nginx/html</code> 目录通过 Volume 挂载到名为 pvc2-nfs 的 PVC 上，并通过 NodePort 类型的 Service 来暴露服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">nfs-pvc-deploy.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nfs-pvc</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">        <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">          <span class="attr">claimName:</span> <span class="string">pvc2-nfs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-pvc</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs-pvc</span></span><br></pre></td></tr></table></figure><p>使用 Kubectl 创建这个 Deployment。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f nfs-pvc-deploy.yaml</span><br><span class="line">deployment.extensions &quot;nfs-pvc&quot; created</span><br><span class="line">service &quot;nfs-pvc&quot; created</span><br><span class="line"></span><br><span class="line">$ kubectl get pods -o wide|grep nfs-pvc</span><br><span class="line">nfs-pvc-789788587b-ctp58                        1&#x2F;1       Running     0          4m        172.30.24.6   dev-node-02</span><br><span class="line">nfs-pvc-789788587b-q294p                        1&#x2F;1       Running     0          4m        172.30.92.6   dev-node-03</span><br><span class="line">nfs-pvc-789788587b-rtl5s                        1&#x2F;1       Running     0          4m        172.30.87.9   dev-node-01</span><br><span class="line"></span><br><span class="line">$ kubectl get svc|grep nfs-pvc</span><br><span class="line">nfs-pvc                         NodePort       10.254.5.24      &lt;none&gt;                                            80:8682&#x2F;TCP                5m</span><br></pre></td></tr></table></figure><p>通过 NodePort 访问该服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl -I http:&#x2F;&#x2F;192.168.100.211:8682</span><br><span class="line">HTTP&#x2F;1.1 403 Forbidden</span><br><span class="line">Server: nginx&#x2F;1.7.9</span><br><span class="line">Date: Tue, 07 Aug 2018 03:42:30 GMT</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 168</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>我们可以看到 Nginx 返回了 403，这是因为我们用 NFS 中的共享目录做为 Nginx 的默认站点目录，目前这个 NFS 共享目录中没有可用的 index.html 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls  &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><p>在 NFS 服务端共享目录下新建一个 index.html 的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sh -c &quot;echo &#39;&lt;h1&gt;Hello Kubernetes~&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;data&#x2F;kubernetes&#x2F;index.html&quot;</span><br><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">index.html  test.txt</span><br></pre></td></tr></table></figure><p>再次通过 NodePort 访问该服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl  http:&#x2F;&#x2F;192.168.100.211:8682</span><br><span class="line">&lt;h1&gt;Hello Kubernetes~&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><h6 id="使用-subpath-对同一个-pv-进行隔离">使用 subPath 对同一个 PV 进行隔离</h6><p>从上面的例子中，我们可以看到容器中的数据是直接放到共享数据目录根目录下的。如果有多个容器都使用一个 PVC 的话，这样就很容易造成文件冲突。Pod 中 <code>volumeMounts.subPath</code> 属性可用于指定引用卷内的路径，只需设置该属性就可以解决该问题。</p><p>修改刚才创建 Deployment 的 YAML 文件，增加 subPath 行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">nfs-pvc-deploy.yaml</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">  <span class="attr">subPath:</span> <span class="string">nginx-pvc-test</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>更改完 YAML 文件后，重新更新下 Deployment 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f nfs-pvc-deploy.yaml</span><br><span class="line">Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply</span><br><span class="line">deployment.extensions &quot;nfs-pvc&quot; configured</span><br><span class="line">Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply</span><br><span class="line">service &quot;nfs-pvc&quot; configured</span><br></pre></td></tr></table></figure><p>更新完后，NFS 的数据共享目录下就会自动新增一个同 subPath 名字一样的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls  &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">index.html      nginx-pvc-test&#x2F; test.txt</span><br></pre></td></tr></table></figure><p>同样 nginx-pvc-test 目录下默认是空的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;nginx-pvc-test&#x2F;</span><br></pre></td></tr></table></figure><p>新增一个 index 文件后访问该服务，一切安好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sh -c &quot;echo &#39;&lt;h1&gt;Hello Kubernetes~&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;data&#x2F;kubernetes&#x2F;nginx-pvc-test&#x2F;index.html&quot;</span><br><span class="line">$ curl  http:&#x2F;&#x2F;192.168.100.211:8682</span><br><span class="line">&lt;h1&gt;Hello Kubernetes~&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><h5 id="验证-pvc-中的数据持久化">验证 PVC 中的数据持久化</h5><p>上面我们已经成功的在 Pod 中使用了 PVC 来做为存储，现在我们来验证下数据是否会丢失。我们分两种情况来验证：一种是直接删除 Deployment 和 Service，另一种是先删除 PVC 后再删除 Deployment 和 Service。</p><h6 id="直接删除-deployment-和-service">直接删除 Deployment 和 Service</h6><p>在这种情况下数据会永久保存下来，删除 Deployment 和 Service 不会对数据造成任何影响。</p><ul><li>删除 Deployment 和 Service</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f nfs-pvc-deploy.yaml</span><br><span class="line">service &quot;nfs-pvc&quot; deleted</span><br><span class="line">deployment.extensions &quot;nfs-pvc&quot; deleted</span><br></pre></td></tr></table></figure><ul><li>查看数据共享目录下面的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;nginx-pvc-test&#x2F;</span><br><span class="line">index.html</span><br></pre></td></tr></table></figure><h6 id="先删除-pvc-后再删除-deployment-和-service">先删除 PVC 后再删除 Deployment 和 Service</h6><ul><li>删除 PVC</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pvc pvc2-nfs</span><br><span class="line">persistentvolumeclaim &quot;pvc2-nfs&quot; deleted</span><br></pre></td></tr></table></figure><p>我们可以看到 PVC 状态已经变成了 Terminating，但是现在数据共享目录中的文件和服务都是可以正常访问的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS        VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc1-nfs   Bound         pv1-nfs   1Gi        RWO                           3h</span><br><span class="line">pvc2-nfs   Terminating   pv2-nfs   2Gi        RWO                           6m</span><br><span class="line"></span><br><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;nginx-pvc-test&#x2F;</span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">$ curl  http:&#x2F;&#x2F;192.168.100.211:8928</span><br><span class="line">&lt;h1&gt;Hello Kubernetes~&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p>这是因为还有 Pod 正在使用 pvc2-nfs 这个 PVC，那么对应的资源依然可用。如果无 Pod 继续使用 pvc2-nfs 这个 PVC，则相应 PVC 对应的资源就会被收回。</p><ul><li>删除 Deployment 和 Service</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f nfs-pvc-deploy.yaml</span><br><span class="line">deployment.extensions &quot;nfs-pvc&quot; deleted</span><br><span class="line">service &quot;nfs-pvc&quot; deleted</span><br><span class="line"></span><br><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc1-nfs   Bound     pv1-nfs   1Gi        RWO                           3h</span><br><span class="line"></span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM              STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Bound       default&#x2F;pvc1-nfs                            4h</span><br><span class="line">pv2-nfs   2Gi        RWO            Recycle          Available                                               25m</span><br><span class="line"></span><br><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;</span><br></pre></td></tr></table></figure><p>从上面的结果我们可以看到 pvc2-nfs 这个 PVC 已经不存在了，pv2-nfs 这个 PV 的状态也变成 Available 了。由于我们设置的 PV 的回收策略是 Recycle，我们可以发现 NFS 的共享数据目录下面的数据也没了，这是因为我们把 PVC 给删除掉后回收了数据。</p><h4 id="使用-storageclass-实现动态-pv">使用 StorageClass 实现动态 PV</h4><p>上面的例子中我们学习了静态 PV 和 PVC 的使用方法，所谓静态 PV 就是我要使用的一个 PVC 的话就必须手动去创建一个 PV。</p><p>这种方式在很多使用场景下使用起来都不灵活，需要依赖集群管理员事先完成 PV 的建立。特别是对于 StatefulSet 类型的应用，简单的使用静态的 PV 就不是很合适了。这种情况下我们就需要用到动态 PV，动态 PV 的实现需要用到 StorageClass。</p><h5 id="创建-provisioner">创建 Provisioner</h5><p>要使用 StorageClass，我们就得安装对应的自动配置程序。比如：我们这里存储后端使用的是 NFS，那么我们就需要使用到一个对应的自动配置程序。支持 NFS 的自动配置程序就是 <a href="https://github.com/kubernetes-incubator/external-storage/tree/master/nfs-client" target="_blank" rel="noopener">nfs-client</a>，我们把它称作 Provisioner。这个程序可以使用我们已经配置好的 NFS 服务器，来自动创建持久卷，也就是自动帮我们创建 PV。</p><ul><li>以 Deployment 方式部署一个 Provisioner</li></ul><p>根据实际情况将下面的环境变量 <code>NFS_SERVER</code>、<code>NFS_PATH</code> 和 NFS 相关配置替换成你的对应的值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">nfs-client.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">quay.io/external_storage/nfs-client-provisioner:latest</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/persistentvolumes</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROVISIONER_NAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">fuseim.pri/ifs</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_SERVER</span></span><br><span class="line">              <span class="attr">value:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.213</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_PATH</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">/data/kubernetes</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.213</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/data/kubernetes</span></span><br></pre></td></tr></table></figure><p>使用 Kubectl 命令建立这个 Deployment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f nfs-client.yaml</span><br><span class="line">deployment.extensions &quot;nfs-client-provisioner&quot; created</span><br></pre></td></tr></table></figure><ul><li>给 nfs-client-provisioner 创建 ServiceAccount</li></ul><p>从 Kubernetes 1.6 版本开始，API Server 启用了 RBAC 授权。Provisioner 要想在 Kubernetes 中创建对应的 PV 资源，就得有对应的权限。</p><p>这里我们新建一个名为 nfs-client-provisioner 的 ServiceAccount 并绑定在一个名为 nfs-client-provisioner-runner 的 ClusterRole 上。该 ClusterRole 包含对 PersistentVolumes 的增、删、改、查等权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ vim nfs-client-sa.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner-runner</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;persistentvolumes&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;delete&quot;]</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;persistentvolumeclaims&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]</span><br><span class="line">  - apiGroups: [&quot;storage.k8s.io&quot;]</span><br><span class="line">    resources: [&quot;storageclasses&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;events&quot;]</span><br><span class="line">    verbs: [&quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  name: run-nfs-client-provisioner</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: nfs-client-provisioner</span><br><span class="line">    namespace: default</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: nfs-client-provisioner-runner</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><p>使用 Kubectl 命令建立这个 ServiceAccount。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f nfs-client-sa.yaml</span><br><span class="line">serviceaccount &quot;nfs-client-provisioner&quot; created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io &quot;nfs-client-provisioner-runner&quot; created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io &quot;run-nfs-client-provisioner&quot; created</span><br></pre></td></tr></table></figure><ul><li>创建 StorageClass 对象</li></ul><p>这里我们创建了一个名为 course-nfs-storage 的 StorageClass 对象，注意下面的 Provisioner 对应的值一定要和上面的 Deployment下面 PROVISIONER_NAME 这个环境变量的值一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vim nfs-client-class.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: storage.k8s.io&#x2F;v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: course-nfs-storage</span><br><span class="line">provisioner: fuseim.pri&#x2F;ifs # or choose another name, must match deployment&#39;s env PROVISIONER_NAME&#39;</span><br></pre></td></tr></table></figure><p>使用 Kubectl 命令建立这个 StorageClass。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f nfs-client-class.yaml</span><br><span class="line">storageclass.storage.k8s.io &quot;course-nfs-storage&quot; created</span><br></pre></td></tr></table></figure><p>以上都创建完成后查看下相关资源的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods|grep nfs-client</span><br><span class="line">NAME                                            READY     STATUS      RESTARTS   AGE</span><br><span class="line">nfs-client-provisioner-9d94b899c-nn4c7          1&#x2F;1       Running     0          1m</span><br><span class="line"></span><br><span class="line">$ kubectl get storageclass</span><br><span class="line">NAME                 PROVISIONER      AGE</span><br><span class="line">course-nfs-storage   fuseim.pri&#x2F;ifs   1m</span><br></pre></td></tr></table></figure><h5 id="手动创建的一个-pvc-对象">手动创建的一个 PVC 对象</h5><ul><li>新建一个 PVC 对象</li></ul><p>我们这里就来建立一个能使用 StorageClass 资源对象来动态建立 PV 的 PVC，要创建使用 StorageClass 资源对象的 PVC 有以下两种方法。</p><p>方法一：在这个 PVC 对象中添加一个 Annotations 属性来声明 StorageClass 对象的标识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 这里我们声明了一个 PVC 对象，采用 ReadWriteMany 的访问模式并向 PV 请求 100Mi 的空间。</span><br><span class="line">$ vim test-pvc.yaml</span><br><span class="line"></span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pvc</span><br><span class="line">  annotations:</span><br><span class="line">    volume.beta.kubernetes.io&#x2F;storage-class: &quot;course-nfs-storage&quot;</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 100Mi</span><br></pre></td></tr></table></figure><p>方法二：把名为 course-nfs-storage 的 StorageClass 设置为 Kubernetes 的默认后端存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl patch storageclass course-nfs-storage -p &#39;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io&#x2F;is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#39;</span><br><span class="line">storageclass.storage.k8s.io &quot;course-nfs-storage&quot; patched</span><br></pre></td></tr></table></figure><p>上面这两种方法都是可以的，为了不影响系统的默认行为，这里我们采用第一种方法，直接使用 YAML 文件创建即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f test-pvc.yaml</span><br><span class="line">persistentvolumeclaim &quot;test-pvc&quot; created</span><br></pre></td></tr></table></figure><p>创建完成后，我们来看看对应的资源是否创建成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS         AGE</span><br><span class="line">pvc1-nfs   Bound     pv1-nfs                                    1Gi        RWO                                 4h</span><br><span class="line">test-pvc   Bound     pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79   100Mi      RWX            course-nfs-storage   41s</span><br><span class="line"></span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM              STORAGECLASS         REASON    AGE</span><br><span class="line">pv1-nfs                                    1Gi        RWO            Recycle          Bound       default&#x2F;pvc1-nfs                                  5h</span><br><span class="line">pv2-nfs                                    2Gi        RWO            Recycle          Available                                                     1h</span><br><span class="line">pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79   100Mi      RWX            Delete           Bound       default&#x2F;test-pvc   course-nfs-storage             2m</span><br></pre></td></tr></table></figure><p>从上面的结果我们可以看到一个名为 test-pvc 的 PVC 对象创建成功并且状态已经是 Bound 了。对应也自动创建了一个名为 pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79 的 PV 对象，其访问模式是 RWX，回收策略是 Delete。STORAGECLASS 栏中的值也正是我们创建的 StorageClass 对象 course-nfs-storage。</p><ul><li>测试</li></ul><p>我们用一个简单的示例来测试下用 StorageClass 方式声明的 PVC 对象是否能正常存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ vim test-pod.yaml</span><br><span class="line"></span><br><span class="line">kind: Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: test-pod</span><br><span class="line">    image: busybox</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    command:</span><br><span class="line">    - &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">    args:</span><br><span class="line">    - &quot;-c&quot;</span><br><span class="line">    - &quot;touch &#x2F;mnt&#x2F;SUCCESS &amp;&amp; exit 0 || exit 1&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: nfs-pvc</span><br><span class="line">      mountPath: &quot;&#x2F;mnt&quot;</span><br><span class="line">  restartPolicy: &quot;Never&quot;</span><br><span class="line">  volumes:</span><br><span class="line">  - name: nfs-pvc</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: test-pvc</span><br></pre></td></tr></table></figure><p>上面这个 Pod 的作用非常简单，就是在一个 busybox 容器里的 /mnt 目录下面新建一个 SUCCESS 的文件，而 /mnt 目录是挂载到 test-pvc 这个资源对象上的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f test-pod.yaml</span><br><span class="line">pod &quot;test-pod&quot; created</span><br></pre></td></tr></table></figure><p>完成 Pod 创建后，我们可以在 NFS 服务器的共享数据目录下面查看数据是否存在。我们可以看到下面有一个名字很长的文件夹，这个文件夹的命名方式是：<code>${namespace}-${pvcName}-${pvName}</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">default-test-pvc-pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79</span><br></pre></td></tr></table></figure><p>再看下这个文件夹下面的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;default-test-pvc-pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79&#x2F;</span><br><span class="line">SUCCESS</span><br></pre></td></tr></table></figure><p>我们看到下面有一个 SUCCESS 的文件，说明 PV 对应的存储里可以成功写入文件。</p><h5 id="自动创建的一个-pvc-对象">自动创建的一个 PVC 对象</h5><p>在上面的演示过程中，我们可以看到是手动创建的一个 PVC 对象，而在实际使用中更多使用 StorageClass 的是 StatefulSet 类型的服务。</p><p>StatefulSet 类型的服务是可以通过一个 volumeClaimTemplates 属性来直接使用 StorageClass。volumeClaimTemplates 其实就是一个 PVC 对象的模板，类似于 StatefulSet 下面的 template，而这种模板可以动态的去创建相应的 PVC 对象。</p><ul><li>创建一个 StatefulSet 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ vim test-statefulset-nfs.yaml</span><br><span class="line">apiVersion: apps&#x2F;v1beta1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-web</span><br><span class="line">spec:</span><br><span class="line">  serviceName: &quot;nginx&quot;</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nfs-web</span><br><span class="line">    spec:</span><br><span class="line">      terminationGracePeriodSeconds: 10</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.7.9</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: www</span><br><span class="line">          mountPath: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: www</span><br><span class="line">      annotations:</span><br><span class="line">        volume.beta.kubernetes.io&#x2F;storage-class: course-nfs-storage</span><br><span class="line">    spec:</span><br><span class="line">      accessModes: [ &quot;ReadWriteOnce&quot; ]</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br></pre></td></tr></table></figure><p>使用 Kubectl 命令建立这个 StatefulSet 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f test-statefulset-nfs.yaml</span><br><span class="line">statefulset.apps &quot;nfs-web&quot; created</span><br></pre></td></tr></table></figure><ul><li>检查相应资源对像是否已完成创建</li></ul><p>创建完成后可以看到上面 StatefulSet 对象中定义的 3 个 Pod 已经运行成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME                                            READY     STATUS      RESTARTS   AGE</span><br><span class="line">nfs-web-0                                       1&#x2F;1       Running     0          19s</span><br><span class="line">nfs-web-1                                       1&#x2F;1       Running     0          16s</span><br><span class="line">nfs-web-2                                       1&#x2F;1       Running     0          6s</span><br></pre></td></tr></table></figure><p>再查看下 PVC 和 PV 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME            STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS         AGE</span><br><span class="line">www-nfs-web-0   Bound     pvc-16ba792f-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            course-nfs-storage   1m</span><br><span class="line">www-nfs-web-1   Bound     pvc-18c631d4-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            course-nfs-storage   1m</span><br><span class="line">www-nfs-web-2   Bound     pvc-1ed50c38-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            course-nfs-storage   1m</span><br><span class="line"></span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                   STORAGECLASS         REASON    AGE</span><br><span class="line">pvc-16ba792f-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            Delete           Bound       default&#x2F;www-nfs-web-0   course-nfs-storage             3m</span><br><span class="line">pvc-18c631d4-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            Delete           Bound       default&#x2F;www-nfs-web-1   course-nfs-storage             3m</span><br><span class="line">pvc-1ed50c38-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            Delete           Bound       default&#x2F;www-nfs-web-2   course-nfs-storage             3m</span><br></pre></td></tr></table></figure><p>我们可以看到生成了 3 个 PVC 对象，名称由模板名称加上 Pod 的名称组合而成，而这 3 个 PVC 对象也都是绑定状态。</p><ul><li>检查 NFS 服务器上面的是否生成相应的数据目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls  &#x2F;data&#x2F;kubernetes&#x2F; -l</span><br><span class="line">total 16</span><br><span class="line">drwxrwxrwx 2 root root 4096 Aug  7 15:32 default-test-pvc-pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79</span><br><span class="line">drwxrwxrwx 2 root root 4096 Aug  7 15:40 default-www-nfs-web-0-pvc-16ba792f-9a15-11e8-9a96-001c42c61a79</span><br><span class="line">drwxrwxrwx 2 root root 4096 Aug  7 15:40 default-www-nfs-web-1-pvc-18c631d4-9a15-11e8-9a96-001c42c61a79</span><br><span class="line">drwxrwxrwx 2 root root 4096 Aug  7 15:40 default-www-nfs-web-2-pvc-1ed50c38-9a15-11e8-9a96-001c42c61a79</span><br></pre></td></tr></table></figure><h4 id="部署一个使用-storageclass-的应用">部署一个使用 StorageClass 的应用</h4><p>上面的例子中都是简单的运行了一个 Nginx 来演示功能，接下来我们用 Helm 来部署一个具体的应用看看效果。如果你对 Helm 还不够了解，可以先读读 「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486154&amp;idx=1&amp;sn=becd5dd0fadfe0b6072f5dfdc6fdf786&amp;chksm=eac52be3ddb2a2f555b8b1028db97aa3e92d0a4880b56f361e4b11cd252771147c44c08c8913&amp;mpshare=1&amp;scene=23&amp;srcid=0809XT1uzvaUqkaWiouHAUv4%23rd" target="_blank" rel="noopener">Helm 入门指南</a>」一文。</p><p>这里我们同样以部署 DokuWiki 的为例。在「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486201&amp;idx=1&amp;sn=8ba9e1ce4ce1cd3e62472db8b946daf9&amp;chksm=eac52bd0ddb2a2c6c579d0e083eb180d1a57c6ad968f1c6dd0f5b74f7b0702e77d85325a5128&amp;mpshare=1&amp;scene=23&amp;srcid=08211PurH1JwOAE6ueZYuZVt%23rd" target="_blank" rel="noopener">利用 Helm 快速部署 Ingress</a>」一文中我们在部署时关闭了 PersistentVolume。现在我们就演示加上 PersistentVolume 的效果。</p><p>DokuWiki 默认是启用 Persistence 特性的，这里主要通过 <code>persistence.apache.storageClass</code>、<code>persistence.apache.size</code> 和 <code>persistence.dokuwiki.storageClass</code>、<code>persistence.dokuwiki.size</code> 几个参数来设置 Apache 和 DokuWiki 两个应用对应的 storageClass 名称和存储大小 。</p><ul><li>使用 helm install 进行一键部署</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;k8s&#x2F;charts&#x2F;stable</span><br><span class="line">$ helm install --name dokuwiki --set &quot;ingress.enabled&#x3D;true,ingress.hosts[0].name&#x3D;wiki.hi-linux.com,persistence.apache.storageClass&#x3D;course-nfs-storage,persistence.apache.size&#x3D;500Mi,persistence.dokuwiki.storageClass&#x3D;course-nfs-storage,persistence.dokuwiki.size&#x3D;500Mi&quot;  dokuwiki</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: DEPLOYED</span><br><span class="line"></span><br><span class="line">RESOURCES:</span><br><span class="line">&#x3D;&#x3D;&gt; v1&#x2F;Secret</span><br><span class="line">NAME               TYPE    DATA  AGE</span><br><span class="line">dokuwiki-dokuwiki  Opaque  1     6m</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; v1&#x2F;PersistentVolumeClaim</span><br><span class="line">NAME                        STATUS  VOLUME                                    CAPACITY  ACCESS MODES  STORAGECLASS        AGE</span><br><span class="line">dokuwiki-dokuwiki-apache    Bound   pvc-1bfd0981-9af0-11e8-9a96-001c42c61a79  500Mi     RWO           course-nfs-storage  6m</span><br><span class="line">dokuwiki-dokuwiki-dokuwiki  Bound   pvc-1bffad3d-9af0-11e8-9a96-001c42c61a79  500Mi     RWO           course-nfs-storage  6m</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; v1&#x2F;Service</span><br><span class="line">NAME               TYPE          CLUSTER-IP     EXTERNAL-IP  PORT(S)                   AGE</span><br><span class="line">dokuwiki-dokuwiki  LoadBalancer  10.254.95.241  &lt;pending&gt;    80:8592&#x2F;TCP,443:8883&#x2F;TCP  6m</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; v1beta1&#x2F;Deployment</span><br><span class="line">NAME               DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE</span><br><span class="line">dokuwiki-dokuwiki  1        1        1           1          6m</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; v1beta1&#x2F;Ingress</span><br><span class="line">NAME               HOSTS              ADDRESS  PORTS  AGE</span><br><span class="line">dokuwiki-dokuwiki  wiki.hi-linux.com  80       6m</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; v1&#x2F;Pod(related)</span><br><span class="line">NAME                               READY  STATUS   RESTARTS  AGE</span><br><span class="line">dokuwiki-dokuwiki-bf9fb965c-d9x2w  1&#x2F;1    Running  1         6m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line"></span><br><span class="line">** Please be patient while the chart is being deployed **</span><br><span class="line"></span><br><span class="line">1. Get the DokuWiki URL indicated on the Ingress Rule and associate it to your cluster external IP:</span><br><span class="line"></span><br><span class="line">   export CLUSTER_IP&#x3D;$(minikube ip) # On Minikube. Use: &#96;kubectl cluster-info&#96; on others K8s clusters</span><br><span class="line">   export HOSTNAME&#x3D;$(kubectl get ingress --namespace default dokuwiki-dokuwiki -o jsonpath&#x3D;&#39;&#123;.spec.rules[0].host&#125;&#39;)</span><br><span class="line">   echo &quot;Dokuwiki URL: http:&#x2F;&#x2F;$HOSTNAME&#x2F;&quot;</span><br><span class="line">   echo &quot;$CLUSTER_IP  $HOSTNAME&quot; | sudo tee -a &#x2F;etc&#x2F;hosts</span><br><span class="line"></span><br><span class="line">2. Login with the following credentials</span><br><span class="line"></span><br><span class="line">  echo Username: user</span><br><span class="line">  echo Password: $(kubectl get secret --namespace default dokuwiki-dokuwiki -o jsonpath&#x3D;&quot;&#123;.data.dokuwiki-password&#125;&quot; | base64 --decode)</span><br></pre></td></tr></table></figure><ul><li>查看部署完成后状态</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm list</span><br><span class="line">NAME         REVISIONUPDATED                 STATUS  CHART              NAMESPACE</span><br><span class="line">dokuwiki     1       Wed Aug  8 17:47:48 2018DEPLOYEDdokuwiki-2.0.3     default</span><br></pre></td></tr></table></figure><ul><li>在后端存储上查看对应的数据目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 应用对应的数据目录已经自动创建</span><br><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;*dokuwiki* -ld</span><br><span class="line">drwxrwxrwx 3 root   root   4096 Aug  8 17:52 &#x2F;data&#x2F;kubernetes&#x2F;default-dokuwiki-dokuwiki-apache-pvc-1bfd0981-9af0-11e8-9a96-001c42c61a79</span><br><span class="line">drwxrwxrwx 5 daemon daemon 4096 Aug  8 17:53 &#x2F;data&#x2F;kubernetes&#x2F;default-dokuwiki-dokuwiki-dokuwiki-pvc-1bffad3d-9af0-11e8-9a96-001c42c61a79</span><br><span class="line"></span><br><span class="line"># 查看应用对应的数据目录下文件</span><br><span class="line">$ ls  &#x2F;data&#x2F;kubernetes&#x2F;default-dokuwiki-dokuwiki-dokuwiki-pvc-1bffad3d-9af0-11e8-9a96-001c42c61a79&#x2F; -l</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x  2 daemon daemon 4096 Aug  8 17:49 conf</span><br><span class="line">drwxr-xr-x 12 daemon daemon 4096 Aug  8 17:48 data</span><br><span class="line">drwxr-xr-x  5 daemon daemon 4096 Aug  8 17:48 lib</span><br><span class="line"></span><br><span class="line">$ ls  &#x2F;data&#x2F;kubernetes&#x2F;default-dokuwiki-dokuwiki-apache-pvc-1bfd0981-9af0-11e8-9a96-001c42c61a79&#x2F;conf&#x2F;</span><br><span class="line">bitnami  deflate.conf  extra  httpd.conf  magic  mime.types  original  vhosts</span><br></pre></td></tr></table></figure><ul><li>访问 Web</li></ul><p>根据提示生成相应的登陆用户名和密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo Username: user</span><br><span class="line">Username: user</span><br><span class="line"></span><br><span class="line">$ echo Password: $(kubectl get secret --namespace default dokuwiki-dokuwiki -o jsonpath&#x3D;&quot;&#123;.data.dokuwiki-password&#125;&quot; | base64 --decode)</span><br><span class="line">Password: e2GrABBkwF</span><br></pre></td></tr></table></figure><p>通过浏览器访问该应用。效果图如下：</p><p><img src="https://www.hi-linux.com/img/linux/k8s-ingress01.png" alt=""></p><h3 id="参考文档">参考文档</h3><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a><br><a href="http://t.cn/RmDscuQ" target="_blank" rel="noopener">http://t.cn/RmDscuQ</a><br><a href="http://t.cn/RDqXk2U" target="_blank" rel="noopener">http://t.cn/RDqXk2U</a><br><a href="http://t.cn/RDqX1qi" target="_blank" rel="noopener">http://t.cn/RDqX1qi</a><br><a href="http://t.cn/RDqT4Xw" target="_blank" rel="noopener">http://t.cn/RDqT4Xw</a><br><a href="http://t.cn/RmDscuQ" target="_blank" rel="noopener">http://t.cn/RmDscuQ</a><br><a href="http://t.cn/RDqg4D0" target="_blank" rel="noopener">http://t.cn/RDqg4D0</a><br><a href="http://t.cn/RDqkyoC" target="_blank" rel="noopener">http://t.cn/RDqkyoC</a><br><a href="http://t.cn/RDVE0bW" target="_blank" rel="noopener">http://t.cn/RDVE0bW</a><br><a href="http://t.cn/R6GaBUK" target="_blank" rel="noopener">http://t.cn/R6GaBUK</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Kubernetes-Volume-相关概念&quot;&gt;Kubernetes Volume 相关概念&lt;/h3&gt;
&lt;p&gt;缺省情况下，一个运行中的容器对文件系统的写入都是发生在其分层文件系统的可写层。一旦容器运行结束，所有写入都会被丢弃。如果数据需要长期存储，那就需要对容器数据做持久化支持。&lt;/p&gt;
&lt;p&gt;Kubernetes 和 Docker 类似，也是通过 Volume 的方式提供对存储的支持。Volume 被定义在 Pod 上，可以被 Pod 里的多个容器挂载到相同或不同的路径下。Kubernetes 中 Volume 的 概念与Docker 中的 Volume 类似，但不完全相同。具体区别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 中的 Volume 与 Pod 的生命周期相同，但与容器的生命周期不相关。当容器终止或重启时，Volume 中的数据也不会丢失。&lt;/li&gt;
&lt;li&gt;当 Pod 被删除时，Volume 才会被清理。并且数据是否丢失取决于 Volume 的具体类型，比如：emptyDir 类型的 Volume 数据会丢失，而 PV 类型的数据则不会丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Volume 的核心是目录，可以通过 Pod 中的容器来访问。该目录是如何形成的、支持该目录的介质以及其内容取决于所使用的特定卷类型。要使用 Volume，需要为 Pod 指定为 Volume (&lt;code&gt;spec.volumes&lt;/code&gt; 字段) 以及将它挂载到容器的位置 (&lt;code&gt;spec.containers.volumeMounts&lt;/code&gt; 字段)。Kubernetes 支持多种类型的卷，一个 Pod 可以同时使用多种类型的 Volume。&lt;/p&gt;
&lt;p&gt;容器中的进程看到的是由其 Docker 镜像和 Volume 组成的文件系统视图。 Docker 镜像位于文件系统层次结构的根目录，任何 Volume 都被挂载在镜像的指定路径中。Volume 无法挂载到其他 Volume 上或与其他 Volume 的硬连接。Pod 中的每个容器都必须独立指定每个 Volume 的挂载位置。&lt;/p&gt;
&lt;p&gt;Kubernetes 目前支持多种 Volume 类型，大致如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;awsElasticBlockStore&lt;/li&gt;
&lt;li&gt;azureDisk&lt;/li&gt;
&lt;li&gt;azureFile&lt;/li&gt;
&lt;li&gt;cephfs&lt;/li&gt;
&lt;li&gt;csi&lt;/li&gt;
&lt;li&gt;downwardAPI&lt;/li&gt;
&lt;li&gt;emptyDir&lt;/li&gt;
&lt;li&gt;fc (fibre channel)&lt;/li&gt;
&lt;li&gt;flocker&lt;/li&gt;
&lt;li&gt;gcePersistentDisk&lt;/li&gt;
&lt;li&gt;gitRepo&lt;/li&gt;
&lt;li&gt;glusterfs&lt;/li&gt;
&lt;li&gt;hostPath&lt;/li&gt;
&lt;li&gt;iscsi&lt;/li&gt;
&lt;li&gt;local&lt;/li&gt;
&lt;li&gt;nfs&lt;/li&gt;
&lt;li&gt;persistentVolumeClaim&lt;/li&gt;
&lt;li&gt;projected&lt;/li&gt;
&lt;li&gt;portworxVolume&lt;/li&gt;
&lt;li&gt;quobyte&lt;/li&gt;
&lt;li&gt;rbd&lt;/li&gt;
&lt;li&gt;scaleIO&lt;/li&gt;
&lt;li&gt;secret&lt;/li&gt;
&lt;li&gt;storageos&lt;/li&gt;
&lt;li&gt;vsphereVolume&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注：这些 Volume 并非全部都是持久化的，比如: emptyDir、secret、gitRepo 等，就会随着 Pod 的消亡而消失。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
</feed>
