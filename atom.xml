<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>运维之美</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2020-05-24T09:05:29.314Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用 Katacoda 免费同步 Docker 镜像到 Docker Hub</title>
    <link href="https://www.hi-linux.com/posts/30618.html"/>
    <id>https://www.hi-linux.com/posts/30618.html</id>
    <published>2020-05-24T01:19:00.000Z</published>
    <updated>2020-05-24T09:05:29.314Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="为什么要同步">为什么要同步</h2><p>安装 kubernetes 的时候，我们需要用到 <code>gcr.io/google_containers</code> 下面的一些镜像，在国内是不能直接下载的。如果用 Self Host 方式安装，Master 上的组件除开 Kubelet 之外都用容器运行，甚至 CNI 插件也是容器运行。比如 Flannel，在 <code>quay.io/coreos</code> 下面，在国内下载非常慢。但是我们可以把这些镜像同步到我们的 Docker Hub 仓库里，再配个 Docker Hub 加速器，这样下载镜像就很快了。</p><h2 id="原理">原理</h2><p>Katacoda 是一个在线学习平台，在 Web 上提供学习需要的服务器终端，里面包含学习所需的环境，我们可以利用 <code>Docker</code> 课程的终端来同步，因为里面有 <code>Docker</code> 环境，可以执行 docker login、docker pull、docker tag、docker push 等命令来实现同步镜像。</p><p>但是手工去执行命令很麻烦，如果要同步的镜像和 Tag 比较多，手工操作那就是浪费生命。我们可以利用程序代替手工操作，不过 Katacoda 为了安全起见，不允许执行外来的二进制程序，但是可以 Shell 脚本，我写好了脚本，大家只需要粘贴进去根据自己需要稍稍修改下，然后运行就可以了。</p><a id="more"></a><h2 id="lets-do-it">Let’s Do It</h2><p>点击 <a href="https://www.katacoda.com/courses/docker/deploying-first-container" target="_blank" rel="noopener" title="Docker 课程">这里</a> 进入 Docker 课程。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1520565820/blog/k8s/katacoda-docker.png" alt=""></p><p>点击 <code>START SCENARIO</code> 或 终端右上角全屏按钮将终端放大。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1520565820/blog/k8s/katacoda-terminal.png" alt=""></p><p>安装脚本依赖的 <code>jq</code> 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt install jq</span><br></pre></td></tr></table></figure><p>登录 Docker Hub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure><p>创建脚本并赋予执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch sync</span><br><span class="line">$ chmod +x sync</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/imroc/image/upload/v1520565825/blog/k8s/katacoda-terminal2.png" alt=""></p><p>编辑脚本，可以使用自带的 vim 编辑器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim sync</span><br></pre></td></tr></table></figure><p>将脚本粘贴进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">docker_repo&#x3D;&quot;k8smirror&quot; # your docker hub username or organization name</span><br><span class="line">registry&#x3D;&quot;gcr.io&quot; # the registry of original image, e.g. gcr.io, quay.io</span><br><span class="line">repo&#x3D;&quot;google_containers&quot; # the repository name of original image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sync_one()&#123;</span><br><span class="line">  docker pull $&#123;registry&#125;&#x2F;$&#123;repo&#125;&#x2F;$&#123;1&#125;:$&#123;2&#125;</span><br><span class="line">  docker tag $&#123;registry&#125;&#x2F;$&#123;repo&#125;&#x2F;$&#123;1&#125;:$&#123;2&#125; docker.io&#x2F;$&#123;docker_repo&#125;&#x2F;$&#123;1&#125;:$&#123;2&#125;</span><br><span class="line">  docker push docker.io&#x2F;$&#123;docker_repo&#125;&#x2F;$&#123;1&#125;:$&#123;2&#125;</span><br><span class="line">  docker rmi -f $&#123;registry&#125;&#x2F;$&#123;repo&#125;&#x2F;$&#123;1&#125;:$&#123;2&#125; docker.io&#x2F;$&#123;docker_repo&#125;&#x2F;$&#123;1&#125;:$&#123;2&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sync_all_tags() &#123;</span><br><span class="line">  for image in $*; do</span><br><span class="line">    tags_str&#x3D;&#96;curl https:&#x2F;&#x2F;$&#123;registry&#125;&#x2F;v2&#x2F;$&#123;repo&#125;&#x2F;$image&#x2F;tags&#x2F;list | jq &#39;.tags&#39; -c | sed &#39;s&#x2F;\[&#x2F;\(&#x2F;g&#39; | sed &#39;s&#x2F;\]&#x2F;\)&#x2F;g&#39; | sed &#39;s&#x2F;,&#x2F; &#x2F;g&#39;&#96;</span><br><span class="line">    echo &quot;$image $tags_str&quot;</span><br><span class="line">    src&#x3D;&quot;</span><br><span class="line">sync_one()&#123;</span><br><span class="line">  docker pull $&#123;registry&#125;&#x2F;$&#123;repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125;</span><br><span class="line">  docker tag $&#123;registry&#125;&#x2F;$&#123;repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125; docker.io&#x2F;$&#123;docker_repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125;</span><br><span class="line">  docker push docker.io&#x2F;$&#123;docker_repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125;</span><br><span class="line">  docker rmi -f $&#123;registry&#125;&#x2F;$&#123;repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125; docker.io&#x2F;$&#123;docker_repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125;</span><br><span class="line">&#125;</span><br><span class="line">tags&#x3D;$&#123;tags_str&#125;</span><br><span class="line">echo \&quot;$image $&#123;tags_str&#125;\&quot;</span><br><span class="line">for tag in \$&#123;tags[@]&#125;</span><br><span class="line">do</span><br><span class="line">  sync_one $image \$&#123;tag&#125;</span><br><span class="line">done;&quot;</span><br><span class="line">    bash -c &quot;$src&quot;</span><br><span class="line">  done </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sync_with_tags()&#123;</span><br><span class="line">  image&#x3D;$1</span><br><span class="line">  skip&#x3D;1</span><br><span class="line">  for tag in $*; do</span><br><span class="line">    if [ $skip -eq 1 ]; then</span><br><span class="line">  skip&#x3D;0</span><br><span class="line">    else</span><br><span class="line">      sync_one $image $tag</span><br><span class="line">fi</span><br><span class="line">  done </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sync_after_tag()&#123;</span><br><span class="line">  image&#x3D;$1</span><br><span class="line">  start_tag&#x3D;$2</span><br><span class="line">  tags_str&#x3D;&#96;curl https:&#x2F;&#x2F;$&#123;registry&#125;&#x2F;v2&#x2F;$&#123;repo&#125;&#x2F;$image&#x2F;tags&#x2F;list | jq &#39;.tags&#39; -c | sed &#39;s&#x2F;\[&#x2F;\(&#x2F;g&#39; | sed &#39;s&#x2F;\]&#x2F;\)&#x2F;g&#39; | sed &#39;s&#x2F;,&#x2F; &#x2F;g&#39;&#96;</span><br><span class="line">  echo &quot;$image $tags_str&quot;</span><br><span class="line">  src&#x3D;&quot;</span><br><span class="line">sync_one()&#123;</span><br><span class="line">  docker pull $&#123;registry&#125;&#x2F;$&#123;repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125;</span><br><span class="line">  docker tag $&#123;registry&#125;&#x2F;$&#123;repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125; docker.io&#x2F;$&#123;docker_repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125;</span><br><span class="line">  docker push docker.io&#x2F;$&#123;docker_repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125;</span><br><span class="line">  docker rmi -f $&#123;registry&#125;&#x2F;$&#123;repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125; docker.io&#x2F;$&#123;docker_repo&#125;&#x2F;\$&#123;1&#125;:\$&#123;2&#125;</span><br><span class="line">&#125;</span><br><span class="line">tags&#x3D;$&#123;tags_str&#125;</span><br><span class="line">start&#x3D;0</span><br><span class="line">for tag in \$&#123;tags[@]&#125;; do</span><br><span class="line">  if [ \$start -eq 1 ]; then</span><br><span class="line">    sync_one $image \$tag</span><br><span class="line">  elif [ \$tag &#x3D;&#x3D; &#39;$start_tag&#39; ]; then</span><br><span class="line">    start&#x3D;1</span><br><span class="line">  fi</span><br><span class="line">done&quot;</span><br><span class="line">  bash -c &quot;$src&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get_tags()&#123;</span><br><span class="line">  image&#x3D;$1</span><br><span class="line">  curl https:&#x2F;&#x2F;$&#123;registry&#125;&#x2F;v2&#x2F;$&#123;repo&#125;&#x2F;$image&#x2F;tags&#x2F;list | jq &#39;.tags&#39; -c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#sync_with_tags etcd 2.0.12 2.0.13 # sync etcd:2.0.12 and etcd:2.0.13</span><br><span class="line">#sync_after_tag etcd 2.0.8 # sync tag after etcd:2.0.8</span><br><span class="line">#sync_all_tags etcd hyperkube # sync all tags of etcd and hyperkube</span><br></pre></td></tr></table></figure><p>脚本中有一些参数需要根据你自己情况修改，可以使用它自带的 <code>vim</code> 在线修改，也可以在你本地改好在粘贴上去。</p><ul><li><code>docker_repo</code> 改为你的 Docker Hub 账号组织名</li><li><code>registry</code> 改为被同步镜像所在仓库的域名</li><li><code>repo</code> 改为被同步镜像所在仓库的账号或组织名</li></ul><p>在脚本最后，可以调用写好的函数来实现镜像同步，举例：</p><ul><li>同步一个镜像中指定的一个或多个 tag</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync_with_tags etcd 2.0.12 2.0.13</span><br></pre></td></tr></table></figure><ul><li>从某个 Tag 后面的 Tag 开始一直同步到最后（Tag 顺序按照字母数字来的，不是上传日期；Katacoda 终端用久了会断连，可能处于安全原因考虑，断开之后可以看 Tag 同步到哪一个了，然后执行类似下面的命令从断连的 Tag 开始同步）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync_after_tag etcd 2.0.8</span><br></pre></td></tr></table></figure><p>同步一个或多个镜像的所有 Tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync_all_tags etcd hyperkube</span><br></pre></td></tr></table></figure><p>最后执行脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;sync</span><br></pre></td></tr></table></figure><p>这就开始同步了，Katacoda 服务器在国外，下载 <a href="http://gcr.io" target="_blank" rel="noopener">gcr.io</a> 或 <a href="http://quay.io" target="_blank" rel="noopener">quay.io</a> 上那些镜像都很快，上传 Docker Hub 也很快。如果断连了，可以在 Docker Hub 上查最新上传的 Tag 是哪个（如：<a href="https://hub.docker.com/r/k8smirror/hyperkube/tags/" target="_blank" rel="noopener">https://hub.docker.com/r/k8smirror/hyperkube/tags/</a> 把 k8smirror 改为你的 Docker 用户名或组织名，hyperkube 改为镜像名），然后改脚本，用 sync_after_tag 这个函数继续上传。</p><blockquote><p>本文转载自：「I’m roc Blog」，原文：<a href="http://t.cn/AiW3Jpot%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">http://t.cn/AiW3Jpot，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要同步&quot;&gt;为什么要同步&lt;/h2&gt;
&lt;p&gt;安装 kubernetes 的时候，我们需要用到 &lt;code&gt;gcr.io/google_containers&lt;/code&gt; 下面的一些镜像，在国内是不能直接下载的。如果用 Self Host 方式安装，Master 上的组件除开 Kubelet 之外都用容器运行，甚至 CNI 插件也是容器运行。比如 Flannel，在 &lt;code&gt;quay.io/coreos&lt;/code&gt; 下面，在国内下载非常慢。但是我们可以把这些镜像同步到我们的 Docker Hub 仓库里，再配个 Docker Hub 加速器，这样下载镜像就很快了。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;Katacoda 是一个在线学习平台，在 Web 上提供学习需要的服务器终端，里面包含学习所需的环境，我们可以利用 &lt;code&gt;Docker&lt;/code&gt; 课程的终端来同步，因为里面有 &lt;code&gt;Docker&lt;/code&gt; 环境，可以执行 docker login、docker pull、docker tag、docker push 等命令来实现同步镜像。&lt;/p&gt;
&lt;p&gt;但是手工去执行命令很麻烦，如果要同步的镜像和 Tag 比较多，手工操作那就是浪费生命。我们可以利用程序代替手工操作，不过 Katacoda 为了安全起见，不允许执行外来的二进制程序，但是可以 Shell 脚本，我写好了脚本，大家只需要粘贴进去根据自己需要稍稍修改下，然后运行就可以了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用 Gitlab 和 Jenkins 构建持续集成环境</title>
    <link href="https://www.hi-linux.com/posts/55356.html"/>
    <id>https://www.hi-linux.com/posts/55356.html</id>
    <published>2020-05-24T01:18:00.000Z</published>
    <updated>2020-05-24T09:05:07.230Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最近用到持续集成顺便总结在这里，都是用的最新版。搭建过程中还有一个 Demo，提交代码到 Gitlab 自动触发 Jenkins 任务，自动编译代码和 Docker 镜像并上传。</p><h2 id="安装运行-gitlab">安装运行 Gitlab</h2><p>Gitlab 国内安装很麻烦，用官方的源装不了，因为在国外，太慢，链接会断掉。国内清华有 Gitlab 的 Apt 和 Yum 源，但是我试过安装 CentOS 7 的 Gitlab ，到最后都会一直卡住结束不了。直接下载清华 Gitlab 的 Rpm Mirror 安装也是一样，所以我还是选择用 Docker 启动 Gitlab（提前配好 Docker Hub 加速器）</p><ul><li>准备镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull gitlab&#x2F;gitlab-ee:latest</span><br></pre></td></tr></table></figure><ul><li>准备 Gitlab 所需目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir gitlab</span><br><span class="line">$ cd gitlab</span><br><span class="line">$ mkdir config logs data</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>准备启动脚本</li></ul><p>替换想要的启动的端口，IP 地址替换为访问你的 Gitlab 的地址，也可以替换想要的挂载目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ vi run</span><br><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">sudo docker run -d --rm \</span><br><span class="line">    -p 8088:8088 \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --env GITLAB_OMNIBUS_CONFIG&#x3D;&quot;external_url &#39;http:&#x2F;&#x2F;118.24.64.246:8088&#x2F;&#39;; gitlab_rails[&#39;lfs_enabled&#39;] &#x3D; true;&quot; \</span><br><span class="line">    -v $PWD&#x2F;config:&#x2F;etc&#x2F;gitlab \</span><br><span class="line">    -v $PWD&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab \</span><br><span class="line">    -v $PWD&#x2F;data:&#x2F;var&#x2F;opt&#x2F;gitlab \</span><br><span class="line">    gitlab&#x2F;gitlab-ee:latest</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>赋予执行权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x run</span><br></pre></td></tr></table></figure><ul><li>启动 Gitlab</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;run</span><br></pre></td></tr></table></figure><ul><li>查看 Gitlab 控制台输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f gitlab</span><br></pre></td></tr></table></figure><p>访问 Gitlab，打开脚本中配置的 external_url 地址，设置管理员密码和注册 Gitlab 账号，登录并添加自己的 SSH key 。创建 Repo ，git clone 到本地，后面我们提交代码到这个 Repo ，触发 Jenkins 的持续集成。</p><h2 id="安装运行-jenkins">安装运行 Jenkins</h2><p>Jenkins 建议直接安装在宿主机，不用 Docker 方式，因为持续集成需要安装各种我们用到的工具，这些工具可能后面根据需要才安装，重启不能让这些工具丢失。比如编译 Java 源码需要装 JDK 环境，编译和上传 Docker 镜像需要安装 Docker 环境，并且还需要提前 docker login 好，不然上传不了。</p><p>因为 Jenkins 用 JAVA 写的，所以确保机器上装有 JDK 或 OpenJDK 环境，准备一个 Jenkins 用的目录，下载 War 包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir jenkins </span><br><span class="line">$ wget http:&#x2F;&#x2F;mirrors.jenkins.io&#x2F;war-stable&#x2F;latest&#x2F;jenkins.war</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup java -jar jenkins.war --httpPort&#x3D;8080 &amp;&gt; jenkins.log &amp;</span><br></pre></td></tr></table></figure><p>查看 jenkins 输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f jenkins.log</span><br></pre></td></tr></table></figure><p>第一次打开 Jenkins Web 界面，要求输出管理员初始密码，生成在服务器上，界面上提示有路径。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523432610/blog/ci/jenkins-initial.png" alt=""></p><p>查看密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;root&#x2F;.jenkins&#x2F;secrets&#x2F;initialAdminPassword</span><br></pre></td></tr></table></figure><p>粘贴密码并继续，安装推荐的插件，等待安装完成</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523433013/blog/ci/xsrm.png" alt=""></p><p>创建管理员，保存并完成。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523440941/blog/ci/create-admin.png" alt=""></p><p>至此，jenkins 安装完成</p><h2 id="jenkins-安装需要的插件">Jenkins 安装需要的插件</h2><p>打开 Jenkins-系统设置-管理插件。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523440424/blog/ci/manage-plugin.png" alt=""></p><p>在可选插件里选择并安装需要的插件：Git 、 GitLab 、Build Authentication Token Root （Git 插件在默认推荐插件里已安装，在可选插件列表里可能没有）。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523443519/blog/ci/install-plugin.png" alt=""></p><p>点击 “直接安装”，勾选 “安装完成后重启 Jenkins (空闲时)“，等待安装完成自动重启 Jenkins。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523443587/blog/ci/jenkins-plugin-install-and-restrart.png" alt=""></p><p>由于后面 Jenkins 的机器上需要用到 Docker，所以保证 Jenkins 所在机器安装好 Docker 并配好 Docker Hub 的加速器，并且 docker login 登录镜像要上传的仓库。</p><h2 id="gitlab-创建-repo">Gitlab 创建 Repo</h2><p>我们这里就以一个简单的 Golang 程序做实例，实现提交代码自动编译代码，然后 Docker 编译镜像并上传至 CCR （腾讯云的 Docker 镜像仓库)。</p><p>在 Gitlab 上创建空 Repo，Clone 到本地，添加三个文件。</p><ul><li>main.go （源码）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">println(&quot;hello world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Dockerfile （编译镜像用的 Dockerfile）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line"></span><br><span class="line">MAINTAINER roc&lt;rockerchen@tencent.com&gt;</span><br><span class="line"></span><br><span class="line">COPY bd-ci-test &#x2F;bin&#x2F;bd-ci-test</span><br><span class="line"></span><br><span class="line">CMD [&quot;bd-ci-test&quot;]</span><br></pre></td></tr></table></figure><ul><li>build （编译源码、镜像和上传镜像的脚本，替换 IMAGE 地址为要上传的地址）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># 编译代码</span><br><span class="line">docker run --rm \</span><br><span class="line">  -v $PWD:&#x2F;go&#x2F;src&#x2F;bd-ci-test \</span><br><span class="line">  -w &#x2F;go&#x2F;src&#x2F;bd-ci-test \</span><br><span class="line">  golang:alpine go build</span><br><span class="line"></span><br><span class="line">IMAGE&#x3D;&quot;imroc&#x2F;bd-ci-test:latest&quot;</span><br><span class="line"></span><br><span class="line"># 编译镜像</span><br><span class="line">docker build -t $IMAGE .</span><br><span class="line"></span><br><span class="line"># 上传镜像 (请提前登录好,docker login 只需登录一次)</span><br><span class="line">docker push $IMAGE</span><br><span class="line"></span><br><span class="line"># 清理</span><br><span class="line">docker rmi $IMAGE</span><br><span class="line">rm bd-ci-test</span><br></pre></td></tr></table></figure><ul><li>给 build 脚本执行权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x build</span><br></pre></td></tr></table></figure><p>至此，我们的代码准备好了，先不忙提交，接下来配置 Jenkins 来做持续集成。</p><h2 id="配置-jenkins">配置 Jenkins</h2><p>新建 Jenkins 项目，选择 “构建一个自由风格的软件项目”。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523444143/blog/ci/jenkins-new-project.png" alt=""></p><p>源代码管理选 Git，Repository URL 填写你 Gitlab 上源码 Repo 的地址，Credentials 是拉取代码时需要用到的身份认证（如果你的Repo 不是公有的，没有身份认证就会报错）。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523451253/blog/ci/jenkins-git.png" alt=""></p><p>点击 Add 添加一个， Kind 选择 “Username with password”，输入 Gitlab 账号密码。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523451426/blog/ci/jenkins-credentials.png" alt=""></p><p>然后 Credentials 选择我们刚刚添加的（检测到账号密码正确就不会报错了），我们准备对 master 分支的代码做持续集成，所以 “Branches to build” 填 “*/master”。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523451601/blog/ci/jenkins-git-after.png" alt=""></p><p>构建触发器选择 “Build when a change is pushed to GitLab” （后面的 URL 是我们需要在 Gitlab 上配的 Webhook 地址），按照下面勾选。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523452134/blog/ci/jenkins-construct-trigger.png" alt=""></p><p>点开高级，“Allowd branches” 勾选 “Filter branches by regex”，填写 “master”。点 “Generate” 生成 Token，这个 Token 用于填写到 Gitlab 的 Webhook 里，Gitlab 检测到代码提交，会通知 Webhook 里填写的 Jenkins 生成的回掉 URL，并带上这个 Token，防止其它人触发 Jenkins 的持续集成。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523452257/blog/ci/jenkins-advanced-trigger.png" alt=""></p><blockquote><p>注: 复制出 URL 和 Token，我们后面配置 Gitlab 的 Webhook 会用到。</p></blockquote><p>增加构建步骤 “execute shell”。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523452676/blog/ci/jenkins-construct.png" alt=""></p><p>由于我们把持续集成的操作都写到 build 脚本了，所以直接填写执行 ./build 就可以了。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523453127/blog/ci/jenkins-build.png" alt=""></p><p>最后点击保存，至此，Jenkins 的持续集成配置好了，还需要配置 Gitlab 的 Webhook，用于代码提交通知 Jenkins。</p><h2 id="配置-gitlab-webhook">配置 Gitlab Webhook</h2><p>打开 Gitlab 的 Repo 的 Settings-Integrations。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523453629/blog/ci/gitlab-webhook.png" alt=""></p><p>URL 和 Secret Token 填写 Jenkins 项目中构建触发器部分生成的，点击 “Add webhook”，搞定！</p><h2 id="测试">测试</h2><p>现在我们可以提交代码测试一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;test&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><p>我们可以看 Jenkins 的输出来看是否触发任务，由于我使用了一些 Docker Hub 的镜像来编译代码和镜像，如果没有提前 Pull 下来，第一次运行任务可能会比较久，等待运行结束，刷新 Jenkins 主页。</p><p>如果运行成功，从 “上次成功” 下拉选择 “控制台输出”</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523453513/blog/ci/jenkins-console-tab.png" alt=""></p><p>可以看到运行任务过程的输出。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523453516/blog/ci/jenkins-console.png" alt=""></p><p>如果都没问题，你可以看看你的镜像仓库，镜像已经成功上传，至此，这个简单的持续集成搭建完毕。</p><h2 id="附录">附录</h2><h3 id="git-submodule">Git Submodule</h3><p>如果你的项目里面还引用了其它项目，也就是 Git 的 Submodules，怎么办？甚至 Submodule 里面还要指定分支呢？</p><p>在创建 Jenkins 项目的时候，在 源码管理-Git-Additional Behaviours-Add 选择 Advanced sub-modules behaviours。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523628768/blog/ci/jekins-advanced-sub-modules.png" alt=""></p><p>勾选下面两个选项。</p><p><img src="https://res.cloudinary.com/imroc/image/upload/v1523628769/blog/ci/jenkins-additional-behaviours.png" alt=""></p><p>Submodules 的分支靠 Git 本来支持的 <code>.gitmodules</code> 文件来控制，用法举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add -b v1 https:&#x2F;&#x2F;github.com&#x2F;imroc&#x2F;req.git ref&#x2F;req</span><br></pre></td></tr></table></figure><p>查看 <code>.gitmodules</code> 文件格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitmodules</span><br><span class="line">[submodule &quot;ref&#x2F;req&quot;]</span><br><span class="line">path &#x3D; ref&#x2F;req</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;imroc&#x2F;req.git</span><br><span class="line">branch &#x3D; v1</span><br></pre></td></tr></table></figure><p>可以自己手动编辑或用 <code>git submodule add</code> 命令生成。</p><blockquote><p>本文转载自：「I’m roc Blog」，原文：<a href="http://t.cn/AiWDsnzq%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">http://t.cn/AiWDsnzq，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用到持续集成顺便总结在这里，都是用的最新版。搭建过程中还有一个 Demo，提交代码到 Gitlab 自动触发 Jenkins 任务，自动编译代码和 Docker 镜像并上传。&lt;/p&gt;
&lt;h2 id=&quot;安装运行-Gitlab&quot;&gt;安装运行 Gitlab&lt;/h2&gt;
&lt;p&gt;Gitlab 国内安装很麻烦，用官方的源装不了，因为在国外，太慢，链接会断掉。国内清华有 Gitlab 的 Apt 和 Yum 源，但是我试过安装 CentOS 7 的 Gitlab ，到最后都会一直卡住结束不了。直接下载清华 Gitlab 的 Rpm Mirror 安装也是一样，所以我还是选择用 Docker 启动 Gitlab（提前配好 Docker Hub 加速器）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准备镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker pull gitlab&amp;#x2F;gitlab-ee:latest&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;准备 Gitlab 所需目录&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir gitlab&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd gitlab&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir config logs data&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Gitlab" scheme="https://www.hi-linux.com/tags/Gitlab/"/>
    
  </entry>
  
  <entry>
    <title>谈谈技术人的发展生存之道</title>
    <link href="https://www.hi-linux.com/posts/1788.html"/>
    <id>https://www.hi-linux.com/posts/1788.html</id>
    <published>2020-05-24T01:17:00.000Z</published>
    <updated>2020-05-24T08:56:22.790Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这是一篇从 “人” (而非技术也非管理)的角度，聚焦于自身职业发展方方面面的文章，包括职业、学习、生产力、影响力等。</p><h2 id="拥有商业心态">拥有商业心态</h2><p>你所能犯的最大错误就是相信自己是在为别人工作，职业发展的驱动力一定是来自个体本身，而不是领导、公司，因为职业发展是属于你自己的。如果你真的想在这个充满竞争的世界里脱颖而出，那么你首先必须制订一个坚实可靠而又深思熟虑的计划，学会主动管理自己的职业生涯。</p><p>职业生涯中要做的第一件事便是，转变你的心态。而商业心态对于管理职业规划至关重要。如果你已经习惯于领取一份固定的薪酬，便会很容易导致你产生：你只是在为这家公司打工的谋生心态。尽管在你的职业生涯的某个特定时间段里，你可能确实是在为某家公司打工，但是千万不要因此固化了你的整个职业生涯。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1562990262645-1c5cf817-03dd-4b0d-82d4-55e4dca112b0.png" alt=""></p><p>那么心态该如何转变呢？首先你要把自己当作一个企业去思考，然后把雇主当作是你这个企业的一个客户。当然，你可能只有这么一个客户，你所有的收入都是从这一个客户得来的，但是这种诠释雇用关系的方式可以将你从雇佣关系的弱势地位转换成为自我治理和自我引导的主动地位，同时，心态转变后能更有利于你做出良好的商业决策。</p><a id="more"></a><h2 id="作为企业该如何思考">作为企业，该如何思考</h2><p>现在你已经把自己当作一个企业了，在这个状态下，其实你的收益并不大，至少物质上并没有给你太多好处。要想从中有所收获，你得先弄明白企业是如何思考、发展的？上个月跟我们的PMO@冰霖 有过一次闲谈，过程中印象最深的一句话是：一个企业要发展，首先要找到一个能赚钱的产品或服务，然后思考如何完善、改进，以达到更长远的发展。发展过程中，始终要考虑投入产出（成本、风险、收益、回报周期），将收益最大化。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1562994831596-1f1844d1-ef9d-4bcd-bf0d-fb9c504ae2d4.png" alt=""></p><p>把你作为一个企业，你目前以及未来能提供什么服务或产品呢？即使你刚开始思考这个问题，对你自己的职业生涯或许也会慢慢产生深远的影响。拿我来举个例子，我目前的职业是web前端工程师，那我售卖的就是前端开发技能，准确来讲，售卖的是把公司的想法实现成互联网产品人机交互的能力。企业需要持续不断地迭代、改进和完善自己的产品。你也应该这么做，通过不断学习升级打怪，去完善自我。</p><h2 id="思考未来的目标">思考未来的目标</h2><p>作为企业，出了要知道自己能提供什么服务或产品，还需要明确的业务目标。起步阶段最简单的就是在心中树立一个大 目标，然后再建立能帮你达成这个大目标的小目标。大目标并不需要那么具体，但是必须足够清晰，能够让你知道自己是在向它前进还是离它越来越远。 例如想成为一家公司的经理或主管?想在某一天走出去开拓自己的业务，研发自己的产品？</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1562994977456-d5af47d6-e8bc-41e1-9332-2dc5caaa69d5.png" alt=""></p><p>很多人认为目标太过于大，不容易实现，这也是为什么需要设立小目标的原因。实现目标的过程，就好比航海，小目标可以让你航行轨道始终控制在正确的方向上，激励你朝着更大的目标前进。大目标如果没有分解成小目标，你很容易偏离航向，迷失在茫茫大海之中。</p><p>举个例子：</p><p>职业上，我想成为一个能够影响互联网行业发展的专家。</p><p>在实现目标的过程中，我的必经之路是踏入行业，掌握行业的某种技能，考核的标准是：能够通过自己掌握的技能，实现就业。<br>经过在行业中的几年摸爬滚打，不断提升自己技术（专业能力）、积累人脉（交际能力），慢慢打磨自己向高手靠拢，衡量的标准是是否能跟其他高手/专家进行平等对话（这里的平等对话，并不是低人一等的意思，而是互相交流过程中能够相互传递信息，而不是不知所云）。<br>越往上走，你会发现你的视野正在变化，可以看到别人所看不到，能够影响甚至引领行业发展的东西正等着你去挖掘。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1562996074814-ec079c9f-721d-4ce2-afa3-baca30fd6ea8.png?x-oss-process=image/resize,w_1492" alt=""></p><p>要实现目标的整个过程，那我可能会切割成如下小目标：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1562999854321-11ddde78-ee69-4053-b6aa-50c0f012932d.png" alt=""></p><h2 id="承担更多的责任">承担更多的责任</h2><p>逼着自己一路前行的方式方法很多，但责任是永远是鞭策你自我成长最有效的途径。如果你自驱能力很强，那我恭喜你哈。如果不是，请你在有任何机会去承担更多责任时，主动去承担，接受挑战。</p><p>很多人会问，假如没有被赋予更多责任怎么办？</p><ul><li><p>主动寻找机会。通常没有人愿意涉足的领域是搜寻机会最好的地方。以程序员来说，可能有一个没人愿意碰的遗留应用，或者代码库里的某个没人敢去碰的模块。正因为没有人愿意碰、没人敢去碰，所以没人跟你抢，这就成为了你日益强大的阵营。如果你能把沼泽变为良田，你也就展现了自己的价值。</p></li><li><p>间接承担责任。最好的方式是成为团队中其他人的导师，自愿帮助新人加速成长，为任何有需要的人提供帮助。通过介入和解决别人的问题，你不仅可以学到更多自己专业之外的知识，而且随着时间的推移，你还能在团队中逐步树立影响力。</p></li></ul><h2 id="解决问题而不是来抱怨问题">解决问题，而不是来抱怨问题</h2><p>在任何组织中，总是有很多人会告诉你为什么这个想法行不通，那个问题太难，这个问题不适合我来做，更适合谁去做。这样的人不胜枚举。千万不要成为他们中的一员。相反，你要成为那个永远能为各种问题找到解决方案，并执行落地这些解决方案以获得成果的人。成为这种人也是获得晋升的可靠方法。如果你能解决别人无法解决或不愿解决的问题，无论在哪家公司，你都能轻而易举地成为最有价值的人。</p><h2 id="掌握快速自我学习的能力">掌握快速自我学习的能力</h2><p>很多程序员被绕进了学习新技术、新编程语言、新框架的漩涡，感觉学习的压力很大，怎么爬也爬不出来。通常，这种压力是自我造成的。</p><p>在我刚出来工作的时候，我学习技术的主要途径就是买一本书，然后只有通读完全书后，我才会将自己学到的技术应用于项目实践中。这个方法，确实能学到东西，但是效率很低，在实践过程中，还得经常回顾书的内容，来弥补自己在学习过程中遗漏的问题。</p><p>通常在业务发展的过程中，技术选型是不会等待你学习好一门技术才投入到业务中的。这便迫使我们去寻找更好的自学方法，能在有限的时间内吸收、掌握所需内容即可。例如我在已有 React 开发经验的情况下，只花了 1 天左右零碎的时间，通过对比 React 与 Vue 的语法区别，然后在 JSBin (<a href="http://jsbin.com" target="_blank" rel="noopener">http://jsbin.com</a>) 中试跑 Demo，第二天便可以将 Vue 投入到项目开发中去。</p><p>这其实是一个筛选学习内容、动手操作再到学以致用的过程，这个过程可以不断循环，不断吸收更多的知识。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1563001416773-405fedae-7ec7-4690-b55f-e303ca7e9a72.png" alt=""></p><p>这个方法可以高效地掌握一门技术，而无需通晓全部细节。通过在业务实践项目中不断暴漏问题、解决问题、总结问题，你会发现所有技术问题，慢慢都会收拢到一起，逐渐丰富你的经验，最终你便开始能够解决“某一类问题”，而不是“某一个问题”，随着你能够解决问题的类型越多，你融会贯通的能力就会越强。</p><h2 id="找出自己的短板并消灭它">找出自己的短板，并消灭它</h2><p>专注于自身强项，这没什么不妥，但有时候，如果弱点得不到解决，通常会成为你的职业或生活的绊脚石。我们每个人都有弱点。我们能发现并消除自身的短板越多，长久来看我们从中受益越多----可以参考木桶效益。</p><p>很遗憾的是，每个人身上大多数的短板，自己只能隐约觉察到。对于自己不知道的，你很难清楚地意识到，也很容易忽略。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1563002803796-5fd0afd6-11bd-4433-96a4-ea20abf2a587.png" alt=""></p><p>那么我们如何找到自己的短板呢？旁观者清、当局者迷的道理大家都知道，但通常人都不太喜欢逆耳的声音，所以别人往往也不会很直接的指出你的短板。</p><p>这种情况下，我们可以通过如下尝试：</p><ul><li><p>自身主动与他人做对比：同样一件事情，人家做到什么程度，你能做到什么程度，人家是怎么做的，你是怎么做的，总的来说，不比不知道，一比吓一跳。通过比较你就知道自己的思路，行动的差距在哪里。</p></li><li><p>在反思中找到自己的短板：有时候做一个事情，不顺利，失败。这时候虽然很沮丧，但是如果能够在沮丧中反思自己，为什么会出现这样的错误，如果当时怎么样处理就会好一些，由此就知道缺少哪一方面的短板了。</p></li><li><p>有一两个知己朋友也会起到很大的作用，虚心吸收朋友指出的问题，并珍惜你俩的基友吧。</p></li><li><p>专注于自己的领域的同时，也有扩宽自己的视野，涉猎不同领域渠道的信息。</p></li></ul><h2 id="合理规划时间提高生产力">合理规划时间，提高生产力</h2><p>多年来，我尝试过不少提升生产力的方法，目前我用的是四象限工作事项管理法和番茄时间管理法组合的方式。</p><h3 id="番茄时间管理法">番茄时间管理法</h3><p>第一次使用番茄工作法的时候，我并没有严格做到它规定的要求。我只是每天用它来设置若干个“25分钟”的番茄钟。我并没有留意自己每天完成了几个番茄钟，也没有估算某项任务要用掉几个番茄钟；因此我并没有从中受益。只是简单认为整个方法就是让你在一个时间段内保持专注。</p><p>直到后来我决定严格地使用番茄时间管理法，发现自己潜移默化地逐渐有能力、可量化去真正评估自己每天可以完成的工作量。通过跟踪自己一天内完成了多少个番茄钟，并为每天要完成的番茄钟的数量设定目标。今后每次项目中，需要评估工作量、估算工时，便发挥了番茄时间管理法真正的威力。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1563004394385-f2460f92-19e2-487b-b3e4-1fa4dc0c3a09.png" alt=""></p><h3 id="四象限工作法">四象限工作法</h3><p>那四象限工作法如何与番茄时间管理结合使用呢？</p><p>使用番茄工作法，你可以把每周看作是由有限个番茄钟组成的。想在每周完成一定数量的任务?你要搞清楚自己一周能完成多少个番茄钟，并相应地设置任务的优先级。通过计算自己完成的番茄钟的数量，可以确切知道自己一周完成了多少任务。</p><p>这里有个有意思的问题：如果你没能完成自己设定的任务，但是却用完了足够数量的番茄钟怎么办？</p><p>某些情况下，我们总是幻想着自己可以在一周内完成超出自己实际能力许多的工作，过高地估计了自己的能力而低估了完成任务所需的时间。这个时候，我们就非常有必要给各个任务项设置的优先级了，将你每周需要完成的任务按照重要、紧急划分成四类：重要紧急、重要不紧急、紧急不重要、不重要不紧急。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1563004203908-40f1d81e-f0c3-469d-a020-e12ec758528f.png?x-oss-process=image/resize,w_944" alt=""></p><p>有人过来问，这两个分别是什么软件？</p><p>这个给大家介绍下哈，分别是Focus Matrix和Be Focused。 这两款软件数据是可以打通的，同时提供了手机版。</p><p><img src="https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/3e8b20818459d99ee23809e03d98bd1e.png" alt=""></p><p>当然也可以不使用软件的方式，这只是一个时间和任务管理的方法论，你也可以买一个沙漏⏳管理时间和便签管理任务，使用得当的话，也是可以达到一样效果的。</p><h2 id="打造个人影响力">打造个人影响力</h2><p>事实上个人影响力的提升一定不是一朝一夕的事情，也不是光设定目标就可以达成的。确实有许多潜移默化和机缘巧合融合在里面。我所谈的也仅仅是方法论，需要大家去践行，再去提炼和总结。这里总结了三步：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1563006995937-30960fb3-ab8a-4177-8be4-3b0fe075cf34.png" alt=""></p><p>第一步是分析自己，很多人觉得我怎么会不知道自己是个什么人呢？抱歉，绝大部分80%的人呢，都是无法认清自己，一个可以客观评价自己的人，在自我认知部分就会更精准。最简单可量化的方式就是从技能、性感等方面去绘画雷达图，从而客观的评价自己。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1563007711443-58187a00-150e-463d-bfe5-a46699784340.png?x-oss-process=image/resize,w_482" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1563007735585-2b7301e7-e098-4052-b153-eb753d250f8a.png?x-oss-process=image/resize,w_436" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2019/png/89257/1563007787194-0f04689a-cbc7-4e37-89c7-b5c28ba1beb6.png?x-oss-process=image/resize,w_444" alt=""></p><p>第二步就到了定位自己，这个其实跟产品的定位有点类似，为什么有些品牌可以成功，确实与其对于自身产品的高度认知和品牌价值的集中萃取，一眼就可以做识别和关联用户。那么对于我们人来说也是这样的，我知道自己是什么样的人之后，我也会清晰的知道，自己适合往什么样的方向去发展，找到自己的定位。</p><p>第三步是形成标签，在你过往的各种各样的人生经历中，你需要提取一些标签，固化自己，让自己成为斜杠青年，让陌生的人在认识你的时候，可以更快的识别。</p><blockquote><p>本文转载自：「开源中国」，原文：<a href="https://tinyurl.com/ydxxfv7u%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://tinyurl.com/ydxxfv7u，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇从 “人” (而非技术也非管理)的角度，聚焦于自身职业发展方方面面的文章，包括职业、学习、生产力、影响力等。&lt;/p&gt;
&lt;h2 id=&quot;拥有商业心态&quot;&gt;拥有商业心态&lt;/h2&gt;
&lt;p&gt;你所能犯的最大错误就是相信自己是在为别人工作，职业发展的驱动力一定是来自个体本身，而不是领导、公司，因为职业发展是属于你自己的。如果你真的想在这个充满竞争的世界里脱颖而出，那么你首先必须制订一个坚实可靠而又深思熟虑的计划，学会主动管理自己的职业生涯。&lt;/p&gt;
&lt;p&gt;职业生涯中要做的第一件事便是，转变你的心态。而商业心态对于管理职业规划至关重要。如果你已经习惯于领取一份固定的薪酬，便会很容易导致你产生：你只是在为这家公司打工的谋生心态。尽管在你的职业生涯的某个特定时间段里，你可能确实是在为某家公司打工，但是千万不要因此固化了你的整个职业生涯。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/89257/1562990262645-1c5cf817-03dd-4b0d-82d4-55e4dca112b0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么心态该如何转变呢？首先你要把自己当作一个企业去思考，然后把雇主当作是你这个企业的一个客户。当然，你可能只有这么一个客户，你所有的收入都是从这一个客户得来的，但是这种诠释雇用关系的方式可以将你从雇佣关系的弱势地位转换成为自我治理和自我引导的主动地位，同时，心态转变后能更有利于你做出良好的商业决策。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="思想" scheme="https://www.hi-linux.com/tags/%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 MySQL 优化实施方案</title>
    <link href="https://www.hi-linux.com/posts/34535.html"/>
    <id>https://www.hi-linux.com/posts/34535.html</id>
    <published>2020-05-24T01:16:00.000Z</published>
    <updated>2020-05-24T08:56:22.789Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在进行 MySQL 的优化之前必须要了解的就是 MySQL 的查询过程，很多的查询优化工作实际上就是遵循一些原则让 MySQL 的优化器能够按照预想的合理方式运行而已。</p><p><img src="https://images2017.cnblogs.com/blog/1190037/201801/1190037-20180106134347674-1416660436.png" alt=""></p><p>图 - MySQL查询过程</p><h3 id="优化的哲学">优化的哲学</h3><p>优化有风险，涉足需谨慎</p><h4 id="优化可能带来的问题">优化可能带来的问题</h4><ul><li>优化不总是对一个单纯的环境进行，还很可能是一个复杂的已投产的系统。</li><li>优化手段本来就有很大的风险，只不过你没能力意识到和预见到！</li><li>任何的技术可以解决一个问题，但必然存在带来一个问题的风险！</li><li>对于优化来说解决问题而带来的问题,控制在可接受的范围内才是有成果。</li><li>保持现状或出现更差的情况都是失败！</li></ul><h4 id="优化的需求">优化的需求</h4><ul><li>稳定性和业务可持续性,通常比性能更重要！</li><li>优化不可避免涉及到变更，变更就有风险！</li><li>优化使性能变好，维持和变差是等概率事件！</li><li>切记优化,应该是各部门协同，共同参与的工作，任何单一部门都不能对数据库进行优化！</li><li>所以优化工作,是由业务需要驱使的！！！</li></ul><h4 id="优化由谁参与">优化由谁参与</h4><p>在进行数据库优化时，应由数据库管理员、业务部门代表、应用程序架构师、应用程序设计人员、应用程序开发人员、硬件及系统管理员、存储管理员等，业务相关人员共同参与。</p><h3 id="优化思路">优化思路</h3><h4 id="优化什么">优化什么</h4><p>在数据库优化上有两个主要方面：即安全与性能。</p><ul><li>安全 —&gt; 数据可持续性</li><li>性能 —&gt; 数据的高性能访问</li></ul><h4 id="优化的范围有哪些">优化的范围有哪些</h4><p><em>存储、主机和操作系统方面:</em></p><ul><li>主机架构稳定性</li><li>I/O 规划及配置</li><li>Swap 交换分区</li><li>OS 内核参数和网络问题</li></ul><p><em>应用程序方面:</em></p><ul><li>应用程序稳定性</li><li>SQL语句性能</li><li>串行访问资源</li><li>性能欠佳会话管理</li><li>这个应用适不适合用 MySQL</li></ul><p><em>数据库优化方面:</em></p><ul><li>内存</li><li>数据库结构(物理&amp;逻辑)</li><li>实例配置</li></ul><blockquote><p>说明：不管是在，设计系统，定位问题还是优化，都可以按照这个顺序执行。</p></blockquote><h4 id="优化维度">优化维度</h4><p><em>数据库优化维度有四个:</em></p><p>硬件、系统配置、数据库表结构、SQL及索引</p><p><img src="https://images2017.cnblogs.com/blog/1190037/201801/1190037-20180108160315254-1073768194.png" alt=""></p><p><em>优化选择</em></p><ul><li>优化成本:硬件&gt;系统配置&gt;数据库表结构&gt;SQL及索引</li><li>优化效果:硬件&lt;系统配置&lt;数据库表结构&lt;SQL及索引</li></ul><h3 id="优化工具有啥">优化工具有啥？</h3><h4 id="数据库层面">数据库层面</h4><p>检查问题常用工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql</span><br><span class="line">msyqladmin                                 mysql客户端，可进行管理操作</span><br><span class="line">mysqlshow                                  功能强大的查看shell命令</span><br><span class="line">show [SESSION | GLOBAL] variables          查看数据库参数信息</span><br><span class="line">SHOW [SESSION | GLOBAL] STATUS             查看数据库的状态信息</span><br><span class="line">information_schema                         获取元数据的方法</span><br><span class="line">SHOW ENGINE INNODB STATUS                  Innodb引擎的所有状态</span><br><span class="line">SHOW PROCESSLIST                           查看当前所有连接session状态</span><br><span class="line">explain                                    获取查询语句的执行计划</span><br><span class="line">show index                                 查看表的索引信息</span><br><span class="line">slow-log                                   记录慢查询语句</span><br><span class="line">mysqldumpslow                              分析slowlog文件的</span><br></pre></td></tr></table></figure><p>不常用但好用的工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zabbix                  监控主机、系统、数据库（部署zabbix监控平台）</span><br><span class="line">pt-query-digest         分析慢日志</span><br><span class="line">mysqlslap               分析慢日志</span><br><span class="line">sysbench                压力测试工具</span><br><span class="line">mysql profiling         统计数据库整体状态工具    </span><br><span class="line">Performance Schema      mysql性能状态统计的数据</span><br><span class="line">workbench               管理、备份、监控、分析、优化工具（比较费资源）</span><br></pre></td></tr></table></figure><h4 id="数据库层面问题解决思路">数据库层面问题解决思路</h4><p><em>一般应急调优的思路：</em></p><p>针对突然的业务办理卡顿，无法进行正常的业务处理！需要立马解决的场景！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、show processlist</span><br><span class="line">2、explain  select id ,name from stu where name&#x3D;&#39;clsn&#39;; # ALL  id name age  sex</span><br><span class="line"></span><br><span class="line">            select id,name from stu  where id&#x3D;2-1 函数 结果集&gt;30;</span><br><span class="line"></span><br><span class="line">　　　 show index from table;</span><br><span class="line"></span><br><span class="line">3、通过执行计划判断，索引问题（有没有、合不合理）或者语句本身问题</span><br><span class="line">4、show status  like &#39;%lock%&#39;;    # 查询锁状态</span><br><span class="line">kill SESSION_ID;   # 杀掉有问题的session</span><br></pre></td></tr></table></figure><p><em>常规调优思路：</em></p><p>针对业务周期性的卡顿，例如:在每天 10-11 点业务特别慢，但是还能够使用，过了这段时间就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、查看 slowlog，分析 slowlog，分析出查询慢的语句。</span><br><span class="line">2、按照一定优先级，进行一个一个的排查所有慢语句。</span><br><span class="line">3、分析 top sql，进行 explain 调试，查看语句执行时间。</span><br><span class="line">4、调整索引或语句本身。</span><br></pre></td></tr></table></figure><h4 id="系统层面">系统层面</h4><p><em>CPU 方面</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat、sar top、htop、nmon、mpstat</span><br></pre></td></tr></table></figure><p><em>内存</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free 、ps -aux</span><br></pre></td></tr></table></figure><p><em>IO设备（磁盘、网络）</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat 、 ss  、 netstat 、 iptraf、iftop、lsof</span><br></pre></td></tr></table></figure><p>vmstat 命令说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Procs：r 显示有多少进程正在等待 CPU 时间。b 显示处于不可中断的休眠的进程数量。在等待 I&#x2F;O。</span><br><span class="line">Memory：swpd 显示被交换到磁盘的数据块的数量。未被使用的数据块，用户缓冲数据块，用于操作系统的数据块的数量。</span><br><span class="line">Swap：操作系统每秒从磁盘上交换到内存和从内存交换到磁盘的数据块的数量。s1 和 s0 最好是 0。</span><br><span class="line">Io：每秒从设备中读入 b1 的写入到设备 b0 的数据块的数量。反映了磁盘 I&#x2F;O。</span><br><span class="line">System：显示了每秒发生中断的数量 (in) 和上下文交换 (cs) 的数量。</span><br><span class="line">Cpu：显示用于运行用户代码，系统代码，空闲，等待 I&#x2F;O 的 CPU 时间。</span><br></pre></td></tr></table></figure><p>iostat 命令说明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实例命令：  iostat -dk 1 5</span><br><span class="line">　　　　    iostat -d -k -x 5 （查看设备使用率（%util）和响应时间（await））</span><br><span class="line"></span><br><span class="line">tps：该设备每秒的传输次数。“一次传输”意思是“一次I&#x2F;O请求”。多个逻辑请求可能会被合并为“一次I&#x2F;O请求”。</span><br><span class="line">iops ：硬件出厂的时候，厂家定义的一个每秒最大的 IO 次数。</span><br><span class="line">&quot;一次传输&quot;请求的大小是未知的。</span><br><span class="line">kB_read&#x2F;s：每秒从设备（drive expressed）读取的数据量。</span><br><span class="line">KB_wrtn&#x2F;s：每秒向设备（drive expressed）写入的数据量。</span><br><span class="line">kB_read：读取的总数据量。</span><br><span class="line">kB_wrtn：写入的总数量数据量，这些单位都为Kilobytes。</span><br></pre></td></tr></table></figure><h4 id="系统层面问题解决办法">系统层面问题解决办法</h4><p>你认为到底负载高好，还是低好呢？</p><p>在实际的生产中，一般认为 Cpu 只要不超过 90% 都没什么问题 。</p><p>当然不排除下面这些特殊情况：</p><ul><li>问题一：Cpu 负载高，IO 负载低</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内存不够</span><br><span class="line"></span><br><span class="line">磁盘性能差</span><br><span class="line"></span><br><span class="line">1. SQL 问题 ------&gt; 去数据库层，进一步排查 SQL 问题</span><br><span class="line">2. IO 出问题了（磁盘到临界了、Raid 设计不好、Raid 降级、锁、在单位时间内 TPS 过高）</span><br><span class="line">3. TPS 过高: 大量的小数据 IO、大量的全表扫描</span><br></pre></td></tr></table></figure><ul><li>问题二：IO 负载高，Cpu 负载低</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">大量小的 IO 写操作：</span><br><span class="line"></span><br><span class="line">1. autocommit   ，产生大量小 IO</span><br><span class="line">2. IO&#x2F;PS,磁盘的一个定值，硬件出厂的时候，厂家定义的一个每秒最大的 IO 次数。</span><br><span class="line"></span><br><span class="line">大量大的IO 写操作</span><br><span class="line"></span><br><span class="line">1. SQL问题的几率比较大</span><br></pre></td></tr></table></figure><ul><li>问题三：IO 和 Cpu 负载都很高</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 硬件不够了或 SQL 存在问题</span><br></pre></td></tr></table></figure><h3 id="基础优化">基础优化</h3><h4 id="优化思路">优化思路</h4><p><em>定位问题点吮吸</em></p><p>硬件 --&gt; 系统 --&gt; 应用 --&gt; 数据库 --&gt; 架构（高可用、读写分离、分库分表）</p><p><em>处理方向</em></p><p>明确优化目标、性能和安全的折中、防患未然。</p><h4 id="硬件优化">硬件优化</h4><ul><li>主机方面：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据数据库类型，主机 CPU 选择、内存容量选择、磁盘选择：</span><br><span class="line"></span><br><span class="line">1. 平衡内存和磁盘资源。</span><br><span class="line">2. 随机的 I&#x2F;O 和顺序的 I&#x2F;O。</span><br><span class="line">3. 主机 RAID卡的 BBU (Battery Backup Unit) 关闭。</span><br></pre></td></tr></table></figure><ul><li>Cpu 的选择：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cpu 的两个关键因素：核数、主频，根据不同的业务类型进行选择：</span><br><span class="line"></span><br><span class="line">1. Cpu 密集型：计算比较多，OLTP--&gt;主频很高的 Cpu、核数还要多。</span><br><span class="line">2. IO 密集型：查询比较多，OLAP--&gt;核数要多，主频不一定高的。</span><br></pre></td></tr></table></figure><ul><li>内存的选择：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. OLAP 类型数据库，需要更多内存，和数据获取量级有关。</span><br><span class="line">2. OLTP 类型数据一般内存是 Cpu 核心数量的 2 倍到 4 倍，没有最佳实践。</span><br></pre></td></tr></table></figure><ul><li>存储方面：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 根据存储数据种类的不同，选择不同的存储设备。</span><br><span class="line">2. 配置合理的 RAID 级别(Raid5、Raid10、热备盘)。</span><br><span class="line">3. 对于操作系统来讲，不需要太特殊的选择，最好做好冗余（Raid 1）（SSD、SAS 、SATA）</span><br><span class="line">4. Raid卡：主机 Raid 卡选择：</span><br><span class="line">  4.1 实现操作系统磁盘的冗余（Raid 1）。</span><br><span class="line">  4.2 平衡内存和磁盘资源。</span><br><span class="line">  4.3  随机的 I&#x2F;O 和顺序的 I&#x2F;O。</span><br><span class="line">  4.4 主机 Raid卡的 BBU (Battery Backup Unit) 要关闭。</span><br></pre></td></tr></table></figure><ul><li>网络设备方面：</li></ul><p>使用流量支持更高的网络设备（交换机、路由器、网线、网卡、HBA卡）。</p><blockquote><p>注意：以上这些规划应该在初始设计系统时就应该考虑好。</p></blockquote><h4 id="服务器硬件优化">服务器硬件优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、物理状态灯。</span><br><span class="line">2、自带管理设备：远程控制卡（FENCE 设备：IPMI、ILO、IDARC），开关机、硬件监控。</span><br><span class="line">3、第三方的监控软件、设备（Snmp、Agent）对物理设施进行监控。</span><br><span class="line">4、存储设备：自带的监控平台。EMC2（HP 收购了）、日立（hds）、IBM低端 OEM hds，高端存储是自己技术，华为存储。</span><br></pre></td></tr></table></figure><h4 id="系统优化">系统优化</h4><ul><li>Cpu：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 基本不需要调整，在硬件选择方面下功夫即可。</span><br></pre></td></tr></table></figure><ul><li>内存：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 基本不需要调整，在硬件选择方面下功夫即可。</span><br></pre></td></tr></table></figure><ul><li>Swap：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. MySQL 尽量避免使用 Swap。</span><br><span class="line">2. 阿里云的服务器中默认swap为0</span><br></pre></td></tr></table></figure><ul><li>IO ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. Raid、No LVM、 Ext 4或 XFS、SSD、IO 调度策略。</span><br></pre></td></tr></table></figure><ul><li>Swap 调整方法</li></ul><p>要关闭 Swap 分区，可使用以下方法</p><ol><li>临时关闭方法</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改 /proc/sys/vm/swappiness 的内容改成 0 。</span><br></pre></td></tr></table></figure><ol start="2"><li>永久关闭方法</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysctl.conf 文件中添加 vm.swappiness=0 。</span><br></pre></td></tr></table></figure><p>这个参数决定了 Linux 是倾向于使用 Swap，还是倾向于释放文件系统 Cache。在内存紧张的情况下，数值越低越倾向于释放文件系统Cache。</p><p>当然，这个参数只能减少使用 Swap 的概率，并不能避免 Linux 使用 Swap。</p><ul><li>开启 O_DIRECT 模式</li></ul><p>修改 MySQL 的配置参数 innodb_flush_method，这种情况下，InnoDB 的 Buffer Pool 会直接绕过文件系统 Cache 来访问磁盘，但是 Redo log 依旧会使用文件系统 Cache。</p><p>值得注意的是，Redo log 是覆写模式的，即使使用了文件系统的 Cache，也不会占用太多。</p><ul><li>IO 调度策略</li></ul><ol><li>临时修改为 deadline</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo deadline&gt;&#x2F;sys&#x2F;block&#x2F;sda&#x2F;queue&#x2F;scheduler</span><br></pre></td></tr></table></figure><ol start="2"><li>永久修改</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vi /boot/grub/grub.conf</span><br><span class="line"></span><br><span class="line">更改到如下内容:</span><br><span class="line"></span><br><span class="line">kernel /boot/vmlinuz-2.6.18-8.el5 ro root=LABEL=/ elevator=deadline rhgb quiet</span><br></pre></td></tr></table></figure><h4 id="系统参数调整">系统参数调整</h4><p><em>Linux 系统内核参数优化</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/sysctl.conf</span><br><span class="line"><span class="comment"># 用户端口范围</span></span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65535  </span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096 </span><br><span class="line">net.ipv4.tcp_fin_timeout = 30 </span><br><span class="line"><span class="comment"># 系统最大文件句柄，控制的是能打开文件最大数量</span></span><br><span class="line">fs.file-max=65535</span><br></pre></td></tr></table></figure><p><em>用户限制参数</em></p><p>（MySQL 可以不设置以下配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim    &#x2F;etc&#x2F;security&#x2F;limits.conf </span><br><span class="line">    * soft nproc 65535</span><br><span class="line">    * hard nproc 65535</span><br><span class="line">    * soft nofile 65535</span><br><span class="line">    * hard nofile 65535</span><br></pre></td></tr></table></figure><h4 id="应用优化">应用优化</h4><ol><li>业务应用和数据库应用独立。</li><li>安装图形界面的服务器不要启动图形界面  runlevel 3 。</li><li>防火墙：Iptables、Selinux 等其他无用服务(关闭)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 23456 acpid off</span><br><span class="line">chkconfig --level 23456 anacron off</span><br><span class="line">chkconfig --level 23456 autofs off</span><br><span class="line">chkconfig --level 23456 avahi-daemon off</span><br><span class="line">chkconfig --level 23456 bluetooth off</span><br><span class="line">chkconfig --level 23456 cups off</span><br><span class="line">chkconfig --level 23456 firstboot off</span><br><span class="line">chkconfig --level 23456 haldaemon off</span><br><span class="line">chkconfig --level 23456 hplip off</span><br><span class="line">chkconfig --level 23456 ip6tables off</span><br><span class="line">chkconfig --level 23456 iptables  off</span><br><span class="line">chkconfig --level 23456 isdn off</span><br><span class="line">chkconfig --level 23456 pcscd off</span><br><span class="line">chkconfig --level 23456 sendmail  off</span><br><span class="line">chkconfig --level 23456 yum-updatesd  off</span><br></pre></td></tr></table></figure><p>另外，思考将来我们的业务是否真的需要 MySQL，还是使用其他种类的数据库。用数据库的最高境界就是不用数据库。</p><h3 id="数据库优化">数据库优化</h3><p>SQL优化方向：执行计划、索引、SQL 改写。</p><p>架构优化方向：高可用架构、高性能架构、分库分表。</p><h4 id="数据库参数优化">数据库参数优化</h4><ol><li>实例整体（高级优化，扩展）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread_concurrency       # 并发线程数量个数</span><br><span class="line">sort_buffer_size         # 排序缓存</span><br><span class="line">read_buffer_size         # 顺序读取缓存</span><br><span class="line">read_rnd_buffer_size     # 随机读取缓存</span><br><span class="line">key_buffer_size          # 索引缓存</span><br><span class="line">thread_cache_size        # (1G—&gt;8, 2G—&gt;16, 3G—&gt;32, &gt;3G—&gt;64)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>连接层（基础优化）</p><p>设置合理的连接客户和连接方式</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">max_connections           # 最大连接数，看交易笔数设置    </span><br><span class="line">max_connect_errors        # 最大错误连接数，能大则大</span><br><span class="line">connect_timeout           # 连接超时</span><br><span class="line">max_user_connections      # 最大用户连接数</span><br><span class="line">skip-name-resolve         # 跳过域名解析</span><br><span class="line">wait_timeout              # 等待超时</span><br><span class="line">back_log                  # 可以在堆栈中的连接数量</span><br></pre></td></tr></table></figure><ol start="3"><li>SQL层（基础优化）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_cache_size： 查询缓存   &gt;&gt;&gt;  OLAP类型数据库,需要重点加大此内存缓存，但是一般不会超过GB。对于经常被修改的数据，缓存会立马失效。我们可以使用内存数据库（Redis、Memecache），替代它的相应功能。</span><br></pre></td></tr></table></figure><h4 id="存储引擎层-innodb-基础优化参数">存储引擎层（ Innodb 基础优化参数）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">default-storage-engine</span><br><span class="line">innodb_buffer_pool_size       # 没有固定大小，50% 测试值，看看情况再微调。但是尽量设置不要超过物理内存 70%。</span><br><span class="line">innodb_file_per_table&#x3D;(1,0)</span><br><span class="line">innodb_flush_log_at_trx_commit&#x3D;(0,1,2) # 1 是最安全的，0 是性能最高，2折中。</span><br><span class="line">binlog_sync</span><br><span class="line">Innodb_flush_method&#x3D;(O_DIRECT, fdatasync)</span><br><span class="line">innodb_log_buffer_size        # 100M 以下。</span><br><span class="line">innodb_log_file_size          # 100M 以下。</span><br><span class="line">innodb_log_files_in_group     # 5个成员以下,一般 2-3 个够用（iblogfile 0-N）。</span><br><span class="line">innodb_max_dirty_pages_pct   # 达到百分之 75 的时候刷写内存脏页到磁盘。</span><br><span class="line">log_bin</span><br><span class="line">max_binlog_cache_size         # 可以不设置。</span><br><span class="line">max_binlog_size               # 可以不设置。</span><br><span class="line">innodb_additional_mem_pool_size    #小于2G内存的机器，推荐值是 20 M。32G 内存以上 100M。</span><br></pre></td></tr></table></figure><h3 id="参考文献">参考文献</h3><p>[1]  <a href="https://www.cnblogs.com/zishengY/p/6892345.html" target="_blank" rel="noopener">https://www.cnblogs.com/zishengY/p/6892345.html</a><br>[2]  <a href="https://www.jianshu.com/p/d7665192aaaf" target="_blank" rel="noopener">https://www.jianshu.com/p/d7665192aaaf</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;div id=&quot;vip-container&quot;&gt;&lt;p&gt;在进行 MySQL 的优化之前必须要了解的就是 MySQL 的查询过程，很多的查询优化工作实际上就是遵循一些原则让 MySQL 的优化器能够按照预想的合理方式运行而已。&lt;/p&gt;
&lt;p&gt;&lt;img
        
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="MySQL" scheme="https://www.hi-linux.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>浅谈中台</title>
    <link href="https://www.hi-linux.com/posts/22676.html"/>
    <id>https://www.hi-linux.com/posts/22676.html</id>
    <published>2020-05-24T01:15:00.000Z</published>
    <updated>2020-05-24T08:56:22.787Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="背景">背景</h2><p>自从阿里巴巴现任CEO逍遥子在2015年提出”大中台，小前台”战略以来，关于”什么是中台”，可谓是一石激起千层浪，大量文章在描述什么是中台。而不懂的人看完后依旧是云里雾里，我们经常听到一些词：”业务中台”，”技术中台”, “系统中台”等，我相信很多同学都会懵逼。今天我们就来彻底的理解下什么是中台和中台战略。</p><h2 id="中台的本质理解">中台的本质理解</h2><p>凡是能帮助我们快速的生产产品而不需要大量重复性研发的系统，就可以称之为中台。这句话同样适用于硬件产品。举个例子，苹果公司的手机生产线平台，早期每次设计出一款新的苹果手机时都需要对生产线上的机器人做大量修改才能满足生产一款新iphone的需求。随着科技进步，苹果对生产线做了升级。每次设计师设计出新的iphone时，只需要在一个系统中进行任务编排和参数配置，整个生产线即可投入新款iphone的生产之中，这样的一套生产线平台就可以称之为”Iphone生产中台”。</p><p>为了进一步的解释中台，了解它的词性，我们来理解下一个日常生活中经常用到的词——”帮手”，我们经常这么说：</p><ul><li><p>王强真是我的好帮手，每次做手术时，他都知道我下一步想要什么。</p></li><li><p>你给我找个帮手来，帮我把电视抬上楼。</p></li><li><p>这个打蛋器真是家庭主妇的好帮手。</p></li></ul><a id="more"></a><p>我们几乎不会这么去问”什么是帮手”，显得很傻。同样的，真正了解了什么是中台和中台的词性后，我们也不太会问”什么是中台”。而换些问法就对了：</p><ul><li><p>你们公司发布新产品这么快，是用了什么产品中台？</p></li><li><p>你们公司技术开发一个新应用这么快，系统中台应该建设的不错吧！</p></li><li><p>这次我们接入支付功能这么快，多亏了你们支付中台。</p></li></ul><p>所以中台系统最为本质的含义，就是低成本高效率生产产品的系统。金融公司隔三差五的就能生成一个新的贷款产品，这就依赖强大的产品中台；公司一周就开发一个新业务应用，这就很可能是得益于其系统中台的强大；阿里内部强调的系统中台建设，就是将支付、商品、会员等经典的电商领域系统做到足够通用和可编排，减少重复的开发成本，任何对接系统中台的应用就是使用了某个中台的产品。比如接入了支付中台，代表的就是使用了一个支付产品（需要一定的视角转换），具体的接入可能包含申请账号，配置和编排支付流程，投入使用等。</p><h2 id="中台的形式和建设之路">中台的形式和建设之路</h2><p>首先，中台并不拘泥于其存在形式，它可以是PaaS，SaaS或者是PaaS+SaaS，也可能就是一个后台网站，甚至是一个PC应用。记住它的本质：低成本高效率生产新产品。 所以中台战略适用于任意规模的公司，用编程思想来看，这就是一种提高复用性的设计，降低的是研发成本，提高的快速试错和上线的能力。不过需要说明的是，大公司的中台战略和小公司的中台战略大概率是不一样的，用大公司的中台战略去指导小公司的研发是不现实的，也是不明智的。 一般来说，中台建设过程分一下几个步骤：</p><ol><li><p>定义需要快速变化、试错和上线的产品。(如果您都无法清晰的定义自己的产品是啥，那估计是走偏了)。</p></li><li><p>分析产品的属性，哪些是通用的，哪些又是多变的。</p></li><li><p>研发生产产品所需的通用逻辑，用开放式的设计来兼容那些多变的属性。</p></li></ol><p>有同学会提出一开始考虑不到位，很大概率设计的中台不够通用。确实是这样的，中台设计的优秀度很大程度依赖于设计师的经验。中台建设也不是一触而就的，更多的是在对过往工作总结后高度的沉淀和抽象。说到这里估计很多开发同学会产生共鸣了，这和写代码的要求很像。再谈阿里的中台战略，阿里作为一个定位为经济体的大集团公司，其各个BU业务五花八门，并且每个BU都有自己的研发团队。而大部分BU为电商，这就意味着存在大量功能相同的系统，比如订单、商品、支付、会员等。面对如此大的研发成本重合，高层进行了反思——如果将这些通用的逻辑抽象出来，把个性化部分做成配置化，那么一来会节省大量的研发成本（时间和资金），二来可以快速的生产各种业务前台，便于商业模式验证、快速试错或快速占领市场。</p><p>放到小公司，阿里的这种中台建设之路就不适用了，为每个领域去开发一套中台是一件非常奢侈的事。小公司应该聚焦自生的产品，建设具有有限通用性的中台。</p><p>说到这里，中台建设是不是更像一条企业对象优化自生生产过程的必经之路呢？</p><blockquote><p>本文转载自：「TBWORKs’ ZONE」，原文：<a href="https://url.cn/5YLXBrq%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5YLXBrq，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;自从阿里巴巴现任CEO逍遥子在2015年提出”大中台，小前台”战略以来，关于”什么是中台”，可谓是一石激起千层浪，大量文章在描述什么是中台。而不懂的人看完后依旧是云里雾里，我们经常听到一些词：”业务中台”，”技术中台”, “系统中台”等，我相信很多同学都会懵逼。今天我们就来彻底的理解下什么是中台和中台战略。&lt;/p&gt;
&lt;h2 id=&quot;中台的本质理解&quot;&gt;中台的本质理解&lt;/h2&gt;
&lt;p&gt;凡是能帮助我们快速的生产产品而不需要大量重复性研发的系统，就可以称之为中台。这句话同样适用于硬件产品。举个例子，苹果公司的手机生产线平台，早期每次设计出一款新的苹果手机时都需要对生产线上的机器人做大量修改才能满足生产一款新iphone的需求。随着科技进步，苹果对生产线做了升级。每次设计师设计出新的iphone时，只需要在一个系统中进行任务编排和参数配置，整个生产线即可投入新款iphone的生产之中，这样的一套生产线平台就可以称之为”Iphone生产中台”。&lt;/p&gt;
&lt;p&gt;为了进一步的解释中台，了解它的词性，我们来理解下一个日常生活中经常用到的词——”帮手”，我们经常这么说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;王强真是我的好帮手，每次做手术时，他都知道我下一步想要什么。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你给我找个帮手来，帮我把电视抬上楼。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个打蛋器真是家庭主妇的好帮手。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="分布式" scheme="https://www.hi-linux.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用 Tiny Tiny RSS 部署一个私有 RSS 服务器</title>
    <link href="https://www.hi-linux.com/posts/47278.html"/>
    <id>https://www.hi-linux.com/posts/47278.html</id>
    <published>2020-05-24T01:14:00.000Z</published>
    <updated>2020-05-24T08:37:53.031Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>9012 年了，别的小朋友们服务器上面跑着各式各样的东西：博客、云盘、监控脚本……再看看我们那台闲（bai）置（piao）很久的阿里云 Server，里面的 Git 竟然还是 1.8 的上古版本。🤦‍♂️ 不如把那台服务器拿出来，部署一个属于自己的 RSS 服务器，甚至可以跟同学们一起用呢～</p><h2 id="rss">RSS</h2><p>首先我们来说一说 RSS。RSS 的全称是 Really Simple Syndication（简易信息聚合），它是一种消息来源的格式规范，网站可以按照这种格式规范提供文章的标题、摘要、全文等信息给订阅用户，用户可以通过订阅不同网站 RSS 链接的方式将不同的信息源进行聚合，在一个工具里阅读这些内容。</p><p>对于第一次接触 RSS 的同学，推荐大家阅读：<a href="https://sspai.com/post/56391" target="_blank" rel="noopener">高效获取信息，你需要这份 RSS 入门指南</a>，进行扫盲。</p><p>市面上有非常多的 RSS 聚合服务，来帮助我们统一管理、订阅、更新、筛选 RSS 源推送给我们的更新信息，避免我们被海量的文章淹没，也能保证我们多个设备上 RSS 的阅读进度一致。Feedly、Inoreader 等等都是非常不错的 RSS 服务，但是它们的免费版本都有着一定的限制，有时候无法满足我们的全部功能需求，而动辄一个月数十刀的订阅费用又让人望而却步。不慌，开源的 RSS 服务：Tiny Tiny RSS 可以满足我们 RSS 订阅的全部需求！</p><h2 id="tiny-tiny-rss-的搭建">Tiny Tiny RSS 的搭建</h2><p><img src="https://i.loli.net/2019/11/19/aCty2KspU5f1gHr.jpg" alt="使用 Feedly 主题的 Tiny Tiny RSS 服务端"></p><p>Tiny Tiny RSS 是一个非常优秀的开源免费 RSS 服务引擎，可以直接部署在我们自己的服务器上面，借助于 Docker 优秀方便的容器技术和 Let’s Encrypt 异常简单的 SSL 证书签署机器人 <code>certbot</code>，我们几分钟之内就可以部署上线属于我们自己的 RSS 服务，运行在我们可控的服务器上，环境稳定，刷新及时，并且完全免费。👍（当然，除了服务器需要一定的费用。）</p><p>在容器、HTTPS 证书自动签署和虚拟化技术极度发达的今天，整个部署过程非常方便简单。我接下来只利用 iPad 进行讲解演示我们的部署过程。请大家坐好，我们立刻开始。</p><a id="more"></a><h2 id="准备工作">准备工作</h2><p>在开始之前，首先我们需要准备一个位于公网的服务器，以及一个可以通过 SSH 连接到服务器上的本地设备。这里我使用我同（bai）学（piao）的已经备案的阿里云服务器作为运行 Tiny Tiny RSS 的服务器，并使用 iPad 和 Blink Shell（一个支持 SSH 协议的 iOS 终端 App）作为我的操作设备。Blink Shell 是 iPad 上面最好用的 SSH/Mosh 工具，推荐大家使用。我们在 Blink Shell 中配置好服务器私钥，通过 SSH 登录服务器。</p><p><img src="https://i.loli.net/2019/11/19/iyk8KrUBYzodPqS.jpg" alt="利用 Blink Shell 登录至服务器"></p><h2 id="利用-docker-部署-tiny-tiny-rss">利用 Docker 部署 Tiny Tiny RSS</h2><h3 id="安装-docker">安装 Docker</h3><p>Docker 是非常优秀的虚拟化容器，借助于 Docker 我们可以方便的部署 Tiny Tiny RSS，首先我们在服务器上安装 Docker 本体。在服务器上面执行下面命令来安装 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>然后启动 Docker 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>然后，我们检查一下 Docker 是否启动成功。我们执行命令：<code>sudo systemctl status docker</code>：</p><p><img src="https://i.loli.net/2019/11/20/L6VicoJy8OCBpxq.jpg" alt="检查 Docker 服务状态"></p><p>看到如上的输出，说明我们 Docker 服务启动成功。</p><p><em>参考资料：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">Get Docker Engine - Community for CentOS | Docker Documentation</a></em></p><h3 id="安装-docker-compose">安装 docker-compose</h3><p>接下来我们安装 <code>docker-compose</code>：一个管理和启动多个 Docker 容器的工具。由于 Tiny Tiny RSS 依赖有 PostgreSQL 的数据库服务以及 <a href="https://github.com/HenryQW/mercury_fulltext" target="_blank" rel="noopener">mercury_fulltext</a> 的全文抓取服务等等，这些服务我们都借助于 Docker 部署，因此利用 <code>docker-compose</code> 就会大大降低我们的部署难度。</p><p>我们继续，在服务器上面执行下面的命令来安装 <code>docker-compose</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p>之后给予安装好的 <code>docker-compose</code> 可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p><em>参考资料：<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">Install Docker Compose | Docker Documentation</a></em></p><p>最后我们运行 <code>docker-compose --version</code> 来检查安装是否成功。如果有如下输出，说明我们的 <code>docker-compose</code> 安装成功：</p><p><img src="https://i.loli.net/2019/11/20/6j3QgG1FszTPp5Y.jpg" alt="检查 docker-compose 安装情况"></p><h3 id="安装-tiny-tiny-rss-及其周边服务">安装 Tiny Tiny RSS 及其周边服务</h3><p>准备工作已经全部完成，接下来我们下载由 Awesome-TTRSS 配置的 Tiny Tiny RSS 服务的 docker-compose 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 ttrss 目录并进入</span></span><br><span class="line">mkdir ttrss &amp;&amp; <span class="built_in">cd</span> ttrss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 curl 下载 ttrss 的 docker-compose 配置文件至服务器</span></span><br><span class="line">curl -fLo docker-compose.yml https://github.com/HenryQW/Awesome-TTRSS/raw/master/docker-compose.yml</span><br></pre></td></tr></table></figure><p>修改 docker-compose.yml 里面的内容：</p><p><img src="https://i.loli.net/2019/11/20/sn4MP8uvb3WIzDt.png" alt="修改 docker-compose 配置文件"></p><ul><li>在配置文件的第 7 行和第 23 行，将 PostgreSQL 数据库的默认密码进行修改。暴露在公网的数据库使用默认密码非常危险。</li><li>在配置文件的第 18 行，将 Tiny Tiny RSS 服务的部署网址修改。比如我的部署网址是 <code>https://ttrss.tenkeyseven.com/</code><ul><li>注意，如果你的部署 URL 包含端口（比如默认部署端口为 181 端口），那么这里的 URL 也需要加上端口号，格式为 <code>{网址}:{端口}</code></li><li>不过不必担心，如果你这里的 URL 配置不正确，那么访问 Tiny Tiny RSS 的时候，Tiny Tiny RSS 会提醒你修改这里的值为正确的 URL，按照提醒进行配置即可</li></ul></li></ul><p>之后，我们保存配置文件，启动 Tiny Tiny RSS 服务。在刚刚的 <code>ttrss</code> 目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>等待脚本执行完成，如果一切没有问题，那么接下来输入 <code>docker ps</code>，我们应该看到类似下面的结果：</p><p><img src="https://i.loli.net/2019/11/20/AxTdoa7YJCgI5i4.jpg" alt="查看正在运行的 Docker 容器"></p><p>上面内容表示我们开启了四个 Docker 容器，分别是：</p><ul><li>Tiny Tiny RSS 本身，监听端口为 <code>0.0.0.0:181 -&gt; 80</code>，同时暴露给外网</li><li>PostgreSQL 数据库，仅供内部使用</li><li>Mercury 全文抓取服务，仅供内部使用</li><li>OpenCC 简体、繁体中文转换服务，仅供内部使用</li></ul><p>如果发现问题，修改 docker-compose 配置文件后，需要执行下面的命令重启 Docker 容器们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭 Docker 容器们</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除已停止的 Docker 容器</span></span><br><span class="line">docker-compose rm</span><br><span class="line"></span><br><span class="line"><span class="comment"># ……</span></span><br><span class="line"><span class="comment"># 修改 docker-compose 配置文件</span></span><br><span class="line"><span class="comment"># ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次开启 Docker 服务</span></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="安装-nginx-作为-docker-容器的反向代理">安装 Nginx 作为 Docker 容器的反向代理</h2><p>事实上，到上一步，如果我们访问 <code>{服务器 IP}:181</code>，应该可以直接看到 Tiny Tiny RSS 的 Web 前端，但是 Tiny Tiny RSS 并不能直接配置 SSL 证书，也就没法添加 HTTPS 支持。我们利用 Nginx 作为反向代理服务器，即可方便的给 Tiny Tiny RSS 单独绑定一个我们希望的域名，并利用 Let’s Encrypt 来部署 HTTPS。</p><h3 id="安装-nginx">安装 Nginx</h3><p>首先我们来安装 Nginx，以 CentOS 为例，我们直接执行下面命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nginx</span><br></pre></td></tr></table></figure><p>之后开启 Nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx</span><br></pre></td></tr></table></figure><p>检查 Nginx 是否启动成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/20/gakiyznx5NhXT16.jpg" alt="检查 Nginx 运行状态"></p><h3 id="签署-ssl-证书部署-https">签署 SSL 证书，部署 HTTPS</h3><p>之后，我们利用 Let’s Encrypt 提供的 <code>certbot</code> 直接为 Nginx 配置 SSL 证书。首先，我们执行下面的命令安装 <code>certbot</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install certbot python2-certbot-nginx</span><br></pre></td></tr></table></figure><p>然后运行 <code>certbot</code> 来签署 SSL 证书并自动配置 Nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot --nginx</span><br></pre></td></tr></table></figure><p><em>参考资料：<a href="https://certbot.eff.org/lets-encrypt/centosrhel7-nginx" target="_blank" rel="noopener">Certbot | Nginx on CentOS/RHEL 7</a></em></p><p>在这里，certbot 会要求我们输入我们希望签署 SSL 证书的域名，我们选择为 Tiny Tiny RSS 分配的域名（比如我的就是 <code>ttrss.tenkeyseven.com</code>）即可。另外，如果 certbot 询问是否需要将访问该网址的全部流量重定向至 HTTPS，那么选择「是」即可。我们等待脚本执行签署任务完毕，然后重启 Nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><p>此时我们如果直接访问这一域名，应该就可以看到带有 HTTPS 的 Nginx 默认网站：</p><p><img src="https://i.loli.net/2019/11/20/jWwRplvBD8oOczJ.jpg" alt="HTTPS 配置成功的 Nginx 默认网站"></p><p>接下来，我们修改 Nginx 的配置文件，配置 Nginx 反向代理，将访问 <code>https://ttrss.tenkeyseven.com</code> 的请求指向我们刚刚部署好的 Tiny Tiny RSS 服务，对服务器来说，也就是 <code>127.0.0.1:181</code> 这一地址。（如果你没有更改 Tiny Tiny RSS 的端口号的话。）</p><p>Nginx 的配置文件位于 <code>/etc/nginx/nginx.conf</code>，我们打开这一文件：</p><p><img src="https://i.loli.net/2019/11/20/J9yaSejPN1iLnkO.png" alt="Nginx 配置文件"></p><ul><li><p>在 <code>http</code> 项下，<code>server</code> 项前定义 <code>upstream</code> 服务：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream ttrssdev &#123;</span><br><span class="line">server 127.0.0.1:181;</span><br><span class="line">keepalive 64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/20/XLAlTsegadr5cPE.jpg" alt="Nginx upstream 服务声明"></p></li><li><p>在刚刚 <code>certbot</code> 为我们生成好的响应域名 <code>server</code> 项下，注释掉第一行定义 <code>root</code> 的内容，并将 <code>location /</code> 项修改为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_redirect off;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;ttrssdev;</span><br><span class="line"></span><br><span class="line">proxy_set_header  Host                $http_host;</span><br><span class="line">proxy_set_header  X-Real-IP           $remote_addr;</span><br><span class="line">proxy_set_header  X-Forwarded-Ssl     on;</span><br><span class="line">proxy_set_header  X-Forwarded-For     $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_set_header  X-Forwarded-Proto   $scheme;</span><br><span class="line">proxy_set_header  X-Frame-Options     SAMEORIGIN;</span><br><span class="line"></span><br><span class="line">client_max_body_size        100m;</span><br><span class="line">client_body_buffer_size     128k;</span><br><span class="line"></span><br><span class="line">proxy_buffer_size           4k;</span><br><span class="line">proxy_buffers               4 32k;</span><br><span class="line">proxy_busy_buffers_size     64k;</span><br><span class="line">proxy_temp_file_write_size  64k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/20/LVXAFOfywRB2inr.jpg" alt="Nginx 配置文件：反向代理配置"></p></li></ul><p>这样，我们再次执行 <code>sudo systemctl restart nginx</code> 重启 Nginx 服务，一切顺利的话，我们就可以通过我们刚刚签署 SSL 证书的域名访问我们部署好的 Tiny Tiny RSS 服务了！鼓掌 👏</p><p>Tiny Tiny RSS 的默认管理员账户密码是 admin 和 password，请在第一时间进行修改。</p><h2 id="配置-tiny-tiny-rss">配置 Tiny Tiny RSS</h2><p><img src="https://i.loli.net/2019/11/20/cis6yUboY2KStEn.jpg" alt="Tiny Tiny RSS 配置、主题"></p><p>如果上面步骤没有问题的话，我们在服务器上面所部署的 Tiny Tiny RSS 本身就已经包含了：</p><ul><li>Mercury 全文提取服务（默认未开启）</li><li>OpenCC 繁简自动转换服务（默认未开启）</li><li>Fever 格式输出插件（默认已开启，用来和 Reeder 等客户端进行连接）</li><li>包括 Feedly、RSSHub 在内的多款主题</li><li>等等……</li></ul><p>我们不需要多余的配置，开箱即可使用上面的主题和插件，根本不需要操心其他服务的部署和安装。我们登录自己的 Tiny Tiny RSS，在右上角「设置→ 插件」中即可启用上述插件，在「设置 → 主题」处就可以更改我们部署的 Tiny Tiny RSS 所用的主题。这些插件和主题在 <a href="https://sspai.com/post/41302" target="_blank" rel="noopener">如何搭建属于自己的 RSS 服务，高效精准获取信息</a> 中已经介绍了使用方法，这里我就不再赘述了。</p><p>如果有同学对上面的配置还有问题，请直接参考 <a href="https://ttrss.henry.wang/zh/#%E6%8F%92%E4%BB%B6" target="_blank" rel="noopener">Awesome TTRSS 的官方文档：🐋 Awesome TTRSS | 插件</a></p><h2 id="小结">小结</h2><p>Tiny Tiny RSS 的配置到这里就基本结束了，我相信你通过上面的配置一定已经在自己的服务器上部署成功了 Tiny Tiny RSS 服务，并为它添加了域名和 HTTPS 的支持。另外，Tiny Tiny RSS 还自带了账号系统，可以邀请其他志同道合的朋友们一起使用我们自己部署的 Tiny Tiny RSS。感谢阅读。</p><p>📖 关联阅读：</p><ul><li><a href="https://ttrss.henry.wang/zh/#%E5%85%B3%E4%BA%8E" target="_blank" rel="noopener">🐋 Awesome TTRSS</a></li><li><a href="https://sspai.com/post/56893" target="_blank" rel="noopener">Docker 的入门「指北」</a></li><li><a href="https://sspai.com/post/41302" target="_blank" rel="noopener">如何搭建属于自己的 RSS 服务，高效精准获取信息</a></li></ul><blockquote><p>本文转载自：「Spencer’s Blog」，原文：<a href="https://url.cn/5oFe33h%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5oFe33h，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;9012 年了，别的小朋友们服务器上面跑着各式各样的东西：博客、云盘、监控脚本……再看看我们那台闲（bai）置（piao）很久的阿里云 Server，里面的 Git 竟然还是 1.8 的上古版本。🤦‍♂️ 不如把那台服务器拿出来，部署一个属于自己的 RSS 服务器，甚至可以跟同学们一起用呢～&lt;/p&gt;
&lt;h2 id=&quot;RSS&quot;&gt;RSS&lt;/h2&gt;
&lt;p&gt;首先我们来说一说 RSS。RSS 的全称是 Really Simple Syndication（简易信息聚合），它是一种消息来源的格式规范，网站可以按照这种格式规范提供文章的标题、摘要、全文等信息给订阅用户，用户可以通过订阅不同网站 RSS 链接的方式将不同的信息源进行聚合，在一个工具里阅读这些内容。&lt;/p&gt;
&lt;p&gt;对于第一次接触 RSS 的同学，推荐大家阅读：&lt;a href=&quot;https://sspai.com/post/56391&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;高效获取信息，你需要这份 RSS 入门指南&lt;/a&gt;，进行扫盲。&lt;/p&gt;
&lt;p&gt;市面上有非常多的 RSS 聚合服务，来帮助我们统一管理、订阅、更新、筛选 RSS 源推送给我们的更新信息，避免我们被海量的文章淹没，也能保证我们多个设备上 RSS 的阅读进度一致。Feedly、Inoreader 等等都是非常不错的 RSS 服务，但是它们的免费版本都有着一定的限制，有时候无法满足我们的全部功能需求，而动辄一个月数十刀的订阅费用又让人望而却步。不慌，开源的 RSS 服务：Tiny Tiny RSS 可以满足我们 RSS 订阅的全部需求！&lt;/p&gt;
&lt;h2 id=&quot;Tiny-Tiny-RSS-的搭建&quot;&gt;Tiny Tiny RSS 的搭建&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/19/aCty2KspU5f1gHr.jpg&quot; alt=&quot;使用 Feedly 主题的 Tiny Tiny RSS 服务端&quot;&gt;&lt;/p&gt;
&lt;p&gt;Tiny Tiny RSS 是一个非常优秀的开源免费 RSS 服务引擎，可以直接部署在我们自己的服务器上面，借助于 Docker 优秀方便的容器技术和 Let’s Encrypt 异常简单的 SSL 证书签署机器人 &lt;code&gt;certbot&lt;/code&gt;，我们几分钟之内就可以部署上线属于我们自己的 RSS 服务，运行在我们可控的服务器上，环境稳定，刷新及时，并且完全免费。👍（当然，除了服务器需要一定的费用。）&lt;/p&gt;
&lt;p&gt;在容器、HTTPS 证书自动签署和虚拟化技术极度发达的今天，整个部署过程非常方便简单。我接下来只利用 iPad 进行讲解演示我们的部署过程。请大家坐好，我们立刻开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="RSS" scheme="https://www.hi-linux.com/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款英语学习神器 Rosetta Stone</title>
    <link href="https://www.hi-linux.com/posts/32690.html"/>
    <id>https://www.hi-linux.com/posts/32690.html</id>
    <published>2020-05-24T01:11:00.000Z</published>
    <updated>2020-05-24T08:37:53.028Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>这是一篇旧文重发，近日又见不少同学在讨论英语学习的方法和重要性。或许本文涉及相关内容就是你的最好选择，本文涉及的相关软件已更新到最新版本。</p></blockquote><p>在这个技术高速发展的时代，新技术日新月异、层出不穷。而这些新技术基本上都是外国人开发的，并且提供的文档通常只有英文的。</p><p>如果想在第一时间掌握到最新的资讯或是解决遇到的问题，满屏的英文认识的单词没几个，这个时候会不会有种书到用时方恨少的感觉。</p><p>今天给你推荐一款学习外语的神器「Rosetta Stone」，这个软件是我从一篇「告诉你外语学习的真实方法及误区分析」文章中得知的。此文是一篇对外语学习非常有用的文章，里面谈到了学外语的四个阶段。该文章电子版本已经放到文末下载地址里了，有兴趣的同学可以读一读。</p><p>「Rosetta Stone」强调的是一个沉浸式的语言环境，学习新语言的方法与您学习母语的方法相同。教您用新的语言说话和思考。自然地发展基本的语言技能，无需依赖翻译和死记硬背。</p><p><img src="https://www.hi-linux.com/img/linux/Rosetta-Stone.jpeg" alt=""></p><a id="more"></a><p>「Rosetta Stone」课程主要分为以下几部分：</p><ol><li><p>核心课程 (包含本节主要内容, 形式：用鼠标选择即可，没有发声、拼写。)</p></li><li><p>发音 (以鼠标选择的形式)</p></li><li><p>词汇 (以鼠标选择的形式)</p></li><li><p>语法 (以鼠标选择的形式)</p></li><li><p>阅读 (用 Mic 读)</p></li><li><p>写作 (用鼠标点击屏幕上的软键盘，来拼写单词。)</p></li><li><p>听力 (以鼠标选择的形式)</p></li><li><p>听力与阅读 (以鼠标选择的形式)</p></li><li><p>口语 (以鼠标选择的形式)</p></li><li><p>复习 (以鼠标选择的形式)</p></li><li><p>重点 (四节课一次， 以鼠标选择的形式)</p></li></ol><p>看上去是不是很不错？零基础，不需要背语法，不需要背单词。还不快快安装学起来吧！</p><p>如果你的英语已经非常的厉害了，你还可以用来学习其它外语呢！「Rosetta Stone」不仅可以学习英语，还可以学习西班牙语、汉语、日语、德语、法语和意大利语等 24 种语言。</p><p>说了这么多「Rosetta Stone」的好处，现在告诉你个坏消息，「Rosetta Stone」其实是一个收费软件，而且还很贵。有没有世界都要崩塌了的感觉，呵呵！</p><p>好了，说了这么多废话。现在重点来了，直接在公众号回复关键词:「<strong>外语</strong>」，可获取「Rosetta Stone」最新特别版 (已解锁所有课程) 下载地址哟 。还在等什么呢，赶快去下载吧！</p><blockquote><p>「Rosetta Stone」目前有 Windows、Macos、IOS 版本。这里暂时只提供 Android 版本，其它版本可以自己搜一搜。</p></blockquote><p>最后，软件再好也只是辅助，坚持和反复练习才是最终获胜的大杀器！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是一篇旧文重发，近日又见不少同学在讨论英语学习的方法和重要性。或许本文涉及相关内容就是你的最好选择，本文涉及的相关软件已更新到最新版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个技术高速发展的时代，新技术日新月异、层出不穷。而这些新技术基本上都是外国人开发的，并且提供的文档通常只有英文的。&lt;/p&gt;
&lt;p&gt;如果想在第一时间掌握到最新的资讯或是解决遇到的问题，满屏的英文认识的单词没几个，这个时候会不会有种书到用时方恨少的感觉。&lt;/p&gt;
&lt;p&gt;今天给你推荐一款学习外语的神器「Rosetta Stone」，这个软件是我从一篇「告诉你外语学习的真实方法及误区分析」文章中得知的。此文是一篇对外语学习非常有用的文章，里面谈到了学外语的四个阶段。该文章电子版本已经放到文末下载地址里了，有兴趣的同学可以读一读。&lt;/p&gt;
&lt;p&gt;「Rosetta Stone」强调的是一个沉浸式的语言环境，学习新语言的方法与您学习母语的方法相同。教您用新的语言说话和思考。自然地发展基本的语言技能，无需依赖翻译和死记硬背。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/Rosetta-Stone.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://www.hi-linux.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>TTY 的前世今生</title>
    <link href="https://www.hi-linux.com/posts/2960.html"/>
    <id>https://www.hi-linux.com/posts/2960.html</id>
    <published>2020-05-24T01:10:00.000Z</published>
    <updated>2020-05-24T08:37:53.032Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="译者序">译者序</h2><p>本文翻译自 2008 年的一篇帖子 The TTY demystified.</p><p>由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。</p><p>以下是译文。</p><h2 id="目录">目录</h2><ol><li><p>历史</p></li><li><p>使用场景</p></li><li><p>进程</p></li><li><p>作业（Jobs）和会话</p></li><li><p>简单粗暴的信号机制</p></li><li><p>一个例子</p></li><li><p>流控和阻塞式 I/O</p></li><li><p>配置 TTY 设备</p></li><li><p>结束语</p></li></ol><p>TTY 子系统是 Linux 乃至 Unix 家族中最核心的设计之一。</p><p>但不幸的是，TTY 的重要性经常被低估，而且网上也很难找到不错的介绍性文章。而我认为，对 Linux 中的 TTY 有一些基本了解对于开发者和高级用户来说是非常有帮助的。</p><p>但要注意：接下来你将看到的东西并不是非常优雅。事实上，TTY 子系统 —— 虽然从用户的角度来非常好用 —— 是很多特殊场景杂糅在一起的结果。而要理解为什么会变成这样， 我们需要从历史说起。</p><h2 id="1-历史">1. 历史</h2><p>1869，人类发明了股票自动报价机（stock ticker）。它是一个用于跨长距离实时传 递股票价格的电子-机械设备，由一个打字机（typewriter）、一对很长的电缆（a long pair of wires）和一个报价用的磁带打印机（tape printer）组成。后来，这个概念逐渐 进化成速度更快的、基于 ASCII 码的电传打印机（teletype）。电传打印机曾通过一个称 为 Telex 的网络实现全球互联，用于传递商业电报，但它们并没有连接到任何计算机（ computers）。</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/oldschool.jpg" alt=""></p><p>20 世纪 40 年代的真实电传打印机（teletypes）</p><p>在同一时期，计算机 —— 虽然仍是很大很原始的机器，但能处理多任务（multitask）—— 开始变得越来越强大，足以实现与用户的实时交互。当命令行（command line）最终取代 了老式的批处理模型（batch processing model）后，人们直接将电传打印机用作了计算 机的输入和输出设备（input and output devices），因为这些设备在市场上很容易买到。</p><p>但此时面临的一个问题是：市场上有大量的电传打印机模型，所有模型之间都有一些细 微差别，因此就需要某种层面的软件中间层来屏蔽这些差异。Unix 世界中的方式是** 让操作系统内核来处理所有的低层（low-level）细节，例如 word 长度、波特率（baud rate）、流控（flow control）、奇偶校验（parity）、基本的行编辑（line editing）功 能所用的控制码等等。而 20 世纪 70 年代随着例如 VT-100 这样的固态视频终端（solid state video terminals）的出现而变成为现实的光标炫酷移动、彩色输入和其他高级特 性，则交给应用（application）来控制**。</p><p>如今在我们的世界中，物理电传打印机和视频终端事实上已经绝迹了。除非你去参观某个博 物馆或者硬件爱好者的私藏，否则你能看到的所有 TTY 很可能都是仿真（模拟）的视频 终端（emulated video terminals）——用软件去模拟真实硬件。但我们将会看到，这些传 统的钢铁浇筑的怪兽仍然潜伏在表面的平静之下。</p><a id="more"></a><h2 id="2-使用场景">2. 使用场景</h2><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/case1.png" alt=""></p><p>用户（通过一个物理电传打印机）在一个终端上输入（打字）。这个终端通过一对电缆连接 到计算机上的一个 UART（Universal Asynchronous Receiver and Transmitter，通用异步收发器）。操作系统中安装了 UART 驱动，能够处理字节的物理传输，包括奇偶校验和流控。在一个简陋的系统中，UART 驱动会将收到的字节直接发送给某个应用进程 。但是，以上方式缺少下列必备特性：</p><h3 id="21-行编辑line-editing">2.1 行编辑（Line editing）</h3><p>大部分用户都难免在打字时犯错，因此退格键（backspace key）是很有必要的。 这个功能当然可以由应用自己实现，但按照 Unix 的设计哲学，应用应该越简单越好。因此 ，为了方便，操作系统提供了一个编辑缓冲区（editing buffer）以及一些基本 的编辑命令（退格、擦除单词、清除行、重新打印），这些功能在 line discipline（行 规程）中是默认开启的。</p><p><strong>Line discipline</strong></p><p>高级应用可以选择关闭这些特性，只要将 line discipline 从默认（或 canonical） 模式改为 raw 模式就行了。大部分交互式应用（编辑器、邮件用户 agent、shell，以及 所有依赖 curses 或 readline 的程序）都运行在 raw 模式，自己来处理所有的行编辑 命令。line discipline 还包含了字符回显（character echoing）和回车/换行（ carriage returns and linefeeds）自动转换的功能。如果你愿意，可以将其想象成内核 中的 sed(1)。</p><p>出于某些偶然的原因，内核提供了多种 line discipline。但在任何时刻，对于某个给 定的串行设备，内核只会 attach 其中的一种到这个设备。默认的 discipline 叫 N_TTY（位于 drivers/char/n_tty.c，如果你喜欢刨根究底）。其他几种 disciplines 用于不同目的，例如管理包交换数据（packet switched data，例如 ppp, IrDA, serial mice 等等），但这些超出了本文的范围。</p><h3 id="22-会话管理session-management">2.2 会话管理（Session management）</h3><p>用户可能希望同时运行多个程序，在不同时刻 和不同的程序交互。如果一个程序进入无限循环，用户可能会杀掉或挂起这个程序。 后台（background）启动的程序如果执行到需要向终端写数据的地方，需要被挂起。与此类似，用户输入只应当被重定向到前台程序（foreground program）。操作系统在 TTY 驱动（drivers/char/tty_io.c）中实现了这些特性。</p><p>我们说一个操作系统进程“活着”（alive）时（有执行上下文），意味着这个进程能够执行 动作（perform actions）。TTY 驱动并没有活着；用面向对象的术语来说，TTY 驱动是一 个被动对象（passive object）。它有一些数据字段和方法，但只有当 它在某个进程或某个内核中断处理函数的上下文中被调用时，它才能够执行。同样的，line discipline 也是一个被动实体（passive entity）。</p><p>UART 驱动、line discipline 实例和 TTY 驱动三者组成一个 TTY 设备， 有时简称为 TTY。用户进程能够通过操作 /dev 目录下的相应设备文件来改变 TTY 设备的行为。进程需要对设备文件有写权限，因此当一个用户登陆到某个特定的 TTY 时 ，该用户必须成为相应设备文件的 owner。传统上这是通过 login(1) 程序实现的 ，该程序需要以 root 特权执行。</p><p>前面图中的物理线路当然也可以是一个长距离电话线路：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/case2.png" alt=""></p><p>在这张图中，除了系统此时也需要处理调制解调器（modem）的 hangup 情况之外，其他方 面跟前一张没有太大区别。</p><p>接下来我们来看一个典型的桌面系统。下图展示的是 Linux console 是如何工作的：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/case3.png" alt=""></p><p>TTY 驱动和 line discipline 的行为和前面例子中的一样，但其中不再涉及 UART 或物理 终端。与前面不同的地方在于，现在多了一个软件仿真的视频终端（一个复杂的状态机，包 括一个字符帧缓冲区和一些图形字符属性），渲染到一个 VGA 显示器。</p><p>控制台（console）子系统某种程度上比较刻板。如果我们将终端仿真放到用户空间（ userland），事情就会变得更加灵活（和抽象）。下面是 xterm(1) 及其衍生版本如何工作的：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/case4.png" alt=""></p><p>为了方便将终端模拟移到用户空间且同时保持 TTY 子系统（会话管理和 line discipline）的完整性，人们引入了伪终端（pseudo terminal）或称 pty。 你也许已经猜到了，当在伪终端内运行伪终端时（running pseudo terminals inside pseudo terminals），事情会变得更加复杂，例如 screen(1) 或 ssh(1)。</p><p>现在让我们退后一步，来看一看这些东西是如何适配到进程模型的。</p><h2 id="3-进程">3. 进程</h2><p>一个 Linux 进程可以处于以下几种状态之一：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/linuxprocess.png" alt=""></p><ul><li><p>R: 运行中或可运行（Running or runnable (on run queue)）</p></li><li><p>D: 不可中断睡眠（Uninterruptible sleep (waiting for some event)）</p></li><li><p>S: 可中断睡眠（Interruptible sleep (waiting for some event or signal)）</p></li><li><p>T: 停止（Stopped, either by a job control signal or because it is being traced by a debugger.）</p></li><li><p>Z: 僵尸进程（Zombie process, terminated but not yet reaped by its parent.）</p></li></ul><p>运行 ps l 可以看到各进程的状态。例如，如果是 sleeping 状态，WCHAN 列（”wait channel”，等待队列的名字）会显示这个进程正在等待的内核事件（kernel event）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ps l</span><br><span class="line">F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND</span><br><span class="line">0   500  5942  5928  15   0  12916  1460 wait   Ss   pts&#x2F;14     0:00 -&#x2F;bin&#x2F;bash</span><br><span class="line">0   500 12235  5942  15   0  21004  3572 wait   S+   pts&#x2F;14     0:01 vim index.php</span><br><span class="line">0   500 12580 12235  15   0   8080  1440 wait   S+   pts&#x2F;14     0:00 &#x2F;bin&#x2F;bash -c (ps l) &gt;&#x2F;tmp&#x2F;v727757&#x2F;1 2&gt;&amp;1</span><br><span class="line">0   500 12581 12580  15   0   4412   824 -      R+   pts&#x2F;14     0:00 ps l</span><br></pre></td></tr></table></figure><p>“wait” 等待队列（wait queue）和 wait(2) 系统调用相关，因此当这些进程的 任何一个子进程有任何状态变化时，这些进程就会被移动到 running 状态。</p><p>sleeping 状态有两种：可中断 sleep 和不可中断 sleep。可中断 sleep 最常见，它表示 虽然该进程当前在 wait 队列中，但只要它收到信号，就可以被移动到 running 状态。如 果查看内核源码，你会发现任何正在等待事件的内核代码都必须在 schedule() 返回 之后检查是否有信号 pending，如果有就 abort。</p><p>在上面 ps 命令的输出结果中，STAT 列显式了每个进程的当前状态。除此之外，这一 列还可能包含额外的属性或标记：</p><ul><li><p>s：表示这个进程是 session leader</p></li><li><p>+：表示这个进程是一个前台进程组的一部分（part of a foreground process group）</p></li></ul><p>这些属性用于作业控制（job control）。</p><h2 id="4-作业jobs和会话">4. 作业（Jobs）和会话</h2><p>当你按下 ^Z 键，或使用 &amp; 在后台启动一个程序时，就是在进行作业控制。</p><p>作业和进程组的概念是一样的（A job is the same as a process group）。shell 内 置的命令，例如 jobs、fg、bg 等等可以用于管理一个会话内已有的作业。每个 session 都是由一个 session leader 管理的，这个 session leader 就是 shell —— 通过一个复杂的信号协议和系统调用来和内核紧密协作。</p><p>下面的例子展示了进程、作业和会话之间的关系：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/exampleterm.png" alt=""></p><p>上图中的 shell 交互对应下面的这些进程：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/examplediagram.png" alt=""></p><p>以及下面这些内核结构：</p><ul><li>TTY Driver (/dev/pts/0)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Size: 45x13                                           # 尺寸：45x13</span><br><span class="line">Controlling process group: (101)                      # 控制进程组：101</span><br><span class="line">Foreground process group: (103)                       # 前台进程组：103</span><br><span class="line">UART configuration (ignored, since this is an xterm): # UART 配置（忽略，因为这是虚拟终端 xterm）</span><br><span class="line">  Baud rate, parity, word length and much more.</span><br><span class="line">Line discipline configuration:                        # Line discipline 配置：</span><br><span class="line">  cooked&#x2F;raw mode, linefeed correction,               #   cooked&#x2F;raw 模式</span><br><span class="line">  meaning of interrupt characters etc.</span><br><span class="line">Line discipline state:                                # Line discipline 状态：</span><br><span class="line">  edit buffer (currently empty),                      #   编辑缓冲区（当前为空）</span><br><span class="line">  cursor position within buffer etc.</span><br></pre></td></tr></table></figure><ul><li>pipe0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Readable end (connected to PID 104 as file descriptor 0) # 可读端（作为文件描述符 0 连接到 PID 104）</span><br><span class="line">Writable end (connected to PID 103 as file descriptor 1) # 可写端（作为文件描述符 1 连接到 PID 103）</span><br><span class="line">Buffer</span><br></pre></td></tr></table></figure><pre><code>                                               # 缓冲区</code></pre><p>这里的基本思想是：every pipeline is a job（每条流水线都是一个作业），因为每个 pipeline 内的进程都需要被同时操控（stopped, resumed, killed）。这也是为什么能够 用 kill(2) 向一整个进程组发送信号的原因。默认情况下，fork(2) 会将新创建出来 的子进程放到与其父进程相同的进程组，因此，例如一个 ^C 键就会同时影响到父子进程 。但 shell 有些不同，作为其 session leader 职责的一部分，它每次创建一个 pipeline 的时候都会创建一个新的进程组。</p><p>TTY 驱动跟踪记录前台进程组 ID（foreground process group id），但只会以被动的方 式跟踪。当有必要时，session leader 必须显式更新这项信息。类似地，TTY 驱动 也会以被动的方式跟踪所连接的终端的尺寸大小（size），但这个信息必须由终端模拟器甚 至用户来显式更新。</p><p>前面的图中可以看到，几个不同进程都将 /dev/pts/0 attach 到了它们的标准输入。但 只有前台任务（ls | sort pipeline）会从 TTY 接收输入。类似地，只有前台作业是允 许写到 TTY 设备的（在默认配置下）。如果图中的 cat 进程试图写到该 TTY，内核会通过一个信号挂起它。</p><h2 id="5-简单粗暴的信号机制">5. 简单粗暴的信号机制</h2><p>现在让我们来更加近距离地看看内核中的 TTY 驱动、line discipline 和 UART 驱动 是如何与用户空间进程通信的。</p><p>UNIX 文件，包括 TTY 设备文件，都可以被读取或写入，以及通过神奇的 ioctl(2)（ UNIX 中的瑞士军刀）系统调用进一步操作，内核中已经为 TTY 设备实现了很多相关的 ioctl 操作。但是，ioctl 请求必须从进程（向内核）发起，因此当内核（主动）希望异步地与应用进行通信时，ioctl 就不适用了。</p><p>在《银河系漫游指南》中， Douglas Adams 描述了一个极其迟钝的星球，上面居住了一群 意志消沉的人以及一种带有锋利牙齿的动物，后者与前者交谈的方式就是用力撕咬他们的大 腿。这与 UNIX 非常相似，因为内核与进程通信的方式就是向进程发送能使之瘫痪或致命的信号。进程可能会捕获其中某些信号，然后尝试解决遇到的问题，但大部分信号都是没 有被捕获的。</p><p>因此，信号是一种粗暴的内核与应用进程异步通信的机制。UNIX 中信号的设计并不整洁或通用；每个信号都是唯一的，因此必须逐个研究。</p><p><code>kill -l</code> 命令可以查看当前系统已经实现了哪些信号。这个命令的输出可能与下面的类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL</span><br><span class="line"> 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE</span><br><span class="line"> 9) SIGKILL      10) SIGUSR1     11) SIGSEGV     12) SIGUSR2</span><br><span class="line">13) SIGPIPE      14) SIGALRM     15) SIGTERM     16) SIGSTKFLT</span><br><span class="line">17) SIGCHLD      18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN      22) SIGTTOU     23) SIGURG      24) SIGXCPU</span><br><span class="line">25) SIGXFSZ      26) SIGVTALRM   27) SIGPROF     28) SIGWINCH</span><br><span class="line">29) SIGIO        30) SIGPWR      31) SIGSYS      34) SIGRTMIN</span><br><span class="line">35) SIGRTMIN+1   36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4</span><br><span class="line">39) SIGRTMIN+5   40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9   44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12</span><br><span class="line">47) SIGRTMIN+13  48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14</span><br><span class="line">51) SIGRTMAX-13  52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10</span><br><span class="line">55) SIGRTMAX-9   56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6</span><br><span class="line">59) SIGRTMAX-5   60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1   64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>如上所示，信号是从 1 开始编码的。但如果是掩码（bitmask）形式表示（例如 ps s 的 输出中），最不重要比特（least significant bit）表示的是 1。</p><p>本文将关下面几信号：SIHUP、SIGIT、SIGQUI、SIGPIPE、 SIGCHLD、SIGSTOP 、 SIGCONT、 SIGTSTP、 SIGTTIN、SIGTTOU 和 SIGWINCH。</p><ul><li><p>SIGHUP</p><ul><li><p>默认动作：Terminate</p></li><li><p>可能动作：Terminate, Ignore, Function call</p></li></ul></li></ul><p>当检测到 hangup 时，UART 驱动会向整个 session 发送 SIGHUP 信号。 正常情况下，这会 kill 掉所有进程。某些程序，例如 nohup(1) 和 screen(1)，会从他们的 session（和 TTY）中 detach 出来， 因此这些程序的子进程无法关注到 hangup 事件。</p><ul><li><p>SIGINT</p><ul><li><p>默认动作：Terminate</p></li><li><p>可能动作：Terminate, Ignore, Function call</p></li></ul></li></ul><p>当输入流中出现interactive attention character（交互式注意字符，通常是 ^C，ASCII 码是 3）时，TTY 驱动会向当前的前台作业发送 SIGINT 信号，除非这个特性被关闭了。任何对 TTY 设备有权限的人都可以修改 the interactive attention character 或打开/关闭这个特性；另外，会话管理器（session manager） 跟踪记录每个作业的 TTY 配置，当发生作业切换时会更新 TTY。</p><ul><li><p>SIGQUIT</p><ul><li><p>默认动作：Core dump</p></li><li><p>可能动作：Core dump, Ignore, Function call</p></li></ul></li></ul><p>SIGQUIT 和 SIGINT 类似，但 quit 字符通常是 ^\，而且默认动作不同。</p><ul><li><p>SIGPIPE</p><ul><li><p>默认动作：Terminate</p></li><li><p>可能动作：Terminate, Ignore, Function call</p></li></ul></li></ul><p>对于每个尝试向没有 reader 的 piepe 写数据的进程，内核会向其发送 SIGPIPE 信号。这很有用，因为如果没有这个信号，某些作业就无法终止。</p><ul><li><p>SIGCHLD</p><ul><li><p>默认动作：Ignore</p></li><li><p>可能动作：Ignore, Function call</p></li></ul></li></ul><p>当一个进程死掉或状态发生改变时（stop/continue），内核会向其父进程发送此信号 。该信号还附带了其他信息，即该进程的进程 ID、用户 ID、退出状态码（或终止信号） 以及其他一些执行时统计信息（execution time statistics）。session leader 使用 这个信号跟踪它的作业。</p><ul><li><p>SIGSTOP</p><ul><li><p>默认动作：Suspend</p></li><li><p>可能动作：Suspend</p></li></ul></li></ul><p>该信号会无条件地挂起信号接受者，例如，该信号的动作是不能被重新配置的（ reconfigure）。但要注意，该信号并不是在作业控制（job control）期间被内核发送 的。^Z 通常情况下触发的是 SIGTSTP 信号，这个信号是可以被应用捕获的。例如 ，应用可以将光标移动到屏幕底部，或者将终端置于某个已知状态，随后通过 SIGSTOP 将自己置于 sleep 状态。</p><ul><li><p>SIGCONT</p><ul><li><p>默认动作：Wake up</p></li><li><p>可能动作：Wake up, Wake up + Function call</p></li></ul></li></ul><p>该信号会唤醒（un-suspend）一个已经 stop 的进程。用户执行 fg 命令时， shell 会显式地发送这个信号。由于应用无法捕获该信号，因此如果出现未预期的 SIGCONT 信号，可能就表示某些进程在一段时间之前被挂起了，现在挂起被解除了。</p><ul><li><p>SIGTSTP</p><ul><li><p>默认动作：Suspend</p></li><li><p>可能动作：Suspend, Ignore, Function call</p></li></ul></li></ul><p>该信号与 SIGINT 和 SIGQUIT 类似，但对应的魔法字符通常是 ^Z，默认动作是挂起进程。</p><ul><li><p>SIGTTIN</p><ul><li><p>默认动作：Suspend</p></li><li><p>可能动作：Suspend, Ignore, Function call</p></li></ul></li></ul><p>如果一个后台作业中的进程尝试读取一个 TTY 设备，TTY 会发送该信号给整个作业。 正常情况下这会挂起作业。</p><ul><li><p>SIGTTOU</p><ul><li><p>默认动作：Suspend</p></li><li><p>可能动作：Suspend, Ignore, Function call</p></li></ul></li></ul><p>如果一个后台作业中的进程尝试写一个 TTY 设备，TTY 会发送该信号给整个作业。 正常情况下这会挂起作业。可以在 per-TTY 级别打开或关闭这个特性。</p><ul><li><p>SIGWINCH</p><ul><li><p>默认动作：Ignore</p></li><li><p>可能动作：Ignore, Function call</p></li></ul></li></ul><p>前面提到，TTY 设备会跟踪记录终端的尺寸（size），但这个信息需要手动更新。 当终端尺寸发送变化时，TTY 设备会向前台作业发送该信号。行为良好的交互式应用， 例如编辑器，会对此作出响应：从 TTY 设备获取新的终端尺寸，然后根据该信息重绘自己。</p><h2 id="6-一个例子">6. 一个例子</h2><p>设想你在用自己的（基于终端的）编辑器编辑某个文件。光标当前位于屏幕中央，编辑器正 忙于执行某些 CPU 密集型任务，例如在一个大文件中执行搜索或替换操作。现在假设你按 下了^Z 键。因为 line discipline 已经配置了捕获此字符（^Z 是单个字节，ASCII 码 为 26），因此你无需等待编辑器完成它正在执行的任务然后开始从 TTY 设备读取数据。</p><p>此时的情况是，line discipline 子系统会立即向前台进程组发送 SIGTSTP 信号。 这个进程组中包括编辑器进程，以及它创建出来的任何子进程。</p><p>编辑器为 SIGTSTP 进程注册了信号处理函数，因此内核此时开始执行该信号处理函数 的代码。该代码通过向 TTY 设备写入相应的控制序列（control sequences），将 光标移动到屏幕最后一行。由于编辑器仍然在前台，这个控制序列能够正常发送出去（给 TTY）。但之后，编辑器会给自己所在的进程组发送一个 SIGSTOP 信号。</p><p>编辑器此时就被挂起（stop）了。这个事件会通过一个 SIGCHLD 信号发送给 session leader， 其中包括了被挂起进程的进程 ID。当前台作业中的所有进程都被挂起后，session leader 从 TTY 设备中读取当前配置，保存以备后面恢复时用。session leader 使用 ioctl 系 统调用，继续将自己注册（install itself）为该 TTY 的当前前台进程组。然后，它打印 出类似 “[1]+ Stopped” 之类的信息，告知用户有一个作业刚被挂起了。</p><p>此时，ps(1) 会告诉你编辑器进程当前处于 stopped state (“T”)。如果我们试图唤醒它 ，不管是通过 shell 内置的 bg 命令，还是使用 kill(1) 发送 SIGCONT 信号给进程 ，都会触发编辑器执行它的 SIGCONT 信号处理函数。该信号处理函数可能会尝试通过写 TTY 设备来重绘编辑器 GUI。但由于此时编辑器是后台作业，TTY 设备是不允许其写入的。 这种情况下 TTY 会给编辑器发送 SIGTTOU 信号，再次将其 stop。这个事件会通过 SIGCHLD 信号通知到 session leader，然后 shell 会再次将 “[1]+ Stopped” 之类的 消息写到终端。</p><p>但当我们输入 fg 命令时，shell 首先会恢复此前保存的 line discipline 配置。 然后，它通知 TTY 驱动从现在开始编辑器作业应当被作为前台作业对待了。最后，它发送一个 SIGCONT 信号给进程组。编辑器进程尝试重绘 GUI，而这一次它不会被 SIGTTOU 中断了，因为它现在是前台作业的一部分了。</p><blockquote><p>（译者）总结：</p><ol><li><p>使用编辑器编辑文件。</p></li><li><p>按 ^Z 键 -&gt; 唤醒 line discipline。</p></li><li><p>line discipline -&gt; 前台进程组：SIGTSTP。</p></li><li><p>编辑器 SIGTSTP 信号处理函数 -&gt; TTY：写入控制序列，将光标移动到最后屏幕一行</p></li><li><p>编辑器 SIGTSTP 信号处理函数 -&gt; 自己所在的进程组：SIGSTOP。</p></li><li><p>编辑器被挂起（stop）。这个事件会通过一个 SIGCHLD 信号发送给 session leader，其中包括了被挂起进程的进程 ID。</p></li><li><p>前台进程组中的所有进程都被挂起，session leader 从 TTY 中读取当前配置并保存</p></li></ol><p>8.session leader 使用 ioctl 系统调用，继续将自己注册（install itself）为该 TTY 的当前前台进程组。然后，它打印出类似 “[1]+ Stopped” 之类的信息，告知 用户有一个作业刚被挂起了。</p><ol start="9"><li><p>bg 或 kill -SIGCONT 给编辑器发信号：编辑器会尝试写 TTY 来重绘窗口，但此 时编辑器进程是后台进程，不允许写 TTY，因此 TTY 会给其发送 SIGTTOU 信号， 再次将其 stop；这个事件会通过 SIGCHLD 信号告知 session leader，后者再次将 [1]+ Stopped 信息写到终端。</p></li><li><p>但当我们输入 fg 命令时，shell 会恢复此前保存的 line discipline 配置。然 后通知 TTY 驱动编辑器进程现在是前台进程了。最后，它发送一个 SIGCONT 信号 给进程组恢复编辑器的执行。</p></li></ol></blockquote><h2 id="7-流控和阻塞式-io">7. 流控和阻塞式 I/O</h2><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/dsc00043.jpg" alt=""></p><p>在 xterm 中执行 yes 命令，你会看到大量的 “yes” 一行一行地快速闪过。正常情况 下条，yes 进程产生 “yes” 输出的速度要远快于 xterm 应用解析这些行、更新帧缓冲 区、与 X server 通信来滚动窗口等等的速度。那么，这些进程之间是如何协作的呢？</p><p>答案就是 blocking I/O（阻塞式输入/输出）。伪终端只能在其内核缓冲区中保存一定量 的数据，当缓冲区已经填满而 yes 程序仍然调用 write(2) 写入时，write(2) 会阻 塞，yes 进程会被移入可中断 sleep 状态，直到 xterm 进程读走了一部分缓存的数据。</p><p>当 TTY 连接到的是串口（serial port）时，过程与此类似。yes 能够以很快的速度 发送数据，例如 9600 波特，但如果串口速度比这个低，内核缓冲区很快就会塞满，随后的 任何 write(2) 调用都会阻塞写进程（或者返回 EAGAIN 错误码 —— 如果进程请求的是非 阻塞 I/O）。</p><p>如果我告诉你，我们能够显式地将 TTY 置于阻塞状态，即使内核缓冲区中仍然有可用 空间呢？这样设置之后，每个进程调用 write(2) 进行写入时，TTY 都会自动阻塞。但 什么情况下回用到这个特性呢？</p><p>设想我们正在以 9600 波特和某个陈旧的 VT-100 硬件通信。我们刚发送了一个复杂的控制 序列要求终端滚动显示页面。此时，终端忙于执行滚动操作，无法以全速 9600 波特接收新 的数据。这种情况下，在物理上，终端 UART 仍然运行在 9600 波特，但缓冲区中没有足够 的空间来给终端存储接收到的数据。这就是一个将 TTY 置于阻塞状态的好时机。那么要实 现这个效果，我们该怎么做呢？</p><p>前面已经看到，可以配置 TTY 设备对某些特定的数据给予特殊对待。例如，在默认配 置中，TTY 收到的 ^C 字符并不会通过 read(2) 直接交给应用，而是会触发发送一个 SIGINT 信号给前台作业。类似地，可以配置 TTY 对 stop flow byte（停止流字节） 和start flow byte（开始流字节）做出响应。通常情况下，这分别是^S (ASCII code 19) 和 ^Q (ASCII code 17)。老式硬件终端能自动发送这些字节，然后期待操作系统能够按照约定对它的数据流进行管控。这个过程称为流控（flow control），这也是 为什么有时你误按了 ^S 时，你的 xterm 会锁定的原因。</p><p>这里要区分两种情况：</p><ul><li><p>向一个由于流控或内核缓冲空间不足而 stop 的 TTY 写入：写入进程会被阻塞（block）</p></li><li><p>从后台作业向一个 TTY 写入：会导致 TTY 发送一个 SIGTTOU 给整个进程组将其挂起（suspend）<br>我不清楚 UNIX 的设计者为何发明 SIGTTOU 和 SIGTTIN 而不是依靠 blocking I/O， 我尽己所能猜到的原因是：负责着作业控制（job control）的 TTY 驱动，设计用于监控和 操作全部作业，而不是作业内的单个进程。</p></li></ul><h2 id="8-配置-tty-设备">8. 配置 TTY 设备</h2><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/cockpit.jpg" alt=""></p><p>要确定当前 shell 的 TTY，可以通过我们前面介绍的 ps l 命令，或者直接运行 tty(1) 命令。</p><p>一个进程可能会通过 ioctl(2) 读取或修改一个已经打开的 TTY 设备。相应的 API 在 tty_ioctl(4) 中作了描述。由于这是 Linux 应用和内核之间的二进制接口的一部分， 因此它在不同的 Linux 版本之间是保持稳定的。但是，这个接口是不可移植的，若想编 写可移植的程序，应用应当使用 termios(3) man page 中提供的 POSIX wrapper。</p><p>这里我不会深入介绍 termios(3) 接口，但如果你正在编写 C 程序，涉及到捕获 ^C、 关闭行编辑或字符回显、修改串口的波特率、关闭流控等等工作，那你就需要去阅读前面提到的 man page。</p><p>另外还有一个命令行工具 stty(1)，用于操纵 TTY 设备。它使用了 termios(3) API。</p><p>我们来试试！</p><h3 id="tty-配置选项">TTY 配置选项</h3><p><code>stty -a</code> 打印所有配置项。默认打印的是当前 shell 所 attach 的 TTY 设备配置项，但 可以通过 -F 指定其他设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ stty -a</span><br><span class="line">speed 38400 baud; rows 73; columns 238; line &#x3D; 0;</span><br><span class="line">intr &#x3D; ^C; quit &#x3D; ^\; erase &#x3D; ^?; kill &#x3D; ^U; eof &#x3D; ^D; eol &#x3D; &lt;undef&gt;; eol2 &#x3D; &lt;undef&gt;; swtch &#x3D; &lt;undef&gt;; start &#x3D; ^Q; stop &#x3D; ^S; susp &#x3D; ^Z; rprnt &#x3D; ^R; werase &#x3D; ^W; lnext &#x3D; ^V; flush &#x3D; ^O; min &#x3D; 1; time &#x3D; 0;</span><br><span class="line">-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts</span><br><span class="line">-ignbrk brkint ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany imaxbel -iutf8</span><br><span class="line">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><br><span class="line">isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke</span><br></pre></td></tr></table></figure><p>以上选项中，某些是 UART 参数；某些影响 line discipline，某些用于作业控制。我们先 来看第一行：</p><ul><li><p>speed</p><ul><li><p>UART 参数</p></li><li><p>波特率。伪终端忽略此选项。</p></li></ul></li><li><p>rows 和 columns</p><ul><li><p>TTY 驱动参数</p></li><li><p>attach 到这个 TTY 设备的终端大小（size），单位是字符数。本质上这只是内核空 间中的一对变量，可以随意修改和读取。修改这两个参数会触发 TTY 驱动发送 SIGWINCH 信号给前台作业。</p></li></ul></li><li><p>line</p><ul><li><p>Line discipline 参数</p></li><li><p>表示 attach 到这个 TTY 的 line discipline。0 代表 N_TTY。所有的合法值列在 /proc/tty/ldiscs 下面。未列出的值似乎是 N_TTY 的 alias，但不依赖前者。</p></li></ul></li></ul><h3 id="修改窗口尺寸">修改窗口尺寸</h3><p>尝试下面的例子：开启一个 xterm。记录下它的 TTY 设备（执行 tty 命令查看）以及尺 寸（执行 stty -a 命令查看）。在 xterm 中启动 vim（或其他全屏终端应用）。编辑器会询问 TTY 设 备当前的终端尺寸，以填充整个窗口。</p><p>现在，在另一个 shell 窗口中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stty -F X rows Y</span><br></pre></td></tr></table></figure><p>其中 X 是 TTY 设备，Y 是终端高度的一半。这条命令会更新内核内存中的 TTY 配置数据 ，并触发向编辑器发送一个 SIGWINCH 信号；vim 收到信号会立即重绘自身，结果是编辑 器的高度减半。</p><h3 id="修改-sigint-对应的控制字符">修改 SIGINT 对应的控制字符</h3><p>stty -a 命令的输出中，第二行列出了所有的特殊字符。</p><p>打开一个新 xterm 然后尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stty intr o</span><br></pre></td></tr></table></figure><p>现在输入字符 o —— 而不是原来默认的 ^C —— 会触发发送 SIGINT 信号给前台作业。</p><p>你可以运行着某个命令，例如 cat，然后验证此时 ^C 是不能终止其执行的。然后，再试试输入 hello 给 cat。</p><h3 id="退格键无法使用">退格键无法使用</h3><p>某些场合下，你可能会在某个 UNIX 系统上遇到退格键无法使用的情况。</p><p>发生这种情况是因为终端模拟器发送的退格码（不管是 ASCII 8 还是 127）与 TTY 设备中的擦除设置（erase setting）不匹配。要解决这个问题，通常需要输入 stty 擦除 ^H（ASCII 8）或 stty erase ^?（ASCII 127）。但请记住，某些终端应用使 用 readline，它们会将 line discipline 置于 raw 模式，这些应用不会受此影响。</p><h3 id="tty-开关项">TTY 开关项</h3><p>最后，stty -a 列出了一系列的开关。这些开关并没有先后顺序。某些与 UART 相关，某 些影响 line discipline 行为，某些用于流控，某些用于作业控制。有减号（-）表示该 开关当前是关闭的；否则就是打开的。所有开关都在 stty(1) man page 中有解释，因此 这里只是简要介绍几个：</p><p>icanon 打开/关闭 canonical (line-based) 模式。尝试在一个新 xterm 内运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stty -icanon; cat</span><br></pre></td></tr></table></figure><p>执行这条命令后，所有的行编辑字符，例如退格和 ^U 将无法使用。你会注意到 cat 此 时开始按字符接收（以及打印）内容，而不是像之前一样按行。</p><p>echo 打开字符回显（character echoing），这个选项默认是打开的。重新启用 canonical mode（stty icanon），然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stty -echo; cat</span><br></pre></td></tr></table></figure><p>输入命令时，终端模拟器会将命令信息发送给内核。通常情况下，内核会将相同的信息回显给 终端模拟器，这样我们就可以看到自己输入的内容了。没有字符回显的话，我们无法看到自己输 入的内容，但由于我们在 cooked 模式，因此行编辑设施还是仍然工作的。当按下回车键 时，line discipline 会将编辑缓冲区发送给 cat，后者就会显示输入的内容。</p><p>tostop 控制是否允许后台作业写终端。首先尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stty tostop; (sleep 5; echo hello, world) &amp;</span><br></pre></td></tr></table></figure><p>&amp; 使得前面的进程以后台作业的方式执行。5 秒之后，该作业会尝试写 TTY。TTY 驱动会 使用 SIGTTOU 来挂起该进程，shell 可能会报告这个结果，可能是立即，也可能是某个时 候弹出一个提醒框。现在 kill 掉后台作业，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stty -tostop; (sleep 5; echo hello, world) &amp;</span><br></pre></td></tr></table></figure><p>以上命令会重新打开输入回显功能；5 秒之后，后台作业发送 hello, world 给终端，此 时不管你正在输入什么，这句话都会打印出来。</p><p>最后，stty sane 会将 TTY 设备恢复到某个合理的配置。</p><h2 id="9-结束语">9. 结束语</h2><p>本文提供了 TTY 驱动和 line discipline 相关的知识，以及它们和终端、行编辑及作业控 制的联系，希望这些内容足够读者对它们有一个了解。更多信息请参考前面提到的几个 man page，以及 glibc 手册（info libc，”Job Control”）。</p><p>最后，感谢阅读！</p><blockquote><p>本文转载自：「ARTHURCHIAO’S BLOG」，原文：<a href="https://url.cn/5Q53HEg%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5Q53HEg，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;译者序&quot;&gt;译者序&lt;/h2&gt;
&lt;p&gt;本文翻译自 2008 年的一篇帖子 The TTY demystified.&lt;/p&gt;
&lt;p&gt;由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。&lt;/p&gt;
&lt;p&gt;以下是译文。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;历史&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用场景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作业（Jobs）和会话&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单粗暴的信号机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个例子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流控和阻塞式 I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 TTY 设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结束语&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TTY 子系统是 Linux 乃至 Unix 家族中最核心的设计之一。&lt;/p&gt;
&lt;p&gt;但不幸的是，TTY 的重要性经常被低估，而且网上也很难找到不错的介绍性文章。而我认为，对 Linux 中的 TTY 有一些基本了解对于开发者和高级用户来说是非常有帮助的。&lt;/p&gt;
&lt;p&gt;但要注意：接下来你将看到的东西并不是非常优雅。事实上，TTY 子系统 —— 虽然从用户的角度来非常好用 —— 是很多特殊场景杂糅在一起的结果。而要理解为什么会变成这样， 我们需要从历史说起。&lt;/p&gt;
&lt;h2 id=&quot;1-历史&quot;&gt;1. 历史&lt;/h2&gt;
&lt;p&gt;1869，人类发明了股票自动报价机（stock ticker）。它是一个用于跨长距离实时传 递股票价格的电子-机械设备，由一个打字机（typewriter）、一对很长的电缆（a long pair of wires）和一个报价用的磁带打印机（tape printer）组成。后来，这个概念逐渐 进化成速度更快的、基于 ASCII 码的电传打印机（teletype）。电传打印机曾通过一个称 为 Telex 的网络实现全球互联，用于传递商业电报，但它们并没有连接到任何计算机（ computers）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://arthurchiao.github.io/assets/img/tty-demystified/oldschool.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;20 世纪 40 年代的真实电传打印机（teletypes）&lt;/p&gt;
&lt;p&gt;在同一时期，计算机 —— 虽然仍是很大很原始的机器，但能处理多任务（multitask）—— 开始变得越来越强大，足以实现与用户的实时交互。当命令行（command line）最终取代 了老式的批处理模型（batch processing model）后，人们直接将电传打印机用作了计算 机的输入和输出设备（input and output devices），因为这些设备在市场上很容易买到。&lt;/p&gt;
&lt;p&gt;但此时面临的一个问题是：市场上有大量的电传打印机模型，所有模型之间都有一些细 微差别，因此就需要某种层面的软件中间层来屏蔽这些差异。Unix 世界中的方式是** 让操作系统内核来处理所有的低层（low-level）细节，例如 word 长度、波特率（baud rate）、流控（flow control）、奇偶校验（parity）、基本的行编辑（line editing）功 能所用的控制码等等。而 20 世纪 70 年代随着例如 VT-100 这样的固态视频终端（solid state video terminals）的出现而变成为现实的光标炫酷移动、彩色输入和其他高级特 性，则交给应用（application）来控制**。&lt;/p&gt;
&lt;p&gt;如今在我们的世界中，物理电传打印机和视频终端事实上已经绝迹了。除非你去参观某个博 物馆或者硬件爱好者的私藏，否则你能看到的所有 TTY 很可能都是仿真（模拟）的视频 终端（emulated video terminals）——用软件去模拟真实硬件。但我们将会看到，这些传 统的钢铁浇筑的怪兽仍然潜伏在表面的平静之下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>一个优秀架构师必知的 30 条设计原则</title>
    <link href="https://www.hi-linux.com/posts/53772.html"/>
    <id>https://www.hi-linux.com/posts/53772.html</id>
    <published>2020-05-24T01:08:00.000Z</published>
    <updated>2020-05-24T08:37:53.030Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，架构师的角色，更偏向于策划、而非指挥，塑造、而非支配，其存在的意义，在于引导大家讨论、而非自己主宰一切。</p><p>但是，具体应该如何执行呢？本文作者整理了 30 个公认的架构原则，来帮助大家解决此问题。也许有的原则，你从未听说，但你看完就能快速学会。</p><p>相信你学会了，工作起来也会事半功倍，或许还可帮你避免很多无用的加班！</p><blockquote><p>本文作者叫 Srinath，是一位计算机科学家、软件架构师、作家。他是 Apache 的核心成员，拥有 15 年分布式系统编程经验，设计了 Apache Axis2 以及 WSO2 流处理器。</p></blockquote><p>在 WSO2，我参与架构评审的时间已长达八年之久。WSO2 的产品非常丰富，比如 WSO2 ESB 、WSO2 API Manager  以及 WSO2 SP 都人尽皆知。在过去八年中，我们对许多产品和功能进行了讨论、设计、改进和重新设计。</p><p>我们在设计软件的过程中，把握的一个关键点是：软件架构并非由架构师负责设计。我们的架构不是由架构师制定，然后交给其他人来实施。</p><p>相反，架构的设计任务由真正编写代码的团队负责。架构师负责对工程师设计的架构进行修复、完善和改进。我们的架构团队是指导员和把关人，而非独裁者。</p><p>在短期内，由一位架构师来制定架构的确既快捷又实惠。但是，从长远来看，我们会组建一个团队，让他们自己不断思考、改善架构，并从他们的错误中来提升自己。</p><p>当我们专注于团队时，他们自然会随着时间的推移而变得更好。架构团队的首要任务是：尽可能保证架构容易执行。此外，架构评审也存在缺陷。</p><p>就像 Paul （@pzfreo）描述的架构评审那样：架构师参与进来，听一会，发表一点评论然后就走了。作为一名架构师，你对架构发表自己的看法和意见无可厚非。但是，如果你不够投入和细心，你的意见可能会让团队感到困惑，团队就无法确定正确的做法到底是什么。</p><p>接下来我会将 30 个架构原则一一列出，其中一些原则是众所周知的，而有些则源于我的个人经验和心血。</p><p><img src="https://i.loli.net/2019/08/15/CVRuDeBOyvcJM9G.png" alt=""></p><a id="more"></a><h2 id="基本原则">基本原则</h2><ul><li><p>原则 1： KISS (Keep it simple,sutpid) 和保持每件事情都尽可能的简单，用最简单的解决方案来解决问题。</p></li><li><p>原则 2：YAGNI（你不需要它）原则 ，只在需要时构建。</p></li><li><p>原则 3：先学会爬，然后再学会走，最后学会跑。换句话说，先保证能够正常运行，然后优化它使其更好，最后逐渐让它变得完美。使用迭代开发，采用敏捷开发模式。为每个功能制定一个开发周期（最多 2 周），然后不断迭代。</p></li><li><p>原则 4：自动化测试是构建稳定、高质量产品的唯一方法。通过自动化测试提升创造力，所有一切都可以自动化！在设计时应当好好考虑自动化。</p></li><li><p>原则 5：注重投资回报率（ROI）并将最多的注意力放在最重要的地方。</p></li><li><p>原则 6：了解用户并相应地平衡资源。大多数产品都有数千个最终用户，大致需要 20 个开发人员和 100 个 DevOps 人员。不要花费数月的时间来构建一个不太可能使用 DevOps 的用户界面（他们更喜欢脚本）。这是原则 5 的特例。</p></li><li><p>原则 7：功能的设计和测试尽可能独立。如果在设计时考虑到这一点，长远来看，它将省去很多麻烦，否则只有一切构建完成时你才可以开始测试整个系统。此外，遵循这个原则，版本发布也会更加顺利。</p></li><li><p>原则 8：警惕搜索引擎中花里胡哨的架构方案。我们天生都喜欢令人夺目的设计。如果你按奈不住， 就可能把太多根本不需要的功能和解决方案引入到你的架构中。</p></li></ul><h2 id="功能选择">功能选择</h2><ul><li><p>原则 9：想要准确知道用户如何使用我们的产品是很难的。所以我们要推行 MVP（最小可行产品）。该理念的核心在于：先制定一些用例，完成用例所涉及的相关功能，立即发布产品，然后根据反馈和经验对产品进行优化。</p></li><li><p>原则 10：尽可能减少功能，如有疑问则将其删除。许多功能可能从未使用，你只需为其留一个扩展接口即可。</p></li><li><p>原则 11：听取客户的意见，看他们想要什么功能。</p></li><li><p>原则 12：当客户要求的功能影响到其他模块时，要勇于和客户辩论。从大局出发，尝试找到另一种方法来处理问题。就像 Fords 所说的那样“每当我问顾客需要什么的时候,他们总是会说需要跑得更快的马”。请记住，你才是专家。你应该主导一切，做出正确和专业的决定。虽然用户可能当时有些疑惑，但最终他们会感谢你的。</p></li></ul><h2 id="服务端设计和并发">服务端设计和并发</h2><ul><li><p>原则 13：要知道一个 Server 是如何运行的，从硬件到操作系统，直到编程语言。优化 IO 调用的数量是你通往最好架构的首选之路。</p></li><li><p>原则 14：遵循 Amdhal 的同步定律。线程之间共享的可变数据会降低程序速度。如果可以，请使用并发数据结构，并且仅在必要时使用同步。尽可能少地使用锁。如果你打算在线程锁期间阻塞，请确保自己足够了解具体细节，因为这里存在极大的隐患。</p></li><li><p>原则 15：如果你的设计是基于事件驱动的非阻塞架构，那就不要阻塞线程或者在线程中执行 IO 操作。一旦这样做，系统将慢如蜗牛。</p></li></ul><h2 id="分布式系统">分布式系统</h2><ul><li><p>原则 16：无状态系统具有良好的扩展性。我们要尽可能了解和使用无分享架构。</p></li><li><p>原则 17：除非你能够掌控客户端和服务器的所有代码，否则消息传递失败的情况在所难免。尽量减少你的系统依赖的因素（例如使用原则 18 ）。</p></li><li><p>原则 18：尽可能实施幂等操作。这样它就很容易恢复，你至少可以保证交付没问题。</p></li><li><p>原则 19：了解 CAP 定理。可扩展的事务（分布式事务）是很难的 。尽可能使用补偿，基于 RDBMS 的事务很难扩展。</p></li><li><p>原则 20：分布式系统共识不支持扩展，也无法进行组通信，不支持群集范围内的可靠消息传递。其最大节点限制大约是八个节点。</p></li><li><p>原则 21：在分布式系统中，你很难隐藏分布式系统中的延迟和故障。（参见分布式计算的谬误解释 ）。</p></li></ul><h2 id="用户体验">用户体验</h2><ul><li><p>原则 22：了解你的用户以及他们的目标：他是新手、专家还是临时用户？他对计算机科学了解多少？极客看重扩展功能，开发人员关注示例和脚本，普通人则更在乎界面。</p></li><li><p>原则 23：最好的产品应当不需要用户手册，用户应该一看就会用。</p></li><li><p>原则 24：当你无法在两个选项之间做出决定时，请不要通过配置选项的方式来呈现问题。这会给用户和架构师带来麻烦。对于系统如何运作的细节，他们没有你了解，他们怎么能做出决定呢？最好的方案是找到一个每次都有效的选择；其次是自动做出选择；第三个方案是添加配置参数并设置合理的默认值。</p></li><li><p>原则 25：始终具有合理的配置默认值。</p></li><li><p>原则 26：设计不良的配置会制造麻烦，始终配置几个示例值。</p></li><li><p>原则 27：询问用户配置值的时候，注意选择用户无需即可设置的值（例如，不要问用户需要的最大缓存条目数量，而是要问他想要用于缓存的内存数量）</p></li><li><p>原则 28：如果发现未知配置，则抛出错误。永远不要忽视它。在调试过程中，无提示的配置错误会浪费我们很多调式时间。</p></li></ul><h2 id="难点">难点</h2><p>原则 29：尝试新语言很容易，但要正确使用却很难。除非公司愿意组建一个十人团队并花一年的时间来学习，否则尽量不要这样做。如果你仍不死心，请阅读有关语言设计的五个问题后再做定夺。</p><p>原则 30：可组合的拖放 UI 很难实现，除非团队准备投入 10 人/年的资源，否则不要去做。</p><p>最后，谈一下我的感受。在理想情况下，一个平台应当由多个正交组件组成，每个组件负责一个方面（例如，安全性、消息传递、注册、调解、分析，等等）。使用这些功能构建的系统将是最佳的。</p><p>不幸的是，现实中我们很难达到这样的状态。因为在项目初始状态时，很多事情是不确定的，你无法做到这样的独立性，现在我认为在开始的时候适当的重复是必要的，当你尝试铲除他们的时候，你会发现引入了新的复杂性，分布本身就意味着复杂。有时候治愈的过程要比疾病本身更加的糟糕。</p><h2 id="总结">总结</h2><p>作为一个架构师，我们应该像园丁一样思考、塑造、策划和去除杂草而不是定义和构建。虽然在短期内，由一位架构师来制定架构的确既快捷又实惠。但是，从长远来看，团队的力量才是最强的。</p><p>如果你不够投入和细心，你只指出错误，但是不道明错误原因，那么你的意见可能会让团队感到困惑。避免这种情况的一种方法是拥有一套普遍接受的原则，这些原则是讨论架构时遵循的基本点，也是初学者学习架构的好资源。所以想成为一名优秀的架构师，还是需要长期的磨练以及时间的验证，当然随时保持学习的状态也是非常重要的。当你学会更多知识，你便会更清晰的解决各种复杂的架构问题。</p><blockquote><p>来源：HACKERNOON</p><p>原文：<a href="http://t.cn/AiHXMF44" target="_blank" rel="noopener">http://t.cn/AiHXMF44</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，架构师的角色，更偏向于策划、而非指挥，塑造、而非支配，其存在的意义，在于引导大家讨论、而非自己主宰一切。&lt;/p&gt;
&lt;p&gt;但是，具体应该如何执行呢？本文作者整理了 30 个公认的架构原则，来帮助大家解决此问题。也许有的原则，你从未听说，但你看完就能快速学会。&lt;/p&gt;
&lt;p&gt;相信你学会了，工作起来也会事半功倍，或许还可帮你避免很多无用的加班！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文作者叫 Srinath，是一位计算机科学家、软件架构师、作家。他是 Apache 的核心成员，拥有 15 年分布式系统编程经验，设计了 Apache Axis2 以及 WSO2 流处理器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 WSO2，我参与架构评审的时间已长达八年之久。WSO2 的产品非常丰富，比如 WSO2 ESB 、WSO2 API Manager  以及 WSO2 SP 都人尽皆知。在过去八年中，我们对许多产品和功能进行了讨论、设计、改进和重新设计。&lt;/p&gt;
&lt;p&gt;我们在设计软件的过程中，把握的一个关键点是：软件架构并非由架构师负责设计。我们的架构不是由架构师制定，然后交给其他人来实施。&lt;/p&gt;
&lt;p&gt;相反，架构的设计任务由真正编写代码的团队负责。架构师负责对工程师设计的架构进行修复、完善和改进。我们的架构团队是指导员和把关人，而非独裁者。&lt;/p&gt;
&lt;p&gt;在短期内，由一位架构师来制定架构的确既快捷又实惠。但是，从长远来看，我们会组建一个团队，让他们自己不断思考、改善架构，并从他们的错误中来提升自己。&lt;/p&gt;
&lt;p&gt;当我们专注于团队时，他们自然会随着时间的推移而变得更好。架构团队的首要任务是：尽可能保证架构容易执行。此外，架构评审也存在缺陷。&lt;/p&gt;
&lt;p&gt;就像 Paul （@pzfreo）描述的架构评审那样：架构师参与进来，听一会，发表一点评论然后就走了。作为一名架构师，你对架构发表自己的看法和意见无可厚非。但是，如果你不够投入和细心，你的意见可能会让团队感到困惑，团队就无法确定正确的做法到底是什么。&lt;/p&gt;
&lt;p&gt;接下来我会将 30 个架构原则一一列出，其中一些原则是众所周知的，而有些则源于我的个人经验和心血。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/15/CVRuDeBOyvcJM9G.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="分布式" scheme="https://www.hi-linux.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 反向代理使用教程</title>
    <link href="https://www.hi-linux.com/posts/5595.html"/>
    <id>https://www.hi-linux.com/posts/5595.html</id>
    <published>2020-05-24T01:07:00.000Z</published>
    <updated>2020-05-24T08:13:23.551Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>前段时间公司根据要求需要将聚石塔上服务器从杭州整体迁移到张家口，刚好趁这次机会将这些乱七八糟的服务器做一次梳理和整合。断断续续一个月迁移完成大概优化掉了 1/3 的机器，完成之后遇到了一些问题，比如：曾经零零散散部署在生产上一些可视化 UI：<code>Apollo</code>、<code>Kibana</code>、<code>Grafana</code>、<code>Jenkins</code> 等等服务，这些服务都采用了 <code>80</code> 或者其它公网端口进行对外暴露。为了安全，现在不再开放非 <code>80</code> 之外的公网端口。由于机器少了，<code>80</code> 端口不够，这些可视化 <code>UI</code> 不再能直接访问到了。所以需另寻其他出路。</p><h2 id="用-nginx-做反向代理">用 Nginx 做反向代理</h2><p>为了解决这两个问题，自然第一反应想到的就是使用反向代理，我的理想构思下应该是下图这样的。</p><p><img src="https://img2018.cnblogs.com/blog/214741/201911/214741-20191103230057336-52782006.jpg" alt=""></p><p>既用户所有的请求都经过 <code>Nginx</code>，让 <code>Nginx</code> 来判断当前 <code>URL</code> 需要跳转到哪一个后端代理上。比较好的策略应该是让 <code>Nginx</code> 来判断当前的 <code>Host</code> 是什么来决定跳转到哪一个后端的 <code>Webserver</code> 上，比如: <code>a.mip.com</code> 就跳转到 <code>Apollo</code>，<code>j.mip.com</code> 就跳转到 <code>Jenkins</code>。以此类推，这样就可以完美解决了。</p><a id="more"></a><h2 id="一个完整的演示实例">一个完整的演示实例</h2><p>为了实现上面的需求，在 <code>Nginx</code> 中你完全可以使用 <code>Rewrite</code> 模块下 <code>if</code> 指令来完成。由于 <code>Nginx</code> 默认带的模块比较少，如果需使用第三方模块，你可能还需要重新编译 <code>Nginx</code>。所以这里直接使用 <code>OpenResty</code>，它扩展了 <code>Nginx</code>，并且集成了很多成熟的 <code>LUA</code> 模块。可自行下载最新的 1.15.8 版本，其安装方式和 <code>Nginx</code> 一模一样。</p><blockquote><p>项目地址：<a href="https://openresty.org/en/download.html" target="_blank" rel="noopener">https://openresty.org/en/download.html</a></p></blockquote><p><img src="https://img2018.cnblogs.com/blog/214741/201911/214741-20191103230705182-358199087.jpg" alt=""></p><p><code>OpenResty</code> 默认是安装到 <code>/usr/local/</code> 目录下，当你看到有一个 <code>openresty</code> 目录就表示你安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># ls</span></span><br><span class="line">bin  etc  games  include  lib  lib64  libexec  openresty  sbin  share  src</span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>接下来你可以使用 <code>nginx  -v</code> 来验证下 <code>OpenResty</code> 版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/openresty/nginx/sbin</span><br><span class="line">[root@localhost sbin]<span class="comment"># </span></span><br><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -v</span></span><br><span class="line">nginx version: openresty/1.15.8.1</span><br></pre></td></tr></table></figure><p>为了演示方便，我就直接使用 <code>Nginx</code> 开启三个 Server。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.23.129:80    　 <span class="comment"># 在 80 端口上开启第一个网站，就是 Proxy 了。</span></span><br><span class="line">192.168.23.129:8001     <span class="comment"># 在 8001 端口上开启第二个网站，模拟 Apollo。</span></span><br><span class="line">192.168.23.129:8002     <span class="comment"># 在 8002 端口上开启第三个网站，模拟 Jenkins。</span></span><br></pre></td></tr></table></figure><p>首先，我们在 <code>Nginx</code> 中的配置好三个网站。</p><ol><li>Apollo 配置片断</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8001;</span><br><span class="line">        server_name  somename  alias  another.alias;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  apollo.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8001 端口网站的默认页是 <code>apollo.html</code>，这个 <code>apollo.html</code> 所在路径就是在 <code>Nginx</code> 目录下的 <code>html</code> 目录，如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost html]<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/openresty/nginx/html</span><br><span class="line">[root@localhost html]<span class="comment"># ls</span></span><br><span class="line">50x.html  apollo.html  index.html  jenkins.html</span><br></pre></td></tr></table></figure><ol start="2"><li>Jenkins 配置片断</li></ol><p><code>Jenkins.html</code> 的文件所在路径如下所示，不再赘述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8002;</span><br><span class="line">        server_name  somename  alias  another.alias;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  jenkins.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Proxy 配置片断</li></ol><p>我们可以看到，这里只需要使用 <code>Rewrite</code> 模块下的 <code>if</code> 条件语句。然后通过 <code>$host</code> 系统变量判断当前的 <code>URL</code> 中的 <code>host</code> 的值来实现跳转到相应的网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line"></span><br><span class="line">           if ($host &#x3D; &quot;a.mip.com&quot;) &#123;</span><br><span class="line">               proxy_pass http:&#x2F;&#x2F;localhost:8001;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if ($host &#x3D; &quot;j.mip.com&quot;) &#123;</span><br><span class="line">               proxy_pass http:&#x2F;&#x2F;localhost:8002;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们做好对应域名关系映射。这里为了演示方便，我们直接在 hosts 文件中进行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/hosts</span><br><span class="line">192.168.23.129 a.mip.com</span><br><span class="line">192.168.23.129 j.mip.com</span><br></pre></td></tr></table></figure><p>最后，启动 Nginx。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx </span></span><br><span class="line">[root@localhost sbin]<span class="comment"># </span></span><br><span class="line">[root@localhost sbin]<span class="comment"># </span></span><br><span class="line">[root@localhost sbin]<span class="comment"># netstat -tlnp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:8001            0.0.0.0:*               LISTEN      3802/nginx: master  </span><br><span class="line">tcp        0      0 0.0.0.0:8002            0.0.0.0:*               LISTEN      3802/nginx: master  </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      3802/nginx: master  </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1172/sshd           </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1724/master         </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1172/sshd           </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      1724/master</span><br></pre></td></tr></table></figure><p>通过上面输出看到，<code>80</code>、<code>8001</code>、<code>8002</code> 端口都已经开启了，接下来大家可以到浏览器去验证一下了。</p><p><img src="https://img2018.cnblogs.com/blog/214741/201911/214741-20191103232858709-1676878325.jpg" alt=""></p><p>从上图中，我们可以看到通过不同域名成功的访问到了不同的后端应用。以下是全部的 <code>Nginx</code> 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">$ cat nginx.conf</span><br><span class="line"></span><br><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$host ----&gt; $remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">    # location &#x3D; &#x2F;get &#123;</span><br><span class="line">        #     set_unescape_uri $key $arg_key;  # this requires ngx_set_misc</span><br><span class="line">        #     redis2_query get $key;</span><br><span class="line">        #     redis2_pass 10.105.13.174:6379;</span><br><span class="line">        # &#125;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">           </span><br><span class="line">           if ($host &#x3D; &quot;a.mip.com&quot;) &#123;</span><br><span class="line">               proxy_pass http:&#x2F;&#x2F;localhost:8001;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if ($host &#x3D; &quot;j.mip.com&quot;) &#123;</span><br><span class="line">               proxy_pass http:&#x2F;&#x2F;localhost:8002;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           root   html;</span><br><span class="line">           index  index.html index.htm;   </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8001;</span><br><span class="line">        server_name  somename  alias  another.alias;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  apollo.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8002;</span><br><span class="line">        server_name  somename  alias  another.alias;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  jenkins.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就演示完了一个反向代理实现多个不同类型的后端网站访问的场景，希望本篇文章对你有所帮助！</p><blockquote><p>来源：博客园</p><p>原文：<a href="https://url.cn/5iSfcUN" target="_blank" rel="noopener">https://url.cn/5iSfcUN</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间公司根据要求需要将聚石塔上服务器从杭州整体迁移到张家口，刚好趁这次机会将这些乱七八糟的服务器做一次梳理和整合。断断续续一个月迁移完成大概优化掉了 1/3 的机器，完成之后遇到了一些问题，比如：曾经零零散散部署在生产上一些可视化 UI：&lt;code&gt;Apollo&lt;/code&gt;、&lt;code&gt;Kibana&lt;/code&gt;、&lt;code&gt;Grafana&lt;/code&gt;、&lt;code&gt;Jenkins&lt;/code&gt; 等等服务，这些服务都采用了 &lt;code&gt;80&lt;/code&gt; 或者其它公网端口进行对外暴露。为了安全，现在不再开放非 &lt;code&gt;80&lt;/code&gt; 之外的公网端口。由于机器少了，&lt;code&gt;80&lt;/code&gt; 端口不够，这些可视化 &lt;code&gt;UI&lt;/code&gt; 不再能直接访问到了。所以需另寻其他出路。&lt;/p&gt;
&lt;h2 id=&quot;用-Nginx-做反向代理&quot;&gt;用 Nginx 做反向代理&lt;/h2&gt;
&lt;p&gt;为了解决这两个问题，自然第一反应想到的就是使用反向代理，我的理想构思下应该是下图这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/214741/201911/214741-20191103230057336-52782006.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;既用户所有的请求都经过 &lt;code&gt;Nginx&lt;/code&gt;，让 &lt;code&gt;Nginx&lt;/code&gt; 来判断当前 &lt;code&gt;URL&lt;/code&gt; 需要跳转到哪一个后端代理上。比较好的策略应该是让 &lt;code&gt;Nginx&lt;/code&gt; 来判断当前的 &lt;code&gt;Host&lt;/code&gt; 是什么来决定跳转到哪一个后端的 &lt;code&gt;Webserver&lt;/code&gt; 上，比如: &lt;code&gt;a.mip.com&lt;/code&gt; 就跳转到 &lt;code&gt;Apollo&lt;/code&gt;，&lt;code&gt;j.mip.com&lt;/code&gt; 就跳转到 &lt;code&gt;Jenkins&lt;/code&gt;。以此类推，这样就可以完美解决了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>别让自己的选择，限制了你的未来</title>
    <link href="https://www.hi-linux.com/posts/45902.html"/>
    <id>https://www.hi-linux.com/posts/45902.html</id>
    <published>2020-05-24T01:06:00.000Z</published>
    <updated>2020-05-24T08:13:23.549Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这一两周与几个朋友聊天，有年轻的90后，也有大叔级的70后，这些人在我看来都是很有能力的人，但是一些喜好过于强烈，让我不经意地回顾了我工作20年来身边的人，有发展得好的，也有发展的不好的，有些人是很可惜的，因为限制他们的不是其它人，也不是环境，而是自己，所以，很想写下这篇文章。（注：这篇文章可能会是一篇说教的文章，所以，可能会让你看着犯困，所以，我会尽量地短一些，而且尽可能多讲故事，少道理，这里的故事，全是真实发生的）</p><h2 id="几个故事">几个故事</h2><p>2019年年初，我面试了一个很年轻的小伙子（93/94年出生），这个小伙子特别有灵性，也很聪明，计算机专业出身，也很喜欢技术，基础和学习能力也很好。在我这20年来认识的人中，如果他能呆在北京、上海、深圳这样的城市，我保证不出三年，他会成为他们同龄人中非常出色的技术人员，如果有个好的舞台有一个好的团队带他，他的未来会非常成功。然而，这个小伙子有两大喜好：1）只愿（或是说被迫）呆在一个毫无IT的环境的三/四线城市，2）对技术有非常大的偏好，只喜欢Go语言，非常不喜欢其它的语言，比如：Java（离开Java的世界，基本上离开了做架构的世界）。</p><p>他的这两个喜好，足以让一个未来会很优秀的人毁掉，因为，这个时代没有限制他，他的能力也没有限制他，但是他的意识完完全全地限制了他。</p><ul><li><p>他把自己最宝贵的青春放在了很烂的项目上，就算能用一些新的技术，他也只能算是自娱自乐，在实验室中玩玩具罢了。</p></li><li><p>他把自己的技术栈封闭起来，而直接放弃了这个时代最具工业化的技术Java，对于一个好的程序员来说，同时掌握几门语言和技术完全是没什么问题，但是自己封闭了自己的视野。</p></li></ul><p>实在是非常可惜，我本来是可以为他介绍到一些很不错的公司的，但是他这样的习性，等于自己把自己未来的门给关上了，虽然我跟他长谈过，但是我也没有办法叫醒不想醒的人……</p><ul><li><p>视野、环境和舞台，对一个人的限制是非常大的。井蛙不知道大海，被空间维度所限制；夏虫不知道冬天，是被时间维度所限制；圈养的动物没有斗志，是被自己意识所限制。</p></li><li><p>偏见和不开放，对一个人的限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己的能力阉割掉，这是一件令人痛心的事。想想大清的闭关锁国是如何让亚洲第一的北洋水师给毁掉的……</p></li></ul><a id="more"></a><p>我还有个同学，他的技术并不差，就算呆在昆明这种很落后的地方，他也非常地好学，学习英文，学习各种新技术，对技术没有任何的偏好，喜欢C/C++/Java/Python/Shell，同样喜欢前端Javascript，对基础知识非常地踏实，他在技术上没有限制自己的潜力，有什么就学什么。后来，我带他玩Docker/Go/K8S……分布式架构，他也上手的很快……像他这样的人，技术能力完全没得说，比我还大一岁，44岁了，还是一样的天天追代码细节，看Youtube的各种大会，翻github里的各种issue和pull request……</p><p>我同学这人，拥有了成为一个技术牛人几乎所有的条件：基础知识过硬，细节扎得深，面很广，学习能力强，有英文能力，逻辑思维能力不错，非常的自律，执行力也很强，抓得住重点……然而，只有一个小问题，就是没有到大公司历练过，我三番五次叫他从昆明出来，但是最终他都呆在昆明这个城市没有出来，因为有所谓的家庭约束。然而，我身边还有好些人，把自己家从北京搬到上海，从上海搬到深圳，从厦门搬到深圳……这样的人大有人在……像他这样的能力，在哪个公司都会是主力和骨干，对于一个公司的主力和骨干来说，家庭上的这些问题都是小问题都是有很多解的……</p><p>另外，我这个同学还是一个比较悲观的人，任何事情都是先想到不好的事，他关注负面的东西会胜于正面的东西，而且他还有一定的社交恐惧，怕与人相处和交流，时间越长越害怕，甚至有时候直接跟我说，“我就是不想改变”这样的话……其实，我以前也是一个很害怕与人交流的人，面试的时候，我根本不敢正眼看面试官一眼，也不知道与人怎么交流。但是，我与他不一样，我努力克服，不断地面试，与人面对面的交流，到一线技术客服接用户的电话，在公司里做分享，慢慢地到外面分享……3-5年就完全克服掉了。</p><p>其实，很多事情，完全是有解的，也没有必要担心，自己的心理障碍也是可以克服的，重点就是自己愿不愿意，只要愿意完成了一半，接下来就是不断的摸爬滚打坚持了。</p><ul><li><p>不限制自己的人，会穷举各种方法来解决问题，限制自己的人，只会找各式各样的问题或借口。</p></li><li><p>不限制自己的人，会努力改变自己的问题和缺陷，限制自己的人，会放任自己。</p></li></ul><h2 id="另外几个故事">另外几个故事</h2><p>我还有另外几个故事（活到四十多，能看到好多人十几年的发展过程，感觉有点上帝视角了）</p><p>我还有一个以前团队里的一个小伙，人是很聪明，但就完全就是野路子，他对技术没有什么偏好，一个PHP程序员，做那个Discuz!论坛，公司被并购了，转成Java，开始研究Java的各种细节，对技术从来没有什么偏见，有什么就玩什么，每做一个项目，就算是一样的他都要用新的技术做一遍，然后跟着我做云计算，我教他TCP，教他C/C++，后来一起玩Docker/Go，等等，反正是一点就通，他是我见过学习能力最强的人。但是，有一个事他一直与我的想法不一样，就是我希望他先把软件设计好，再写代码，他非常不能理解，他习惯于直接动手开干，然后有什么问题就整什么问题，我也很难教育他。</p><p>有一天，他电话面了一下Facebook，电话面了15分钟后对方就放弃了，他受到了严重的打击。然后，他就开始找菲利宾人练英文口语了，我也让他做算法题，然后，他才发现，一道连算法都不是的纯编程题都提交几次都过不了，等他做完了Leetcode最初的那151道题后，整个人都改变了，写代码前认认真真地在纸上把程序的状态，处理时序以及可能遇到的一些条件先罗列出来，然后，进行逻辑设计后，再写，从此，他就开启他更大的天地了。我后来把他推荐给了微软，先在中国的Bing，在中国升好2-3级，然后去了美国的Azure，现在听说他准备要跟 k8s 的 co-founder Brendan Burns 混了（虽然，他现在还在印度人手下，但是，我真的不知道他未来能玩多大，因为今年他才33岁，而且非常聪明）</p><p>他以前是把自己封闭起来的，我叫他出来，他也不出来，后来因为一些办公室政治的原因不得不来找我，于是我就带着他玩了两年，跟他讲了很多外面的世界是怎么玩的，他这个人也是一个相当不善于社交的人，但是心是开放的，愿意接受新的东西，虽然对技术也有一定偏见，比如不喜欢Windows，但是也不会不喜欢到完全封闭。后来我跟他说，微软的技术相当的强的，你看到的技术只是表面，深层次的东西都是相通的，直到他到了微软后发现各种牛逼的东西，对微软系统的技术的态度也有了改变，而且我让他跟我说很多微软那边的事，我发现，他对技术了解的维度已经是越来越高级的了……</p><p>还是我以前团队的一个小伙，他是一个前端，他说前端的东西没什么意思，想来找我做后端，我也一点点带他……后来，我说，你如果想要玩得好，你必需来北京，无论现在你觉得过得有多好，你都要放弃掉，然后，尽最大可能出去经历一下世界最顶尖的公司，我甚至跟他说，如果他女朋友不跟来的话，就先分开一段时间，先自己立业，他来北京的时候，他之前的同事都等着看他的笑话，我说，那些人连想都不敢想，不必管他们。于是，他去了Amazon，再过了一年去了西雅图，我跟他说，接下来就是去AWS，然后，如果有足够的野心，用自己的年轻这个资本去硅谷创业公司赌一把……未来他怎么样我不知道，但至少他没有限制自己，他的未来不会有封顶……</p><p>也是我的同学，我跟他在大学是上下铺，后来他去了人民大学读计算机博士，大学的时候做国产数据库kingbase，然后去了一家外企，天天被派到用户那边做数据分析，后来，他想回科研单位做国产数据库，我说，别啊，你的技术比我好太多，还有博士理论加持，你不去国外顶尖公司玩玩，你不知道自己有多强的，于是他跟公司申请去了国外做核心，后来因为Hadoop的原因，公司的产品最终成为了历史，于是我说，你来了美国么，你一定要去AWS，于是他就去了AWS的Aurora团队，成为了AWS明星级产品的中坚力量，天天在改MySQL的核心源码，干了两年，被提升为Principal Software Engineer ……</p><p>这里我到不是说出国有多牛，也许你只关注能挣多少钱，但是我想说，他们之所以能有这样的际遇，除了他们本来就有实力，还更因为他们从来不给自己设制什么限制，就是那种“艺多不压身”，有什么就学什么，有更高的就去向更高的迈进，其它的像家庭什么的问题其实都是会有解的，真的不必担心太多……</p><h2 id="别限制了自己">别限制了自己</h2><p>上面的这些故事，也许你能看得懂，也许你看得不一定能懂，这里，让我来做个总结吧</p><ul><li><p>**做有价值的事。**这个世界对计算机人才的要求是供不应求的，所以，不要让自己为自己找各式各样的借口，让自己活在“玩玩具”、“搬砖”和“使蛮力加班”的境地。其实，我发现这世界上有能力的人并不少，但是有品味的人的确很少。<strong>所谓的有价值，就是，别人愿付高价的，高技术门槛的，有创造力的，有颠覆性的……</strong></p></li><li><p>**扩大自己的眼界，开放自己的内心。**人要变得开放，千万不要做一个狭隘的民族主义者，做一个开放的人，把目光放在全人类这个维度，不断地把自己融入到世界上，而不是把自己封闭起来，这里，<strong>你的英文语言能力对你能不能融入世界是起决定性的作用。</strong> 开放自己的心态，正视自己的缺点，你才可能往前迈进。<strong>你的视野决定了你的知不知道要去哪，你的开放决定了你想不想去。</strong></p></li><li><p><strong>站在更高的维度。</strong> 面的维度会超过点的维点，空间的维度会超过面的维度，在更高维度上思考和学习，你会获得更多。<strong>整天在焦虑那些低维度的事（比如自己的薪水、工作的地点、稳不稳定、有没有户口……），只会让你变得越来越平庸，只要你站在更高的维度（比如： 眼界有没有扩大、可能性是不是更多、竞争力是不是更强、能不能解决更大更难的问题、能创造多大的价值……），时间会让你明白那些低维度的东西全都不是事儿。</strong> 技术学习上也一样，站在学习编程语法特性的维度和站在学习编程范式、设计模式的维度是两种完全不一样的学习方式。</p></li><li><p><strong>精于计算得失。</strong> 很多人其实不是很懂计算。绝大多数人都是在算计自己会失去多少，而不会算会得到多少。而一般的人也总是在算短期内会失去什么，优秀则总是会算我投入后未来会有什么样的回报，前者在算计今天，目光短浅，而后者则是舍在今天，得在明天，计算的是未来。<strong>精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。</strong></p></li><li><p><strong>勇于跳出传统的束缚。</strong> 有时候，跳出传统并不是一件很容易的事，因为大多数人都会对未知有恐惧的心理。比如：我看到很多人才都被大公司垄断了，其实，有能力的人都不需要加入大公司，有能力的人是少数，这些少数的人应该是所有的公司share着用的，这样一来，对于所有的人都是利益最大化的。这样的事现在也有，比如：律师、设计师……。但是，绝大多数有能力的技术人员是不敢走出这步。我在2015年到2016年实践过一年半，有过这些实践，做“鸡”的比“二奶”好多了，收入也好很多很多（不好意思开车了）……</p></li></ul><p>庄子说过几句话——</p><blockquote><p>井蛙不可以语于海者，拘于虚也；//空间局限</p><p>夏虫不可以语于冰者，笃于时也；//时间局限</p><p>曲士不可以语于道者，束于教也。//认识局限</p></blockquote><p>别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想，共勉！</p><p><strong>注：这篇文章就是要劝大家更为开放，让自己有更多的可能性，能到更高的层次，做更有价值的事，成为更强更好的人……当然，如果你觉得你只想做一个平凡人，也和本文并不冲突……另外你也不要觉得这篇文章是让你要成为一个精英，但你一定要去摸高……这篇文章是告诉你一种面对人生的思考方式，在这种思考方式下，你会有更多的可能性，更大的场景……而不是直接把自己归到“平常人”，把自己“墙”了！</strong></p><blockquote><p>本文转载自：「酷壳」，原文：<a href="https://url.cn/5xBwefC%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5xBwefC，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一两周与几个朋友聊天，有年轻的90后，也有大叔级的70后，这些人在我看来都是很有能力的人，但是一些喜好过于强烈，让我不经意地回顾了我工作20年来身边的人，有发展得好的，也有发展的不好的，有些人是很可惜的，因为限制他们的不是其它人，也不是环境，而是自己，所以，很想写下这篇文章。（注：这篇文章可能会是一篇说教的文章，所以，可能会让你看着犯困，所以，我会尽量地短一些，而且尽可能多讲故事，少道理，这里的故事，全是真实发生的）&lt;/p&gt;
&lt;h2 id=&quot;几个故事&quot;&gt;几个故事&lt;/h2&gt;
&lt;p&gt;2019年年初，我面试了一个很年轻的小伙子（93/94年出生），这个小伙子特别有灵性，也很聪明，计算机专业出身，也很喜欢技术，基础和学习能力也很好。在我这20年来认识的人中，如果他能呆在北京、上海、深圳这样的城市，我保证不出三年，他会成为他们同龄人中非常出色的技术人员，如果有个好的舞台有一个好的团队带他，他的未来会非常成功。然而，这个小伙子有两大喜好：1）只愿（或是说被迫）呆在一个毫无IT的环境的三/四线城市，2）对技术有非常大的偏好，只喜欢Go语言，非常不喜欢其它的语言，比如：Java（离开Java的世界，基本上离开了做架构的世界）。&lt;/p&gt;
&lt;p&gt;他的这两个喜好，足以让一个未来会很优秀的人毁掉，因为，这个时代没有限制他，他的能力也没有限制他，但是他的意识完完全全地限制了他。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;他把自己最宝贵的青春放在了很烂的项目上，就算能用一些新的技术，他也只能算是自娱自乐，在实验室中玩玩具罢了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;他把自己的技术栈封闭起来，而直接放弃了这个时代最具工业化的技术Java，对于一个好的程序员来说，同时掌握几门语言和技术完全是没什么问题，但是自己封闭了自己的视野。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实在是非常可惜，我本来是可以为他介绍到一些很不错的公司的，但是他这样的习性，等于自己把自己未来的门给关上了，虽然我跟他长谈过，但是我也没有办法叫醒不想醒的人……&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;视野、环境和舞台，对一个人的限制是非常大的。井蛙不知道大海，被空间维度所限制；夏虫不知道冬天，是被时间维度所限制；圈养的动物没有斗志，是被自己意识所限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;偏见和不开放，对一个人的限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己的能力阉割掉，这是一件令人痛心的事。想想大清的闭关锁国是如何让亚洲第一的北洋水师给毁掉的……&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="思想" scheme="https://www.hi-linux.com/tags/%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Explain 使用指南</title>
    <link href="https://www.hi-linux.com/posts/5749.html"/>
    <id>https://www.hi-linux.com/posts/5749.html</id>
    <published>2020-05-24T01:05:00.000Z</published>
    <updated>2020-05-24T08:13:23.550Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>MySQL的 explain 命令语句提供了如何执行 SQL 语句的信息，解析 SQL 语句的执行计划并展示，explain 支持 select、delete、insert、replace 和 update 等语句，也支持对分区表的解析。通常 explain 用来获取 select 语句的执行计划，通过 explain 展示的信息我们可以了解到表查询的顺序，表连接的方式等，并根据这些信息判断 select 执行效率，决定是否添加索引或改写 SQL 语句优化表连接方式以提高执行效率。本文参考官方文档：EXPLAIN Output Format 对 explain 输出的内容进行说明，同时也对自己之前使用 explain 不清晰的方面进行总结。</p><p>本文使用的 MySQL 版本为官方社区版 5.7.24。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:(none)&gt; select version();</span><br><span class="line">+------------+</span><br><span class="line">| version()  |</span><br><span class="line">+------------+</span><br><span class="line">| 5.7.24-log |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.066s</span><br></pre></td></tr></table></figure><h2 id="主要用法">主要用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; EXPLAIN | DESCRIBE &#125; [EXTENDED | PARTITIONS | FORMAT&#x3D;[TRADITIONAL | JSON]] SQL_STATEMENT;</span><br></pre></td></tr></table></figure><ol><li><p>EXPLAIN 和 DESCRIBE(可以简写成 DESC)都可以用来查看语句的执行计划，但通常使用 EXPLAIN 较多；</p></li><li><p>FORMAT 选项可以指定执行计划输出信息为 JSON 格式，而且包含一些更详细的指标说明；</p></li><li><p>EXTENDED 和 PARTITIONS 选项可以输出更详细选项说明，语法上是为了兼容低版本 MySQL，未来会废弃，默认使用 EXPLAIN 命令即可。</p></li></ol><h2 id="测试数据">测试数据</h2><p>本文基于 MySQL 官方示例数据库 employee：Example Databases 进行解析说明，使用到的表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">-- employees：</span><br><span class="line">mysql root@localhost:employees&gt; show create table employees\G;</span><br><span class="line">***************************[ 1. row ]***************************</span><br><span class="line">Table        | employees</span><br><span class="line">Create Table | CREATE TABLE &#96;employees&#96; (</span><br><span class="line">  &#96;emp_no&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;birth_date&#96; date NOT NULL,</span><br><span class="line">  &#96;first_name&#96; varchar(14) NOT NULL,</span><br><span class="line">  &#96;last_name&#96; varchar(16) NOT NULL,</span><br><span class="line">  &#96;gender&#96; enum(&#39;M&#39;,&#39;F&#39;) NOT NULL,</span><br><span class="line">  &#96;hire_date&#96; date NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;emp_no&#96;),</span><br><span class="line">  KEY &#96;idx_first_last&#96; (&#96;first_name&#96;,&#96;last_name&#96;),</span><br><span class="line">  KEY &#96;idx_birth_hire&#96; (&#96;birth_date&#96;,&#96;hire_date&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.008s</span><br><span class="line"></span><br><span class="line">-- dept_emp：</span><br><span class="line">mysql root@localhost:employees&gt; show create table dept_emp\G;</span><br><span class="line">***************************[ 1. row ]***************************</span><br><span class="line">Table        | dept_emp</span><br><span class="line">Create Table | CREATE TABLE &#96;dept_emp&#96; (</span><br><span class="line">  &#96;emp_no&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;dept_no&#96; char(4) NOT NULL,</span><br><span class="line">  &#96;from_date&#96; date NOT NULL,</span><br><span class="line">  &#96;to_date&#96; date NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;emp_no&#96;,&#96;dept_no&#96;),</span><br><span class="line">  KEY &#96;dept_no&#96; (&#96;dept_no&#96;),</span><br><span class="line">  CONSTRAINT &#96;dept_emp_ibfk_1&#96; FOREIGN KEY (&#96;emp_no&#96;) REFERENCES &#96;employees&#96; (&#96;emp_no&#96;) ON DELETE CASCADE,</span><br><span class="line">  CONSTRAINT &#96;dept_emp_ibfk_2&#96; FOREIGN KEY (&#96;dept_no&#96;) REFERENCES &#96;departments&#96; (&#96;dept_no&#96;) ON DELETE CASCADE</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.010s</span><br><span class="line"></span><br><span class="line">-- departments：</span><br><span class="line">mysql root@localhost:employees&gt; show create table departments\G;</span><br><span class="line">***************************[ 1. row ]***************************</span><br><span class="line">Table        | departments</span><br><span class="line">Create Table | CREATE TABLE &#96;departments&#96; (</span><br><span class="line">  &#96;dept_no&#96; char(4) NOT NULL,</span><br><span class="line">  &#96;dept_name&#96; varchar(40) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;dept_no&#96;),</span><br><span class="line">  UNIQUE KEY &#96;dept_name&#96; (&#96;dept_name&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.012s</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="输出说明">输出说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select count(*) from employees;</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+--------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref    | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+--------+--------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | index | &lt;null&gt;        | PRIMARY | 4       | &lt;null&gt; | 299512 | 100.0    | Using index |</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+--------+--------+----------+-------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.026s</span><br></pre></td></tr></table></figure><p>通过以上示例语句得出 explain 输出有 12 个字段，主要说明如下表：</p><p><img src="https://i.loli.net/2019/09/25/Lp2vShJgtlMEqK6.png" alt=""></p><h3 id="id">id</h3><p>id 为 select 标识符，语句在执行计划当中的执行顺序。id 值的出现有如下几种情况：</p><ol><li><p>id 值全相同，则按由上到下顺序执行；</p></li><li><p>id 值全不相同，则按 id 值大小，由大到小顺序执行；</p></li><li><p>id 值部分相同，部分不相同，则同组 id 值大的优先执行(组内 id 值相同的顺序执行)。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">-- id 全相同</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from employees e,dept_emp d,departments de where e.emp_no &#x3D; d.emp_no and de.dept_name &#x3D; &#39;Human</span><br><span class="line">                                Resources&#39;;</span><br><span class="line"></span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+--------------------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref                | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+--------------------+--------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | de    | &lt;null&gt;     | const | dept_name     | dept_name | 122     | const              | 1      | 100.0    | Using index |</span><br><span class="line">| 1  | SIMPLE      | e     | &lt;null&gt;     | ALL   | PRIMARY       | &lt;null&gt;    | &lt;null&gt;  | &lt;null&gt;             | 299512 | 100.0    | &lt;null&gt;      |</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | ref   | PRIMARY       | PRIMARY   | 4       | employees.e.emp_no | 1      | 100.0    | &lt;null&gt;      |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+--------------------+--------+----------+-------------+</span><br><span class="line">3 rows in set</span><br><span class="line">Time: 0.018s</span><br><span class="line"></span><br><span class="line">-- id 全不相同</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from employees e where e.emp_no &#x3D; (select d.emp_no from dept_emp d where d.dept_no &#x3D; (select de.d</span><br><span class="line">                                ept_no from departments de where de.dept_name &#x3D; &#39;Development&#39;) and d.emp_no &#x3D; 10023);</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+-----------+---------+-------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys   | key       | key_len | ref         | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+-----------+---------+-------------+------+----------+-------------+</span><br><span class="line">| 1  | PRIMARY     | e     | &lt;null&gt;     | const | PRIMARY         | PRIMARY   | 4       | const       | 1    | 100.0    | &lt;null&gt;      |</span><br><span class="line">| 2  | SUBQUERY    | d     | &lt;null&gt;     | const | PRIMARY,dept_no | PRIMARY   | 16      | const,const | 1    | 100.0    | Using index |</span><br><span class="line">| 3  | SUBQUERY    | de    | &lt;null&gt;     | const | dept_name       | dept_name | 122     | const       | 1    | 100.0    | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+-----------+---------+-------------+------+----------+-------------+</span><br><span class="line">3 rows in set</span><br><span class="line">Time: 0.027s</span><br><span class="line"></span><br><span class="line">-- id 部分相同，部分不相同</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from^Iemployees e where^Ie.emp_no in (select d.emp_no from dept_emp d where d.dept_no &#x3D; (select d</span><br><span class="line">                                e.dept_no from departments de where de.dept_name &#x3D; &#39;Human Resources&#39;));</span><br><span class="line">+----+-------------+-------+------------+--------+-----------------+-----------+---------+--------------------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys   | key       | key_len | ref                | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+--------+-----------------+-----------+---------+--------------------+-------+----------+-------------+</span><br><span class="line">| 1  | PRIMARY     | d     | &lt;null&gt;     | ref    | PRIMARY,dept_no | dept_no   | 12      | const              | 33212 | 100.0    | Using index |</span><br><span class="line">| 1  | PRIMARY     | e     | &lt;null&gt;     | eq_ref | PRIMARY         | PRIMARY   | 4       | employees.d.emp_no | 1     | 100.0    | &lt;null&gt;      |</span><br><span class="line">| 3  | SUBQUERY    | de    | &lt;null&gt;     | const  | dept_name       | dept_name | 122     | const              | 1     | 100.0    | Using index |</span><br><span class="line">+----+-------------+-------+------------+--------+-----------------+-----------+---------+--------------------+-------+----------+-------------+</span><br><span class="line">3 rows in set</span><br><span class="line">Time: 0.020s</span><br></pre></td></tr></table></figure><h3 id="select_type">select_type</h3><p>select_type 为表查询的类型，根据官方文档总结几种常见类型如下表：</p><p><img src="https://i.loli.net/2019/09/25/zWs5YpGgiMQmtvB.png" alt=""></p><ol><li>SIMPLE：最常见的查询类型，通常情况下没有子查询、union 查询就是 SIMPLE 类型。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees where emp_no &#x3D; 10001;</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | const | PRIMARY       | PRIMARY | 4       | const | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.019s</span><br></pre></td></tr></table></figure><ol start="2"><li>PRIMARY 和 SUBQUERY：在含有子查询的语句中会出现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from dept_emp d where d.dept_no &#x3D; (select de.dept_no from departments de where de.dept_name &#x3D; &#39;De</span><br><span class="line">                                velopment&#39;);</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref   | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+--------+----------+-------------+</span><br><span class="line">| 1  | PRIMARY     | d     | &lt;null&gt;     | ref   | dept_no       | dept_no   | 12      | const | 148054 | 100.0    | Using where |</span><br><span class="line">| 2  | SUBQUERY    | de    | &lt;null&gt;     | const | dept_name     | dept_name | 122     | const | 1      | 100.0    | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+--------+----------+-------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.021s</span><br></pre></td></tr></table></figure><ol start="3"><li>UNION 和 UNION RESULT：在有 union 查询的语句中出现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from departments where dept_no &#x3D; &#39;d005&#39; union select * from departments where dept_no &#x3D; &#39;d004&#39;;</span><br><span class="line">+--------+--------------+-------------+------------+-------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">| id     | select_type  | table       | partitions | type  | possible_keys | key     | key_len | ref    | rows   | filtered | Extra           |</span><br><span class="line">+--------+--------------+-------------+------------+-------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">| 1      | PRIMARY      | departments | &lt;null&gt;     | const | PRIMARY       | PRIMARY | 12      | const  | 1      | 100.0    | &lt;null&gt;          |</span><br><span class="line">| 2      | UNION        | departments | &lt;null&gt;     | const | PRIMARY       | PRIMARY | 12      | const  | 1      | 100.0    | &lt;null&gt;          |</span><br><span class="line">| &lt;null&gt; | UNION RESULT | &lt;union1,2&gt;  | &lt;null&gt;     | ALL   | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt; | &lt;null&gt; | &lt;null&gt;   | Using temporary |</span><br><span class="line">+--------+--------------+-------------+------------+-------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">3 rows in set</span><br><span class="line">Time: 0.020s</span><br></pre></td></tr></table></figure><ol start="4"><li>DEPENDENT UNION 和 DEPENDENT SUBQUERY：当语句中子查询和 union 查询依赖外部查询会出现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees e where e.emp_no in (select d.emp_no from dept_emp d where d.from_date &#x3D; &#39;1986-06-</span><br><span class="line">                                26&#39; union select d.emp_no from dept_emp d where d.from_date &#x3D; &#39;1996-08-03&#39;);</span><br><span class="line">+--------+--------------------+------------+------------+------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">| id     | select_type        | table      | partitions | type | possible_keys | key     | key_len | ref    | rows   | filtered | Extra          |</span><br><span class="line">+--------+--------------------+------------+------------+------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">| 1      | PRIMARY            | e          | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt; | 299512 | 100.0    | Using where    |</span><br><span class="line">| 2      | DEPENDENT SUBQUERY | d          | &lt;null&gt;     | ref  | PRIMARY       | PRIMARY | 4       | func   | 1      |  10.0    | Using where    |</span><br><span class="line">| 3      | DEPENDENT UNION    | d          | &lt;null&gt;     | ref  | PRIMARY       | PRIMARY | 4       | func   | 1      |  10.0    | Using where    |</span><br><span class="line">| &lt;null&gt; | UNION RESULT       | &lt;union2,3&gt; | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt; | &lt;null&gt; | &lt;null&gt;   | Using temporary|</span><br><span class="line">+--------+--------------------+------------+------------+------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">4 rows in set</span><br><span class="line">Time: 0.022s</span><br></pre></td></tr></table></figure><ol start="5"><li>DERIVED：当查询涉及生成临时表时出现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from (select * from departments limit 5) de;</span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+-----------+---------+--------+------+----------+-------------+</span><br><span class="line">| id | select_type | table       | partitions | type  | possible_keys | key       | key_len | ref    | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+-----------+---------+--------+------+----------+-------------+</span><br><span class="line">| 1  | PRIMARY     | &lt;derived2&gt;  | &lt;null&gt;     | ALL   | &lt;null&gt;        | &lt;null&gt;    | &lt;null&gt;  | &lt;null&gt; | 5    | 100.0    | &lt;null&gt;      |</span><br><span class="line">| 2  | DERIVED     | departments | &lt;null&gt;     | index | &lt;null&gt;        | dept_name | 122     | &lt;null&gt; | 9    | 100.0    | Using index |</span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+-----------+---------+--------+------+----------+-------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.012s</span><br></pre></td></tr></table></figure><ol start="6"><li>table</li></ol><p>指执行计划当中当前是从哪张表获取数据，如果为表指定了别名，则显示别名，如果没有涉及对表的数据读取，则显示 NULL，还有如下几种情形：</p><ul><li><p>&lt;unionM,N&gt;：数据来自union查询的id为M和N的结果集；</p></li><li><p>：数据来自派生表id为N的结果集；</p></li><li><p>：数据来自子查询id为N的结果集。</p></li></ul><ol start="7"><li>partitions</li></ol><p>指执行计划中当前从分区表哪个表分区获取数据，如果不是分区表，则显示为 NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-- 示例数据库 employees 的分区表 salaries</span><br><span class="line">mysql root@localhost:employees&gt; show create table salaries;</span><br><span class="line">+----------+-----------------------------------------------------------------+</span><br><span class="line">| Table    | Create Table                                                    |</span><br><span class="line">+----------+-----------------------------------------------------------------+</span><br><span class="line">| salaries | CREATE TABLE &#96;salaries&#96; (                                       |</span><br><span class="line">|          |   &#96;emp_no&#96; int(11) NOT NULL,                                    |</span><br><span class="line">|          |   &#96;salary&#96; int(11) NOT NULL,                                    |</span><br><span class="line">|          |   &#96;from_date&#96; date NOT NULL,                                    |</span><br><span class="line">|          |   &#96;to_date&#96; date NOT NULL,                                      |</span><br><span class="line">|          |   PRIMARY KEY (&#96;emp_no&#96;,&#96;from_date&#96;)                            |</span><br><span class="line">|          | ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8                            |</span><br><span class="line">|          | &#x2F;*!50500 PARTITION BY RANGE  COLUMNS(from_date)                 |</span><br><span class="line">|          | (PARTITION p01 VALUES LESS THAN (&#39;1985-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p02 VALUES LESS THAN (&#39;1986-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p03 VALUES LESS THAN (&#39;1987-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p04 VALUES LESS THAN (&#39;1988-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p05 VALUES LESS THAN (&#39;1989-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p06 VALUES LESS THAN (&#39;1990-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p07 VALUES LESS THAN (&#39;1991-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p08 VALUES LESS THAN (&#39;1992-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p09 VALUES LESS THAN (&#39;1993-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p10 VALUES LESS THAN (&#39;1994-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p11 VALUES LESS THAN (&#39;1995-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p12 VALUES LESS THAN (&#39;1996-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p13 VALUES LESS THAN (&#39;1997-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p14 VALUES LESS THAN (&#39;1998-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p15 VALUES LESS THAN (&#39;1999-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p16 VALUES LESS THAN (&#39;2000-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p17 VALUES LESS THAN (&#39;2001-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p18 VALUES LESS THAN (&#39;2002-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p19 VALUES LESS THAN (MAXVALUE) ENGINE &#x3D; InnoDB) *&#x2F;  |</span><br><span class="line">+----------+-----------------------------------------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.018s</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; explain select * from salaries where from_date &gt; &#39;1985-12-31&#39; and from_date &lt; &#39;1990-12-31&#39;;</span><br><span class="line">+----+-------------+----------+---------------------+------+---------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table    | partitions          | type | possible_keys | key    | key_len | ref    | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+----------+---------------------+------+---------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | salaries | p02,p03,p04,p05,p06 | ALL  | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 384341 | 11.11    | Using where |</span><br><span class="line">+----+-------------+----------+---------------------+------+---------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.023s</span><br></pre></td></tr></table></figure><h3 id="type">type</h3><p>type 应该被认为是解读执行计划当中最重要的部分，根据 type 显示的内容可以判断语句总体的查询效率。主要有以下几种类型：</p><ol><li>system：表只有一行(系统表)，是 const 的一种特殊情况。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">-- 测试表 departments_1 生成：</span><br><span class="line">mysql root@localhost:employees&gt; create table departments_1 as select * from departments where dept_no&#x3D;&#39;d005&#39;;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Time: 0.107s </span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; alter table departments_1 add primary key(dept_no);</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; create index idx_dept_name on departments_1(dept_name);</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; show create table departments_1\G;</span><br><span class="line">***************************[ 1. row ]***************************</span><br><span class="line">Table        | departments_1</span><br><span class="line">Create Table | CREATE TABLE &#96;departments_1&#96; (</span><br><span class="line">  &#96;dept_no&#96; char(4) NOT NULL,</span><br><span class="line">  &#96;dept_name&#96; varchar(40) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;dept_no&#96;),</span><br><span class="line">  KEY &#96;idx_dept_name&#96; (&#96;dept_name&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.010s</span><br><span class="line"></span><br><span class="line">-- 系统表：</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from mysql.proxies_priv;</span><br><span class="line">+----+-------------+--------------+------------+--------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">| id | select_type | table        | partitions | type   | possible_keys | key    | key_len | ref    | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+--------------+------------+--------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | proxies_priv | &lt;null&gt;     | system | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+--------------+------------+--------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.023s</span><br><span class="line"></span><br><span class="line">-- 普通表：</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from (select * from departments_1 where dept_no &#x3D; &#39;d005&#39; limit 1) de;</span><br><span class="line">+----+-------------+---------------+------------+--------+---------------+---------+---------+--------+------+----------+--------+</span><br><span class="line">| id | select_type | table         | partitions | type   | possible_keys | key     | key_len | ref    | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+---------------+------------+--------+---------------+---------+---------+--------+------+----------+--------+</span><br><span class="line">| 1  | PRIMARY     | &lt;derived2&gt;    | &lt;null&gt;     | system | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt; | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">| 2  | DERIVED     | departments_1 | &lt;null&gt;     | const  | PRIMARY       | PRIMARY | 12      | const  | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+---------------+------------+--------+---------------+---------+---------+--------+------+----------+--------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.015s</span><br></pre></td></tr></table></figure><ol start="2"><li>const：对于主键或者唯一索引键的等值查询，只返回一行数据。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from departments_1 where dept_no &#x3D; &#39;d005&#39;;</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | departments_1 | &lt;null&gt;     | const | PRIMARY       | PRIMARY | 12      | const | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.018s</span><br></pre></td></tr></table></figure><ol start="3"><li>eq_ref：对于前表的每一行数据，都只能匹配当前表唯一一行数据。除了 system 与 const 之外这是最好的一种连接查询类型，主键或者是非空唯一索引的所有部分都可以在连接时被使用，通常使用的是’='操作符，比较值可以是一个常量，也可以是一个在该表之前读取该表的字段表达式。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">explain select * from departments d,departments_1 d1 where d.dept_no &#x3D; d1.dept_no;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------------+---------+----------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key           | key_len | ref                  | rows | filtered | Extra      |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------------+---------+----------------------+------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | d1    | &lt;null&gt;     | index  | PRIMARY       | idx_dept_name | 123     | &lt;null&gt;               | 1    | 100.0    | Using index|</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | eq_ref | PRIMARY       | PRIMARY       | 12      | employees.d1.dept_no | 1    | 100.0    | &lt;null&gt;     |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------------+---------+----------------------+------+----------+-------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.037s</span><br></pre></td></tr></table></figure><ol start="4"><li>ref：对于前表的每一行数据，都从当前表读取所有匹配索引值的行。与 eq_ref 相比，连接查询字段不是主键或者唯一索引，又或者是复合索引的部分左前缀，如果连接查询匹配的是少量几行数据，ref 是个不同错的选择，通常使用的运算符是’=’、’&lt;=‘或者’&gt;='等。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from dept_emp where dept_no &#x3D;&#39;d005&#39;;</span><br><span class="line">+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+--------+</span><br><span class="line">| id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra  |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | dept_emp | &lt;null&gt;     | ref  | dept_no       | dept_no | 12      | const | 148054 | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+--------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.059s</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; explain select * from dept_emp d,departments_1 d1 where d.dept_no &#x3D; d1.dept_no;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+----------------------+-------+----------+--------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref                  | rows  | filtered | Extra  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+----------------------+-------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | d1    | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt;               | 1     | 100.0    | &lt;null&gt; |</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | ref  | dept_no       | dept_no | 12      | employees.d1.dept_no | 41392 | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+----------------------+-------+----------+--------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.012s</span><br></pre></td></tr></table></figure><ol start="5"><li>ref_or_null：同ref类型，但是包含了对NULL值的搜索。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select dept_name from departments_1 where dept_name &#x3D; &#39;d005&#39; or dept_name is null;</span><br><span class="line">+----+-------------+---------------+------------+-------------+---------------+---------------+---------+-------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table         | partitions | type        | possible_keys | key           | key_len | ref   | rows | filtered | Extra                   |</span><br><span class="line">+----+-------------+---------------+------------+-------------+---------------+---------------+---------+-------+------+----------+--------------------------+</span><br><span class="line">| 1  | SIMPLE      | departments_1 | &lt;null&gt;     | ref_or_null | idx_dept_name | idx_dept_name | 123     | const | 2    | 100.0    | Using where; Using index |</span><br><span class="line">+----+-------------+---------------+------------+-------------+---------------+---------------+---------+-------+------+----------+--------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.011s</span><br></pre></td></tr></table></figure><ol start="6"><li>index_merge：使用了索引合并优化进行查询。如果查询指定条件涉及对多个索引的使用时，会将多个索引合并操作。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from dept_emp where emp_no &#x3D; 10001 or dept_no &#x3D; (select dept_no from departments_1);</span><br><span class="line">+----+-------------+---------------+------------+-------------+-----------------+-----------------+---------+--------+--------+----------+-------------------------------------------+</span><br><span class="line">| id | select_type | table         | partitions | type        | possible_keys   | key             | key_len | ref    | rows   | filtered | Extra                                    |</span><br><span class="line">+----+-------------+---------------+------------+-------------+-----------------+-----------------+---------+--------+--------+----------+-------------------------------------------+</span><br><span class="line">| 1  | PRIMARY     | dept_emp      | &lt;null&gt;     | index_merge | PRIMARY,dept_no | PRIMARY,dept_no | 4,12    | &lt;null&gt; | 148055 | 100.0    | Using union(PRIMARY,dept_no); Using where |</span><br><span class="line">| 2  | SUBQUERY    | departments_1 | &lt;null&gt;     | index       | &lt;null&gt;          | idx_dept_name   | 123     | &lt;null&gt; | 1      | 100.0    | Using index                               |</span><br><span class="line">+----+-------------+---------------+------------+-------------+-----------------+-----------------+---------+--------+--------+----------+-------------------------------------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.014s</span><br></pre></td></tr></table></figure><ol start="7"><li>range：使用索引扫描条件指定范围内的数据。常用的操作符有 ‘&gt;’、’&lt;’、‘is null’、‘between’、‘in’ 和 ‘like’ 等。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select de.* from dept_emp de,departments_1 d where de.dept_no &#x3D; d.dept_no and de.emp_no &lt; 10010;</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+---------------+---------+--------+------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys   | key           | key_len | ref    | rows | filtered | Extra                                             |</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+---------------+---------+--------+------+----------+----------------------------------------------------+</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | index | PRIMARY         | idx_dept_name | 123     | &lt;null&gt; | 1    | 100.0    | Using index                                       |</span><br><span class="line">| 1  | SIMPLE      | de    | &lt;null&gt;     | range | PRIMARY,dept_no | PRIMARY       | 4       | &lt;null&gt; | 9    |  12.5    | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+---------------+---------+--------+------+----------+----------------------------------------------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.019s</span><br></pre></td></tr></table></figure><ol start="8"><li>index：使用索引全扫描。类似于全表扫描，只是扫描对象是索引，出现于以下两种情况：</li></ol><ul><li><p>如果索引是覆盖索引，即索引包含查询所需要的所有表数据，就只扫描索引，并且在 Extra 中出现 Using index。通常情况下扫描索引比打描表要更快，因为索引一般比表来的小；</p></li><li><p>全表扫描采用索引的顺序来读取数据，本质上还是全表扫描，并且在 Extra 中不会出现 Using index，避免再进行排序消耗性能，因为索引本身就是排序好的。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select dept_name from departments_1;</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">| id | select_type | table         | partitions | type  | possible_keys | key           | key_len | ref    | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | departments_1 | &lt;null&gt;     | index | &lt;null&gt;        | idx_dept_name | 123     | &lt;null&gt; | 1    | 100.0    | Using index |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.020s</span><br></pre></td></tr></table></figure><ol start="9"><li>all：使用全表扫描。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; drop index idx_dept_name on departments_1;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.052s</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; explain select * from departments_1;</span><br><span class="line">+----+-------------+---------------+------------+------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">| id | select_type | table         | partitions | type | possible_keys | key    | key_len | ref    | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+---------------+------------+------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | departments_1 | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+---------------+------------+------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.018s</span><br></pre></td></tr></table></figure><p>通过以上各种主要类型的分析，可以总结出各个类型性能排序(从左到右性能从高到低)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</span><br></pre></td></tr></table></figure><h3 id="possible_keys">possible_keys</h3><p>显示了 MySQL 在查找当前表中数据的时候可能使用到的索引，如果该字段值为 NULL，则表明没有相关索引可用。</p><h3 id="key">key</h3><p>显示了 MySQL 在实际查找数据时决定使用的索引，如果该字段值为 NULL，则表明没有使用索引。</p><h3 id="key_len">key_len</h3><p>显示了 MySQL 实际使用索引的键大小，单位字节。可以通过 key_len 的大小判断评估复合索引使用了哪些部分，如果 key 字段值为 NULL，则 key_len 的值也为 NULL。</p><p>几种常见字段类型索引长度大小如下，假设字符编码为 UTF8：</p><ul><li><p>字段属性是否允许 NULL，如果允许 NULL，则需要额外增加一个字节；</p></li><li><p>字符型：</p><ul><li>char(n)：3n个字节</li><li>varchar(n)：3n+2个字节</li></ul></li><li><p>数值型：</p><ul><li>tinyint：1 个字节</li><li>int：4 个字节</li><li>bigint：8 个字节</li></ul></li><li><p>时间型：</p><ul><li>date：3 个字节</li><li>datetime：5 个字节+秒精度字节</li><li>timestamp：4 个字节+秒精度字节</li><li>秒精度字节(最大 6 位)：<ul><li>1~2位：1 个字节</li><li>3~4位：2 个字节</li><li>5~6位：3 个字节</li></ul></li></ul></li></ul><h3 id="ref">ref</h3><p>显示哪些常量或者字段被用于查询索引列键值，以获取表中数据行。</p><ol><li><p>如果是常量等值查询，则显示为 const；</p></li><li><p>如果是连接查询，则被驱动表的该字段会显示驱动表的所关联字段；</p></li><li><p>如果条件当中使用函数表达式，或者值导致条件字段发生隐式转换，这里显示为 func。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from departments d,departments_1 d1 where d.dept_no &#x3D; d1.dept_no;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+--------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                  | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | d1    | &lt;null&gt;     | ALL    | PRIMARY       | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt;               | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | eq_ref | PRIMARY       | PRIMARY | 12      | employees.d1.dept_no | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+--------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.038s</span><br></pre></td></tr></table></figure><h3 id="rows">rows</h3><p>显示预估需要查询的行数。对 InnoDB 表来说这是个预估值，并非是个准确值。</p><h3 id="filtered">filtered</h3><p>显示按表条件过滤的表行的估计百分比。</p><h3 id="extra">Extra</h3><p>显示查询时的额外信息。常见的有如下几种：</p><ol><li>Using index</li></ol><p>仅查询索引树就可以获取到所需要的数据行，而不需要读取表中实际的数据行。通常适用于 select 字段就是查询使用索引的一部分，即使用了覆盖索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select dept_name from departments_1;</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">| id | select_type | table         | partitions | type  | possible_keys | key           | key_len | ref    | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | departments_1 | &lt;null&gt;     | index | &lt;null&gt;        | idx_dept_name | 123     | &lt;null&gt; | 1    | 100.0    | Using index |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.015s</span><br></pre></td></tr></table></figure><ol start="2"><li>Using index condition</li></ol><p>显示采用了Index Condition Pushdown (ICP) 特性通过索引去表中获取数据。关于ICP特性可以参考官方文档：Index Condition Pushdown Optimization。简单说法如下：</p><ul><li><p>如果开启 ICP 特性，部分 where 条件部分可以下推到存储引擎通过索引进行过滤，ICP 可以减少存储引擎访问基表的次数；</p></li><li><p>如果没有开启 ICP 特性，则存储引擎根据索引需要直接访问基表获取数据并返回给 server 层进行 where 条件的过滤。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- employees表创建复合索引idx_birth_hire</span><br><span class="line">mysql root@localhost:employees&gt; create index idx_birth_hire on employees(birth_date,hire_date);</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.768s</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; explain select * from employees where birth_date &#x3D; &#39;1960-01-01&#39; and hire_date &gt; &#39;1980-01-01&#39;;</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table     | partitions | type  | possible_keys  | key            | key_len | ref    | rows | filtered | Extra                |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+-----------------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | range | idx_birth_hire | idx_birth_hire | 6       | &lt;null&gt; | 63   | 100.0    | Using index condition |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+-----------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.016s</span><br></pre></td></tr></table></figure><ol start="3"><li>Using index for group-by</li></ol><p>跟 Using index 访问表的方式类似，显示 MySQL 通过索引就可以完成对 GROUP BY 或 DISTINCT 字段的查询，而无需再访问表中的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select distinct dept_no from dept_emp;</span><br><span class="line">+----+-------------+----------+------------+-------+-----------------+---------+---------+--------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys   | key     | key_len | ref    | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+----------+------------+-------+-----------------+---------+---------+--------+------+----------+--------------------------+</span><br><span class="line">| 1  | SIMPLE      | dept_emp | &lt;null&gt;     | range | PRIMARY,dept_no | dept_no | 12      | &lt;null&gt; | 9    | 100.0    | Using index for group-by |</span><br><span class="line">+----+-------------+----------+------------+-------+-----------------+---------+---------+--------+------+----------+--------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.020s</span><br></pre></td></tr></table></figure><ol start="4"><li>Using where</li></ol><p>显示 MySQL 通过索引条件定位之后还需要返回表中获得所需要的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees where birth_date &lt; &#39;1970-01-01&#39;;</span><br><span class="line">+----+-------------+-----------+------------+------+----------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys  | key    | key_len | ref    | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+-----------+------------+------+----------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | ALL  | idx_birth_hire | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 299512 | 50.0     | Using where |</span><br><span class="line">+----+-------------+-----------+------------+------+----------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.016s</span><br></pre></td></tr></table></figure><ol start="5"><li>Impossible WHERE</li></ol><p>where 子句的条件永远都不可能为真。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees where 1 &#x3D; 0;</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------+</span><br><span class="line">| id | select_type | table  | partitions | type   | possible_keys | key    | key_len | ref    | rows   | filtered | Extra            |</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------+</span><br><span class="line">| 1  | SIMPLE      | &lt;null&gt; | &lt;null&gt;     | &lt;null&gt; | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | &lt;null&gt; | &lt;null&gt;   | Impossible WHERE |</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.015s</span><br></pre></td></tr></table></figure><ol start="6"><li>Using join buffer (Block Nested Loop), Using join buffer (Batched Key Access)</li></ol><p>在表联接过程当中，将先前表的部分数据读取到 join buffer 缓冲区中，然后从缓冲区中读取数据与当前表进行连接。主要有两种算法：Block Nested Loop和Batched Key Access，关于这两种算法说明可以参考官方文档：Block Nested-Loop and Batched Key Access Joins，也可以参考另一篇博文说明：MySQL 查询优化之 Block Nested-Loop 与 Batched Key Access Joins。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- Block Nested Loop</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from employees e,dept_emp d where e.emp_no &gt; 10001 and e.emp_no &lt;&gt; d.emp_no;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+--------+--------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref    | rows   | filtered | Extra                                             |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+--------+--------+----------+----------------------------------------------------+</span><br><span class="line">| 1  | SIMPLE      | e     | &lt;null&gt;     | range | PRIMARY       | PRIMARY | 4       | &lt;null&gt; | 149756 | 100.0    | Using where                                       |</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | ALL   | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt; | 331143 |  90.0    | Using where; Using join buffer(Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+--------+--------+----------+----------------------------------------------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.020s</span><br><span class="line"></span><br><span class="line">-- Batched Key Access</span><br><span class="line">mysql root@localhost:employees&gt; explain SELECT &#x2F;*+ bka(a)*&#x2F; a.gender, b.dept_no FROM employees a, dept_emp b WHERE a.birth_date &#x3D; b.from_date;</span><br><span class="line">+----+-------------+-------+------------+------+----------------+----------------+---------+-----------------------+--------+----------+----------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys  | key            | key_len | ref                   | rows   | filtered | Extra                                 |</span><br><span class="line">+----+-------------+-------+------------+------+----------------+----------------+---------+-----------------------+--------+----------+----------------------------------------+</span><br><span class="line">| 1  | SIMPLE      | b     | &lt;null&gt;     | ALL  | &lt;null&gt;         | &lt;null&gt;         | &lt;null&gt;  | &lt;null&gt;                | 331143 | 100.0    | &lt;null&gt;                                |</span><br><span class="line">| 1  | SIMPLE      | a     | &lt;null&gt;     | ref  | idx_birth_hire | idx_birth_hire | 3       | employees.b.from_date | 63     | 100.0    | Using join buffer (Batched Key Access) |</span><br><span class="line">+----+-------------+-------+------------+------+----------------+----------------+---------+-----------------------+--------+----------+----------------------------------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.014s</span><br></pre></td></tr></table></figure><ol start="7"><li>Using MRR</li></ol><p>读取数据采用多范围读 (Multi-Range Read) 的优化策略。关于MRR特性也可以参考官方文档：Multi-Range Read Optimization</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; set optimizer_switch&#x3D;&#39;mrr&#x3D;on,mrr_cost_based&#x3D;off&#39;;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.001s</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from employees where birth_date &#x3D; &#39;1970-01-01&#39; and hire_date &gt; &#39;1990-01-01&#39;;</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+----------------------------------+</span><br><span class="line">| id | select_type | table     | partitions | type  | possible_keys  | key            | key_len | ref    | rows | filtered | Extra                           |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+----------------------------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | range | idx_birth_hire | idx_birth_hire | 6       | &lt;null&gt; | 1    | 100.0    | Using index condition; Using MRR |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+----------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.014s</span><br></pre></td></tr></table></figure><ol start="8"><li>Range checked for each record (index map: N)</li></ol><p>MySQL 在获取数据时发现在没有索引可用，但当获取部分先前表字段值时发现可以采用当前表某些索引来获取数据。index map展示的是一个掩码值，如 index map:0x19，对应二进制值为 11001，表示当前表索引编号为 1、4 和 5 号索引可能被用来获取数据，索引编号通过 SHOW INDEX 语句获得。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees e,dept_emp d where e.emp_no &gt; d.emp_no;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+--------+--------+----------+------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key    | key_len | ref    | rows   | filtered | Extra                                         |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+--------+--------+----------+------------------------------------------------+</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | ALL  | PRIMARY       | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 331143 | 100.0    | &lt;null&gt;                                        |</span><br><span class="line">| 1  | SIMPLE      | e     | &lt;null&gt;     | ALL  | PRIMARY       | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 299512 |  33.33   | Range checked for each record (index map: 0x1) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+--------+--------+----------+------------------------------------------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.038s</span><br></pre></td></tr></table></figure><ol start="9"><li>Select tables optimized away</li></ol><p>MySQL 优化器能够确定以下两点：</p><ul><li><p>最多只有一行记录被返回；</p></li><li><p>为了获取这一行数据，有一定的结果集需要获取。</p></li></ul><p>当语句在优化器阶段过程中可以获取查询结果(如获取行数，只需要读取相应索引数据)，而无需再返回表中查询数据，可能会出现 Select tables optimized away。例如针对 MyISAM 引擎的表，使用 select count(*) 获取表的总行数，而且又没有 where 子句或者条件总是为真，也没有 GROUP BY 子句时，其实就包含了以上的条件且隐式含有 GROUP BY 分组的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 创建 MyISAM 引擎的 employees 表</span><br><span class="line">mysql root@localhost:employees&gt; create table employees_myisam like employees;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.040s</span><br><span class="line">mysql root@localhost:employees&gt; insert into employees_myisam select * from employees;</span><br><span class="line">Query OK, 300024 rows affected</span><br><span class="line">Time: 5.023s</span><br><span class="line">mysql root@localhost:employees&gt; alter table employees_myisam engine&#x3D;MyISAM;</span><br><span class="line">Query OK, 300024 rows affected</span><br><span class="line">Time: 1.515s</span><br><span class="line"></span><br><span class="line">-- 获取执行 count(*) 查询行数执行计划</span><br><span class="line">mysql root@localhost:employees&gt; explain select count(*) from employees_myisam;</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------------------+</span><br><span class="line">| id | select_type | table  | partitions | type   | possible_keys | key    | key_len | ref    | rows   | filtered | Extra                        |</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------------------+</span><br><span class="line">| 1  | SIMPLE      | &lt;null&gt; | &lt;null&gt;     | &lt;null&gt; | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | &lt;null&gt; | &lt;null&gt;   | Select tables optimized away |</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.024s</span><br></pre></td></tr></table></figure><ol start="10"><li>Using temporary</li></ol><p>MySQL 需要创建临时表来存放查询结果集。通常发生在有 GROUP BY 或 ORDER BY 子句的语句当中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select hire_date from employees group by hire_date;</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+--------+----------+----------------------------------------------+</span><br><span class="line">| id | select_type | table     | partitions | type  | possible_keys  | key            | key_len | ref    | rows   | filtered | Extra</span><br><span class="line">                          |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+--------+----------+----------------------------------------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | index | idx_birth_hire | idx_birth_hire | 6       | &lt;null&gt; | 299512 | 100.0    | Using index; Using temporary; Using filesort |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+--------+----------+----------------------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.018s</span><br></pre></td></tr></table></figure><ol start="11"><li>Using filesort</li></ol><p>MySQL 需要对获取的数据进行额外的一次排序操作，无法通过索引的排序完成。通常发生在有 ORDER BY 子句的语句当中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees order by hire_date;</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+--------+---------+--------+--------+----------+----------------+</span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key    | key_len | ref    | rows   | filtered | Extra          |</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+--------+---------+--------+--------+----------+----------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 299512 | 100.0    | Using filesort |</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+--------+---------+--------+--------+----------+----------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.015s</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>以上内容总结了 MySQL 获取执行计划 explain 命令执行时输出的主要字段说明，还有许多未仔细说明的参数和选项，以后还需多多实践总结。可以看出 explain 命令输出内容当中比较重要的是：</p><ol><li><p>type：展示了表的查询/连接类型，体现查询效率；</p></li><li><p>key/key_len：实际使用了什么索引，使用了哪些部分索引；</p></li><li><p>Extra：对执行计划步骤额外的说明，采用了哪些查询特性。</p></li></ol><h2 id="参考">参考</h2><ol><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a></p></li><li><p><a href="https://dev.mysql.com/doc/index-other.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/index-other.html</a></p></li><li><p><a href="https://blog.csdn.net/u012410733/article/details/66472157" target="_blank" rel="noopener">https://blog.csdn.net/u012410733/article/details/66472157</a></p></li><li><p><a href="https://blog.csdn.net/wanbin6470398/article/details/82425620" target="_blank" rel="noopener">https://blog.csdn.net/wanbin6470398/article/details/82425620</a></p></li><li><p><a href="https://blog.csdn.net/tianya9704/article/details/80067860" target="_blank" rel="noopener">https://blog.csdn.net/tianya9704/article/details/80067860</a></p></li></ol><blockquote><p>来源：博客园</p><p>原文：<a href="https://tinyurl.com/y26xecs7" target="_blank" rel="noopener">https://tinyurl.com/y26xecs7</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL的 explain 命令语句提供了如何执行 SQL 语句的信息，解析 SQL 语句的执行计划并展示，explain 支持 select、delete、insert、replace 和 update 等语句，也支持对分区表的解析。通常 explain 用来获取 select 语句的执行计划，通过 explain 展示的信息我们可以了解到表查询的顺序，表连接的方式等，并根据这些信息判断 select 执行效率，决定是否添加索引或改写 SQL 语句优化表连接方式以提高执行效率。本文参考官方文档：EXPLAIN Output Format 对 explain 输出的内容进行说明，同时也对自己之前使用 explain 不清晰的方面进行总结。&lt;/p&gt;
&lt;p&gt;本文使用的 MySQL 版本为官方社区版 5.7.24。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql root@localhost:(none)&amp;gt; select version();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| version()  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 5.7.24-log |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 row in set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Time: 0.066s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;主要用法&quot;&gt;主要用法&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; EXPLAIN | DESCRIBE &amp;#125; [EXTENDED | PARTITIONS | FORMAT&amp;#x3D;[TRADITIONAL | JSON]] SQL_STATEMENT;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;EXPLAIN 和 DESCRIBE(可以简写成 DESC)都可以用来查看语句的执行计划，但通常使用 EXPLAIN 较多；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FORMAT 选项可以指定执行计划输出信息为 JSON 格式，而且包含一些更详细的指标说明；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EXTENDED 和 PARTITIONS 选项可以输出更详细选项说明，语法上是为了兼容低版本 MySQL，未来会废弃，默认使用 EXPLAIN 命令即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;测试数据&quot;&gt;测试数据&lt;/h2&gt;
&lt;p&gt;本文基于 MySQL 官方示例数据库 employee：Example Databases 进行解析说明，使用到的表如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- employees：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql root@localhost:employees&amp;gt; show create table employees\G;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************[ 1. row ]***************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Table        | employees&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Create Table | CREATE TABLE &amp;#96;employees&amp;#96; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;emp_no&amp;#96; int(11) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;birth_date&amp;#96; date NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;first_name&amp;#96; varchar(14) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;last_name&amp;#96; varchar(16) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;gender&amp;#96; enum(&amp;#39;M&amp;#39;,&amp;#39;F&amp;#39;) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;hire_date&amp;#96; date NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (&amp;#96;emp_no&amp;#96;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY &amp;#96;idx_first_last&amp;#96; (&amp;#96;first_name&amp;#96;,&amp;#96;last_name&amp;#96;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY &amp;#96;idx_birth_hire&amp;#96; (&amp;#96;birth_date&amp;#96;,&amp;#96;hire_date&amp;#96;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE&amp;#x3D;InnoDB DEFAULT CHARSET&amp;#x3D;utf8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 row in set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Time: 0.008s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-- dept_emp：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql root@localhost:employees&amp;gt; show create table dept_emp\G;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************[ 1. row ]***************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Table        | dept_emp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Create Table | CREATE TABLE &amp;#96;dept_emp&amp;#96; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;emp_no&amp;#96; int(11) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;dept_no&amp;#96; char(4) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;from_date&amp;#96; date NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;to_date&amp;#96; date NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (&amp;#96;emp_no&amp;#96;,&amp;#96;dept_no&amp;#96;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY &amp;#96;dept_no&amp;#96; (&amp;#96;dept_no&amp;#96;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CONSTRAINT &amp;#96;dept_emp_ibfk_1&amp;#96; FOREIGN KEY (&amp;#96;emp_no&amp;#96;) REFERENCES &amp;#96;employees&amp;#96; (&amp;#96;emp_no&amp;#96;) ON DELETE CASCADE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CONSTRAINT &amp;#96;dept_emp_ibfk_2&amp;#96; FOREIGN KEY (&amp;#96;dept_no&amp;#96;) REFERENCES &amp;#96;departments&amp;#96; (&amp;#96;dept_no&amp;#96;) ON DELETE CASCADE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE&amp;#x3D;InnoDB DEFAULT CHARSET&amp;#x3D;utf8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 row in set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Time: 0.010s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-- departments：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql root@localhost:employees&amp;gt; show create table departments\G;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************[ 1. row ]***************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Table        | departments&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Create Table | CREATE TABLE &amp;#96;departments&amp;#96; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;dept_no&amp;#96; char(4) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;dept_name&amp;#96; varchar(40) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (&amp;#96;dept_no&amp;#96;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UNIQUE KEY &amp;#96;dept_name&amp;#96; (&amp;#96;dept_name&amp;#96;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE&amp;#x3D;InnoDB DEFAULT CHARSET&amp;#x3D;utf8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 row in set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Time: 0.012s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://www.hi-linux.com/categories/MySQL/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="MySQL" scheme="https://www.hi-linux.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的回退 Git 误操作</title>
    <link href="https://www.hi-linux.com/posts/2831.html"/>
    <id>https://www.hi-linux.com/posts/2831.html</id>
    <published>2020-05-24T01:02:00.000Z</published>
    <updated>2020-05-24T07:59:40.841Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Git</code> 版本管理时，往往需要撤销某些操作。</p><p>本文介绍几种最主要的情况，给出详细的解释。更多的命令可以参考《<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483821&amp;idx=1&amp;sn=37a2d147d25cea5efc424736bfb01dc8&amp;chksm=eac52084ddb2a9922e1962d30347f2593014dd45de91ba8464539b04a79906b28fa1c450336d&amp;token=630135187&amp;lang=zh_CN#rd" target="_blank" rel="noopener">常用 Git 命令清单</a>》一文。</p><h2 id="一-撤销提交">一、撤销提交</h2><p>一种常见的场景是，提交代码以后，你突然意识到这个提交有问题，应该撤销掉，这时执行下面的命令就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert HEAD</span><br></pre></td></tr></table></figure><p>上面命令的原理是，在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化。它不会改变过去的历史，所以是首选方式，没有任何丢失代码的风险。</p><p><code>git revert</code> 命令只能抵消上一个提交，如果想抵消多个提交，必须在命令行依次指定这些提交。比如，抵消前两个提交，要像下面这样写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert [倒数第一个提交] [倒数第二个提交]</span><br></pre></td></tr></table></figure><p><code>git revert</code> 命令还有两个参数。</p><ul><li><code>--no-edit</code>：执行时不打开默认编辑器，直接使用 <code>Git</code> 自动生成的提交信息。</li><li><code>--no-commit</code>：只抵消暂存区和工作区的文件变化，不产生新的提交。</li></ul><a id="more"></a><h2 id="二-丢弃提交">二、丢弃提交</h2><p>如果希望以前的提交在历史中彻底消失，而不是被抵消掉，可以使用 <code>git reset</code> 命令，丢弃掉某个提交之后的所有提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset [last good SHA]</span><br></pre></td></tr></table></figure><p><code>git reset</code> 的原理是，让最新提交的指针回到以前某个时点，该时点之后的提交都从历史中消失。</p><p>默认情况下，<code>git reset</code> 不改变工作区的文件（但会改变暂存区），<code>--hard</code> 参数可以让工作区里面的文件也回到以前的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard [last good SHA]</span><br></pre></td></tr></table></figure><p>执行 <code>git reset</code> 命令之后，如果想找回那些丢弃掉的提交，可以使用 <code>git reflog</code> 命令，具体做法参考这里。不过，这种做法有时效性，时间长了可能找不回来。</p><h2 id="三-替换上一次提交">三、替换上一次提交</h2><p>提交以后，发现提交信息写错了，这时可以使用 <code>git commit</code> 命令的 <code>--amend</code>  参数，可以修改上一次的提交信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend -m <span class="string">"Fixes bug #42"</span></span><br></pre></td></tr></table></figure><p>它的原理是产生一个新的提交对象，替换掉上一次提交产生的提交对象。</p><p>这时如果暂存区有发生变化的文件，会一起提交到仓库。所以，<code>--amend</code> 不仅可以修改提交信息，还可以整个把上一次提交替换掉。</p><h2 id="四-撤销工作区的文件修改">四、撤销工作区的文件修改</h2><p>如果工作区的某个文件被改乱了，但还没有提交，可以用 <code>git checkout</code> 命令找回本次修改之前的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- [filename]</span><br></pre></td></tr></table></figure><p>它的原理是先找暂存区，如果该文件有暂存的版本，则恢复该版本，否则恢复上一次提交的版本。</p><p>注意，工作区的文件变化一旦被撤销，就无法找回了。</p><h2 id="五-从暂存区撤销文件">五、从暂存区撤销文件</h2><p>如果不小心把一个文件添加到暂存区，可以用下面的命令撤销。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached [filename]</span><br></pre></td></tr></table></figure><p>上面的命令不影响已经提交的内容。</p><h2 id="六-撤销当前分支的变化">六、撤销当前分支的变化</h2><p>你在当前分支上做了几次提交，突然发现放错了分支，这几个提交本应该放到另一个分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个 feature 分支，指向当前最新的提交</span></span><br><span class="line"><span class="comment"># 注意，这时依然停留在当前分支</span></span><br><span class="line">$ git branch feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到这几次提交之前的状态</span></span><br><span class="line">$ git reset --hard [当前分支此前的最后一次提交]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 feature 分支</span></span><br><span class="line">$ git checkout feature</span><br></pre></td></tr></table></figure><p>上面的操作等于是撤销当前分支的变化，将这些变化放到一个新建的分支。</p><blockquote><p>本文转载自：「阮一峰的网络日志」，原文：<a href="https://url.cn/5NLK2pC%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5NLK2pC，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Git&lt;/code&gt; 版本管理时，往往需要撤销某些操作。&lt;/p&gt;
&lt;p&gt;本文介绍几种最主要的情况，给出详细的解释。更多的命令可以参考《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247483821&amp;amp;idx=1&amp;amp;sn=37a2d147d25cea5efc424736bfb01dc8&amp;amp;chksm=eac52084ddb2a9922e1962d30347f2593014dd45de91ba8464539b04a79906b28fa1c450336d&amp;amp;token=630135187&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;常用 Git 命令清单&lt;/a&gt;》一文。&lt;/p&gt;
&lt;h2 id=&quot;一、撤销提交&quot;&gt;一、撤销提交&lt;/h2&gt;
&lt;p&gt;一种常见的场景是，提交代码以后，你突然意识到这个提交有问题，应该撤销掉，这时执行下面的命令就可以了。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git revert HEAD&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令的原理是，在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化。它不会改变过去的历史，所以是首选方式，没有任何丢失代码的风险。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git revert&lt;/code&gt; 命令只能抵消上一个提交，如果想抵消多个提交，必须在命令行依次指定这些提交。比如，抵消前两个提交，要像下面这样写。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git revert [倒数第一个提交] [倒数第二个提交]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;git revert&lt;/code&gt; 命令还有两个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--no-edit&lt;/code&gt;：执行时不打开默认编辑器，直接使用 &lt;code&gt;Git&lt;/code&gt; 自动生成的提交信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-commit&lt;/code&gt;：只抵消暂存区和工作区的文件变化，不产生新的提交。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Git" scheme="https://www.hi-linux.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核故障调试利器 dmesg 使用指南</title>
    <link href="https://www.hi-linux.com/posts/5619.html"/>
    <id>https://www.hi-linux.com/posts/5619.html</id>
    <published>2020-05-24T01:01:00.000Z</published>
    <updated>2020-05-24T07:59:40.843Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Linux</code> 内核是操作系统的核心，它控制对系统资源（例如： <code>CPU</code>、<code>I/O</code>设备、物理内存和文件系统）的访问。在引导过程中以及系统运行时，内核会将各种消息写入内核环形缓冲区。这些消息包括有关系统操作的各种信息。</p><p>内核环形缓冲区是物理内存的一部分，用于保存内核的日志消息。它具有固定的大小，这意味着一旦缓冲区已满，较旧的日志记录将被覆盖。</p><p><code>dmesg</code> 命令行实用程序用于在 <code>Linux</code> 和其他类似 <code>Unix</code> 的操作系统中打印和控制内核环形缓冲区。对于检查内核启动消息和调试与硬件相关的问题很有用。</p><p>在本教程中，我们将介绍 <code>dmesg</code> 命令的基础。</p><h2 id="使用-dmesg-命令">使用 dmesg 命令</h2><p><code>dmesg</code> 命令的语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg [OPTIONS]</span><br></pre></td></tr></table></figure><p>在不带任何选项的情况下调用时，<code>dmesg</code> 将所有消息从内核环形缓冲区写入标准输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg</span><br></pre></td></tr></table></figure><p>默认情况下，所有用户都可以运行 <code>dmesg</code> 命令。但是，在某些系统上，非 root 用户可能会限制对 <code>dmesg</code>的访问。在这种情况下，调用 dmesg`时您将收到如下错误消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg: <span class="built_in">read</span> kernel buffer failed: Operation not permitted</span><br></pre></td></tr></table></figure><a id="more"></a><p>内核参数 <code>kernel.dmesg_restrict</code> 指定非特权用户是否可以使用 <code>dmesg</code> 查看来自内核日志缓冲区的消息。要删除限制，请将其设置为零：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -w kernel.dmesg_restrict=0</span><br></pre></td></tr></table></figure><p>通常，输出包含很多信息行，因此只能看到输出的最后一部分。要一次查看一页，请将输出通过管道传送到分页实用程序，例如 <code>less</code> 或 <code>more</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg --color=always | less</span><br></pre></td></tr></table></figure><p>其中的 <code>--color=always</code> 参数用于保留彩色输出。</p><p>如果要过滤缓冲区消息，可能使用 <code>grep</code> 。例如，要仅查看与 USB 相关的消息，请键入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg | grep -i usb</span><br></pre></td></tr></table></figure><p>dmesg 从 <code>/proc/kmsg</code> 虚拟文件中读取内核生成的消息。该文件提供了到内核环形缓冲区的接口，并且只能由一个进程打开。如果系统上正在运行 <code>syslog</code> 进程，并且你尝试使用 <code>cat</code> 或 <code>less</code> 命令读取文件，则命令将挂起。</p><p><code>syslog</code> 守护程序将内核消息转储到 <code>/var/log/dmesg</code>，因此你也可以使用该日志文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/<span class="built_in">log</span>/dmesg</span><br></pre></td></tr></table></figure><h2 id="格式化-dmesg-输出">格式化 dmesg 输出</h2><p><code>dmesg</code> 命令提供了许多选项，可帮助你格式化和过滤输出。</p><p><code>dmesg</code> 中最常用的选项之一是 <code>-H（--human）</code>，它将输出更容易读的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg -H</span><br></pre></td></tr></table></figure><p>要打印人类可读的时间戳，请使用 <code>-T（--ctime</code> 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg -T</span><br><span class="line"></span><br><span class="line">[Mon Oct 14 14:38:04 2019] IPv6: ADDRCONF(NETDEV_CHANGE): wlp1s0: link becomes ready</span><br></pre></td></tr></table></figure><p>时间戳格式也可以使用 <code>--time-format &lt;format&gt;</code> 选项设置，可以是 <code>ctime</code>，<code>reltime</code>，<code>delta</code>，<code>notime</code>或 <code>iso</code>。例如：要使用增量格式，你可以输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg --time-format=delta</span><br></pre></td></tr></table></figure><p>你也可以组合两个或多个选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg -H -T</span><br></pre></td></tr></table></figure><p>要实时观看 <code>dmesg</code> 命令的输出，请使用 <code>-w（--follow）</code>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg --follow</span><br></pre></td></tr></table></figure><h2 id="过滤-dmesg-输出">过滤 dmesg 输出</h2><p>你可以将 <code>dmesg</code> 输出限制为给定的设施和等级。<code>dmesg</code> 支持以下类型：</p><ul><li><p>kern-内核消息</p></li><li><p>user-用户级消息</p></li><li><p>mail-邮件系统</p></li><li><p>daemon-系统守护程序</p></li><li><p>auth-安全/授权消息</p></li><li><p>syslog-内部 syslogd 消息</p></li><li><p>lpr-行式打印机子系统</p></li><li><p>news-网络新闻子系统</p></li></ul><p><code>-f（--facility &lt;list&gt;）</code> 选项允许你将输出限制为特定的设备，该选项接受一个或多个逗号分隔的功能。</p><p>例如，要仅显示内核和系统守护程序消息，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg -f kern,daemon</span><br></pre></td></tr></table></figure><p>每条日志消息都与一个显示消息重要性的日志级别相关联，<code>dmesg</code> 支持以下日志级别：</p><ul><li><p>emerg-系统无法使用</p></li><li><p>alert-必须立即采取措施</p></li><li><p>crit-紧急情况</p></li><li><p>err-错误条件</p></li><li><p>warn-警告条件</p></li><li><p>notice-正常但重要的条件</p></li><li><p>info-信息性</p></li><li><p>debug-调试级消息</p></li></ul><p><code>-l（--level &lt;list&gt;）</code>选项允许你将输出限制为定义的级别，该选项接受一个或多个逗号分隔的级别。以下命令仅显示错误和严重消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg -l err,crit</span><br></pre></td></tr></table></figure><h2 id="清除环形缓冲区">清除环形缓冲区</h2><p><code>-C（--clear）</code> 选项可让您清除环形缓冲区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dmesg -C</span><br></pre></td></tr></table></figure><p>只有 <code>root</code> 或具有 <code>sudo</code> 特权的用户才能清除缓冲区。</p><p>要在清除之前打印缓冲区内容，请使用 <code>-c（--read-clear）</code>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dmesg -c</span><br></pre></td></tr></table></figure><p>如果要在清除文件之前将当前 <code>dmesg</code> 日志保存到文件中，你可以将输出重定向到文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg &gt; dmesg_messages</span><br></pre></td></tr></table></figure><h2 id="结论">结论</h2><p><code>dmesg</code> 命令允许你查看和控制内核环形缓冲区。对内核或硬件问题进行故障排除时，它非常有用。</p><p>在终端中输入 <code>man dmesg</code>，你可以获取有关所有可用 <code>dmesg</code> 选项的信息。</p><blockquote><p>来源：myfreax</p><p>原文：<a href="https://url.cn/5Fn5kFm" target="_blank" rel="noopener">https://url.cn/5Fn5kFm</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 内核是操作系统的核心，它控制对系统资源（例如： &lt;code&gt;CPU&lt;/code&gt;、&lt;code&gt;I/O&lt;/code&gt;设备、物理内存和文件系统）的访问。在引导过程中以及系统运行时，内核会将各种消息写入内核环形缓冲区。这些消息包括有关系统操作的各种信息。&lt;/p&gt;
&lt;p&gt;内核环形缓冲区是物理内存的一部分，用于保存内核的日志消息。它具有固定的大小，这意味着一旦缓冲区已满，较旧的日志记录将被覆盖。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dmesg&lt;/code&gt; 命令行实用程序用于在 &lt;code&gt;Linux&lt;/code&gt; 和其他类似 &lt;code&gt;Unix&lt;/code&gt; 的操作系统中打印和控制内核环形缓冲区。对于检查内核启动消息和调试与硬件相关的问题很有用。&lt;/p&gt;
&lt;p&gt;在本教程中，我们将介绍 &lt;code&gt;dmesg&lt;/code&gt; 命令的基础。&lt;/p&gt;
&lt;h2 id=&quot;使用-dmesg-命令&quot;&gt;使用 dmesg 命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dmesg&lt;/code&gt; 命令的语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dmesg [OPTIONS]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在不带任何选项的情况下调用时，&lt;code&gt;dmesg&lt;/code&gt; 将所有消息从内核环形缓冲区写入标准输出：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ dmesg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认情况下，所有用户都可以运行 &lt;code&gt;dmesg&lt;/code&gt; 命令。但是，在某些系统上，非 root 用户可能会限制对 &lt;code&gt;dmesg&lt;/code&gt;的访问。在这种情况下，调用 dmesg`时您将收到如下错误消息：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dmesg: &lt;span class=&quot;built_in&quot;&gt;read&lt;/span&gt; kernel buffer failed: Operation not permitted&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="dmesg" scheme="https://www.hi-linux.com/tags/dmesg/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款全平台目录结构分析神器 folder-explorer</title>
    <link href="https://www.hi-linux.com/posts/41860.html"/>
    <id>https://www.hi-linux.com/posts/41860.html</id>
    <published>2020-05-24T01:00:00.000Z</published>
    <updated>2020-05-24T07:59:40.846Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>对于一个比较复杂的项目来说，我们经常需要在项目文档中对其结构和重要的文件进行介绍。而要形像生动的介绍清楚项目中所有内容，无疑是用一张漂亮的目录结构图。</p><p><img src="https://qiniucdn.fairyever.com/20190926165513.png" alt=""></p><p>通常一个目录结构图的制作需要以下几个步骤：</p><ol><li><p>扫描目录</p></li><li><p>编辑注释</p></li><li><p>隐藏希望忽略的文件</p></li><li><p>生成美观的结构图</p></li></ol><p>今天我们就给大家介绍一款可以自动扫描目录、分析文件结构和生成统计信息的利器 Folder-Explorer。 Folder-Explorer 不仅能自动分析目录和文件，还能给任意文件添加备注和导出多种格式的树形目录结构图，大大方便了项目技术文档的编写。</p><blockquote><p>项目地址：<a href="https://github.com/d2-projects/folder-explorer" target="_blank" rel="noopener">https://github.com/d2-projects/folder-explorer</a></p></blockquote><a id="more"></a><h2 id="folder-explorer-功能介绍">Folder-Explorer 功能介绍</h2><p><img src="https://qiniucdn.fairyever.com/20190926165542.png" alt=""></p><ul><li><p>支持扫描指定的目录（支持拖拽）以及再次扫描当前结果中的指定目录</p></li><li><p>展示文件结构的树形统计，</p></li><li><p>支持给文件添加注释</p></li><li><p>支持隐藏单个文件或者文件夹内容</p></li><li><p>支持文件类型统计</p></li><li><p>支持文件体积分布统计</p></li><li><p>支持导出文字构成的树形结构图，支持注释和自动对齐，支持自定义内容格式</p></li><li><p>支持导出 JSON 文件和 XML 文件供其他软件或者程序使用</p></li><li><p>支持导出 Xmind 结构图，支持自定义节点、Label 和注释的内容格式化</p></li><li><p>支持自定义导出文件的名称预设</p></li><li><p>支持注释信息记忆功能</p></li><li><p>支持个性化设置的备份和导入</p></li><li><p>更多其它丰富的设置选项</p></li></ul><h2 id="folder-explorer-常见使用场景">Folder-Explorer 常见使用场景</h2><ul><li><p>项目文档书写，附上文件结构和注释可以更清晰地让别人上手项目</p></li><li><p>展示课程目录，如果你是讲师，可以一口气将你的课程所有章节生成树形结构展示</p></li><li><p>统计某个资源文件夹中的文件大小分布，例如分析你的照片文件夹，或者一目了然磁盘里每部电影占了多大空间</p></li></ul><h2 id="安装-folder-explorer">安装 Folder-Explorer</h2><p>Folder-Explorer 的安装非常简单，主流平台 (macOS、Windows、Linux) 都支持了，开箱即用。你只需到项目官方地址的 Releases 页面下载即可。</p><h2 id="folder-explorer-详细功能介绍">Folder-Explorer 详细功能介绍</h2><p>以下所有演示，都将基于下述的目录结构进行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">├─.DS_Store </span><br><span class="line">├─.browserslistrc </span><br><span class="line">├─.gitignore </span><br><span class="line">├─README.md </span><br><span class="line">├─babel.config.js </span><br><span class="line">├─package.json </span><br><span class="line">├─postcss.config.js </span><br><span class="line">├─public </span><br><span class="line">│ ├─favicon.ico </span><br><span class="line">│ └─index.html </span><br><span class="line">├─src </span><br><span class="line">│ ├─App.vue </span><br><span class="line">│ ├─assets </span><br><span class="line">│ │ └─sys </span><br><span class="line">│ │   └─logo </span><br><span class="line">│ │     └─w200.png </span><br><span class="line">│ ├─components </span><br><span class="line">│ │ └─HelloWorld.vue </span><br><span class="line">│ ├─layout </span><br><span class="line">│ │ └─headerAside </span><br><span class="line">│ │   ├─components </span><br><span class="line">│ │   │ ├─aside </span><br><span class="line">│ │   │ │ ├─index.vue </span><br><span class="line">│ │   │ │ └─style.scss </span><br><span class="line">│ │   │ └─header </span><br><span class="line">│ │   │   ├─index.vue </span><br><span class="line">│ │   │   └─style.scss </span><br><span class="line">│ │   └─index.vue </span><br><span class="line">│ └─main.js </span><br><span class="line">└─yarn.lock</span><br></pre></td></tr></table></figure><h3 id="folder-explorer-编辑器中的日常操作演示">Folder-Explorer 编辑器中的日常操作演示</h3><ol><li>展开和折叠节点</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926165558.gif" alt=""></p><ol start="2"><li>移除节点</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926165703.gif" alt=""></p><ol start="3"><li>给文件或者目录添加注释</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926165924.gif" alt=""></p><p>添加注释后的导出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">├─README.md --------------- // 介绍</span><br><span class="line">├─babel.config.js </span><br><span class="line">├─package.json </span><br><span class="line">├─postcss.config.js </span><br><span class="line">├─public ------------------ // 公共资源</span><br><span class="line">│ ├─favicon.ico </span><br><span class="line">│ └─index.html </span><br><span class="line">├─src </span><br><span class="line">│ ├─App.vue --------------- // 根组件</span><br><span class="line">│ ├─assets </span><br><span class="line">│ │ └─sys </span><br><span class="line">│ │   └─logo </span><br><span class="line">│ │     └─w200.png </span><br><span class="line">│ ├─components </span><br><span class="line">│ │ └─HelloWorld.vue </span><br><span class="line">│ ├─layout </span><br><span class="line">│ │ └─headerAside </span><br><span class="line">│ │   ├─components </span><br><span class="line">│ │   │ ├─aside </span><br><span class="line">│ │   │ │ ├─index.vue </span><br><span class="line">│ │   │ │ └─style.scss </span><br><span class="line">│ │   │ └─header </span><br><span class="line">│ │   │   ├─index.vue </span><br><span class="line">│ │   │   └─style.scss </span><br><span class="line">│ │   └─index.vue </span><br><span class="line">│ └─main.js </span><br><span class="line">└─yarn.lock</span><br></pre></td></tr></table></figure><blockquote><ol><li>从上面的导出结果我们可以看到，并不会导出被折叠和隐藏的文件或目录，并且会根据折叠之后的状态重新计算树形结构。</li></ol></blockquote><blockquote><ol start="2"><li>备注有记忆功能，例如扫描 <code>/a</code> 目录后添加了注释，之后扫描了 <code>/b</code> 目录，当再次扫描 <code>/a</code> 目录后第一次添加的注释会自动还原。</li></ol></blockquote><ol start="4"><li>直接在 Folder-Explorer 中打开文件</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926170049.gif" alt=""></p><ol start="5"><li>直接在 Folder-Explorer 中打开目录</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926170058.gif" alt=""></p><ol start="6"><li>扫描子文件夹</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926170246.gif" alt=""></p><h3 id="在-folder-explorer-中进行统计">在 Folder-Explorer 中进行统计</h3><ol><li>文件类型统计</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926170302.png" alt=""></p><ol start="2"><li>文件大小统计</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926170319.png" alt=""></p><h3 id="将目录结果进行导出">将目录结果进行导出</h3><p><img src="https://qiniucdn.fairyever.com/20190926170332.png" alt=""></p><p>目前支持以下导出方式：</p><ol><li>文本</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113304.png" alt=""></p><ol start="2"><li>JSON</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113313.png" alt=""></p><ol start="3"><li>Xmind</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113337.png" alt=""></p><ol start="4"><li>XML</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113352.png" alt=""></p><ol start="5"><li>HTML</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113402.png" alt=""></p><h3 id="更多个性化设置">更多个性化设置</h3><ol><li>自定义扫描</li></ol><p>支持自定义扫描忽略的文件夹和文件，并可以指定忽略的文件类型。</p><p><img src="https://qiniucdn.fairyever.com/20190927113631.png" alt=""></p><p>为方便快速设置，选项会自动根据当前的扫描结果改变。</p><p><img src="https://qiniucdn.fairyever.com/20190927113643.png" alt=""></p><p><img src="https://qiniucdn.fairyever.com/20190927113653.png" alt=""></p><ol start="2"><li>自定义扫描深度</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113703.png" alt=""></p><p><img src="https://qiniucdn.fairyever.com/20190927113709.png" alt=""></p><ol start="3"><li>只扫描文件夹</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927142016.png" alt=""></p><ol start="4"><li>忽略隐藏文件</li></ol><p>支持设置忽略 <code>.</code> 开头的文件，因为这些文件在 macOS 和 Linux 上是隐藏的</p><p><img src="https://qiniucdn.fairyever.com/20190927113718.png" alt=""></p><ol start="5"><li>预设文件名</li></ol><p>几乎所有的导出都支持自定义文件名，并支持多种占位符，请注意输入框右上角的提示：</p><p><img src="https://qiniucdn.fairyever.com/20190927113740.png" alt=""></p><p>点击提示之后会弹出这个位置所有可用的占位符，点击占位符可以快速复制到剪贴板：</p><p><img src="https://qiniucdn.fairyever.com/20190927113747.png" alt=""></p><p>占位符示例：</p><p><img src="https://qiniucdn.fairyever.com/20190927113752.png" alt=""></p><blockquote><p>注：在一些其它的设置位置也支持占位符，例如：设置备注的格式化，脑图的节点内容等。</p></blockquote><p>至此，这款好用的项目结构分析工具就介绍完了。如果你也有些需求，就赶紧的用起来吧！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个比较复杂的项目来说，我们经常需要在项目文档中对其结构和重要的文件进行介绍。而要形像生动的介绍清楚项目中所有内容，无疑是用一张漂亮的目录结构图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiniucdn.fairyever.com/20190926165513.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;通常一个目录结构图的制作需要以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;扫描目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐藏希望忽略的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成美观的结构图&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天我们就给大家介绍一款可以自动扫描目录、分析文件结构和生成统计信息的利器 Folder-Explorer。 Folder-Explorer 不仅能自动分析目录和文件，还能给任意文件添加备注和导出多种格式的树形目录结构图，大大方便了项目技术文档的编写。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/d2-projects/folder-explorer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/d2-projects/folder-explorer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>浅谈集群、分布式、微服务的异同</title>
    <link href="https://www.hi-linux.com/posts/52526.html"/>
    <id>https://www.hi-linux.com/posts/52526.html</id>
    <published>2020-05-23T02:27:00.000Z</published>
    <updated>2020-05-23T15:29:29.321Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="什么是集群">什么是集群</h3><p>集群是是指将多台服务器集中在一起，每台服务器都实现相同的业务，做相同的事情。但是每台服务器并不是缺一不可，存在的作用主要是缓解并发压力和单点故障转移问题。可以利用一些廉价的符合工业标准的硬件构造高扩展、高性能、低成本、高可用的系统。</p><p>集群主要具有以下特性：</p><ul><li>伸缩性（Scalability）</li></ul><p>在一些大的系统中，预测最终用户的数量和行为是非常困难的，伸缩性是指系统适应不断增长的用户数的能力。提高这种并发会话能力的一种最直观的方式就增加资源（CPU，内存，硬盘等），集群是解决这个问题的另一种方式，它允许一组服务器组在一起，像单个服务器一样分担处理一个繁重的任务，我们只需要将新的服务器加入集群中即可，对于客户来看，服务无论从连续性还是性能上都几乎没有变化，好像系统在不知不觉中完成了升级。</p><ul><li>高可用性（High availability）</li></ul><p>单一服务器的解决方案并不是一个健壮方式，因为容易出现单点失效。像银行、账单处理这样一些关键的应用程序是不能容忍哪怕是几分钟的死机。它们需要这样一些服务在任何时间都可以访问并在可预期的合理的时间周期内有响应。高可用性集群的出现是为了使集群的整体服务尽可能可用，以便考虑计算硬件和软件的易错性。如果高可用性集群中的主节点发生了故障，那么这段时间内将由次节点代替它。次节点通常是主节点的镜像，所以当它代替主节点时，它可以完全接管其身份，并且因此使系统环境对于用户是一致的。</p><ul><li>负载均衡（Load balancing）</li></ul><p>负载均衡集群为企业需求提供了更实用的系统。如名称所暗示的，该系统使负载可以在计算机集群中尽可能平均地分摊处理。该负载可能是需要均衡的应用程序处理负载或网络流量负载。这样的系统非常适合于运行同一组应用程序的大量用户。每个节点都可以处理一部分负载，并且可以在节点之间动态分配负载，以实现平衡。</p><ul><li>高性能 (High Performance)</li></ul><p>通常，这种涉及为集群开发并行编程应用程序，以解决复杂的科学问题。这是并行计算的基础，尽管它不使用专门的并行超级计算机，这种超级计算机内部由十至上万个独立处理器组成。但它却使用商业系统，如通过高速连接来链接的一组单处理器或双处理器 PC，并且在公共消息传递层上进行通信以运行并行应用程序。因此，您会常常听说又有一种便宜的 Linux 超级计算机问世了。但它实际是一个计算机集群，其处理能力与真的超级计算机相等。</p><a id="more"></a><h3 id="什么是分布式">什么是分布式</h3><p>分布式服务顾名思义服务是分散部署在不同的机器上的，一个服务可能负责几个功能，是一种面向 SOA 架构的，服务之间也是通过 RPC 来交互或者是 Webservice 来交互的。</p><p>分布式部署是指将多台服务器集中在一起，每台服务器都实现总体中的不同业务，做不同的事情。各分开部署的部分彼此通过各种通讯协议交互信息，并且每台服务器都缺一不可，如果某台服务器故障，则部分功能缺失，或导致整体无法运行。</p><p>分布式存在的主要作用是大幅度的提高效率，缓解服务器的访问和存储压力。区别分布式的方式是一个业务分拆多个子业务，部署在不同的服务器上。</p><p>例如：将一个大的系统划分为多个业务模块，业务模块分别部署到不同的机器上，各个业务模块之间通过接口进行数据交互。</p><p><img src="https://img-blog.csdn.net/20170213134043567" alt=""></p><p>上面：service A、B、C、D 分别是业务组件，通过 API Geteway 进行业务访问。</p><h3 id="什么是微服务">什么是微服务</h3><p>微服务的概念和分布式比较相似，微服务是一种架构风格。简单来说微服务就是很小的服务，小到一个服务只对应一个单一的功能。每个微服务仅关注于完成一件任务并很好地完成该任务，这个服务可以单独部署运行。 各个微服务之间是松耦合的，服务之间可以通过 RPC 来相互交互。每个微服务都是由独立的小团队开发、测试、部署，上线，负责它的整个生命周期。</p><p>在做架构设计的时候，先做逻辑架构，再做物理架构。当你拿到需求后，估算过最大用户量和并发量后，计算单个应用服务器能否满足需求，如果用户量只有几百人的小应用，单体应用就能搞定，即所有应用部署在一个应用服务器里。如果是很大用户量，且某些功能会被频繁访问，或者某些功能计算量很大，建议将应用拆解为多个子系统，各自负责各自功能，这就是微服务架构。</p><p>微服务的设计是为了不因为某个模块的升级和 BUG 影响现有的系统业务。微服务与分布式的细微差别是，微服务的应用不一定是分散在多个服务器上，它也可以是同一个服务器。</p><p>微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低。由于每个微服务都由独立的小团队负责，因此它敏捷性更高。分布式服务最后都会向微服务架构演化，这是一种趋势。不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难。</p><h3 id="分布式-集群-微服务的异同及联系">分布式、集群、微服务的异同及联系</h3><ol><li>分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。</li></ol><p>例如：如果一个任务由 10 个子任务组成，每个子任务单独执行需 1 小时，则在一台服务器上执行该任务需 10 小时。</p><ul><li><p>采用分布式方案，提供 10 台服务器，每台服务器只负责处理一个子任务，不考虑子任务间的依赖关系，执行完这个任务只需一个小时。(这种工作模式的一个典型代表就是 Hadoop 的 Map/Reduce 分布式计算模型）</p></li><li><p>而采用集群方案，同样提供 10 台服务器，每台服务器都能独立处理这个任务。假设有 10 个任务同时到达，10 个服务器将同时工作，1 小时后，10 个任务同时完成，这样，整身来看，还是 1 小时内完成一个任务。</p></li></ul><blockquote><p>注：分布式需要做好事务管理。</p></blockquote><ol start="2"><li>集群模式是不同服务器部署同一套服务对外访问，实现服务的负载均衡。区别集群的方式是根据部署多台服务器业务是否相同，分布式中的每一个节点，都可以做集群。而集群并不一定就是分布式的。</li></ol><p>举例：就比如新浪网，访问的人多了，他可以做一个群集，前面放一个响应服务器，后面几台服务器完成同一业务，如果有业务访问的时候，响应服务器看哪台服务器的负载不是很重，就将给哪一台去完成。</p><p>而分布式，从窄意上理解，也跟集群差不多。但是它的组织比较松散，不像集群有一个组织性，一台服务器垮了，其它的服务器可以顶上来。分布式的每一个节点，都完成不同的业务，一个节点垮了，那这个业务就不可访问了。</p><blockquote><p>注：集群模式需要做好 Session 共享，确保在不同服务器切换的过程中不会因为没有获取到 Session 而中止退出服务。</p></blockquote><ul><li>分布式是否属于微服务？</li></ul><p>答案是肯定的。分布式和微服务的架构很相似，只是部署的方式不一样而已。</p><p>生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。</p><ul><li>在开发中我们可以将分布式和集群分开吗？</li></ul><p>针对这个问题，我们可以根据分布式的介绍看出，其主要的功能是用了将我们的系统模块化，将系统进行解耦的，方便我们的维护和开发的，但是其并不能解决我们的并发问题，也无法保证我们的系统在服务器宕机后的正常运转。</p><p>而集群呢？其恰好弥补了分布式的缺陷。集群，就是多个服务器处理相同的业务，这在一方面可以解决或者说改善我们系统的并发问题，一方面可以解决我们服务器如果出现一定数量的宕机后，系统仍然可以正常运转。</p><p>好的设计应该是分布式和集群的结合，先分布式再集群，具体实现就是业务拆分成很多子业务，然后针对每个子业务进行集群部署，这样每个子业务如果出了问题，整个系统完全不会受影响。</p><p>因此分布式和集群是一对好基友，谁也离不开谁。</p><h3 id="参考文档">参考文档</h3><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="http://t.cn/E9VjXwt" target="_blank" rel="noopener">http://t.cn/E9VjXwt</a></li><li><a href="http://t.cn/E9VRNNh" target="_blank" rel="noopener">http://t.cn/E9VRNNh</a></li><li><a href="http://t.cn/E9VeGiu" target="_blank" rel="noopener">http://t.cn/E9VeGiu</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是集群&quot;&gt;什么是集群&lt;/h3&gt;
&lt;p&gt;集群是是指将多台服务器集中在一起，每台服务器都实现相同的业务，做相同的事情。但是每台服务器并不是缺一不可，存在的作用主要是缓解并发压力和单点故障转移问题。可以利用一些廉价的符合工业标准的硬件构造高扩展、高性能、低成本、高可用的系统。&lt;/p&gt;
&lt;p&gt;集群主要具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伸缩性（Scalability）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一些大的系统中，预测最终用户的数量和行为是非常困难的，伸缩性是指系统适应不断增长的用户数的能力。提高这种并发会话能力的一种最直观的方式就增加资源（CPU，内存，硬盘等），集群是解决这个问题的另一种方式，它允许一组服务器组在一起，像单个服务器一样分担处理一个繁重的任务，我们只需要将新的服务器加入集群中即可，对于客户来看，服务无论从连续性还是性能上都几乎没有变化，好像系统在不知不觉中完成了升级。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高可用性（High availability）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;单一服务器的解决方案并不是一个健壮方式，因为容易出现单点失效。像银行、账单处理这样一些关键的应用程序是不能容忍哪怕是几分钟的死机。它们需要这样一些服务在任何时间都可以访问并在可预期的合理的时间周期内有响应。高可用性集群的出现是为了使集群的整体服务尽可能可用，以便考虑计算硬件和软件的易错性。如果高可用性集群中的主节点发生了故障，那么这段时间内将由次节点代替它。次节点通常是主节点的镜像，所以当它代替主节点时，它可以完全接管其身份，并且因此使系统环境对于用户是一致的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡（Load balancing）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;负载均衡集群为企业需求提供了更实用的系统。如名称所暗示的，该系统使负载可以在计算机集群中尽可能平均地分摊处理。该负载可能是需要均衡的应用程序处理负载或网络流量负载。这样的系统非常适合于运行同一组应用程序的大量用户。每个节点都可以处理一部分负载，并且可以在节点之间动态分配负载，以实现平衡。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高性能 (High Performance)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，这种涉及为集群开发并行编程应用程序，以解决复杂的科学问题。这是并行计算的基础，尽管它不使用专门的并行超级计算机，这种超级计算机内部由十至上万个独立处理器组成。但它却使用商业系统，如通过高速连接来链接的一组单处理器或双处理器 PC，并且在公共消息传递层上进行通信以运行并行应用程序。因此，您会常常听说又有一种便宜的 Linux 超级计算机问世了。但它实际是一个计算机集群，其处理能力与真的超级计算机相等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="分布式" scheme="https://www.hi-linux.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用 Sysdig 进行监控和调试 Linux 机器</title>
    <link href="https://www.hi-linux.com/posts/9561.html"/>
    <id>https://www.hi-linux.com/posts/9561.html</id>
    <published>2020-05-23T02:26:00.000Z</published>
    <updated>2020-05-23T15:22:46.161Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="sysdig-简介">Sysdig 简介</h3><p><code>Sysdig</code> 官网 上对自己的介绍是：</p><blockquote><p>Open Source Universal System Visibility With Native Contaier Support.</p></blockquote><p>它的定位是系统监控、分析和排障的工具，其实在 <code>Linux</code> 平台上，已经有很多这方面的工具 <code>strace</code>、<code>tcpdump</code>、<code>htop</code>、<code>iftop</code>、<code>lsof</code>、<code>netstat</code>，它们都能用来分析 <code>Linux</code> 系统的运行情况，而且还有很多日志、监控工具。为什么还需要 <code>Sysdig</code> 呢？在我看来，<code>Sysdig</code> 的优点可以归纳为三个词语：整合、强大、灵活。</p><h4 id="整合">整合</h4><p>虽然 <code>Linux</code> 有很多系统分析和调优的工具，但是它们一般都负责某个特殊的功能，并且使用方式有很大的差异，如果要分析和定位问题，一般都需要熟练掌握需要命令的使用。而且这些工具的数据无法进行共享，只能相互独立工作。<code>Sysdig</code> 一个工具就能实现上述所有工具的功能，并且提供了统一的使用语法。</p><h4 id="强大">强大</h4><p><code>Sysdig</code> 能获取实时的系统数据，也能把信息保存到文件中以供后面分析。捕获的数据包含系统的个个方面：</p><ul><li>全方面的系统参数：CPU、Memory、Disk IO、网络 IO</li><li>支持各种 IO 活动：进程、文件、网络连接等</li></ul><p>除了帮你捕获信息之外，<code>Sysdig</code> 还预先还有有用的工具来分析这些数据，从大量的数据中找到有用的信息变得非常简单。比如你能还简单地做到下面这些事情：</p><ul><li>按照 CPU 的使用率对进程进行排序，找到 CPU 使用率最高的那个</li><li>按照发送网络数据报文的多少对进程进行排序</li><li>找到打开最多文件描述符的进程</li><li>查看哪些进程修改了指定的文件</li><li>打印出某个进程的 HTTP 请求报文</li><li>找到用时最久的系统调用</li><li>查看系统中所有的用户都执行了哪些命令</li><li>……</li></ul><p>基本上自带的工具就能满足大部分的分析需求。</p><a id="more"></a><h4 id="灵活">灵活</h4><p><code>Sysdig</code> 有着类似于 <code>tcpdump</code> 的过滤语法，用户可以随意组合自己的过滤逻辑，从茫茫的数据中找到关心的信息。除此之外，用户还可以自己编写 <code>Lua</code> 脚本来自定义分析逻辑，基本上不受任何限制。</p><h4 id="工作原理">工作原理</h4><p><code>Sysdig</code> 通过在内核的 driver 模块注册系统调用的 hook，这样当有系统调用发生和完成的时候，它会把系统调用信息拷贝到特定的 buffer，然后用户模块的组件对数据信息处理（解压、解析、过滤等），并最终通过 <code>Sysdig</code> 命令行和用户进行交互。</p><p><img src="https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/2014/04/Blog2-pic3-1024x886.png" alt=""></p><p>更多的原理可以参考官方博客</p><p>除了 <code>Sysdig</code> 命令之外，还有一个基于终端的 UI 命令 <code>Csysdig</code>，它类似于 <code>top</code> 命令，定时对系统情况进行刷新，并且可以让用户交互。这篇文章我们只介绍 <code>Sysdig</code>，不会讲解 <code>Csysdig</code> 的使用。</p><h3 id="安装">安装</h3><p><code>Sysdig</code> 的安装在官方文档中有详细的说明，这里不再赘述。需要注意的是，<code>Sysdig</code> 对内核版本有一定的要求，请保证内核不要太旧。</p><p>另外，如果使用容器的方式安装，需要把主机的很多系统目录 mount 到容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --name sysdig --privileged -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;host&#x2F;var&#x2F;run&#x2F;docker.sock -v &#x2F;dev:&#x2F;host&#x2F;dev -v &#x2F;proc:&#x2F;host&#x2F;proc:ro -v &#x2F;boot:&#x2F;host&#x2F;boot:ro -v &#x2F;lib&#x2F;modules:&#x2F;host&#x2F;lib&#x2F;modules:ro -v &#x2F;usr:&#x2F;host&#x2F;usr:ro sysdig&#x2F;sysdig</span><br></pre></td></tr></table></figure><h3 id="sysdig-基本用法">Sysdig 基本用法</h3><h4 id="基本格式">基本格式</h4><p>直接在终端输入 <code>sysdig</code> 就能开始捕获系统信息，这个命令需要系统管理员权限，执行后你会看到终端有持续不断的输出流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysdig</span><br></pre></td></tr></table></figure><p>因为系统每时每刻都有大量的系统调用产生，这样是没办法看清更无法分析输出信息的，可以先使用 CTRL + c 来退出命令。</p><p>在讲解如何使用 <code>Sysdig</code> 的参数之前，我们先来解释一下它的输出格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5352209 11:54:08.853479695 0 ssh-agent (13314) &lt; getrusage</span><br><span class="line">5352210 11:54:08.853481094 0 ssh-agent (13314) &gt; clock_gettime</span><br><span class="line">5352211 11:54:08.853482049 0 ssh-agent (13314) &lt; clock_gettime</span><br><span class="line">5352226 11:54:08.853510313 0 ssh-agent (13314) &gt; getrusage</span><br><span class="line">5352228 11:54:08.853511089 0 ssh-agent (13314) &lt; getrusage</span><br><span class="line">5352229 11:54:08.853511646 0 ssh-agent (13314) &gt; clock_gettime</span><br><span class="line">5352231 11:54:08.853512020 0 ssh-agent (13314) &lt; clock_gettime</span><br><span class="line">5352240 11:54:08.853530285 0 ssh-agent (13314) &gt; stat</span><br><span class="line">5352241 11:54:08.853532329 0 ssh-agent (13314) &lt; stat res&#x3D;0 path&#x3D;&#x2F;home&#x2F;cizixs&#x2F;.ssh</span><br><span class="line">5352242 11:54:08.853533065 0 ssh-agent (13314) &gt; stat</span><br><span class="line">5352243 11:54:08.853533990 0 ssh-agent (13314) &lt; stat res&#x3D;0 path&#x3D;&#x2F;home&#x2F;cizixs&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line">5353954 11:54:08.857382204 0 ssh-agent (13314) &gt; write fd&#x3D;16 size&#x3D;280</span><br></pre></td></tr></table></figure><p>所有的输入都是按照行来分割的，每行都是一条记录，由多个列组成，默认的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%evt.num %evt.outputtime %evt.cpu %proc.name (%thread.tid) %evt.dir %evt.type %evt.info</span><br></pre></td></tr></table></figure><p>各个字段的含义如下：</p><ul><li>evt.num： 递增的事件号。</li><li>evt.time： 事件发生的时间。</li><li>evt.cpu： 事件被捕获时所在的 CPU，也就是系统调用是在哪个 CPU 执行的。比较上面的例子中，值 0 代表机器的第一个 CPU。</li><li><a href="http://proc.name" target="_blank" rel="noopener">proc.name</a>： 生成事件的进程名字，也就是哪个进程在运行。</li><li>thread.tid： 线程的 id，如果是单线程的程序，这也是进程的 pid。</li><li>evt.dir： 事件的方向（direction），&gt; 代表进入事件，&lt; 代表退出事件。</li><li>evt.type： 事件的名称，比如 open、stat等，一般是系统调用。</li><li>evt.args： 事件的参数。如果是系统调用，这些对应着系统调用的参数。</li></ul><h4 id="过滤">过滤</h4><p>完整的 <code>Sysdig</code> 使用方法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysdig [option]...  [filter]</span><br></pre></td></tr></table></figure><p>因为 <code>Sysdig</code> 的输出内容很多，不管是监控还是查问题我们要关注的事件只是其中很小的一部分。这个时候就要用到过滤的功能，找到感兴趣的事件。<code>Sysdig</code> 的过滤功能很强大，不仅支持的过滤项很多，而且还能够自由地进行逻辑组合。</p><p><code>Sysdig</code> 的过滤器也是分成不同类别的，比如:</p><ul><li>fd: 对文件描述符（file descriptor）进行过滤，比如 fd 标号（fd.num）、fd 名字（<a href="http://fd.name" target="_blank" rel="noopener">fd.name</a>）。</li><li>process: 进程信息的过滤，比如进程 id（<a href="http://proc.id" target="_blank" rel="noopener">proc.id</a>）、进程名（<a href="http://proc.name" target="_blank" rel="noopener">proc.name</a>）。</li><li>evt: 事件信息的过滤，比如事件编号、事件名。</li><li>user: 用户信息的过滤，比如用户 id、用户名、用户 home 目录、用户的登录 shell（user.shell）。</li><li>syslog: 系统日志的过滤，比如日志的严重程度、日志的内容。</li><li>fdlist: poll event 的文件描述符的过滤。</li></ul><p>完整的过滤器列表可以使用 <code>sysdig -l</code> 来查看，比如可以查看建立 TCP 连接的事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysdig evt.type&#x3D;accept</span><br></pre></td></tr></table></figure><p>过滤器除了直接的相等比较之外，还有其他操作符，包括 =、!=、&gt;=、&gt;、&lt;、&lt;=、contains、in 和 exists，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig fd.name contains &#x2F;etc</span><br><span class="line">$ sysdig &quot;evt.type in ( &#39;select&#39;, &#39;poll&#39; )&quot;</span><br><span class="line">$ sysdig proc.name exists</span><br></pre></td></tr></table></figure><p>更酷的是，多个过滤条件还可以通过 and、or 和 not 进行逻辑组合，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig &quot;not (fd.name contains &#x2F;proc or fd.name contains &#x2F;dev)&quot;</span><br></pre></td></tr></table></figure><p>这些强大的功能综合到一起，就能让我们很容易定位到需要的事件，分析和监控更有目的性。</p><h4 id="自定义输出格式">自定义输出格式</h4><p>标准的输出已经打印出常用的信息，sysdig 还允许你自定义打印出的内容，参数 <code>-p</code> 可以加上类似于 C 语言 printf 字符串，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -p&quot;user:%user.name dir:%evt.arg.path&quot; evt.type&#x3D;chdir</span><br><span class="line">user:ubuntu dir:&#x2F;root</span><br><span class="line">user:ubuntu dir:&#x2F;root&#x2F;tmp</span><br><span class="line">user:ubuntu dir:&#x2F;root&#x2F;Download</span><br></pre></td></tr></table></figure><p>上面的信息，可以很容易看到用户更改当前目录的情况。从上面的例子也可以使用 <code>-p</code> 的使用方法：</p><ul><li>字段必须用 % 作为前缀，所有在 <code>sysdig -l</code> 中列出来的字段都可以使用</li><li>你可以在字符串中加入其他可读性的内容，它们会如实打印出来</li><li>如果某个字段在时间中不存在，默认这个事件会过滤掉，在这个字符串最前面加上 * 符号，会打印出所有的事件，不存在的字段会变成 <na>，比如:</na></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -p&quot;*%evt.type %evt.dir %evt.arg.name&quot; evt.type&#x3D;open</span><br><span class="line">open &gt; &lt;NA&gt;</span><br><span class="line">open &lt; &#x2F;proc&#x2F;1285&#x2F;task&#x2F;1399&#x2F;stat</span><br><span class="line">open &gt; &lt;NA&gt;</span><br><span class="line">open &lt; &#x2F;proc&#x2F;1285&#x2F;task&#x2F;1400&#x2F;io</span><br><span class="line">open &gt; &lt;NA&gt;</span><br><span class="line">open &lt; &#x2F;proc&#x2F;1285&#x2F;task&#x2F;1400&#x2F;statm</span><br><span class="line">open &gt; &lt;NA&gt;</span><br></pre></td></tr></table></figure><h4 id="保存到文件">保存到文件</h4><p>尽管可以用过滤器减少输出，直接在终端查看事件流还是没有办法让我们进行深入分析。和 <code>tcpdump</code> 工具类似，<code>Sysdig</code> 也允许你把捕获的时间保存到本地的文件，然后再读取文件的内容进行分析。</p><p>保存到文件可以通过 <code>-w</code> 实现，从文件中读取需要 <code>-r</code> 参数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 捕获事件，并保存到文件中，这样在终端是看不到输出的。</span><br><span class="line">$ sudo sysdig -w sysdig-trace-file.scap</span><br><span class="line"></span><br><span class="line"># 从文件中读取 Sysdig 格式的事件进行分析。</span><br><span class="line">$ sudo sysdig -r sysdig-trace-file.scap</span><br></pre></td></tr></table></figure><p>另一个有用的功能是，你可以控制捕获到文件的内容。通常情况下，<code>Sysdig</code> 捕获了系统所有的活动，因此这些数据会很大，如果一直捕获的话，会造成磁盘空间的浪费，<code>Sysdig</code> 提供了类似于 <code>logrotate</code> 的方式，让你只保存最新捕获的文件。</p><p>控制捕获文件大小的一个办法是在捕获的使用使用过滤器，之外，你还可以通过 <code>-n 2000</code> 指定捕获 2000 条事件之后就退出，或者通过 <code>logrotate</code> 的方式来滚动文件：</p><ul><li><code>sysdig -C 5 -W 10 -w dump.pcap</code> ：保证每个文件不超过 5M 大小，并且只保存最近的 10 个文件</li><li><code>sysdig -G 60 -W 60 -w dump.pcap</code>：每个文件只保存一分钟内的系统活动（-G 60），并且只保存 60 个文件，也就是说捕获最近一个小时的系统活动，每分钟的数据一个文件</li><li><code>sysdig -e 1000 -W 5 -w dump.scap</code>：保存 5 个文件，每个文件只有 1000 个事件</li></ul><p>当使用 <code>-w</code> 保存文件的使用，还可以使用 <code>-z</code> 参数对保存的内容进行压缩，进一步减少占用的空间。</p><p>读取的时候也可以使用过滤器，如果我们只关心 write 系统调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -r sysdig-trace-nano.scap evt.type&#x3D;write</span><br></pre></td></tr></table></figure><p>而且读取的时候也可以进一步对文件进行分割，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -r dump.scap -G 300 -z -w segments.scap</span><br></pre></td></tr></table></figure><p>这个命令，就是读取 dump.scap 文件的内容，并且把它分割成五分钟（-G 300s）的多个文件。</p><h4 id="常用的参数">常用的参数</h4><p>除了上面介绍的过滤器参数，<code>Sysdig</code> 还有很多可用的参数，完整的列表和解释请参考 <code>man sysdig</code> 文档。这里介绍一下比较常用的：</p><ul><li>-A --print-ascii：把 buffer 中数据按照 ASCII 格式打印，方便用户阅读</li><li>-x --print-hex： 把 buffer 中数据按照十六进制格式打印</li><li>-X --print-hex-ascii： 把 buffer 中数据同时按照 ASCII 格式和十六进制格式打印</li><li>-s 1024：捕获 buffer 的数据大小，默认为 80，如果这个值设置的过大，会产生很大的文件</li><li>-N：不用把端口号转换成可读的名字，这个参数会提高处理的效率</li></ul><h3 id="chisels实用的工具箱">Chisels：实用的工具箱</h3><p>虽然有了过滤器和文件的输入输出，加上 <code>Sysdig</code> 其他的参数，我们可以按照需求去分析和监控系统了，但是很多场景需要更复杂的数据聚合。<code>Sysdig</code> 提供了另外一个强大的功能：<code>chisels</code>，它们是一组预定义的功能集合，通过 <code>Lua</code> 脚本实现，用来分析特定的场景。</p><p>可以通过 <code>sudo sysdig -cl</code> 列出支持的所有 <code>chisels</code>，我们来解释一些比较常用的 <code>chisels</code>：</p><ul><li>httplog：输出所有的 HTTP 请求。</li><li>topprocs_cpu：输出按照 CPU 使用率排序的进程列表。</li><li>echo_fds：输出进程读写的数据。</li><li>netstat：列出网络的连接情况。</li><li>spy_file：输出文件的读写数据，可以提供某个文件名作为参数，这样就只输出该文件的读写内容。</li></ul><p>有些 <code>chisel</code> 可能需要参数才能正常运行，如果要了解某个 <code>chisel</code> 的具体使用说明，可以用 <code>-i</code> 参数，比如要了解 <code>spy_file</code> 的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysdig -i spy_file</span><br><span class="line"></span><br><span class="line">Category: I&#x2F;O</span><br><span class="line">-------------</span><br><span class="line">spy_file        Echo any read&#x2F;write made by any process to all files. Optionall</span><br><span class="line">                y, you can provide the name of one file to only intercept reads</span><br><span class="line">                &#x2F;writes to that file.</span><br><span class="line"></span><br><span class="line">This chisel intercepts all reads and writes to all files. Instead of all files,</span><br><span class="line"> you can limit interception to one file.</span><br><span class="line">Args:</span><br><span class="line">[string] read_or_write - Specify &#39;R&#39; to capture only read event</span><br><span class="line">                s; &#39;W&#39; to capture only write events; &#39;RW&#39; to capture read and w</span><br><span class="line">                rite events. By default both read and write events are captured</span><br><span class="line">                .</span><br><span class="line">[string] spy_on_file_name - The name of the file which the chis</span><br><span class="line">                el should spy on for all read and write activity.</span><br></pre></td></tr></table></figure><p>文章最开始的时候，我提到过 <code>Sysdig</code> 可以满足大部分的日常分析，它们主要就是通过 <code>chisel</code> 完成的。比如：</p><p>按照网络的使用情况对进程进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sysdig -c topprocs_net</span><br></pre></td></tr></table></figure><p>按照建立连接数量对进程进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -c fdcount_by fd.sport &quot;evt.type&#x3D;accept&quot;</span><br></pre></td></tr></table></figure><p>查看系统中用户执行的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -r sysdig.pcap -c spy_users</span><br></pre></td></tr></table></figure><p>更多的使用案例，可以参考 Sysdig Example 这篇 wiki。</p><p>在 <code>Linux</code> 机器上，这些 <code>chisel</code> 保存在 /usr/share/sysdig/chisels 文件夹中，每个 <code>chisel</code> 对应一个 <code>Lua</code> 脚本文件。如果提供的这些 <code>chisel</code> 还不能满足需求，用户也可以根据需求编写自己的 <code>chisel</code>。</p><h3 id="对容器的支持">对容器的支持</h3><p><code>Sysdig</code> 另外一个优势是它对容器（ <code>Docker</code> 和 <code>Kubernetes</code> ）的良好支持，这对于目前采用了容器化的系统管理员来说是很好的福利。</p><p>使用 <code>-pc</code> 参数就能自动在打印的事件中添加上容器的信息（容器名、容器 id 等），比如捕获 container 名字为 zen_knuth 的所有系统活动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -pc container.name&#x3D;zen_knuth</span><br></pre></td></tr></table></figure><p>对容器的分析和原来的一样，只要通过 container.name=apache 指定要分析的容器名字就行，比如查看某个容器的网络连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -pc -c topconns container.name&#x3D;wordpress1</span><br></pre></td></tr></table></figure><p>要集成 <code>Kubernetes</code> 系统监控的话，使用 <code>-k http://master_ip:8080</code> 参数，后面是 apiserver 的地址，如果 apiserver 需要认证的话，需要指定 <code>-K filename</code> 来说明 apiserver CA 证书的文件地址。关于 <code>Kubernetes</code> 的监控和分析不是这篇文章的重点，读者可以参数 <code>Sysdig</code> 的博客或者其他文档。</p><h3 id="csysdig图形化的-sysdig">Csysdig：图形化的 Sysdig</h3><p><code>Sysdig</code> 还提供了另外一个图形化的工具：<code>Csysdig</code>，它的界面和 top/htop 命令相似，并且可以接受用户的交互。</p><p><img src="https://assets.digitalocean.com/articles/sysdig_ubuntu_1604/LEhCwvI.jpg" alt=""></p><p>和 <code>Sysdig</code> 一样，<code>Csysdig</code> 可以实时捕获系统事件，也可以读取之前保存的文件。</p><h3 id="更多文档">更多文档</h3><p>这篇文章介绍的都出入门的、基础概念性的知识，如果读者希望进一步了解 sysdig，不妨继续阅读下面这些文章：</p><ul><li>sysdig 和传统的 strace、htop、lsof、tcpdump、iftop命令的比较</li><li>理解 sysdig 的输出</li><li>sysdig twitter 账号 #digoftheday</li></ul><h3 id="参考资料">参考资料</h3><p>这篇文章主要参考了一下的博客、文章和资料：</p><ul><li>Sysdig User Guide</li><li>Linux Troubleshooting Cheatsheet: strace, htop, lsof, tcpdump, iftop &amp; sysdig</li><li>DigitalOcean: How To Monitor Your Ubuntu 16.04 System with Sysdig</li><li>Sysdig vs DTrace vs Strace: a Technical Discussion</li><li>用 Sysdig 监控服务器和 Docker 容器</li></ul><blockquote><p>来源：Cizixs Blogs</p><p>原文：<a href="https://tinyurl.com/yc3tm4bf" target="_blank" rel="noopener">https://tinyurl.com/yc3tm4bf</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Sysdig-简介&quot;&gt;Sysdig 简介&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Sysdig&lt;/code&gt; 官网 上对自己的介绍是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Open Source Universal System Visibility With Native Contaier Support.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它的定位是系统监控、分析和排障的工具，其实在 &lt;code&gt;Linux&lt;/code&gt; 平台上，已经有很多这方面的工具 &lt;code&gt;strace&lt;/code&gt;、&lt;code&gt;tcpdump&lt;/code&gt;、&lt;code&gt;htop&lt;/code&gt;、&lt;code&gt;iftop&lt;/code&gt;、&lt;code&gt;lsof&lt;/code&gt;、&lt;code&gt;netstat&lt;/code&gt;，它们都能用来分析 &lt;code&gt;Linux&lt;/code&gt; 系统的运行情况，而且还有很多日志、监控工具。为什么还需要 &lt;code&gt;Sysdig&lt;/code&gt; 呢？在我看来，&lt;code&gt;Sysdig&lt;/code&gt; 的优点可以归纳为三个词语：整合、强大、灵活。&lt;/p&gt;
&lt;h4 id=&quot;整合&quot;&gt;整合&lt;/h4&gt;
&lt;p&gt;虽然 &lt;code&gt;Linux&lt;/code&gt; 有很多系统分析和调优的工具，但是它们一般都负责某个特殊的功能，并且使用方式有很大的差异，如果要分析和定位问题，一般都需要熟练掌握需要命令的使用。而且这些工具的数据无法进行共享，只能相互独立工作。&lt;code&gt;Sysdig&lt;/code&gt; 一个工具就能实现上述所有工具的功能，并且提供了统一的使用语法。&lt;/p&gt;
&lt;h4 id=&quot;强大&quot;&gt;强大&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Sysdig&lt;/code&gt; 能获取实时的系统数据，也能把信息保存到文件中以供后面分析。捕获的数据包含系统的个个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全方面的系统参数：CPU、Memory、Disk IO、网络 IO&lt;/li&gt;
&lt;li&gt;支持各种 IO 活动：进程、文件、网络连接等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了帮你捕获信息之外，&lt;code&gt;Sysdig&lt;/code&gt; 还预先还有有用的工具来分析这些数据，从大量的数据中找到有用的信息变得非常简单。比如你能还简单地做到下面这些事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照 CPU 的使用率对进程进行排序，找到 CPU 使用率最高的那个&lt;/li&gt;
&lt;li&gt;按照发送网络数据报文的多少对进程进行排序&lt;/li&gt;
&lt;li&gt;找到打开最多文件描述符的进程&lt;/li&gt;
&lt;li&gt;查看哪些进程修改了指定的文件&lt;/li&gt;
&lt;li&gt;打印出某个进程的 HTTP 请求报文&lt;/li&gt;
&lt;li&gt;找到用时最久的系统调用&lt;/li&gt;
&lt;li&gt;查看系统中所有的用户都执行了哪些命令&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上自带的工具就能满足大部分的分析需求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Sysdig" scheme="https://www.hi-linux.com/tags/Sysdig/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中 Pstree 命令使用指南</title>
    <link href="https://www.hi-linux.com/posts/35899.html"/>
    <id>https://www.hi-linux.com/posts/35899.html</id>
    <published>2020-05-23T02:25:00.000Z</published>
    <updated>2020-05-23T15:22:46.159Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在 Linux 机器上工作时，有时你可能需要找出当前正在运行的进程。你可以使用许多命令来查找有关正在运行的进程的信息，其中 <code>ps</code> 和 <code>top</code> 是最常用的命令。</p><p>在本文中，我们将讨论 <code>pstree</code> 命令。它类似于 <code>ps</code> ，但没有列出正在运行的进程，而是将它们显示在一个目录树中。树状格式是以一种更方便的方式来显示进程层次结构，并使输出在视觉上更具吸引力。</p><h2 id="如何使用-pstree-命令">如何使用 pstree 命令</h2><p><code>pstree</code> 命令的一般语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [OPTIONS] [USER or PID]</span><br></pre></td></tr></table></figure><p>以最简单的形式调用时没有任何选项或参数，<code>pstree</code> 命令将显示所有正在运行的进程的分层树结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ pstree</span><br><span class="line">systemd─┬─VBoxService───7*[&#123;VBoxService&#125;]</span><br><span class="line">        ├─accounts-daemon───2*[&#123;accounts-daemon&#125;]</span><br><span class="line">        ├─2*[agetty]</span><br><span class="line">        ├─atd</span><br><span class="line">        ├─cron</span><br><span class="line">        ├─dbus-daemon</span><br><span class="line">        ├─irqbalance───&#123;irqbalance&#125;</span><br><span class="line">        ├─2*[iscsid]</span><br><span class="line">        ├─lvmetad</span><br><span class="line">        ├─lxcfs───2*[&#123;lxcfs&#125;]</span><br><span class="line">        ├─networkd-dispat───&#123;networkd-dispat&#125;</span><br><span class="line">        ├─nginx───2*[nginx]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><a id="more"></a><p>目录树中的 <code>top/root</code> 项目是所有系统进程的父进程。在此示例中为 <code>systemd</code>，这是系统启动时启动的第一个进程。</p><p><code>pstree</code> 通过将相同的分支放在方括号之间并为它们加上代表分支数的整数作为前缀来合并它们，这使得输出更具可读性和视觉吸引力。以下是显示如何使用方括号的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pstree</span><br><span class="line">├─2*[agetty]</span><br></pre></td></tr></table></figure><p>要禁用相同分支的合并，请使用 <code>-c</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -c</span><br><span class="line">├─agetty        </span><br><span class="line">├─agetty</span><br></pre></td></tr></table></figure><p>每个进程的线程显示在父进程下，并使用花括号内的进程名称显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">├─lxcfs───2*[&#123;lxcfs&#125;]</span><br></pre></td></tr></table></figure><p>你可以使用 <code>-t</code> 选项显示完整的线程名称，如果要隐藏线程并仅显示进程，请使用 <code>-T</code> 选项。</p><p>通常，<code>pstree</code> 会在屏幕上显示多行输出。要一次查看输出一页，你可以将其结果通过管道传递到 <code>less</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pstree | less</span><br></pre></td></tr></table></figure><p>如果使用用户名作为参数，则 <code>pstree</code> 仅显示该用户拥有的进程。例如，以下命令将仅显示那些由名为 myfreax 的用户启动的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pstree myfreax</span><br></pre></td></tr></table></figure><p>如果将 <code>PID</code> 指定为参数，则 <code>pstree</code> 将显示一棵以给定进程为树根的目录树。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pstree 1943</span><br><span class="line">sshd───bash───pstree</span><br></pre></td></tr></table></figure><p>要显示给定进程的父进程，你可以使用 <code>-s</code> 选项，并在其后跟进程 <code>PID</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -s 1943</span><br><span class="line">systemd───sshd───sshd───bash───pstree</span><br></pre></td></tr></table></figure><h2 id="显示-pid-和-pgid">显示 PID 和 PGID</h2><p>通常，当运行 <code>pstree</code> 命令时，用户寻找的最重要的信息是进程 ID。例如，你知道 PID 即可让你杀死发生故障的进程。</p><p>我们可以通过 <code>-p</code> 选项让 <code>pstree</code> 显示进程的 <code>PID</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个进程或线程后的括号中均显示的是 PID。</span></span><br><span class="line">$ pstree -p</span><br><span class="line">systemd(1)─┬─VBoxService(955)─┬─&#123;VBoxService&#125;(956)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(957)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(958)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(959)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(960)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(961)</span><br><span class="line">           │                  └─&#123;VBoxService&#125;(962)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>默认情况下，<code>pstree</code> 按名称对具有相同父项的进程进行排序。 如果你想按 <code>PID</code> 排序，你则可以使用 <code>-n</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -pn</span><br></pre></td></tr></table></figure><p>一个或多个进程组 ID 是进程组的第一个成员的进程 ID。如果你要查看 <code>PGID</code>，可以使用 <code>-g</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个进程或线程之后的括号中也显示了 PID。</span></span><br><span class="line">$ pstree -g</span><br><span class="line">systemd(1)─┬─VBoxService(954)─┬─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  └─&#123;VBoxService&#125;(954)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>注：显示 <code>PID</code> 或 <code>PGID</code> 时，将隐式禁用默认的进程合并。</p></blockquote><h2 id="显示命令行参数">显示命令行参数</h2><p>默认情况下，<code>pstree</code> 不会向你显示正在运行的进程的命令行参数。要查看进程是如何开始的，你可以使用 <code>-a</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -a</span><br><span class="line">...</span><br><span class="line">  ├─agetty -o -p -- \\u --keep-baud 115200,38400,9600 ttyS0 vt220</span><br><span class="line">  ├─agetty -o -p -- \\u --noclear tty1 linux</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="高亮">高亮</h2><p><code>pstree</code> 还可以使你突出显示进程以更好地呈现视觉效果。-h 选项指示 <code>pstree</code> 高亮显示当前进程及其所有父进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -h</span><br></pre></td></tr></table></figure><p>如果要高亮显示特定的进程，你可以使用 <code>-H</code> 选项，然后加上进程 ID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -H PID_NUMBER</span><br></pre></td></tr></table></figure><h2 id="结论">结论</h2><p>至此，我们就讲完了以树结构的形式显示正在运行的进程的 <code>pstree</code> 命令。有关所有可用 <code>pstree</code> 选项的信息，你可以通过在终端中输入 <code>man pstree</code> 进行查看。</p><blockquote><p>来源：myfreax</p><p>原文：<a href="https://url.cn/5yQDYSA" target="_blank" rel="noopener">https://url.cn/5yQDYSA</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Linux 机器上工作时，有时你可能需要找出当前正在运行的进程。你可以使用许多命令来查找有关正在运行的进程的信息，其中 &lt;code&gt;ps&lt;/code&gt; 和 &lt;code&gt;top&lt;/code&gt; 是最常用的命令。&lt;/p&gt;
&lt;p&gt;在本文中，我们将讨论 &lt;code&gt;pstree&lt;/code&gt; 命令。它类似于 &lt;code&gt;ps&lt;/code&gt; ，但没有列出正在运行的进程，而是将它们显示在一个目录树中。树状格式是以一种更方便的方式来显示进程层次结构，并使输出在视觉上更具吸引力。&lt;/p&gt;
&lt;h2 id=&quot;如何使用-pstree-命令&quot;&gt;如何使用 pstree 命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;pstree&lt;/code&gt; 命令的一般语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ps [OPTIONS] [USER or PID]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以最简单的形式调用时没有任何选项或参数，&lt;code&gt;pstree&lt;/code&gt; 命令将显示所有正在运行的进程的分层树结构。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pstree&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;systemd─┬─VBoxService───7*[&amp;#123;VBoxService&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─accounts-daemon───2*[&amp;#123;accounts-daemon&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─2*[agetty]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─atd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─cron&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─dbus-daemon&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─irqbalance───&amp;#123;irqbalance&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─2*[iscsid]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─lvmetad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─lxcfs───2*[&amp;#123;lxcfs&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─networkd-dispat───&amp;#123;networkd-dispat&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─nginx───2*[nginx]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>浅谈劳动合同法中赔偿金 N、N+1、2N 的区别</title>
    <link href="https://www.hi-linux.com/posts/16375.html"/>
    <id>https://www.hi-linux.com/posts/16375.html</id>
    <published>2020-05-23T02:24:00.000Z</published>
    <updated>2020-05-23T15:22:46.163Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1-离职经济补偿金的法律依据是什么">1. 离职经济补偿金的法律依据是什么？</h2><p>首先需要注意的是，虽然我们遇到问题就会提到《劳动法》，但是离职经济补偿金的相关规定都在《劳动合同法》之中，两个法规并不是一回事。所以，再遇到相关问题的时候就不要拿《劳动法》说事了。</p><h2 id="2-n-是什么意思">2. N 是什么意思？</h2><p>参见第四十七条，经济补偿计算</p><p>经济补偿按劳动者在本单位工作的年限，每满一年支付一个月工资的标准向劳动者支付。六个月以上不满一年的，按一年计算；不满六个月的，向劳动者支付半个月工资的经济补偿。</p><p>这里大家俗称的 N 就是指劳动者在用人单位的工作年限。</p><h2 id="3-n1-是怎么回事">3. N+1 是怎么回事？</h2><p>参见第四十条 无过失性辞退</p><p>有下列情形之一的，用人单位提前三十日以书面形式通知劳动者本人或者额外支付劳动者一个月工资后，可以解除劳动合同：</p><p>（一）劳动者患病或者非因工负伤，在规定的医疗期满后不能从事原工作，也不能从事由用人单位另行安排的工作的；</p><p>（二）劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的；</p><p>（三）劳动合同订立时所依据的客观情况发生重大变化，致使劳动合同无法履行，经用人单位与劳动者协商，未能就变更劳动合同内容达成协议的。</p><p>也就是说如果用人单位按照以上情况主动辞退员工的时候，需要支付 N 个月的补偿金，但是必须提前三十天以书面形式通知劳动者，这实际上是为了让劳动者有一个缓冲期来找新的工作以及处理社保等内容。<strong>如果没有提前通知就要辞退的话，需要额外支付一个月的补偿金，也就是 N+1的来源。</strong></p><a id="more"></a><h2 id="4-为什么有的公司只需要赔偿-n">4. 为什么有的公司只需要赔偿 N ？</h2><p>参见第四十一条 经济性裁员</p><p>有下列情形之一，需要裁减人员二十人以上或者裁减不足二十人但占企业职工总数百分之十以上的，用人单位提前三十日向工会或者全体职工说明情况，听取工会或者职工的意见后，裁减人员方案经向劳动行政部门报告，可以裁减人员：</p><p>（一）依照企业破产法规定进行重整的；</p><p>（二）生产经营发生严重困难的；</p><p>（三）企业转产、重大技术革新或者经营方式调整，经变更劳动合同后，仍需裁减人员的；</p><p>（四）其他因劳动合同订立时所依据的客观经济情况发生重大变化，致使劳动合同无法履行的。</p><p>满足这个前提条件的情况下，公司主动辞退员工的时候，不用提前一个月通知，也不用额外支付一个月的补偿金，所以只需要赔偿N就可以了。但是，为了避免公司投机取巧，还规定了优先留用人员以及优先招用规则：</p><p>裁减人员时，应当优先留用下列人员：</p><p>（一）与本单位订立较长期限的固定期限劳动合同的；</p><p>（二）与本单位订立无固定期限劳动合同的；</p><p>（三）家庭无其他就业人员，有需要扶养的老人或者未成年人的。用人单位依照本条第一款规定裁减人员，在六个月内重新招用人员的，应当通知被裁减的人员，并在同等条件下优先招用被裁减的人员。</p><h2 id="5-什么情况公司解雇员工不用赔偿">5. 什么情况公司解雇员工不用赔偿？</h2><p>参见第三十九条 用人单位单方解除劳动合同（过失性辞退）</p><p>劳动者有下列情形之一的，用人单位可以解除劳动合同：</p><p>（一）在试用期间被证明不符合录用条件的；</p><p>（二）严重违反用人单位的规章制度的；</p><p>（三）严重失职，营私舞弊，给用人单位造成重大损害的；</p><p>（四）劳动者同时与其他用人单位建立劳动关系，对完成本单位的工作任务造成严重影响，或者经用人单位提出，拒不改正的；</p><p>（五）因本法第二十六条第一款第一项规定的情形致使劳动合同无效的；</p><p>（六）被依法追究刑事责任的。</p><p>这里重点介绍一下！当员工有过错的前提下，公司确实可以开除员工而不用支付补偿金。</p><p><strong>但是！但是！但是！</strong></p><p><strong>公司很难依照此条文解雇员工，具体常见逼退手段下面再单独讲解！</strong></p><h2 id="6-为什么有人可以获得-2n-赔偿">6. 为什么有人可以获得 2N 赔偿？</h2><p>参见第八十七条 违反解除或者终止劳动合同的法律责任</p><p>用人单位违反本法规定解除或者终止劳动合同的，应当依照本法第四十七条规定的经济补偿标准的二倍向劳动者支付赔偿金。</p><p>这里例句一些常见的一些情况，方便大家保护自身利益：</p><p>（一）从事接触职业病危害作业的劳动者未进行离岗前职业健康检查，或者疑似职业病病人在诊断或者医学观察期间的；</p><p>（二）在本单位患职业病或者因工负伤并被确认丧失或者部分丧失劳动能力的；</p><p>（三）患病或者非因工负伤，在规定的医疗期内的；</p><p>（四）女职工在孕期、产期、哺乳期的；</p><p>（五）在本单位连续工作满十五年，且距法定退休年龄不足五年的；</p><p>（六）法律、行政法规规定的其他情形。</p><p>法律上并没有 2N+1 的说法，毕竟违法裁员，根本不需要提前一个月通知，所以只有 2N，没有 2N+1。注意：2N 这个就应该叫做赔偿金了，是违法的赔偿。</p><h2 id="7-为什么有人可以获得-n6">7. 为什么有人可以获得 N+6？</h2><p>N+6 等补偿金更多的是一种操作策略，而不是出于劳动合同法上的需求。企业为了尽快解决裁员问题，减少麻烦，会提出各种补偿办法。比如今年的甲骨文裁员，5 月 22 日前签字是 N+6，6 月 7 日前签字是 N+1，6 月 7后签字走人就只有 N 了。</p><h2 id="8-员工主动离职可以提出补偿吗">8. 员工主动离职可以提出补偿吗？</h2><p>参见第三十七条 劳动者提前通知解除劳动合同</p><p>劳动者提前三十日以书面形式通知用人单位，可以解除劳动合同。劳动者在试用期内提前三日通知用人单位，可以解除劳动合同。</p><p>所以，自己提出辞职的人，就不要再想拿补偿金了。</p><h2 id="9-劳动合同到期了辞退员工如何补偿">9. 劳动合同到期了辞退员工如何补偿？</h2><p>劳动合同到期，如果公司不想续签也需要补偿 N。另外，如果员工可以签订<strong>无固定期限劳动合同</strong>的情况，公司需要支付 2N 的赔偿。</p><h2 id="10-什么是无固定期限劳动合同">10. 什么是无固定期限劳动合同？</h2><p>参见第十四条 无固定期限劳动合同</p><p>无固定期限劳动合同，是指用人单位与劳动者约定无确定终止时间的劳动合同。用人单位与劳动者协商一致，可以订立无固定期限劳动合同。有下列情形之一，劳动者提出或者同意续订、订立劳动合同的，除劳动者提出订立固定期限劳动合同外，应当订立无固定期限劳动合同：</p><p>（一）劳动者在该用人单位连续工作满十年的；</p><p>（二）用人单位初次实行劳动合同制度或者国有企业改制重新订立劳动合同时，劳动者在该用人单位连续工作满十年且距法定退休年龄不足十年的；</p><p>（三）连续订立二次固定期限劳动合同，且劳动者没有本法第三十九条和第四十条第一项、第二项规定的情形，续订劳动合同的。用人单位自用工之日起满一年不与劳动者订立书面劳动合同的，视为用人单位与劳动者已订立无固定期限劳动合同。</p><p>所以各位可以检查一下自己是否签订了无固定期限劳动合同？</p><h2 id="11-离职经济补偿金的基数怎么算">11. 离职经济补偿金的基数怎么算？</h2><p>1）合同解除前 12 个月内的货币性收入</p><p>2）应发工资（税前工资）</p><p>3）包含年终奖或年终双薪、包含津贴和补贴</p><p>4）包含加班费（据说上海规定不含，具体遇到问题的朋友请及时联系法律顾问）</p><h2 id="12-为什么我的补偿金少了">12. 为什么我的补偿金少了？</h2><p>参见第四十七条 经济补偿的计算</p><p>劳动者月工资高于用人单位所在直辖市、设区的市级人民政府公布的本地区上年度职工月平均工资三倍的，向其支付经济补偿的标准按职工月平均工资三倍的数额支付，向其支付经济补偿的年限最高不超过十二年。</p><p>所以，如果你的工资太高了，也不会给你补偿那么多的。以北京为例，2019 年平均工作为 6906，最高的离职补偿金就是：6909x3x12≈25万。</p><p>补偿金不用缴纳个税。</p><h2 id="13-劳动合同不同于劳务合同">13. 劳动合同不同于劳务合同</h2><p>劳务关系，是指不构成劳动关系的，一方提供劳务、一方支付报酬的民事关系，如家庭或个人与家政服务人员之间的关系，个体工匠与帮工、学徒之间的关系，农村承包经营户与受雇人之间的关系等。</p><p>劳务关系离职是没有补偿金说法的，所以签订协议时要明确是劳动合同还是劳务合同。</p><h2 id="14-劳动合同法是保护劳动者的">14. 劳动合同法是保护劳动者的！</h2><p>虽然我们在第 5 点里介绍了公司可以不支付补偿金的情况，<strong>但是绝大多数情况下，公司都很难以此来解除劳动合同，而在解除合同过程中任何一点瑕疵，都是违法的！</strong></p><p>所有解除的理由必须证据确凿并需要你亲自签字确认才可以，而且重大过失要有调查过程，还需要给你澄清的机会。总之，<strong>劳动者面对违法解约时，只要上诉劳动仲裁部门，基本都能赢，所以不要怕 HR 的威逼利诱！</strong></p><p>就比如严重违反用人单位的规章制度这一条，上班睡觉算不算违反，上班玩手机算不算违反？如果要按照仲裁流程的话，用人单位要提供清楚什么内容才算玩手机，玩了多久才算违规，另外还需要提供证据证明你在什么时间到什么时候玩了什么内容，对公司的生产造成了什么样的危害。总之，所有的举证责任都在公司，想要合法的开除一个人，是真的很难很难的。</p><p>再比很多 HR 会拿绩效不达标或者末尾淘汰为理由辞退员工。但是需要注意的是绩效不达标、末位淘汰≠不能胜任工作。另外，绩效考核标准必须合理，这一点就有大的解释空间和法律风险。都需要公司去举证。</p><p>另外常见的手段就是给你转岗到海外或者不发达地区，其实这个属于变动了劳动合同内容，需要与员工协商签字才可以，否则就是违法的！</p><p><strong>《中华人民共和国劳动合同法》 完整版本</strong>可参见这里：<a href="https://url.cn/5QSBTZj" target="_blank" rel="noopener">https://url.cn/5QSBTZj</a></p><blockquote><p>再提醒一点：哺乳期的同事不要同意签署延迟协议（HR 会让你哺乳期结束就滚蛋），务必直接签下一个合同，否则劳动局仲裁；</p></blockquote><p><strong>最后！和 HR 还有主管谈话时，</strong></p><p><strong>记得带好录音笔！</strong></p><p><strong>记得带好录音笔！</strong></p><p><strong>记得带好录音笔！</strong></p><p>希望这篇文章能给到广大朋友以帮助！</p><blockquote><p>本文转载自：「表哥有话讲」，原文：<a href="https://url.cn/5Ls0zGQ%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5Ls0zGQ，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-离职经济补偿金的法律依据是什么？&quot;&gt;1. 离职经济补偿金的法律依据是什么？&lt;/h2&gt;
&lt;p&gt;首先需要注意的是，虽然我们遇到问题就会提到《劳动法》，但是离职经济补偿金的相关规定都在《劳动合同法》之中，两个法规并不是一回事。所以，再遇到相关问题的时候就不要拿《劳动法》说事了。&lt;/p&gt;
&lt;h2 id=&quot;2-N-是什么意思？&quot;&gt;2. N 是什么意思？&lt;/h2&gt;
&lt;p&gt;参见第四十七条，经济补偿计算&lt;/p&gt;
&lt;p&gt;经济补偿按劳动者在本单位工作的年限，每满一年支付一个月工资的标准向劳动者支付。六个月以上不满一年的，按一年计算；不满六个月的，向劳动者支付半个月工资的经济补偿。&lt;/p&gt;
&lt;p&gt;这里大家俗称的 N 就是指劳动者在用人单位的工作年限。&lt;/p&gt;
&lt;h2 id=&quot;3-N-1-是怎么回事？&quot;&gt;3. N+1 是怎么回事？&lt;/h2&gt;
&lt;p&gt;参见第四十条 无过失性辞退&lt;/p&gt;
&lt;p&gt;有下列情形之一的，用人单位提前三十日以书面形式通知劳动者本人或者额外支付劳动者一个月工资后，可以解除劳动合同：&lt;/p&gt;
&lt;p&gt;（一）劳动者患病或者非因工负伤，在规定的医疗期满后不能从事原工作，也不能从事由用人单位另行安排的工作的；&lt;/p&gt;
&lt;p&gt;（二）劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的；&lt;/p&gt;
&lt;p&gt;（三）劳动合同订立时所依据的客观情况发生重大变化，致使劳动合同无法履行，经用人单位与劳动者协商，未能就变更劳动合同内容达成协议的。&lt;/p&gt;
&lt;p&gt;也就是说如果用人单位按照以上情况主动辞退员工的时候，需要支付 N 个月的补偿金，但是必须提前三十天以书面形式通知劳动者，这实际上是为了让劳动者有一个缓冲期来找新的工作以及处理社保等内容。&lt;strong&gt;如果没有提前通知就要辞退的话，需要额外支付一个月的补偿金，也就是 N+1的来源。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="虚拟化" scheme="https://www.hi-linux.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>30 个你应该知道的编程技巧</title>
    <link href="https://www.hi-linux.com/posts/39135.html"/>
    <id>https://www.hi-linux.com/posts/39135.html</id>
    <published>2020-05-23T02:23:00.000Z</published>
    <updated>2020-05-23T15:22:46.164Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>本文作者 Jun Wu 有着编程和统计学背景，她在 15 年前就是一名程序员。近日，她分享了给程序员的 30 条心得建议。</p></blockquote><p>如果你想成为一名程序员，这个建议可以帮助你走上正确的道路。</p><p>程序员不是一个容易的职业，每年都有许多人从国内顶尖院校的计算机科学专业毕业，这是任何人都能从事的竞争最大的职业之一。同时，编程也是令人兴奋的。随着技术的进步，工业界每天都有创新。编程对于热爱它的人来说是一项充满激情的事业。</p><p>当我 15 年前开始做程序员的时候，我希望有人能告诉我下面清单上的一切建议。这个清单可以为所有新手程序员节省大量的时间和精力，并且，你可以在编程职业发展的整个过程中都参考这些建议。即使这里面有些观点现在可能与你无关，但总有一天你会看到其中的智慧。</p><p>作为一名程序员，你正处在伟大的顶点。</p><p>你只要对自己要走的道路稍有了解就可以开始冒险了。</p><h2 id="1-你不需要学位但你需要知识">1. 你不需要学位，但你需要知识</h2><p>我和许多没有计算机科学硕士学位或计算机科学本科学位的程序员一起工作。编程是少数不依赖学位的职业之一。然而，编程是一项知识密集型的职业。如果你想开始编程生涯，这十本基础书籍你必读的。这十本书将涵盖计算机科学的基本概念以及如何在项目团队中工作。它们可以为你的技术打下坚实的基础，让你对基本概念有一个深刻的理解，并且让你有能力去编写功能性的代码，顺利进行技术面试并与同事交流。</p><h2 id="2-创造性是提高解决编程问题能力的重要因素">2. 创造性是提高解决编程问题能力的重要因素</h2><p>大多数人都有这样的认知：编程都是关于分析和解决问题的技能。这个观点并不是完全正确的，编程也非常需要创造力。通常，你可以用很多方法编写给定的代码。当你拥有了创造力，就能设计出最简单、最有效的代码。</p><h2 id="3-不要什么都学精通一部分知识">3. 不要什么都学，精通一部分知识</h2><p>编程语言有数百种。有一些编程领域有着明确的职业道路：Web 开发人员、前端开发人员、后端开发人员、软件工程师、数据库开发人员等。你需要决定要成为哪种开发人员，然后学习该职位所需的所有技术和技能。</p><h2 id="4-你不需要活的像机器人">4. 你不需要活的像机器人</h2><p>记住，你首先是一个人，其次才是程序员。当您第一次开始编程时，很容易在代码中迷失方向。有时我在完成项目的所有任务之前都不离开电脑。但是你是一个人，你需要笑，哭，减压，和人交谈。管理好你的生活，最大限度地提高工作之外的兴趣爱好，这将为程序员的工作带来更多的创造力。</p><h2 id="5-编程就是应用知识而不是为了记忆">5. 编程就是应用知识而不是为了记忆</h2><p>与研究不同，在研究中，你会发明和创造新的知识领域，但编程就是应用现有的知识。书籍、研究论文、在线文章和学习视频成为您经常使用的资源。不需要记住任何东西。你总是可以搜索资源来找到答案。随着你处理的项目越来越多，这些记忆会自动自然地出现。</p><a id="more"></a><h2 id="6-你每天都要克服自己是冒牌货的心态">6. 你每天都要克服自己是「冒牌货」的心态</h2><p>编程似乎是所有「聪明」人都倾向于做的一种职业。除非你是个天才，否则你会像我一样，每天都会怀疑自己是个冒牌货。当你每天都经历这些的时候，你往往会想出一个办法来解决这个问题。对我来说，我一直把它当做学习新事物的动力。我已经学会了站在正确的角度看待这个问题，并且满足于每天都有的一点点进步。</p><h2 id="7-你必须有程序员以外的生活否则你只会沉迷于编程">7. 你必须有程序员以外的生活，否则你只会沉迷于编程</h2><p>有时你会宅在家里。然而，要成为一个快乐的程序员，你必须主动地在电脑屏幕之外寻找生活。你事业的成功往往取决于你遇到的人。当你是一个程序员时，社交网络是必不可少的。拥有程序员以外的生活对于防止自己沉溺于编程是至关重要的。当你编程是因为激情而不是被迫的时候，你就能做出最好的工作。</p><h2 id="8-如果你和其他人共同完成一个项目你会更快地学会编程">8. 如果你和其他人共同完成一个项目，你会更快地学会编程</h2><p>在你的职业生涯刚开始的时候，你会试图把自己封闭起来，阅读关于编程的书来建立你的计算机科学基础。你猜怎么着？如果你找到一个朋友一起合作，你会学习得更快。我在和其他小伙伴合作完成一个项目的过程中看完了编程书籍。当你和其他人一起合作时，你所有的程序缺点就会暴露出来，你的代码将受到批评。你将学会编写有效的代码，因为有人在监视你。你会想找出最好的方法去做事情，因为你的朋友也在学习。当你做程序员时，总有人在审查你的代码。你永远不会独自编程，所以你需要习惯这些。</p><h2 id="9-你不需要擅长数学和科学">9. 你不需要擅长数学和科学</h2><p>在科技行业，你会遇到各种超级程序员，他们在接受了一辈子的文科教育后发现编程的逻辑思维很有吸引力。有很多画家和作家在一边追求艺术，一边做着程序员。编程是一项艰苦的工作，做一个好的程序员所需要的只是坚持，任何人都可以通过编程书籍学习基础知识。很多人在这个行业工作了一段时间后就开始学数学了。最终，这些人甚至可以理解和实现复杂的算法，尽管他们并没有接受任何形式的正式数学教育。</p><h2 id="10-你需要成为一个全明星的学习者">10. 你需要成为一个全明星的「学习者」</h2><p>程序员是一个熟练的学习者。现在你可能不是一个大师级的学习者，但你会到达那一步的。有时候你的工作会要求你在六个月内学会三种编程语言，这就是技术创新的现状。作为程序员，我们每天都在学习。对我们来说，学习就像呼吸一样自然。如果你对每天的学习感到不耐烦，你必须强迫自己去习惯这一点。</p><h2 id="11-专注于完成你的项目">11. 专注于完成你的项目</h2><p>编码是真的会上瘾。在你的编程生涯中的某个时刻，你将经历一整晚的通宵编程。在完成目标之前，你不会想睡觉的。你会忘记吃饭、喝酒，甚至忘记从办公桌上起来，因为你的大脑处理了太多的信息。没关系，在做完后，到外面散散步，度个假吧。</p><h2 id="12-你会花费整天找一个小-bug">12. 你会花费整天找一个小 Bug</h2><p>大多数时候，在一个项目中，许多部分是相互依赖的。通常，你会发现除非你修复了一个潜伏在你系统中的小 Bug，否则你无法继续前进。作为一个程序员，除非你发现这个错误，否则你会对整个项目感到有压力，你将整天坐在电脑前寻找它，在找到它之前你将在晚上梦见代码。</p><h2 id="13-你将花大部分时间搜索没有人能告诉你的答案">13. 你将花大部分时间搜索没有人能告诉你的答案</h2><p>如果你用一种流行的语言编程，你将能够找到你在网上遇到的大多数问题的答案。但是，也有例外。有时，没有人遇到过你碰到的问题。在这种情况下，参考编程书籍和在四处询问通常会为您指明正确的方向。</p><h2 id="14-你会读一本设计模式书">14. 你会读一本设计模式书</h2><p>你是否毕业于最好的计算机院校关系不大。在每一个程序员的职业生涯中，总有一段时间你会坐下来，从头到尾地阅读「 Head First Design Patterns」。对于一个新手程序员来说，这可能是阅读得最多的书之一。那么，你还在等什么？把它捡起来，从头读到尾。</p><h2 id="15-你将学会专注于准确的拼写">15. 你将学会专注于准确的拼写</h2><p>在每一个程序员职业生涯中的某个时刻，您将用您最喜欢的语言编写了足够的代码，以便按照自己想要的方式来做事情。这包括变量、类甚至数据库中的表按照你自己的命名约定进行准确的编写。你将对此进行彻底的审查。你最不想看到的是一些因为你拼写错误而出现的 Bug。记住，如果理由足够，那么请专注于一件事情。但当你没有很好的理由而去做某件事，这可能只是重复性的行为。</p><h2 id="16-你会放弃">16. 你会放弃</h2><p>我放弃了多少次？我已经数不清了。有时你会碰到你无法解决的问题，有时候你会因为困难而想停止，有时候工作环境会让你想辞职。你的激情取决于你的坚持，这些正是考验你的时候。是留下还是离开？我每次都留下来了。有时，在几年没有写一行代码之后，我会作为一个准备好完成一个项目的新人回来。当你知道你热爱你的工作时，它会变成一个家，你会愿意为之冒险。</p><h2 id="17-重启你自己">17. 重启你自己</h2><p>如果你相信更高的力量，你可能会需要这个建议。我看到过很多人重新开始编程，通常他们都是因为热爱，与钱无关。当你看到一个人像你以前一样对编程乐在其中时，你是嫉妒的，你觉得你也不能放弃编码。然后，突然间，你又回到了一个项目中。你知道，在你的内心深处，你的生活和呼吸都离不开代码。这就是你知道自己是一个真正程序员的时刻。</p><h2 id="18-你将回到某种形式的学校学习正确的做事方式">18. 你将回到某种形式的「学校」学习「正确」的做事方式</h2><p>即使是从精英计算机科学专业硕士毕业的最好的程序员也会在工作后继续学习。事实上，在职培训是在大型科技公司工作的最佳福利之一。公司会给你提供「昂贵」的课程和研讨会，让你了解他们希望你使用的最新技术。如果可能，你在工作中学到的知识是不够的，你将参加许多在线编码学院，查看 YouTube 视频来提高你的技能。</p><h2 id="19-你将被一个你不想为之工作的人雇用">19. 你将被一个你不想为之工作的人雇用</h2><p>即使你是一个平庸的程序员，某些公司也会需要你的技能。当他们面试你时，请记住你也在面试他们。由于公司的文化，你可能会发现自己想对一个轻松的 offer 说「不」。作为一名程序员，你将工作很长时间，因此，找到一个文化和你契合的公司文化至关重要。愉快的心情能让你更好地工作。如果你的技能合适，其他公司也会来敲你的门，除非有必要，请不要随意跳槽。</p><h2 id="20-你会在技术面试中失败">20. 你会在技术面试中失败</h2><p>技术面试不是开玩笑。高级程序员经常为了好玩而编造技术面试问题。通常，由于某种原因，这些问题是非常困难的。如果你没有通过技术面试，那并不是世界末日，它并不能证明你没有编程能力，它只是在测试你的知识库，试着往好的方面看。如果你的人际交往能力出众，经理们会记住你的。如果他们喜欢你，而你不适合这个职位，他们可能还会打电话给你另一个职位。</p><h2 id="21-你会被告知你很棒">21. 你会被告知你很棒</h2><p>在你的职业生涯中，有时你会觉得自己是明星。依赖于你完成项目的经理会为了激励你，会告诉你特别伟大。你会觉得自己在世界的顶端。记住，保持脚踏实地。总是有新技术需要探索，总是有比你更好的新程序员。</p><h2 id="22-你会被告知你什么都不知道">22. 你会被告知你什么都不知道</h2><p>在你的职业生涯中，有时你会觉得自己什么都不知道。对某个项目感到沮丧的人会告诉你你什么都不知道。也许他们这样做是为了让你安顿下来。但是，你完全不应该否定自己。因为你知道的可能比你想象的要多得多。每过一天，你就会知道得比前一天多一点。一年后，人们会尊敬你的。请继续努力，一段时间之后，你甚至可能得到那个告诉你你什么都不知道的人的尊重。</p><h2 id="23-你会想和其他你钦佩的程序员竞争">23. 你会想和其他你钦佩的程序员竞争</h2><p>编程最棒的方面之一就是竞争。我喜欢和我崇拜的人一起编程。当你能编写一段让你欣赏的程序员肯定的代码时，你会像刚刚中了彩票一样开心。编程中的竞争是很有趣的，它并不是比谁最好，更多的是互相学习。</p><h2 id="24-你不明白你的同事刚刚说的话">24. 你不明白你的同事刚刚说的话</h2><p>在最开始，这可能每周或每月发生一次。在你的新编程工作中，你会不理解你的同事刚刚说的话。这可能有两个原因。一个可能的原因是，你就是无法理解他们的口音。在这种情况下，可以请另一个同事翻译。不能听懂别人的话并不羞耻，很可能其他同事也花了很多年才习惯这种口音。另一个原因是，你的同事刚刚说的话完全超出了你的想象。但这也没关系，毕竟，你的同事是专家。摆好椅子，请你的同事以图片的形式解释这一切。很可能，你需要一段时间去适应。</p><h2 id="25-看到去年写的乱七八糟的代码你会感到羞愧">25. 看到去年写的乱七八糟的代码你会感到羞愧</h2><p>这也是经常发生的。在最开始，我也因为代码不规范受到过批评。当时，设计很好且有着良好文档，但我是用一种难以阅读的语言写的。但直到现在，不管我多么努力，每年我仍然会找到一些乱七八糟的代码，这通常都是因为我想很快地完成工作。实际上这就是程序员的工作，我们不停地完善和修改各种代码。这并不羞耻。当你意识到它们是你写的的时候，后退一步，如果可以的话，好好地修改它。</p><h2 id="26-当你厌倦看代码时你将在你的数据库项目中躲避">26. 当你厌倦看代码时，你将在你的数据库项目中躲避</h2><p>当你在进行一次愉快的编程之旅时，可能会发生这种情况。你已经连续工作两个月了，你需要休息一下。但你喜欢这种当时的状态，所以你继续前进。然后您会发现 SQL 很有趣。你不明白为什么你看不进去一行代码。但不知何故，将数据放入数据库并将其取出，是一件令人愉快的事情。你陶醉于这种完全符合逻辑的简单语言。</p><h2 id="27-你对黑客又爱又恨">27. 你对黑客又爱又恨</h2><p>黑客攻击现在很常见。程序员在团队中互相竞争，在这个过程中，好几个小时你都在高度紧张地学习。此时的黑客攻击就像调味剂一样，你可能会非常喜欢。但有时，你会讨厌在高速敲键盘时被打断。你也会讨厌拥挤的办公室和喧嚣的活动。</p><h2 id="28-在阅读研究论文时你会认为你一个单词都看不懂">28. 在阅读研究论文时，你会认为你一个单词都看不懂</h2><p>你会说英语吗？好吧，大多数人的回答都是肯定的。但是，我向你保证，有时你会一遍又一遍地读一些研究论文，并意识到自己完全无法理解它们。对我来说，在我学会大学数学的课程之前，大多数关于算法的研究论文都像是没有意义的森林。然后，突然某一天，一切似乎都有了意义。</p><h2 id="29-你要买耳机">29. 你要买耳机</h2><p>在你的职业生涯中的某个时刻，当你全神贯注于你的代码时，你会意识到任何一种噪音都会阻碍你的感官。一个好的耳机可以消除外部噪音，这样在拥挤的办公室里你也会隔绝外部干扰。在某些时候，你也会发现听音乐可以帮助你编码。在我编码生涯的早期，我发现音乐的节奏有助于我流畅地编码。即使现在，我也会借助一些音乐来提高自己的生产力。</p><h2 id="30-你将去一个新的地方如果幸运的话它将是拉斯维加斯">30. 你将去一个新的地方，如果幸运的话，它将是拉斯维加斯</h2><p>在你职业生涯中的某个阶段，你会成为对公司非常重要的核心开发人员。这时，你可能会被邀请到异地和其它技术人员进行交流。高层管理人员可能会利用这个机会了解你。请别误会，这并不代表着你可以无忧无虑地喝醉酒了，而是你和你的同龄人交往和交流的好机会。如果你幸运的话，活动将会在拉斯维加斯。有时，还会有其他公司的技术专家来参加这些活动。</p><blockquote><p>来源：雷锋网</p><p>原文：<a href="http://t.cn/AiY7TQ9g" target="_blank" rel="noopener">http://t.cn/AiY7TQ9g</a></p><p>译文：<a href="http://t.cn/AiY7T3uX" target="_blank" rel="noopener">http://t.cn/AiY7T3uX</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文作者 Jun Wu 有着编程和统计学背景，她在 15 年前就是一名程序员。近日，她分享了给程序员的 30 条心得建议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你想成为一名程序员，这个建议可以帮助你走上正确的道路。&lt;/p&gt;
&lt;p&gt;程序员不是一个容易的职业，每年都有许多人从国内顶尖院校的计算机科学专业毕业，这是任何人都能从事的竞争最大的职业之一。同时，编程也是令人兴奋的。随着技术的进步，工业界每天都有创新。编程对于热爱它的人来说是一项充满激情的事业。&lt;/p&gt;
&lt;p&gt;当我 15 年前开始做程序员的时候，我希望有人能告诉我下面清单上的一切建议。这个清单可以为所有新手程序员节省大量的时间和精力，并且，你可以在编程职业发展的整个过程中都参考这些建议。即使这里面有些观点现在可能与你无关，但总有一天你会看到其中的智慧。&lt;/p&gt;
&lt;p&gt;作为一名程序员，你正处在伟大的顶点。&lt;/p&gt;
&lt;p&gt;你只要对自己要走的道路稍有了解就可以开始冒险了。&lt;/p&gt;
&lt;h2 id=&quot;1-你不需要学位，但你需要知识&quot;&gt;1. 你不需要学位，但你需要知识&lt;/h2&gt;
&lt;p&gt;我和许多没有计算机科学硕士学位或计算机科学本科学位的程序员一起工作。编程是少数不依赖学位的职业之一。然而，编程是一项知识密集型的职业。如果你想开始编程生涯，这十本基础书籍你必读的。这十本书将涵盖计算机科学的基本概念以及如何在项目团队中工作。它们可以为你的技术打下坚实的基础，让你对基本概念有一个深刻的理解，并且让你有能力去编写功能性的代码，顺利进行技术面试并与同事交流。&lt;/p&gt;
&lt;h2 id=&quot;2-创造性是提高解决编程问题能力的重要因素&quot;&gt;2. 创造性是提高解决编程问题能力的重要因素&lt;/h2&gt;
&lt;p&gt;大多数人都有这样的认知：编程都是关于分析和解决问题的技能。这个观点并不是完全正确的，编程也非常需要创造力。通常，你可以用很多方法编写给定的代码。当你拥有了创造力，就能设计出最简单、最有效的代码。&lt;/p&gt;
&lt;h2 id=&quot;3-不要什么都学，精通一部分知识&quot;&gt;3. 不要什么都学，精通一部分知识&lt;/h2&gt;
&lt;p&gt;编程语言有数百种。有一些编程领域有着明确的职业道路：Web 开发人员、前端开发人员、后端开发人员、软件工程师、数据库开发人员等。你需要决定要成为哪种开发人员，然后学习该职位所需的所有技术和技能。&lt;/p&gt;
&lt;h2 id=&quot;4-你不需要活的像机器人&quot;&gt;4. 你不需要活的像机器人&lt;/h2&gt;
&lt;p&gt;记住，你首先是一个人，其次才是程序员。当您第一次开始编程时，很容易在代码中迷失方向。有时我在完成项目的所有任务之前都不离开电脑。但是你是一个人，你需要笑，哭，减压，和人交谈。管理好你的生活，最大限度地提高工作之外的兴趣爱好，这将为程序员的工作带来更多的创造力。&lt;/p&gt;
&lt;h2 id=&quot;5-编程就是应用知识而不是为了记忆&quot;&gt;5. 编程就是应用知识而不是为了记忆&lt;/h2&gt;
&lt;p&gt;与研究不同，在研究中，你会发明和创造新的知识领域，但编程就是应用现有的知识。书籍、研究论文、在线文章和学习视频成为您经常使用的资源。不需要记住任何东西。你总是可以搜索资源来找到答案。随着你处理的项目越来越多，这些记忆会自动自然地出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="编程" scheme="https://www.hi-linux.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
