<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇妙的 Linux 世界</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2024-06-03T09:31:47.869Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『极客视界』一站式科技达人综合资讯指南和神秘宝箱，等你来开启</title>
    <link href="https://www.hi-linux.com/posts/22000.html"/>
    <id>https://www.hi-linux.com/posts/22000.html</id>
    <published>2050-06-18T01:00:00.000Z</published>
    <updated>2024-06-03T09:31:47.869Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="️-极客视界科技达人的综合资讯指南">🛠️ 『极客视界』科技达人的综合资讯指南</span></h2><p>你是否常常为寻找最新的技术资讯、工具和资源而感到困扰？或者每次开发时都需要开启无数个标签页，才能找到所需的工具和信息？</p><p>别担心，让我为你介绍一个好地方『极客视界』，这是每位科技达人的福音、必备的综合资讯指南。</p><p>『极客视界』提供了一站式的服务，它包罗万象、功能丰富，直接满足你从资讯获取到开发辅助的全部需求。</p><p>从 GitHub 热榜到 PDF 工具箱，从实时新闻资讯、技术文章到虚拟临时邮箱，样样俱全！</p><a id="more"></a><h3><span id="极客视界">🤓 极客视界</span></h3><p>『极客视界』是一个综合科技资讯的枢纽。如果你喜欢紧跟最新的科技动态、追踪热门项目，或是希望时刻了解技术动向，那这个板块绝对不容错过。</p><h4><span id="github-热榜">🏆 Github 热榜</span></h4><p>每天都有成千上万的项目在 GitHub 上更新，又如何挑选出最热门、最有趣的项目呢？</p><p>别担心，『极客视界』已经为你做了筛选。我们提供的每日更新的 GitHub 热门项目榜单，每天看看就知道哪些项目正火热。</p><p>实时获取最新最火的开源项目，助你快速了解哪些项目正在迅速蹿红，也可以看看有多少大牛在关注同样的项目，再也不用费力翻找。</p><h4><span id="最新-it-新闻和技术文章">📰 最新 IT 新闻和技术文章</span></h4><p>获取行业动态和最新资讯是每个极客的日常标配。在『极客视界』，你能找到最新的 IT 新闻和技术文章。</p><p>我们涵盖了从前沿技术到开发实战，从行业大事件到新兴趋势的一切内容。</p><p>不仅内容丰富，还有专业的编辑团队为你推荐精选文章，让你在最短时间内掌握最有价值的信息。</p><h4><span id="黑客新闻">🧑‍💻 黑客新闻</span></h4><p>这里提供最新、最全的黑客新闻，覆盖广泛的领域。无论是安全漏洞、趋势分析，还是开发者的门道，这里都有。</p><h4><span id="github-热门仓库状态跟踪">📈 Github 热门仓库状态跟踪</span></h4><p>对你关注的热门仓库进行状态跟踪，实时获取更新信息。再也无须手动查询，每天都能知道自己心仪的仓库发生了哪些变化。</p><h4><span id="服务监控">💚 服务监控</span></h4><p>对各种网络服务进行监控，只需轻松设置，关键数据一目了然。实时掌握各种关注服务的状态，确保系统平稳运行。</p><h3><span id="极客秘境">🗞 极客秘境</span></h3><p>这里是技术人的宝藏，包括最新的 IT 新闻、技术文章和深度分析，兼具广度和深度。</p><h4><span id="ai-新世界">🤖 AI 新世界</span></h4><p>这里聚焦人工智能领域的最新资讯和技术动态，想知道 AI 的新突破、新应用，或者最新的研究成果，这里一站搞定。</p><h4><span id="科技周刊汇">📅 科技周刊汇</span></h4><p>每周汇总最具价值的科技新闻，如果你是一周一更新的节奏党，这里绝对不会让你错过任何重要信息。</p><h4><span id="数码潮流">💻 数码潮流</span></h4><p>最新数码产品的资讯和评测，从手机到电脑再到各种智能设备。让你在购买之前就对产品有全面的了解，做个不踩雷的科技买手。</p><h4><span id="知乎热榜">🌐 知乎热榜</span></h4><p>集成知乎的科技热榜，看看大家都在讨论些什么热门话题。知乎神仙们的回答一定会让你豁然开朗。</p><h4><span id="it-之家热榜">🏠 IT 之家热榜</span></h4><p>再也不会错过 IT 之家发布的有趣新闻和深度文章，适合 IT 人必读的榜单，全方位提升知识水平。</p><h4><span id="稀土掘金文章榜">💡 稀土掘金文章榜</span></h4><p>聚集稀土掘金平台的热门技术文章，无论是新工具、新技术，还是各种开发干货，这里都值得一看。</p><h4><span id="hellogithub-热门仓库">🚀 HelloGithub 热门仓库</span></h4><p>专业团队挑选和介绍的 Github 热门仓库，涵盖广泛的编程语言和框架。每期精选，你一定能找到自己感兴趣的项目。</p><h3><span id="it-人必备工具箱">🧰 IT 人必备工具箱</span></h3><p>『IT 人必备工具箱』 是每一位 IT 人都不可或缺的资源宝库，里面收纳着各种专注于技术领域的优质资源和实用工具。</p><p>它如同一座巨大的数字图书馆，为 IT 从业者提供了丰富的资讯和工具。</p><p>让他们在数字世界中驰骋自如，无论是编程开发、网络安全、数据分析还是人工智能。</p><p>这个工具箱都汇聚了各种经典和前沿的资源，为 IT 人士解决难题、提升技能提供了强大的支持。</p><p>无论是初学者还是资深技术大牛，都可以从中汲取灵感，探索未知，不断成长。</p><h3><span id="开发工具箱">🧑‍💻 开发工具箱</span></h3><p>作为开发者，你一定会喜欢我们的开发工具箱。</p><p>这里囊括了各种实用的开发小工具，涵盖了从代码编辑、JSON 解析器、网络调试工具、正则表达式测试器等的一切，应有尽有。</p><p>所有的工具都经过精心挑选和测试，确保能在关键时刻帮到你。减少你在开发过程中寻找工具的时间，提升工作效率。</p><h3><span id="代码图美化">🎨 代码图美化</span></h3><p>代码不仅要运行得好，还要看得美。我们的代码图美化工具，可以将你的一段代码精美地呈现出来。</p><p>它可以帮助你将代码片段转化成美观的图片，它支持高度定制，照顾到每一个细节，让你的代码更具表现力。</p><p>不论是分享给团队成员，还是展示在个人博客上，漂亮的代码图总能让你的工作成果更上一层楼。</p><h3><span id="ip-工具箱">🌍 IP 工具箱</span></h3><p>无论是开发还是运维，IP 信息总是绕不开的问题。『极客视界』为你准备了全面的 IP 工具箱，涵盖从 IP 查找、IP 段查询到地理位置转换等多种功能，让你轻松搞定所有与 IP 相关的难题。</p><p>对于网络管理员和开发者来说，这些功能在日常工作中非常实用。</p><h3><span id="pdf-工具箱">📄 PDF 工具箱</span></h3><p>处理 PDF 文件常常让人头疼，但在『极客视界』这一切都不是问题。我们提供了全方位的 PDF 工具箱，包括 PDF 转换、合并、拆分、压缩等多种功能。</p><p>不管你的需求是什么，这里都有合适的工具帮你搞定，一站解决所有需求，让你轻松应对各种文档格式的转换问题。</p><h3><span id="今日热榜">🔥 今日热榜</span></h3><p>想知道今天哪些内容最火爆？来看看我们的今日热榜吧！这里汇集了各大平台的热门内容，如微博、知乎、抖音等。</p><p>无论是新闻、帖子、视频还是其他内容，最受关注的总能在这里找到。不用再费力刷各大社交媒体，只需一站尽知天下热点，轻松做个潮流达人。</p><h3><span id="虚拟临时邮箱">📫 虚拟临时邮箱</span></h3><p>注册各种网站服务时，常常会担心邮箱被垃圾信息淹没？</p><p>使用我们的虚拟临时邮箱功能吧！它能生成临时邮件地址，帮你保护真实邮箱免受打扰。使用简单方便，一键生成，特别适合短期注册需求。</p><h3><span id="️-手绘画板">🖌️ 手绘画板</span></h3><p>需要临时记录灵感或进行手绘创作？『极客视界』的手绘画板功能正是为你准备的。</p><p>无需下载任何应用，在线即可进行手绘，支持多种笔刷和颜色选择，无论是画草图还是进行简单设计，这里都能得心应手。</p><h3><span id="视频下载">📥 视频下载</span></h3><p>在线遇到好视频想下载，却苦于找不到合适的工具？</p><p>我们提供的在线视频下载工具可以帮你解决这个问题。支持多种视频平台，下载速度快，操作简便，让你轻松保存喜欢的视频内容。</p><h3><span id="️-超级终端">🖥️ 超级终端</span></h3><p>如果你经常需要在的终端工作，这个超级终端你一定会爱不释手。它支持各种命令输出，让你看上去很酷而忙碌，是极客必备的利器。</p><h2><span id="为什么选择极客视界">🤔 为什么选择『极客视界』？</span></h2><h3><span id="集成化一站式服务">🌅 集成化，一站式服务</span></h3><p>无需再奔波于各个网站寻找工具和资讯，『极客视界』将所有常用的开发工具和最新资讯集成在一个平台上，一站式解决你的所有需求。</p><h3><span id="实用性强">📝 实用性强</span></h3><p>我们精心挑选每一项功能和工具，确保它们在实际工作中有用且好用，节省你的时间，提升工作效率。</p><h3><span id="持续更新">📈 持续更新</span></h3><p>科技的发展日新月异，我们的团队时刻关注行业动态，不断更新功能和内容，确保你在『极客视界』获取到最新、最热的资讯和工具。</p><h2><span id="如何开始">🚀 如何开始？</span></h2><p>体验所有这些功能只需一个简单的步骤：访问 <a href="https://bestgeek.org" target="_blank" rel="noopener">https://bestgeek.org</a> 开始你的极客之旅吧！</p><p>然后根据你的需求选择相应的分类开始探索吧！无论你是开发者、设计师还是普通的科技爱好者，『极客视界』都能为你提供你需要的一切。</p><h2><span id="结语">🎉 结语</span></h2><p>上述功能仅仅是『极客视界』的一部分，我们致力于为每一个热爱科技的朋友提供全面的资讯与工具支持。</p><p>『极客视界』不仅是功能齐全的工具和资讯平台，更是每个极客共同的家园。</p><p>在这里，你可以找到志同道合的伙伴，获取最新的技术资讯和最实用的开发工具。让我们一起在这个充满科技乐趣的视界里遨游吧！</p><p>赶快收藏 <a href="https://bestgeek.org" target="_blank" rel="noopener">极客视界</a>，开启你的科技之旅吧！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;🛠️-『极客视界』科技达人的综合资讯指南&quot;&gt;🛠️ 『极客视界』科技达人的综合资讯指南&lt;/h2&gt;
&lt;p&gt;你是否常常为寻找最新的技术资讯、工具和资源而感到困扰？或者每次开发时都需要开启无数个标签页，才能找到所需的工具和信息？&lt;/p&gt;
&lt;p&gt;别担心，让我为你介绍一个好地方『极客视界』，这是每位科技达人的福音、必备的综合资讯指南。&lt;/p&gt;
&lt;p&gt;『极客视界』提供了一站式的服务，它包罗万象、功能丰富，直接满足你从资讯获取到开发辅助的全部需求。&lt;/p&gt;
&lt;p&gt;从 GitHub 热榜到 PDF 工具箱，从实时新闻资讯、技术文章到虚拟临时邮箱，样样俱全！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="IT" scheme="https://www.hi-linux.com/tags/IT/"/>
    
      <category term="程序员" scheme="https://www.hi-linux.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>『IT 人必备工具箱』一份属于你的数字宝藏，期待你的支持！</title>
    <link href="https://www.hi-linux.com/posts/2894.html"/>
    <id>https://www.hi-linux.com/posts/2894.html</id>
    <published>2050-03-20T01:00:00.000Z</published>
    <updated>2025-01-11T16:02:28.871Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>嘿，小伙伴们！还记得你第一次发现 「IT 人必备工具箱」时的那种惊喜吗？就像打开了一扇通往数字宝藏的门，里面满满的都是你在工作和生活中需要的利器。</p><p>从 AI 工具到代码生成，从 UI 设计到网络安全，每一个工具都像专为你量身打造的秘密武器。</p><p>今天，我想和你聊聊这个网站背后的故事，以及为什么你的支持对我们来说如此重要。</p><a id="more"></a><h2><span id="网站的价值一个-it-人的瑞士军刀"><strong>网站的价值：一个 IT 人的瑞士军刀</strong></span></h2><blockquote><p>『IT 人必备工具箱』是一个专注于 IT 人相关的优质资源分享导航站，包含 AI、翻译、编程、设计、Linux、网络、云原生、安全等多款实用又好玩的应用。</p><p>我们的目标是：帮助 IT 人发现更多有价值的优质资源。</p><p>🏷️ 网站地址：<a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a></p></blockquote><p><img src="https://img.hi-linux.com/staticfile/it-tools-20250111-2025-01-11-efdRj5.webp" alt></p><p>当你在项目卡壳时，当你为寻找好用的工具而筋疲力尽时，「IT 人必备工具箱」就像是你的救星。它不仅节省了你宝贵的时间，还帮你解决了一个又一个棘手的问题。就像瑞士军刀一样，这里集合了多种功能，能满足你各种场景的需求。</p><p>用户们经常对我们说：“这个网站简直就是我的秘密武器！”</p><p>是的，我们希望让每一个访问者都能感受到这种力量。</p><h2><span id="运营挑战一座快被撑爆的服务器"><strong>运营挑战：一座快被撑爆的服务器</strong></span></h2><p>但你知道吗？随着越来越多的用户涌入，我们的服务器已经在 “喘气” 了。</p><p>想象一下，一辆小汽车要承载成百上千的人，这压力未免也太大了吧？</p><p>服务器的费用在持续飙升，而为了保证大家的访问速度和体验，我们不断升级硬件。这些都需要大量的资金，而我们仍然坚持保持网站免费，完全靠热爱和激情在支撑。</p><h2><span id="为什么需要你的支持"><strong>为什么需要你的支持？</strong></span></h2><p>我们希望一直保持 「IT 人必备工具箱」的公益性，不设置任何访问门槛，让每一个人都能免费使用这些工具。</p><p>但这条路并不容易，尤其是在面对高昂的运营成本时。</p><p>你的支持，不仅仅是帮助我们分摊服务器费用，更是对我们工作的最大认可。每一份支持，都是一股推动我们前进的力量。</p><h2><span id="打赏的影响你的一点心意成就我们的未来"><strong>打赏的影响：你的一点心意，成就我们的未来</strong></span></h2><p>你可能会想：“我的一小笔支持真的有用吗？” 答案是：当然！</p><p>试想一下，当成千上万的 IT人 都愿意贡献一点点心意，这些微小的支持就会汇聚成一股强大的力量，足以让我们继续为你提供免费、优质的服务。</p><p>你的支持不仅帮助我们解决了燃眉之急，还为我们未来的工具开发和内容优化提供了可能。</p><h2><span id="如何进行打赏简单到你想不到"><strong>如何进行打赏，简单到你想不到！</strong></span></h2><p>打赏的操作超级简单！以下是具体步骤：</p><ul><li>方法一</li></ul><ol><li>打开微信，扫描下面的打赏码；</li><li>选择或输入金额，确认支付；</li><li>大功告成，你已经成为我们的英雄了！</li></ol><p><img src="https://img.hi-linux.com/staticfile/341A73F64x01028-2025-01-09-XR77Iv.jpg" alt></p><ul><li>方法二</li></ul><ol><li>点击文末赞赏按钮；</li><li>选择或输入金额，确认支付；</li><li>大功告成，你已经成为我们的英雄了！</li></ol><h2><span id="打赏的透明性每一分钱都花在刀刃上"><strong>打赏的透明性：每一分钱都花在刀刃上</strong></span></h2><p>我们深知，作为一名支持者，你最关心的是你的支持是否被合理利用。</p><p>因此，我们承诺资金使用完全透明，每一笔打赏都会被记录并定期公开。</p><h2><span id="打赏的回报用心感谢每一位支持者"><strong>打赏的回报：用心感谢每一位支持者</strong></span></h2><p>作为对你支持的感谢，我们为打赏者准备了一些特别的福利，比如：</p><ul><li>提前体验新上线的工具；</li><li>网站上特别的致谢页面，记录你的名字（可匿名选择）；</li><li>专享的技术资源包，助你在工作中如虎添翼。</li></ul><p>你的支持不仅帮助了我们，也让你成为了社区的一部分，和我们一起成长。</p><h2><span id="社区的力量一个属于我们的-it-乌托邦"><strong>社区的力量：一个属于我们的 IT 乌托邦</strong></span></h2><p>我们相信，「IT 人必备工具箱」不仅仅是一个网站，更是一个社区。它是一个连接 IT 人的桥梁，在这里，我们可以分享知识，交流经验，甚至结识志同道合的伙伴。</p><p>你的支持，让这个社区变得更温暖、更强大。</p><h2><span id="用户的声音听听他们怎么说"><strong>用户的声音：听听他们怎么说</strong></span></h2><p>摘选自用户留言：</p><blockquote><p>“自从用了这个网站，我的工作效率提升了好几个档次，真的太感谢了！”</p></blockquote><blockquote><p>“支持你们是应该的，毕竟这么好的资源免费提供，太不容易了。”</p></blockquote><p>这样的声音每天都在我们耳边回响，正是这些鼓励支撑着我们一路走来。</p><h2><span id="未来的路我们一起走"><strong>未来的路，我们一起走</strong></span></h2><p>我们深知，只有持续的努力和用户的支持，才能让「IT 人必备工具箱」走得更远。</p><p>未来，我们将继续优化现有资源，开发更多工具，力争成为每一位 IT 人离不开的数字助手。</p><p>所以，如果你觉得我们做的事情有意义，请伸出援手，成为我们前行路上的一份力量。</p><p>你的支持，不仅是对我们的认可，更是对整个 IT 社区的投资。</p><h2><span id="常见问题解答"><strong>常见问题解答</strong></span></h2><ol><li><p><strong>打赏是否安全？</strong></p><ul><li>完全安全！我们采用了知名支付平台，你的个人信息绝对不会被泄露。</li></ul></li><li><p><strong>我能否在网站上看到我的贡献？</strong></p><ul><li>当然可以！我们会在 “支持者墙” 上显示每一位打赏者的名字（或匿名昵称），并表达最诚挚的感谢。</li></ul></li><li><p><strong>打赏的最低金额是多少？</strong></p><ul><li>没有最低限制！无论是一杯咖啡的钱，还是一顿饭的费用，每一份支持都对我们意义重大。</li></ul></li><li><p><strong>会有商业广告植入吗？</strong></p><ul><li>不会！我们承诺保持网站的公益性，绝不会让广告破坏你的使用体验。</li></ul></li><li><p><strong>我能否推荐新的工具加入网站？</strong></p><ul><li>当然可以！我们非常欢迎用户的建议，如果你有好工具推荐，请随时告诉我们！</li></ul></li></ol><h2><span id="最后的一句话"><strong>最后的一句话</strong></span></h2><p>「IT 人必备工具箱」是我们的，也是你的。让我们携手，让这个充满可能性的数字宝藏变得更强大！</p><p>感谢每一位支持者，你们的善意将成为这个社区最闪亮的光芒。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嘿，小伙伴们！还记得你第一次发现 「IT 人必备工具箱」时的那种惊喜吗？就像打开了一扇通往数字宝藏的门，里面满满的都是你在工作和生活中需要的利器。&lt;/p&gt;
&lt;p&gt;从 AI 工具到代码生成，从 UI 设计到网络安全，每一个工具都像专为你量身打造的秘密武器。&lt;/p&gt;
&lt;p&gt;今天，我想和你聊聊这个网站背后的故事，以及为什么你的支持对我们来说如此重要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>『IT 人员必备工具箱』：一个专注于 IT 人的优质资源分享导航站</title>
    <link href="https://www.hi-linux.com/posts/53504.html"/>
    <id>https://www.hi-linux.com/posts/53504.html</id>
    <published>2050-03-18T01:00:00.000Z</published>
    <updated>2024-03-14T03:05:50.391Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』是一个专注于 IT 人优质资源分享的导航站，包含大量好玩又实用的 AI、翻译、编程、设计、Linux、网络、云原生、安全等多款应用。</p><p>🏷️  网站地址：<a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a></p><p><img src="https://img.hi-linux.com/staticfile/Tweelet00-2024-03-14-n0S5jR.webp" alt="全站预览图"></p><p>我们的目标是帮助更多 IT 人发现有价值的优质资源，让更多人受益。</p><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』也可以推荐你喜欢的软件和网站呢！如果你有什么好玩有趣又实用的酷软趣站，快『<a href="https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz" target="_blank" rel="noopener">推荐</a>』给我们吧！</p><p>🏷️  趣站酷软推荐收集表: <a href="https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz" target="_blank" rel="noopener">https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz</a></p><a id="more"></a><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』部分截图展示：</p><p><img src="https://img.hi-linux.com/staticfile/Tweelet01-2024-03-14-9hHDLK.png" alt="实用工具"><br><img src="https://img.hi-linux.com/staticfile/Tweelet02-2024-03-14-ejfZrm.png" alt="奇妙的 Linux 世界 + 搜索引擎 + 新闻资讯"><br><img src="https://img.hi-linux.com/staticfile/Tweelet03-2024-03-14-ZkjPxQ.png" alt="电子邮件 + 出行服务 + AI 翻译利器"><br><img src="https://img.hi-linux.com/staticfile/Tweelet04-2024-03-14-NbfprZ.png" alt="AI 新世界 + 云服务"><br><img src="https://img.hi-linux.com/staticfile/Tweelet05-2024-03-14-xTbQV6.png" alt="编程开发"><br><img src="https://img.hi-linux.com/staticfile/Tweelet06-2024-03-14-OvFNBk.png" alt="GitHub 热榜 + 网络调试"><br><img src="https://img.hi-linux.com/staticfile/Tweelet07-2024-03-14-bluwgD.png" alt="绘图设计 + 镜像加速"><br><img src="https://img.hi-linux.com/staticfile/Tweelet08-2024-03-14-G4HEGV.png" alt="云原生容器化 + 安全相关 + 玩转 NixOS + 博客网摘"><br><img src="https://img.hi-linux.com/staticfile/Tweelet09-2024-03-14-FjDHJs.png" alt="职来职往 + 光影时刻 + 音乐之声"><br><img src="https://img.hi-linux.com/staticfile/Tweelet10-2024-03-14-3W7reF.png" alt="趣站酷软"></p><p>📕 关注『<a href="https://mp.weixin.qq.com/s/8iRVr_IN3jB3MnmAdgAOoQ" target="_blank" rel="noopener">奇妙的 Linux 世界</a>』公众号，带你开启有趣新生活！更多好用好玩的软件资源，可访问 <a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a> 免费获取。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IT 人员必备工具箱&lt;/a&gt;』是一个专注于 IT 人优质资源分享的导航站，包含大量好玩又实用的 AI、翻译、编程、设计、Linux、网络、云原生、安全等多款应用。&lt;/p&gt;
&lt;p&gt;🏷️  网站地址：&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://666666.dev&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/Tweelet00-2024-03-14-n0S5jR.webp&quot; alt=&quot;全站预览图&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们的目标是帮助更多 IT 人发现有价值的优质资源，让更多人受益。&lt;/p&gt;
&lt;p&gt;『&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IT 人员必备工具箱&lt;/a&gt;』也可以推荐你喜欢的软件和网站呢！如果你有什么好玩有趣又实用的酷软趣站，快『&lt;a href=&quot;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;推荐&lt;/a&gt;』给我们吧！&lt;/p&gt;
&lt;p&gt;🏷️  趣站酷软推荐收集表: &lt;a href=&quot;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>掌握这 9 个 IT 新技术：让你轻松驾驭技术浪潮，成为团队核心，轻松逆袭职场！</title>
    <link href="https://www.hi-linux.com/posts/51647.html"/>
    <id>https://www.hi-linux.com/posts/51647.html</id>
    <published>2035-01-08T01:00:00.000Z</published>
    <updated>2025-01-09T04:11:58.713Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="1-引言">1. 引言</span></h2><p>大家好！在这个数字化飞速发展的时代，技术的每一次变革都可能影响您的业务成败。</p><p>想象一下，有一位经验丰富的技术专家在您身边，为您指明前行的方向，帮助您避开潜在的陷阱，最终实现业务目标。</p><p>我正是您在技术迷宫中最值得信赖的向导。无论您是刚起步的创业者，还是成熟企业的决策者。选择我，就是选择了一条通往成功的捷径。</p><h2><span id="2-我的专业背景">2. 我的专业背景</span></h2><p>我是一名拥有 20+ 年丰富经验的 IT 技术专家。在我的职业生涯中见证了互联网技术的飞速发展，从最初的简单网站到如今复杂的云原生应用，我始终保持着对新技术的热情和学习。</p><p>多年来，我参与并主导了众多大型项目的系统架构设计和实施。为各大企业提供了稳定、高效、安全的 IT 基础设施支持。</p><p>在云计算领域，我对阿里云、腾讯云、AWS、GCP 等主流公有云平台了如指掌。我的深厚技术背景使我能够帮助您充分利用云计算的优势，实现业务的灵活性与可扩展性。</p><p>在容器化与编排技术方面，我始终走在技术前沿。精通 Docker 与 Kubernetes，能够帮助您设计和实施高可用的服务器架构，实现应用的容器化部署，提升系统的可靠性与可扩展性。</p><p>作为一名 Linux 专家，我精通各种 Linux 发行版的安装、系统管理、网络配置、安全加固、性能调优、监控与故障排除等，我能为您提供专业的解决方案，确保您的系统高效运行。</p><a id="more"></a><h2><span id="21-我的技术栈">2.1 我的技术栈</span></h2><p>我积累了丰富的软件开发与互联网系统运维经验。这不仅意味着我能构建高效的软件，还能确保它在复杂的网络环境中稳定运行。我的技术栈涵盖了现代 IT 基础设施的各个方面,包括但不限于:</p><h3><span id="211-web-服务器和反向代理">2.1.1 Web 服务器和反向代理</span></h3><p>精通配置和优化各种 Web 服务器和反向代理,包括:</p><ul><li>Nginx</li><li>Lighttpd</li><li>HAProxy</li><li>Traefik</li><li>Envoy</li><li>Apache HTTP Server</li><li>…</li></ul><p>这些技能使我能够为不同规模和需求的项目选择最合适的解决方案，并进行高效的负载均衡和流量管理。</p><h3><span id="212-数据库管理">2.1.2 数据库管理</span></h3><p>具备管理各种主流关系型和非关系型数据库的专业知识,包括:</p><ul><li>MySQL/MariaDB</li><li>PostgreSQL</li><li>MongoDB</li><li>Redis</li><li>Elasticsearch</li><li>Cassandra</li><li>HBase</li><li>…</li></ul><p>这些技能使我能够进行复杂的数据库优化、备份恢复、高可用配置和性能调优等。</p><h3><span id="213-消息队列和流处理">2.1.3 消息队列和流处理</span></h3><p>在分布式系统中，熟练使用和管理各种消息队列和流处理平台:</p><ul><li>RabbitMQ</li><li>Apache Kafka</li><li>Apache Pulsar</li><li>ZeroMQ</li><li>…</li></ul><p>这些技能使我能够设计和实现高吞吐量、低延迟的数据流处理系统。</p><h3><span id="214-监控和日志管理">2.1.4 监控和日志管理</span></h3><p>精通各种监控和日志管理工具，能够构建全面的系统可观测性解决方案:</p><ul><li>Prometheus + Grafana</li><li>ELK Stack (Elasticsearch, Logstash, Kibana)</li><li>Zabbix</li><li>Nagios</li><li>Datadog</li><li>New Relic</li><li>…</li></ul><p>这些技能使我能够及时发现和解决潜在的系统问题，确保系统的高可用性。</p><h3><span id="215-配置管理和自动化">2.1.5 配置管理和自动化</span></h3><p>熟练使用各种配置管理和自动化工具，提高系统管理的效率和一致性:</p><ul><li>Ansible</li><li>Puppet</li><li>Chef</li><li>SaltStack</li><li>Terraform</li><li>…</li></ul><p>这些技能使我能够实现基础设施即代码(IaC)，大大提高了系统部署和管理的效率。</p><h3><span id="216-容器化和编排">2.1.6 容器化和编排</span></h3><p>在容器化技术方面，不仅精通 Docker 和 Containerd 等，还熟练掌握了各种容器编排平台:</p><ul><li>Kubernetes</li><li>K3s</li><li>Docker Swarm</li><li>Nomad</li><li>…</li></ul><p>这些技能使我能够设计和实施复杂的微服务架构，并确保其高可用性和可扩展性。</p><h3><span id="217-cicd-和-devops">2.1.7 CI/CD 和 DevOps</span></h3><p>具备丰富的持续集成和持续部署(CI/CD)经验，能熟练使用:</p><ul><li>Jenkins</li><li>GitLab CI</li><li>Travis CI</li><li>ArgoCD</li><li>…</li></ul><p>这些技能使我能够构建高效的 DevOps 流程，加速软件交付并提高代码质量。</p><h3><span id="218-网络和安全">2.1.8 网络和安全</span></h3><p>深入了解网络协议和安全最佳实践，能够:</p><ul><li>配置和管理防火墙(如：Iptables、Firewalld 等)</li><li>实施 VPN 解决方案(如：OpenVPN、WireGuard、Headscale、Tailscale 等)</li><li>设置入侵检测系统(IDS)和入侵防御系统(IPS)</li><li>进行网络故障排除和性能优化</li><li>…</li></ul><p>这些技能确保我管理的系统不仅高效，而且安全可靠。</p><h3><span id="219-高可用性和灾难恢复">2.1.9 高可用性和灾难恢复</span></h3><p>有丰富的经验在设计和实施高可用性解决方案，包括:</p><ul><li>负载均衡集群</li><li>数据库主从复制和故障转移</li><li>分布式文件系统(如：GlusterFS, Ceph)</li><li>灾难恢复策略和实施</li><li>…</li></ul><p>这些技能确保了我管理的系统能够在各种故障情况下保持运行，最大限度地减少停机时间。</p><p>通过这些广泛而深入的技术能力，我能够为各种规模和复杂度的项目提供全面的解决方案。</p><p>从系统架构设计到日常运维管理，都能够得心应手。无论是传统的单体应用还是现代的微服务架构，我都有能力构建和维护高性能、高可用、安全可靠的系统。</p><h2><span id="3-我的服务内容">3. 我的服务内容</span></h2><h3><span id="31-技术咨询">3.1 技术咨询</span></h3><p>我提供深入的技术咨询服务，帮助您理解当前的技术趋势，评估不同的技术选项，并为您的特定需求推荐最佳解决方案。</p><h3><span id="32-系统架构设计">3.2 系统架构设计</span></h3><p>我可以帮助您设计可扩展、高性能且安全的系统架构，确保您的 IT 基础设施能够支持您的业务增长。</p><h3><span id="33-性能优化">3.3 性能优化</span></h3><p>运用先进的工具和技术，我将对您的系统进行全面的性能分析，找出瓶颈，并实施优化措施，提升系统的整体性能。</p><h3><span id="34-问题排查与解决">3.4 问题排查与解决</span></h3><p>当您遇到技术难题时，我是您可以依赖的专家。能够快速诊断问题并提供有效的解决方案，让您高枕无忧。</p><h3><span id="35-云迁移与部署">3.5 云迁移与部署</span></h3><p>我可以帮助您平稳地将业务迁移到云平台，或在云环境中部署新的应用和服务，充分利用云计算的优势。</p><h3><span id="36-更多">3.6 更多…</span></h3><p>你需要的一切定制化服务。</p><h2><span id="4-为什么选择我的服务">4. 为什么选择我的服务？</span></h2><h3><span id="41-经验丰富值得信赖">4.1 经验丰富，值得信赖</span></h3><p>20+ 年的丰富行业经验意味着我几乎见过所有类型的技术挑战。这种深度与广度的经验使我能够快速识别问题，并提供经过实战检验的解决方案。</p><h3><span id="42-全面的技术覆盖">4.2 全面的技术覆盖</span></h3><p>从软件开发到系统运维，从开源解决方案到云计算平台，我的专业知识覆盖了现代 IT 基础设施的各个方面。这意味着我可以为您提供全面、集成的解决方案，而不是零散的建议。</p><h3><span id="43-问题解决能力出众">4.3 问题解决能力出众</span></h3><p>我不仅仅是提供建议，更重要的是我能够解决实际问题。无论是性能瓶颈、安全漏洞，还是系统崩溃，我都有能力快速诊断并解决问题，最大限度地减少您的业务中断。</p><h3><span id="44-紧跟技术前沿">4.4 紧跟技术前沿</span></h3><p>技术世界瞬息万变，但您无需担心落后。我持续学习和更新知识，确保我的建议和解决方案始终反映最新的技术趋势和最佳实践。</p><h3><span id="45-选择我的服务您将获得的收益">4.5 选择我的服务，您将获得的收益</span></h3><p>与我合作，您将获得：</p><ol><li>更高的系统可靠性和性能</li><li>降低的运营成本</li><li>增强的安全性</li><li>更快的问题解决速度</li><li>更好的技术决策支持</li><li>提高的团队技术能力</li><li>…</li></ol><p>这些收益将直接转化为您的业务优势，帮助您在竞争激烈的市场中脱颖而出。</p><h2><span id="5-我的服务流程-从咨询到实施的无缝衔接">5. 我的服务流程: 从咨询到实施的无缝衔接</span></h2><p>我的服务流程设计得简单而高效：</p><ol><li><strong>初步咨询</strong>：了解您的需求和挑战</li><li><strong>问题分析</strong>：深入研究您的技术环境</li><li><strong>方案制定</strong>：提出定制化的解决方案</li><li><strong>方案实施</strong>：执行商定的计划</li><li><strong>效果评估</strong>：衡量实施效果</li><li><strong>持续支持</strong>：提供后续的技术支持</li></ol><p>这个流程确保了从问题识别到解决方案实施的每一步都经过精心规划和执行。</p><h2><span id="6-我的付费方案-灵活且具有竞争力的定价">6. 我的付费方案: 灵活且具有竞争力的定价</span></h2><p>我提供灵活的付费方案，以满足不同客户的需求：</p><ol><li><strong>按小时计费</strong>：每小时咨询服务费 100 元起。</li><li><strong>问题解决</strong>：每次解决实际问题 100 元起，具体费用根据问题复杂度而定。</li><li><strong>项目制</strong>：针对大型项目，我提供量身定制的固定价格方案。</li><li><strong>长期合作</strong>：针对需要持续技术支持的客户，我提供优惠的月度或年度服务包。</li></ol><p>我的定价透明公正，没有隐藏费用。您只需为您实际需要的服务付费。</p><h2><span id="7-我的成功案例">7. 我的成功案例</span></h2><h3><span id="案例-1某电子商务平台性能优化">案例 1：<strong>某电子商务平台性能优化</strong></span></h3><ul><li><strong>挑战</strong>：客户的网站在促销期间经常崩溃。</li><li><strong>我的解决方案</strong>：优化了数据库查询，实施了缓存策略，并设计了自动扩展架构。</li><li><strong>结果</strong>：网站性能提升 300 %，能够轻松应对流量高峰。</li></ul><h3><span id="案例-2某金融机构的云迁移">案例 2：<strong>某金融机构的云迁移</strong></span></h3><ul><li><strong>挑战</strong>：客户需要将核心系统迁移到云端，同时确保数据安全。</li><li><strong>我的解决方案</strong>：设计了混合云架构，将全部原传统部署的应用迁移到了 Kubernetes 容器化平台。实施了严格的安全措施，并进行了分阶段迁移。</li><li><strong>结果</strong>：成功完成迁移，系统可用性达到 99.99%，同时每年节省 30% 的IT成本。</li></ul><h2><span id="8-联系我-开启您的技术升级之旅">8. 联系我: 开启您的技术升级之旅</span></h2><p>在这个技术驱动的世界里，拥有正确的技术伙伴可以成为您成功的关键。</p><p>我不仅带来了行业丰富经验，还带来了对技术的热情和对客户成功的承诺。</p><p>选择我，就是选择了一个能够真正理解您业务需求，并能提供切实可行的技术解决方案的合作伙伴。</p><p>让我们一起携手，释放技术的力量，推动您的业务向前发展。因为在 IT 领域，让专业的人做专业的事，才是明智之选。</p><p>让我们一起开创您的技术新纪元，开启您的技术升级之旅！</p><p>你可以通过下面的方式联系我：</p><p><strong>微信</strong>：通过微信 ID：<code>YWZM_Mike</code> 或扫描下方二维码：</p><p><img src="https://img.hi-linux.com/staticfile/271736328245_.pic-2025-01-08-nJO68H.jpg" alt></p><p><strong>下面任一网站</strong>：</p><ul><li><p><a href="https://www.hi-linux.com">https://www.hi-linux.com</a></p></li><li><p><a href="https://bestgeek.org" target="_blank" rel="noopener">https://bestgeek.org</a></p></li><li><p><a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a></p></li></ul><p>我期待与您合作，共同实现您的技术愿景！</p><h2><span id="9-常见问题解答faq">9. 常见问题解答(FAQ)</span></h2><h3><span id="91-问您能处理什么规模的项目">9.1 <strong>问：您能处理什么规模的项目？</strong></span></h3><p>答：我有能力处理从小型初创公司到大型企业的各种规模的项目，我的解决方案可以根据您的具体需求进行定制。</p><h3><span id="92-问如果我不懂技术您能用通俗易懂的语言解释吗">9.2 <strong>问：如果我不懂技术，您能用通俗易懂的语言解释吗？</strong></span></h3><p>答：当然可以。我擅长将复杂的技术概念转化为易于理解的语言，确保您完全理解我的建议和解决方案。</p><h3><span id="93-问您如何保证服务质量">9.3 <strong>问：您如何保证服务质量？</strong></span></h3><p>答：我有严格的质量控制流程，每个项目都由我亲自负责。我还提供服务保证，如果您对结果不满意，我会继续工作直到问题得到解决。</p><h3><span id="94-问您能提供远程服务吗">9.4 <strong>问：您能提供远程服务吗？</strong></span></h3><p>答：是的，我提供远程咨询和支持服务。借助先进的远程工具，我可以高效地解决大多数问题，无需现场访问。</p><h3><span id="95-问如果我需要长期的技术支持您有什么方案">9.5 <strong>问：如果我需要长期的技术支持，您有什么方案？</strong></span></h3><p>答：我提供定制的长期支持计划，可以包括定期的系统检查、性能优化、安全审计等。这些计划可以根据您的具体需求进行调整。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引言&quot;&gt;1. 引言&lt;/h2&gt;
&lt;p&gt;大家好！在这个数字化飞速发展的时代，技术的每一次变革都可能影响您的业务成败。&lt;/p&gt;
&lt;p&gt;想象一下，有一位经验丰富的技术专家在您身边，为您指明前行的方向，帮助您避开潜在的陷阱，最终实现业务目标。&lt;/p&gt;
&lt;p&gt;我正是您在技术迷宫中最值得信赖的向导。无论您是刚起步的创业者，还是成熟企业的决策者。选择我，就是选择了一条通往成功的捷径。&lt;/p&gt;
&lt;h2 id=&quot;2-我的专业背景&quot;&gt;2. 我的专业背景&lt;/h2&gt;
&lt;p&gt;我是一名拥有 20+ 年丰富经验的 IT 技术专家。在我的职业生涯中见证了互联网技术的飞速发展，从最初的简单网站到如今复杂的云原生应用，我始终保持着对新技术的热情和学习。&lt;/p&gt;
&lt;p&gt;多年来，我参与并主导了众多大型项目的系统架构设计和实施。为各大企业提供了稳定、高效、安全的 IT 基础设施支持。&lt;/p&gt;
&lt;p&gt;在云计算领域，我对阿里云、腾讯云、AWS、GCP 等主流公有云平台了如指掌。我的深厚技术背景使我能够帮助您充分利用云计算的优势，实现业务的灵活性与可扩展性。&lt;/p&gt;
&lt;p&gt;在容器化与编排技术方面，我始终走在技术前沿。精通 Docker 与 Kubernetes，能够帮助您设计和实施高可用的服务器架构，实现应用的容器化部署，提升系统的可靠性与可扩展性。&lt;/p&gt;
&lt;p&gt;作为一名 Linux 专家，我精通各种 Linux 发行版的安装、系统管理、网络配置、安全加固、性能调优、监控与故障排除等，我能为您提供专业的解决方案，确保您的系统高效运行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>告别混乱远程管理！这款开源神器，让运维效率飙升 500%</title>
    <link href="https://www.hi-linux.com/posts/46565.html"/>
    <id>https://www.hi-linux.com/posts/46565.html</id>
    <published>2025-03-19T01:00:00.000Z</published>
    <updated>2025-03-18T19:41:37.734Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="运维人的痛点你还在用原始工具吗">运维人的痛点：你还在用“原始工具”吗？</span></h2><p>作为 IT 从业者，你是否经历过这些场景？</p><p>• SSH 窗口开满屏幕，找一台服务器要翻 10 分钟历史记录；<br>• 修改远程配置文件，先 SCP 下载到本地，改完再上传；<br>• Kubernetes 集群排查故障，在 kubectl 和日志工具间反复横跳；<br>• 团队共享服务器密码，靠微信发 txt 文件…</p><p>这些低效操作，正在消耗你本可用于技术精进的宝贵时间。</p><p>而今天要介绍的 <strong>XPipe</strong> ，正是为解决这些问题而生——它是一款 GitHub 7.0k Star 的开源远程管理工具，号称“All-in-One 运维中枢”，支持 SSH、Docker、Kubernetes 等 20+ 协议，将分散的操作整合为可视化工作流。</p><a id="more"></a><p><img src="https://img.hi-linux.com/staticfile/banner-20250315021939362-2025-03-15-SDDr8U.png" alt></p><h2><span id="xpipe-核心功能重新定义远程管理">XPipe 核心功能：重新定义远程管理</span></h2><h3><span id="1-万能连接中枢20-协议一网打尽">1. <strong>万能连接中枢：20+ 协议一网打尽</strong></span></h3><p><img src="https://img.hi-linux.com/staticfile/hub_shadow-2025-03-15-Gg2Cje.png" alt></p><p>XPipe 最颠覆的功能，是它打破了协议壁垒：</p><p>• <strong>基础协议</strong>：SSH、RDP、VNC（远程桌面）<br>• <strong>容器生态</strong>：Docker、Kubernetes（Pod/Node 级管理）<br>• <strong>虚拟化平台</strong>：Proxmox、VMware、Hyper-V<br>• <strong>云服务</strong>：AWS EC2、Azure VM（通过 SSH 隧道）</p><p>所有连接按项目/环境/地域分层归类，支持树状结构可视化。例如，你可以将「生产环境→华东集群→MySQL 主从节点」组成层级，3 秒定位目标服务器。</p><h3><span id="2-跨系统文件管理拖拽编辑-秒级传输">2. <strong>跨系统文件管理：拖拽编辑 + 秒级传输</strong></span></h3><p><img src="https://img.hi-linux.com/staticfile/browser_shadow-2025-03-15-obQ51P.png" alt></p><p>传统运维中，编辑远程文件需要反复下载上传，而 XPipe 实现了两大革新：</p><p>• <strong>本地编辑器直连</strong>：用 VS Code 或 Sublime 直接打开远程文件，修改后自动同步至服务器；<br>• <strong>多系统互传加速</strong>：支持 Linux↔Windows↔macOS 跨平台传输，速度比 SCP 快 3 倍，且可批量操作多个服务器。</p><p>更贴心的是，当需要 sudo 权限时，XPipe 会动态提升会话权限，无需断开重连。</p><h3><span id="3-智能终端管家从手动到自动化">3. <strong>智能终端管家：从手动到自动化</strong></span></h3><p><img src="https://img.hi-linux.com/staticfile/terminal_shadow-2025-03-15-vbrH6m.png" alt="Terminal"></p><p><img src="https://img.hi-linux.com/staticfile/scripts_shadow-2025-03-15-sXNEm1.png" alt="scripts"></p><p><img src="https://img.hi-linux.com/staticfile/terminal-2025-03-15-izVp3p.gif" alt="Terminal launcher"></p><p>• <strong>预置脚本库</strong>：内置 Ansible、Puppet 脚本模板，一键部署 LNMP、K8s 集群；<br>• <strong>自定义工作流</strong>：编写全局脚本（如批量更新证书），自动注入所有服务器的 PATH 环境变量；<br>• <strong>会话回溯</strong>：终端操作自动录制，误删文件时可回滚到任意时间点。</p><p>（实战案例：创建一个「一键重启服务」脚本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存为 xpipe-scripts/restart_services.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">systemctl restart nginx</span><br><span class="line">docker restart mysql-container</span><br><span class="line">kubectl rollout restart deployment/web-app</span><br></pre></td></tr></table></figure><p>将此脚本保存后，所有服务器均可直接调用。</p><h3><span id="4-军工级安全体系告别明文密码">4. <strong>军工级安全体系：告别明文密码</strong></span></h3><p>XPipe 采用本地 AES-256 加密存储所有凭证，并与 1Password、Bitwarden 等密码管理器集成。团队协作时，可通过 Git 仓库同步加密配置，确保密钥永不落地。</p><h2><span id="极简安装3-分钟上手">极简安装：3 分钟上手</span></h2><p>XPipe 无需在远程服务器安装任何组件，支持全平台：</p><table><thead><tr><th>系统</th><th>安装方式（任选其一）</th></tr></thead><tbody><tr><td><strong>Windows</strong></td><td>1. 下载 .msi 安装包 <br> 2. 用 Winget：<code>winget install xpipe</code></td></tr><tr><td><strong>macOS</strong></td><td>1. 官网下载 ARM/Intel 版 DMG <br> 2. Homebrew：<code>brew install --cask xpipe-io/tap/xpipe</code></td></tr><tr><td><strong>Linux</strong></td><td>1. 官网下载 deb/rpm 安装包 <br> 2. 一键脚本：<code>bash &lt;(curl -sL https://github.com/xpipe-io/xpipe/raw/master/get-xpipe.sh)</code></td></tr></tbody></table><h2><span id="实战演示从连接到高效运维">实战演示：从连接到高效运维</span></h2><h3><span id="步骤-1导入现有配置">步骤 1：导入现有配置</span></h3><p>首次启动时，XPipe 会自动扫描本地 SSH 配置（~/.ssh/config），并生成可视化拓扑图。你还可以手动添加 Docker 容器、K8s 集群等。</p><h3><span id="步骤-2文件管理进阶">步骤 2：文件管理进阶</span></h3><p>• <strong>直接编辑</strong>：右键点击服务器→「用 VS Code 打开」→ 修改 /etc/nginx.conf 并保存；<br>• <strong>批量传输</strong>：选中 5 台服务器，拖拽上传同一份配置文件。</p><h3><span id="步骤-3脚本自动化">步骤 3：脚本自动化</span></h3><p>在「脚本库」中创建「安全巡检」任务：</p><ol><li>检查系统漏洞（使用 trivy 扫描镜像）；</li><li>备份关键日志（压缩 /var/log 目录）；</li><li>邮件发送报告（调用 mailx 命令）。</li></ol><p>设置定时任务后，XPipe 会自动在凌晨执行。</p><h2><span id="为什么选择-xpipe">为什么选择 XPipe？</span></h2><p>XPipe 对比传统工具</p><table><thead><tr><th>功能维度</th><th>XPipe</th><th>Xshell/MobaXterm</th></tr></thead><tbody><tr><td><strong>协议支持</strong></td><td>20+ 全栈协议</td><td>仅 SSH/Telnet/RDP</td></tr><tr><td><strong>文件管理</strong></td><td>双向拖拽 + 本地编辑</td><td>依赖 SFTP 客户端</td></tr><tr><td><strong>自动化能力</strong></td><td>内置脚本引擎</td><td>需搭配 Ansible</td></tr><tr><td><strong>安全体系</strong></td><td>本地加密 + 密钥管理器</td><td>明文存储密码</td></tr><tr><td><strong>开源协议</strong></td><td>Apache 2.0（可商用）</td><td>部分功能需付费</td></tr></tbody></table><p>数据来源：XPipe 官方文档及第三方测评</p><h2><span id="进阶玩法解锁隐藏技能">进阶玩法：解锁隐藏技能</span></h2><p>• <strong>浏览器运维</strong>：通过 Docker 启动 Webtop 容器，在浏览器中使用 XPipe + VS Code；<br>• <strong>企业级扩展</strong>：付费版支持多用户权限审计、私有云部署（适合金融/医疗行业）；<br>• <strong>API 编程控制</strong>：用 Python 调用 XPipe HTTP 接口，实现自动化运维流水线。</p><h2><span id="立即行动免费获取与资源">立即行动：免费获取与资源</span></h2><ol><li><strong>GitHub 项目</strong>：<a href="https://github.com/xpipe-io/xpipe" target="_blank" rel="noopener">https://github.com/xpipe-io/xpipe</a></li><li><strong>官方网站</strong>：<a href="https://xpipe.io" target="_blank" rel="noopener">https://xpipe.io</a></li></ol><h2><span id="写在最后">写在最后</span></h2><p>XPipe 的出现，标志着远程运维从“手工时代”迈向“智能中枢时代”。它不仅是工具，更是一种效率哲学——让技术人从重复劳动中解放，专注于架构设计、性能优化等真正创造价值的工作。</p><p><strong>今日互动</strong>：你在远程管理中遇到过哪些头疼问题？欢迎在评论区分享！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;运维人的痛点：你还在用“原始工具”吗？&quot;&gt;运维人的痛点：你还在用“原始工具”吗？&lt;/h2&gt;
&lt;p&gt;作为 IT 从业者，你是否经历过这些场景？&lt;/p&gt;
&lt;p&gt;• SSH 窗口开满屏幕，找一台服务器要翻 10 分钟历史记录；&lt;br&gt;
• 修改远程配置文件，先 SCP 下载到本地，改完再上传；&lt;br&gt;
• Kubernetes 集群排查故障，在 kubectl 和日志工具间反复横跳；&lt;br&gt;
• 团队共享服务器密码，靠微信发 txt 文件…&lt;/p&gt;
&lt;p&gt;这些低效操作，正在消耗你本可用于技术精进的宝贵时间。&lt;/p&gt;
&lt;p&gt;而今天要介绍的 &lt;strong&gt;XPipe&lt;/strong&gt; ，正是为解决这些问题而生——它是一款 GitHub 7.0k Star 的开源远程管理工具，号称“All-in-One 运维中枢”，支持 SSH、Docker、Kubernetes 等 20+ 协议，将分散的操作整合为可视化工作流。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="SSH" scheme="https://www.hi-linux.com/tags/SSH/"/>
    
      <category term="XPipe" scheme="https://www.hi-linux.com/tags/XPipe/"/>
    
  </entry>
  
  <entry>
    <title>「奇妙的 Linux 世界」全新升级：AI 小助手正式上线，等你来撩！</title>
    <link href="https://www.hi-linux.com/posts/59563.html"/>
    <id>https://www.hi-linux.com/posts/59563.html</id>
    <published>2025-03-09T01:00:00.000Z</published>
    <updated>2025-03-13T16:28:50.964Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>嘿，各位 Linux 爱好者们！👋</p><p>你是否曾在配置环境时抓狂到想敲键盘？💻</p><p>你是否曾在终端输错命令后暗自祈祷有个 “智能队友” 来救场？🆘</p><p>好消息来了！🎉 「奇妙的 Linux 世界」公众号正式推出全新功能 —— AI 小助手，从此，你的 Linux 之旅不再孤单！🌈</p><a id="more"></a><p>我们精心打造的这位 AI 小助手，不仅聪明能干 🧠，还能陪你聊技术、解难题，甚至偶尔抖个机灵 😜。</p><p>它可是由知名的 <code>DeepSeek</code> 大模型驱动，堪称 AI 界的 “全能选手” 🏆，随时为你提供贴心支持。</p><p>接下来，跟我一起看看怎么 “撩” 起来吧！👇</p><h2><span id="ai-小助手怎么用两大招式轻松上手">🎯 AI 小助手怎么用？两大招式轻松上手！</span></h2><p>为了让大家用得顺手，我们给 AI 小助手设计了两种超方便的访问方式，随你挑：</p><h3><span id="招式一直接回复消息随时开聊">招式一：直接回复消息，随时开聊 💬</span></h3><p><img src="https://img.hi-linux.com/staticfile/WX20250309-222615@2x-2025-03-09-5k6vLi.png" alt></p><ul><li><p>用法：打开「奇妙的 Linux 世界」公众号，在对话框里输入你想问的问题。比如: “怎么在 Ubuntu 上安装 Nginx？” 或者 “帮我分析下这个错误日志”，然后发送！</p></li><li><p>场景：适合随手提问，比如半夜调试代码时灵光一闪想问点啥，直接丢给 AI 小助手，它秒回不墨迹！⚡</p></li></ul><h3><span id="招式二公众号菜单入口专属体验">招式二：公众号菜单入口，专属体验 📋</span></h3><p><img src="https://img.hi-linux.com/staticfile/WX20250309-221759@2x-2025-03-09-82GTu2.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/WX20250309-222039@2x-2025-03-09-OAsyre.png" alt></p><ul><li><p>用法：点击公众号底部的菜单，找到 “AI 小助手” 选项，一键进入专属对话模式。</p></li><li><p>场景：适合深度互动，比如想让它帮你查资料、分析复杂问题，或者单纯聊聊 “Linux 内核的那些事儿” 🖥️ 。</p></li><li><p>小贴士：菜单入口就像你的 “私人助手办公室”，随时待命，绝不掉线！✅</p></li></ul><h2><span id="ai-小助手能干啥亮点抢先看">✨ AI 小助手能干啥？亮点抢先看！</span></h2><h3><span id="技术答疑">技术答疑 ❓</span></h3><p>从 “怎么用 tar 打包” 到 “内核参数怎么调优”，有问必答，绝不敷衍。</p><h3><span id="资源挖掘">资源挖掘 🔍</span></h3><p>比如 “最近有什么好用的开源工具？” 它会给你挖出宝藏 💎。</p><h3><span id="幽默加持">幽默加持 😂</span></h3><p>偶尔还能跟你聊聊 “程序员的自我修养”，调节一下敲代码的疲惫心情。</p><h2><span id="️-试试这些-撩法解锁更多玩法">🛠️ 试试这些 “撩法”，解锁更多玩法！</span></h2><ul><li>怎么用 Docker 运行 Nginx？📂</li><li>最近有什么 Linux 相关的热门讨论？🌐</li><li>给我讲讲 systemd 的优缺点吧！📖</li></ul><p>不管你是 Linux 新手还是老司机，AI 小助手都能陪你玩出花样 🌸。它没有知识截止日期，随时更新最新资讯，绝对是你的 “技术外脑” 🧩。</p><h2><span id="快来体验吧">🎈 快来体验吧！</span></h2><p>现在就打开「奇妙的 Linux 世界」公众号，试试直接回复消息 💌，或者点击菜单里的 “AI 小助手” 🔧，和它聊上几句！</p><p>你会发现，这个小家伙不仅能帮你解决问题，还能让你的 Linux 学习之旅变得更有趣。🎡</p><p>有任何使用反馈或者期待的功能，欢迎随时留言告诉我们。📩</p><p>毕竟，一个好的助手，是粉丝们一起调教出来的嘛！💪</p><p>未来，我们还会不断优化 AI 小助手的功能，让它成为你最靠谱的 “Linux 搭档”。⏳</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嘿，各位 Linux 爱好者们！👋&lt;/p&gt;
&lt;p&gt;你是否曾在配置环境时抓狂到想敲键盘？💻&lt;/p&gt;
&lt;p&gt;你是否曾在终端输错命令后暗自祈祷有个 “智能队友” 来救场？🆘&lt;/p&gt;
&lt;p&gt;好消息来了！🎉 「奇妙的 Linux 世界」公众号正式推出全新功能 —— AI 小助手，从此，你的 Linux 之旅不再孤单！🌈&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="AI" scheme="https://www.hi-linux.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>无成本！10 万次免费统计，Han-Analytics 让网站分析变得如此简单</title>
    <link href="https://www.hi-linux.com/posts/38520.html"/>
    <id>https://www.hi-linux.com/posts/38520.html</id>
    <published>2025-02-28T01:00:00.000Z</published>
    <updated>2025-03-01T19:01:34.641Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言网站分析不花一分钱">引言：网站分析，不花一分钱？</span></h2><p>嘿，小伙伴们！有没有想过给自己的网站加个 “数据仪表盘”，看看每天有多少人来逛，哪些页面最火，却又不想花钱买服务器、搭数据库？</p><p>今天要介绍的 <strong>Han-Analytics</strong>，简直是 “抠门程序员” 的福音！</p><p>它跑在 Cloudflare 上，每天免费 10 万次统计，连域名都不用买，部署简单到像点外卖。准备好了吗？咱们一起来把网站流量 “玩明白”！</p><p><img src="https://img.hi-linux.com/staticfile/68747470733a2f2f69302e77702e636f6d2f757869616f68616e2e6769746875622e696f2f76322f323032342f30392f313732373030373933372e77656270-2025-02-27-kGLQ4H.jpeg" alt></p><h2><span id="han-analytics-是个啥">Han-Analytics 是个啥？</span></h2><p>简单说，Han-Analytics 是一个轻量级的网站分析工具，包含一个跟踪器和一个仪表板。它靠 Cloudflare 的“赛博菩萨”之力——Cloudflare Pages 和 Analytics Engine，零成本运行。开发者在 <a href="https://github.com/uxiaohan/Han-Analytics" target="_blank" rel="noopener">GitHub 上开源了这个项目</a>，用它你就能知道网站访客从哪来、点了啥，全程不搭服务器、不建数据库，省心又省钱。</p><blockquote><p>项目地址：<a href="https://github.com/uxiaohan/HanAnalytics/" target="_blank" rel="noopener">https://github.com/uxiaohan/HanAnalytics/</a></p></blockquote><p><img src="https://img.hi-linux.com/staticfile/68747470733a2f2f69302e77702e636f6d2f757869616f68616e2e6769746875622e696f2f76322f323032342f30392f313732363939333733352e77656270-2025-02-27-WFSOF3.jpeg" alt></p><a id="more"></a><h3><span id="核心亮点">核心亮点</span></h3><ul><li><strong>零成本部署</strong>：托管在 Cloudflare Pages 上，免费额度够你玩到爽。</li><li><strong>10 万次免费统计</strong>：每天 10 万次请求，够中小网站用得飞起。</li><li><strong>超简单集成</strong>：加一行代码，网站流量就“跑”进仪表板。</li><li><strong>密码保护+白名单</strong>：想加个密码防偷窥？想只统计特定网站？随便你搞！</li></ul><p><strong>小贴士</strong>：它用的是 Cloudflare Analytics Engine，数据全靠 HTTP API 拉取，安全又省事。</p><h3><span id="为啥你得试试">为啥你得试试？</span></h3><p>作为一个网站开发者，你是不是也好奇 “谁在看我的页面” ？传统分析工具要么贵得离谱，要么配置麻烦得像解数学题。Han-Analytics 不一样，部署快、用起来爽，特别适合：</p><ul><li><strong>DevOps 工程师</strong>：试试 Cloudflare 的玩法，顺便监控流量。</li><li><strong>独立开发者</strong>：没预算也能搞定网站统计。</li><li><strong>技术爱好者</strong>：折腾新玩具还能学点 Vue 和 Cloudflare。</li></ul><h2><span id="动手实践三步部署起来">动手实践：三步部署起来</span></h2><p>别眨眼，咱们直接开干！以下是部署 Han-Analytics 的超简单步骤，参考了<a href="https://github.com/uxiaohan/Han-Analytics" target="_blank" rel="noopener">官方文档</a>。</p><h3><span id="第一步准备-cloudflare-账号和密钥">第一步：准备 Cloudflare 账号和密钥</span></h3><ol><li>去 <a href="https://dash.cloudflare.com/sign-up" target="_blank" rel="noopener">Cloudflare 注册</a> 或登录，没账号的赶紧弄一个。</li><li>点击“Workers 和 Pages”，随便建个 Worker，开启 Analytics Engine，记下 Workers ID（长得像一串乱码）。</li><li>创建 API Token：<ul><li>去 <a href="https://dash.cloudflare.com/profile/api-tokens" target="_blank" rel="noopener">API Tokens 页面</a>。</li><li>选 “创建令牌”，权限选 “编辑 Cloudflare Pages”，复制好备用。</li></ul></li></ol><h3><span id="第二步fork-项目-部署到-pages">第二步：Fork 项目 + 部署到 Pages</span></h3><ol><li><p>到 GitHub 上 Fork <a href="https://github.com/uxiaohan/Han-Analytics" target="_blank" rel="noopener">Han-Analytics 仓库</a>。</p></li><li><p>回 Cloudflare，点 “Pages” &gt; “创建项目”，链接你刚 Fork 的仓库。</p></li><li><p>设置环境变量（如下），框架选 Vue，然后点“部署”：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CLOUDFLARE_ACCOUNT_ID = 你的 Workers ID</span><br><span class="line">CLOUDFLARE_API_TOKEN = 你的 API Token</span><br><span class="line">CLOUDFLARE_WEBSITE_PWD = 访问密码（可选，不填就不用密码）</span><br><span class="line">CLOUDFLARE_WEBSITE_WHITELIST = 白名单网站（可选，比如 api.vvhan.com,Hello-Han-Api）</span><br></pre></td></tr></table></figure><ol start="4"><li><p>部署完，去“设置” &gt; “绑定”，添加 Analytics Engine：</p><ul><li>变量名：AnalyticsBinding</li><li>数据集：AnalyticsDataset</li></ul></li><li><p>点 “保存并重新部署”，等几分钟，访问 <a href="https://xxxxxx.pages.dev" target="_blank" rel="noopener">https://xxxxxx.pages.dev</a>，仪表板就上线了！</p></li></ol><p><strong>注意</strong>：刚部署完没数据？别急，先集成到网站，等有人访问后再来看。</p><h3><span id="第三步集成到你的网站">第三步：集成到你的网站</span></h3><p>部署好了？接下来加一行代码就能开始统计：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"https://xxxxxx.pages.dev/tracker.min.js"</span> data-website-id=<span class="string">"my-cool-site"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>把这行丢到网站底部，data-website-id 随便填个唯一标识（比如网站名）。</li><li>访问网站几次，再打开仪表板，数据就来了！</li></ul><h2><span id="使用示例从零到有数据">使用示例：从零到有数据</span></h2><p>假设你有个博客，想看看有多少人读你的文章：</p><ol><li><p>按上面步骤部署好，假设域名是 <a href="https://cool-analytics.pages.dev" target="_blank" rel="noopener">https://cool-analytics.pages.dev</a>。</p></li><li><p>在博客的 HTML 里加：</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"https://cool-analytics.pages.dev/tracker.min.js"</span> <span class="attr">data-website-id</span>=<span class="string">"my-blog"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>打开博客逛两圈，再访问 <a href="https://cool-analytics.pages.dev" target="_blank" rel="noopener">https://cool-analytics.pages.dev</a>，输入密码（如果设了），就能看到访客数、热门页面等数据。</li></ol><h2><span id="数据不准别慌">数据不准？别慌！</span></h2><p>如果数据没出来，可能是：</p><ul><li>网站没法访问（检查下网络）。</li><li>Analytics Engine 没开（回头确认下绑定）。</li><li>刚部署，数据还没采集（多等几分钟，或者自己多刷几下网站）。</li></ul><p>Han-Analytics 用的是 Cloudflare 的抽样技术，像 Google Analytics 那样聪明地处理大数据，具体细节可以看 <a href="https://www.cloudflare.com/analytics-engine/" target="_blank" rel="noopener">Cloudflare 的说明</a>。</p><h2><span id="结尾流量统计从此不求人">结尾：流量统计，从此不求人</span></h2><p>怎么样，是不是觉得网站分析也能这么“丝滑”？Han-Analytics 就像你开发路上的 “免费小助手”，零成本、超简单，还能秀一波技术。快去 <a href="https://github.com/uxiaohan/Han-Analytics" target="_blank" rel="noopener">GitHub</a> Fork 一份试试吧，顺手给作者点个 Star，支持下开源精神！</p><p>下次有人问你 “网站有多少人看”，别挠头，直接甩出 Han-Analytics 的仪表板，数据说话，谁还敢说你不会玩流量？</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言：网站分析，不花一分钱？&quot;&gt;引言：网站分析，不花一分钱？&lt;/h2&gt;
&lt;p&gt;嘿，小伙伴们！有没有想过给自己的网站加个 “数据仪表盘”，看看每天有多少人来逛，哪些页面最火，却又不想花钱买服务器、搭数据库？&lt;/p&gt;
&lt;p&gt;今天要介绍的 &lt;strong&gt;Han-Analytics&lt;/strong&gt;，简直是 “抠门程序员” 的福音！&lt;/p&gt;
&lt;p&gt;它跑在 Cloudflare 上，每天免费 10 万次统计，连域名都不用买，部署简单到像点外卖。准备好了吗？咱们一起来把网站流量 “玩明白”！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/68747470733a2f2f69302e77702e636f6d2f757869616f68616e2e6769746875622e696f2f76322f323032342f30392f313732373030373933372e77656270-2025-02-27-kGLQ4H.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Han-Analytics-是个啥？&quot;&gt;Han-Analytics 是个啥？&lt;/h2&gt;
&lt;p&gt;简单说，Han-Analytics 是一个轻量级的网站分析工具，包含一个跟踪器和一个仪表板。它靠 Cloudflare 的“赛博菩萨”之力——Cloudflare Pages 和 Analytics Engine，零成本运行。开发者在 &lt;a href=&quot;https://github.com/uxiaohan/Han-Analytics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 上开源了这个项目&lt;/a&gt;，用它你就能知道网站访客从哪来、点了啥，全程不搭服务器、不建数据库，省心又省钱。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/uxiaohan/HanAnalytics/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/uxiaohan/HanAnalytics/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/68747470733a2f2f69302e77702e636f6d2f757869616f68616e2e6769746875622e696f2f76322f323032342f30392f313732363939333733352e77656270-2025-02-27-WFSOF3.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Han-Analytics" scheme="https://www.hi-linux.com/tags/Han-Analytics/"/>
    
  </entry>
  
  <entry>
    <title>Github 星标 2.3 K，异地组网新工具 Easytier 助你轻松实现跨地域设备互联</title>
    <link href="https://www.hi-linux.com/posts/28049.html"/>
    <id>https://www.hi-linux.com/posts/28049.html</id>
    <published>2025-01-12T01:00:00.000Z</published>
    <updated>2025-01-11T16:45:42.149Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>EasyTier 是由 Rust 和 Tokio 驱动一个<strong>简单</strong>、<strong>安全</strong>、<strong>去中心化</strong>的内网穿透 远程 组网方案，<strong>开源项目</strong>。</p><h2><span id="优点">优点</span></h2><ul><li>去中心化：无需依赖中心化服务，节点平等且独立</li><li>公网 IP 组网：支持利用共享的公网节点组网, 可以使用 EasyTier 公共 Peers</li><li>低占用: 即使最垃圾的机器也可以跑</li><li>跨平台支持</li><li>NAT 穿透：支持基于 UDP 的 NAT 穿透，即使在复杂的网络环境下也能建立稳定的连接</li><li>子网代理(点对网）：节点可以将可访问的网段作为代理暴露给 远程 子网，允许其他节点通过该节点访问这些子网</li><li>智能路由：根据流量智能选择链路，减少延迟，提高吞吐量</li><li>TCP 支持：在 UDP 受限的情况下，通过并发 TCP 链接提供可靠的数据传输，优化性能</li><li>高可用性：支持多路径和在检测到高丢包率或网络错误时切换到健康路径</li><li>安全：支持利用 WireGuard 加密通信，也支持 AES-GCM 加密保护中转流量</li><li>IPV6 支持：支持利用 IPV6 组网</li></ul><a id="more"></a><h2><span id="项目情况">项目情况</span></h2><ul><li><a href="https://github.com/EasyTier/EasyTier/releases" target="_blank" rel="noopener">EasyTier/EasyTier</a></li><li><a href="https://easytier.cn/guide/introduction.html" target="_blank" rel="noopener">官方文档</a></li></ul><h2><span id="部署">部署</span></h2><blockquote><p>这里以手动安装和 docker 部署方式为例</p></blockquote><h3><span id="手动安装部署">手动安装部署</span></h3><p>EasyTier 采用 rust 开发，交叉编译成二进制文件，部署极其方便简单<br>直接下载已经编译好的文件，安装即可，下面分几步执行</p><p>EasyTier 默认是不区分客户端还是服务端，故本次部署即是服务端又是客户端。一般情况下 <strong>开放监听端口为服务端，不开放监听端口为客户端</strong></p><p><code>Linux-x86_64</code> 适用于 Debian 系列,其它架构系统类似。默认 root 终端执行。</p><h4><span id="下载-easytier">下载 EasyTier</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /etc/et &amp;&amp; <span class="built_in">cd</span> /etc/et</span><br><span class="line">$ wget https://github.com/EasyTier/EasyTier/releases/download/v2.1.1/easytier-linux-x86_64-v2.1.1.zip</span><br><span class="line"><span class="comment"># 上面没法下载，可以使用下面的链接下载</span></span><br><span class="line">$ wget https://gh.dev.438250.xyz/https://github.com/EasyTier/EasyTier/releases/download/v2.1.1/easytier-linux-x86_64-v2.1.1.zip</span><br></pre></td></tr></table></figure><h4><span id="解压">解压</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ unzip easytier-linux-x86_64-v2.1.1.zip</span><br><span class="line">$ cp -a easytier-linux-x86_64/* .</span><br><span class="line">$ rm -rf easytier-linux-x86_64 easytier-linux-x86_64-v2.1.1.zip</span><br><span class="line">$ chmod +x ./*</span><br><span class="line">$ mv ./easytier-* /usr/bin/</span><br></pre></td></tr></table></figure><h4><span id="编写配置文件">编写配置文件</span></h4><p>默认路径为 <code>/etc/et/config.toml</code>，内容如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">instance_name</span> = <span class="string">"default"</span></span><br><span class="line"><span class="comment"># easytier组网的ip地址</span></span><br><span class="line"><span class="attr">ipv4</span> = <span class="string">"192.168.66.80"</span></span><br><span class="line"><span class="attr">dhcp</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">exit_nodes</span> = []</span><br><span class="line"><span class="comment"># api地址,记得改成本地监听</span></span><br><span class="line"><span class="attr">rpc_portal</span> = <span class="string">"127.0.0.1:15888"</span></span><br><span class="line"><span class="comment"># 自定义 使用 32379 32380 端口作为监听发现服务 默认监听IPv4/IPv6, 服务端可以根据自己实际情况配置，可以全开，也可以为空不开listeners = []，客户端可以不开</span></span><br><span class="line"><span class="attr">listeners</span> = [</span><br><span class="line">    <span class="string">"tcp://0.0.0.0:32379"</span>,</span><br><span class="line">    <span class="string">"udp://0.0.0.0:32379"</span>,</span><br><span class="line">    <span class="string">"udp://[::]:32379"</span>,</span><br><span class="line">    <span class="string">"tcp://[::]:32379"</span>,</span><br><span class="line">    <span class="string">"wss://0.0.0.0:32380/"</span>,</span><br><span class="line">    <span class="string">"wss://[::]:32380/"</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组网凭证</span></span><br><span class="line"><span class="section">[network_identity]</span></span><br><span class="line"><span class="attr">network_name</span> = <span class="string">"xxxx"</span></span><br><span class="line"><span class="attr">network_secret</span> = <span class="string">"xxxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tcp://public.easytier.top:11010 是自定义要连的其他节点, 如果是第一个节点，可以不用配置, 这里以官方的节点为例</span></span><br><span class="line"><span class="section">[[peer]]</span></span><br><span class="line"><span class="attr">uri</span> = <span class="string">"tcp://public.easytier.top:11010"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他参数</span></span><br><span class="line"><span class="section">[flags]</span></span><br><span class="line"><span class="attr">dev_name</span> = <span class="string">"easytier0"</span></span><br><span class="line"><span class="attr">enable_ipv6</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>另外当服务跑起来后，也可以使用 <code>easytier-cli node config</code> 命令查看节点配置文件</p><h4><span id="编写启动守护文件并启动">编写启动守护文件并启动</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; /etc/systemd/system/easytier.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=EasyTier</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">WorkingDirectory=/etc/et</span><br><span class="line"><span class="comment"># ExecStart=/usr/bin/easytier-core -i 192.168.66.80 --network-name ysicing --network-secret ysicing -e tcp://public.easytier.top:11010 --dev-name easytier0 --rpc-portal 127.0.0.1:15888 --no-listener</span></span><br><span class="line">ExecStart=/usr/bin/easytier-core -c /etc/et/config.toml</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>可以使用配置文件，也可以使用命令行参数方式，如果节点配置都一样，推荐使用配置文件方式。</p><h4><span id="启动服务">启动服务</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启并立即启动</span></span><br><span class="line">$ systemctl <span class="built_in">enable</span> easytier --now</span><br></pre></td></tr></table></figure><p>如果使用命令行参数，每次启动后需要 reload 一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart easytier</span><br></pre></td></tr></table></figure><h4><span id="查询服务是否正常">查询服务是否正常</span></h4><p>执行 <code>easytier-cli peer</code>, 由于使用的是公共节点，所以会有节点信息</p><p><img src="https://img.hi-linux.com/staticfile/01-2025-01-08-z4UYxb.png" alt></p><p>如下是我自己的组网节点</p><p><img src="https://img.hi-linux.com/staticfile/02-2025-01-08-TV5UkN.png" alt></p><h3><span id="使用-docker-部署">使用 Docker 部署</span></h3><h4><span id="编写-docker-composeyml">编写 docker-compose.yml</span></h4><ul><li>首先创建一个目录(如 easytier)，然后在该目录下创建 docker-compose.yml 文件，内容如下:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">easytier:</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">easytier</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">easytier:/root</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="comment"># 方便国内部署，我会定期同步到腾讯云容器仓库</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ccr.ccs.tencentyun.com/k7scn/easytier:latest</span></span><br><span class="line">    <span class="comment"># 凭证需要保持一致</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">-i</span> <span class="number">192.168</span><span class="number">.66</span><span class="number">.8</span> <span class="string">--network-name</span> <span class="string">ysicing</span> <span class="string">--network-secret</span> <span class="string">ysicing</span> <span class="string">-l</span> <span class="string">tcp://0.0.0.0:32379</span> <span class="string">-e</span> <span class="string">tcp://public.easytier.top:11010</span> <span class="string">--dev-name</span> <span class="string">easytier0</span> <span class="string">--rpc-portal</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:15888</span> <span class="comment"># --vpn-portal wg://0.0.0.0:32380/192.168.77.0/24</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">easytier:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br></pre></td></tr></table></figure><ul><li>启动服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose pull</span><br><span class="line">$ docker compose up -d</span><br></pre></td></tr></table></figure><p>同理，如果需要查看节点信息，可以使用 <code>docker exec -it easytier easytier-cli peer</code> 命令</p><blockquote><p>需要自行放行相关端口，如 32379, 32380 等</p></blockquote><h3><span id="其他系统部署">其他系统部署</span></h3><p>Windows 部署可以参考<a href="https://easytier.cn/guide/network/install-as-a-windows-service.html" target="_blank" rel="noopener">官方文档</a></p><h4><span id="windows-scoop-安装">Windows Scoop 安装</span></h4><p>在 PowerShell 执行下列代码以安装 Scoop</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">irm get.scoop.sh | iex</span><br><span class="line">scoop install git</span><br><span class="line">scoop install nssm</span><br><span class="line"><span class="comment"># 添加软件源</span></span><br><span class="line">scoop bucket add moec https://github.com/laoxong/ScoopBucket</span><br><span class="line">scoop install easytier</span><br><span class="line"><span class="comment"># 以服务的方式启动，也可以直接启动测试</span></span><br><span class="line">nssm.exe install easytier_service C:\Scoop\apps\easytier\current\easytier<span class="literal">-core</span>.exe 你的参数</span><br><span class="line"><span class="comment"># 编辑服务</span></span><br><span class="line">nssm edit easytier_service</span><br></pre></td></tr></table></figure><p>示例: <code>nssm.exe install easytier_service C:\Scoop\apps\easytier\current\easytier-core.exe -i 192.168.66.81 -e tcp://public.easytier.top:11010 --dev-name easytier0 --network-name xxxx --network-secret xxxx</code></p><blockquote><p>注意：Windows 下需要管理员权限执行, 相关路径也需要确定，不一定是 <code>C:\Scoop\</code>,可能是当前用户目录下的 <code>scoop</code> 目录</p></blockquote><p>打开 services.msc 找到 easytier_service，修改为延迟启动</p><p><img src="https://img.hi-linux.com/staticfile/03-20250108222526429-2025-01-08-idS862.png" alt></p><h2><span id="其他">其他</span></h2><p>仅供参考，不对其安全性负责</p><ul><li><a href="https://github.com/CGG888/EasyTier/blob/main/script%2FREADME.md" target="_blank" rel="noopener">EasyTier 配置管理脚本<br></a></li><li><a href="https://github.com/xlc520/easytier-manager" target="_blank" rel="noopener">EasyTier 管理器</a></li><li><a href="https://easytier.gd.nkbpal.cn/status/easytier" target="_blank" rel="noopener">EasyTier 公共服务器</a></li></ul><blockquote><p>本文转载自：「Solitudes」，原文：<a href="https://ysicing.me/easytier" target="_blank" rel="noopener">https://ysicing.me/easytier</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EasyTier 是由 Rust 和 Tokio 驱动一个&lt;strong&gt;简单&lt;/strong&gt;、&lt;strong&gt;安全&lt;/strong&gt;、&lt;strong&gt;去中心化&lt;/strong&gt;的内网穿透 远程 组网方案，&lt;strong&gt;开源项目&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;去中心化：无需依赖中心化服务，节点平等且独立&lt;/li&gt;
&lt;li&gt;公网 IP 组网：支持利用共享的公网节点组网, 可以使用 EasyTier 公共 Peers&lt;/li&gt;
&lt;li&gt;低占用: 即使最垃圾的机器也可以跑&lt;/li&gt;
&lt;li&gt;跨平台支持&lt;/li&gt;
&lt;li&gt;NAT 穿透：支持基于 UDP 的 NAT 穿透，即使在复杂的网络环境下也能建立稳定的连接&lt;/li&gt;
&lt;li&gt;子网代理(点对网）：节点可以将可访问的网段作为代理暴露给 远程 子网，允许其他节点通过该节点访问这些子网&lt;/li&gt;
&lt;li&gt;智能路由：根据流量智能选择链路，减少延迟，提高吞吐量&lt;/li&gt;
&lt;li&gt;TCP 支持：在 UDP 受限的情况下，通过并发 TCP 链接提供可靠的数据传输，优化性能&lt;/li&gt;
&lt;li&gt;高可用性：支持多路径和在检测到高丢包率或网络错误时切换到健康路径&lt;/li&gt;
&lt;li&gt;安全：支持利用 WireGuard 加密通信，也支持 AES-GCM 加密保护中转流量&lt;/li&gt;
&lt;li&gt;IPV6 支持：支持利用 IPV6 组网&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="WireGuard" scheme="https://www.hi-linux.com/tags/WireGuard/"/>
    
      <category term="EasyTier" scheme="https://www.hi-linux.com/tags/EasyTier/"/>
    
  </entry>
  
  <entry>
    <title>如何同时向两个远程 Git 仓库推送代码</title>
    <link href="https://www.hi-linux.com/posts/45935.html"/>
    <id>https://www.hi-linux.com/posts/45935.html</id>
    <published>2024-08-26T01:00:00.000Z</published>
    <updated>2024-08-26T07:16:00.270Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>在日常开发中，我们有时需要将代码推送到多个远程仓库以确保代码备份和同步。本篇文章将介绍如何配置和操作 Git，同时推送代码到两个远程仓库。</p></blockquote><h2><span id="为什么需要多个远程仓库">为什么需要多个远程仓库？</span></h2><p>多个远程仓库的常见场景包括：</p><ul><li>备份：确保代码在不同平台上有备份，例如 <code>GitHub</code> 和 <code>GitLab</code>。</li><li>协作：团队成员在不同的远程仓库上工作，需要确保代码同步。</li></ul><h2><span id="配置多个远程仓库">配置多个远程仓库</span></h2><p>假设我们已经有一个远程仓库 <code>origin</code>，现在需要添加一个名为 <code>backup</code> 的远程仓库。</p><a id="more"></a><h3><span id="步骤-1-添加第二个远程仓库">步骤 1: 添加第二个远程仓库</span></h3><p>首先，添加 <code>backup</code> 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add backup https://gitlab.com/user/backup-repo.git</span><br></pre></td></tr></table></figure><h3><span id="步骤-2-验证远程仓库">步骤 2: 验证远程仓库</span></h3><p>确保远程仓库添加成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><p>你应该看到类似如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">origin    https://github.com/user/main-repo.git (push)</span><br><span class="line">backup    https://gitlab.com/user/backup-repo.git (fetch)</span><br><span class="line">backup    https://gitlab.com/user/backup-repo.git (push)</span><br></pre></td></tr></table></figure><h3><span id="步骤-3-推送到两个远程仓库">步骤 3: 推送到两个远程仓库</span></h3><h4><span id="方法-1-分别推送">方法 1: 分别推送</span></h4><p>你可以分别推送到两个远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin &lt;branch-name&gt;</span><br><span class="line">$ git push backup &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h4><span id="方法-2-创建自定义的-remote">方法 2: 创建自定义的 remote</span></h4><p>创建一个自定义的 remote，将两个远程仓库的 URL 都添加到这个 remote 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">set</span>-url --add --push origin https://github.com/user/main-repo.git</span><br><span class="line">$ git remote <span class="built_in">set</span>-url --add --push origin https://gitlab.com/user/backup-repo.git</span><br></pre></td></tr></table></figure><h4><span id="方法-3-使用-git-config">方法 3: 使用 <code>git config</code></span></h4><p>通过配置文件来设置多个 push URL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --add remote.origin.pushurl https://gitlab.com/user/backup-repo.git</span><br></pre></td></tr></table></figure><h2><span id="推送代码">推送代码</span></h2><p>现在，你可以使用以下命令将代码推送到两个远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>或者推送到默认的分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin</span><br></pre></td></tr></table></figure><p>这会将代码推送到 <code>origin</code> 配置的两个 URL，即 <code>origin</code> 和 <code>backup</code> 仓库。</p><h2><span id="推送所有分支">推送所有分支</span></h2><p>如果你想推送所有分支，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --all origin</span><br></pre></td></tr></table></figure><p>这样，你的所有分支都会被推送到 <code>origin</code> 的两个 URL。</p><h2><span id="示例">示例</span></h2><p>假设你的主仓库 URL 是 <code>https://github.com/user/main-repo.git</code>，备份仓库 URL 是 <code>https://gitlab.com/user/backup-repo.git</code>：</p><ol><li>添加备份仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add backup https://gitlab.com/user/backup-repo.git</span><br></pre></td></tr></table></figure><ol start="2"><li>设置 <code>origin</code> 同时推送到两个仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">set</span>-url --add --push origin https://github.com/user/main-repo.git</span><br><span class="line">$ git remote <span class="built_in">set</span>-url --add --push origin https://gitlab.com/user/backup-repo.git</span><br></pre></td></tr></table></figure><ol start="3"><li>推送到两个远程仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>通过以上步骤，你可以轻松配置 Git，同时将代码推送到多个远程仓库，确保代码的备份和同步。希望这篇文章对你有所帮助，如果有任何问题，欢迎在评论区讨论。</p><blockquote><p>本文转载自：「框架師」，原文：<a href="https://url.hi-linux.com/FF4aQ" target="_blank" rel="noopener">https://url.hi-linux.com/FF4aQ</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在日常开发中，我们有时需要将代码推送到多个远程仓库以确保代码备份和同步。本篇文章将介绍如何配置和操作 Git，同时推送代码到两个远程仓库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么需要多个远程仓库？&quot;&gt;为什么需要多个远程仓库？&lt;/h2&gt;
&lt;p&gt;多个远程仓库的常见场景包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;备份：确保代码在不同平台上有备份，例如 &lt;code&gt;GitHub&lt;/code&gt; 和 &lt;code&gt;GitLab&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;协作：团队成员在不同的远程仓库上工作，需要确保代码同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;配置多个远程仓库&quot;&gt;配置多个远程仓库&lt;/h2&gt;
&lt;p&gt;假设我们已经有一个远程仓库 &lt;code&gt;origin&lt;/code&gt;，现在需要添加一个名为 &lt;code&gt;backup&lt;/code&gt; 的远程仓库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Git" scheme="https://www.hi-linux.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>如何实现同一端口代理不同的后端服务</title>
    <link href="https://www.hi-linux.com/posts/34227.html"/>
    <id>https://www.hi-linux.com/posts/34227.html</id>
    <published>2024-08-26T01:00:00.000Z</published>
    <updated>2024-08-26T07:16:00.270Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在网络通信中，端口是用于区分不同服务的重要资源。通常，每个服务会绑定到一个特定端口上，但有时我们需要通过同一个端口来代理不同的服务。这种技术被称为端口复用。本文将介绍端口复用的场景、用途、协议特性，并分别使用 Nginx 和 HAProxy 进行端口复用配置。</p><h2><span id="端口复用的场景与用途">端口复用的场景与用途</span></h2><p>端口复用在以下场景中非常有用：</p><ol><li><strong>资源限制</strong>：在IP地址和端口资源有限的环境中，通过同一端口提供多个服务可以最大化利用现有资源。</li><li><strong>简化配置</strong>：简化客户端配置，使其无需关心不同服务使用不同端口的问题。</li><li><strong>负载均衡与高可用性</strong>：在负载均衡器或反向代理服务器上，通过同一端口代理不同的后端服务，提高服务的可用性和可靠性。</li></ol><a id="more"></a><h2><span id="协议特性">协议特性</span></h2><p>端口复用的实现依赖于协议特性。通过分析协议的特定字段或数据包的前几个字节，可以判断请求的类型并将其转发到相应的后端服务。</p><p>通过 Wireshark 抓包来分析协议特性，下面是分析 MySQL 协议特性的例子：</p><p><img src="https://img.hi-linux.com/staticfile/457511833-20240722142721859-2024-07-22-2p5cXp.png" alt></p><p>从抓包中，可以发现 MySQL 握手包前面 5 个字节是相对固定的 <code>0x490000000a</code>，特别需要注意的是，MySQL 握手包的第一个字节表示包长度，在不同的版本中，长度可能是不一样的，比如说在 8.0.38 版本中，前一个字节是<code>0x4a</code>，需要你抓包确认。</p><p><img src="https://img.hi-linux.com/staticfile/2833408640-20240722142722152-2024-07-22-Jmz8Rf.png" alt></p><p>特别说明一下，MySQL 不能做端口复用，你抓包看MySQL的协议交互会发现，TCP 三次握手之后，第一个包是服务端向客户端发的，这种交互方式在代理层是无法做数据判断的。</p><p>以下是一些常见协议的特性示例：</p><p>在 http 协议中，数据包的前几个字节是<code>GET</code>, <code>POST</code>,<code>PUT</code>,<code>DELETE</code>等，因为长度不一样，通常分析前3字节即可。</p><table><thead><tr><th>协议</th><th>协议特性</th></tr></thead><tbody><tr><td>HTTP(GET)</td><td>payload(0,3) = 474554</td></tr><tr><td>HTTP(POS)</td><td>payload(0,3) = 504f53</td></tr><tr><td>HTTP(PUT)</td><td>payload(0,3) = 505554</td></tr><tr><td>HTTP(DEL)</td><td>payload(0,3) = 44454c</td></tr><tr><td>HTTP(OPT)</td><td>payload(0,3) = 4f5054</td></tr><tr><td>HTTP(HEA)</td><td>payload(0,3) = 484541</td></tr><tr><td>HTTP(CON)</td><td>payload(0,3) = 434f4e</td></tr><tr><td>HTTP(TRA)</td><td>payload(0,3) = 545241</td></tr><tr><td>SSH</td><td>payload(0,3) = 535348</td></tr><tr><td>FTP</td><td>payload(0,3) = 535348</td></tr><tr><td>Redis</td><td>payload(0,4) = 2a320d0a</td></tr></tbody></table><h2><span id="使用-nginx-实现端口复用">使用 Nginx 实现端口复用</span></h2><p>Nginx 是一款高性能的 HTTP 和反向代理服务器。通过结合 Nginx 的 Stream 模块和 Lua 脚本，我们可以根据 payload 的前几个字节实现端口复用。</p><h3><span id="安装必要的软件">安装必要的软件</span></h3><p>首先，确保你安装了带有 Lua 支持的 Nginx，推荐使用 OpenResty，它集成了 Nginx 和 LuaJIT。</p><h3><span id="配置-openresty">配置 OpenResty</span></h3><p>以下是一个 OpenResty 的配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    lua_shared_dict protocol_cache 10m;</span><br><span class="line">    upstream redis_backend &#123;</span><br><span class="line">        server localhost:6379;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    upstream http_backend &#123;</span><br><span class="line">        server localhost:80;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    upstream ssh_backend &#123;</span><br><span class="line">        server localhost:22;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_add_variable $backend;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 3000;</span><br><span class="line">        preread_by_lua_block &#123;</span><br><span class="line">            local sock &#x3D; ngx.req.socket()</span><br><span class="line">            local data, err &#x3D; sock:peek(3)  -- 读取数据包前3个字节</span><br><span class="line">            if not data then</span><br><span class="line">                ngx.log(ngx.ERR, &quot;接收数据失败: &quot;, err)</span><br><span class="line">                return ngx.exit(ngx.ERROR)</span><br><span class="line">            end</span><br><span class="line">            -- 判断payload内容</span><br><span class="line">            if data &#x3D;&#x3D; &quot;\x47\x45\x54&quot; or data &#x3D;&#x3D; &quot;\x50\x4f\x53&quot; or data &#x3D;&#x3D; &quot;\x50\x55\x54&quot; or data &#x3D;&#x3D; &quot;\x44\x45\x4c&quot; or data &#x3D;&#x3D; &quot;\x4f\x50\x54&quot; or data &#x3D;&#x3D; &quot;\x48\x45\x41&quot; or data &#x3D;&#x3D; &quot;\x43\x4f\x4e&quot; or data &#x3D;&#x3D; &quot;\x54\x52\x41&quot; then  -- http</span><br><span class="line">                ngx.var.backend &#x3D; &quot;http_backend&quot;</span><br><span class="line">            elseif data &#x3D;&#x3D; &quot;\x2a\x32\x0d&quot; then -- redis</span><br><span class="line">                ngx.var.backend &#x3D; &quot;redis_backend&quot;</span><br><span class="line">            elseif data &#x3D;&#x3D; &quot;\x53\x53\x48&quot; then -- ssh</span><br><span class="line">                ngx.var.backend &#x3D; &quot;ssh_backend&quot;</span><br><span class="line">            end</span><br><span class="line">        &#125;</span><br><span class="line">        proxy_pass $backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="使用-haproxy-实现端口复用">使用 HAProxy 实现端口复用</span></h2><p>HAProxy 是一款高性能的 TCP/HTTP 负载均衡器。通过配置 HAProxy，我们也可以根据 payload 内容实现端口复用。</p><h3><span id="安装-haproxy">安装 HAProxy</span></h3><p>确保你已经安装了 HAProxy，可以使用包管理器进行安装，如 <code>apt-get install haproxy</code>。</p><h3><span id="配置-haproxy">配置 HAProxy</span></h3><p>以下是一个基于TCP协议的示例配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">frontend main_front</span><br><span class="line">    bind *:3000</span><br><span class="line">    mode tcp</span><br><span class="line">    tcp-request inspect-delay 5s</span><br><span class="line">    </span><br><span class="line">    acl is_http req.payload(0,3) ‐m bin 474554 504f53 505554 44454c 4f5054 484541 434f4e 545241</span><br><span class="line">    acl is_redis req.payload(0,3) ‐m bin 535348</span><br><span class="line">    acl is_ssh req.payload(0,3) ‐m bin 535348</span><br><span class="line">    use_backend http_backend if is_http</span><br><span class="line">    use_backend redis_backend if is_redis</span><br><span class="line">    use_backend ssh_backend if is_ssh</span><br><span class="line">    default_backend another_backend</span><br><span class="line">backend http_backend</span><br><span class="line">    mode tcp</span><br><span class="line">    server server1 localhost:80</span><br><span class="line">backend redis_backend</span><br><span class="line">    mode tcp</span><br><span class="line">    server server1 localhost:6379</span><br><span class="line">backend ssh_backend</span><br><span class="line">    mode tcp</span><br><span class="line">    server server1 localhost:22</span><br><span class="line">backend another_backend</span><br><span class="line">    mode tcp</span><br><span class="line">    server server1 localhost:9000</span><br></pre></td></tr></table></figure><h2><span id="小结">小结</span></h2><p>端口复用能够在资源受限的环境中提高服务的灵活性和可用性。通过分析协议特性，我们可以在同一端口上代理不同的服务。Nginx 和 HAProxy 都提供了强大的功能来实现这一需求，HAProxy 配置更简单明朗。</p><blockquote><p>本文转载自：「 哈希 」，原文：<a href="https://url.hi-linux.com/l3u8n" target="_blank" rel="noopener">https://url.hi-linux.com/l3u8n</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网络通信中，端口是用于区分不同服务的重要资源。通常，每个服务会绑定到一个特定端口上，但有时我们需要通过同一个端口来代理不同的服务。这种技术被称为端口复用。本文将介绍端口复用的场景、用途、协议特性，并分别使用 Nginx 和 HAProxy 进行端口复用配置。&lt;/p&gt;
&lt;h2 id=&quot;端口复用的场景与用途&quot;&gt;端口复用的场景与用途&lt;/h2&gt;
&lt;p&gt;端口复用在以下场景中非常有用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;资源限制&lt;/strong&gt;：在IP地址和端口资源有限的环境中，通过同一端口提供多个服务可以最大化利用现有资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化配置&lt;/strong&gt;：简化客户端配置，使其无需关心不同服务使用不同端口的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡与高可用性&lt;/strong&gt;：在负载均衡器或反向代理服务器上，通过同一端口代理不同的后端服务，提高服务的可用性和可靠性。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>一分钟上手 PG Back Web，让你的 PostgreSQL 备份高枕无忧</title>
    <link href="https://www.hi-linux.com/posts/46814.html"/>
    <id>https://www.hi-linux.com/posts/46814.html</id>
    <published>2024-08-15T01:00:00.000Z</published>
    <updated>2024-08-15T02:15:18.068Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言">引言</span></h2><p>在当今数据驱动的世界中，数据库备份的重要性不言而喻。无论是开发者还是系统管理员，确保数据的安全和可用性都是至关重要的任务。</p><p>然而，手动备份不仅繁琐，还容易出错。幸运的是，有了 PG Back Web，这一切变得轻而易举。本文将带领大家深入了解 pgbackweb 的强大功能，并教你如何使用它来简化 PostgreSQL 的备份任务。</p><h2><span id="什么是-pg-back-web">什么是 PG Back Web？</span></h2><p>PG Back Web 是一个专为 PostgreSQL 数据库设计的备份工具，其核心特点是提供了一个用户友好的网页界面，让备份工作变得简单直观。</p><p>无论你是个人开发者还是团队的一员，PG Back Web 都能帮助你自动化备份任务，节省时间，减少手动操作的麻烦。</p><p>项目地址：<a href="https://github.com/eduardolat/pgbackweb" target="_blank" rel="noopener">https://github.com/eduardolat/pgbackweb</a></p><a id="more"></a><h2><span id="功能介绍">功能介绍</span></h2><h3><span id="简洁直观的网页界面">📦 简洁直观的网页界面</span></h3><p>PG Back Web 提供了一个直观的网页界面，让你无需数据库专业知识也能轻松管理备份。通过这个界面，你可以方便地创建、管理和恢复备份。</p><h3><span id="定时备份">📅 定时备份</span></h3><p>设置定时备份任务，让 PG Back Web 自动化你的备份流程。从此，你再也不用担心忘记手动备份了。</p><h3><span id="备份监控">📈 备份监控</span></h3><p>通过执行日志，你可以可视化地查看备份的状态，确保每次备份都顺利完成。</p><h3><span id="即时下载与恢复">📤 即时下载与恢复</span></h3><p>需要恢复备份？没问题！你可以直接从网页界面下载或恢复你的备份，快速应对各种突发状况。</p><h3><span id="多版本支持">🖥 多版本支持</span></h3><p>PG Back Web 兼容 PostgreSQL 13、14、15 和 16 版本，无论你使用的是哪个版本，都能轻松集成。</p><h3><span id="本地与-s3-存储">📁 本地与 S3 存储</span></h3><p>你可以选择将备份存储在本地，或者添加多个 S3 存储桶，以获得更大的灵活性。</p><h3><span id="安全加密">🔒 安全加密</span></h3><p>PG Back Web 使用 PGP 加密来保护你的敏感信息，确保数据的安全性。</p><h3><span id="️-开源与可信赖">🛡️ 开源与可信赖</span></h3><p>PG Back Web 是一个开源项目，代码公开透明，使用了稳健的 pg_dump 工具，值得信赖。</p><h3><span id="黑暗模式">🌚 黑暗模式</span></h3><p>喜欢黑暗模式？PG Back Web 也提供了这个选项，让你在夜晚操作时更舒适。</p><h2><span id="安装指南">安装指南</span></h2><p>PG Back Web 作为 Docker 镜像提供，你只需要设置两个环境变量就可以开始使用。以下是使用 Docker Compose 运行 PG Back Web 的示例配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">pgbackweb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">eduardolat/pgbackweb:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8085:8085"</span> <span class="comment"># Access the web interface at http://localhost:8085</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./backups:/backups</span> <span class="comment"># If you only use S3 destinations, you don't need this volume</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">PBW_ENCRYPTION_KEY:</span> <span class="string">"my_secret_key"</span></span><br><span class="line">      <span class="attr">PBW_POSTGRES_CONN_STRING:</span> <span class="string">"postgresql://postgres:password@postgres:5432/pgbackweb?sslmode=disable"</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">postgres:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:16</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">pgbackweb</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"5432:5432"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/postgresql/data</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="string">["CMD-SHELL",</span> <span class="string">"pg_isready -U postgres"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>只需将上面的配置保存为 <code>docker-compose.yml</code> 文件，然后运行 <code>docker-compose up -d</code> 命令即可启动 PG Back Web。</p><h2><span id="配置说明">配置说明</span></h2><p>你只需配置以下两个环境变量：</p><ul><li><code>PBW_ENCRYPTION_KEY</code>：你的加密密钥。请生成一个强密码并妥善保存，PG Back Web 会使用它来加密敏感数据。</li><li><code>PBW_POSTGRES_CONN_STRING</code>：用于存储 PG Back Web 数据的 PostgreSQL 数据库连接字符串。</li></ul><h2><span id="截图展示">截图展示</span></h2><p>以下是 PG Back Web 的一些界面截图：</p><p><img src="https://img.hi-linux.com/staticfile/summary-2024-08-14-Wc4Z4o.png" alt="Summary"></p><p><img src="https://img.hi-linux.com/staticfile/backups-2024-08-14-9Wk0wU.png" alt="Backups"></p><p><img src="https://img.hi-linux.com/staticfile/executions-2024-08-14-LaQJTO.png" alt="Executions"></p><h2><span id="重置密码">重置密码</span></h2><p>如果你需要重置 PG Back Web 的密码，可以在运行 PG Back Web 的服务器上执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it &lt;container_name_or_id&gt; sh -c change-password</span><br></pre></td></tr></table></figure><p>将 <code>&lt;container_name_or_id&gt;</code> 替换为 PG Back Web 容器的名称或 ID，然后按照提示操作即可。</p><h2><span id="结论">结论</span></h2><p>PG Back Web 是一个强大且易于使用的 PostgreSQL 备份工具，通过其直观的网页界面和自动化功能，可以大大简化你的备份任务。</p><p>无论你是个人开发者还是团队的一员，PG Back Web 都是你不可或缺的助手。</p><p>立即尝试 PG Back Web，让你的 PostgreSQL 数据备份变得前所未有的简单和高效！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;在当今数据驱动的世界中，数据库备份的重要性不言而喻。无论是开发者还是系统管理员，确保数据的安全和可用性都是至关重要的任务。&lt;/p&gt;
&lt;p&gt;然而，手动备份不仅繁琐，还容易出错。幸运的是，有了 PG Back Web，这一切变得轻而易举。本文将带领大家深入了解 pgbackweb 的强大功能，并教你如何使用它来简化 PostgreSQL 的备份任务。&lt;/p&gt;
&lt;h2 id=&quot;什么是-PG-Back-Web？&quot;&gt;什么是 PG Back Web？&lt;/h2&gt;
&lt;p&gt;PG Back Web 是一个专为 PostgreSQL 数据库设计的备份工具，其核心特点是提供了一个用户友好的网页界面，让备份工作变得简单直观。&lt;/p&gt;
&lt;p&gt;无论你是个人开发者还是团队的一员，PG Back Web 都能帮助你自动化备份任务，节省时间，减少手动操作的麻烦。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/eduardolat/pgbackweb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/eduardolat/pgbackweb&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="PostgreSQL" scheme="https://www.hi-linux.com/tags/PostgreSQL/"/>
    
      <category term="备份" scheme="https://www.hi-linux.com/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>解锁科技魔法「极客光年」，让你的手机看上去更美，从此与众不同！</title>
    <link href="https://www.hi-linux.com/posts/53528.html"/>
    <id>https://www.hi-linux.com/posts/53528.html</id>
    <published>2024-08-14T01:00:00.000Z</published>
    <updated>2024-08-14T02:52:21.584Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><img src="https://img.hi-linux.com/staticfile/WX20240813-141455@2x-2024-08-13-J7YjX4.png" alt></p><p>你是否厌倦了每次解锁手机，看到的都是那些千篇一律的壁纸？你的朋友是不是总能找到令人惊叹的手机背景，而你只能羡慕嫉妒恨？</p><p>别担心，我们找到了解决方案「极客光年」！这个网站简直就是手机壁纸界的宝藏窟，绝对能让你的屏幕从此与众不同！</p><h2><span id="为什么选择极客光年">为什么选择「极客光年」？</span></h2><ol><li><p><strong>海量高质量壁纸</strong></p><p>想象一下，你打开「极客光年」，就像走进了一个巨大的艺术画廊。从绚丽的风景到可爱的动物，从未来科技到复古怀旧，应有尽有。无论你是喜欢简约风还是奇幻风，这里总有一款适合你。</p></li><li><p><strong>摄影大师的杰作</strong></p><p>极客光年不仅仅是壁纸网站，它还是摄影爱好者的天堂。这里汇集了来自世界各地摄影师的精品照片。谁说你的手机屏幕不能成为一件艺术品？在这里，每次解锁都是一次视觉盛宴！</p></li><li><p><strong>AI 图片，引领潮流</strong></p><p>如果你觉得普通照片已经无法满足你的需求，那就来看看「极客光年」的 AI 图片区吧。这里的图片不是普通的 PS，而是由最先进的 AI 技术生成的艺术品。想象一下，你的手机壁纸可能是这个世界上独一无二的存在，酷不酷？</p></li><li><p><strong>免费又方便</strong></p><p>最棒的是，极客光年完全免费！你不需要注册，不需要付费，只需要点击下载，就能获得心仪的壁纸。省钱又省心，还有比这更好的事吗？</p></li></ol><a id="more"></a><h2><span id="如何使用极客光年">如何使用「极客光年」？</span></h2><blockquote><p>「极客光年」网址：<a href="https://bestgeek.org/pic" target="_blank" rel="noopener">https://bestgeek.org/pic</a></p></blockquote><p>使用「极客光年」简单得连你家的宠物狗都能学会（好吧，可能有点夸张）。只需要三步：</p><ol><li>打开网站</li><li>浏览并选择你喜欢的图片</li><li>点击下载</li></ol><p>就这么简单！你甚至可以在等公交车或排队买咖啡的时候完成这个过程。</p><h2><span id="让你的手机与众不同">让你的手机与众不同</span></h2><p>想象一下，当你和朋友聚会时，大家都在比较手机壁纸。你轻轻一按解锁键，瞬间，所有人的目光都被你的屏幕吸引。</p><p>“哇，这壁纸太酷了！”</p><p>“你从哪里找到的？” 他们会问。而你，只需要微微一笑，优雅地说：“哦，这个啊，我在「极客光年」上找到的。”</p><p>从此以后，你就是朋友圈里的壁纸达人，手机屏幕界的时尚坐标！</p><h2><span id="结语">结语</span></h2><p>亲爱的朋友们，还在等什么？快来「极客光年」，让你的手机焕然一新吧！记住，生活可以平凡，但你的手机壁纸绝不能平凡。让「极客光年」成为你的秘密武器，让你的手机屏幕成为你个性的完美展示。</p><p>别忘了，每一次解锁，都是一次视觉享受。每一张壁纸，都是一个小小的惊喜。现在就行动吧，让你的手机从此与众不同！</p><p>「极客光年」 - 因为你的手机，值得拥有最好的壁纸！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/WX20240813-141455@2x-2024-08-13-J7YjX4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;你是否厌倦了每次解锁手机，看到的都是那些千篇一律的壁纸？你的朋友是不是总能找到令人惊叹的手机背景，而你只能羡慕嫉妒恨？&lt;/p&gt;
&lt;p&gt;别担心，我们找到了解决方案「极客光年」！这个网站简直就是手机壁纸界的宝藏窟，绝对能让你的屏幕从此与众不同！&lt;/p&gt;
&lt;h2 id=&quot;为什么选择「极客光年」？&quot;&gt;为什么选择「极客光年」？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;海量高质量壁纸&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想象一下，你打开「极客光年」，就像走进了一个巨大的艺术画廊。从绚丽的风景到可爱的动物，从未来科技到复古怀旧，应有尽有。无论你是喜欢简约风还是奇幻风，这里总有一款适合你。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;摄影大师的杰作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;极客光年不仅仅是壁纸网站，它还是摄影爱好者的天堂。这里汇集了来自世界各地摄影师的精品照片。谁说你的手机屏幕不能成为一件艺术品？在这里，每次解锁都是一次视觉盛宴！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AI 图片，引领潮流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得普通照片已经无法满足你的需求，那就来看看「极客光年」的 AI 图片区吧。这里的图片不是普通的 PS，而是由最先进的 AI 技术生成的艺术品。想象一下，你的手机壁纸可能是这个世界上独一无二的存在，酷不酷？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;免费又方便&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最棒的是，极客光年完全免费！你不需要注册，不需要付费，只需要点击下载，就能获得心仪的壁纸。省钱又省心，还有比这更好的事吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="壁纸" scheme="https://www.hi-linux.com/tags/%E5%A3%81%E7%BA%B8/"/>
    
      <category term="摄影" scheme="https://www.hi-linux.com/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="手机" scheme="https://www.hi-linux.com/tags/%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>告别复杂命令行，Hollama 让与 Ollama AI 对话丝般顺滑</title>
    <link href="https://www.hi-linux.com/posts/37064.html"/>
    <id>https://www.hi-linux.com/posts/37064.html</id>
    <published>2024-08-12T01:00:00.000Z</published>
    <updated>2024-08-12T01:25:13.312Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言">🌐 引言</span></h2><p>在人工智能快速发展的今天，我们越来越依赖各种 AI 工具来提高工作效率和生活质量。</p><p>Ollama 作为一个强大的本地 AI 模型服务器，为我们提供了丰富的 AI 能力。但是，如何更方便地与 Ollama 进行交互呢？</p><p>这就是 Hollama 的用武之地！Hollama 为 Ollama 服务器提供了一个简洁优雅的 Web 界面，让你可以轻松地与 AI 模型对话，无需复杂的命令行操作。让我们一起来探索 Hollama 的魅力吧！</p><a id="more"></a><h2><span id="hollamaollama-的网页化身">🎭 Hollama：Ollama 的网页化身</span></h2><p>Hollama 是一个为 Ollama 服务器设计的极简 Web 用户界面。它的目标是让用户能够通过直观的 Web 界面与 Ollama 提供的 AI 模型进行交互，而不需要直接使用命令行或复杂的 API 调用。</p><p>✨ Hollama 支持的特性:</p><p>✅ 大型提示字段<br>✅ 带语法高亮的 Markdown 渲染<br>✅ 代码编辑器功能<br>✅ 可定制的系统提示<br>✅ 复制代码片段、信息或整个会话<br>✅ 重试完成<br>✅ 在浏览器本地存储数据<br>✅ 响应式布局<br>✅ 浅色和深色主题</p><p>🏷️ Hollama 项目地址：</p><ul><li><a href="https://github.com/fmaclen/hollama" target="_blank" rel="noopener">https://github.com/fmaclen/hollama</a></li></ul><h2><span id="️-安装-hollama简单快捷">🛠️ 安装 Hollama：简单快捷</span></h2><p>要在本地运行 Hollama 服务器，你需要安装 Docker。以下是安装和启动 Hollama 的步骤：</p><h3><span id="通过-docker-部署">通过 Docker 部署</span></h3><h4><span id="1-安装-docker">1. 安装 Docker</span></h4><ul><li>前往 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker 官方网站</a> 下载并安装 Docker Desktop。</li><li>根据你的操作系统选择相应的安装包，并按照提示完成安装。</li></ul><h4><span id="2-运行-hollama-服务器">2. 运行 Hollama 服务器</span></h4><ul><li>打开你的终端，并输入以下命令以启动 Hollama 服务器：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -d -p 4173:4173 ghcr.io/fmaclen/hollama:latest</span><br></pre></td></tr></table></figure><p>这条命令会在后台启动 Hollama 服务器，并将其映射到本地主机的 4173 端口。</p><h4><span id="3-访问-hollama-网页界面">3. 访问 Hollama 网页界面</span></h4><ul><li>在你的浏览器中访问 <code>http://localhost:4173</code>，即可开始使用 Hollama 的网页界面。</li></ul><h3><span id="下载-hollama-桌面端应用">下载 Hollama 桌面端应用</span></h3><p>此外，Hollama 还提供了桌面端应用程序，支持 macOS、Windows 和 Linux 系统。</p><p>如果你更喜欢桌面应用的使用体验，可以下载 Hollama 的桌面端应用：</p><ul><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-mac-arm64.dmg" target="_blank" rel="noopener">Download for macOS ARM</a></li><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-mac-x64.dmg" target="_blank" rel="noopener">Download for macOS x64</a></li><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-win-x64.exe" target="_blank" rel="noopener">Download for Windows</a></li><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-linux-x64.tar.gz" target="_blank" rel="noopener">Download for Linux</a></li></ul><p>安装完成后，桌面应用将为你提供与网页端相同的功能和使用体验。</p><blockquote><p>注意：如果你使用的是公共托管版本，或者你的 Docker 服务器位于与 Ollama 服务器不同的设备上，你就必须在 OLLAMA_ORIGINS 中设置域。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OLLAMA_ORIGINS&#x3D;https:&#x2F;&#x2F;hollama.fernando.is ollama serve</span><br></pre></td></tr></table></figure><h2><span id="使用-hollama简洁而强大的界面">🚀 使用 Hollama：简洁而强大的界面</span></h2><p><img src="https://img.hi-linux.com/staticfile/tE6uxk-2024-08-08-wyzHFq.png" alt></p><p>Hollama 的网页界面设计简洁明了，主要包括以下几个部分：</p><ol><li><strong>模型选择</strong>：你可以选择想要使用的 AI 模型。</li><li><strong>对话区域</strong>：这里显示你与 AI 的对话历史。</li><li><strong>输入框</strong>：在这里输入你想问的问题或指令。</li><li><strong>发送按钮</strong>：点击发送你的输入给 AI 模型。</li></ol><p>使用步骤非常简单：</p><ol><li>选择想要使用的 AI 模型。</li><li>在输入框中输入你的问题或指令。</li><li>点击发送按钮或按回车键。</li><li>等待 AI 的回复，回复会实时显示在对话区域。</li></ol><h3><span id="实时响应流畅的对话体验">🔄 实时响应：流畅的对话体验</span></h3><p>Hollama 支持流式输出，这意味着你可以看到 AI 正在实时生成的回答。每个字都会在你眼前逐步呈现，让你感受到与 AI 进行真实对话的流畅体验。</p><p><img src="https://img.hi-linux.com/staticfile/Ur5eIG-2024-08-08-Z3ycqQ.png" alt></p><h3><span id="多模型支持丰富你的-ai-体验">🎨 多模型支持：丰富你的 AI 体验</span></h3><p>Hollama 支持 Ollama 服务器上所有可用的模型。你可以轻松切换不同的模型，体验它们各自的特点和能力。无论是需要 GPT 系列的创意写作，还是 CodeLlama 的编程协助，Hollama 都能满足你的需求。</p><p><img src="https://img.hi-linux.com/staticfile/EYtDjX-2024-08-08-wRMtho.png" alt></p><h3><span id="对话历史回顾精彩瞬间">📜 对话历史：回顾精彩瞬间</span></h3><p>Hollama 会在浏览器中保存你的对话历史，让你可以随时回顾之前的对话内容。这个功能特别适合那些需要参考之前讨论结果的场景。</p><h3><span id="安全可靠本地部署更安心">🔐 安全可靠：本地部署更安心</span></h3><p>由于 Hollama 是一个本地运行的网页界面，连接的也是本地的 Ollama 服务器，因此你的所有对话都是在本地进行的。这极大地提高了数据的安全性和隐私保护，特别适合处理敏感信息的场景。</p><h3><span id="自定义选项打造专属体验">🌈 自定义选项：打造专属体验</span></h3><p>Hollama 提供了一些自定义选项，让你可以根据个人喜好调整使用体验：</p><ul><li>可以设置默认的 AI 模型</li><li>调整界面主题（如果支持的话）</li><li>设置最大标记数等参数</li></ul><p><img src="https://img.hi-linux.com/staticfile/uiAPvA-2024-08-08-LSGn3K.png" alt></p><h3><span id="响应式设计随时随地畅聊-ai">📱 响应式设计：随时随地畅聊 AI</span></h3><p>Hollama 采用响应式设计，无论你是使用台式电脑、笔记本还是手机，都能获得良好的使用体验。这意味着你可以随时随地与 AI 进行对话，激发创意灵感。</p><h2><span id="结论">🔚 结论</span></h2><p>Hollama 为 Ollama 服务器提供了一个简洁、直观且功能强大的 Web 界面。</p><p>它让与 AI 模型的交互变得前所未有的简单，无论你是 AI 爱好者、开发者，还是普通用户，都能轻松上手。</p><p>通过 Hollama，你可以充分发挥 Ollama 的潜力，探索 AI 的无限可能。</p><p>从此，与 AI 对话再也不是高深莫测的技术活，而是像聊天一样简单自然。Hollama 不仅仅是一个工具，它是连接你与 AI 世界的桥梁，让 AI 的力量触手可及。</p><p>准备好开始你的 AI 探索之旅了吗？</p><p>安装 Hollama，打开浏览器或桌面应用，让我们一起徜徉在 AI 的海洋中，发现 AI 带来的无限可能吧！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;🌐-引言&quot;&gt;🌐 引言&lt;/h2&gt;
&lt;p&gt;在人工智能快速发展的今天，我们越来越依赖各种 AI 工具来提高工作效率和生活质量。&lt;/p&gt;
&lt;p&gt;Ollama 作为一个强大的本地 AI 模型服务器，为我们提供了丰富的 AI 能力。但是，如何更方便地与 Ollama 进行交互呢？&lt;/p&gt;
&lt;p&gt;这就是 Hollama 的用武之地！Hollama 为 Ollama 服务器提供了一个简洁优雅的 Web 界面，让你可以轻松地与 AI 模型对话，无需复杂的命令行操作。让我们一起来探索 Hollama 的魅力吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="AI" scheme="https://www.hi-linux.com/tags/AI/"/>
    
      <category term="Ollama" scheme="https://www.hi-linux.com/tags/Ollama/"/>
    
      <category term="Hollama" scheme="https://www.hi-linux.com/tags/Hollama/"/>
    
  </entry>
  
  <entry>
    <title>10 个你不知道的 cURL 高级实用技巧</title>
    <link href="https://www.hi-linux.com/posts/21794.html"/>
    <id>https://www.hi-linux.com/posts/21794.html</id>
    <published>2024-08-07T01:00:00.000Z</published>
    <updated>2024-08-07T01:23:09.849Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="10-个例子展示为什么-curl-是一个很棒的命令行工具">10 个例子展示为什么 cURL 是一个很棒的命令行工具</span></h2><p>无论你是开发者、DevOps 工程师、系统管理员、QA 还是其他技术岗位，你一定对 cURL 很熟悉——用于通过 URL 传输数据的命令行工具和库。</p><p>然而，大多数时候，我们都只用 <code>curl</code> 来做一些简单的任务，比如下载文件或检查网站是否可访问，但 <code>curl</code> 能做的远不止这些！</p><p>在这篇文章中，我们将介绍一些很酷的例子和技巧，展示为什么 <code>curl</code> 是一个非常棒且被低估的工具……</p><h2><span id="文件名代换">文件名代换</span></h2><p>首先介绍的是文件名代换，它允许我们用一个 <code>curl</code> 命令发出多个请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/users/[1-3]"</span> | jq -s .</span><br><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/users/[0-10:2]"</span> | jq -s .</span><br><span class="line"></span><br><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/photos/&#123;1,6,35&#125;"</span> | jq -s .</span><br><span class="line"></span><br><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/users/[1-3]"</span> -o <span class="string">"file_#1.json"</span></span><br></pre></td></tr></table></figure><p>前两个命令展示了如何运行一系列请求——第一个命令会产生对 <code>.../users/1</code>、<code>.../users/2</code> 和 <code>.../users/3</code> 的请求，而另一个使用步长选项，产生 2、4、6、8 和 10 的请求。考虑到这些特定请求返回的是 JSON，我们还将它与 <code>jq ...</code> 和 <code>-s</code>（slurp）操作符结合，将单个请求的响应合并为一个数组。</p><p>第三个例子使用了特定数字的列表而不是范围，这也适用于字符和单词。例如，我们可以使用 globbing 发出带有多种协议的请求：<code>{http,https}://...</code></p><p>最后一个例子将 globbing 与输出变量结合，文件名中的 <code>#1</code> 变量指的是范围 <code>[1-3]</code>。这将生成 <code>file_1.json</code>、<code>file_2.json</code> 和 <code>file_3.json</code>。</p><a id="more"></a><h2><span id="配置文件">配置文件</span></h2><p>大多数时候，使用 <code>curl</code> 时我们可能希望传递相同的命令行选项，如代理设置、请求超时、头信息等。这时名为 <code>.curlrc</code> 的 <code>curl</code> 配置文件可能会派上用场：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.curlrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些头信息</span></span><br><span class="line">-H <span class="string">"Upgrade-Insecure-Requests: 1"</span></span><br><span class="line">-H <span class="string">"Accept-Language: en-US,en;q=0.8"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟随重定向</span></span><br><span class="line">--location</span><br></pre></td></tr></table></figure><p>这只是一个文本文件，每行代表一个将传递给 <code>curl</code> 的选项。它会自动从 <code>~/.curlrc</code> 读取，所以你不需要任何额外的标志，但你可以使用 <code>-K</code> 来覆盖或指定不同的位置，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -K .curlrc https://google.com</span><br></pre></td></tr></table></figure><p>类似于标志和选项，有时我们也希望传递凭据。这可以通过 <code>--user</code> 选项来完成，但这会将凭据留在 <code>Shell</code> 历史记录中，所以我们可以利用 <code>curl</code> 支持的 <code>.netrc</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.netrc</span></span><br><span class="line">machine https://authenticationtest.com/HTTPAuth/</span><br><span class="line">login user</span><br><span class="line">password pass</span><br></pre></td></tr></table></figure><p>格式包括 <code>machine</code>（URL）、<code>login</code> 和 <code>password</code>。它们可以在一行中或如上所示，并且我们可以在一个文件中有多个。要使用它，只需将其传递给 <code>curl</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --netrc-file .netrc https://authenticationtest.com/HTTPAuth/</span><br></pre></td></tr></table></figure><h2><span id="并行请求">并行请求</span></h2><p>我们已经在 <code>文件名代换部分</code> 讨论了请求的范围，但并行化呢？好吧，<code>curl</code> 也能做到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -I --parallel --parallel-immediate --parallel-max 3 --config websites.txt</span><br><span class="line"></span><br><span class="line">$ curl -I --parallel --parallel-immediate --parallel-max 3 stackoverflow.com google.com example.com</span><br></pre></td></tr></table></figure><p>我们需要做的只是添加 <code>--parallel</code>（或 <code>-Z</code>），<code>curl</code> 将打开最多 50 个并行连接（可以通过 <code>--parallel-max N</code> 更改）。</p><p>还要注意我们是如何提供 URL 的，第一种方法是通过 <code>--config</code> 参数和一个文本文件，看起来像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"stackoverflow.com"</span></span><br><span class="line">url = <span class="string">"google.com"</span></span><br><span class="line">url = <span class="string">"example.com"</span></span><br></pre></td></tr></table></figure><p>另一个方法是将所有 URL 放在命令行上。这两个选项也适用于非并行请求！</p><h2><span id="格式化和变量">格式化和变量</span></h2><p><code>curl</code> 可以输出很多东西，有时会让人不知所措、冗长且不必要。幸运的是，我们可以使用输出格式化只打印我们感兴趣的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ curl --silent --output /dev/null --show-error -w @format.txt http://example.com/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型: text/html; charset=UTF-8</span></span><br><span class="line"><span class="comment"># 代码: 200</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 从 8.1.0:</span></span><br><span class="line"><span class="comment"># 协议: http</span></span><br><span class="line"><span class="comment"># 主机: example.com</span></span><br><span class="line"><span class="comment"># 端口: 80</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 读取头信息内容 (v7.83.0):</span></span><br><span class="line"><span class="comment"># 服务器: Sat, 29 Jun 2024 13:01:30 GMT</span></span><br></pre></td></tr></table></figure><p>我们通过使用 <code>-w</code> 选项并传递一个格式文件来实现这一点。要生成上述输出，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># format.txt</span></span><br><span class="line">类型: %&#123;content_type&#125;\n代码: %&#123;response_code&#125;\n\n</span><br><span class="line"></span><br><span class="line">从 8.1.0:\n\n</span><br><span class="line"></span><br><span class="line">协议: %&#123;url.scheme&#125;\n</span><br><span class="line">主机: %&#123;url.host&#125;\n</span><br><span class="line">端口: %&#123;url.port&#125;\n</span><br><span class="line"></span><br><span class="line">读取头信息内容 (v7.83.0):\n</span><br><span class="line">%header&#123;date&#125;</span><br></pre></td></tr></table></figure><p>每个变量都用 <code>%{...}</code> 包围。它们可以是简单变量，如 <code>response_code</code>，也可以是 <code>url.&lt;NAME&gt;</code> 的一部分，指的是 URL 组件，如主机或端口。最后，我们还可以使用 <code>%header{HEADER_NAME}</code> 变量输出响应头信息。</p><p>格式化的一个很好的用途是测量请求/响应时间，可以用以下格式来实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># format.txt</span></span><br><span class="line">     域名解析时间:  %&#123;time_namelookup&#125;s\n</span><br><span class="line">        连接时间:  %&#123;time_connect&#125;s\n</span><br><span class="line">     应用连接时间:  %&#123;time_appconnect&#125;s\n</span><br><span class="line">       预传输时间:  %&#123;time_pretransfer&#125;s\n</span><br><span class="line">       重定向时间:  %&#123;time_redirect&#125;s\n</span><br><span class="line">      开始传输时间: %&#123;time_starttransfer&#125;s\n</span><br><span class="line">                ----------\n</span><br><span class="line">          总时间:  %&#123;time_total&#125;s\n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">     域名解析时间:  0.000765s</span><br><span class="line">        连接时间:  0.111908s</span><br><span class="line">     应用连接时间:  0.000000s</span><br><span class="line">       预传输时间:  0.111967s</span><br><span class="line">       重定向时间:  0.000000s</span><br><span class="line">     开始传输时间:  0.223373s</span><br><span class="line">                ----------</span><br><span class="line">          总时间:  0.223992s</span><br></pre></td></tr></table></figure><p>有关完整的变量列表，请参阅 <a href="https://everything.curl.dev/usingcurl/verbose/writeout.html#available---write-out-variables" target="_blank" rel="noopener">文档</a>。</p><h2><span id="测试与故障排除">测试与故障排除</span></h2><p>使用 <code>curl</code> 最常见的方式是进行（网络）故障排除。通常只需对特定 URL 发出请求即可提供足够的信息，但我们可以做更多的事情，例如我们可以强制使用特定的本地网络接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip link show</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 3: wlp5s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DORMANT group default qlen 1000</span></span><br><span class="line"></span><br><span class="line">$ curl --interface wlp5s0 https://example.com</span><br></pre></td></tr></table></figure><p>同样，我们可以强制使用特定的 DNS 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --dns-ipv4-addr 1.1.1.1 https://example.com</span><br></pre></td></tr></table></figure><p>或者我们可以测试超时并捕获退出代码（<a href="https://everything.curl.dev/cmdline/exitcode.html" target="_blank" rel="noopener">退出代码</a>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl --connect-timeout 30 --silent --output /dev/null \</span><br><span class="line">  --show-error -w <span class="string">'总时间: %&#123;time_total&#125;s\n'</span> http://google.com/ || EXIT_CODE=$?</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$EXIT_CODE</span> = 28 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"无法连接（超时）。"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"可以连接。"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这对测试代理服务器是否正常工作非常有用（使用 <code>-x http://proxy.example.com:80</code>）。</p><h2><span id="trurl">Trurl</span></h2><p><code>curl</code> 不只是一个 CLI 工具——该项目还包括 <code>libcurl</code> 以及 <code>trurl</code>，我想在这里展示一下。</p><p><a href="https://curl.se/trurl/" target="_blank" rel="noopener">trurl</a> 是一个用于解析 URL 的专用工具，是 <code>curl</code> 的兄弟项目。可以从源代码安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libcurl4-openssl-dev</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/curl/trurl.git</span><br><span class="line">$ <span class="built_in">cd</span> trurl</span><br><span class="line">$ make</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>这里有几个使用它的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ trurl --url https://example.com/some/path/to/file.html --get <span class="string">'&#123;path&#125;'</span></span><br><span class="line"><span class="comment"># /some/path/to/file.html</span></span><br><span class="line"></span><br><span class="line">$ trurl --url <span class="string">"https://example.com/?name=hello"</span> --append query=key=value</span><br><span class="line"><span class="comment"># https://example.com/?name=hello&amp;key=value</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析为 JSON：</span></span><br><span class="line">$ trurl --url <span class="string">"https://example.com/?name=hello"</span> --json</span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment">#   &#123;</span></span><br><span class="line"><span class="comment">#     "url": "https://example.com/?name=hello",</span></span><br><span class="line"><span class="comment">#     "parts": &#123;</span></span><br><span class="line"><span class="comment">#       "scheme": "https",</span></span><br><span class="line"><span class="comment">#       "host": "example.com",</span></span><br><span class="line"><span class="comment">#       "path": "/",</span></span><br><span class="line"><span class="comment">#       "query": "name=hello"</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     "params": [</span></span><br><span class="line"><span class="comment">#       &#123;</span></span><br><span class="line"><span class="comment">#         "key": "name",</span></span><br><span class="line"><span class="comment">#         "value": "hello"</span></span><br><span class="line"><span class="comment">#       &#125;</span></span><br><span class="line"><span class="comment">#     ]</span></span><br><span class="line"><span class="comment">#   &#125;</span></span><br><span class="line"><span class="comment"># ]</span></span><br></pre></td></tr></table></figure><p>第一个例子展示了如何提取 URL 组件，这里是路径，但也可以是如 url、scheme、user、password、options 或 host 等。</p><p>第二个例子使用 <code>append</code> 功能，向 URL 添加查询参数。</p><p>最后一个例子展示了 <code>--json</code> 选项，它将解析的 URL 输出为 JSON，非常适合进一步处理。</p><p><code>trurl</code> 可以做更多事情，你可以查看 <a href="https://www.youtube.com/watch?v=oDL7DVszr2w" target="_blank" rel="noopener">这个视频</a> 或 <a href="https://curl.se/trurl/manual.html" target="_blank" rel="noopener">手册</a>（底部有例子）。</p><h2><span id="发送上传数据">发送/上传数据</span></h2><p>大多数时候我们使用 <code>curl</code> 下载或请求数据，但它（显然）也可以发送数据。用 <code>curl</code> 发送 POST 数据并不是什么新鲜事，对吧？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST <span class="string">"https://httpbin.org/post"</span> -H <span class="string">"accept: application/json"</span> --json <span class="string">'&#123;"key": "value"&#125;'</span></span><br></pre></td></tr></table></figure><p>但这样发送 JSON，需要在单引号和双引号之间切换，很快就会变得很烦人，但有一个更好的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jo -p key=value | curl -X POST <span class="string">"https://httpbin.org/post"</span> -H <span class="string">"accept: application/json"</span> --json @-</span><br></pre></td></tr></table></figure><p>我想我们都熟悉用 <code>jq</code> 解析 <code>curl</code> 的 JSON 输出，但反过来呢？</p><p>上面我们使用 <code>jo</code> 工具，它可以轻松创建 JSON，然后我们可以使用 <code>--json</code> 选项将其传递给 <code>curl</code>。</p><p>当然，<code>--json</code> 选项也可以从文件中读取输入，例如使用 <code>--json @data.json</code>。</p><h2><span id="协议">协议</span></h2><p>最后但同样重要的是协议 —— 通常我们只会使用 HTTP 或 HTTPS，但 <code>curl</code> 支持 <a href="https://everything.curl.dev/protocols/protocols.html#what-other-protocols-are-there" target="_blank" rel="noopener">很多协议</a>。</p><p>我特别想提到一个是 <code>telnet</code>，它对于测试服务器是否监听特定端口很有用，但如果你在一台没有安装也不能安装 <code>telnet</code> 的服务器/机器上怎么办？只需使用 <code>curl</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同 telnet example.com 1234</span></span><br><span class="line">$ curl telnet://example.com:1234</span><br></pre></td></tr></table></figure><p>一些更为冷门（有趣）的协议选项是用于电子邮件的 IMAP、POP3 和 SMTP，这意味着你可以使用 <code>curl</code> 阅读和发送电子邮件。要阅读它们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --url <span class="string">"imaps://imap.gmail.com:993/Inbox;UID=1"</span> --user <span class="string">"[email protected]:PASSWORD"</span></span><br></pre></td></tr></table></figure><p>要使其在 GMail 上工作，你需要创建 <a href="https://support.google.com/mail/answer/185833?hl=en" target="_blank" rel="noopener">应用密码</a>，这比正常密码更不安全。如果你真的想尝试这个，请查看 <a href="https://developers.google.com/gmail/imap/imap-extensions" target="_blank" rel="noopener">Gmail IMAP 文档</a> 和 <a href="https://gist.github.com/akpoff/53ac391037ae2f2d376214eac4a23634" target="_blank" rel="noopener">这些查询</a> 以获取灵感。</p><p>要发送电子邮件，你可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl smtp://mail.example.com \</span><br><span class="line">  --mail-from [email protected] \</span><br><span class="line">  --mail-rcpt [email protected] \</span><br><span class="line">  --upload-file message.txt \</span><br><span class="line">  -u <span class="string">"[email protected]:PASSWORD"</span></span><br></pre></td></tr></table></figure><p>这里的 <code>message.txt</code> 是实际的电子邮件，需要遵循特定格式，请查看 <a href="https://everything.curl.dev/usingcurl/smtp.html" target="_blank" rel="noopener">这个页面</a> 了解示例。</p><h2><span id="结论">结论</span></h2><p>我们到了最后，我很确定这些例子至少有 10 个（我停止计数了）。但老实说，这只是冰山一角——我们甚至没有触及 <code>curl</code> 的重要级成部分 <code>libcurl</code>。</p><p><code>curl</code> 可以做的事情还有很多，所以我推荐你去探索 <a href="https://curl.se/docs/manpage.html" target="_blank" rel="noopener">文档</a> 和 <a href="https://everything.curl.dev/" target="_blank" rel="noopener">https://everything.curl.dev/</a>。</p><blockquote><p>本文翻译自：「 Martin Heinz 」，原文：<a href="https://martinheinz.dev/blog/113" target="_blank" rel="noopener">https://martinheinz.dev/blog/113</a> ，版权归原作者所有。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;10-个例子展示为什么-cURL-是一个很棒的命令行工具&quot;&gt;10 个例子展示为什么 cURL 是一个很棒的命令行工具&lt;/h2&gt;
&lt;p&gt;无论你是开发者、DevOps 工程师、系统管理员、QA 还是其他技术岗位，你一定对 cURL 很熟悉——用于通过 URL 传输数据的命令行工具和库。&lt;/p&gt;
&lt;p&gt;然而，大多数时候，我们都只用 &lt;code&gt;curl&lt;/code&gt; 来做一些简单的任务，比如下载文件或检查网站是否可访问，但 &lt;code&gt;curl&lt;/code&gt; 能做的远不止这些！&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将介绍一些很酷的例子和技巧，展示为什么 &lt;code&gt;curl&lt;/code&gt; 是一个非常棒且被低估的工具……&lt;/p&gt;
&lt;h2 id=&quot;文件名代换&quot;&gt;文件名代换&lt;/h2&gt;
&lt;p&gt;首先介绍的是文件名代换，它允许我们用一个 &lt;code&gt;curl&lt;/code&gt; 命令发出多个请求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/users/[1-3]&quot;&lt;/span&gt; | jq -s .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/users/[0-10:2]&quot;&lt;/span&gt; | jq -s .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/photos/&amp;#123;1,6,35&amp;#125;&quot;&lt;/span&gt; | jq -s .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/users/[1-3]&quot;&lt;/span&gt; -o &lt;span class=&quot;string&quot;&gt;&quot;file_#1.json&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前两个命令展示了如何运行一系列请求——第一个命令会产生对 &lt;code&gt;.../users/1&lt;/code&gt;、&lt;code&gt;.../users/2&lt;/code&gt; 和 &lt;code&gt;.../users/3&lt;/code&gt; 的请求，而另一个使用步长选项，产生 2、4、6、8 和 10 的请求。考虑到这些特定请求返回的是 JSON，我们还将它与 &lt;code&gt;jq ...&lt;/code&gt; 和 &lt;code&gt;-s&lt;/code&gt;（slurp）操作符结合，将单个请求的响应合并为一个数组。&lt;/p&gt;
&lt;p&gt;第三个例子使用了特定数字的列表而不是范围，这也适用于字符和单词。例如，我们可以使用 globbing 发出带有多种协议的请求：&lt;code&gt;{http,https}://...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后一个例子将 globbing 与输出变量结合，文件名中的 &lt;code&gt;#1&lt;/code&gt; 变量指的是范围 &lt;code&gt;[1-3]&lt;/code&gt;。这将生成 &lt;code&gt;file_1.json&lt;/code&gt;、&lt;code&gt;file_2.json&lt;/code&gt; 和 &lt;code&gt;file_3.json&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="cURL" scheme="https://www.hi-linux.com/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cdebug 容器调试界的瑞士军刀，5 个超能力让你成为调试大师</title>
    <link href="https://www.hi-linux.com/posts/11869.html"/>
    <id>https://www.hi-linux.com/posts/11869.html</id>
    <published>2024-08-06T01:00:00.000Z</published>
    <updated>2024-08-06T01:38:36.591Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>你是否曾经遇到过这样的情况:</p><ul><li>需要调试一个没有 Shell 的容器?</li><li>或者想访问容器内部未公开的端口?</li><li>也许你只是想方便地将容器文件系统导出到本地?</li></ul><p>如果有，那么 <code>cdebug</code> 就是为你量身打造的工具!</p><a id="more"></a><h2><span id="什么是-cdebug">什么是 cdebug?</span></h2><p><code>cdebug</code> 是一个功能强大的容器调试工具，它就像是容器世界的瑞士军刀。无论你是在处理 <code>Docker</code> 容器、<code>Kubernetes Pod</code>，还是其他类型的容器，<code>cdebug</code> 都能给你提供所需的工具和便利。</p><p>想象一下，你有一个神奇的工具箱，里面装满了各种调试工具。现在，你可以随时随地打开这个工具箱，解决容器中遇到的各种问题。这就是 <code>cdebug</code>!</p><ul><li>Github 地址: <a href="https://github.com/iximiuz/cdebug" target="_blank" rel="noopener">https://github.com/iximiuz/cdebug</a></li></ul><h2><span id="cdebug-能做什么">cdebug 能做什么?</span></h2><ol><li><strong>调试 “无 Shell” 容器</strong>: 即使容器内没有 Shell 或调试工具，你也能轻松进入并调试。</li><li><strong>端口魔术师</strong>: 将未公开的端口或 localhost 端口转发到你的主机系统。</li><li><strong>反向通道</strong>: 将主机系统的端点暴露给容器和 Kubernetes 网络。</li><li><strong>文件系统导出专家</strong>: 轻松将镜像或容器的文件系统导出到本地文件夹。</li><li><strong>更多惊喜等你发现…</strong></li></ol><h2><span id="安装-cdebug-简单得不能再简单">安装 cdebug: 简单得不能再简单!</span></h2><p><code>cdebug</code> 是一个静态链接的 <code>Go</code> 二进制文件，安装起来就像变魔术一样简单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于Linux amd64系统</span></span><br><span class="line">GOOS=linux</span><br><span class="line">GOARCH=amd64</span><br><span class="line"></span><br><span class="line">$ curl -Ls https://github.com/iximiuz/cdebug/releases/latest/download/cdebug_<span class="variable">$&#123;GOOS&#125;</span>_<span class="variable">$&#123;GOARCH&#125;</span>.tar.gz | tar xvz</span><br><span class="line"></span><br><span class="line">$ sudo mv cdebug /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><p>如果你是 <code>Homebrew</code> 用户，那就更简单了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install cdebug</span><br></pre></td></tr></table></figure><p>目前支持的系统:</p><ul><li>linux/amd64</li><li>darwin/amd64</li><li>darwin/arm64</li></ul><h2><span id="cdebug-使用指南-让调试变得有趣">cdebug 使用指南: 让调试变得有趣!</span></h2><h3><span id="1-cdebug-exec-你的容器你做主">1. cdebug exec: 你的容器，你做主</span></h3><p>想在一个 “瘦身” 容器中启动一个交互式 Shell? 没问题!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Docker 容器中启动一个 busybox:musl 的 shell</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it mycontainer</span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it docker://mycontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器中执行命令</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> mycontainer cat /etc/os-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用不同的调试工具包镜像</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image=alpine mycontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 nixery.dev 镜像，按需定制你的工具</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image=nixery.dev/shell/vim/ps/tshark mycontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 containerd 容器中执行</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it containerd://mycontainer ...</span><br><span class="line">$ cdebug <span class="built_in">exec</span> --namespace myns -it containerd://mycontainer ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 nerdctl 在容器中执行 </span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it nerdctl://mycontainer ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Kubernetes pod 中启动 shell</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/mypod</span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it k8s://mypod</span><br><span class="line">$ cdebug <span class="built_in">exec</span> --namespace=myns -it pod/mypod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Kubernetes pod 的容器中启动 shell</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/mypod/mycontainer</span><br></pre></td></tr></table></figure><p><code>cdebug exec</code> 就像是 <code>docker exec</code> 和 <code>kubectl debug</code> 的完美结合。它能让你在目标容器中启动一个调试用的 “伴侣” 容器，感觉就像是在使用 <code>docker exec</code>，但功能更强大:</p><ul><li>调试器的根文件系统就是目标容器的根文件系统。</li><li>目标容器不会被重新创建或重启。</li><li>无需额外的卷或复制调试工具。</li><li>调试工具在目标容器中随时可用。</li></ul><h3><span id="2-cdebug-port-forward-端口转发从未如此简单">2. cdebug port-forward: 端口转发从未如此简单</span></h3><p>想要访问容器内部的 “隐藏” 端口? 或者将本地端口暴露给容器? <code>cdebug port-forward</code> 助你轻松搞定!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器的 80 端口发布到主机的随机端口</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器的 localhost:5432 暴露到主机系统</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L 127.0.0.1:5432</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过目标容器将本地流量代理到远程主机</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L &lt;LOCAL_HOST&gt;:&lt;LOCAL_PORT&gt;:&lt;REMOTE_HOST&gt;:&lt;REMOTE_PORT&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 Kubernetes 服务暴露到主机系统</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L 8888:my.svc.cluster.local:443</span><br></pre></td></tr></table></figure><h3><span id="3-实战示例">3. 实战示例</span></h3><h4><span id="示例-1-给-无-shell-容器一个温暖的家">示例 1: 给 “无 Shell” 容器一个温暖的家</span></h4><p>想象你有一个基于 <code>Distroless</code> 的 <code>Node.js</code> 容器，没有 <code>Shell</code>，没有调试工具，简直就是一个 “光秃秃” 的容器。别担心，<code>cdebug</code> 来救场!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先，启动一个目标容器</span></span><br><span class="line">$ $ docker run -d --rm \</span><br><span class="line">  --name my-distroless gcr.io/distroless/nodejs \</span><br><span class="line">  -e <span class="string">'setTimeout(() =&gt; console.log("Done"), 99999999)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后，使用 cdebug 进入容器</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it my-distroless</span><br><span class="line"></span><br><span class="line"><span class="comment"># 瞧!你现在有了一个交互式 shell</span></span><br><span class="line">/ <span class="variable">$#</span> ls -lah</span><br><span class="line">total 60K</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Oct 17 23:49 .</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Oct 17 23:49 ..</span><br><span class="line">👉 lrwxrwxrwx 1 root     root          18 Oct 17 23:49 .cdebug-c153d669 -&gt; /proc/55/root/bin/</span><br><span class="line">-rwxr-xr-x    1 root     root           0 Oct 17 19:49 .dockerenv</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Jan  1  1970 bin</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Jan  1  1970 boot</span><br><span class="line">drwxr-xr-x    5 root     root         340 Oct 17 19:49 dev</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Oct 17 19:49 etc</span><br><span class="line">drwxr-xr-x    3 nonroot  nonroot     4.0K Jan  1  1970 home</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Jan  1  1970 lib</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Jan  1  1970 lib64</span><br><span class="line">drwxr-xr-x    5 root     root        4.0K Jan  1  1970 nodejs</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4><span id="示例-2-给你的容器加上超能力">示例 2: 给你的容器加上超能力</span></h4><p>有时候，<code>busybox</code> 提供的工具可能不够用。没关系，我们可以借助 <code>nixery</code> 项目的力量，给容器加上任何你想要的工具!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想要一个带有 vim 的 shell? 没问题!</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image nixery.dev/shell/vim my-distroless</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要更多高级工具?来吧!</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image nixery.dev/shell/ps/findutils/tshark my-distroless</span><br></pre></td></tr></table></figure><h4><span id="示例-3-调试-containerd-容器无需-docker">示例 3: 调试 containerd 容器（无需 Docker）</span></h4><p>首先，启动目标容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ctr image pull docker.io/library/nginx:latest</span><br><span class="line">$ sudo ctr run -d docker.io/library/nginx:latest nginx-1</span><br></pre></td></tr></table></figure><p>使用简单的 <code>cdebug exec</code> 在目标容器中运行交互式 <code>Shell</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it containerd://nginx-1</span><br><span class="line">/ <span class="variable">$#</span> wget -O- 127.0.0.1</span><br></pre></td></tr></table></figure><p>使用 <code>cdebug exec --image nixery.dev/shell/vim</code> 在目标容器中运行 <code>VIM</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it --rm --image nixery.dev/shell/vim containerd://nginx-1</span><br></pre></td></tr></table></figure><h4><span id="示例-4-调试-nerdctl-容器无需-docker">示例 4: 调试 nerdctl 容器（无需 Docker）</span></h4><p>使用 <code>nerdctl</code> 启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo $(<span class="built_in">which</span> nerdctl) run -d --name nginx-1 nginx</span><br><span class="line">9f8763d82259a6e3e747df83d0ce8b7ee3d33d94269a72cd04e0e3862a3abc5f</span><br></pre></td></tr></table></figure><p>使用 <code>nerdctl://</code> 模式和目标名称运行调试器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it --rm nerdctl://nginx-1</span><br></pre></td></tr></table></figure><p>或者使用 <code>containerd://</code> 模式在上述容器中运行调试会话：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it --rm containerd://9f876</span><br></pre></td></tr></table></figure><h4><span id="示例-5-kubernetes-pod-调试大师">示例 5: Kubernetes Pod 调试大师</span></h4><p>在 Kubernetes 中调试 Pod 不再是噩梦:</p><p>首先，创建一个 Pod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run --image nginx:alpine nginx-1</span><br><span class="line">$ kubectl run --image=nginx:alpine nginx-1 \</span><br><span class="line">  --overrides=<span class="string">'&#123; "apiVersion": "v1", "spec": &#123; "containers": [&#123; "name": "app", "image": "nginx:alpine" &#125;] &#125; &#125;'</span></span><br><span class="line">pod/nginx-1 created</span><br><span class="line"></span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-1   1/1     Running   0         5s</span><br></pre></td></tr></table></figure><p>然后，使用 <code>cdebug</code> 进入Pod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/nginx-1</span><br><span class="line"></span><br><span class="line">Debugger container name: cdebug-3023d11d</span><br><span class="line">Starting debugger container...</span><br><span class="line">Waiting <span class="keyword">for</span> debugger container...</span><br><span class="line">Attaching to debugger container...</span><br><span class="line">If you don<span class="string">'t see a command prompt, try pressing enter.</span></span><br><span class="line"><span class="string">/ # ps auxf</span></span><br><span class="line"><span class="string">PID   USER     TIME  COMMAND</span></span><br><span class="line"><span class="string">    1 root      0:00 sh /.cdebug-entrypoint.sh</span></span><br><span class="line"><span class="string">   10 root      0:00 /bin/sh -i</span></span><br><span class="line"><span class="string">   11 root      0:00 ps auxf</span></span><br></pre></td></tr></table></figure><p>想要直接进入特定的容器? 也是没问题的!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/nginx-1/app</span><br><span class="line"></span><br><span class="line">cdebug <span class="built_in">exec</span> -it pod/nginx-1/app</span><br><span class="line">Debugger container name: cdebug-b44ca485</span><br><span class="line">Starting debugger container...</span><br><span class="line">Waiting <span class="keyword">for</span> debugger container...</span><br><span class="line">Attaching to debugger container...</span><br><span class="line">If you don<span class="string">'t see a command prompt, try pressing enter.</span></span><br><span class="line"><span class="string">/ # ps auxf</span></span><br><span class="line"><span class="string">PID   USER     TIME  COMMAND</span></span><br><span class="line"><span class="string">    1 root      0:00 nginx: master process nginx -g daemon off;</span></span><br><span class="line"><span class="string">   30 nginx     0:00 nginx: worker process</span></span><br><span class="line"><span class="string">   ...</span></span><br><span class="line"><span class="string">   41 nginx     0:00 nginx: worker process</span></span><br><span class="line"><span class="string">   42 root      0:00 sh /.cdebug-entrypoint.sh</span></span><br><span class="line"><span class="string">   51 root      0:00 /bin/ash -i</span></span><br><span class="line"><span class="string">   52 root      0:00 ps auxf</span></span><br></pre></td></tr></table></figure><h4><span id="示例-6-端口转发魔术">示例 6: 端口转发魔术</span></h4><h5><span id="61-忘记发布容器端口了-cdebug-来帮忙">6.1 忘记发布容器端口了? cdebug 来帮忙:</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个nginx容器，不暴露任何端口</span></span><br><span class="line">$ docker run -d --name nginx-1 nginx:1.23</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 cdebug 将本地 8080 端口转发到容器的 80 端口</span></span><br><span class="line">$ cdebug port-forward nginx-1 -L 8080:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在你可以访问 nginx了</span></span><br><span class="line">$ curl localhost:8080</span><br></pre></td></tr></table></figure><h5><span id="62-将本地端口暴露给容器">6.2 将本地端口暴露给容器:</span></h5><p>启动仅监听本地主机的容器化服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name svc-1 python:3-alpine python3 -m <span class="string">'http.server'</span> -b 127.0.0.1 8888</span><br></pre></td></tr></table></figure><p>利用上述服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cdebug port-forward svc-1 -L 127.0.0.1:8888</span><br><span class="line">Pulling forwarder image...</span><br><span class="line">latest: Pulling from shell&#x2F;socat</span><br><span class="line">Digest: sha256:b43b6cf8d22615616b13c744b8ff525f5f6c0ca6c11b37fa3832a951ebb3c20c</span><br><span class="line">Status: Image is up to date for nixery.dev&#x2F;shell&#x2F;socat:latest</span><br><span class="line">Forwarding 127.0.0.1:49176 to 127.0.0.1:8888 through 172.17.0.4:34128</span><br><span class="line"></span><br><span class="line">$ curl localhost:49176</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2><span id="总结-你的容器调试新伙伴">总结: 你的容器调试新伙伴</span></h2><p><code>cdebug</code> 不仅仅是一个工具，它是你在容器世界冒险时的得力助手。无论你是在调试一个顽固的容器，还是需要快速访问一个隐藏的服务，<code>cdebug</code> 都能帮你搞定。</p><p>记住，在容器的海洋中，<code>cdebug</code> 就是你的瑞士军刀。所以，下次当你面对一个看似不可能的容器调试任务时，别忘了问问自己:“我的 <code>cdebug</code> 在哪里?”</p><p>祝你调试愉快，容器世界的冒险家!</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否曾经遇到过这样的情况:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要调试一个没有 Shell 的容器?&lt;/li&gt;
&lt;li&gt;或者想访问容器内部未公开的端口?&lt;/li&gt;
&lt;li&gt;也许你只是想方便地将容器文件系统导出到本地?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果有，那么 &lt;code&gt;cdebug&lt;/code&gt; 就是为你量身打造的工具!&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="cdebug" scheme="https://www.hi-linux.com/tags/cdebug/"/>
    
  </entry>
  
  <entry>
    <title>开发者必备神器，find-container-process 一键让容器进程无所遁形</title>
    <link href="https://www.hi-linux.com/posts/59304.html"/>
    <id>https://www.hi-linux.com/posts/59304.html</id>
    <published>2024-08-05T01:00:00.000Z</published>
    <updated>2024-08-05T01:21:14.549Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>嘿，开发者朋友们！你是否曾经在一堆容器和进程中迷失过方向？</p><p>你是否曾经怀疑你的容器里到底藏了哪些神秘的进程？别担心，我们的 <code>find-container-process</code> 工具来了！</p><p>这个小工具能帮你轻松找到指定的进程所在的容器，并展示详细信息。它简洁实用，让你在调试和管理容器时不再抓狂。</p><h2><span id="find-container-process-功能">find-container-process 功能</span></h2><p><code>find-container-process</code> 有哪些神奇的功能呢？简单来说，它能：</p><ul><li>根据你输入的进程 ID (PID)，找到对应的 Docker 容器。</li><li>显示进程名称、进程 ID、容器名称和容器 ID。</li><li>提供一个整洁的表格视图，让信息一目了然。</li></ul><a id="more"></a><h2><span id="find-container-process-使用方法">find-container-process 使用方法</span></h2><h3><span id="环境要求">环境要求</span></h3><ul><li>需要安装 <code>Docker</code>。</li></ul><h3><span id="在-docker-容器中运行-find-container-process">在 Docker 容器中运行 find-container-process</span></h3><p>运行以下命令启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it --name find-container-process -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/find-container-process</span><br></pre></td></tr></table></figure><h3><span id="find-container-process-操作方法">find-container-process 操作方法</span></h3><ol><li><strong>输入 PID 列表</strong></li></ol><p>程序启动后，会提示你输入一个或多个 PID（用逗号分隔）。</p><p>别担心，这里没有陷阱，只需输入你想要查找的进程 ID，按下回车键即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter the PIDs (comma-separated): 3347139,3347187,3347188,3347189,3347208</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>查看结果</strong></li></ol><p>程序会显示一个漂亮的表格，包含进程名称、进程 ID、容器名称和容器 ID。</p><p>看看，这样是不是清晰多了？</p><p><img src="https://img.hi-linux.com/staticfile/qGFtDH-2024-08-02-l4sKH9.png" alt></p><h3><span id="注意事项">注意事项</span></h3><ul><li>请确保 Docker 正在运行，并且你有足够的权限访问 Docker 守护进程（即你在 Docker 组中）。</li><li>如果你在容器中运行这个工具，请使用 <code>--privileged</code> 选项，并挂载 Docker 套接字：<code>-v /var/run/docker.sock:/var/run/docker.sock</code>。</li><li>我们使用 <code>--pid=host</code> 和 <code>--net=host</code> 来允许容器访问主机的进程和网络命名空间。</li></ul><h2><span id="结语">结语</span></h2><p>好了，朋友们，现在你又拥有了一个强大的 <code>Docker</code> 小工具，它能在容器和进程的迷宫中轻松导航。</p><p><code>find-container-process</code> 将成为你调试和管理 <code>Docker</code> 容器的得力助手。如果你觉得这个工具有趣又实用，别忘了给我们点个星星哦！</p><p>祝你在容器的世界里玩得开心！🚀</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嘿，开发者朋友们！你是否曾经在一堆容器和进程中迷失过方向？&lt;/p&gt;
&lt;p&gt;你是否曾经怀疑你的容器里到底藏了哪些神秘的进程？别担心，我们的 &lt;code&gt;find-container-process&lt;/code&gt; 工具来了！&lt;/p&gt;
&lt;p&gt;这个小工具能帮你轻松找到指定的进程所在的容器，并展示详细信息。它简洁实用，让你在调试和管理容器时不再抓狂。&lt;/p&gt;
&lt;h2 id=&quot;find-container-process-功能&quot;&gt;find-container-process 功能&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;find-container-process&lt;/code&gt; 有哪些神奇的功能呢？简单来说，它能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据你输入的进程 ID (PID)，找到对应的 Docker 容器。&lt;/li&gt;
&lt;li&gt;显示进程名称、进程 ID、容器名称和容器 ID。&lt;/li&gt;
&lt;li&gt;提供一个整洁的表格视图，让信息一目了然。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>一键测速、24 小时实时监控，MySpeed 让你成为网络管理专家</title>
    <link href="https://www.hi-linux.com/posts/55534.html"/>
    <id>https://www.hi-linux.com/posts/55534.html</id>
    <published>2024-07-30T01:00:00.000Z</published>
    <updated>2024-07-30T05:55:03.012Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>你是否曾经遇到过网速突然变慢，但又不知道如何查找原因的情况？或者你想长期监控你的网络性能，但找不到合适的工具？</p><p>别担心，<code>MySpeed</code> 来啦！这个强大而简单的工具可以帮助你轻松测试和监控网络速度。今天，让我们一起深入了解 <code>MySpeed</code>，看看它如何成为你的网络管家!</p><h2><span id="什么是-myspeed">什么是 MySpeed？</span></h2><p><code>MySpeed</code> 是一个开源的网络速度测试和监控工具。它不仅可以测试你的当前网速，还能持续监控网络性能，并以图表形式展示结果。无论你是网络达人还是普通用户，<code>MySpeed</code> 都能满足你的需求。</p><p><code>MySpeed</code> 支持 <code>Ookla</code>、<code>LibreSpeed</code> 和 <code>Cloudflare</code> 多种速度测试服务器。你可以根据自身需求，在它们之间进行任意选择。</p><ul><li>MySpeed 官方地址</li></ul><p><a href="https://myspeed.dev/" target="_blank" rel="noopener">https://myspeed.dev/</a></p><ul><li>MySpeed Github 地址</li></ul><p><a href="https://github.com/gnmyt/myspeed" target="_blank" rel="noopener">https://github.com/gnmyt/myspeed</a></p><a id="more"></a><p>⭐ MySpeed 具有以下特性</p><p>📊 <code>MySpeed</code> 可生成清晰的速度、<code>Ping</code> 等统计数据<br>⏰ <code>MySpeed</code> 可自动进行速度测试，并允许您使用 <code>Cron</code> 表达式设置测试之间的时间间隔<br>🗄️ 直接向 <code>MySpeed</code> 实例添加多个服务器<br>🩺 配置健康检查，以便在出现错误或停机时通过电子邮件、Signal、WhatsApp 或 Telegram 通知您<br>📆 测试结果可存储长达 30 天<br>🔥 支持 <code>Prometheus</code> 和 <code>Grafana</code><br>🗳️ 在 <code>Ookla</code>、<code>LibreSpeed</code> 和 <code>Cloudflare</code> 速度测试服务器之间进行选择</p><h2><span id="为什么选择-myspeed">为什么选择 MySpeed?</span></h2><ol><li><strong>开源免费</strong>: 作为一个开源项目，<code>MySpeed</code> 完全免费使用，你还可以根据需要自定义功能。</li><li><strong>功能强大</strong>: 支持速度测试、长期监控、数据可视化等多种功能。</li><li><strong>使用简单</strong>: 界面友好，操作直观，即使是技术小白也能轻松上手。</li><li><strong>隐私保护</strong>: 所有数据都存储在你的本地设备上，无需担心隐私泄露。</li></ol><p>好了，话不多说，让我们开始 <code>MySpeed</code> 的奇妙之旅吧!</p><h2><span id="安装-myspeed">安装 MySpeed</span></h2><p><code>MySpeed</code> 使用 <code>Node.js</code> 开发，因此你需要先安装 <code>Node.js</code> 和 <code>NPM</code> 包管理器。</p><p>好消息！<code>MySpeed</code> 现在支持 <code>Docker</code> 安装,这意味着你可以在几分钟内就完成安装,而不需要担心复杂的依赖问题。让我们一起来看看如何通过 <code>Docker</code> 轻松部署 <code>MySpeed</code>。</p><h3><span id="准备工作">准备工作</span></h3><p>在开始之前,请确保你的系统已经安装了 <code>Docker</code>。如果还没有安装,可以访问 <code>Docker</code> 官网下载并安装适合你系统的版本。</p><ol><li>步骤 1: 拉取 MySpeed 镜像</li></ol><p>打开你的终端，输入以下命令来拉取 <code>MySpeed</code> 的 <code>Docker</code> 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull germannewsmaker/myspeed:latest</span><br></pre></td></tr></table></figure><p>这个命令会从 <code>Docker</code> 容器仓库下载最新版本的 <code>MySpeed</code> 最新镜像。</p><ol start="2"><li>步骤 2: 运行 MySpeed 容器</li></ol><p>现在，让我们启动 <code>MySpeed</code> 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5216:5216 -v myspeed:/myspeed/data --restart=unless-stopped --name MySpeed germannewsmaker/myspeed</span><br></pre></td></tr></table></figure><p>这个命令做了以下几件事：</p><ul><li><code>-d</code>: 在后台运行容器</li><li><code>-p 5216:5216</code>: 将容器的 5216 端口映射到主机的 5216 端口</li><li><code>-v myspeed_data:/myspeed/data</code>: 创建一个名为 <code>myspeed_data</code> 的卷,用于持久化存储数据</li><li><code>--name myspeed</code>: 给容器取名为 “myspeed”</li></ul><ol start="3"><li>步骤 3: 验证安装</li></ol><p>打开你喜欢的浏览器,访问 <code>http://localhost:5216</code>。如果你看到 <code>MySpeed</code> 的界面，恭喜你，安装成功了！</p><ol start="4"><li>额外提示：更新 MySpeed</li></ol><p>当有新版本发布时，更新 <code>MySpeed</code> 也非常简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5216:5216 --pull always -v myspeed:/myspeed/data --restart=unless-stopped --name MySpeed germannewsmaker/myspeed</span><br></pre></td></tr></table></figure><p>加入的 <code>--pull always</code> 参数的作用是告诉 <code>Docker</code> 始终尝试更新镜像。</p><h2><span id="使用-myspeed">使用 MySpeed</span></h2><h3><span id="访问-web-界面">访问 Web 界面</span></h3><p>打开你喜欢的浏览器，输入<code>http://localhost:5216</code> 。欢迎来到 <code>MySpeed</code> 的世界!</p><h3><span id="进行速度测试">进行速度测试</span></h3><ol><li>在主页上，你会看到一个大大的 “开始测试” 按钮。</li><li>点击它，MySpeed 就会开始测试你的下载和上传速度。</li><li>稍等片刻，结果就会以清晰的图表和数字展示出来。</li></ol><p><img src="https://img.hi-linux.com/staticfile/9AgHIB-2024-07-29-s9nmOK.png" alt></p><h3><span id="查看历史数据">查看历史数据</span></h3><p><code>MySpeed</code> 不仅仅是一个简单的速度测试工具，它还能帮你记录和分析长期的网络性能。</p><ol><li>点击顶部导航栏的 “设置-切换视图” 选项。</li><li>你会看到一个漂亮的图表，展示了你的网络速度变化趋势。</li><li>可以选择不同的时间范围，比如最近 7 天、30 天或自定义时间段。</li></ol><p><img src="https://img.hi-linux.com/staticfile/WFAeZS-2024-07-29-ZqTuef.png" alt></p><h3><span id="设置自动测试">设置自动测试</span></h3><p>想要 24 小时监控你的网络性能吗？<code>MySpeed</code> 可以帮你实现!</p><ol><li>进入 “设置” 页面。</li><li>找到 “设置频率” 选项。</li><li>设置测试频率，比如：每小时一次。</li><li>保存设置，然后放松一下，让 <code>MySpeed</code> 为你工作吧!</li></ol><p><img src="https://img.hi-linux.com/staticfile/sD5KHH-2024-07-29-217a7g.png" alt></p><h3><span id="数据导出">数据导出</span></h3><p>想要深入分析你的网络数据? <code>MySpeed</code> 支持数据导出功能:</p><ol><li>在 “管理存储” 页面，点击 “导出数据” 按钮。</li><li>选择导出格式 (CSV 或 JSON)。</li><li>选择时间范围。</li><li>下载文件，开始你的数据探索之旅!</li></ol><p><img src="https://img.hi-linux.com/staticfile/Jmy0Kz-2024-07-29-cD99EF.png" alt></p><h2><span id="结语">结语</span></h2><p>无论是日常使用还是长期监控，<code>MySpeed</code> 都将成为你的得力助手。记住，好的网络体验始于了解你的网络状况。所以，开始你的 <code>MySpeed</code> 之旅吧，让我们一起享受畅快的网络世界!</p><p>最后，别忘了时不时地查看 <code>MySpeed</code> 的 GitHub 页面，关注最新的更新和功能。</p><p>如果你有什么好点子，也不要犹豫，给开发者提交一个 <code>Pull Request</code>。谁知道呢，也许你的创意会成为 MySpeed 的下一个重要功能!</p><p>现在，开始你的网速探索之旅吧。愿你的网络永远畅通无阻!</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否曾经遇到过网速突然变慢，但又不知道如何查找原因的情况？或者你想长期监控你的网络性能，但找不到合适的工具？&lt;/p&gt;
&lt;p&gt;别担心，&lt;code&gt;MySpeed&lt;/code&gt; 来啦！这个强大而简单的工具可以帮助你轻松测试和监控网络速度。今天，让我们一起深入了解 &lt;code&gt;MySpeed&lt;/code&gt;，看看它如何成为你的网络管家!&lt;/p&gt;
&lt;h2 id=&quot;什么是-MySpeed？&quot;&gt;什么是 MySpeed？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MySpeed&lt;/code&gt; 是一个开源的网络速度测试和监控工具。它不仅可以测试你的当前网速，还能持续监控网络性能，并以图表形式展示结果。无论你是网络达人还是普通用户，&lt;code&gt;MySpeed&lt;/code&gt; 都能满足你的需求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MySpeed&lt;/code&gt; 支持 &lt;code&gt;Ookla&lt;/code&gt;、&lt;code&gt;LibreSpeed&lt;/code&gt; 和 &lt;code&gt;Cloudflare&lt;/code&gt; 多种速度测试服务器。你可以根据自身需求，在它们之间进行任意选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySpeed 官方地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://myspeed.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://myspeed.dev/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySpeed Github 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gnmyt/myspeed&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/gnmyt/myspeed&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="开源" scheme="https://www.hi-linux.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="MySpeed" scheme="https://www.hi-linux.com/tags/MySpeed/"/>
    
  </entry>
  
  <entry>
    <title>一款超实用的 Docker 容器网络实时监控工具，助你轻松掌握 Docker 容器网络状态</title>
    <link href="https://www.hi-linux.com/posts/36215.html"/>
    <id>https://www.hi-linux.com/posts/36215.html</id>
    <published>2024-07-29T01:00:00.000Z</published>
    <updated>2024-07-29T01:24:49.026Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="1-什么是-check-docker-connection">1. 什么是 check-docker-connection</span></h2><p><code>check-docker-connection</code> 主要用于监控 <code>Docker</code> 容器的网络连接情况。它可以显示指定容器的网络连接状态，包括 <code>TCP</code> 和 <code>UDP</code> 连接的数量。</p><p>用户可以通过容器 <code>ID</code> 或名称来指定要监控的容器，或者指定显示连接数最多的前 N 个容器。输出结果以表格形式展示，方便用户查看。</p><h3><span id="check-docker-connection-主要功能包括">check-docker-connection 主要功能包括：</span></h3><p>列出指定容器的网络连接状态，包括：</p><ul><li>已建立连接（ESTABLISHED）</li><li>TIME_WAIT 状态的连接</li><li>FIN_WAIT2 状态的连接</li><li>CLOSE_WAIT 状态的连接</li><li>监听状态（LISTEN）</li><li>SYN_SENT 状态的连接</li><li>SYN_RECV 状态的连接</li><li>UDP 连接数</li></ul><a id="more"></a><h2><span id="2-check-docker-connection-具体使用方法">2. check-docker-connection 具体使用方法</span></h2><h3><span id="环境要求">环境要求</span></h3><ul><li>需要安装 <code>Docker</code>。</li><li>宿主机上必须安装有 <code>netstat</code> 和 <code>nsenter</code> 命令，以便访问容器的网络命名空间。如果没有，请自行安装，各大发行版上通常都是 <code>net-tools</code> 和 <code>util-linux</code> 包。</li></ul><h3><span id="命令行参数">命令行参数</span></h3><ul><li><code>-c</code>: 指定一个或多个容器的 ID 或名称，多个容器用逗号分隔。</li><li><code>-n</code>: 显示连接数最多的前 N 个容器。</li></ul><p>注意：<code>-c</code> 和 <code>-n</code> 参数不能同时使用。</p><h3><span id="运行-check-docker-connection">运行 check-docker-connection</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><code>check-docker-connection</code> 需要访问 <code>Docker socket</code>，所以我们挂载了 <code>/var/run/docker.sock</code>。</li><li>我们使用 <code>--pid=host</code> 和 <code>--net=host</code> 来允许容器访问主机的进程和网络命名空间。</li><li><code>--privileged</code> 标志允许容器使用 <code>nsenter</code> 命令。</li></ol><h2><span id="3-check-docker-connection-使用实例">3. check-docker-connection 使用实例</span></h2><h3><span id="示例-1监控单个容器">示例 1：监控单个容器</span></h3><p>要监控名为 <code>traefik</code> 的容器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -c traefik</span><br></pre></td></tr></table></figure><p>这将输出该容器的所有网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/uyZkmg-2024-07-25-tLw6IA.png" alt></p><h3><span id="示例-2监控多个容器">示例 2：监控多个容器</span></h3><p>要监控多个容器，例如 <code>traefik</code> 和 <code>splayer</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -c traefik,splayer</span><br></pre></td></tr></table></figure><p>这将显示这两个容器的网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/Klvkhf-2024-07-25-N5PIBC.png" alt></p><h3><span id="示例-3显示连接数最多的前-3-个容器">示例 3：显示连接数最多的前 3 个容器</span></h3><p>要显示连接数最多的前 3 个容器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -n 3</span><br></pre></td></tr></table></figure><p>这将输出连接数最多的三个容器的网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/CHYMME-2024-07-25-4rCycb.png" alt></p><p>通过以上示例，用户可以轻松地监控 Docker 容器的网络连接状态，帮助进行网络性能分析和故障排查。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是-check-docker-connection&quot;&gt;1. 什么是 check-docker-connection&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;check-docker-connection&lt;/code&gt; 主要用于监控 &lt;code&gt;Docker&lt;/code&gt; 容器的网络连接情况。它可以显示指定容器的网络连接状态，包括 &lt;code&gt;TCP&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt; 连接的数量。&lt;/p&gt;
&lt;p&gt;用户可以通过容器 &lt;code&gt;ID&lt;/code&gt; 或名称来指定要监控的容器，或者指定显示连接数最多的前 N 个容器。输出结果以表格形式展示，方便用户查看。&lt;/p&gt;
&lt;h3 id=&quot;check-docker-connection-主要功能包括：&quot;&gt;check-docker-connection 主要功能包括：&lt;/h3&gt;
&lt;p&gt;列出指定容器的网络连接状态，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已建立连接（ESTABLISHED）&lt;/li&gt;
&lt;li&gt;TIME_WAIT 状态的连接&lt;/li&gt;
&lt;li&gt;FIN_WAIT2 状态的连接&lt;/li&gt;
&lt;li&gt;CLOSE_WAIT 状态的连接&lt;/li&gt;
&lt;li&gt;监听状态（LISTEN）&lt;/li&gt;
&lt;li&gt;SYN_SENT 状态的连接&lt;/li&gt;
&lt;li&gt;SYN_RECV 状态的连接&lt;/li&gt;
&lt;li&gt;UDP 连接数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>解锁 VSCode 远程 SSH 的隐藏功能 - 跨用户访问文件系统的完美解决方案</title>
    <link href="https://www.hi-linux.com/posts/31204.html"/>
    <id>https://www.hi-linux.com/posts/31204.html</id>
    <published>2024-07-24T01:00:00.000Z</published>
    <updated>2024-07-24T01:49:54.723Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在使用远程服务器（例如: 虚拟机）时，有时您需要切换到不同的用户，例如：短时间内获得更高的权限。</p><p>通常可以使用以下命令之一来完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su &lt;different-user&gt;</span><br><span class="line">$ sudo -i -u &lt;different-user&gt;</span><br></pre></td></tr></table></figure><p>但如果你想使用 <code>VSCode</code> 时更轻松地探索文件系统和编辑代码，这就不那么简单了。比如：登录用户为 <code>mike</code>，而您想在 VSCode 资源管理器中访问 <code>root</code> 用户的主目录。</p><a id="more"></a><p>首先，您需要在 <code>VSCode</code> 配置中启用一些标志，你可以在用户界面 ( 用 <code>ctrl+,</code> 打开设置，搜索 <code>Remote.SSH</code> ) 中启用：</p><p><img src="https://img.hi-linux.com/staticfile/1*zUTsTgGusNzfhdYGQnyA7g-20240719134757890-2024-07-19-zJ7n8x.png" alt></p><p>或 <code>settings.json</code> 中编辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;remote.SSH.useLocalServer&quot;: true,</span><br><span class="line">&quot;remote.SSH.enableRemoteCommand&quot;: true,</span><br></pre></td></tr></table></figure><p>然后，打开 <code>SSH</code> 配置文件（默认为 <code>/home/$USER/.ssh/config</code>），在主机中添加 <code>RemoteCommand</code> 和 <code>RequestTTY</code> 选项。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host example.com</span><br><span class="line">  HostName example.com</span><br><span class="line">  IdentitiesOnly&#x3D;yes</span><br><span class="line">  User my_user</span><br><span class="line">  RequestTTY yes</span><br><span class="line">  RemoteCommand sudo -i -u other_user</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>RequestTTY</code> 选项的作用是指定是否为会话请求伪 TTY。参数可以是：no（从不请求 TTY）、yes（当标准输入为 TTY 时始终请求 TTY）、force（始终请求 TTY）或 auto（打开登录会话时请求 TTY）。该选项与 -t 和 -T 标志相同。如果你不加上这个选项，通过 SSH 命令行登陆时将无法正常登陆。</p></blockquote><p>如果远程服务器可以访问互联网，那就已经配置完成了。</p><p>否则，您需要采取以下两个步骤中的一个。</p><ol><li>远程服务器可通过代理访问互联网</li></ol><p>在这种情况下，请在需要切换用户的主目录下创建一个 <code>.wgetrc</code> 文件。例如: <code>/home/other_user/.wgetrc</code>，内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use_proxy&#x3D;on</span><br><span class="line">http_proxy&#x3D;http:&#x2F;&#x2F;proxy.host:&lt;port&gt;</span><br><span class="line">https_proxy&#x3D;http:&#x2F;&#x2F;proxy.host:&lt;port&gt;</span><br></pre></td></tr></table></figure><p>这是必要的，因为 <code>VSCode</code> 会在会话开始时使用 <code>wget</code> 下载必要的二进制文件。</p><ol start="2"><li>远程服务器根本无法访问互联网</li></ol><p>在这种情况下，您需要在本地下载 <code>VSCode</code> 服务器文件，然后将其复制（例如: 使用 <code>scp</code>）到服务器，具体步骤如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 本地下载</span><br><span class="line">$ commit_id&#x3D;f1e16e1e6214d7c44d078b1f0607b2388f29d729</span><br><span class="line">$ curl -sSL &quot;https:&#x2F;&#x2F;update.code.visualstudio.com&#x2F;commit:$&#123;commit_id&#125;&#x2F;server-linux-x64&#x2F;stable&quot; -o vscode-server-linux-x64.tar.gz</span><br><span class="line">$ scp  vscode-server-linux-x64.tar.gz user@remotehost:&#x2F;home&#x2F;user&#x2F;</span><br><span class="line"></span><br><span class="line"># 远程服务器操作</span><br><span class="line">$ commit_id&#x3D;f1e16e1e6214d7c44d078b1f0607b2388f29d729</span><br><span class="line">$ mkdir -p ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125;</span><br><span class="line">$ tar zxvf ~&#x2F;vscode-server-linux-x64.tar.gz -C ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125; --strip 1</span><br><span class="line">$ touch ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125;&#x2F;0</span><br></pre></td></tr></table></figure><p>更详细步骤可参考：<a href="https://stackoverflow.com/a/57601121/8175198" target="_blank" rel="noopener">https://stackoverflow.com/a/57601121/8175198</a></p><p>或者，先用 <code>VSCode</code> 远程 <code>SSH</code> 连接正常用户，让它传输文件，然后将文件复制到另一个用户的主目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r &#x2F;home&#x2F;mike&#x2F;.vscode-server&#x2F; &#x2F;root&#x2F;</span><br></pre></td></tr></table></figure><p>您还可以将默认设为在客户端上下载 VSCode 服务器文件，并使用 <code>scp</code> 将其传输到主机，而不是先尝试 <code>wget</code> 将其下载到主机上。</p><p><img src="https://img.hi-linux.com/staticfile/1*a-Yc1-R4b707xJSkq8qnwQ-2024-07-19-ngo7vk.png" alt></p><p>您也可以更改这些文件的安装位置</p><p><img src="https://img.hi-linux.com/staticfile/1*61VUKyX8fM13gW4Vb8e1MA-2024-07-19-q2Ii72.png" alt></p><p>参考文档：</p><ol><li><a href="https://medium.com/@krisztian.sala/vs-code-remote-ssh-as-another-user-57d449e20fb1" target="_blank" rel="noopener">https://medium.com/@krisztian.sala/vs-code-remote-ssh-as-another-user-57d449e20fb1</a></li><li><a href="https://stackoverflow.com/a/57601121/8175198" target="_blank" rel="noopener">https://stackoverflow.com/a/57601121/8175198</a></li><li><a href="https://github.com/b01/dl-vscode-server" target="_blank" rel="noopener">https://github.com/b01/dl-vscode-server</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用远程服务器（例如: 虚拟机）时，有时您需要切换到不同的用户，例如：短时间内获得更高的权限。&lt;/p&gt;
&lt;p&gt;通常可以使用以下命令之一来完成：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ su &amp;lt;different-user&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo -i -u &amp;lt;different-user&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但如果你想使用 &lt;code&gt;VSCode&lt;/code&gt; 时更轻松地探索文件系统和编辑代码，这就不那么简单了。比如：登录用户为 &lt;code&gt;mike&lt;/code&gt;，而您想在 VSCode 资源管理器中访问 &lt;code&gt;root&lt;/code&gt; 用户的主目录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="VSCode" scheme="https://www.hi-linux.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>无需 Dockerfile，打造你的专属即时容器镜像--自建 Nixery 私有服务器</title>
    <link href="https://www.hi-linux.com/posts/26894.html"/>
    <id>https://www.hi-linux.com/posts/26894.html</id>
    <published>2024-07-22T01:00:00.000Z</published>
    <updated>2024-07-22T02:17:10.405Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>自建一个 <code>Nixery</code> 实例可以让你在本地或私有服务器上运行 <code>Nixery</code> 服务，从而避免公共服务的不稳定性。以下是一个基本的步骤指南，帮助你在本地或服务器上部署 <code>Nixery</code>。</p><h2><span id="1-准备环境">1. 准备环境</span></h2><p>确保你的系统已经安装了以下软件：</p><ul><li>Nix</li><li>Docker</li><li>Git</li></ul><p><code>Docker</code> 和 <code>Git</code> 属于基础软件，就不再展开讲解安装部分了。<code>Nix</code> 安装你可以参考 <a href="https://nixos.org/download/#nix-install-linux" target="_blank" rel="noopener">Nix 官方文档</a> 进行安装。</p><a id="more"></a><h2><span id="2-克隆-nixery-仓库">2. 克隆 Nixery 仓库</span></h2><p>首先，你需要克隆 <code>Nixery</code> 的代码仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://code.tvl.fyi/depot.git:/tools/nixery.git nixery</span><br><span class="line">$ <span class="built_in">cd</span> nixery</span><br></pre></td></tr></table></figure><h2><span id="3-构建和运行-nixery">3. 构建和运行 Nixery</span></h2><p>使用 <code>Nix</code> 构建 <code>Nixery</code> 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nix-build -A nixery-image</span><br></pre></td></tr></table></figure><p>构建完成后，你会在 <code>result</code> 目录中得到一个 <code>Docker</code> 镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载镜像</span></span><br><span class="line">$ docker load &lt; result</span><br><span class="line"><span class="comment"># 按你的实际 tag 修改下面的值</span></span><br><span class="line">$ docker tag nixery:bbgi5sfqwpp6fsd36ccqw9yi0vykdkz3 nixery:latest</span><br></pre></td></tr></table></figure><h2><span id="4-配置-nixery">4. 配置 Nixery</span></h2><p><code>Nixery</code> 支持多种配置选项，可以通过环境变量进行设置。以下是一些常见的配置选项：</p><ul><li>PORT：Nixery 应监听的 HTTP 端口</li><li>NIXERY_CHANNEL：用于构建 Nixery 的 Nix/NixOS 通道名称。</li><li>NIXERY_PKGS_REPO：包含软件包集的 git 仓库的 URL（使用本地配置的 SSH/git 凭据）</li><li>NIXERY_PKGS_PATH：包含用于构建的 Nix 软件包集的本地文件系统路径</li><li>NIXERY_STORAGE_BACKEND：要使用的后端存储类型，目前支持的值为 gcs（谷歌云存储）和 filesystem。</li><li>NIX_TIMEOUT：允许任何 Nix 生成器运行的秒数（默认值为 60）</li><li>NIX_POPULARITY_URL：指向包含软件包集受欢迎程度数据的文件的 URL（参见 popcount/）。</li></ul><h4><span id="存储">存储</span></h4><p><code>Nixery</code> 支持多种不同的存储后端，构建缓存和图像层都保存在这些后端中，并从这些后端提供服务。</p><p>目前可用的存储后端有谷歌云端存储和本地文件系统。</p><p>在谷歌云存储中，通过将客户端重定向到存储桶来提供镜像。存储在文件系统中的镜像图层则直接从本地磁盘提供。</p><p>要配置存储后端，必须设置这些额外的配置环境变量：</p><ul><li>GCS_BUCKET：要使用的谷歌云存储桶名称（gcs 必填）</li><li>GOOGLE_APPLICATION_CREDENTIALS：指向 GCP 服务帐户 JSON 密钥的路径（GCS 可选）</li><li>STORAGE_PATH：用于存储和提供数据的文件夹的路径（本地存储路径）</li></ul><p>如果 <code>GOOGLE_APPLICATION_CREDENTIALS</code> 环境变量设置为服务账户密钥，<code>Nixery</code> 将使用该密钥为存储桶中的图层创建签名 URL。这样就可以从存储桶中提供图层，而无需将其公开。</p><p>如果未设置 <code>GOOGLE_APPLICATION_CREDENTIALS</code> 环境变量，则会重定向到 <code>storage.googleapis.com</code>，这意味着底层的存储桶对象需要可公开访问。</p><h2><span id="5-运行-nixery-容器">5. 运行 Nixery 容器</span></h2><ul><li>使用本地文件系统作为存储后端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nixery -d -p 8080:8080 \</span><br><span class="line">  -e PORT&#x3D;8080 \</span><br><span class="line">  -e NIXERY_STORAGE_BACKEND&#x3D;filesystem \</span><br><span class="line">  -e STORAGE_PATH&#x3D;&#x2F;opt&#x2F;data&#x2F;store \</span><br><span class="line">  -e NIXERY_PKGS_REPO&#x3D;https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs \</span><br><span class="line">  -e NIXERY_CHANNEL&#x3D;nixos-unstable \</span><br><span class="line">  -v .&#x2F;data:&#x2F;opt&#x2F;data&#x2F;  \</span><br><span class="line">  nixery:latest</span><br></pre></td></tr></table></figure><ul><li>使用 GCS 作为存储后端</li></ul><p>如果你想使用 <code>Google Cloud Storage</code> (GCS) 作为存储后端，可以按以下步骤操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nixery -d -p 8080:8080 \</span><br><span class="line">  -e PORT&#x3D;8080 \</span><br><span class="line">  -e NIXERY_STORAGE_BACKEND&#x3D;gcs \</span><br><span class="line">  -e GCS_BUCKET&#x3D;your-gcs-bucket-name \</span><br><span class="line">  -e NIXERY_PKGS_REPO&#x3D;https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs \</span><br><span class="line">  -e NIXERY_CHANNEL&#x3D;nixos-unstable \</span><br><span class="line">  -v .&#x2F;data:&#x2F;opt&#x2F;data&#x2F;  \  </span><br><span class="line">  nixery</span><br></pre></td></tr></table></figure><ul><li>访问自建的 Nixery</li></ul><p>现在，你应该可以通过 <code>http://localhost:8080</code> 访问你的 Nixery 实例。</p><h2><span id="6-使用自建的-nixery-拉取镜像">6. 使用自建的 Nixery 拉取镜像</span></h2><p>启动 <code>Nixery</code> 容器后，你可以像使用公共 <code>Nixery</code> 服务一样使用你自建的 <code>Nixery</code> 实例。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it localhost:8080/shell/btop</span><br><span class="line">$ docker run --rm -it IP:8080/shell/git/btop/curl</span><br></pre></td></tr></table></figure><h2><span id="7-进一步配置">7. 进一步配置</span></h2><p>你可以根据需要进一步配置你的 <code>Nixery</code> 实例，例如：</p><ul><li>使用 Nginx 或其他反向代理服务器来处理请求</li></ul><p>以下是一个使用 <code>Nginx</code> 作为反向代理的示例配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name your.domain.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:8080;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 HTTP 访问 Nixery 实例</li></ul><p>自建的 <code>Nixery</code> 实例默认没有支持 <code>HTTPS</code>。你如果不想配置 <code>HTTPS</code>，请确保 <code>Docker Daemon</code> 允许使用 <code>HTTP</code> 连接。你可以通过以下步骤进行配置：</p><ol><li>编辑 <code>Docker Daemon</code> 的配置文件（通常位于 <code>/etc/docker/daemon.json</code>）并添加不安全的注册表地址</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [<span class="string">"10.1.2.3:8080"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：10.1.2.3:8080 是你的 Nixery 实例的 IP 地址和端口号，请按实际情况修改。</p></blockquote><ol start="2"><li>重启 Docker 服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2><span id="8-监控和日志">8. 监控和日志</span></h2><p>为了保证服务的稳定运行，你可能需要设置监控和日志系统。例如，可以使用 <code>Prometheus</code> 和 <code>Grafana</code> 来监控 <code>Nixery</code> 的性能。</p><p>通过这些步骤，你能够成功自建一个 Nixery 实例并根据需要进行配置和扩展。如果你在过程中遇到任何问题，可以参考 Nixery 的文档或社区支持。</p><h2><span id="9-彩蛋">9. 彩蛋</span></h2><p>自建 <code>Nixery</code> 私有服务器最大的技术难点是需要 <code>Nix</code> 环境。你如果不想扯腾 <code>Nix</code> 环境，可以直接使用我构建好的 <code>Nixery</code> 的镜像。</p><p>你只需要在公众号后台直接回复「<code>Nixery</code>」，即可免费获取 <code>Nixery</code> 镜像下载地址。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自建一个 &lt;code&gt;Nixery&lt;/code&gt; 实例可以让你在本地或私有服务器上运行 &lt;code&gt;Nixery&lt;/code&gt; 服务，从而避免公共服务的不稳定性。以下是一个基本的步骤指南，帮助你在本地或服务器上部署 &lt;code&gt;Nixery&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1-准备环境&quot;&gt;1. 准备环境&lt;/h2&gt;
&lt;p&gt;确保你的系统已经安装了以下软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nix&lt;/li&gt;
&lt;li&gt;Docker&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 和 &lt;code&gt;Git&lt;/code&gt; 属于基础软件，就不再展开讲解安装部分了。&lt;code&gt;Nix&lt;/code&gt; 安装你可以参考 &lt;a href=&quot;https://nixos.org/download/#nix-install-linux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nix 官方文档&lt;/a&gt; 进行安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nixery" scheme="https://www.hi-linux.com/tags/Nixery/"/>
    
      <category term="Nix" scheme="https://www.hi-linux.com/tags/Nix/"/>
    
  </entry>
  
</feed>
