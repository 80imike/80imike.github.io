<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇妙的 Linux 世界</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2021-06-25T01:51:52.060Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CentOS 之父创造的 Rocky Linux 8.4 正式版发布了！(内附镜像下载地址）</title>
    <link href="https://www.hi-linux.com/posts/24084.html"/>
    <id>https://www.hi-linux.com/posts/24084.html</id>
    <published>2021-06-25T01:00:00.000Z</published>
    <updated>2021-06-25T01:51:52.060Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>跟随上个月的 Red Hat Enterprise Linux 8.4 版本的发布，再到后来的基于 RHEL 8.4 的 Alma Linux、Oracle Linux 和 CentOS 8的更新，RockyLinux 今天的 v8.4 版本已经全面上线。<strong>Rocky Linux 是CentOS创始人Greg Kurtzer等人瞄准的免费 RHEL替代品。</strong></p></blockquote><p>Rocky Linux 8.4 现已正式发布。Rocky Linux 是一个社区版的企业操作系统，旨在与 Red Hat Enterprise Linux 8.4 实现 100% 的 bug-for-bug 兼容。官方表示，由于这是 Rocky Linux 的第一个版本，所以发布说明只反映了各版本之间上游功能的变化。且不支持从 Rocky Linux 8.3 RC1、Rocky Linux 8.4 RC1 或任何其他候选版本迁移到 Rocky Linux 8.4。</p><p>Rocky Linux 团队提供了 migrate2rocky 工具用于帮助使用者从其他企业 Linux 系统迁移到 Rocky Linux 8.4。此工具已经过测试并且可以正常运行，但使用时需自担风险。</p><h2><span id="新模块">新模块</span></h2><p>Rocky Linux 8.4 中全新的 module streams 包括以下内容：</p><ul><li>Python 3.9</li><li>SWIG 4.0</li><li>Subversion 1.14</li><li>Redis 6</li><li>PostgreSQL 13</li><li>MariaDB 10.5</li></ul><a id="more"></a><h2><span id="主要变化">主要变化</span></h2><p>Rocky Linux 8.4 的主要变化体现在安全、网络、内核和高可用以及集群等方面。</p><h3><span id="安全">安全</span></h3><ul><li>Libreswan 提供的 IPsec VPN 现在支持 IKEv2 的 TCP 封装和安全标签</li><li>scap-security-guide 已更新到到 0.1.54 ，OpenSCAP 已更新到 1.3.4。这更新提供了实质性的改进，包括优化内存管理</li><li>fapolicyd 框架现在提供完整性检查，并且 RPM 插件注册由 YUM 包管理器或 RPM 包管理器更新</li></ul><h3><span id="网络">网络</span></h3><ul><li>完全支持 Nmstate（主机的网络 API），这些 nmstate 包提供了一个库和 nmstatectl 命令行，以声明方式管理主机网络设置</li><li>支持 MPLS（多协议标签交换）</li><li>iproute2 引入了三个新的流量控制 (tc) 操作：<code>mac_push</code>, <code>push_eth</code>, 和<code>pop_eth</code>，并添加 MPLS 标签</li></ul><h3><span id="内核">内核</span></h3><ul><li>主动压缩功能：在发出分配请求之前定期启动内存压缩工作。因此，降低了特定内存分配请求的延迟。</li><li>提供了用于控制组技术的平板内存控制器。Slab 内存控制器优化了内存的利用率，并且能够将内存记帐从页面级别转移到对象级别。因此，可以观察到总内核内存占用量显著下降，并改善了内存碎片情况。</li><li>时间命名空间功能：此功能适用于更改 Linux 容器内的日期和时间。现在也可以在检查点恢复后进行容器内时钟的调整。</li><li>支持第 8、 9 代英特尔酷睿处理器中设置的错误检测和纠正 (EDAC) 内核模块。</li></ul><h3><span id="高可用和集群">高可用和集群</span></h3><ul><li>维护状态数据的持久性：Pacemaker 资源代理可以异步检测故障并立即将故障注入 Pacemaker，而无需等待下一个监控间隔。持久性资源代理还可以加快具有高状态开销的服务的集群响应时间，因为维护状态数据可以通过不为每个操作单独调用状态来减少集群操作（例如启动、停止和监控）的状态开销。</li></ul><h3><span id="编译器和开发工具">编译器和开发工具</span></h3><p>以下编译器工具集已更新：</p><ul><li>GCC Toolset 10</li><li>LLVM Toolset 11.0.0</li><li>Rust Toolset 1.49.0</li><li>Go Toolset 1.15.7</li></ul><h3><span id="身份管理">身份管理</span></h3><ul><li>Rocky Linux 8.4 提供了 Ansible 模块，用于自动化管理身份管理（IdM）中基于角色的访问控制（RBAC），一个 Ansible role 用于备份和恢复 IdM 服务器，以及一个 Ansible 模块用于位置管理。</li></ul><p>更多详情可查看：<a href="https://docs.rockylinux.org/zh_CN/release_notes/8.4/" target="_blank" rel="noopener">https://docs.rockylinux.org/zh_CN/release_notes/8.4/</a></p><p><strong>Rocky Linux 8.4 正式版官方下载地址：</strong> <a href="https://rockylinux.org/download/" target="_blank" rel="noopener">https://rockylinux.org/download/</a></p><blockquote><p>本文转载自：「 开源中国 」，原文：<a href="https://tinyurl.com/3b2p5mv3" target="_blank" rel="noopener">https://tinyurl.com/3b2p5mv3</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;跟随上个月的 Red Hat Enterprise Linux 8.4 版本的发布，再到后来的基于 RHEL 8.4 的 Alma Linux、Oracle Linux 和 CentOS 8的更新，RockyLinux 今天的 v8.4 版本已经全面上线。&lt;strong&gt;Rocky Linux 是CentOS创始人Greg Kurtzer等人瞄准的免费 RHEL替代品。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Rocky Linux 8.4 现已正式发布。Rocky Linux 是一个社区版的企业操作系统，旨在与 Red Hat Enterprise Linux 8.4 实现 100% 的 bug-for-bug 兼容。官方表示，由于这是 Rocky Linux 的第一个版本，所以发布说明只反映了各版本之间上游功能的变化。且不支持从 Rocky Linux 8.3 RC1、Rocky Linux 8.4 RC1 或任何其他候选版本迁移到 Rocky Linux 8.4。&lt;/p&gt;
&lt;p&gt;Rocky Linux 团队提供了 migrate2rocky 工具用于帮助使用者从其他企业 Linux 系统迁移到 Rocky Linux 8.4。此工具已经过测试并且可以正常运行，但使用时需自担风险。&lt;/p&gt;
&lt;h2 id=&quot;新模块&quot;&gt;新模块&lt;/h2&gt;
&lt;p&gt;Rocky Linux 8.4 中全新的 module streams 包括以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 3.9&lt;/li&gt;
&lt;li&gt;SWIG 4.0&lt;/li&gt;
&lt;li&gt;Subversion 1.14&lt;/li&gt;
&lt;li&gt;Redis 6&lt;/li&gt;
&lt;li&gt;PostgreSQL 13&lt;/li&gt;
&lt;li&gt;MariaDB 10.5&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="CentOS" scheme="https://www.hi-linux.com/categories/CentOS/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="CentOS" scheme="https://www.hi-linux.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂 eBPF 对 Kubernetes 可观测的重要性</title>
    <link href="https://www.hi-linux.com/posts/14561.html"/>
    <id>https://www.hi-linux.com/posts/14561.html</id>
    <published>2021-06-23T01:00:00.000Z</published>
    <updated>2021-06-23T04:32:40.108Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>作者：Lavanya Chockalingam，New Relic 高级产品营销经理。最初发表在 <strong>New Relic 的博客[1]</strong>。</p></blockquote><p>在 Linux 内核中工作是实现安全性、网络和可观察性特性的理想选择。然而，这并不是没有挑战。无论是修改内核源代码，还是添加模块，开发人员传统上发现他们要与难以调试的复杂基础设施和抽象层作斗争。<strong>Extended BPF</strong>[2]（eBPF）解决了这两个问题。</p><p>Extended Berkeley Packet Filter（eBPF）是一种内核技术（从 Linux 4.x 开始），它允许程序在无需更改内核源代码，或添加额外模块的情况下运行。你可以将其视为 Linux 内核中的轻量级沙箱虚拟机（VM），程序员可以在其中运行 BPF 字节码，从而利用特定的内核资源。</p><p>使用 eBPF 消除了更改内核源代码的需要，并简化了软件利用现有层的能力。因此，它是一项强大的技术，有可能从根本上改变网络、可观察性和安全性等服务的交付方式。</p><p>下面详细介绍一下它是什么，它是如何工作的，以及何时考虑实施它。</p><a id="more"></a><h2><span id="ebpf-是如何工作">eBPF 是如何工作</span></h2><p>eBPF 程序是事件驱动的，并附加到代码路径上。代码路径包含特定的触发器（称为钩子），这些触发器在传递附加的 eBPF 程序时执行它们。钩子的一些例子包括网络事件、系统调用、函数项和内核追踪点。</p><p>当触发时，代码首先被编译为 BPF 字节码。然后，字节码在运行之前会被验证，以确保它不会创建循环。这个步骤可以防止程序无意或故意损害 Linux 内核。</p><p>在钩子上触发程序之后，它就会进行助手调用。这些助手调用是为 eBPF 配备许多用于访问内存的特性的函数。助手调用需要由内核预先定义，但是存在的函数列表在<strong>不断增长</strong>[3]。</p><p>eBPF 最初被用作过滤网络数据包时，提高可观察性和安全性的一种方法。然而，随着时间的推移，它成为了一种使用户提供的代码实现更安全、更方便和性能更好的方法。</p><h2><span id="ebpf-的优点">eBPF 的优点</span></h2><p>eBPF 通常用于<strong>追踪</strong>[4]用户空间进程，它的优点在这里很明显。这是一个安全和有用的方法来确保：</p><ul><li>速度和性能。eBPF 可以将包处理从内核空间转移到用户空间。同样，eBPF 是即时（JIT）编译器。编译字节码后，将调用 eBPF，而不是为每个方法调用字节码的新解释。</li><li>低侵入性。当作为调试器使用时，eBPF 不需要停止程序来观察其状态。</li><li>安全。程序实际上是沙箱化的，这意味着内核源代码仍然受到保护并且没有改变。验证步骤确保资源不会被运行无限循环的程序堵塞。</li><li>方便。创建钩子内核函数的代码比构建和维护内核模块的工作要少。</li><li>统一的追踪。eBPF 为你提供了一个用于追踪流程的单一、强大且可访问的框架。这增加了可见性和安全性。</li><li>可编程性。使用 eBPF 有助于增加环境的特性丰富度，而无需添加额外的层。同样，由于代码直接在内核中运行，因此可以在 eBPF 事件之间存储数据，而不像其他追踪程序那样转储数据。</li><li>表达能力。eBPF 具有表达性，能够执行通常只能在高级语言中找到的功能。</li></ul><h2><span id="ebpf-的最佳实践">eBPF 的最佳实践</span></h2><p>由于 eBPF 是一项如此新的技术，许多东西仍未被探索。随着技术的发展，围绕 eBPF 的最佳实践仍在不断发展。虽然没有明确的最佳实践集存在，但你可以做一些事情来确保有效、高效的程序。</p><p>如果你正在为你的生态系统使用 eBPF，我们建议你：</p><ul><li>使用<strong>LLVM Clang</strong>[5]将 C 编译成字节码。当 eBPF 首次出现时，需要手工编写和组装程序。然后，开发人员使用内核的汇编程序生成字节码。幸运的是，现在不再需要这样做了。Clang 提供了 C 语言的前端基础设施和工具。</li><li>编写 BPF 程序时请使用 BCC 工具包。<strong>BPF Compiler Collection</strong>[6]（BCC）是一个工具包，可以帮助你创建高效的内核追踪和操作程序。它特别适合于性能分析和网络流量控制相关的任务。</li></ul><h2><span id="ebpf-的缺点">eBPF 的缺点</span></h2><p>尽管 eBPF 功能强大，但它并不是适合每个项目或生态系统的灵丹妙药。eBPF 确实有一些明显的缺点，这可能会使它在某些实例中工作起来令人沮丧。一些开发人员可能会发现 eBPF 不适合使用，原因如下：</p><ul><li>它仅限于 Linux 和一个最新的内核。eBPF 是在 Linux 内核中开发的，并且是完全面向 Linux 内核的。这使得它比其他追踪器更难携带。此外，你需要一个相当新的内核。如果你运行的是比 v4.13 更老的版本，你将无法使用它。</li><li>沙箱程序是有限的。eBPF 通过限制程序可以访问的资源来提高安全性。然而，通过限制程序可以访问的操作系统部分，功能也可能受到限制。</li></ul><h2><span id="ebpf-的常用情况">eBPF 的常用情况</span></h2><p>eBPF 在<strong>云原生应用</strong>[7]中正迅速获得关注。因此，eBPF 最常用于两种情况：</p><ul><li>需要使用内核追踪实现可观察性。在这种情况下，eBPF 更快、更准确。这里不涉及<strong>上下文切换</strong>[8]，而且 eBPF 程序是基于事件的，因此没有特定的触发器就不会运行任何程序——你不会错过任何事件。</li><li>传统的安全监控不起作用。eBPF 在分布式和基于容器的环境中得到了广泛的应用，包括<strong>Kubernetes</strong>[9]。在这些环境中，eBPF 可以缩小可见性差距，因为它可以提供对 HTTP 通信的可见性。</li></ul><p>你可能还会发现 eBPF 被部署用于其他安全措施，包括：</p><ul><li>防火墙</li><li>设备驱动程序</li><li>网络性能监控</li></ul><h2><span id="new-relic-和-ebpf">New Relic 和 eBPF</span></h2><p><strong>Pixie</strong>[10]（早前被 New Relic 收购了）是一个开源的 kubernetes-native-in-cluster 可观察平台，它提供了 Kubernetes 工作负载的即时可见性，无需手动检测。eBPF 提供了 Pixie 平台背后的大部分魔力。如前所述，eBPF 允许在触发事件时运行受限制的代码。这个事件可以是内核空间（kprobes）或用户空间（uprobes）中的函数调用。Pixie 同时使用 uprobes 和 kprobes 来支持跨服务和应用程序的可观察性。</p><p>Pixie 利用 eBPF 自动获取遥测数据，其边缘机智能将这些数据与 Kubernetes 元数据连接起来，在保持数据局部性的同时提供可见性。这种可见性补充了 New Relic 强大的 Kubernetes 可观测性解决方案。从 5 月底开始，你将能够将 Pixie 生成的遥测数据发送到 New Relic One，获得可扩展的留存率、强大的可视化、高级关联和智能警报功能。</p><h2><span id="ebpf-是有效的可观察性">eBPF 是有效的可观察性</span></h2><p>eBPF 是一种新技术，它改进了 Linux 内核中的可观察性、联网和安全性。它消除了更改内核源代码或添加模块的需要，因此你可以创建更丰富的基础设施来支持你的系统，而不会使其过于复杂。</p><h2><span id="总结">总结</span></h2><p>我们了解了 eBPF 是什么，它是如何工作的，以及为什么它在分布式环境中如此有用。通过从内核层进行监控，许多与云中的可观测性相关的挑战都得到了解决。你可以在数据中享受更深入的可见性、更多的上下文和更准确的信息。</p><h3><span id="参考资料">参考资料</span></h3><ol><li>New Relic 的博客: <a href="https://newrelic.com/blog/best-practices/what-is-ebpf" target="_blank" rel="noopener">https://newrelic.com/blog/best-practices/what-is-ebpf</a></li><li>Extended BPF: <a href="https://www.kernel.org/doc/html/latest/bpf/index.html" target="_blank" rel="noopener">https://www.kernel.org/doc/html/latest/bpf/index.html</a></li><li>不断增长: <a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man7/bpf-helpers.7.html</a></li><li>追踪: <a href="https://blog.pixielabs.ai/ebpf-function-tracing/post/" target="_blank" rel="noopener">https://blog.pixielabs.ai/ebpf-function-tracing/post/</a></li><li>LLVM Clang: <a href="https://clang.llvm.org/" target="_blank" rel="noopener">https://clang.llvm.org/</a></li><li>BPF Compiler Collection: <a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">https://github.com/iovisor/bcc</a></li><li>云原生应用: <a href="https://newrelic.com/solutions/cloud-native" target="_blank" rel="noopener">https://newrelic.com/solutions/cloud-native</a></li><li>上下文切换: <a href="https://www.quora.com/What-is-context-switching-in-Linux" target="_blank" rel="noopener">https://www.quora.com/What-is-context-switching-in-Linux</a></li><li>Kubernetes: <a href="https://kubernetes.io/blog/2017/12/using-ebpf-in-kubernetes/" target="_blank" rel="noopener">https://kubernetes.io/blog/2017/12/using-ebpf-in-kubernetes/</a></li><li>Pixie: <a href="http://pixielabs.ai/" target="_blank" rel="noopener">http://pixielabs.ai/</a></li></ol><blockquote><p>本文转载自：「  CNCF 」，原文：<a href="https://tinyurl.com/ymz2kh4j" target="_blank" rel="noopener">https://tinyurl.com/ymz2kh4j</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Lavanya Chockalingam，New Relic 高级产品营销经理。最初发表在 &lt;strong&gt;New Relic 的博客[1]&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Linux 内核中工作是实现安全性、网络和可观察性特性的理想选择。然而，这并不是没有挑战。无论是修改内核源代码，还是添加模块，开发人员传统上发现他们要与难以调试的复杂基础设施和抽象层作斗争。&lt;strong&gt;Extended BPF&lt;/strong&gt;[2]（eBPF）解决了这两个问题。&lt;/p&gt;
&lt;p&gt;Extended Berkeley Packet Filter（eBPF）是一种内核技术（从 Linux 4.x 开始），它允许程序在无需更改内核源代码，或添加额外模块的情况下运行。你可以将其视为 Linux 内核中的轻量级沙箱虚拟机（VM），程序员可以在其中运行 BPF 字节码，从而利用特定的内核资源。&lt;/p&gt;
&lt;p&gt;使用 eBPF 消除了更改内核源代码的需要，并简化了软件利用现有层的能力。因此，它是一项强大的技术，有可能从根本上改变网络、可观察性和安全性等服务的交付方式。&lt;/p&gt;
&lt;p&gt;下面详细介绍一下它是什么，它是如何工作的，以及何时考虑实施它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="eBPF" scheme="https://www.hi-linux.com/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>再见 Teamviewer，是时候拥抱下一代远程控制工具 RustDesk 了！</title>
    <link href="https://www.hi-linux.com/posts/23378.html"/>
    <id>https://www.hi-linux.com/posts/23378.html</id>
    <published>2021-06-22T01:00:00.000Z</published>
    <updated>2021-06-22T01:15:28.032Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>对很多 Mac 用户来说，想用远程控制请教下大佬，太难了。</p><p>在 Windows 上一个 QQ 就能搞定的事，而 Mac 用户几乎只能依赖 Teamviewer。</p><p>Teamviewer 还遭到不少吐槽：占用高、打开慢，有时还因为被识别为商用而收费……</p><p>现在，你不必再和它较劲了。</p><a id="more"></a><p>这款名叫 <strong>RustDesk</strong> 的远程桌面软件火了！已经在 Github 上获得了 <strong>6.1k</strong> 颗星。</p><p><img src="https://img.hi-linux.com/staticfile/image-20210618093429673-2021-06-18-XpQTXT.png" alt></p><p>这个名字已经 “暴露” 了它，没错，这款软件的开发语言正是 <strong>Rust</strong>。</p><p>RustDesk 支持多个平台，并且 “安装包” 只有 8~9MB，相当<strong>轻量</strong>了。</p><p><img src="https://img.hi-linux.com/staticfile/image-20210618093608925-2021-06-18-t14cEh.png" alt></p><p>而且，这款软件属于半便携式，无需安装和配置，<strong>开箱即用</strong>。用户界面也是非常直观、简单：</p><p><img src="https://img.hi-linux.com/staticfile/113112362-ae4deb80-923b-11eb-957d-ff88daad4f06-2021-06-18-5qp5lD.png" alt></p><p>RustDesk 采用的是<strong>加密直连</strong>，先尝试打洞直连，帮助两者建立连接，如果失败再通过服务器转发。</p><p>它支持<strong>跨平台传输</strong>文件。比如，Mac 和 Windows 电脑之间进行文件传输时，界面长这样：</p><p><img src="https://img.hi-linux.com/staticfile/113112857-3fbd5d80-923c-11eb-9836-768325faf906-2021-06-18-GlY6Fx.png" alt></p><p>RustDesk 开发者还是一位<strong>中国程序员</strong>，当然软件也支持中文版。</p><p>苦远程久矣的我，上手试了一下～</p><p>选择 Mac 和 Android 手机客户端，下载安装一气呵成。</p><p>打开后，界面的确非常清爽，大概是这样：</p><p><img src="https://img.hi-linux.com/staticfile/image-20210618094901549-2021-06-18-UW6X7G.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/113112619-f705a480-923b-11eb-911d-97e984ef52b6-20210618101248945-2021-06-18-6mxGk1.png" alt></p><blockquote><p>注意：公共服务器目前是<strong>不支持</strong>修改 ID 的。</p></blockquote><p>从去年开始，作者已经开始不断更新软件版本。有不少网友表示：软件体积小、界面简洁，比 Teamviewer 香～</p><p>不过也有人基于安全性提出质疑。</p><p>作者在 V2EX 上表示，已经在 GitHub 上开源了 90% 的代码（算上总代码量），但是保留了服务器代码以及移动端。</p><p>此外，由于存在内网穿透失败而连接很慢的情况，RustDesk 还支持<strong>自建中继服务器</strong>，并且提供了教程。</p><p><img src="https://img.hi-linux.com/staticfile/image-20210618095504045-2021-06-18-lxFYtq.png" alt></p><p>想要了解更多详情，可戳下方链接～</p><p>传送门：</p><ul><li><a href="https://rustdesk.com/zh/" target="_blank" rel="noopener">https://rustdesk.com/zh/</a></li><li><a href="https://github.com/rustdesk/rustdesk" target="_blank" rel="noopener">https://github.com/rustdesk/rustdesk</a></li><li><a href="https://gitee.com/rustdesk" target="_blank" rel="noopener">https://gitee.com/rustdesk</a></li><li><a href="https://gitee.com/rustdesk/rustdesk-server/blob/master/id-relay-set.md" target="_blank" rel="noopener">https://gitee.com/rustdesk/rustdesk-server/blob/master/id-relay-set.md</a></li></ul><p>参考链接：</p><ul><li><a href="https://www.v2ex.com/t/772047" target="_blank" rel="noopener">https://www.v2ex.com/t/772047</a></li><li><a href="https://www.v2ex.com/t/712086?p=1" target="_blank" rel="noopener">https://www.v2ex.com/t/712086?p=1</a></li><li><a href="https://juejin.cn/post/6881056112909500430" target="_blank" rel="noopener">https://juejin.cn/post/6881056112909500430</a></li></ul><blockquote><p>本文转载自：「 量子位 」，原文：<a href="https://tinyurl.com/p6msym8h" target="_blank" rel="noopener">https://tinyurl.com/p6msym8h</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对很多 Mac 用户来说，想用远程控制请教下大佬，太难了。&lt;/p&gt;
&lt;p&gt;在 Windows 上一个 QQ 就能搞定的事，而 Mac 用户几乎只能依赖 Teamviewer。&lt;/p&gt;
&lt;p&gt;Teamviewer 还遭到不少吐槽：占用高、打开慢，有时还因为被识别为商用而收费……&lt;/p&gt;
&lt;p&gt;现在，你不必再和它较劲了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RustDesk" scheme="https://www.hi-linux.com/categories/RustDesk/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="RustDesk" scheme="https://www.hi-linux.com/tags/RustDesk/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你使用 Kube-Vip 部署一个生产级别的高可用 Kubernetes 集群</title>
    <link href="https://www.hi-linux.com/posts/13616.html"/>
    <id>https://www.hi-linux.com/posts/13616.html</id>
    <published>2021-06-21T01:00:00.000Z</published>
    <updated>2021-06-21T01:37:47.488Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>kube-vip</code> 可以在你的控制平面节点上提供一个 Kubernetes 原生的 HA 负载均衡，我们不需要再在外部设置 HAProxy 和 Keepalived 来实现集群的高可用了。</p><p><code>kube-vip</code> 是一个为 Kubernetes 集群内部和外部提供高可用和负载均衡的开源项目，在 Vmware 的 Tanzu 项目中已经使用 kube-vip 替换了用于 vSphere 部署的 HAProxy 负载均衡器，本文我们将先来了解 kube-vip 如何用于 Kubernetes 控制平面的高可用和负载均衡功能。</p><h2><span id="特点">特点</span></h2><p>Kube-Vip 最初是为 Kubernetes 控制平面提供 HA 解决方案而创建的，随着时间的推移，它已经发展为将相同的功能合并到 Kubernetes 的 LoadBalancer 类型的 Service 中了。</p><ul><li>VIP 地址可以是 IPv4 或 IPv6</li><li>带有 ARP（第2层）或 BGP（第3层）的控制平面</li><li>使用领导选举或 raft 控制平面</li><li>带有 kubeadm（静态 Pod）的控制平面 HA</li><li>带有 K3s/和其他（DaemonSets）的控制平面 HA</li><li>使用 ARP 领导者选举的 Service LoadBalancer（第 2 层）</li><li>通过 BGP 使用多个节点的 Service LoadBalancer</li><li>每个命名空间或全局的 Service LoadBalancer 地址池</li><li>Service LoadBalancer 地址通过 UPNP 暴露给网关</li></ul><a id="more"></a><h2><span id="haproxy-和-kube-vip-的-ha-集群">HAProxy 和 kube-vip 的 HA 集群</span></h2><p>在以前我们在私有环境下创建 Kubernetes 集群时，我们需要准备一个硬件/软件的负载均衡器来创建多控制面集群，更多的情况下我们会选择使用 HAProxy + Keepalived 来实现这个功能。一般情况下我们创建2个负载均衡器的虚拟机，然后分配一个 VIP，然后使用 VIP 为负载均衡器提供服务，通过 VIP 将流量重定向到后端的某个 Kubernetes 控制器平面节点上。</p><p><img src="https://img.hi-linux.com/staticfile/640-2021-06-17-heYabg.jpg" alt></p><p>接下来我们再来看看如果我们使用 kube-vip 的话会怎样呢？</p><p><img src="https://img.hi-linux.com/staticfile/640-20210617164455474-2021-06-17-weRMv3.jpg" alt></p><p>kube-vip 可以通过静态 pod 运行在控制平面节点上，这些 pod 通过ARP 对话来识别每个节点上的其他主机，所以需要在 hosts 文件中设置每个节点的 IP 地址，我们可以选择 BGP 或 ARP 来设置负载平衡器，这与 Metal LB 比较类似。这里我们没有 BGP 服务，只是想快速测试一下，所以这里我们使用 ARP 与静态 pod 的方式。</p><h2><span id="kube-vip-架构">kube-vip 架构</span></h2><p>kube-vip 有许多功能设计选择提供高可用性或网络功能，作为VIP/负载平衡解决方案的一部分。</p><h3><span id="cluster">Cluster</span></h3><p>kube-vip 建立了一个多节点或多模块的集群来提供高可用性。在 ARP 模式下，会选出一个领导者，这个节点将继承虚拟 IP 并成为集群内负载均衡的领导者，而在 BGP 模式下，所有节点都会通知 VIP 地址。</p><p>当使用 ARP 或 layer2 时，它将使用领导者选举，当然也可以使用 raft 集群技术，但这种方法在很大程度上已经被领导者选举所取代，特别是在集群中运行时。</p><h3><span id="虚拟ip">虚拟IP</span></h3><p>集群中的领导者将分配 vip，并将其绑定到配置中声明的选定接口上。当领导者改变时，它将首先撤销 vip，或者在失败的情况下，vip 将直接由下一个当选的领导者分配。</p><p>当 vip 从一个主机移动到另一个主机时，任何使用 vip 的主机将保留以前的 <code>vip &lt;-&gt; MAC</code> 地址映射，直到 ARP 过期（通常是30秒）并检索到一个新的 <code>vip &lt;-&gt; MAC</code> 映射，这可以通过使用无偿的 ARP 广播来优化。</p><h3><span id="arp">ARP</span></h3><p>kube-vip可以被配置为广播一个无偿的 arp（可选），通常会立即通知所有本地主机 <code>vip &lt;-&gt; MAC</code> 地址映射已经改变。</p><p>下面我们可以看到，当 ARP 广播被接收时，故障转移通常在几秒钟内完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">64 bytes from 192.168.0.75: icmp_seq&#x3D;146 ttl&#x3D;64 time&#x3D;0.258 ms</span><br><span class="line">64 bytes from 192.168.0.75: icmp_seq&#x3D;147 ttl&#x3D;64 time&#x3D;0.240 ms</span><br><span class="line">92 bytes from 192.168.0.70: Redirect Host(New addr: 192.168.0.75)</span><br><span class="line">Vr HL TOS  Len   ID Flg  off TTL Pro  cks      Src      Dst</span><br><span class="line"> 4  5  00 0054 bc98   0 0000  3f  01 3d16 192.168.0.95  192.168.0.75</span><br><span class="line"></span><br><span class="line">Request timeout for icmp_seq 148</span><br><span class="line">92 bytes from 192.168.0.70: Redirect Host(New addr: 192.168.0.75)</span><br><span class="line">Vr HL TOS  Len   ID Flg  off TTL Pro  cks      Src      Dst</span><br><span class="line"> 4  5  00 0054 75ff   0 0000  3f  01 83af 192.168.0.95  192.168.0.75</span><br><span class="line"></span><br><span class="line">Request timeout for icmp_seq 149</span><br><span class="line">92 bytes from 192.168.0.70: Redirect Host(New addr: 192.168.0.75)</span><br><span class="line">Vr HL TOS  Len   ID Flg  off TTL Pro  cks      Src      Dst</span><br><span class="line"> 4  5  00 0054 2890   0 0000  3f  01 d11e 192.168.0.95  192.168.0.75</span><br><span class="line"></span><br><span class="line">Request timeout for icmp_seq 150</span><br><span class="line">64 bytes from 192.168.0.75: icmp_seq&#x3D;151 ttl&#x3D;64 time&#x3D;0.245 ms</span><br></pre></td></tr></table></figure><h2><span id="使用-kube-vip">使用 kube-vip</span></h2><p>接下来我们来使用 kube-vip 搭建一个高可用的 Kubernetes 集群。先准备6个节点：</p><ul><li>3个控制平面节点</li><li>3个 worker 节点</li></ul><p><img src="https://img.hi-linux.com/staticfile/640-20210617164502472-2021-06-17-q1QUur.jpg" alt></p><p>首先在宿主机上面安装相关依赖，包括 kubeadm、kubelet、kubectl 以及一个容器运行时，这里我们使用的是 containerd。</p><p>获取 kube-vip 的 docker 镜像，并在 <code>/etc/kuberentes/manifests</code> 中设置静态 pod 的 yaml 资源清单文件，这样 Kubernetes 就会自动在每个控制平面节点上部署 kube-vip 的 pod 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置VIP地址</span><br><span class="line">$ export VIP&#x3D;192.168.0.100</span><br><span class="line">$ export INTERFACE&#x3D;eth0</span><br><span class="line">$ ctr image pull docker.io&#x2F;plndr&#x2F;kube-vip:0.3.1</span><br><span class="line">$ ctr run --rm --net-host docker.io&#x2F;plndr&#x2F;kube-vip:0.3.1 vip \</span><br><span class="line">&#x2F;kube-vip manifest pod \</span><br><span class="line">--interface $INTERFACE \</span><br><span class="line">--vip $VIP \</span><br><span class="line">--controlplane \</span><br><span class="line">--services \</span><br><span class="line">--arp \</span><br><span class="line">--leaderElection | tee  &#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;kube-vip.yaml</span><br></pre></td></tr></table></figure><p>接下来就可以配置 kubeadm 了，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; ~&#x2F;init_kubelet.yaml &lt;&lt;EOF</span><br><span class="line">apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- token: &quot;9a08jv.c0izixklcxtmnze7&quot;</span><br><span class="line">description: &quot;kubeadm bootstrap token&quot;</span><br><span class="line">ttl: &quot;24h&quot;</span><br><span class="line">nodeRegistration:</span><br><span class="line">criSocket: &quot;&#x2F;var&#x2F;run&#x2F;containerd&#x2F;containerd.sock&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">controlPlaneEndpoint: &quot;192.168.0.100:6443&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: kubelet.config.k8s.io&#x2F;v1beta1</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">cgroupDriver: &quot;systemd&quot;</span><br><span class="line">protectKernelDefaults: true</span><br><span class="line">EOF</span><br><span class="line">$ kubeadm init --config init_kubelet.yaml --upload-certs</span><br></pre></td></tr></table></figure><p>然后安装 CNI，比如我们选择使用 Cilium。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;helm&#x2F;helm&#x2F;master&#x2F;scripts&#x2F;get-helm-3 | bash</span><br><span class="line">$ helm repo add cilium https:&#x2F;&#x2F;helm.cilium.io&#x2F;</span><br><span class="line">$ helm install cilium cilium&#x2F;cilium --version 1.9.4 \</span><br><span class="line">--namespace kube-system</span><br></pre></td></tr></table></figure><p>在第一个控制平面节点准备好后，让其他节点加入你的集群。对于其他控制平面节点，运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm join 192.168.0.100:6443 --token hash.hash\</span><br><span class="line">     --discovery-token-ca-cert-hash sha256:hash \</span><br><span class="line">     --control-plane --certificate-key key</span><br></pre></td></tr></table></figure><p>对于工作节点，运行类似命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm join 192.168.0.100:6443 --token hash.hash\</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:hash</span><br></pre></td></tr></table></figure><p>正常执行完成后集群就可以启动起来了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get node -o wide</span><br><span class="line">NAME           STATUS   ROLES                  AGE    VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION     CONTAINER-RUNTIME</span><br><span class="line">k8s-master-0   Ready    control-plane,master   121m   v1.20.2   192.168.0.201   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4.0-45-generic   containerd:&#x2F;&#x2F;1.4.3</span><br><span class="line">k8s-master-1   Ready    control-plane,master   114m   v1.20.2   192.168.0.202   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4.0-45-generic   containerd:&#x2F;&#x2F;1.4.3</span><br><span class="line">k8s-master-2   Ready    control-plane,master   113m   v1.20.2   192.168.0.203   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4.0-45-generic   containerd:&#x2F;&#x2F;1.4.3</span><br><span class="line">k8s-worker-0   Ready    &lt;none&gt;                 114m   v1.20.2   192.168.0.204   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4.0-45-generic   containerd:&#x2F;&#x2F;1.4.3</span><br><span class="line">k8s-worker-1   Ready    &lt;none&gt;                 114m   v1.20.2   192.168.0.205   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4.0-45-generic   containerd:&#x2F;&#x2F;1.4.3</span><br><span class="line">k8s-worker-2   Ready    &lt;none&gt;                 112m   v1.20.2   192.168.0.206   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4.0-45-generic   containerd:&#x2F;&#x2F;1.4.3</span><br></pre></td></tr></table></figure><p>现在可以看到我们的控制面的端点是 192.168.0.100，没有其他额外的节点，是不是非常方便。</p><p>参考文档： <a href="https://inductor.medium.com/say-good-bye-to-haproxy-and-keepalived-with-kube-vip-on-your-ha-k8s-control-plane-bb7237eca9fc" target="_blank" rel="noopener">https://inductor.medium.com/say-good-bye-to-haproxy-and-keepalived-with-kube-vip-on-your-ha-k8s-control-plane-bb7237eca9fc</a></p><blockquote><p>本文转载自：「 k8s 技术圈 」，原文：<a href="https://tinyurl.com/f66ejhbc" target="_blank" rel="noopener">https://tinyurl.com/f66ejhbc</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;kube-vip&lt;/code&gt; 可以在你的控制平面节点上提供一个 Kubernetes 原生的 HA 负载均衡，我们不需要再在外部设置 HAProxy 和 Keepalived 来实现集群的高可用了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kube-vip&lt;/code&gt; 是一个为 Kubernetes 集群内部和外部提供高可用和负载均衡的开源项目，在 Vmware 的 Tanzu 项目中已经使用 kube-vip 替换了用于 vSphere 部署的 HAProxy 负载均衡器，本文我们将先来了解 kube-vip 如何用于 Kubernetes 控制平面的高可用和负载均衡功能。&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;特点&lt;/h2&gt;
&lt;p&gt;Kube-Vip 最初是为 Kubernetes 控制平面提供 HA 解决方案而创建的，随着时间的推移，它已经发展为将相同的功能合并到 Kubernetes 的 LoadBalancer 类型的 Service 中了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VIP 地址可以是 IPv4 或 IPv6&lt;/li&gt;
&lt;li&gt;带有 ARP（第2层）或 BGP（第3层）的控制平面&lt;/li&gt;
&lt;li&gt;使用领导选举或 raft 控制平面&lt;/li&gt;
&lt;li&gt;带有 kubeadm（静态 Pod）的控制平面 HA&lt;/li&gt;
&lt;li&gt;带有 K3s/和其他（DaemonSets）的控制平面 HA&lt;/li&gt;
&lt;li&gt;使用 ARP 领导者选举的 Service LoadBalancer（第 2 层）&lt;/li&gt;
&lt;li&gt;通过 BGP 使用多个节点的 Service LoadBalancer&lt;/li&gt;
&lt;li&gt;每个命名空间或全局的 Service LoadBalancer 地址池&lt;/li&gt;
&lt;li&gt;Service LoadBalancer 地址通过 UPNP 暴露给网关&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="教程" scheme="https://www.hi-linux.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>科普 | 抖音服务器带宽有多大，为什么能够供上亿用户同时刷？</title>
    <link href="https://www.hi-linux.com/posts/58624.html"/>
    <id>https://www.hi-linux.com/posts/58624.html</id>
    <published>2021-06-20T01:00:00.000Z</published>
    <updated>2021-06-20T12:20:43.394Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>最近看到一个有意思的提问：抖音服务器带宽有多大，为什么能够供那么多人同时刷？今天来给大家科普一下。</p></blockquote><p>抖音，百度，阿里云，腾讯都是自建的数据中心，都是 T 级别出口带宽（总出口带宽），也就是达到 1T=1024G/s 的出口带宽，服务器总数基本都在 20 万台以上，甚至阿里云都超过了 100 万台。</p><p>字节跳动的数据中心总带宽，可能在 10TB 级别左右，预期突破 15TB 级别不远了。</p><a id="more"></a><p>一般情况下：总出口带宽 1TB，实际机房出口带宽可能只有 100G 上下，这是采用双（多）链路设计，双出口实现动态流量分担，总的出口带宽可以达到 T 级别。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210618125403552-2021-06-18-Ast4Xn.jpg" alt="大型数据中心"></p><p>想要同一时间有数亿人在线，TB 级别带宽，CDN 加速和多节点，负载均衡等等技术缺一不可。（这个设计技术过于复杂，有相关专业朋友，可以评论简要概述）</p><p><img src="https://img.hi-linux.com/staticfile/640-20210618132137982-2021-06-18-SKL3gf.jpg" alt="CDN 加速"></p><h2><span id="字节跳动有多少台服务器">字节跳动有多少台服务器？</span></h2><p>根据网络数据整理，2017 年 2-3 万台服务器，这个时候主要是租用服务器为主。</p><p>2018 年，字节跳动自己建设了数据中心，最大的数据中心在河北怀来官厅湖新媒体产业园，一期 5 万台服务器，二期 9 万台服务器。</p><p>2018 年，租用+自建的服务器数量达到 17 万台服务器。</p><p>2020 年，根据字节跳动招聘公告的数据，显示有 42 万台服务器。比 2018 年增长了 1.5 倍。（数据来自网络）</p><p><img src="https://img.hi-linux.com/staticfile/640-20210618132143644-2021-06-18-yYrcJJ.jpg" alt="一个机柜中 10-20 台服务器"></p><p>这部分服务器都是给中国区域使用，主要应用国内的抖音，西瓜视频，今日头条，飞书等产品。</p><p>在美国的 TIKTOK 是独立出来的运营，数据在美国当地存储和分发。2020 年 Tiktok 在美国也租用了近 10 万台服务器</p><p>据 Business Insider 公布数据，2020 年上半年，字节跳动在美国弗吉尼亚州北部租用了能耗达 53 兆瓦的数据中心。可以容纳数十万台服务器，占地面积可达数十万平方英尺。</p><p>Tiktok 在印度，新加坡都在投资建设数据中心。</p><h2><span id="字节跳动大型的数据中心出口带宽是多少">字节跳动大型的数据中心出口带宽是多少？</span></h2><p>聊完了服务器数量，那么咱们来点硬核的东西：字节跳动大型的数据中心出口带宽是多少？</p><blockquote><p>知识点：所谓的出口带宽，其实就是咱们普通人所说的下载带宽。就是服务器给每一个手机分发数据总速度。</p></blockquote><p>一般情况下，小型的 IDC 公司自建机房，比如一些网站公司，租用联通，移动，电信的机房，可能总体出口带宽只有 5G。超过 30G 那都是具备一定规模的企业。网络公司营收少说也是几千万的企业。</p><p>所以，经常能够看到，一些规模还不错的企业，基本上都不再自建机房，都是使用云主机。例如阿里云的 ECS，腾讯云，百度云，AWS（亚马逊）。</p><p>一般一个企业网站（企业官网），20M 带宽，4G 内存，100G 硬盘，一年价格也就 4000-5000 块钱就足够了，赶上做活动价格可能更便宜。</p><p>这里面就是带宽最贵，当然增加带宽，达到一定等级，例如访问量增大，必须要增加内存和硬盘。</p><p>相比来说，带宽增加的话，费用更贵一些。这里就跟你说明一下：带宽比较昂贵，属于稀缺资源。</p><p>我们来看中国移动的一个机房，中国移动（河北石家庄）数据中心的数据：占地面积 174 亩，总建筑面积 13 万平方米，规划 10 栋单体建筑，全部建成后可提供约 3 万个机架的装机能力。</p><p>3 个 IDC 机房共可提供 3.1 万架机柜，15T 带宽资源。一个机柜，全 1U 设备部署数量一般不超过 16 台，全 2U 设备一般不超过 12 台，全 4U 设备一般 4 到 7 台。</p><p>我们取高性能的 2U 和 4U 服务器进行平均折中，各算一半（毕竟移动也算是有钱的大户，不能买低端的 1U 设备）。</p><p>那么 3.1 万架机柜就可以安装，最多 21-36 万台服务器。这里粗略取一个平均值：30 万台服务器。</p><p>享受 15T 的出口带宽资源。当然作为电信的干路网，移动拿带宽资源肯定是要比字节跳动更有优势的。</p><p>所以，我们粗略地估计字节跳动自建的 17 万台服务器的数据中心。总出口带宽可能在 7Tb-10TB 上下。</p><p>基本上肯定会采用双出口流量设计，再加上多链路的部署方式：可以做到实际出口带宽在 800G-1TG 就可以实现 10T 左右的总出口带宽。【这是技术方式】</p><p><img src="https://img.hi-linux.com/staticfile/640-20210618125403637-2021-06-18-0b9MmZ.jpg" alt="字节跳动 2018 年河北怀化数据中心"></p><p>T 级别出口带宽是什么概念，如果我告诉你 2009 年，整个上海的出口带宽才 1140G，也就是刚刚达到 1TB。</p><p>在短短的 10 年后，一个企业的数据中心的出口带宽就超过 1TB，这个速度真的不可想象。</p><p>要知道 2009 年，虽然智能手机不发达，但是个人 PC 销量已经非常庞大了。</p><p>CDN 加速，让大众刷抖音，看视频都不再卡。</p><blockquote><p>知识点：CDN（Content Delivery Network，内容分发网络）。</p></blockquote><p>将服务端的内容发布到最接近用户的边缘节点，使用户可以就近取得所需的内容。</p><p>解决 Internet 网络拥塞状况，提高用户访问网站的响应速度。多种加速的方案集合。</p><p><strong>用通俗的话解释 CDN 就是：</strong> 会把一些页面，专门压缩，有的压缩为静态页面，静态页面直接分发速度快。用户可以在 2s 内看到内容，体验感更好。【这是静态传输】</p><p>对于动态视频，首先通过智能路由，寻找最佳路径，然后协议优化将长连接，内容进行压缩，去除冗余。【这就是动态压缩】</p><p>给你们看一下 2015 年腾讯 5 亿日活，集合了音乐，即时通讯等等产品的 CDN 的级别，达到了 10TB 带宽。每天请求万亿次。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210618132155242-2021-06-18-RoPW9i.jpg" alt="2015 年腾讯 CDN 的级别"></p><p>因此，我这里说字节跳动整体服务器有 10TB 应该只少不多。毕竟抖音日活有 6 亿，西瓜视频+今日头条我们粗略算是 2 亿，总计有 8 亿的日活。</p><p>就是这么大的带宽和技术实力，才能让我们看视频这么顺畅。</p><blockquote><p>本文转载自：「 新浪 」，原文：<a href="https://tinyurl.com/khheksc5" target="_blank" rel="noopener">https://tinyurl.com/khheksc5</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近看到一个有意思的提问：抖音服务器带宽有多大，为什么能够供那么多人同时刷？今天来给大家科普一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抖音，百度，阿里云，腾讯都是自建的数据中心，都是 T 级别出口带宽（总出口带宽），也就是达到 1T=1024G/s 的出口带宽，服务器总数基本都在 20 万台以上，甚至阿里云都超过了 100 万台。&lt;/p&gt;
&lt;p&gt;字节跳动的数据中心总带宽，可能在 10TB 级别左右，预期突破 15TB 级别不远了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="网络" scheme="https://www.hi-linux.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="抖音" scheme="https://www.hi-linux.com/tags/%E6%8A%96%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Yadm 优雅管理你的应用配置和数据</title>
    <link href="https://www.hi-linux.com/posts/64799.html"/>
    <id>https://www.hi-linux.com/posts/64799.html</id>
    <published>2021-06-18T01:00:00.000Z</published>
    <updated>2021-06-18T01:16:59.484Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>开始，开始，开始使用吧！</strong></p></blockquote><h2><span id="1-功能简介">1. 功能简介</span></h2><blockquote><p><strong>User-specific app config is stored in so called dotfiles</strong></p></blockquote><p>您开始尝试对配置进行新的更改，现在一切都被破坏了。<code>yadm</code> 可以帮助你决定什么改变了，或者简单地恢复你所有的改变。</p><ul><li><strong>Yadm 可以恢复你的配置</strong></li></ul><p>您已经花费了时间调整您的计算环境。一切都按照你想要的方式运作。太棒了！然后你的硬盘出了故障，电脑需要重建。</p><ul><li><strong>Yadm 可以帮你协调机器之间的配置</strong></li></ul><p>你得到了一台新电脑，你想要重新创建那个环境。您可能希望两台机器的配置保持同步。</p><a id="more"></a><h2><span id="2-工作方式">2. 工作方式</span></h2><blockquote><p><strong>Yet Another Dotfiles Manager</strong></p></blockquote><p><code>yadm</code> 就像有一个版本的 <code>Git</code>，它只在你的 <code>dotfiles</code> 上运行。如果你知道如何使用 <code>Git</code> 工具的话，你已经知道如何使用 <code>yadm</code> 了。</p><ol><li>如果您的工作目录是另一个 <code>Git</code> 管理的存储库，这并不重要。</li><li>不必移动 <code>dotfiles</code> 或者将它们从另一个位置符号链接起来。</li><li><code>Yadm</code> 自动继承了 <code>Git</code> 的所有特性，允许你分支、合并、重建、使用子模块等。</li></ol><p>实际上 <code>yadm</code> 底层依旧是使用 <code>Git</code> 来做管理的，即 <code>yadm</code> 在管理 <code>dotfiles</code> 的时候，实际上是用 <code>Git</code> 来进行版本控制、远程同步等操作的。但是，<code>yadm</code> 在 <code>Git</code> 工具功能的基础之上，进行了合理的功能拓展。</p><ol><li>使用单一存储库</li><li>几乎没有任何依赖</li><li>能够使用基于操作系统或主机的备用文件</li><li>能够加密和跟踪机密文件</li></ol><h2><span id="3-安装方式">3. 安装方式</span></h2><blockquote><p><strong>安装方式原来很简单</strong></p></blockquote><ul><li><strong>OSX</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install yadm</span><br></pre></td></tr></table></figure><ul><li><strong>Ubuntu/Debian</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install -y yadm</span><br></pre></td></tr></table></figure><ul><li><strong>Download</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fLo /usr/<span class="built_in">local</span>/bin/yadm https://github.com/TheLocehiliosan/yadm/raw/master/yadm</span><br><span class="line">$ chmod a+x /usr/<span class="built_in">local</span>/bin/yadm</span><br></pre></td></tr></table></figure><h2><span id="4-快速开始">4. 快速开始</span></h2><blockquote><p><strong>只需要简单几个步骤，</strong></p></blockquote><ul><li><strong>[1] 创建一个新的远程仓库</strong></li></ul><p>在 <code>Github</code> 上面创建一个空的仓库，推荐使用私有仓库，况且现在私有仓库已经免费开放了。不然，一旦将私有的内容同步上去的话，那就非常尴尬且危险了。之后，再我们的家目录(<code>~/</code>)下面进行初始化并添加到仓库里面进行管理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化yadm仓库</span></span><br><span class="line">$ yadm init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用yadm添加文件或目录</span></span><br><span class="line">$ yadm add &lt;file/dir&gt;</span><br><span class="line">$ yadm commit -m <span class="string">"info"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程仓库</span></span><br><span class="line">$ yadm remote add origin &lt;github url&gt;</span><br><span class="line">$ yadm push -u origin master</span><br></pre></td></tr></table></figure><ul><li><strong>[2] 已经有了远程存储库</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用</span></span><br><span class="line">$ yadm <span class="built_in">clone</span> &lt;github url&gt;</span><br><span class="line">$ yadm status</span><br></pre></td></tr></table></figure><p>从此开始，我们就可以使用 <code>yadm</code> 来专属管理我们分散在系统中各个地方的配置文件或者重要目录了，即专属的 <code>Dotfiles</code> 管家。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看使用yadm管理的Dotfiles列表</span></span><br><span class="line">$ yadm list | head -2</span><br><span class="line">.tmux.conf</span><br><span class="line">.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个Dotfiles文件的修改情况</span></span><br><span class="line">$ yadm status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span></span><br><span class="line">nothing to commit (use -u to show untracked files)</span><br></pre></td></tr></table></figure><h2><span id="5-命令使用">5. 命令使用</span></h2><blockquote><p><strong>先来掌握下 yadm 命令的使用吧！</strong></p></blockquote><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">Yadm 命令参数</th><th style="text-align:left">参数对应含义解释</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong><code>yadm status</code></strong></td><td style="text-align:left">查看状态</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong><code>yadm fetch</code></strong></td><td style="text-align:left">远程获取</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong><code>yadm push</code></strong></td><td style="text-align:left">推送配置</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong><code>yadm diff</code></strong></td><td style="text-align:left">对比差异</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong><code>yadm diff --cached</code></strong></td><td style="text-align:left">对比差异</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong><code>yadm list</code></strong></td><td style="text-align:left">管理列表</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong><code>yadm list -a</code></strong></td><td style="text-align:left">管理列表</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong><code>yadm clone</code></strong></td><td style="text-align:left">克隆项目</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong><code>yadm clone --bootstrap</code></strong></td><td style="text-align:left">克隆项目</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong><code>yadm checkout</code></strong></td><td style="text-align:left">状态迁出</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><strong><code>yadm checkout -b</code></strong></td><td style="text-align:left">状态迁出</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><strong><code>yadm encrypt</code></strong></td><td style="text-align:left">文件解密</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><strong><code>yadm decrypt</code></strong></td><td style="text-align:left">文件解密</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><strong><code>yadm decrypt -l</code></strong></td><td style="text-align:left">文件加密</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><strong><code>yadm commit --amend</code></strong></td><td style="text-align:left">用新的提交替换上次提交</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><strong><code>yadm alt</code></strong></td><td style="text-align:left">创建符号链接</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left"><strong><code>yadm remote -v</code></strong></td><td style="text-align:left">查看远程仓库地址</td></tr></tbody></table><h2><span id="6-自动配置">6. 自动配置</span></h2><blockquote><p><strong>使用 Yadm 来自动配置环境</strong></p></blockquote><ul><li>咳咳咳，我们使用 <code>yadm</code> 工具不光光是可以管理我们的 <code>Dotfiles</code> 文件或者目录，而且还可以使用它的 <code>bootstrap</code> 功能来完成初始化电脑时许多工具的安装。</li><li>使用 <code>bootstrap</code> 功能可以自动将任务脚本的执行 <code>hook</code> 在 <code>yadm</code> 克隆之后，来完成环境的全自动部署。这里不论是 <code>Bash</code> 脚本、<code>Python</code> 脚本还是什么别的，只要是可执行文件就可以。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认位置</span></span><br><span class="line"><span class="variable">$HOME</span>/.config/yadm/bootstrap/</span><br></pre></td></tr></table></figure><ul><li>创建和准备好下述脚本之后，我们就可以执行 <code>yadm bootstrap</code> 命令来手动执行检测一下了。当然，我们编写的 <code>bootstrap</code> 文件也是可以使用 <code>yadm</code> 工具来进行管理的。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">system_type=$(uname -s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">is_command</span></span>() &#123;</span><br><span class="line">    <span class="built_in">command</span> -v <span class="string">"<span class="variable">$1</span>"</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;system_type&#125;</span> = <span class="string">"Darwin"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> ! is_command zsh; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Installing zsh..."</span></span><br><span class="line">        brew install zsh</span><br><span class="line">        <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"All packages are installed."</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"Install zsh error."</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/use-yadm-manager-dotfiles-01-2021-01-26-gdrSJR.png" alt></p><h2><span id="7-隐私保护">7. 隐私保护</span></h2><blockquote><p><strong>使用 Yadm 来隐私保护</strong></p></blockquote><ul><li>对敏感文件(比如 <code>SSH</code> 密钥)进行加密、解密，提供私有仓库以外的额外一层保护，非常有用且重要。但是，这样做会将纯文本数据放入 <code>Git</code> 存储库，后者通常驻留在公共系统中。</li><li>然而 <code>yadm</code> 实现了一个特性，可以很容易地对一组文件进行加密和解密，这样加密后的版本就可以保存在 <code>Git</code> 仓库中。这个特性只有在 <code>gpg</code> 命令可用的情况下才能工作。建议您在保存机密文件时使用私有存储库，即使这些文件是加密的。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认位置</span></span><br><span class="line"><span class="variable">$HOME</span>/.config/yadm/encrypt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密后位置</span></span><br><span class="line"><span class="variable">$HOME</span>/.config/yadm/files.gpg</span><br></pre></td></tr></table></figure><ul><li>要使用这个特性，必须创建一个模式列表，保存对应内容到上述的默认配置文件中即可。这样 <code>yadm</code> 加密命令会找到所有与模式匹配的文件，并提示输入密码。一旦确认了密码，匹配的文件将被加密并保存为 <code>files.gpg</code> 文件。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="variable">$HOME</span>/.config/yadm/encrypt</span><br><span class="line">.ssh/*.key</span><br></pre></td></tr></table></figure><ul><li>接下来需要做的就是和普通添加文件或目录操作一致，即使用 <code>yadm</code> 提交到远程仓库中去。以后要解密这些文件，或者在另一个系统上运行 <code>yadm</code> 解密并提供正确的密码。默认情况下，任何解密文件都会被删除其 <strong>“group”</strong> 和 <strong>“others”</strong> 权限。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加文件并提交</span></span><br><span class="line">$ yadm add .config/yadm/encrypt</span><br><span class="line">$ yadm add .config/yadm/files.gpg</span><br></pre></td></tr></table></figure><ul><li>默认情况下使用的是对称加密，但使用 <code>yadm.gpg-receiver</code> 配置可以启用非对称加密。要做到这一点，请运行如下命令即可。为此，接收者地址中必须存在 <code>gpg</code> 的秘钥才可以。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非对称加密</span></span><br><span class="line">$ yadm config yadm.gpg-recipient &lt;recipient-address&gt;</span><br></pre></td></tr></table></figure><h2><span id="8-配置分类">8. 配置分类</span></h2><blockquote><p><strong>使用 Yadm 来配置分类</strong></p></blockquote><p>如果可能的话，最好在所有系统上使用相同的文件。但是，在某些场合您需要不同的文件。即针对不同的操作系统、不同的环境，需要维护不同种类的同一软件或插件的 <code>dotfile</code> 文件，可以使用如下两个插件来解决。</p><ul><li><a href="https://yadm.io/docs/templates" target="_blank" rel="noopener">yadm Docs - Templates</a></li><li><a href="https://yadm.io/docs/alternates" target="_blank" rel="noopener">yadm Docs - Alternate Files</a></li></ul><blockquote><p><strong>Alternate Files</strong></p></blockquote><ul><li>使用上述的 <code>Alternate Files</code> 功能时，<code>Yadm</code> 为不同的操作系统、主机、用户会自动创建一个符号链接到适当的文件版本上，一个有效的后缀被附加到文件名，即后缀中包含使用该文件必须满足的条件。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式如下</span></span><br><span class="line"><span class="comment">##&lt;condition&gt;[,&lt;condition&gt;,…]</span></span><br></pre></td></tr></table></figure><ul><li>每个条件都是一个 <strong>属性/值</strong> 对，由一个句点分隔。有些条件不需要 <strong>“值”</strong>，在这种情况下，可以省略句点和值，且大多数属性可以缩写为一个单独的字母。</li></ul><table><thead><tr><th style="text-align:left">Attribute</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left"><code>template</code>, <code>t</code></td><td style="text-align:left">Valid when the value matches a supported template processor. See the <a href="https://yadm.io/docs/templates" target="_blank" rel="noopener">Templates</a> section for more details.</td></tr><tr><td style="text-align:left"><code>user</code>, <code>u</code></td><td style="text-align:left">Valid if the value matches the current user. Current user is calculated by running <code>id ‑u ‑n</code>.</td></tr><tr><td style="text-align:left"><code>distro</code>, <code>d</code></td><td style="text-align:left">Valid if the value matches the distro. Distro is calculated by running <code>lsb_release ‑si</code> or inspecting <code>/etc/os-release</code></td></tr><tr><td style="text-align:left"><code>os</code>, <code>o</code></td><td style="text-align:left">Valid if the value matches the OS. OS is calculated by running <code>uname ‑s</code>.</td></tr><tr><td style="text-align:left"><code>class</code>, <code>c</code></td><td style="text-align:left">Valid if the value matches the local.class configuration. Class must be manually set using <code>yadm config local.class &lt;class&gt;</code>.</td></tr><tr><td style="text-align:left"><code>hostname</code>, <code>h</code></td><td style="text-align:left">Valid if the value matches the short hostname. Hostname is calculated by running <code>hostname</code>, and trimming off any domain.</td></tr><tr><td style="text-align:left"><code>default</code></td><td style="text-align:left">Valid when no other alternate is valid.</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例演示</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##default</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##class.Work</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Darwin</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Darwin,hostname.host1</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Darwin,hostname.host2</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Linux</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Linux,hostname.host1</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Linux,hostname.host2</span></span><br></pre></td></tr></table></figure><ul><li>模板是另一个在每个主机上创建替代内容的强大工具，你应该尝试在每个系统上使用相同的文件。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .vimrc</span></span><br><span class="line"><span class="built_in">let</span> OS=substitute(system(<span class="string">'uname -s'</span>),<span class="string">"\n"</span>,<span class="string">""</span>,<span class="string">""</span>)</span><br><span class="line"><span class="keyword">if</span> (OS == <span class="string">"Darwin"</span>)</span><br><span class="line">    <span class="string">" do something that only makes sense on a Mac</span></span><br><span class="line"><span class="string">endif</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># . bash_profile</span></span><br><span class="line">system_type=$(uname -s)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$system_type</span>"</span> = <span class="string">"Darwin"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> $(gdircolors <span class="variable">$HOME</span>/.dir_colors)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">eval</span> $(dircolors -b <span class="variable">$HOME</span>/.dir_colors)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Templates</strong></p></blockquote><ul><li>模板是一种特殊的 <code>alternate</code> 文件，模板内容和主机特定的数据结合起来作为输入到一个模板处理文件中，该文件产生一个新的文件作为其输出。如果你需要改变一个文件的一小部分，这会非常有用，但是它不支持任何类型的头文件。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式如下</span></span><br><span class="line"><span class="comment">##template.&lt;template processor&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>支持的模板处理器</strong></li></ul><table><thead><tr><th style="text-align:left">Processor</th><th style="text-align:left">Suffixes</th><th style="text-align:left">Dependencies</th></tr></thead><tbody><tr><td style="text-align:left">default</td><td style="text-align:left"><code>##template</code>, <code>##template.default</code></td><td style="text-align:left"><code>awk</code> must be installed. (This should be installed on all linux systems)</td></tr><tr><td style="text-align:left">esh</td><td style="text-align:left"><code>##template.esh</code></td><td style="text-align:left"><code>esh</code> must be installed.</td></tr><tr><td style="text-align:left">j2cli</td><td style="text-align:left"><code>##template.j2</code>, <code>##template.j2cli</code></td><td style="text-align:left"><code>j2cli</code> must be installed.</td></tr><tr><td style="text-align:left">envtpl</td><td style="text-align:left"><code>##template.j2</code>, <code>##template.envtpl</code></td><td style="text-align:left"><code>envtpl</code> must be installed.</td></tr></tbody></table><ul><li><strong>内置指令集</strong></li></ul><table><thead><tr><th style="text-align:left">Default (built-in)</th><th style="text-align:left">Jinja or ESH</th><th style="text-align:left">Description</th><th style="text-align:left">Source</th></tr></thead><tbody><tr><td style="text-align:left"><code>yadm.class</code></td><td style="text-align:left"><code>YADM_CLASS</code></td><td style="text-align:left">Locally defined yadm class</td><td style="text-align:left"><code>yadm config local.class</code></td></tr><tr><td style="text-align:left"><code>yadm.distro</code></td><td style="text-align:left"><code>YADM_DISTRO</code></td><td style="text-align:left">Distribution</td><td style="text-align:left"><code>lsb_release ‑si</code></td></tr><tr><td style="text-align:left">or <code>/etc/os-release</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>yadm.hostname</code></td><td style="text-align:left"><code>YADM_HOSTNAME</code></td><td style="text-align:left">Hostname</td><td style="text-align:left"><code>hostname</code> (without domain)</td></tr><tr><td style="text-align:left"><code>yadm.os</code></td><td style="text-align:left"><code>YADM_OS</code></td><td style="text-align:left">Operating system</td><td style="text-align:left"><code>uname ‑s</code></td></tr><tr><td style="text-align:left"><code>yadm.user</code></td><td style="text-align:left"><code>YADM_USER</code></td><td style="text-align:left">Current user</td><td style="text-align:left"><code>id ‑u ‑n</code></td></tr><tr><td style="text-align:left"><code>yadm.source</code></td><td style="text-align:left"><code>YADM_SOURCE</code></td><td style="text-align:left">Template filename</td><td style="text-align:left">(fully qualified path)</td></tr></tbody></table><ul><li><strong>实例演示</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> yadm.os == <span class="string">"Darwin"</span> %&#125;</span><br><span class="line">This block is included <span class="keyword">for</span> MacOS</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">This block is included <span class="keyword">for</span> any other OS</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h2><span id="9-扩展配合">9. 扩展配合</span></h2><blockquote><p><strong>管理 $HOME 以外的文件</strong></p></blockquote><ul><li>在默认的情况下，<code>yadm</code> 工具仅仅只会管理 <code>$HOME</code> 下的文件和目录，这大部分情况下也是完全合理以及必要的。即我们家目录下面的文件，并不会管理其他的目录层级，比如 <code>/etc/</code> 等。</li><li>但是，我们要想管理 <code>$HOME</code> 以外的文件，即扩大文件树的管理范围，就要对其进行一些必要的改造。首先，需要管理的区域要有可读写的权限。然后，执行如下操作即可。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用.yadm作为yadm的系统文件管理目录</span></span><br><span class="line">$ <span class="built_in">alias</span> sysyadm=<span class="string">"sudo yadm -Y <span class="variable">$HOME</span>/.yadm"</span></span><br></pre></td></tr></table></figure><ul><li>配置好上面的命令别名之后，就可以使用 <code>sysyadm</code> 命令创建一个单独的远程仓库，来单独管理系统文件。即我们单独使用 <code>sysyadm</code> 命令来管理系统配置，和上面我们管理家目录的互不干扰，各司其职。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将/目录初始化为sysyadm的文件树</span></span><br><span class="line">$ sysyadm init -w /</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文件、签入版本控制系统、同步远程仓库</span></span><br><span class="line">$ sysyadm add /etc/nginx/nginx.conf</span><br><span class="line">$ sysyadm commit -m <span class="string">"add nginx config"</span></span><br><span class="line">$ yadm push</span><br></pre></td></tr></table></figure><h2><span id="10-参考文档">10. 参考文档</span></h2><ul><li><a href="https://github.com/TheLocehiliosan/yadm" target="_blank" rel="noopener">Yadm 的 GitHub 地址</a></li><li><a href="https://yadm.io/" target="_blank" rel="noopener">Yadm 的官方文档地址</a></li><li><a href="https://blog.spencerwoo.com/2020/07/how-i-manage-my-dotfiles/" target="_blank" rel="noopener">我是如何同步并管理我的 Dotfiles 的</a></li></ul><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/y4r6d5fu%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://tinyurl.com/y4r6d5fu，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;开始，开始，开始使用吧！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-功能简介&quot;&gt;1. 功能简介&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;User-specific app config is stored in so called dotfiles&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;您开始尝试对配置进行新的更改，现在一切都被破坏了。&lt;code&gt;yadm&lt;/code&gt; 可以帮助你决定什么改变了，或者简单地恢复你所有的改变。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Yadm 可以恢复你的配置&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;您已经花费了时间调整您的计算环境。一切都按照你想要的方式运作。太棒了！然后你的硬盘出了故障，电脑需要重建。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Yadm 可以帮你协调机器之间的配置&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你得到了一台新电脑，你想要重新创建那个环境。您可能希望两台机器的配置保持同步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Yadm" scheme="https://www.hi-linux.com/tags/Yadm/"/>
    
  </entry>
  
  <entry>
    <title>巧用 Docker Buildx 构建多种系统架构镜像</title>
    <link href="https://www.hi-linux.com/posts/58027.html"/>
    <id>https://www.hi-linux.com/posts/58027.html</id>
    <published>2021-06-17T01:00:00.000Z</published>
    <updated>2021-06-17T01:23:31.834Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Docker Buildx 是一个 Docker CLI 插件，其扩展了 Docker 命令，支持 Moby BuildKit 提供的功能。提供了与 Docker Build 相同的用户体验，并增加了许多新功能。</p><p>BuildKit 是下一代的镜像构建组件，主要特点有很多，本文主要使用其可以编译多种系统架构的特性。</p><blockquote><p>网址：<a href="https://github.com/moby/buildkit" target="_blank" rel="noopener">https://github.com/moby/buildkit</a></p></blockquote><p>需要注意的是，该功能仅适用于 Docker v19.03+ 版本。</p><p>本文将讲解如何使用 Buildx 构建多种系统架构的镜像。</p><a id="more"></a><p>在开始之前，已经默认你在 Linux 系统（各大发行版）下安装好了 64 位的 Docker。</p><p>在写本文时，Docker 最新版本号是 19.03.13。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           19.03.13</span><br><span class="line"> API version:       1.40</span><br><span class="line"> Go version:        go1.13.15</span><br><span class="line"> Git commit:        4484c46d9d</span><br><span class="line"> Built:             Wed Sep 16 17:03:45 2020</span><br><span class="line"> OS&#x2F;Arch:           linux&#x2F;amd64</span><br><span class="line"> Experimental:      true</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          19.03.13</span><br><span class="line">  API version:      1.40 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.13.15</span><br><span class="line">  Git commit:       4484c46d9d</span><br><span class="line">  Built:            Wed Sep 16 17:02:21 2020</span><br><span class="line">  OS&#x2F;Arch:          linux&#x2F;amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.3.7</span><br><span class="line">  GitCommit:        8fba4e9a7d01810a393d5d25a3621dc101981175</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.0-rc10</span><br><span class="line">  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.18.0</span><br><span class="line">  GitCommit:        fec3683</span><br></pre></td></tr></table></figure><h2><span id="1-启用-buildx">1. 启用 Buildx</span></h2><p>buildx 命令属于实验特性，因此首先需要开启该特性。</p><p>上面的查看 Docker 版本返回的内容中，如果出现 <code>Experimental: true</code> 字样就代表已经开启该特性了。下面的这一步骤就可以省略。</p><p>编辑 <code>~/.docker/config.json</code> 文件，新增如下内容（以下的演示适用于事先不存在 .docker 目录的情况下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~&#x2F;.docker</span><br><span class="line">$ cat &gt; ~&#x2F;.docker&#x2F;config.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">&quot;experimental&quot;: &quot;enabled&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>Linux/macOS 下可以通过设置环境变量的方式启用（不推荐）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export DOCKER_CLI_EXPERIMENTAL&#x3D;enabled</span><br></pre></td></tr></table></figure><h2><span id="2-新建-builder-实例">2. 新建 Builder 实例</span></h2><p>在 Docker 19.03+ 版本中可以使用 <code>docker buildx build</code> 命令使用 BuildKit 构建镜像。该命令支持 <code>--platform</code> 参数可以同时构建支持多种系统架构的 Docker 镜像，大大简化了构建步骤。</p><p>由于 Docker 默认的 builder 实例不支持同时指定多个 <code>--platform</code> ，我们必须首先创建一个新的 Builder 实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx create --name mybuilder --driver docker-container</span><br></pre></td></tr></table></figure><p>返回新的 Builder 实例名，为「mybuilder」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybuilder</span><br></pre></td></tr></table></figure><p>使用新创建好的 Builder 实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx use mybuilder</span><br></pre></td></tr></table></figure><p>查看已有的 Builder 实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx ls</span><br><span class="line">NAME&#x2F;NODE    DRIVER&#x2F;ENDPOINT             STATUS   PLATFORMS</span><br><span class="line">mybuilder *  docker-container</span><br><span class="line">  mybuilder0 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock inactive </span><br><span class="line">default      docker</span><br><span class="line">  default    default                     running  linux&#x2F;amd64, linux&#x2F;386</span><br></pre></td></tr></table></figure><p>Docker 在 Linux/AMD64 系统架构下是不支持 ARM 架构镜像，因此我们可以运行一个新的容器（Emulator）让其支持该特性，Docker 桌面版则无需进行此项设置。</p><ul><li>方法一：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --privileged docker&#x2F;binfmt:a7996909642ee92942dcd6cff44b9b95f08dad64</span><br></pre></td></tr></table></figure><blockquote><p>注：docker/binfmt 可以参考网址：<a href="https://hub.docker.com/r/docker/binfmt/tags" target="_blank" rel="noopener">https://hub.docker.com/r/docker/binfmt/tags</a> 获取最新镜像</p></blockquote><ul><li>方法二（推荐）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --privileged tonistiigi&#x2F;binfmt --install all</span><br></pre></td></tr></table></figure><blockquote><p>可参考网址：<a href="https://hub.docker.com/r/tonistiigi/binfmt" target="_blank" rel="noopener">https://hub.docker.com/r/tonistiigi/binfmt</a> 获取最新镜像。目前（2021/04/20 更新）的 <code>Qemu version: 5.0.0</code></p></blockquote><h2><span id="3-新建-dockerfile-文件">3. 新建 Dockerfile 文件</span></h2><p>要想构建多种系统架构的镜像，还需要一个支持的 Dockerfile 文件。</p><p>以下是一个示例的 Dockerfile 文件。</p><blockquote><p>参考链接：<a href="https://github.com/teddysun/across/blob/master/docker/kms/Dockerfile.architecture" target="_blank" rel="noopener">https://github.com/teddysun/across/blob/master/docker/kms/Dockerfile.architecture</a></p></blockquote><p>该 Dockerfile 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM --platform&#x3D;$TARGETPLATFORM alpine:latest AS builder</span><br><span class="line">WORKDIR &#x2F;root</span><br><span class="line">RUN apk add --no-cache git make build-base &amp;&amp; \</span><br><span class="line">    git clone --branch master --single-branch https:&#x2F;&#x2F;github.com&#x2F;Wind4&#x2F;vlmcsd.git &amp;&amp; \</span><br><span class="line">    cd vlmcsd&#x2F; &amp;&amp; \</span><br><span class="line">    make</span><br><span class="line"></span><br><span class="line">FROM --platform&#x3D;$TARGETPLATFORM alpine:latest</span><br><span class="line">LABEL maintainer&#x3D;&quot;Teddysun &lt;i@teddysun.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">COPY --from&#x3D;builder &#x2F;root&#x2F;vlmcsd&#x2F;bin&#x2F;vlmcsd &#x2F;usr&#x2F;bin&#x2F;vlmcsd</span><br><span class="line">EXPOSE 1688</span><br><span class="line">CMD [ &quot;vlmcsd&quot;, &quot;-D&quot;, &quot;-e&quot; ]</span><br></pre></td></tr></table></figure><p><code>$TARGETPLATFORM</code> 是内置变量，由 <code>--platform</code> 参数来指定其值。</p><p>由于是基于 <a href="https://hub.docker.com/_/alpine" target="_blank" rel="noopener">alpine 的镜像</a>来制作的，而 <a href="https://hub.docker.com/_/alpine?tab=tags" target="_blank" rel="noopener">alpine</a> 是支持以下 7 种系统架构的，因此我们制作的镜像也就跟着支持这 7 种系统架构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&#x2F;amd64, linux&#x2F;arm&#x2F;v6, linux&#x2F;arm&#x2F;v7, linux&#x2F;arm64, linux&#x2F;386, linux&#x2F;ppc64le, linux&#x2F;s390x</span><br></pre></td></tr></table></figure><p>更友好一点的架构名称如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amd64, arm32v6, arm32v7, arm64v8, i386, ppc64le, s390x</span><br></pre></td></tr></table></figure><p>这里穿插一句吐槽。简单统计了一下，ARM 的系统架构有如下各种简称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arm64, armv8l, arm64v8, aarch64</span><br><span class="line">arm, arm32, arm32v7, armv7, armv7l, armhf</span><br><span class="line">arm32v6, armv6, armv6l, arm32v5, armv5,  armv5l, armel, aarch32</span><br></pre></td></tr></table></figure><p>看完了是不是很想打人？</p><p>而对比 Intel 和 AMD 的就简单多了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x86, 386, i386, i686</span><br><span class="line">x86_64, x64, amd64</span><br></pre></td></tr></table></figure><h2><span id="4-构建镜像">4. 构建镜像</span></h2><p>先来本地构建一个。</p><p><code>git clone</code> 刚才的示例 Dockerfile 文件，并进入其目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~ &amp;&amp; git clone https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across.git &amp;&amp; cd across&#x2F;docker&#x2F;kms&#x2F;</span><br></pre></td></tr></table></figure><p>在本地构建支持 7 种 Platform 的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx build --platform linux&#x2F;amd64,linux&#x2F;arm&#x2F;v6,linux&#x2F;arm&#x2F;v7,linux&#x2F;arm64,linux&#x2F;ppc64le,linux&#x2F;s390x,linux&#x2F;386 -t teddysun&#x2F;kms -o type&#x3D;local,dest&#x3D;.docker -f .&#x2F;Dockerfile.architecture .</span><br></pre></td></tr></table></figure><p>docker buildx build 的具体参数含义，参考下面的官方文档:</p><blockquote><p><a href="https://docs.docker.com/engine/reference/commandline/buildx_build/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/buildx_build/</a></p></blockquote><p>做完上面的那一步，实际上是把构建好的镜像放在了本地路径下。</p><p>此时我们再来查看一下已有的 builder 实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx ls</span><br><span class="line">NAME&#x2F;NODE    DRIVER&#x2F;ENDPOINT             STATUS  PLATFORMS</span><br><span class="line">mybuilder *  docker-container                    </span><br><span class="line">  mybuilder0 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock running linux&#x2F;amd64, linux&#x2F;arm64, linux&#x2F;riscv64, linux&#x2F;ppc64le, linux&#x2F;s390x, linux&#x2F;386, linux&#x2F;arm&#x2F;v7, linux&#x2F;arm&#x2F;v6</span><br><span class="line">default      docker                              </span><br><span class="line">  default    default                     running linux&#x2F;amd64, linux&#x2F;386</span><br></pre></td></tr></table></figure><p>你会发现 mybuilder 下存在 8 种支持的架构（riscv64 目前还用不上，但是已经支持）。</p><p>此时查看一下 docker image 的运行情况，会发现存在一个名为 <code>buildx_buildkit_mybuilder0</code> 的容器在运行。</p><p>这是刚才在本地构建时，自动创建的，切记不要将其停止，也不要删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -as</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND           CREATED             STATUS              PORTS             NAMES                        SIZE</span><br><span class="line">be753fa16090        moby&#x2F;buildkit:buildx-stable-1   &quot;buildkitd&quot;       15 minutes ago      Up 15 minutes                         buildx_buildkit_mybuilder0   0B (virtual 78.6MB)</span><br></pre></td></tr></table></figure><p>再来构建一个多系统架构镜像，并将构建好的镜像推送到 Docker 仓库（也就是 <a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a>）。</p><p>在此操作之前，你需要事先注册一个账号（演示过程省略），并登录。登录命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure><p>输入你的用户名和密码即可登录。</p><blockquote><p>注意，以下演示的命令中 tag 的前面是我的用户名 <code>teddysun</code>，如果你想制作自己的镜像，请自行替换为你自己的用户名。</p></blockquote><p>使用 <code>--push</code> 参数构建好的镜像推送到 Docker 仓库。</p><p>此时仍然是在刚才的 <code>~/across/docker/kms</code> 目录下，文件 <code>Dockerfile.architecture</code> 是为多系统架构构建准备的。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx build --platform linux&#x2F;386,linux&#x2F;amd64,linux&#x2F;arm&#x2F;v6,linux&#x2F;arm&#x2F;v7,linux&#x2F;arm64,linux&#x2F;ppc64le,linux&#x2F;s390x -t teddysun&#x2F;kms --push -f .&#x2F;Dockerfile.architecture .</span><br></pre></td></tr></table></figure><p>命令执行成功后，你就会在 Docker Hub 看到你上传的镜像啦。示例图如下：</p><p><img src="https://img.hi-linux.com/staticfile/kms_docker_hub-20210429161527270-2021-04-29-vT9VO3.png" alt></p><h2><span id="5-写在最后">5. 写在最后</span></h2><p>在制作多系统架构的 Docker 镜像时，建议使用 CPU 比较强或者多核心的 VPS 来构建，否则会非常耗时。</p><blockquote><p>本文转载自：「秋水逸冰」，原文：<a href="https://teddysun.com/581.html" target="_blank" rel="noopener">https://teddysun.com/581.html</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker Buildx 是一个 Docker CLI 插件，其扩展了 Docker 命令，支持 Moby BuildKit 提供的功能。提供了与 Docker Build 相同的用户体验，并增加了许多新功能。&lt;/p&gt;
&lt;p&gt;BuildKit 是下一代的镜像构建组件，主要特点有很多，本文主要使用其可以编译多种系统架构的特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网址：&lt;a href=&quot;https://github.com/moby/buildkit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/moby/buildkit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的是，该功能仅适用于 Docker v19.03+ 版本。&lt;/p&gt;
&lt;p&gt;本文将讲解如何使用 Buildx 构建多种系统架构的镜像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="教程" scheme="https://www.hi-linux.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>4 种优雅的在 Kubernetes 中调试网络流量的方式</title>
    <link href="https://www.hi-linux.com/posts/22651.html"/>
    <id>https://www.hi-linux.com/posts/22651.html</id>
    <published>2021-06-17T01:00:00.000Z</published>
    <updated>2021-06-17T01:29:36.606Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="前言">前言</span></h2><p>在当今世界, 分布式系统, 微服务/SOA架构遍地, 服务之间的许多交互和通信都不再是同一主机的不同线程或进程, 而是跨主机, 甚至跨网络区域. 那么一旦相关服务出现问题, 我们就会需要调试服务间的通讯, 主机间的网络…</p><p><img src="https://img.hi-linux.com/staticfile/smartscape-complex-environment-572-9c4b25ca16-2021-04-08-u3bMoJ.png" alt="复杂的网络架构"></p><p>Kubernetes 中的应用出了问题, 往往需要进行网络抓包分析. 本文介绍了在 Kubernetes 中网络调试分析的4种方法.</p><ol><li>使用 sidecar</li><li>使用 <a href="https://github.com/nicolaka/netshoot" target="_blank" rel="noopener">netshoot</a> - 一个 Docker + Kubernetes网络故障排除的瑞士军刀容器</li><li>利用Network Namespace</li><li>使用 kubectl 插件 - <code>ksniff</code></li></ol><a id="more"></a><h2><span id="方法一-使用-sidecar">方法一 使用 Sidecar</span></h2><p>在分布式计算、容器和微服务的世界中，服务之间的许多交互和通信都是通过 RESTful Api 完成的。在开发这些 Api 和服务之间的交互时，我经常需要调试服务之间的通信，特别是当事情看起来不像预期的那样工作时。</p><p>在容器出现之前，我只需将服务部署到本地机器上，启动 Wireshark，执行测试，并分析服务之间的HTTP通信。对我来说，这是一种快速分析软件中通信问题的简单而有效的方法。然而，这种调试方法在一个容器化的世界中并不适用。</p><p>首先，容器很可能在您的机器无法直接访问的内部容器平台网络上运行。第二个问题是，按照容器设计最佳实践，容器只包含执行其任务所需的最小应用程序和库集。这意味着像 Tcpdump 这样的工具通常在容器中不可用。这使得调试和分析容器之间的网络通信变得更加困难，从而使得调试微服务间的通信比在非容器环境中更加困难。本文展示了一种解决方案。</p><h3><span id="sidecar-前来救援">Sidecar 前来救援</span></h3><p><img src="https://img.hi-linux.com/staticfile/sidecar-20210408104152197-2021-04-08-aw0bbq.jpg" alt="Sidecar"></p><p>在过去的几个月里，我尝试了各种方法来克服这个问题，最终形成了我将在本文中概述的方法。它是捕获Kubernetes/OpenShift Pods 之间的网络流量数据的简单方法，允许开发人员更好地分析和调试容器化应用程序中的通信问题，并更快、更有效地解决问题。</p><p>我们将使用 Tcpdump 捕获一个所谓的 PCAP(packet capture)文件，该文件将包含 Pod 的网络流量。然后可以将这个 PCAP 文件加载到 Wireshark 之类的工具中来分析流量，在本例中，分析在 Pod 中运行的服务的 RESTful 通信。在本文中，我将使用 Red Hat Process Automation Manager 产品的 KIE 服务器(执行服务器)作为示例，但是这种方法应该适用于任何类型的容器化应用程序。</p><p>要克服的第一个问题是 Kubernetes Pod 中 Tcpdump 命令的可用性。KIE 服务器容器映像没有安装Tcpdump。其次，容器不提供从 Red Hat 存储库安装 Tcpdump 的实用程序。为了克服这个问题，我们使用了 “Sidecar 容器” 的概念。</p><h4><span id="sidecar-概念">Sidecar 概念</span></h4><p>Sidecar 容器是与实际服务/应用程序运行在相同 Pod 中的容器，能够为服务/应用程序提供附加功能。<strong>Sidecar 容器的一个例子是 Istio 的 Envoy sidecar，它使pod成为服务网格的一部分</strong> 。在本例中，我们将部署一个 Sidecar 容器，该容器提供 Tcpdump 实用程序。由于 <strong>pod中的多个容器共享相同的网络层</strong> ，所以我们可以使用 Sidecar 来捕获进出 KIE 服务器的网络流量。</p><h3><span id="部署-sidecar">部署 Sidecar</span></h3><p>在这个例子中，我部署了<a href="https://github.com/jbossdemocentral/rhpam7-mortgage-demo" target="_blank" rel="noopener">Red Hat Process Automation Manager 7 Mortgage Demo</a>，它将在我的 OpenShift namespace 中创建两个 Pod。一个 Pod 运行 Business Central workbench，另一个 Pod 是执行服务器的 Pod。这两个组件之间的通信是通过 REST 完成的，这是我们将要捕获的流量。</p><p><img src="https://img.hi-linux.com/staticfile/Screenshot-2019-02-20-at-09.04.48-20210408103149938-2021-04-08-ZXh8d2.png" alt="OpenShift Namespace Overview"></p><p>我们的目标是捕获 KIE 服务器 Pod 上的网络流量，以便分析 Business Central Workbench 发送给 KIE 服务器的 RESTful 命令。要做到这一点，我们首先需要附加 (attach)一个 Sidecar 到 KIE 服务器的 Pod.</p><ol><li><p>在 Overview 页面中，单击要分析的 Pod 的名称。这将打开 <em>部署配置(Deployment Config, 简称DC)</em> 页面。</p></li><li><p>在 <em>部署配置</em> 屏幕的右上角，单击 Actions -&gt; Edit YAML。这将打开 DC 的 YAML配置。</p></li></ol><p><img src="https://img.hi-linux.com/staticfile/Screenshot-2019-02-20-at-09.08.55-2021-04-08-XCDrsY.png" alt></p><ol start="3"><li>向下滚动，直到看到单词 <code>containers</code>。我们将添加一个额外的容器，安装了 Tcpdump 的Sidecar 到 Pod 中。直接在 <code>containers</code> 定义下添加以下 YAML 片段:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- name: tcpdump</span><br><span class="line">   image: corfr&#x2F;tcpdump</span><br><span class="line">   command:</span><br><span class="line">     - &#x2F;bin&#x2F;sleep</span><br><span class="line">     - infinity</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/Screenshot-2019-02-20-at-09.17.56-2021-04-08-ci10cL.png" alt></p><ol start="4"><li>保存配置。这将部署一个新的 Pod，它现在由两个容器组成: 一个容器包含 KIE 服务器，另一个容器包含我们的 Tcpdump 工具，它将无限期地持续运行。</li></ol><h3><span id="捕获和分析流量">捕获和分析流量</span></h3><p>随着 Sidecar 的部署和运行，我们现在可以开始捕获数据了。我尝试的方法之一是使用 <code>oc rsh</code> 命令远程执行 Sidecar 中的 <code>tcpdump</code> 命令，将网络数据流输出到 FIFO 文件，并将数据直接导入 Wireshark。由于各种原因，这种方法失败了。其中一个问题是，<code>tcpdump</code> 向 <code>stderr</code> 发送信息消息，但是这些消息与 <code>stdout</code> 在相同的流中, 并且是通过 SSH 接收，从而破坏了进入 Wireshark 的数据。</p><p>我最后使用的方法是登录到 Sidecar 容器，并在 Sidecar 中运行 <code>tcpdump</code> 命令来创建 PCAP 文件。当您捕获了足够的数据后，就可以停止捕获过程并将 PCAP 文件复制到您希望使用 Wireshark 进行网络流量分析的机器上。具体步骤如下:</p><ol><li>在您的开发机器上，用 <code>oc</code> 客户端连接到 OpenShift 实例，并激活正确的项目( project, 即namespace)，运行 <code>oc get pods</code> 命令来列出您的 Pods:</li></ol><p><img src="https://img.hi-linux.com/staticfile/Screenshot-2019-02-20-at-09.26.30-2021-04-08-Xyw4s5.png" alt></p><ol start="2"><li><p>使用以下命令登录到我们的 KIE 服务器 Pod 的 tcpdump 容器中: <code>oc rsh -c tcpdump rhpam7-mortgage-kieserver-2-zcpsn</code></p></li><li><p>在 <code>tcpdump</code> 容器中，运行此命令以启动网络流量捕获过程: <code>tcpdump -s 0 -n -w /tmp/kieserver.pcap</code></p></li><li><p>运行要分析的网络流量的测试。在本例中，我将从 Business Central workbench 中启动一个业务流程，它将向 KIE 服务器发送一个 RESTful 请求。</p></li><li><p>捕获足够的数据后，在 <code>tcpdump</code> 容器中使用 <code>Ctrl+C</code> 完成捕获过程。</p></li><li><p>回到本地机器。将 PCAP 文件从 Pod 复制到本地机器: <code>oc cp -c tcpdump rhpam7-mortgage-kieserver-2-zcpsn:tmp/kieserver.pcap kieserver.pcap</code></p></li><li><p>用 Wireshark 打开 PCAP 文件并分析网络流量。在这个例子中，我正在分析我的 HTTP POST 方法，它创建了 Mortgage 进程的一个新实例:</p></li></ol><p><img src="https://img.hi-linux.com/staticfile/Screenshot-2019-02-20-at-09.45.47-2021-04-08-FBOqZz.png" alt="Wireshark 分析"></p><h3><span id="总结">总结</span></h3><p>在容器环境(如 Kubernetes 和/或 OpenShift )中分析 Pod 之间的网络通信可能比在非容器环境中更困难一些。然而，Sidecar 容器的概念为开发人员提供了一种简单的工具，可以将容器连同所需的开发工具和实用程序附加到微服务pod上。<strong>这避免了开发人员必须在应用程序容器映像本身中安装这些调试工具，从而保持容器的轻便和干净。</strong> 使用像 <code>oc rsh</code> 和 <code>oc cp</code> 这样的 OpenShift 工具，我展示了如何轻松地从 Pod 捕获网络流量数据并将数据带到开发机器进行分析。</p><h2><span id="方法二-使用-netshoot">方法二 使用 netshoot</span></h2><p><a href="https://github.com/nicolaka/netshoot" target="_blank" rel="noopener">Netshoot</a> - Docker + Kubernetes网络故障排除的瑞士军刀容器</p><p><img src="https://img.hi-linux.com/staticfile/403141-2021-04-08-17rDoq.jpg" alt="瑞士军刀"></p><h3><span id="用途">用途</span></h3><p>Docker 和 Kubernetes 网络故障排除变得复杂。通过正确理解 Docker 和 Kubernetes 网络的工作方式和正确的工具集，您可以排除故障并解决这些网络问题。netshoot 容器有一组强大的网络troubleshoot 工具，可以用来排除 Docker 网络问题。与这些工具一起出现的还有一组用例，展示了如何在真实场景中使用这个容器。</p><h3><span id="network-namespaces-网络名称空间">Network Namespaces - 网络名称空间</span></h3><p>在开始使用这个工具之前，有一点很重要:网络名称空间。网络名称空间提供与网络相关的系统资源的隔离。Docker使用网络和其他类型的名称空间(<code>pid</code>、<code>mount</code>、<code>user</code>…)为每个容器创建一个隔离的环境。从接口、路由到 ip 的所有内容都完全隔离在容器的网络名称空间中。</p><p>Kubernetes 也使用网络名称空间。<strong>Kubelets为每个pod创建一个网络名称空间，其中该 Pod 中的所有容器共享相同的网络名称空间(eths、IP、tcp套接字……)。这是 Docker 容器和Kubernetes pod之间的关键区别。</strong></p><p>名称空间很酷的一点是您可以在它们之间进行切换。您可以输入不同容器的网络名称空间，使用甚至没有安装在该容器上的工具在其网络堆栈上执行一些故障排除。此外，netshoot 可以通过使用主机的网络名称空间来对主机本身进行故障排除。这允许您在不直接在主机或应用程序包上安装任何新包的情况下执行任何故障排除。</p><h3><span id="针对容器的用法">针对容器的用法</span></h3><ul><li><strong>容器的网络名称空间</strong> :如果您的应用程序的容器存在网络问题，您可以像这样使用容器的网络名称空间启动 netshoot: <code>$ docker run -it --net container:&lt;container_name&gt; nicolaka/netshoot</code></li><li><strong>主机的网络名称空间</strong> :如果您认为网络问题在于主机本身，那么可以使用该主机的网络名称空间启动 netshoot。命令: <code>$ docker run -it --net host nicolaka/netshoot</code></li><li><strong>网络的网络名称空间</strong> :如果要对Docker网络进行故障排除，可以使用 <code>nsenter</code> 输入网络的名称空间。这将在下面的 <code>nsenter</code> 部分进行解释。</li></ul><h3><span id="针对-kubernetes-的用法">针对 Kubernetes 的用法</span></h3><p><strong>Kubernetes</strong>: 如果你想打开一个临时的容器来调试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run --generator&#x3D;run-pod&#x2F;v1 tmp-shell --rm -i --tty --image nicolaka&#x2F;netshoot -- &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>如果您想在主机的网络名称空间上 spin up 一个容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run tmp-shell --generator&#x3D;run-pod&#x2F;v1 --rm -i --tty --overrides&#x3D;&#39;&#123;&quot;spec&quot;: &#123;&quot;hostNetwork&quot;: true&#125;&#125;&#39; --image nicolaka&#x2F;netshoot -- &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><blockquote><p>同样的原理, <code>netshoot</code> 也可以通过 Sidecar 的方式进行使用.</p></blockquote><h3><span id="网络问题">网络问题</span></h3><p>许多网络问题可能导致应用程序性能下降。其中一些问题可能与底层网络基础设施有关。其他问题可能与主机或 Docker 级别的配置错误有关。让我们来看看常见的网络问题</p><ul><li>延迟(latency)</li><li>路由(routing)</li><li>DNS解析(DNS resolution)</li><li>防火墙(firewall)</li><li>不完整的 ARP(incomplete ARPs)</li></ul><p>为了解决这些问题，<code>netshoot</code> 包含了一组强大的工具，如图所示。</p><p><img src="https://img.hi-linux.com/staticfile/netshoot-all-tools-2021-04-08-oPnkeD.png" alt="netshoot 工具集"></p><h3><span id="被包含的包">被包含的包</span></h3><p>以下包被包含在 <code>netshoot</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">apache2-utils</span><br><span class="line">bash</span><br><span class="line">bind-tools</span><br><span class="line">bird</span><br><span class="line">bridge-utils</span><br><span class="line">busybox-extras</span><br><span class="line">calicoctl</span><br><span class="line">conntrack-tools</span><br><span class="line">ctop</span><br><span class="line">curl</span><br><span class="line">dhcping</span><br><span class="line">drill</span><br><span class="line">ethtool</span><br><span class="line">file</span><br><span class="line">fping</span><br><span class="line">iftop</span><br><span class="line">iperf</span><br><span class="line">iproute2</span><br><span class="line">ipset</span><br><span class="line">iptables</span><br><span class="line">iptraf-ng</span><br><span class="line">iputils</span><br><span class="line">ipvsadm</span><br><span class="line">libc6-compat</span><br><span class="line">liboping</span><br><span class="line">mtr</span><br><span class="line">net-snmp-tools</span><br><span class="line">netcat-openbsd</span><br><span class="line">netgen</span><br><span class="line">nftables</span><br><span class="line">ngrep</span><br><span class="line">nmap</span><br><span class="line">nmap-nping</span><br><span class="line">openssl</span><br><span class="line">py-crypto</span><br><span class="line">py2-virtualenv</span><br><span class="line">python2</span><br><span class="line">scapy</span><br><span class="line">socat</span><br><span class="line">strace</span><br><span class="line">tcpdump</span><br><span class="line">tcptraceroute</span><br><span class="line">util-linux</span><br><span class="line">vim</span><br></pre></td></tr></table></figure><h2><span id="方法三-利用network-namespace">方法三 利用Network Namespace</span></h2><p>正如方法二中提到的 Network Namespace 概念, 实际上, 不同的容器, <strong>只是在宿主机上不同 namespace 运行的进程而已</strong> . 因此要在不同的容器抓包可以简单地使用命令切换 Network Namespace 即可，可以使用在宿主机上的 <code>tcpdump</code> 等应用进行抓包。</p><blockquote><p>前提条件: 宿主机上已安装<code>tcpdump</code></p><p>参考链接: <a href="https://ruofeng.me/2018/09/19/capture-packets-in-kubernetes/" target="_blank" rel="noopener">在 k8s 中对指定 Pod 进行抓包</a></p></blockquote><p>具体操作步骤如下:</p><ol><li>查看指定 Pod 运行在哪个宿主机上:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubctl describe pod &lt;pod&gt; -n mservice</span><br></pre></td></tr></table></figure><ol start="2"><li>获得容器的 Pid:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;.State.Pid&#125;&#125; &lt;container&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>进入该容器的 network namespace:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsenter --target &lt;PID&gt; -n</span><br></pre></td></tr></table></figure><ol start="4"><li>使用宿主机的 <code>tcpdump</code> 抓包, 指定 eth0 网卡:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 tcp and port 80 -vvv</span><br></pre></td></tr></table></figure><ol start="5"><li>或者直接抓包并导出到文件:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -w &#x2F;tmp&#x2F;out.cap</span><br></pre></td></tr></table></figure><ol start="6"><li>从远程 <code>scp</code> 到本地:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ipaddr:&#x2F;tmp&#x2F;out.cap .&#x2F;</span><br></pre></td></tr></table></figure><ol start="7"><li>之后在 Wireshark 中可以打开文件非常直观得查看过滤抓到的数据。</li></ol><h2><span id="方法四-使用-kubectl-插件-ksniff">方法四 使用 kubectl 插件 ksniff</span></h2><p>ksniff 项目地址：<a href="https://github.com/eldadru/ksniff" target="_blank" rel="noopener">https://github.com/eldadru/ksniff</a></p><h3><span id="题外话-krew-kubectl-插件包管理器">题外话: krew - kubectl 插件包管理器</span></h3><blockquote><p>前提条件: kubectl v1.12 或更高.</p><p>项目地址：<a href="https://github.com/kubernetes-sigs/krew/" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/krew/</a></p></blockquote><p>Krew 是 kubectl 插件的包管理器。</p><h4><span id="什么是-krew">什么是 <code>krew</code></span></h4><p>krew 是一个使 <a href="https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/" target="_blank" rel="noopener">kubectl插件</a> 易于使用的工具。krew 帮助您发现插件，并在您的机器上安装和管理它们。它类似于 apt、dnf 或 brew 等工具。</p><ul><li><strong>对于 kubectl 用户</strong> : krew 帮助您以一致的方式查找、安装和管理 kubectl插件。</li></ul><p>krew 易于使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl krew search                 # show all plugins</span><br><span class="line">kubectl krew install view-secret    # install a plugin named &quot;view-secret&quot;</span><br><span class="line">kubectl view-secret                 # use the plugin</span><br><span class="line">kubectl krew upgrade                # upgrade installed plugins</span><br><span class="line">kubectl krew uninstall view-secret  # uninstall a plugin</span><br></pre></td></tr></table></figure><p>详细文档请参阅<a href="https://krew.sigs.k8s.io/docs/user-guide/" target="_blank" rel="noopener">用户指南</a>。</p><p>查看在 krew 上<a href="http://sigs.k8s.io/krew-index/plugins.md" target="_blank" rel="noopener">可用的 kubectl 插件列表</a>，或者运行 <code>kubectl krew search</code> 来发现可用的插件。</p><h4><span id="安装-krew">安装 krew</span></h4><p><strong>Bash 和 ZSH</strong>:</p><ol><li>确保 <code>git</code> 已安装;</li><li>运行如下命令, 下载并安装 <code>krew</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">  set -x; cd &quot;$(mktemp -d)&quot; &amp;&amp;</span><br><span class="line">  curl -fsSLO &quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes-sigs&#x2F;krew&#x2F;releases&#x2F;download&#x2F;v0.3.1&#x2F;krew.&#123;tar.gz,yaml&#125;&quot; &amp;&amp;</span><br><span class="line">  tar zxvf krew.tar.gz &amp;&amp;</span><br><span class="line">  .&#x2F;krew-&quot;$(uname | tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;)_amd64&quot; install \</span><br><span class="line">    --manifest&#x3D;krew.yaml --archive&#x3D;krew.tar.gz</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>添加 <code>$HOME/.krew/bin</code> 目录到 <code>PATH</code> 环境变量. 如下: <code>export PATH=&quot;${KREW_ROOT:-$HOME/.krew}/bin:$PATH&quot;</code> 并重启下 Shell 生效.</li></ol><h3><span id="安装-ksniff">安装 ksniff</span></h3><p>通过 <code>krew</code>: <code>kubectl krew install sniff</code></p><h3><span id="使用方法">使用方法</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># kubectl &lt; 1.12:</span><br><span class="line">$ kubectl plugin sniff &lt;POD_NAME&gt; [-n &lt;NAMESPACE_NAME&gt;] [-c &lt;CONTAINER_NAME&gt;] [-i &lt;INTERFACE_NAME&gt;] [-f &lt;CAPTURE_FILTER&gt;] [-o OUTPUT_FILE] [-l LOCAL_TCPDUMP_FILE] [-r REMOTE_TCPDUMP_FILE]</span><br><span class="line"></span><br><span class="line"># kubectl &gt;&#x3D; 1.12:</span><br><span class="line">$ kubectl sniff &lt;POD_NAME&gt; [-n &lt;NAMESPACE_NAME&gt;] [-c &lt;CONTAINER_NAME&gt;] [-i &lt;INTERFACE_NAME&gt;] [-f &lt;CAPTURE_FILTER&gt;] [-o OUTPUT_FILE] [-l LOCAL_TCPDUMP_FILE] [-r REMOTE_TCPDUMP_FILE]</span><br><span class="line"></span><br><span class="line">POD_NAME: Required. the name of the kubernetes pod to start capture it&#39;s traffic.</span><br><span class="line">NAMESPACE_NAME: Optional. Namespace name. used to specify the target namespace to operate on.</span><br><span class="line">CONTAINER_NAME: Optional. If omitted, the first container in the pod will be chosen.</span><br><span class="line">INTERFACE_NAME: Optional. Pod Interface to capture from. If omited, all Pod interfaces will be captured.</span><br><span class="line">CAPTURE_FILTER: Optional. specify a specific tcpdump capture filter. If omitted no filter will be used.</span><br><span class="line">OUTPUT_FILE: Optional. if specified, ksniff will redirect tcpdump output to local file instead of wireshark.</span><br><span class="line">LOCAL_TCPDUMP_FILE: Optional. if specified, ksniff will use this path as the local path of the static tcpdump binary.</span><br><span class="line">REMOTE_TCPDUMP_FILE: Optional. if specified, ksniff will use the specified path as the remote path to upload static tcpdump to.</span><br></pre></td></tr></table></figure><p>举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl sniff mypod -n myproject -o &#x2F;tmp&#x2F;mypod.pcap</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>为了在容器或 K8S 中进行网络调试和分析, 本文列举了 4 种方法, 现在进行总结归纳:</p><ol><li><p>使用 Sidecar - Sidecar 容器所在的 <strong>Pod 中的多个容器共享相同的网络层</strong>, 且Sidecar 容器可以包含 <code>tcpdump</code> 等工具;</p></li><li><p>利用 Network Namespace - 不同的容器, <strong>只是在宿主机上不同 namespace 运行的进程而已</strong>. 容器的网络也是如此.</p></li><li><p>使用 <code>netshoot</code> - <code>netshoot</code> 其实是包含一系列的常用网络分析调试工具集的容器, 真正的使用方法其实还是以上 2 种:</p><ol><li>通过 sidecar 挂载</li><li>利用 Network Namespace 分析调试</li></ol></li><li><p>使用 kubectl 插件 - <code>ksniff</code>.</p></li></ol><p>以上这些方法, 有不同的前提条件和使用场景, 希望本文读完会让你的 K8S 调试技能有所提升.</p><blockquote><p>本文转载自：「 个人技术分享 」，原文：<a href="http://t.cn/AimWk1Wl%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">http://t.cn/AimWk1Wl，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在当今世界, 分布式系统, 微服务/SOA架构遍地, 服务之间的许多交互和通信都不再是同一主机的不同线程或进程, 而是跨主机, 甚至跨网络区域. 那么一旦相关服务出现问题, 我们就会需要调试服务间的通讯, 主机间的网络…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/smartscape-complex-environment-572-9c4b25ca16-2021-04-08-u3bMoJ.png&quot; alt=&quot;复杂的网络架构&quot;&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 中的应用出了问题, 往往需要进行网络抓包分析. 本文介绍了在 Kubernetes 中网络调试分析的4种方法.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 sidecar&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://github.com/nicolaka/netshoot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;netshoot&lt;/a&gt; - 一个 Docker + Kubernetes网络故障排除的瑞士军刀容器&lt;/li&gt;
&lt;li&gt;利用Network Namespace&lt;/li&gt;
&lt;li&gt;使用 kubectl 插件 - &lt;code&gt;ksniff&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>弹指一挥间，揭秘诞生 30 周年 Linux 成功的真正原因</title>
    <link href="https://www.hi-linux.com/posts/43403.html"/>
    <id>https://www.hi-linux.com/posts/43403.html</id>
    <published>2021-06-11T01:00:00.000Z</published>
    <updated>2021-06-11T03:46:46.656Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><ul><li>作者丨 Jeremy Andrews</li><li>译者丨屠灵</li><li>策划丨蔡芳芳</li></ul><blockquote><p>Linux 诞生于 1991 年，距今已经 30 年了。虽然它一开始只是 Linus 的一个个人项目，而非出于要开发一个新操作系统的伟大梦想，但如今的 Linux 早已无处不在。</p></blockquote><p>30 年前，当 Linus Torvalds 第一次发布 Linux 内核时，他还是赫尔辛基大学的一名 21 岁的学生。他宣布说：“我正在开发一个（免费的）操作系统（这只是个爱好，不会做得很大，也不会很专业……）”。30 年后，500 强超级计算机和 70% 以上的智能手机都在运行 Linux。很显然，Linux 不仅大，而且很专业。</p><p>30 年来，Linus Torvalds 一直在领导着 Linux 内核的开发，启发了无数开发者和开源项目。2005 年，Linus 开发了 Git，用来管理内核开发过程。Git 现在已经成为最流行的版本控制系统，受到无数开源和私有项目的信任。</p><p>正值 Linux 诞生 30 周年之际，Linus Torvalds 通过电子邮件回复了 Tag 1 咨询公司的创始合伙人 / 首席执行官 Jeremy Andrews 的访谈问题（《An Interview With Linus Torvalds: Linux and Git - Part 1》），回顾并总结了过去这些年他在领导大型开源项目过程中得到的真知灼见。本文着重介绍 Linux 内核开发和 Git。InfoQ 对访谈内容进行了翻译，以飨读者。</p><a id="more"></a><h2><span id="linux-内核开发">Linux 内核开发</span></h2><h3><span id="linux-发展的关键我不认识的人都在使用-linux">Linux 发展的关键：“我不认识的人都在使用 Linux”</span></h3><p><strong>Jeremy Andrews：Linux 无处不在，它是整个开源世界的灵感源泉。当然，事情并不是从一开始就这样的。1991 年，你在 comp.os.minix Usenet 新闻组中发布了一个 Linux 内核。十年后，你写了一本书，叫作“Just for Fun: The Story of an Accidental Revolutionary”（中译名：《只是为了好玩：Linux 之父林纳斯自传》），对那段历史进行了深度回顾。今年 8 月，Linux 将迎来它的 30 周年纪念日！在这个过程中，你是在什么时候开始意识到 Linux 并不仅仅是一个“爱好”的？</strong></p><p><strong>Linus Torvalds</strong>：这听起来可能有点荒谬，实际上我很早就开始意识到了。在 1991 年末（以及 1992 年初），Linux 已经比我预想的要大得多。</p><p>那时候可能只有几百个用户（确切地说不是“用户”，因为人们还要不断地对它进行修修补补），从没想过 Linux 后来能够发展壮大。在我看来，<strong>最大的转折点是当我意识到其他人正在使用它，并对它感兴趣，它开始有了自己的生命</strong>。人们开始发送补丁，这个系统能做的事情比我最初预想的要多得多。</p><p>1992 年 4 月的某个时候，X11 被移植到 Linux 上（其实我也记不太清具体时间了，毕竟那是很久以前的事了），这是一个重大进步，Linux 系统突然间有了 GUI 和一系列全新的功能。</p><p>我一开始并没有什么大计划。这只是一个个人项目，并不是出于要开发一个新操作系统的伟大梦想。我当时只是想了解我的新 PC 硬件的来龙去脉。</p><p>所以，在发布第一个版本时，实际上更多的是想“看看自己都做了些什么”。当然，我希望其他人会觉得它有趣，但它并不是一个真正可用的操作系统。它更多的是一种概念验证，而且只是一个我在当时做了几个月的个人项目。</p><p>从“个人项目”到其他人开始使用它、给我反馈（和 bug 报告）和发送补丁，对我来说是一个巨大的转变。</p><p>举个最基本的例子：最初的版权许可是“你可以以源代码的形式发布它，但不能用它赚钱”。</p><p>对于当时的我来说，商业版 Unix 太贵了（作为穷学生，我已经为了买新 PC 花光了所有钱），所以我希望这个操作系统的源代码是公开可用的（这样人们就可以提供补丁），<strong>我希望将它开放给像我这样负担不起昂贵电脑和操作系统的人</strong>。</p><p>1991 年末（或是 1992 年初），我把许可改为 GPLv2，因为有人想把它以软盘的形式分发给本地 Unix 用户组，但又想收回软盘的成本，并补偿他们拷贝软盘所花费的时间。我觉得这很合理，因为“免费”与否并不是最重要的，最重要的是要“公开源码”。</p><p>最终的结果是：人们不仅在 Unix 用户组中发布它，在几个月之内还出现了 SLS 和 Slackware 的软盘发行版。</p><p>与最初的那些根本性的变化相比，后来的一切都是“增量式”的。当然，有些增量式的变化也是大跨步（IBM 的加入、Oracle 数据库的移植、Red Hat 的首次公开募股，Android 在手机上的应用，等等），但在我看来，它们仍然不如最初的“我不认识的人都在使用 Linux”那样具有革命性。</p><h3><span id="linux-成功的重要原因修改开源许可协议采用-gplv2">Linux 成功的重要原因：修改开源许可协议，采用 GPLv2</span></h3><p>Jeremy Andrews：你是否曾经后悔修改了许可协议？或者说，其他人或公司用你开发的系统赚了很多钱，你因此感到后悔吗？</p><p><strong>Linus Torvalds</strong>：我从来没有后悔过。</p><p>首先，我过得还不错。我不是特别富有，但我是一个薪水很高的软件工程师，可以按照自己的节奏做我喜欢做的事情。</p><p>关键是我百分之百认为这个许可是 Linux（以及 Git）取得成功的重要原因。我认为，当所有人都认为他们有平等的权利，没有人在这方面有特权的时候，他们才会变得更快乐。</p><p>有很多项目采用了“双重许可”，一方面，原作者保留了商业许可（“只要你支付了许可费用，就可以使用它”），另一方面，项目也可以在 GPL 许可下开源。</p><p>我认为要在这种情况下建立好的社区是非常困难的，因为开源那一方知道自己是“二等公民”。另外，为了让享有特权的那一方一直享有特殊的权利，需要做很多许可文书工作，这给项目带来了额外的阻力。</p><p>另一方面，我见过很多基于 BSD（或 MIT 等类似的许可）许可的开源项目，当它们变得足够强大，大到具备商业价值时，它们就开始分裂，相关的公司不可避免地会将自己的那部分变成专有的。</p><p>我认为 <strong>GPLv2 能够在“每个人都处于相同的规则之下”和“要求人们回馈社区”之间取得完美的平衡</strong>。每个人都知道，所有参与者都受到相同的规则的约束，所以这是非常公平的。</p><p>当然，你的投入总会得到回报。如果你只是想轻度参与项目，或者只是想作为一名用户，那也是可以的。如果你真的只是这样，就也无法控制这个项目。如果你真的只需要一个基本的操作系统，而 Linux 已经具备你想要的所有功能，那也完全没有问题。但如果你有特殊的需求，想要为这个项目做一点事情，那么唯一的方法就是参与其中。</p><p>这让每个人都秉持诚实的态度，包括我在内。任何人都可以 fork 这个项目，用他们自己的方式，然后说“再见了，Linus，我要维护自己的 Linux 版本”。我之所以“特别”，仅仅是因为人们相信我能把工作做好。</p><p>“任何人都可以维护自己的 Linux 版本”，这让一些人对 GPLv2 产生了怀疑，但我认为这是一种优势，而不是劣势。我认为，这实际上是避免 Linux 出现分裂的原因：每个人都可以创建自己的项目分支。事实上，这也是“Git”的核心设计原则之一——代码库的每一个克隆都是一个分支，人们（和公司）再 fork 出自己的版本，完成开发工作。</p><p>所以，分支不是问题，只要你能把好的部分合并回来。这就是 GPLv2 发挥作用的地方。能够拉取分支，并按照自己的方式修改代码，拥有这些权利很重要，但另一方面也同样重要——当一个分支被证明取得了成功，有权利把它合并回去。</p><p>另一个问题是，除了要有支持这种工作流的工具，也要有可以支持它的心态。合并分支的一大障碍不仅是许可问题，还有“嫌隙”问题。如果分支是源于对立，那么要合并两个分支就非常困难——不是因为许可或技术方面的原因，而是因为分支之间太过对立。我认为 Linux 避免了这种情况的发生，主要是因为我们一直认为分支是一件很自然的事情。而且，当一些开发工作被证明取得了成功，尝试将其合并回来也是很自然的。</p><p>虽然这个答案有点偏离正题，但我认为它很重要——我不后悔修改了许可，因为我真的认为 GPLv2 是 Linux 取得成功的一个重要原因。</p><p>金钱不是一种很好的激励方式，它无法让人们团结在一起。我认为，参与一个共同的项目，并感觉到自己可以成为这个项目的合作伙伴，这样才能激励人们。</p><p><strong>Jeremy Andrews：现在，人们基于 GPLv2 发布源代码通常是因为 Linux。你当时是怎么找到这个许可的？你在调研其他许可方面又投入了多少时间和精力呢？</strong></p><p><strong>Linus Torvalds</strong>：那个时候，有关 BSD 和 GPL 的争论非常激烈。我在阅读各种新闻组（比如 comp.arch、comp.os.minix 等）时看到了一些有关许可的讨论。</p><p>其中两个最主要的原因可能是 gcc 和 Lars Wirzenius。gcc 对 Linux 的发展起到了很大作用，因为我肯定需要一个 C 语言编译器。Lars Wirzenius 是我在念大学时另一个说瑞典语（瑞典语在芬兰是小语种）的计算机系学生。</p><p>Lasu 比我更喜欢讨论与许可相关的事情。</p><p>在我看来，选择 GPLv2 并不算是什么重大的政治问题，主要是因为我最初在选择许可时太过仓促，后来需要做出修改。况且，我很感恩有 gcc，并且 GPLv2 更符合我对“你必须把源代码合并回来”这种想法的期望。</p><p>因此，与其另起炉灶新建一个许可，不如选择一个人们已经知道并且有一些律师参与其中的许可。</p><h3><span id="linux-之父的一天">Linux 之父的一天</span></h3><p><strong>Jeremy Andrews：通常情况下，你的一天是怎么过的？其中有多少时间花在写代码上，多少花在评审代码上，多少花在电子邮件上？你如何平衡个人生活和 Linux 内核开发工作？</strong></p><p><strong>Linus Torvalds</strong>：我现在写的代码很少，而且已经很久没写了。再要写代码，通常是因为人们对某些特定的问题存在争议。我修改代码，并将其作为补丁发布出去，作为对解决方案的解释说明。</p><p>换句话说，我写的大部分代码更多的是作为解决方案的示例，而补丁是一种非常具体的例子。人们很容易陷入理论讨论的陷阱，而我发现描述解决方案最好的方式是写代码片段，不一定要完整的程序，只要让解决方案具体化一些即可。</p><p>我的工作时间都花在电子邮件上了。主要是沟通，而不是写代码。事实上，我认为这种与记者和技术博主之间的交流就是我工作的一部分——它可能比技术讨论优先级低一些，但我也花了相当多的时间在这类事情上。</p><p>当然，我也会花一些时间在代码评审上。但老实说，当我收到一个 PR 时，有问题的代码通常已经被其他人评审过了。所以，虽然我仍然会看一下补丁，但实际上会更多地去关注注解，以及补丁的演化过程。但对于那些与我共事很久的人，我不会这么做：他们是自己子系统的维护者，我不需要对他们的工作指手画脚。</p><p>所以，很多时候，我的主要工作就是“待在那里”，执行管理和发布任务。换句话说，我的工作通常更多地是关于维护过程，而不是底层代码。</p><h3><span id="linux-之父的工作环境">Linux 之父的工作环境</span></h3><p>Jeremy Andrews：你的工作环境是怎样的？比如，你是喜欢黑暗、不会受人打扰的房间，还是喜欢能看到风景的房间？你喜欢在安静的环境下工作，还是喜欢一边听音乐一边工作？你通常使用哪种硬件？你是在终端上使用 vi 来评审代码，还是使用某种奇特的 IDE？你是否有偏爱的 Linux 发行版作为开发环境？</p><p><strong>Linus Torvalds</strong>：我的房间并不“暗”，但我确实把桌子旁边窗户上的百叶窗关上了，因为我不想要强烈的阳光。所以，我的房间没有什么风景视野，<strong>只有一张（凌乱的）桌子，配了两个 4k 显示器，桌子下面有一台强劲的电脑主机</strong>。还有几台笔记本电脑供我测试和在路上用。</p><p>我喜欢安静地工作。我很讨厌机械硬盘的滴答声，所以我把它们扔进了垃圾桶，现在只使用 SSD。这样已经 10 多年了。嘈杂的 CPU 风扇声也是不可接受的。</p><p>代码评审都是在传统的终端上完成的，不过我没有使用 vi。我使用的是“<strong>micro-emacs</strong>”这个令人讨厌的东西。它与 GNU emacs 完全没有关系，只是有些键绑定与它相似。我在赫尔辛基大学时就习惯用它了，到现在还没改掉这个习惯。几年前，我给它增加了（非常有限的）utf-8 支持，但它确实很老旧了，所有的迹象都表明它是在 80 年代开发的，我使用的版本是一个自 90 年代中期以来就没有更新过的分支。</p><p>赫尔辛基大学选择了这个工具，因为它可以在 DOS、VAX/VMS 和 Unix 上运行，这也是为什么我也会用它。到现在，我的手指已经对它形成肌肉记忆了。我真的需要换个有人维护并支持 utf-8 的工具，只是我增强的那部分功能用起来还好，所以一直没有强迫我的手指去接受新的工具。</p><p>我的工作桌面相当简单：几个文本终端，一个打开了电子邮箱的浏览器（还打开了其他几个标签，主要是新闻和科技网站）。我喜欢大的桌面空间，因为我习惯使用大终端窗口（100x40 是我的默认初始大小），并且并排打开好几个。我使用了两个 4k 显示器。</p><p>我在所有的机器上都安装了 Fedora 发行版，并不是因为我偏爱它，而是因为我习惯了。我并不太关心使用哪个发行版——对于我来说，选择发行版只是在机器上安装 Linux 和开发工具的一种方式。</p><h3><span id="如何处理大量电子邮件">如何处理大量电子邮件？</span></h3><p><strong>Jeremy Andrews：Linux 内核邮件组（<a href="https://lore.kernel.org/lkml/%EF%BC%89" target="_blank" rel="noopener">https://lore.kernel.org/lkml/）</a> 是人们公开交流内核开发的地方，流量非常高。你是怎么处理这么多电子邮件的？你尝试过邮件组之外的其他协作和沟通解决方案吗？或者说，这种简单的邮件组对你的工作来说足够好吗？</strong></p><p><strong>Linus Torvalds</strong>：我没有直接阅读内核邮件组里的邮件，而且好几年都没有。邮件太多了。</p><p>内核邮件组里的邮件会被抄送到所有的讨论当中。当新人加入讨论时，他们可以通过查看内核邮件组来了解相关的历史和背景。</p><p>过去我会订阅邮件组，让所有没有抄送给我的电子邮件自动归档，默认不看它们。当一些问题需要我介入时，我可以找到所有相关的讨论，因为它们都在我的电子邮件里，只是在需要时才会出现在我的收件箱里。</p><p>现在，我使用的是 <a href="http://lore.kernel.org" target="_blank" rel="noopener">lore.kernel.org</a> 提供的功能，因为它很好用，而且我们还基于它开发了一些工具。这样就不需要让邮件自动归档了，我们换了一种讨论方式，但基本的工作流程是一样的。</p><p>但很显然，我仍然会收到很多邮件——但从很多方面来看，这些年来情况变得越来越好，而不是越来越糟。其中很大一部分原因是 Git 和内核发布流程的改进：我们过去在代码流程和工具方面存在很多问题。在本世纪初是最为糟糕的，当时我们仍然在处理巨大的补丁炸弹，我们的开发流程存在严重的可伸缩性问题。</p><p>邮件组模式确实运作得很好，但并不是说人们就不使用除电子邮件之外的其他沟通方式了：有些人喜欢各种实时聊天工具（比如传统的 IRC）。虽然我不是很喜欢这样，但很显然有些人喜欢用它们来进行头脑风暴。但这种“邮件组存档”模式运作得非常好，并且能够无缝地与“开发者之间以邮件的形式发送补丁”和“以邮件的形式发送问题报告”相结合。</p><p>所以电子邮件仍然是主要的沟通渠道，并且因为邮件中可以包含补丁，我们可以更容易地讨论技术问题。而且邮件可以跨越时区，当参与者分布在不同地区时，这一点非常重要。</p><h3><span id="linux-30-以来内核开发的有趣事情">Linux 3.0 以来，内核开发的有趣事情</span></h3><p><strong>Jeremy Andrews：我密切关注内核开发大约有 10 年了，并在 KernelTrap 上写与内核有关的博文，大概是在 3.0 内核发布时停止更新博客。3.0 内核的发布与 2.6.x 内核的发布相隔了 8 年。请总结一下自 3.0 版本以来内核开发中发生的一些有趣的事情。</strong></p><p><strong>Linus Torvalds</strong>：那是很久以前的事了，我不知道该从哪里开始总结。从 3.0 版本到现在已经 10 年了，在这 10 年中发生了很多技术上的变化。ARM 已经发展成熟，ARM64 已经成为我们的主要架构之一，并出现了大量新的驱动程序和核心功能。</p><p>如果说过去 10 年有什么有趣的事情，那一定是我们努力保持开发模式的稳定，以及那些没有发生改变的东西。</p><p>在过去的几十年里，我们经历了多种不同的版本号方案和不同的开发模式，3.0 版本最终确定了后来一直使用的模式。它让“基于时间发布，版本号只是数字，与特性无关”这一说法落地了。</p><p>在 2.6.x 版本中，我们就有了基于时间的发布模式，所以它并不是什么新东西，但 3.0 版本确实是让这种模式板上钉钉的至关重要的一步。</p><p>我们以前使用随机编号方案（主要是在 1.0 版本之前），然后用“奇数表示开发版内核，偶数表示稳定的生产就绪版内核”，然后在 2.6.x 版本中，我们开始进入基于时间的发布模式。但人们仍然对“什么时候需要增加主版本号”存在疑问。3.0 版本正式发布后，宣告了主版本号没有任何意义，我们尽量简化数字，不要让它们变得太大。</p><p>因此，在过去的 10 年里，我们做了巨大的改变（有了 Git，就可以很容易地得到一些数字统计数据：超过 1.7 万人提交了大约 75 万次代码），但开发模式仍然相当稳定。</p><p>但并非一直都是这样的，内核开发的前 20 年经历了相当痛苦的开发模式变更，只是在过去 10 年中，发布可预测性才得到大幅提升。</p><h3><span id="linux-发布流程">Linux 发布流程</span></h3><p><strong>Jeremy Andrews：目前，最新的版本是 5.12-rc5。现在的发布流程标准是怎样的？例如，-rc1 和 -rc2 有什么不同？你会在什么情况下决定正式发布其中一个给定的版本？如果在正式发布之后出现了大量的回归会怎样？这种情况发生的频率是怎样的？这些年来，这个过程是如何演变的？</strong></p><p><strong>Linus Torvalds</strong>：我之前提到过，这个过程本身是很标准的，并且在过去十年里一直如此。在此之前，它经历了几次演变，但实际上从 3.0 开始它就像时钟一样走得很稳定。</p><p>到现在为止，我们的发布节奏是这样的：先是两周的合并时间窗口，然后是大约 6 到 8 周的候选版本，然后是最终版本。这样子差不多 15 年了。</p><p>规则一直都是一样的，尽管它们并不总是被完全严格执行：合并时间窗口是针对那些被认为已经“经过测试和准备就绪”的新代码，然后在接下来的大约两个月里进行修复，以确保所有的问题都得到解决。有时候，那些所谓的“就绪”代码会在发布之前会被禁用或完全推翻。</p><p>这个过程会重复，所以我们大约每 10 周发布一次。</p><p>达到可以发布的标准是我对候选版本有足够的信心，而这是以各种问题报告为基础的。如果某些方面在 rc 后期仍然会出问题，我就极力推翻这些内容，并建议将其放在后续的版本中。但总体而言，很少会出现这种情况。</p><p>这样就完全没有问题了吗？不是的。一旦内核发布了，就会有新用户，他们会发现一些在 rc 版本中没有被发现的问题。这几乎是不可避免的。这也是为什么我们需要“稳定内核”树。在发布之后，我们可以继续修复代码。一些稳定内核比其他版本内核维护的时间更长，被称为 LTS（“Long Term Support”）版本。</p><p>所有这些在过去十年里都没有什么变化，尽管后来有了更多的自动化流程。一般来说，内核测试自动化是很困难的——因为很多内核是驱动程序，十分依赖硬件的可用性。不过，我们有几个测试场同时进行引导和性能测试，以及各种随机负载测试。这些在这几年有了很大的改善。</p><h3><span id="一直等待可用的-arm-机器">一直等待可用的 ARM 机器</span></h3><p><strong>Jeremy Andrews：去年 11 月，有人说你对苹果公司在部分新款电脑中使用的 ARM64 芯片十分感兴趣。Linux 会支持它们吗？我看到一些代码被合并到 for-next。即将到来的 5.13 内核有可能在苹果 MacBook 上启动吗？你有可能是它的早期采用者吗？ARM64 有什么重大的意义？</strong></p><p><strong>Linus Torvalds</strong>：我偶尔会跟进一下，但现在说这些还为时过早。正如你所说的，早期支持可能会被合并到 5.13 中，但这只是一个开始，并不能说明 Linux 和苹果电脑将来会怎样。</p><p>主要问题不是 arm64 架构，而是与之相关的所有硬件驱动程序（特别是 SSD 和 GPU）。到目前为止，一些底层的东西得到了支持，但除了可以启用硬件之外，没有任何有用的结果。要想达到可以被人们使用的程度，还需要一些时间。</p><p>不仅仅是苹果的硬件得到了改进——arm64 架构总体上也已经成长了很多，内核在服务器领域也更具竞争力了。不久前，arm64 在服务器领域的竞争力还很弱，但亚马逊的 Graviton2 和安培的 Altra 处理器——都是基于改进后的 ARM Neoverse IP——比几年前的产品要好很多。</p><p>我已经等了十多年都没能等到一个可用的 ARM 机器，可能还要继续等下去，但情况明显比以前好了一些。</p><p>事实上，我很早之前就想要一台 ARM 机器。当我还是个少年，我真正想要的是一台 Acorn Archimedes，但可用性和价格让我最终选择了 Sinclair QL（M68008 处理器），然后几年后换成了 i386。</p><p>所以，这个想法已经酝酿了几十年。但到现在它们还没有被广泛使用，而且对于我来说，它们在价格和性能方面都不具竞争力。希望在不久的将来，这个想法能够变成现实。</p><h3><span id="重写内核会做出的改变">重写内核会做出的改变</span></h3><p><strong>Jeremy Andrews：内核中有什么东西需要进行完全的重写才能达到最优的吗？或者说，内核已经有 30 年的历史了，知识、编程语言和硬件在这 30 年里发生了很大的变化：如果现在让你从头开始重写，你会做出哪些改变？</strong></p><p><strong>Linus Torvalds</strong>：如果有必要的话我们会这么做的。我们真的很擅长重写，那些本来会造成灾难的东西很久以前就被我们重写了。</p><p>我们有很多“兼容”层，不过它们一般不会造成太大问题。如果从头开始重写，这些兼容层是否要去掉，我们还不清楚——它们存在的目的是为了与旧二进制文件向后兼容（通常是与旧架构向后兼容，例如在 x86-64 上运行 32 位的 x86 应用程序）。因为我认为向后兼容是非常重要的，所以即使重写，我也希望保留这些兼容层。</p><p>所以很明显，有很多东西并不是最优的，毕竟任何东西都有改进的空间。但就你提的这个问题，我不得不说，我不鄙视任何东西。有一些遗留驱动程序，可能没有人关心，也没有人去清理，会做一些丑陋的事情，但这主要是因为“没有人关心”。这些在过去不是问题，而一旦成为问题，我们就会积极把这些没人关心的东西移除掉。多年来，我们已经移除了很多驱动程序，当维护不再有任何意义时，我们会放弃整个架构支持。</p><p>“重写”的主要原因是：整个架构不再有意义，但仍然存在一些应用场景。最有可能的情况是，一些小型嵌入式系统并不需要 Linux 提供的所有东西，它们的硬件很小，需要的是更简单、更少的系统功能。</p><p>Linux 已经有了长足的发展。现在，即使是小硬件（比如手机等）也比当初开发 Linux 所使用的机器强大得多。</p><h3><span id="不会用-rust-取代-c-语言来开发内核">不会用 Rust 取代 C 语言来开发内核</span></h3><p><strong>Jeremy Andrews：如果用 Rust 来重写一部分系统会怎样？在这方面还有改进的余地吗？在内核开发方面，你觉得是否有可能用另一种语言（比如 Rust）来取代 C 语言？</strong></p><p><strong>Linus Torvalds</strong>：我不认为我们会用 Rust 取代 C 语言来开发内核，但可能会用来开发一些驱动程序，也许是整个驱动子系统，也许是文件系统。所以不是“取代 C 语言”，而是“在一些有意义的地方扩展我们的 C 代码”。</p><p>当然，驱动程序几乎占了内核的一半代码，有非常大的重写空间，但我不认为所有人都会很期待使用 Rust 全盘重写现有的驱动程序。可能“有些人会用 Rust 开发新驱动程序，或者适当地重写一部分旧驱动程序”。</p><p>现在更多的是“人们在尝试和体验”Rust，仅此而已。Rust 优势的背后肯定存在复杂性，所以我会采取观望的态度，看看这些优势是否真的奏效。</p><h3><span id="内核中最令-linux-之父自豪的部分">内核中最令 Linux 之父自豪的部分</span></h3><p><strong>Jeremy Andrews：内核中是否有你个人感到最自豪的部分？</strong></p><p><strong>Linus Torvalds</strong>：我最想说的是 VFS 层（虚拟文件系统，特别是路径名查找）和 VM。前者是因为 Linux 在做一些基础任务（在操作系统中查找文件名确实是一个核心的操作）时比其他系统都要好得多，后者主要是因为我们支持 20 多种架构，但仍然在使用一个基本统一的 VM 层，我认为这一点很了不起。</p><p>但与此同时，这很大程度上取决于“你最关注内核的哪一部分”。内核很大，不同的开发者（和不同的用户）会关注不同的方面。有些人认为调度是内核中最令人感到兴奋的部分，有些人则关注设备驱动程序的细节（我们有很多这样的驱动程序）。我个人在 VM 和 VFS 这两个方面参与得更多，所以自然会提到它们。</p><h3><span id="linux-在这个方面比其他操作系统做得更好">Linux 在这个方面比其他操作系统做得更好</span></h3><p><strong>Jeremy Andrews：我看了这个关于路径名查找的描述（<a href="https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html%EF%BC%89%EF%BC%8C%E5%AE%83%E6%AF%94%E6%88%91%E9%A2%84%E6%83%B3%E7%9A%84%E8%A6%81%E5%A4%8D%E6%9D%82%E3%80%82%E6%98%AF%E4%BB%80%E4%B9%88%E8%AE%A9" target="_blank" rel="noopener">https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html），它比我预想的要复杂。是什么让</a> Linux 在这方面比其他操作系统做得更好？你说的“更好”是什么意思？</strong></p><p><strong>Linus Torvalds</strong>：路径名查找是一个非常常见和基础的任务，以至于大多数非内核开发者不认为它会是一个问题：他们只知道打开文件，并认为这是理所当然的。</p><p>但要做好其实是相当复杂的。确切地说，因为几乎所有地方都在用路径名查找，所以对性能要求很高，而且大家都希望它在 SMP 环境中具有良好的伸缩性，而在锁定方面又很复杂。你不想发生 IO，那么缓存就非常重要。路径名查找是如此的重要，以至于你不能把它留给底层的文件系统，因为我们有 20 多种不同的文件系统，让它们各自拥有自己的缓存和锁定机制将是一场彻头彻尾的灾难。</p><p>所以，VFS 层的一个主要任务是处理所有路径名组件的锁定和缓存问题，以及所有的序列化和挂载点遍历问题，这些都是通过无锁算法（RCU）来完成的，但也会有一些非常智能的锁（Linux 内核的“lockref”锁是一种非常特殊的“带有引用计数的自旋锁”，表面上看是为 dcache 缓存而设计的，但本质上是一个专门的锁感知引用计数，可以在某些常见情况下消除锁）。</p><p>最终结果是：底层文件系统仍然需要对未缓存的内容进行查找，但它们不需要关心缓存和一致性规则以及与路径名查找相关的原子性规则。VFS 会为它们处理好所有这些问题。</p><p>而且它的性能比任何其他操作系统都要好，基本上可以在拥有数千个 CPU 的机器上完美运行。</p><p>所以不仅仅是“更好”，而是“大写”的更好。没有什么能与之相提并论的了。Linux dcache 是独一无二的。</p><h3><span id="新冠疫情对内核开发的影响">新冠疫情对内核开发的影响</span></h3><p><strong>Jeremy Andrews：过去的一年对全世界来说是艰难的一年。新冠疫情对内核开发进程带来了哪些影响？</strong></p><p><strong>Linus Torvalds</strong>：实际上，得益于我们一直以来的工作方式，它的影响非常小。电子邮件真的是一个很好的工具，我们并不依赖面对面的会议。</p><p>是的，它确实影响了去年的年度内核峰会（今年的峰会仍悬而未决），大多数会议被取消或转为线上进行。以前在办公室工作的人大都开始在家里工作（但很多核心内核维护者在之前已经这么做了）。所以，周围的很多东西都发生了改变，但内核开发还是像以前一样。</p><p>很显然，新冠疫情在其他方面影响了我们所有人的生活，但总的来说，作为几乎完全通过电子邮件进行交流的内核开发人员，我们可能是受影响最小的。</p><h2><span id="版本控制系统-git">版本控制系统 Git</span></h2><h3><span id="对-git-项目领导权主动放手">对 Git 项目领导权主动放手</span></h3><p><strong>Jeremy Andrews：Linux 只是你对开源做出的众多贡献中的一个。在 2005 年，你还创建了 Git，一个非常流行的分布式源代码控制系统。你快速地将 Linux 内核源代码树从专有的 Bitkeeper 迁移到开源的 Git 系统中，并在同年将维护工作移交给了 Junio Hamano。这里有很多有趣的故事，是什么原因促使你这么快就将项目的领导权移交了出来，你是如何找到并选择了 Junio 的？</strong></p><p><strong>Linus Torvalds</strong>：答案可以分为两个部分。</p><p>首先，我并不想创建一个新的源代码控制系统。开发 Linux 是因为硬件和软件之间的底层接口很吸引我——基本上是出于个人的热爱和兴趣。相反，开发 Git 是因为确实有这个需要：不是因为我觉得源代码控制很有趣，而是因为我十分鄙视市面上的大多数源代码控制系统。而我觉得最合适的、在 Linux 开发当中很好用的 BitKeeper 已经无法维持下去了。</p><p>我开发 Linux 已经超过 30 年了（距离第一个版本的周年纪念还有几个月，但在 30 年前我就开始研究 Linux 的“前身”了），并且一直在维护它。但 Git 呢？我从来没有想过我真的想要长期维护它。我喜欢用它，而且在某种程度上，我认为它是最好的 SCM，但它并不是我的兴趣所在。</p><p>所以我总是希望别人来为我维护 SCM——事实上，如果当初我不用自己开发这个 SCM，我会很开心。</p><p>以上就是故事的背景。</p><p>至于 Junio，他实际上是最早加入 Git 开发队伍的人员之一。他在我将 Git 的第一个非常粗糙的版本公开后的几天内提交了第一次变更代码，所以 Junio 在 Git 一开始就参与其中了。</p><p>但我之所以把项目交给 Junio，并不是因为他是第一批参与项目的人。在维护了 Git 几个月之后，让我决定将项目交给 Junio 维护者的真正原因是“好品味”——一个很难描述的概念。我真的想不到还有什么更好的描述：编程主要是为了解决技术问题，但如何解决这些问题以及如何思考也很重要。随着时间的推移，你开始意识到：有些人就有这种“好品味”，他总能选择正确的解决方案。</p><p>我不想将编程说成是一门艺术，因为它实际上主要是关于“好的工程”。我很喜欢托马斯·爱迪生的那句“天才是百分之一的灵感加上百分之九十九的汗水”：编程涉及的几乎都是细枝末节的东西和日常繁重的工作。但是，那百分之一的“灵感”，也就是“好品味”，不仅要解决问题，而且要干净、漂亮地解决。</p><p>Junio 就有那种“好品味”。</p><p>每次提到 Git，我都想试着讲清楚：我在一开始提出了 Git 的核心思想，并经常因为这部分工作而获得太多荣誉。Git 的这 15 年，我也只是在第一年真正参与了项目。Junio 是一个优秀的维护者，是他让 Git 变成现在的样子。</p><p>顺便说一下，关于“好品味”，以及找到拥有好品味的人，并信任他们——不仅仅 Git 是这样，Linux 也是这样。与 Git 不一样的是，Linux 这个项目我仍然在积极维护，但与 Git 一样的是，Linux 也是一个有很多人共同参与的项目。我认为，Linux 的一大成功是它拥有数百名维护者，他们都具备了“好品味”，并维护着内核的不同部分。</p><h3><span id="项目维护并非非黑即白">项目维护并非“非黑即白”</span></h3><p><strong>Jeremy Andrews：你有没有过这样的经历：把控制权交给维护者，然后发现这是一个错误的决定？</strong></p><p><strong>Linus Torvalds</strong>：我们的维护体系从来就不是非黑即白的，所以不会出现这种情况。事实上，我们甚至没有将维护权正式记录下来：我们确实有一个 MAINTAINERS 文件，但那只是为了让你在遇到问题时能够找到对的人，并不是某种排他所有权的标志。</p><p>所以，“谁负责什么东西”更像是一种流动的指南，以及“这个人很活跃，工作做得很好”，而不是“我们把所有权给了那个人，然后他搞砸了”。</p><p>从某种意义上说，我们的维护体系也是流动的。假设你是某个子系统的维护者，如果你需要另一个子系统的东西，是可以跨界的。通常人们在这样做之前都会进行广泛的沟通，而且这种事情确实发生了。这并不是“你只能动这个文件”之类的硬性规定。</p><p>实际上，这与前面讨论的有关许可的事情有些联系。“Git”的另一个设计原则是“每个人都有自己的代码树，但没有哪一个代码树是特殊的”。</p><p>因为很多其他项目都使用了工具——比如 CVS 或 SVN——这些工具会让一些人变得“特殊”，赋予了他们某种“所有权”。在 BSD 世界里，他们称之为“commit bit”：给一个维护者“commit bit”意味着他可以将代码提交到中央代码库。</p><p>我一直很讨厌这种模式，因为它会不可避免地导致政治“小团体”的出现。在这种模式下，总有一些人是特殊、隐性受信任的。问题的关键甚至不在于“隐性受信任”，而在于硬币的另一面——其他人不被信任，他们被定义成局外人，必须受制于监护者。</p><p>同样，在 Git 开发中也不存在这种情况。每个人都是平等的，任何人都可以克隆代码，做自己的开发，做好了，就可以合并回来。</p><p>所以，没有必要给人们特权，也不需要“commit bit”。这样就可以避免出现政治“小团体”，也不需要“隐性信任”。如果他们做得不好——或者更常见的是，最终消失了，并转向了另一个兴趣——他们的代码就不会被合并回来，也不会阻碍其他有新想法的人。</p><h3><span id="对-git-特性的看法">对 Git 特性的看法</span></h3><p><strong>Jeremy Andrews：Git 有没有哪些新特性让你印象深刻，并成为你工作流的一部分？还有哪些特性是你想要增加的？</strong></p><p><strong>Linus Torvalds</strong>：我对 Git 的需求总是最早得到满足的，所以，对于我来说，Git 没有“新”特性。</p><p>这些年来，Git 确实有很大的改进，有一些在我的工作流中已经体现出来了。例如，Git 的速度一直都很快——毕竟这是我的设计目标之一——但它的大部分特性最初是围绕 shell 脚本而构建的。多年来，大多数 shell 脚本都已经消失了，这意味着我可以比原来更快地应用 Andrew Morton 的补丁。这一点令人感到欣慰，因为这实际上是我早期用于性能测试的基准之一。</p><p>所以，Git 对我来说一直都很好，而且变得越来越好。</p><p>Git 最大的改进在于“普通用户”的使用体验变得更好了。一部分原因是人们在学习 Git 工作流的过程中逐渐习惯了它，但更多的是因为 Git 本身变得更易于使用。</p><blockquote><p>本文转载自：「 架构头条 」，原文：<a href="https://tinyurl.com/wxejbh4w" target="_blank" rel="noopener">https://tinyurl.com/wxejbh4w</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;作者丨 Jeremy Andrews&lt;/li&gt;
&lt;li&gt;译者丨屠灵&lt;/li&gt;
&lt;li&gt;策划丨蔡芳芳&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux 诞生于 1991 年，距今已经 30 年了。虽然它一开始只是 Linus 的一个个人项目，而非出于要开发一个新操作系统的伟大梦想，但如今的 Linux 早已无处不在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;30 年前，当 Linus Torvalds 第一次发布 Linux 内核时，他还是赫尔辛基大学的一名 21 岁的学生。他宣布说：“我正在开发一个（免费的）操作系统（这只是个爱好，不会做得很大，也不会很专业……）”。30 年后，500 强超级计算机和 70% 以上的智能手机都在运行 Linux。很显然，Linux 不仅大，而且很专业。&lt;/p&gt;
&lt;p&gt;30 年来，Linus Torvalds 一直在领导着 Linux 内核的开发，启发了无数开发者和开源项目。2005 年，Linus 开发了 Git，用来管理内核开发过程。Git 现在已经成为最流行的版本控制系统，受到无数开源和私有项目的信任。&lt;/p&gt;
&lt;p&gt;正值 Linux 诞生 30 周年之际，Linus Torvalds 通过电子邮件回复了 Tag 1 咨询公司的创始合伙人 / 首席执行官 Jeremy Andrews 的访谈问题（《An Interview With Linus Torvalds: Linux and Git - Part 1》），回顾并总结了过去这些年他在领导大型开源项目过程中得到的真知灼见。本文着重介绍 Linux 内核开发和 Git。InfoQ 对访谈内容进行了翻译，以飨读者。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="杂谈" scheme="https://www.hi-linux.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>6 张图带你搞懂微服务</title>
    <link href="https://www.hi-linux.com/posts/39095.html"/>
    <id>https://www.hi-linux.com/posts/39095.html</id>
    <published>2021-06-10T01:00:00.000Z</published>
    <updated>2021-06-10T09:50:38.832Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>虽说<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">微服务</a>早已是一个老生常谈的话题了，在 <a href="https://www.infoq.cn/topic/microservice" target="_blank" rel="noopener">infoq</a> 或者 <a href="https://insights.thoughtworks.cn/tag/microservices/" target="_blank" rel="noopener">thoughtworks</a> 上可以找到很多案例，不过可惜的是其中相当比例的案例是失败的案例，究其原因，除了<a href="https://microservices.io/index.html" target="_blank" rel="noopener">技术门槛</a>之外，主要是因为很多人脱离了实际情况，只是为了微服务而微服务。本文通过一个例子带领大家从头到尾体验一下微服务的演化过程，不仅要做到知其然，更要做到知其所以然。</p><a id="more"></a><p>假设我们正在开发一个在线购物项目，其主要功能包括商城、推荐、评论、用户等，它是一个典型的<a href="https://microservices.io/patterns/monolithic.html" target="_blank" rel="noopener">单体架构</a>：不同团队的技术人员工作在同一个版本库上，系统功能按模块划分，不同模块之间通过本地函数调用，通常操作同一个数据库。</p><p><img src="https://img.hi-linux.com/staticfile/ms01-20210514145248915-2021-05-14-k5YOD0.png" alt></p><p>在项目早期，单体架构往往能很好的适应快速迭代的需求，不过随着项目的发展，项目本身会变得复杂，其弊端不可避免的出现，比如下面列举的一些情况：</p><ul><li>因为大家都工作在同一个版本库上，所以可能会遇到：商城模块完成了新功能，准备上线，结果推荐模块刚提交了还没来得及测试的代码，于是不得不推迟上线。</li><li>不同的需求采用不同的技术栈：负责评论模块的同事想用 PHP + MySQL 来构建系统，负责用户模块的同事却想用 Golang + PostgreSQL 来构建系统。</li><li>有的模块需要高性能 CPU，有的模块需要大内存，因为不同的模块是耦合在一起的，所以我们的服务器不得不同时具备高性能 CPU，大内存，从而增加了成本。</li></ul><p>如何解决此类问题？<a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">康威定律</a>给出了很好的建议：「设计系统的架构受制于产生这些设计的组织的沟通结构」，通俗点说就是：「有什么样的组织架构就会设计出什么样的系统架构」。在本例中，因为不同的团队负责不同的模块，所以很自然的可以通过模块来把系统切分成商城、推荐、评论、用户等几个独立的服务：每个服务有自己独立的版本库和数据库，服务之间通过 RPC 来通信。不同的服务拥有自己的版本库，可以使用适合自己的技术栈和硬件，独立开发独立部署。</p><p>一个需要注意的问题是如何确定服务粒度的大小，虽然按照康威定律的描述只要按照组织架构的大小来确定服务的大小即可，但是如何规划一个合理的团队规模呢？实际上并没有一个精确的答案，我们需要按照客观情况来确定一个适合自己的大小适中的服务粒度，过小的粒度会导致服务之间强耦合，过大的粒度则背离了微服务的初衷，Uber 甚至还针对服务粒度大小问题发明了一个<a href="https://mp.weixin.qq.com/s/1P_5mMeZQ8YQzybLmjENLg" target="_blank" rel="noopener">宏服务</a>的概念，有兴趣的读者不妨看看。</p><p><img src="https://img.hi-linux.com/staticfile/ms02-20210514145255339-2021-05-14-mujm29.png" alt></p><p>当我们把单体架构切分成独立的服务之后，原本模块间本地的函数调用变成了服务间远程的 RPC 调用，我们不得不处理服务治理之类的问题，随着微服务数量的增加，问题会变得越来越棘手，好在随着云原生的发展，特别是 <a href="https://kubernetes.io/" target="_blank" rel="noopener">K8S</a> 和 <a href="https://istio.io/" target="_blank" rel="noopener">istio</a> 等技术的成熟，我们的架构可以演化到 <a href="https://www.servicemesher.com/" target="_blank" rel="noopener">service mesh</a> 阶段，通过 sidecar 透明实现服务治理。</p><p><img src="https://img.hi-linux.com/staticfile/ms03-2021-05-14-7Q6UhO.png" alt></p><p>如果仅仅是把原本模块间本地的函数调用变成了服务间远程的 RPC 调用的话，那么我们的微服务很可能会沦为「<a href="https://skyao.io/talk/202007-microservice-avoiding-distributed-monoliths/" target="_blank" rel="noopener">分布式单体</a>」。问题的症结在于过度使用 RPC，导致服务与服务之间强耦合，解决方法是引入 Event，通过 Event 实现服务与服务的解耦。</p><p>看看如何实现下面的业务逻辑：当一个用户注册后，要在商城里给用户一张优惠券。</p><ul><li>使用 RPC（强调做什么）：当用户模块创建了一个新用户的时候，通过 RPC 调用商城模块给用户一张优惠券，过程中用户模块和商城模块是强耦合的。</li><li>使用 Event（强调发生了什么）：当用户模块创建了一个新用户的时候，它发出一个 UserCreated 事件，商城模块观察到对应的事件后，给用户一张优惠券，过程中用户模块和商城模块是弱耦合的。</li></ul><p>实际情况中应该按需求来选择使用 RPC 或者 Event：如果是业务逻辑的实现部分，倾向于选择使用 RPC；如果是业务逻辑完成之后的后续通知部分，强烈建议选择使用 Event。</p><p><img src="https://img.hi-linux.com/staticfile/ms04-2021-05-14-mw4b0B.png" alt></p><p>服务部署好了之后，接下来我们还需要考虑如何暴露服务以供前端调用，比如用户浏览某个商品的详情页，内容包括商品数据、以及对应的推荐数据和评论数据，如果直接操作服务的话，那么需要多次查询商品服务、推荐服务、评论服务，并不可取，此时可以加入 <a href="https://microservices.io/patterns/apigateway.html" target="_blank" rel="noopener">API Gateway</a> 充当代理，前端只要请求 API Gateway 一次就可以拿到数据。</p><p><img src="https://img.hi-linux.com/staticfile/ms05-2021-05-14-oA6Kbk.png" alt></p><p>有了 API Gateway 之后，它可以帮我们完成聚合之类的逻辑。不过有一个问题是前端可能有多种不同的类型，比如 PC 前端，Mobile 前端，它们的业务逻辑不可避免的会有各种各样的差异，如果在 API Gateway 中处理这些差异的话，那么会出现坏味道，为了解决此类问题，我们引入 <a href="https://microservices.io/patterns/apigateway.html" target="_blank" rel="noopener">BFF</a>（Backend For Frontend），每一种前端都有属于自己的 BFF，用来处理专属于自己的业务逻辑，至于 API Gateway，则只处理鉴权，日志等公共业务逻辑。</p><p><img src="https://img.hi-linux.com/staticfile/ms06-2021-05-14-teyyms.png" alt></p><p>微服务是个极其复杂的概念，本文仅就一些表面问题浅谈一二，其他诸如 <a href="https://microservices.io/patterns/data/saga.html" target="_blank" rel="noopener">SAGA</a> 之类的复杂问题，由于篇幅所限，并未涉猎，大家如果有兴趣的话请自行查阅。</p><p>最后把 <a href="https://martinfowler.com/" target="_blank" rel="noopener">Martin Fowler</a> 在 <a href="https://www.martinfowler.com/books/eaa.html" target="_blank" rel="noopener">PoEAA</a> 中提出的<a href="https://martinfowler.com/bliki/FirstLaw.html" target="_blank" rel="noopener">分布式对象第一定律</a>送给大家：不要分布你的对象！套用这个说法的话，不难引申出微服务第一定律：不要使用微服务！虽然话里有一些戏虐的成份，但是它至少告诫我们在面对微服务的时候要怀揣着一颗敬畏的心。</p><blockquote><p>本文转载自：「 火丁笔记 」，原文：<a href="http://t.cn/A6VzZPdg" target="_blank" rel="noopener">http://t.cn/A6VzZPdg</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽说&lt;a href=&quot;https://martinfowler.com/articles/microservices.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微服务&lt;/a&gt;早已是一个老生常谈的话题了，在 &lt;a href=&quot;https://www.infoq.cn/topic/microservice&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;infoq&lt;/a&gt; 或者 &lt;a href=&quot;https://insights.thoughtworks.cn/tag/microservices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;thoughtworks&lt;/a&gt; 上可以找到很多案例，不过可惜的是其中相当比例的案例是失败的案例，究其原因，除了&lt;a href=&quot;https://microservices.io/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;技术门槛&lt;/a&gt;之外，主要是因为很多人脱离了实际情况，只是为了微服务而微服务。本文通过一个例子带领大家从头到尾体验一下微服务的演化过程，不仅要做到知其然，更要做到知其所以然。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="https://www.hi-linux.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="微服务" scheme="https://www.hi-linux.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linux下优雅的进行大文件切割与合并</title>
    <link href="https://www.hi-linux.com/posts/15581.html"/>
    <id>https://www.hi-linux.com/posts/15581.html</id>
    <published>2021-06-10T01:00:00.000Z</published>
    <updated>2021-06-10T09:50:38.834Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>往往是因为网络传输的限制，导致很多时候，我们需要在 Linux 系统下进行大文件的切割。这样将一个大文件切割成为多个小文件，进行传输，传输完毕之后进行合并即可。</strong></p></blockquote><h2><span id="1-文件切割-split">1. 文件切割 - split</span></h2><blockquote><p><strong>在 Linux 系统下使用 split 命令进行大文件切割很方便</strong></p></blockquote><ul><li><strong>[1] 命令语法</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a: 指定输出文件名的后缀长度(默认为2个:aa,ab...)</span></span><br><span class="line"><span class="comment"># -d: 指定输出文件名的后缀用数字代替</span></span><br><span class="line"><span class="comment"># -l: 行数分割模式(指定每多少行切成一个小文件;默认行数是1000行)</span></span><br><span class="line"><span class="comment"># -b: 二进制分割模式(支持单位:k/m)</span></span><br><span class="line"><span class="comment"># -C: 文件大小分割模式(切割时尽量维持每行的完整性)</span></span><br><span class="line">split [-a] [-d] [-l &lt;行数&gt;] [-b &lt;字节&gt;] [-C &lt;字节&gt;] [要切割的文件] [输出文件名]</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><strong>[2] 使用实例</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行切割文件</span></span><br><span class="line">$ split -l 300000 users.sql /data/users_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用数字后缀</span></span><br><span class="line">$ split -d -l 300000 users.sql /data/users_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字节大小分割</span></span><br><span class="line">$ split -d -b 100m users.sql /data/users_</span><br></pre></td></tr></table></figure><ul><li><strong>[3] 帮助信息</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 帮助信息</span></span><br><span class="line">$ split --<span class="built_in">help</span></span><br><span class="line">Usage: split [OPTION]... [FILE [PREFIX]]</span><br><span class="line">Output pieces of FILE to PREFIXaa, PREFIXab, ...;</span><br><span class="line">default size is 1000 lines, and default PREFIX is <span class="string">'x'</span>.</span><br><span class="line"></span><br><span class="line">With no FILE, or when FILE is -, <span class="built_in">read</span> standard input.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory <span class="keyword">for</span> short options too.</span><br><span class="line">  -a, --suffix-length=N   generate suffixes of length N (default 2)            后缀名称的长度(默认为2)</span><br><span class="line">      --additional-suffix=SUFFIX  append an additional SUFFIX to file names</span><br><span class="line">  -b, --bytes=SIZE        put SIZE bytes per output file                       每个输出文件的字节大小</span><br><span class="line">  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file    每个输出文件的最大字节大小</span><br><span class="line">  -d                      use numeric suffixes starting at 0, not alphabetic   使用数字后缀代替字母后缀</span><br><span class="line">      --numeric-suffixes[=FROM]  same as -d, but allow setting the start value</span><br><span class="line">  -e, --elide-empty-files  <span class="keyword">do</span> not generate empty output files with <span class="string">'-n'</span>        不产生空的输出文件</span><br><span class="line">      --filter=COMMAND    write to shell COMMAND; file name is <span class="variable">$FILE</span>           写入到shell命令行</span><br><span class="line">  -l, --lines=NUMBER      put NUMBER lines/records per output file             设定每个输出文件的行数</span><br><span class="line">  -n, --number=CHUNKS     generate CHUNKS output files; see explanation below  产生chunks文件</span><br><span class="line">  -t, --separator=SEP     use SEP instead of newline as the record separator;  使用新字符分割</span><br><span class="line">                            <span class="string">'\0'</span> (zero) specifies the NUL character</span><br><span class="line">  -u, --unbuffered        immediately copy input to output with <span class="string">'-n r/...'</span>     无需缓存</span><br><span class="line">      --verbose           <span class="built_in">print</span> a diagnostic just before each                  显示分割进度</span><br><span class="line">                            output file is opened</span><br><span class="line">      --<span class="built_in">help</span>     display this <span class="built_in">help</span> and <span class="built_in">exit</span>                                    显示帮助信息</span><br><span class="line">      --version  output version information and <span class="built_in">exit</span>                           显示版本信息</span><br><span class="line"></span><br><span class="line">The SIZE argument is an <span class="built_in">integer</span> and optional unit (example: 10K is 10*1024).</span><br><span class="line">Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).</span><br><span class="line"></span><br><span class="line">CHUNKS may be:</span><br><span class="line">  N       split into N files based on size of input</span><br><span class="line">  K/N     output Kth of N to stdout</span><br><span class="line">  l/N     split into N files without splitting lines/records</span><br><span class="line">  l/K/N   output Kth of N to stdout without splitting lines/records</span><br><span class="line">  r/N     like <span class="string">'l'</span> but use round robin distribution</span><br><span class="line">  r/K/N   likewise but only output Kth of N to stdout</span><br><span class="line"></span><br><span class="line">GNU coreutils online <span class="built_in">help</span>: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">Full documentation at: &lt;http://www.gnu.org/software/coreutils/split&gt;</span><br><span class="line">or available locally via: info <span class="string">'(coreutils) split invocation'</span></span><br></pre></td></tr></table></figure><h2><span id="2-文件合并-cat">2. 文件合并 - cat</span></h2><blockquote><p><strong>在 Linux 系统下使用 cat 命令进行多个小文件的合并也很方便</strong></p></blockquote><ul><li><strong>[1] 命令语法</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -n: 显示行号</span></span><br><span class="line"><span class="comment"># -e: 以$字符作为每行的结尾</span></span><br><span class="line"><span class="comment"># -t: 显示TAB字符(^I)</span></span><br><span class="line">cat [-n] [-e] [-t] [输出文件名]</span><br></pre></td></tr></table></figure><ul><li><strong>[2] 使用实例</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并文件</span></span><br><span class="line">$ cat /data/users_* &gt; users.sql</span><br></pre></td></tr></table></figure><ul><li><strong>[3] 帮助信息</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 帮助信息</span></span><br><span class="line">$ cat --h</span><br><span class="line">Usage: cat [OPTION]... [FILE]...</span><br><span class="line">Concatenate FILE(s) to standard output.</span><br><span class="line"></span><br><span class="line">With no FILE, or when FILE is -, <span class="built_in">read</span> standard input.</span><br><span class="line"></span><br><span class="line">  -A, --show-all           equivalent to -vET</span><br><span class="line">  -b, --number-nonblank    number nonempty output lines, overrides -n</span><br><span class="line">  -e                       equivalent to -vE</span><br><span class="line">  -E, --show-ends          display $ at end of each line</span><br><span class="line">  -n, --number             number all output lines</span><br><span class="line">  -s, --squeeze-blank      suppress repeated empty output lines</span><br><span class="line">  -t                       equivalent to -vT</span><br><span class="line">  -T, --show-tabs          display TAB characters as ^I</span><br><span class="line">  -u                       (ignored)</span><br><span class="line">  -v, --show-nonprinting   use ^ and M- notation, except <span class="keyword">for</span> LFD and TAB</span><br><span class="line">      --<span class="built_in">help</span>     display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">      --version  output version information and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  cat f - g  Output f<span class="string">'s contents, then standard input, then g'</span>s contents.</span><br><span class="line">  cat        Copy standard input to standard output.</span><br><span class="line"></span><br><span class="line">GNU coreutils online <span class="built_in">help</span>: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">Full documentation at: &lt;http://www.gnu.org/software/coreutils/cat&gt;</span><br><span class="line">or available locally via: info <span class="string">'(coreutils) cat invocation'</span></span><br></pre></td></tr></table></figure><h2><span id="3-参考文档">3. 参考文档</span></h2><ul><li><a href="https://www.cnblogs.com/bymo/p/7571320.html" target="_blank" rel="noopener">Linux 大文件的分割与合并</a></li><li><a href="https://www.jianshu.com/p/014ec71b0215" target="_blank" rel="noopener">Linux 学习–文件分割与合并</a></li></ul><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/y3zhsyyw%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://tinyurl.com/y3zhsyyw，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;往往是因为网络传输的限制，导致很多时候，我们需要在 Linux 系统下进行大文件的切割。这样将一个大文件切割成为多个小文件，进行传输，传输完毕之后进行合并即可。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-文件切割-split&quot;&gt;1. 文件切割 - split&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在 Linux 系统下使用 split 命令进行大文件切割很方便&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[1] 命令语法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -a: 指定输出文件名的后缀长度(默认为2个:aa,ab...)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -d: 指定输出文件名的后缀用数字代替&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -l: 行数分割模式(指定每多少行切成一个小文件;默认行数是1000行)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -b: 二进制分割模式(支持单位:k/m)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -C: 文件大小分割模式(切割时尽量维持每行的完整性)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;split [-a] [-d] [-l &amp;lt;行数&amp;gt;] [-b &amp;lt;字节&amp;gt;] [-C &amp;lt;字节&amp;gt;] [要切割的文件] [输出文件名]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Shell" scheme="https://www.hi-linux.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款开源即时性能分析工具 Pyroscope</title>
    <link href="https://www.hi-linux.com/posts/52545.html"/>
    <id>https://www.hi-linux.com/posts/52545.html</id>
    <published>2021-06-09T01:00:00.000Z</published>
    <updated>2021-06-09T01:24:04.959Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>当网站上线后，流量增加或短暂功能故障，都会造成使用者体验相当不好，而这时该怎么快速找到性能的瓶颈呢？通常 CPU 达到 100% 时，有时候也很难复制及找出关键问题点。</p><p>本篇文章，我们会介绍一套工具叫 Pyroscope，让开发者可以快速找到性能瓶颈的代码。Pyroscope 目前可以支持 Python, Ruby 或 Go 的环境。本文笔者会针对 Go 环境做介绍。</p><h2><span id="什么是-pyroscope">什么是 Pyroscope？</span></h2><p>Pyroscope 是一套开源的性能即时监控平台，简单的 Server 及 Agent 架构，让开发者可以轻松监控代码性能，不管你要找 10 秒或几分钟内的性能数据，都可以快速的即时呈现，开发者也不用在意装了此监控会造成任何性能上的负担。Pyroscope 背后的储存采用 Badger 这套 Key-Value 数据库，性能上是非常好的。目前只支持 3 种语言 (Python, Ruby 及 Go) 未来会预计支持 NodeJS。假设您还没引入任何性能分析工具或平台，那 Pyroscope 会是您最好的选择。</p><a id="more"></a><h2><span id="pyroscope-架构">Pyroscope 架构</span></h2><p>如果你有打算找性能分析工具平台，Pyroscope 提供了三大优势，让开发者可以放心使用</p><ul><li>低 CPU 使用率，不会影响既有平台</li><li>可储存好几年的资料，并且可用 10 秒细颗粒度查看资料</li><li>压缩储存资料，减少浪费硬盘空间</li><li>架构只有分 Server 和 Agent，除了 Go 语言之外，Python 跟 Ruby App 都是透过 pyroscope 指令启动相关 app 来监控系统效能。</li></ul><p><img src="https://img.hi-linux.com/staticfile/36tdD2-2021-04-22-Im2TSi.jpg" alt="Pyroscope 架构图"></p><h2><span id="启动-pyroscope-服务">启动 Pyroscope 服务</span></h2><p>启动方式有两种，第一是直接用 docker 指令启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -p 4040:4040 pyroscope&#x2F;pyroscope:latest server</span><br></pre></td></tr></table></figure><p>另一种可以用 docker-compose 启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">services:</span><br><span class="line">  pyroscope:</span><br><span class="line">    image: &quot;pyroscope&#x2F;pyroscope:latest&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;4040:4040&quot;</span><br><span class="line">    command:</span><br><span class="line">      - &quot;server&quot;</span><br></pre></td></tr></table></figure><h2><span id="安装-agent">安装 Agent</span></h2><h3><span id="在-go-语言中使用">在 Go 语言中使用</span></h3><p>本篇用 Go 语言当作示例，先 import package</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;github.com&#x2F;pyroscope-io&#x2F;pyroscope&#x2F;pkg&#x2F;agent&#x2F;profiler&quot;</span><br></pre></td></tr></table></figure><p>接著在 main.go 写入底下代码即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">profiler.Start(profiler.Config&#123;</span><br><span class="line">    ApplicationName: &quot;simple.golang.app&quot;,</span><br><span class="line">    ServerAddress:   &quot;http:&#x2F;&#x2F;pyroscope:4040&quot;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中 <code>http://pyroscope</code> 可以换成自定义的 hostname 即可，接着打开上述网址就可以看到性能监控的画面了</p><p><img src="https://img.hi-linux.com/staticfile/7hYcxe-2021-04-22-v59IxB.jpg" alt></p><p>通过画面，我们可以快速找到是 SQL 或哪个函式执行时间长。</p><p><img src="https://img.hi-linux.com/staticfile/ChNi8m-2021-04-22-YkkYNt.jpg" alt></p><h3><span id="在-python-和-ruby-语言中使用">在 Python 和 Ruby 语言中使用</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># If using Python</span><br><span class="line">$ pyroscope exec python manage.py runserver </span><br><span class="line"></span><br><span class="line"># If using Ruby</span><br><span class="line">$ pyroscope exec rails server</span><br></pre></td></tr></table></figure><h2><span id="心得">心得</span></h2><p>这套工具相当方便，在 Go 语言虽然可以用 pprof 快速找到问题，但是难免还是需要手动的一些地方才可以查出性能瓶颈，有了这套平台，就可以将全部 App 都进行监控，当使用者有任何问题，就可以快速透过 Pyroscope 查看哪些代码出了问题。</p><blockquote><p>本文转载自：「 小恶魔 」，原文：<a href="http://t.cn/A6c0G3dm%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">http://t.cn/A6c0G3dm，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当网站上线后，流量增加或短暂功能故障，都会造成使用者体验相当不好，而这时该怎么快速找到性能的瓶颈呢？通常 CPU 达到 100% 时，有时候也很难复制及找出关键问题点。&lt;/p&gt;
&lt;p&gt;本篇文章，我们会介绍一套工具叫 Pyroscope，让开发者可以快速找到性能瓶颈的代码。Pyroscope 目前可以支持 Python, Ruby 或 Go 的环境。本文笔者会针对 Go 环境做介绍。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Pyroscope？&quot;&gt;什么是 Pyroscope？&lt;/h2&gt;
&lt;p&gt;Pyroscope 是一套开源的性能即时监控平台，简单的 Server 及 Agent 架构，让开发者可以轻松监控代码性能，不管你要找 10 秒或几分钟内的性能数据，都可以快速的即时呈现，开发者也不用在意装了此监控会造成任何性能上的负担。Pyroscope 背后的储存采用 Badger 这套 Key-Value 数据库，性能上是非常好的。目前只支持 3 种语言 (Python, Ruby 及 Go) 未来会预计支持 NodeJS。假设您还没引入任何性能分析工具或平台，那 Pyroscope 会是您最好的选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Pyroscope" scheme="https://www.hi-linux.com/tags/Pyroscope/"/>
    
  </entry>
  
  <entry>
    <title>推荐两款助你效率提高 10 倍的 Kubernetes 容器日志查看神器</title>
    <link href="https://www.hi-linux.com/posts/43085.html"/>
    <id>https://www.hi-linux.com/posts/43085.html</id>
    <published>2021-06-07T01:00:00.000Z</published>
    <updated>2021-06-07T02:17:23.004Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>通常情况下，在部署了 <code>K8S</code> 服务之后，为了更好地监控服务的运行情况，都会接入对应的日志系统来进行检测和分析，比如常见的 <code>Filebeat + ElasticSearch + Kibana</code> 这一套组合来完成。虽然该组合可以满足我们对于服务监控的要求，但是如果只是部署一个内部单服务用的话，未免显得大材小用，而且部署服务还会带来大量的资源消耗。那么有没有简单查看 <code>K8S</code> 中多个 <code>Pod</code> 中的日志工具呢？咳咳咳，那么今天就介绍两款超好用的多容器实时日志查看工具 <code>Kubetail</code> 和 <code>Stern</code>。</p><a id="more"></a><h2><span id="1-kubetail-工具">1. Kubetail 工具</span></h2><blockquote><p><strong>Bash script to tail Kubernetes logs from multiple pods at the same time</strong></p></blockquote><p><a href="https://github.com/johanhaleby/kubetail" target="_blank" rel="noopener">Kubetail</a> 项目其实是一个简单 <code>Shell</code> 脚本，它可以将多个 <code>Pod</code> 中的日志信息聚合到一起进行展示，并支持彩色输出和条件过滤。</p><p><img src="https://img.hi-linux.com/staticfile/watch-k8s-logs-tools-01-2021-05-29-2NQPv6.png" alt="查看K8S容器日志内容 - Kubetail"></p><h3><span id="11-工具安装">1.1 工具安装</span></h3><blockquote><p><strong>安装非常简单，而且针对不同平台适配不同类型的工具。</strong></p></blockquote><ul><li><strong>Homebrew</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install kubetail using brew</span></span><br><span class="line">$ brew tap johanhaleby/kubetail &amp;&amp; brew install kubetail</span><br></pre></td></tr></table></figure><ul><li><strong>Linux</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># download and to go</span></span><br><span class="line"><span class="comment"># https://github.com/johanhaleby/kubetail/releases</span></span><br><span class="line">$ wget https://raw.githubusercontent.com/johanhaleby/kubetail/master/kubetail</span><br><span class="line">$ chmod +x kubetail</span><br><span class="line">$ cp kubetail /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><ul><li><strong>zsh plugin</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># oh-my-zsh</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/johanhaleby/kubetail.git kubetail</span><br><span class="line"></span><br><span class="line">$ vim ~/.zshrc</span><br><span class="line">plugins=( ... kubetail )</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><h3><span id="12-工具使用">1.2 工具使用</span></h3><blockquote><p><strong>使用起来也非常的简单，短短 2 分钟就可以上手！</strong></p></blockquote><ul><li><strong>示例说明前数据信息准备</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show all your pods</span></span><br><span class="line">$ kubectl get pods -n <span class="built_in">test</span></span><br><span class="line">NAME                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">app1-v1-aba8y          1/1       Running   0          1d</span><br><span class="line">app1-v1-gc4st          1/1       Running   0          1d</span><br><span class="line">app1-v1-m8acl          1/1       Running   0          6d</span><br><span class="line">app1-v1-s20d0          1/1       Running   0          1d</span><br><span class="line">app2-v31-9pbpn         1/1       Running   0          1d</span><br><span class="line">app2-v31-q74wg         1/1       Running   0          1d</span><br><span class="line">my-demo-v5-0fa8o       1/1       Running   0          3h</span><br><span class="line">my-demo-v5-yhren       1/1       Running   0          2h</span><br></pre></td></tr></table></figure><ul><li><strong>介绍了工具的使用方式</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时跟踪两个"app2"的Pod的日志</span></span><br><span class="line">$ kubetail app2</span><br><span class="line">$ kubetail app1,app2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定"app2"的Pod里面的容器名称</span></span><br><span class="line">$ kubetail app2 -c container1</span><br><span class="line">$ kubetail app2 -c container1 -c container2</span><br><span class="line">$ kubetail app2 -c container1 -n namespace1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式</span></span><br><span class="line">$ kubetail <span class="string">"^app1|.*my-demo.*"</span> --regex</span><br></pre></td></tr></table></figure><ul><li><strong>通过使用 <code>-k</code> 参数，您可以指定 <code>kubetail</code> 如何使用颜色</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pod:   只有Pod名称着色且其他输出均使用终端默认颜色</span></span><br><span class="line"><span class="comment"># line:  整行是彩色的(默认)</span></span><br><span class="line"><span class="comment"># false: 所有输出都不着色</span></span><br><span class="line">$ kubetail app2 -k pod</span><br><span class="line">$ kubetail app2 -k line</span><br><span class="line">$ kubetail app2 -k <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><strong>常见命令行参数说明</strong></li></ul><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">命令行参数</th><th style="text-align:left">对应含义解析</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong><code>-n</code></strong></td><td style="text-align:left">指定命名空间的名称</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong><code>-c</code></strong></td><td style="text-align:left">指定多容器 <code>Pod</code> 中的容器具体名称</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong><code>-k</code></strong></td><td style="text-align:left">将输出的日志内容进行着色显示</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong><code>-b</code></strong></td><td style="text-align:left">是否使用 <code>line-buffered</code> 特性，默认为 <code>false</code> 状态</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong><code>-l</code></strong></td><td style="text-align:left">标签过滤器，用于忽略 <code>Pod</code> 名称</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong><code>-t</code></strong></td><td style="text-align:left">指定 <code>Kubeconfig</code> 文件中的 <code>Context</code> 内容</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong><code>-s</code></strong></td><td style="text-align:left">指定返回一个相对时间之后的日志；例如 <code>5s</code>/<code>2m</code>/<code>3h</code>，默认是 <code>10s</code></td></tr></tbody></table><h2><span id="2-stern-工具">2. Stern 工具</span></h2><blockquote><p><strong>Multi pod and container log tailing for Kubernetes</strong></p></blockquote><p><a href="https://github.com/wercker/stern" target="_blank" rel="noopener">Stern</a> 是使用 <code>Go</code> 语言开发的一款开箱即用的简单工具，它可以将多个 <code>Pod</code> 中的日志信息聚合到一起进行展示，并支持彩色输出和条件过滤。需要说的是，改工具已经很久都没有更新过了，所有不建议使用了。</p><p><img src="https://img.hi-linux.com/staticfile/watch-k8s-logs-tools-02-2021-05-29-TeVzd6.png" alt></p><h3><span id="21-工具安装">2.1 工具安装</span></h3><blockquote><p><strong>安装非常简单，而且针对不同平台适配不同类型的工具。</strong></p></blockquote><ul><li><strong>Homebrew</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install kubetail using brew</span></span><br><span class="line">$ brew install stern</span><br></pre></td></tr></table></figure><ul><li><strong>Linux</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># download and to go</span></span><br><span class="line"><span class="comment"># https://github.com/wercker/stern/tags</span></span><br><span class="line">$ wget https://github.com/wercker/stern/releases/download/1.11.0/stern_linux_amd64</span><br><span class="line">$ chmod +x stern_linux_amd64</span><br><span class="line">$ mv stern_linux_amd64 /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><ul><li><strong>zsh plugin</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bash-completion</span></span><br><span class="line">$ brew install bash-completion</span><br><span class="line">$ <span class="built_in">source</span> &lt;(brew --prefix)/etc/bash-completion</span><br><span class="line">$ <span class="built_in">source</span> &lt;(stern --completion=bash)</span><br><span class="line"></span><br><span class="line"><span class="comment"># .zshrc</span></span><br><span class="line">$ <span class="built_in">source</span> &lt;(stern --completion=zsh)</span><br></pre></td></tr></table></figure><h3><span id="22-工具使用">2.2 工具使用</span></h3><blockquote><p><strong>使用起来也非常的简单，短短 2 分钟就可以上手！</strong></p></blockquote><ul><li><strong>示例说明前数据信息准备</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show all your pods</span></span><br><span class="line">$ kubectl get pods -n <span class="built_in">test</span></span><br><span class="line">NAME                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">app1-v1-aba8y          1/1       Running   0          1d</span><br><span class="line">app1-v1-gc4st          1/1       Running   0          1d</span><br><span class="line">app1-v1-m8acl          1/1       Running   0          6d</span><br><span class="line">app1-v1-s20d0          1/1       Running   0          1d</span><br><span class="line">app2-v31-9pbpn         1/1       Running   0          1d</span><br><span class="line">app2-v31-q74wg         1/1       Running   0          1d</span><br><span class="line">my-demo-v5-0fa8o       1/1       Running   0          3h</span><br><span class="line">my-demo-v5-yhren       1/1       Running   0          2h</span><br></pre></td></tr></table></figure><ul><li><strong>介绍了工具的使用方式</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看默认名称空间下的所有Pod日志</span></span><br><span class="line">$ stern  .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod 中指定容器的日志</span></span><br><span class="line">$ stern app2 --container container1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定命名空间中容器的日志</span></span><br><span class="line">$ stern app2 --namespace namespace1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定命名空间中除指定容器外的所有容器的日志</span></span><br><span class="line">$ stern --namespace namespace1 --exclude-container container1 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间范围内容器的日志(15分钟内)</span></span><br><span class="line">$ stern app2 -t --since 15m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有命名空间中符合指定标签容器的日志</span></span><br><span class="line">$ stern --all-namespaces -l run=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找前端Pod中版本为canary的日志</span></span><br><span class="line">$ stern frontend --selector release=canary</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将日志消息通过管道传输到jq命令</span></span><br><span class="line">$ stern backend -o json | jq .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅输出日志消息本身</span></span><br><span class="line">$ stern backend -o raw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义模板输出</span></span><br><span class="line">$ stern --template <span class="string">'&#123;&#123;.Message&#125;&#125; (&#123;&#123;.Namespace&#125;&#125;/&#123;&#123;.PodName&#125;&#125;/&#123;&#123;.ContainerName&#125;&#125;)'</span> backend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用stern提供的颜色的自定义模板输出</span></span><br><span class="line">$ stern --template <span class="string">'&#123;&#123;.Message&#125;&#125; (&#123;&#123;.Namespace&#125;&#125;/&#123;&#123;color .PodColor .PodName&#125;&#125;/&#123;&#123;color .ContainerColor .ContainerName&#125;&#125;)'</span> backend</span><br></pre></td></tr></table></figure><ul><li><strong>常见命令行参数说明</strong></li></ul><table><thead><tr><th style="text-align:left">flag</th><th style="text-align:left">default</th><th style="text-align:left">purpose</th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>--container</code></strong></td><td style="text-align:left"><code>.*</code></td><td style="text-align:left">Container name when multiple containers in pod (regular expression)</td></tr><tr><td style="text-align:left"><strong><code>--exclude-container</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Container name to exclude when multiple containers in pod (regular expression)</td></tr><tr><td style="text-align:left"><strong><code>--container-state</code></strong></td><td style="text-align:left"><code>running</code></td><td style="text-align:left">Tail containers with status in running, waiting or terminated. Default to running.</td></tr><tr><td style="text-align:left"><strong><code>--timestamps</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Print timestamps</td></tr><tr><td style="text-align:left"><strong><code>--since</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Return logs newer than a relative duration like 52, 2m, or 3h. Displays all if omitted</td></tr><tr><td style="text-align:left"><strong><code>--context</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Kubernetes context to use. Default to <code>kubectl config current-context</code></td></tr><tr><td style="text-align:left"><strong><code>--exclude</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Log lines to exclude; specify multiple with additional <code>--exclude</code>; (regular expression)</td></tr><tr><td style="text-align:left"><strong><code>--namespace</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Kubernetes namespace to use. Default to namespace configured in Kubernetes context</td></tr><tr><td style="text-align:left"><strong><code>--kubeconfig</code></strong></td><td style="text-align:left"><code>~/.kube/config</code></td><td style="text-align:left">Path to kubeconfig file to use</td></tr><tr><td style="text-align:left"><strong><code>--all-namespaces</code></strong></td><td style="text-align:left"></td><td style="text-align:left">If present, tail across all namespaces. A specific namespace is ignored even if specified with –namespace.</td></tr><tr><td style="text-align:left"><strong><code>--selector</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Selector (label query) to filter on. If present, default to <code>.*</code> for the pod-query.</td></tr><tr><td style="text-align:left"><strong><code>--tail</code></strong></td><td style="text-align:left"><code>-1</code></td><td style="text-align:left">The number of lines from the end of the logs to show. Defaults to -1, showing all logs.</td></tr><tr><td style="text-align:left"><strong><code>--color</code></strong></td><td style="text-align:left"><code>auto</code></td><td style="text-align:left">Force set color output. <code>auto</code>: colorize if tty attached, <code>always</code>: always colorize, <code>never</code>: never colorize</td></tr><tr><td style="text-align:left"><strong><code>--output</code></strong></td><td style="text-align:left"><code>default</code></td><td style="text-align:left">Specify predefined template. Currently support: [default, raw, json] See templates section</td></tr><tr><td style="text-align:left"><strong><code>template</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Template to use for log lines, leave empty to use –output flag</td></tr></tbody></table><h2><span id="3-参考链接地址">3. 参考链接地址</span></h2><ul><li><a href="https://github.com/johanhaleby/kubetail" target="_blank" rel="noopener">johanhaleby/kubetail</a></li><li><a href="https://github.com/wercker/stern" target="_blank" rel="noopener">wercker/stern</a></li><li><a href="https://www.hi-linux.com/posts/14566.html">两款超好用的 Kubernetes 实时日志查看工具</a></li></ul><blockquote><p>本文转载自：「  Ecsape 的博客 」，原文：<a href="https://tinyurl.com/euu7396c" target="_blank" rel="noopener">https://tinyurl.com/euu7396c</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常情况下，在部署了 &lt;code&gt;K8S&lt;/code&gt; 服务之后，为了更好地监控服务的运行情况，都会接入对应的日志系统来进行检测和分析，比如常见的 &lt;code&gt;Filebeat + ElasticSearch + Kibana&lt;/code&gt; 这一套组合来完成。虽然该组合可以满足我们对于服务监控的要求，但是如果只是部署一个内部单服务用的话，未免显得大材小用，而且部署服务还会带来大量的资源消耗。那么有没有简单查看 &lt;code&gt;K8S&lt;/code&gt; 中多个 &lt;code&gt;Pod&lt;/code&gt; 中的日志工具呢？咳咳咳，那么今天就介绍两款超好用的多容器实时日志查看工具 &lt;code&gt;Kubetail&lt;/code&gt; 和 &lt;code&gt;Stern&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂 DevOps 和 SRE 的区别</title>
    <link href="https://www.hi-linux.com/posts/38404.html"/>
    <id>https://www.hi-linux.com/posts/38404.html</id>
    <published>2021-06-04T01:00:00.000Z</published>
    <updated>2021-06-04T06:15:16.306Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="devops-和-sre">DevOps 和 SRE</span></h2><p>最近有一位朋友和我聊职业发展方向问题，聊了不少 DevOps 和 SRE 话题。 我几年前刚接触这两个概念时也常常将之混淆，可惜当时没有人来解答我困惑。 现在这虽然已经极为流行，但是我发现我这位朋友对这两个职位还存在一些误区。 于是我给了一些见解并整理成文章以饕大众。</p><p>最常见的误区：</p><ul><li>DevOps 新概念，好高级哦</li><li>SRE 是高级版 DevOps</li><li>运维可以轻松转身 DevOps 工程师</li></ul><h2><span id="devops-和-sre-定义">DevOps 和 SRE 定义</span></h2><p>DevOps 是字面上 Dev 开发 / Ops 运维两者组合， 严格意义上 DevOps 如下（via DevOps - Wikipedia）：</p><blockquote><p>DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev） ”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。</p></blockquote><p>SRE 全称是 Site Reliability Engineering，最早是由 Google 提出，并且在其工程实践中发扬光大。 他们还出了一本同名书籍「Site Reliability Engineering」， 让这个理念在互联网工程师圈子里广泛传播。</p><p>Google 对 SRE 解释是（via Site Reliability Engineering - Wikipedia）：</p><blockquote><p>Site reliability engineering (SRE) is a discipline that incorporates aspects of software engineering and applies that to operations whose goals are to create ultra-scalable and highly reliable software systems.</p></blockquote><p>我将其翻译翻译为中文：</p><blockquote><p>网站稳定性工程师是致力于打造「高扩展、高可用系统」，并将其贯彻为原则的软件工程师。</p></blockquote><p>从定义来看，DevOps 是文化、运动和惯例，而 SRE 是有严格任职要求的职位。 文化是软性定义，文化有更多概念可以捏造，而 SRE 定义精准，就少了想象空间（也可能 SRE 门槛高 ）。 按 Google 给出的说法是，SRE 工程师实践了 DevOps 文化。这个观点没错，但是国内的 DevOps 逐步独立出 DevOps 工程师， 所以在本文，我着重讨论的是 DevOps 工程师和 SRE 工程师两种职位对比。</p><a id="more"></a><h2><span id="两者产生背景和历史">两者产生背景和历史</span></h2><p>互联网需求催生了 DevOps 。在最传统软件企业中，是只有 Dev 没有 Ops， 那时 Ops 可能还是只是技术支持人员。开发按照瀑布流：需求分析、系统设计、开发、测试、交付、运行， 传统软件发布是一个重量级操作。一旦发布，Dev 几乎不再直接操作。 80 后可能会记得 QQ 每年都会有一个大版本发布吧，QQ 2000 / 2003 / 2004 等等。 此时 Ops 不用和 Dev 直接高频接触，甚至针对一些纯离线业务，压根没有设立 Ops 这个岗位。</p><p>互联网浪潮之后，软件由传统意义上桌面软件演变为面向网站、手机应用。 这时候业务核心逻辑，比如交易，社交行为都不在用户桌面完成，而是在服务器后端完成。 这给互联网企业给予了极大操作空间：随时可以改变业务逻辑，这促进了业务快速迭代变更。 但即便这样，Dev 和 Ops 是极其分裂的两个环节。Ops 不关心代码是如何运作的，Dev 不知道代码如何运行在服务器上。</p><p>当业界还沉浸在可以每周发布版本喜悦中时，2009 年，Flicker 提出了每天发布 10+ 次概念，大大震撼了业界。 Flicker 提出了几个核心理念：</p><ul><li>业务快速发展，需要拥抱变更，小步快跑</li><li>Ops 目标不是为了网站稳定和快速，而是推动业务快速发展</li><li>基于自动化工具提高 Dev / Ops 联接：代码版本管理、监控</li><li>高效沟通：IRC / IM Robot（现在那些 ChatBot 套路，10 年前就被 Flicker 玩过了）</li><li>信任、透明、高效、互助的沟通文化</li></ul><p>真是让人难以想象，今天各种培训公司和一些知名大 V 在呼唤这些 DevOps 理念， 竟然在 2009 年一份幻灯片中就展现淋漓尽致。经典总是不过时，在尘封下闪耀着智慧光芒。 有些人将 DevOps 和运维自动化等同，这是只看到表象。 DevOps 目标是提高业务系统交付速度，并为之提供相关工具、制度和服务。 一些个人或培训机构添油加醋和衍生含义，都是围绕这 DevOps 本质而发散。</p><p>接下来聊聊 SRE 历史， SRE 出现要晚一些。在 2003 年时候 Google 的 Ben Treynor 招募了几个软件工程师，这个团队设立目的是帮助 Google 生产环境服务运行更稳定、健壮、可靠。 不同于中小型规模公司，Google 服务于十几亿用户服务，短暂服务不可用会带来致命后果。 因此 Google 走在了时代最前面，SRE 产生了。 这个职位为大规模集群服务，小型团队不需要这样职位设定（可能也招不起真正 SRE ）。 Google 在探索若干年之后，SRE 团队开始将自己心得体会写在线上，并在 2016 年将此书出版。</p><h2><span id="两者的职能不同">两者的职能不同</span></h2><p>现在不少公司将 DevOps 职能单独抽取出来，称之为 DevOps 工程师。 那让我们看看 DevOps 工程师关心什么：DevOps 文化目的是提交交付速度， DevOps 工程师就自然会关心软件 / 服务的整个生命周期。 一个简单的公式：速度 = 总量 / 时间，添上工程行业术语，即 交付速度 = （（功能特性 * 工程质量） / 交付时间） * 交付风险。</p><p>功能特性交给产品经理和项目经理管理，DevOps 工程师需要关心剩下几个因素：工程质量 / 交付时间 / 交付风险。 DevOps 工程师职能如下：</p><ul><li>管理应用全生命周期（需求、设计、开发、QA、发布、运行）</li><li>关注全流程效率提升，挖掘瓶颈点并将其解决</li><li>自动化运维平台设计和研发工作（标准化、自动化、平台化）</li><li>支持运维系统，包括 虚拟化技术、资源管理技术、监控技术、网络技术</li></ul><p>SRE 关键词是「高扩展性」「高可用性」。高扩展性是指当服务用户数量暴增时， 应用系统以及支撑其服务（服务器资源、网络系统、数据库资源）可以在不调整系统结构，不强化机器本身性能 ，仅仅增加实例数量方式进行扩容。高可用性是指，应用架构中任何环节出现不可用时，比如应用服务、网关、数据库 等系统挂掉，整个系统可以在可预见时间内恢复并重新提供服务。当然，既然是「高」可用， 那么这个时间一般期望在分钟级别。SRE 职能可以概括为以下：</p><ul><li>为 应用、中间件、基础设施等提供 选型、设计、开发、容量规划、调优、故障处理</li><li>为业务系统提供基于可用性、可扩展性考虑决策，参与业务系统设计和实施</li><li>定位、处理、管理故障，优化导致故障发生相关部件</li><li>提高各部件资源利用率</li></ul><h2><span id="工作内容不同">工作内容不同</span></h2><p>职责不同导致两个职位工作内容也不尽相同，我将 DevOps 工程师和 SRE 工程师职能列举如下：</p><ul><li><p>DevOps</p><ul><li>设定应用生命管理周期制度，扭转流程</li><li>开发、管理 开发工程师 /QA 工程师使用 开发平台系统</li><li>开发、管理 发布系统</li><li>开发、选型、管理 监控、报警系统</li><li>开发、管理 权限系统</li><li>开发、选型、管理 CMBD</li><li>管理变更</li><li>管理故障</li></ul></li><li><p>SRE</p><ul><li>管理变更</li><li>管理故障</li><li>制定 SLA 服务标准</li><li>开发、选型、管理 各类中间件</li><li>开发、管理 分布式监控系统</li><li>开发、管理 分布式追踪系统</li><li>开发、管理 性能监控、探测系统（dtrace、火焰图）</li><li>开发、选型、培训 性能调优工具</li></ul></li></ul><p>很有趣的对比，DevOps 和 SRE 都会关心应用生命周期，特别是生命周期里面的变更和故障。 但是 DevOps 工作内容是主要为开发链路服务，一个 DevOps Team 通常会提供一串工具链， 这其中会包括：开发工具、版本管理工具、CI 持续交付工具、CD 持续发布工具、报警工具、故障处理。 而 SRE Team 则关注更为关注变更、故障、性能、容量相关问题，会涉及具体业务，产出工具链会有： 容量测量工具、Logging 日志工具、Tracing 调用链路跟踪工具、Metrics 性能度量工具、监控报警工具等。</p><h2><span id="devops-和-sre-关系">DevOps 和 SRE 关系</span></h2><p>DevOps 首先是一种文化，后期逐渐独立成一个职位；SRE 一开始就明确是一个职位； 不少同学把 DevOps 和 SRE 搞混，是被两者表象锁迷惑，看上去这两者都有的工具属性、自动化要求也相似。 甚至有一些开发同学把这类运维工作都统一理解为：服务器 + 工具 + 自动化。这是盲人摸象，管中窥豹。</p><p>从技能上来说，两者都需要较强的运维技能。 在职业发展天花板上，DevOps 可能缺乏 SRE 在一些专业领域的技能： 计算机体系结构能力；高吞吐高并发优化能力；可扩展系统设计能力；复杂系统设计能力；业务系统排查能力。 两者都需要软实力，但是 SRE 面临复杂度更高，挑战更大，要求也更高：</p><p>DevOps 具有普遍意义，现代互联网公司都需要 DevOps，但是并非所有团队对高可用性、高扩展性存在需求，它们不需要 SRE。 DevOps 工程师掌握相关技能之后，也有机会可以发展为 SRE 工程师。 而一位合格 SRE 工程师，在有选择情况下面，我相信不会去转型为 DevOps 工程师。</p><p>从专业背景来看，无论是 DevOps 还是 SRE 工程师，都需要研发背景，前者需要开发工具链，后者需要有较强架构设计经验。 如果有运维工程师想转型成为 DevOps 或者 SRE，那么需要补上相关技术知识。 毕竟，不是会搭建一套 Jenkins + Kubernetes 就可以自称为 DevOps / SRE 工程师。</p><p>怎么样，有没有解开这几个常见误区呢？希望你看到这里可以豁然开朗，最后附上两个工程师的技能点， 期望有志成为这两种工程师的同学，加油努力。</p><h2><span id="附录技能点">附录：技能点</span></h2><p>DevOps：</p><ul><li><p>Operator 技能</p><ul><li><p>Linux Basis</p><ul><li>基本命令操作</li><li>Linux FHS（Filesystem Hierarchy Standard 文件系统层次结构标准）</li><li>Linux 系统（差异、历史、标准、发展）</li></ul></li><li><p>脚本</p><ul><li>Bash / Python</li></ul></li><li><p>基础服务</p><ul><li>DHCP / NTP / DNS / SSH / iptables / LDAP / CMDB</li></ul></li><li><p>自动化工具</p><ul><li>Fabric / Saltstack / Chef / Ansible</li></ul></li><li><p>基础监控工具</p><ul><li>Zabbix / Nagios / Cacti</li></ul></li><li><p>虚拟化</p><ul><li>KVM 管理 / XEN 管理 / vSphere 管理 / Docker</li><li>容器编排 / Mesos / Kubernetes</li></ul></li><li><p>服务</p><ul><li>Nginx / F5 / HAProxy / LVS 负载均衡</li><li>常见中间件 Operate（启动、关闭、重启、扩容）</li></ul></li></ul></li><li><p>Dev</p><ul><li><p>语言</p><ul><li>Python</li><li>Go（可选）</li><li>Java（了解部署）</li></ul></li><li><p>流程和理论</p><ul><li>Application Life Cycle</li><li>12 Factor</li><li>微服务概念、部署、生命周期</li><li>CI 持续集成 / Jenkins / Pipeline / Git Repo Web Hook</li><li>CD 持续发布系统</li></ul></li><li><p>基础设施</p><ul><li>Git Repo / Gitlab / Github</li><li>Logstash / Flume 日志收集</li><li>配置文件管理（应用、中间件等）</li><li>Nexus / JFrog / Pypi 包依赖管理</li><li>面向 开发 / QA 开发环境管理系统</li><li>线上权限分配系统</li><li>监控报警系统</li><li>基于 Fabric / Saltstack / Chef / Ansible 自动化工具开发</li></ul></li></ul></li></ul><p>SRE：</p><ul><li><p>语言和工程实现</p><ul><li><p>深入理解开发语言（假设是 Java）</p><ul><li>业务部门使用开发框架</li><li>并发、多线程和锁</li><li>资源模型理解：网络、内存、CPU</li><li>故障处理能力（分析瓶颈、熟悉相关工具、还原现场、提供方案）</li></ul></li><li><p>常见业务设计方案和陷阱（比如 Business Modeling，N+1、远程调用、不合理 DB 结构）</p></li><li><p>MySQL / Mongo OLTP 类型查询优化</p></li><li><p>多种并发模型，以及相关 Scalable 设计</p></li></ul></li><li><p>问题定位工具</p><ul><li>容量管理</li><li>Tracing 链路追踪</li><li>Metrics 度量工具</li><li>Logging 日志系统</li></ul></li><li><p>运维架构能力</p><ul><li>Linux 精通，理解 Linux 负载模型，资源模型</li><li>熟悉常规中间件（MySQL Nginx Redis Mongo ZooKeeper 等），能够调优</li><li>Linux 网络调优，网络 IO 模型以及在语言里面实现</li><li>资源编排系统（Mesos / Kubernetes）</li></ul></li><li><p>理论</p><ul><li>容量规划方案</li><li>熟悉分布式理论（Paxos / Raft / BigTable / MapReduce / Spanner 等），能够为场景决策合适方案</li><li>性能模型（比如 Pxx 理解、Metrics、Dapper）</li><li>资源模型（比如 Queuing Theory、负载方案、雪崩问题）</li><li>资源编排系统（Mesos / Kurbernetes）</li></ul></li></ul><blockquote><p>本文转载自：「 知乎 」，原文：<a href="https://tinyurl.com/fbjbzcn4" target="_blank" rel="noopener">https://tinyurl.com/fbjbzcn4</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DevOps-和-SRE&quot;&gt;DevOps 和 SRE&lt;/h2&gt;
&lt;p&gt;最近有一位朋友和我聊职业发展方向问题，聊了不少 DevOps 和 SRE 话题。 我几年前刚接触这两个概念时也常常将之混淆，可惜当时没有人来解答我困惑。 现在这虽然已经极为流行，但是我发现我这位朋友对这两个职位还存在一些误区。 于是我给了一些见解并整理成文章以饕大众。&lt;/p&gt;
&lt;p&gt;最常见的误区：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DevOps 新概念，好高级哦&lt;/li&gt;
&lt;li&gt;SRE 是高级版 DevOps&lt;/li&gt;
&lt;li&gt;运维可以轻松转身 DevOps 工程师&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;DevOps-和-SRE-定义&quot;&gt;DevOps 和 SRE 定义&lt;/h2&gt;
&lt;p&gt;DevOps 是字面上 Dev 开发 / Ops 运维两者组合， 严格意义上 DevOps 如下（via DevOps - Wikipedia）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev） ”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SRE 全称是 Site Reliability Engineering，最早是由 Google 提出，并且在其工程实践中发扬光大。 他们还出了一本同名书籍「Site Reliability Engineering」， 让这个理念在互联网工程师圈子里广泛传播。&lt;/p&gt;
&lt;p&gt;Google 对 SRE 解释是（via Site Reliability Engineering - Wikipedia）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Site reliability engineering (SRE) is a discipline that incorporates aspects of software engineering and applies that to operations whose goals are to create ultra-scalable and highly reliable software systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我将其翻译翻译为中文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网站稳定性工程师是致力于打造「高扩展、高可用系统」，并将其贯彻为原则的软件工程师。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从定义来看，DevOps 是文化、运动和惯例，而 SRE 是有严格任职要求的职位。 文化是软性定义，文化有更多概念可以捏造，而 SRE 定义精准，就少了想象空间（也可能 SRE 门槛高 ）。 按 Google 给出的说法是，SRE 工程师实践了 DevOps 文化。这个观点没错，但是国内的 DevOps 逐步独立出 DevOps 工程师， 所以在本文，我着重讨论的是 DevOps 工程师和 SRE 工程师两种职位对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DevOps" scheme="https://www.hi-linux.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>最 COOL 的 Kubernetes 网络方案 CILIUM 入门教程</title>
    <link href="https://www.hi-linux.com/posts/60044.html"/>
    <id>https://www.hi-linux.com/posts/60044.html</id>
    <published>2021-06-03T01:00:00.000Z</published>
    <updated>2021-06-04T06:19:36.391Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>最近业界使用范围最广的K8S CNI网络方案<a href="https://www.projectcalico.org/introducing-the-calico-ebpf-dataplane/" target="_blank" rel="noopener">Calico宣布支持eBPF</a>，而作为第一个通过 eBPF 实现了 kube-proxy 所有功能的 K8S 网络方案——Cilium，它的先见之名是否能转成优势，继而成为 CNI 新的头牌呢？今天我们一起来入门最 Cool Kubernetes 网络方案 Cilium。</p></blockquote><h2><span id="cilium介绍">Cilium介绍</span></h2><blockquote><p>以下基于<a href="https://cilium.readthedocs.io/en/stable/" target="_blank" rel="noopener">Cilium官网文档</a>翻译整理。</p></blockquote><h3><span id="当前趋势">当前趋势</span></h3><p>现代数据中心的应用系统已经逐渐转向基于微服务架构的开发体系，一个微服务架构的应用系统是由多个小的独立的服务组成，它们之间通过轻量通信协议如 HTTP、gRPC、Kafka 等进行通信。微服务架构下的服务天然具有动态变化的特点，结合容器化部署，时常会引起大规模的容器实例启动或重启。要确保这种向高度动态化的微服务应用之间的安全可达，既是挑战，也是机遇。</p><h3><span id="现有问题">现有问题</span></h3><p>传统的 Linux 网络访问安全控制机制（如 iptables）是基于静态环境的IP地址和端口配置网络转发、过滤等规则，但是 IP 地址在微服务架构下是不断变化的，非固定的；出于安全目的，协议端口(例如 HTTP 传输的 TCP 端口 80)也不再固定用来区分应用系统。为了匹配大规模容器实例快速变化的生命周期，传统网络技术需要维护成千上万的负载均衡规则和访问控制规则，并且需要以不断增长的频率更新这些规则，而如果没有准确的可视化功能，要维护这些规则也是十分困难，这些对传统网络技术的可用性和性能都是极大的挑战。比如经常会有人对 kube-proxy 基于 iptables 的服务负载均衡功能在大规模容器场景下具有严重的性能瓶颈，同时由于容器的创建和销毁非常频繁，基于 IP 做身份关联的故障排除和安全审计等也很难实现。</p><a id="more"></a><h3><span id="解决方案">解决方案</span></h3><p>Cilium 作为一款 Kubernetes CNI 插件，从一开始就是为大规模和高度动态的容器环境而设计，并且带来了 API 级别感知的网络安全管理功能，通过使用基于 Linux 内核特性的新技术——<a href="https://docs.cilium.io/en/stable/bpf/" target="_blank" rel="noopener">BPF</a>，提供了基于 service/pod/container 作为标识，而非传统的 IP 地址，来定义和加强容器和 Pod 之间网络层、应用层的安全策略。因此，Cilium 不仅将安全控制与寻址解耦来简化在高度动态环境中应用安全性策略，而且提供传统网络第 3 层、4 层隔离功能，以及基于 http 层上隔离控制，来提供更强的安全性隔离。</p><p>另外，由于 BPF 可以动态地插入控制 Linux 系统的程序，实现了强大的安全可视化功能，而且这些变化是不需要更新应用代码或重启应用服务本身就可以生效，因为 BPF 是运行在系统内核中的。</p><p>以上这些特性，使 Cilium 能够在大规模容器环境中也具有高度可伸缩性、可视化以及安全性。</p><p><img src="https://img.hi-linux.com/staticfile/cilium-arch2020-1024x584-2021-05-29-H9lm7N.png" alt></p><h2><span id="部署-cilium">部署 Cilium</span></h2><p>部署 Cilium 非常简单，可以通过单独的 yaml 文件部署全部组件（目前我使用了这个方式部署了1.7.1 版本），也可以通过 helm chart 一键完成。重要的是部署环境和时机：</p><ol><li><p>官方建议所有部署节点都使用 Linux 最新稳定内核版本，这样所有的功能都能启用，具体部署环境建议可以参照<a href="https://cilium.readthedocs.io/en/stable/install/system_requirements/" target="_blank" rel="noopener">这里</a>。</p></li><li><p>作为一个 Kubernetes 网络组件，它应该在部署 Kubernetes 其他基础组件之后，才进行部署。这里，我自己遇到的问题是，因为还没有 CNI 插件，coredns 组件的状态一直是 pending的，直到部署完 Cilium 后，coredns 完成了重置变成running状态。</p></li></ol><p>下图是 Cilium 的整体部署组件图：</p><p><img src="https://img.hi-linux.com/staticfile/cilium-provision-2021-05-29-mP4svg.png" alt></p><h2><span id="测试安装效果">测试安装效果</span></h2><p>官方提供了一个<a href="https://github.com/cilium/cilium/blob/master/examples/kubernetes/connectivity-check/connectivity-check.yaml" target="_blank" rel="noopener">connectivity检查工具</a>，以检测部署好的 Cilium 是否工作正常。如果你的网络环境有些限制，我作了一些简单修改，可以参照<a href="https://github.com/nevermosby/K8S-CNI-Cilium-Tutorial/blob/master/cilium/connectivity-check.yaml" target="_blank" rel="noopener">这里</a>。部署起来很简单，请确保至少有两个可用的节点，否则有几个 deployment 会无法成功运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl apply -f connectivity-check.yaml</span><br><span class="line"></span><br><span class="line">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">echo-a                                  1&#x2F;1     1            1           16d</span><br><span class="line">echo-b                                  1&#x2F;1     1            1           16d</span><br><span class="line">host-to-b-multi-node-clusterip          1&#x2F;1     1            1           16d</span><br><span class="line">host-to-b-multi-node-headless           1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a                                1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a-allowed-cnp                    1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a-external-1111                  1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a-l3-denied-cnp                  1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-b-intra-node                     1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-b-multi-node-clusterip           1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-b-multi-node-headless            1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-external-fqdn-allow-google-cnp   1&#x2F;1     1            1           16d</span><br></pre></td></tr></table></figure><p>如果所有的 deployment 都能成功运行起来，说明 Cilium 已经成功部署并工作正常。</p><p><img src="https://img.hi-linux.com/staticfile/draggedimage-13-2021-05-29-wnSUP8.png" alt></p><h2><span id="网络可视化神器-hubble">网络可视化神器 Hubble</span></h2><p>上文提到了 Cilium 强大之处就是提供了简单高效的网络可视化功能，它是通过<a href="https://github.com/cilium/hubble" target="_blank" rel="noopener">Hubble</a>组件完成的。<a href="https://cilium.io/blog/2019/11/19/announcing-hubble" target="_blank" rel="noopener">Cilium在1.7版本后推出并开源了Hubble</a>，它是专门为网络可视化设计，能够利用 Cilium 提供的 eBPF 数据路径，获得对 Kubernetes 应用和服务的网络流量的深度可见性。这些网络流量信息可以对接 Hubble CLI、UI 工具，可以通过交互式的方式快速诊断如与 DNS 相关的问题。除了 Hubble 自身的监控工具，还可以对接主流的云原生监控体系—— Prometheus 和  Grafana，实现可扩展的监控策略。</p><p><img src="https://img.hi-linux.com/staticfile/hubble_arch-2021-05-29-Z4N8xr.png" alt></p><p><img src="https://cilium.io/static/hubble-arch-aa2f9af8628edc26f6c8473854d97a8a-50393.png" alt></p><h3><span id="部署-hubble-和-hubble-ui">部署 Hubble 和 Hubble UI</span></h3><p>官方提供了基于 Helm Chart 部署方式，这样可以灵活控制部署变量，实现不同监控策略。出于想要试用 hubble UI 和对接 Grafana，我是这样的部署的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; helm template hubble \</span><br><span class="line">    --namespace kube-system \</span><br><span class="line">    --set metrics.enabled&#x3D;&quot;&#123;dns:query;ignoreAAAA;destinationContext&#x3D;pod-short,drop:sourceContext&#x3D;pod;destinationContext&#x3D;pod,tcp,flow,port-distribution,icmp,http&#125;&quot; \</span><br><span class="line">    --set ui.enabled&#x3D;true \</span><br><span class="line">    &gt; hubble.yaml</span><br><span class="line">&gt; kubectl apply -f hubble.yaml</span><br><span class="line"># 包含两个组件</span><br><span class="line"># - daemonset hubble</span><br><span class="line"># - deployment hubble UI</span><br><span class="line">&gt; kubectl get pod -n kube-system |grep hubble</span><br><span class="line">hubble-67ldp                       1&#x2F;1     Running   0          21h</span><br><span class="line">hubble-f287p                       1&#x2F;1     Running   0          21h</span><br><span class="line">hubble-fxzms                       1&#x2F;1     Running   0          21h</span><br><span class="line">hubble-tlq64                       1&#x2F;1     Running   1          21h</span><br><span class="line">hubble-ui-5f9fc85849-hkzkr         1&#x2F;1     Running   0          15h</span><br><span class="line">hubble-vpxcb                       1&#x2F;1     Running   0          21h</span><br></pre></td></tr></table></figure><h3><span id="运行效果">运行效果</span></h3><p>由于默认的 Hubble UI 只提供了 ClusterIP 类似的 service，无法通过外部访问。因此需要创建一个 NodePort 类型的 service，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># hubble-ui-nodeport-svc.yaml</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  name: hubble-ui-np</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: hubble-ui</span><br><span class="line">  ports:</span><br><span class="line">    - name: http</span><br><span class="line">      port: 12000</span><br><span class="line">      nodePort: 32321</span><br><span class="line">  type: NodePort</span><br></pre></td></tr></table></figure><p>执行 <code>kubectl apply -f hubble-ui-nodeport-svc.yaml</code>，就可以通过任意集群节点 IP 地址加上 32321 端口访问 Hubble UI 的 web 服务了。打开效果如下所示：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-000-2021-05-29-tnYtAT.png" alt></p><ul><li>页面上半部分是之前部署的一整套 conectivity-check 组件的数据流向图，官方叫做 <code>Service Map</code>，默认情况下可以自动发现基于网络 3 层和 4 层的访问依赖路径，看上去非常 cool，也有点分布式链路追踪图的感觉。点击某个服务，还能看到更为详细的关系图：</li></ul><p><img src="https://img.hi-linux.com/staticfile/service-map-ex001-2021-05-29-fFJ0Ts.png" alt></p><ul><li>下图是 kube-system 命名空间下的数据流图，能看到 Hubble-UI 组件和 Hubble 组件是通过gRPC 进行通信的，非常有趣。但令人感到的好奇的是，为何没有显示 Kubernetes 核心组件之间的调用关系图:</li></ul><p><img src="https://img.hi-linux.com/staticfile/draggedimage-1-1-2021-05-29-za8OnA.png" alt></p><p>页面的下半部分默认显示的是对于每条数据流路径的详细描述，包括发起请求的 pod 名称、发起请求的 service 名称、请求目标的 pod 名称、请求目标的 service 名称、目标 IP、目标端口、目标 7 层信息、请求状态、最后一次查看时间等，如下图所示：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-flow-000-2021-05-29-HqW2Pi.png" alt></p><p>点击任意一条 flow，可以查看到更多详细信息：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-flow-001-2021-05-29-11nSZ4.png" alt></p><p>页面的下半部分可以通过点击切换成显示 network policy 模式，列出了当前命名空间下所有的网络策略：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-policy-000-2021-05-29-HRJMNo.png" alt></p><p>如果想开启网络 7 层的可视化观察，就需要对目标 pod 进行 annotations ，感兴趣可以看<a href="http://docs.cilium.io/en/stable/policy/visibility/" target="_blank" rel="noopener">这里</a>，就不在入门篇详述了。</p><p>这样的网络可视化是不是你梦寐以求的，绝对能在排查请求调用问题的时候帮上大忙。</p><h3><span id="对接-grafana-prometheus">对接 Grafana + Prometheus</span></h3><p>如果你跟一样是 Grafana+ Prometheus 的忠实粉丝，那么使 Hubble 对接它们就是必然操作了。仔细的同学已经发现之前 helm template 的玄机了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--set metrics.enabled&#x3D;&quot;&#123;dns:query;ignoreAAAA;destinationContext&#x3D;pod-short,drop:sourceContext&#x3D;pod;destinationContext&#x3D;pod,tcp,flow,port-distribution,icmp,http&#125;&quot;</span><br><span class="line"># 上面的设置，表示开启了 hubble 的 metrics 输出模式，并输出以上这些信息。</span><br><span class="line"># 默认情况下，Hubble daemonset 会自动暴露 metrics API 给 Prometheus。</span><br></pre></td></tr></table></figure><p>你可以对接现有的 Grafana+Prometheus 服务，也可以部署一个简单的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下面的命令会在命名空间 cilium-monitoring 下部署一个 Grafana 服务和 Prometheus 服务</span><br><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;cilium&#x2F;cilium&#x2F;v1.6&#x2F;examples&#x2F;kubernetes&#x2F;addons&#x2F;prometheus&#x2F;monitoring-example.yaml</span><br><span class="line"># 创建对应 NodePort Service，方便外部访问 web 服务</span><br><span class="line">$ kubectl expose deployment&#x2F;grafana --type&#x3D;NodePort --port&#x3D;3000 --name&#x3D;gnp -n cilium-monitoring </span><br><span class="line">$ kubectl expose deployment&#x2F;prometheus --type&#x3D;NodePort --port&#x3D;9090 --name&#x3D;pnp -n cilium-monitoring</span><br></pre></td></tr></table></figure><p>完成部署后，打开 Grafana 网页，导入官方制作的<a href="https://github.com/cilium/hubble/blob/master/tutorials/deploy-hubble-and-grafana/grafana.json" target="_blank" rel="noopener">dashboard</a>，可以快速创建基于 Hubble 的 metrics 监控。等待一段时间，就能在 Grafana 上看到数据了：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-grafana-000-2021-05-29-trvJCq.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/hubble-grafana-001-2021-05-29-sF10Ae.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/hubble-grafana-002-2021-05-29-a0lhJn.png" alt></p><p>Cilium 配合 Hubble，的确非常好用！</p><h2><span id="取代-kube-proxy-组件">取代 kube-proxy 组件</span></h2><p>Cilium 另外一个很大的宣传点是宣称已经全面实现kube-proxy的功能，包括 <code>ClusterIP</code>, <code>NodePort</code>, <code>ExternalIPs</code> 和 <code>LoadBalancer</code>，可以完全取代它的位置，同时提供更好的性能、可靠性以及可调试性。当然，这些都要归功于 eBPF 的能力。</p><p>官方文档中提到，如果你是在先有 kube-proxy 后部署的 Cilium，那么他们是一个 “共存” 状态，Cilium 会根据节点操作系统的内核版本来决定是否还需要依赖 kube-proxy 实现某些功能，可以通过以下手段验证是否能停止 kube-proxy 组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 检查 Cilium 对于取代 kube-proxy 的状态</span><br><span class="line">&gt; kubectl exec -it -n kube-system [Cilium-agent-pod] -- cilium status | grep KubeProxyReplacement</span><br><span class="line"># 默认是 Probe 状态</span><br><span class="line"># 当 Cilium agent 启动并运行，它将探测节点内核版本，判断 BPF 内核特性的可用性，</span><br><span class="line"># 如果不满足，则通过依赖 kube-proxy 来补充剩余的 Kubernetess，</span><br><span class="line"># 并禁用 BPF 中的一部分功能</span><br><span class="line">KubeProxyReplacement:   Probe   [NodePort (SNAT, 30000-32767), ExternalIPs, HostReachableServices (TCP, UDP)]</span><br><span class="line"># 查看 Cilium 保存的应用服务访问列表</span><br><span class="line"># 有了这些信息，就不需要 kube-proxy 进行中转了</span><br><span class="line">&gt; kubectl exec -it -n kube-system [Cilium-agent-pod] -- cilium service list</span><br><span class="line">ID   Frontend              Service Type   Backend</span><br><span class="line">1    10.96.0.10:53         ClusterIP      1 &#x3D;&gt; 100.64.0.98:53</span><br><span class="line">                                          2 &#x3D;&gt; 100.64.3.65:53</span><br><span class="line">2    10.96.0.10:9153       ClusterIP      1 &#x3D;&gt; 100.64.0.98:9153</span><br><span class="line">                                          2 &#x3D;&gt; 100.64.3.65:9153</span><br><span class="line">3    10.96.143.131:9090    ClusterIP      1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">4    10.96.90.39:9090      ClusterIP      1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">5    0.0.0.0:32447         NodePort       1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">6    10.1.1.179:32447      NodePort       1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">7    100.64.0.74:32447     NodePort       1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">8    10.96.190.1:80        ClusterIP</span><br><span class="line">9    10.96.201.51:80       ClusterIP</span><br><span class="line">10   10.96.0.1:443         ClusterIP      1 &#x3D;&gt; 10.1.1.171:6443</span><br><span class="line">                                          2 &#x3D;&gt; 10.1.1.179:6443</span><br><span class="line">                                          3 &#x3D;&gt; 10.1.1.188:6443</span><br><span class="line">11   10.96.129.193:12000   ClusterIP      1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">12   0.0.0.0:32321         NodePort       1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">13   10.1.1.179:32321      NodePort       1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">14   100.64.0.74:32321     NodePort       1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">15   10.96.0.30:3000       ClusterIP</span><br><span class="line">16   10.96.156.253:3000    ClusterIP</span><br><span class="line">17   100.64.0.74:31332     NodePort</span><br><span class="line">18   0.0.0.0:31332         NodePort</span><br><span class="line">19   10.1.1.179:31332      NodePort</span><br><span class="line">20   10.96.131.215:12000   ClusterIP      1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line"># 查看 iptables 是否有 kube-proxy 维护的规则</span><br><span class="line">&gt; iptables-save | grep KUBE-SVC</span><br><span class="line">&lt;Empty&gt; # 说明 kube-proxy 没有维护任何应用服务跳转，即可以停止它了。</span><br></pre></td></tr></table></figure><h2><span id="小结">小结</span></h2><p>Cilium 作为当下最 Cool 的 Kubernetes CNI 网络插件，还有很多特性，如高阶 network policy、7 层流量控制等，这款基于 BPF/eBPF 打造出的简单、高效、易用的网络管理体验，有机会大家都来试用吧。</p><blockquote><p>本文转载自：「  MY X FILES 」，原文：<a href="https://tinyurl.com/54h8zzvd" target="_blank" rel="noopener">https://tinyurl.com/54h8zzvd</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近业界使用范围最广的K8S CNI网络方案&lt;a href=&quot;https://www.projectcalico.org/introducing-the-calico-ebpf-dataplane/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Calico宣布支持eBPF&lt;/a&gt;，而作为第一个通过 eBPF 实现了 kube-proxy 所有功能的 K8S 网络方案——Cilium，它的先见之名是否能转成优势，继而成为 CNI 新的头牌呢？今天我们一起来入门最 Cool Kubernetes 网络方案 Cilium。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Cilium介绍&quot;&gt;Cilium介绍&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;以下基于&lt;a href=&quot;https://cilium.readthedocs.io/en/stable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cilium官网文档&lt;/a&gt;翻译整理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;当前趋势&quot;&gt;当前趋势&lt;/h3&gt;
&lt;p&gt;现代数据中心的应用系统已经逐渐转向基于微服务架构的开发体系，一个微服务架构的应用系统是由多个小的独立的服务组成，它们之间通过轻量通信协议如 HTTP、gRPC、Kafka 等进行通信。微服务架构下的服务天然具有动态变化的特点，结合容器化部署，时常会引起大规模的容器实例启动或重启。要确保这种向高度动态化的微服务应用之间的安全可达，既是挑战，也是机遇。&lt;/p&gt;
&lt;h3 id=&quot;现有问题&quot;&gt;现有问题&lt;/h3&gt;
&lt;p&gt;传统的 Linux 网络访问安全控制机制（如 iptables）是基于静态环境的IP地址和端口配置网络转发、过滤等规则，但是 IP 地址在微服务架构下是不断变化的，非固定的；出于安全目的，协议端口(例如 HTTP 传输的 TCP 端口 80)也不再固定用来区分应用系统。为了匹配大规模容器实例快速变化的生命周期，传统网络技术需要维护成千上万的负载均衡规则和访问控制规则，并且需要以不断增长的频率更新这些规则，而如果没有准确的可视化功能，要维护这些规则也是十分困难，这些对传统网络技术的可用性和性能都是极大的挑战。比如经常会有人对 kube-proxy 基于 iptables 的服务负载均衡功能在大规模容器场景下具有严重的性能瓶颈，同时由于容器的创建和销毁非常频繁，基于 IP 做身份关联的故障排除和安全审计等也很难实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="微服务" scheme="https://www.hi-linux.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款可快速全量交付 Kubernetes 集群分布式应用的神器 Sealer</title>
    <link href="https://www.hi-linux.com/posts/29602.html"/>
    <id>https://www.hi-linux.com/posts/29602.html</id>
    <published>2021-06-02T01:00:00.000Z</published>
    <updated>2021-06-04T06:20:55.416Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="什么是集群镜像">什么是集群镜像</span></h2><p>顾名思义，和操作系统 .iso 镜像或 Docker 镜像类似，集群镜像是<strong>用一定的技术手段把整个集群的所有文件以一定格式打成的一个资源包</strong>。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210601143614113-2021-06-01-u9cFX4.jpg" alt></p><p>对比单机和集群会发现一些的有趣现象：</p><ul><li>单机有计算、存储、网络等驱动；集群有 CNI/CSI/CRI 实现像是集群的驱动。</li><li>单机有 Ubuntu、Centos 操作系统；集群中可以把 Kubernetes 看成云操作系统。</li><li>单机上可以运行 Docker 容器或虚拟机；相当于一个运行的实例，集群上也有运行着 K8s 的实例。</li><li>单机上有虚拟机镜像，Docker 镜像；随着云计算技术的发展，集群上也会抽象出类似的镜像技术。</li></ul><p>以基于 Kubernetes 的集群镜像为例，里面包含了除操作系统以外的所有文件：</p><ul><li>docker 依赖的二进制与 Systemd 配置、Dockerd 配置，以及一个私有的容器镜像仓库。</li><li>Kubernetes 核心组件二进制、容器镜像、kubelet system 配置等。</li><li>应用需要用到的 yaml 配置或 helm chart，以及应用的容器镜像。</li><li>其它脚本、配置与二进制工具等应用运行需要的所有依赖。</li></ul><p>同样，集群镜像运行时肯定不是起一个容器或者装在一台机器上，而是这个镜像可以直接安装到多台服务器上或者直接对接到公有云的基础设施上。</p><a id="more"></a><h2><span id="什么是-sealer">什么是 sealer</span></h2><p>sealer[ˈsiːlər]是一款分布式应用打包交付运行的解决方案，通过把分布式应用及其数据库中间件等依赖一起打包以解决复杂应用的交付问题。</p><p>sealer 构建出来的产物我们称之为集群镜像, 集群镜像里内嵌了一个 kubernetes, 解决了分布式应用的交付一致性问题。集群镜像可以 push 到 registry 中共享给其他用户使用，也可以在官方仓库中找到非常通用的分布式软件直接使用。</p><p>Docker 解决了单个容器的镜像化问题，而 sealer 把 kubernetes 看成操作系统，在这个更高的抽象纬度上做出来的镜像就是集群镜像。sealer 通过把整个集群打包，实现了分布式软件的 Build Share Run!!!</p><h3><span id="特性">特性</span></h3><ul><li>[x] 极其简单的方式在生产环境中或者离线环境中安装 kubernetes、以及 kubernetes 生态中其它软件</li><li>[x] 通过 Kubefile 可以非常简单的自定义 kubernetes 集群镜像对集群和应用进行打包，并可以提交到仓库中进行分享</li><li>[x] 强大的生命周期管理能力，以难以想象的简单的方式去做如集群升级，集群备份恢复，节点阔缩等操作</li><li>[x] 速度极快 3min 以内完成集群安装</li><li>[x] 支持 ARM x86, v1.20 以上版本支持 containerd，几乎兼容所有支持 systemd 的 linux 操作系统</li><li>[x] 不依赖 ansible haproxy keepalived, 高可用通过 ipvs 实现，占用资源少，稳定可靠</li><li>[x] 官方仓库中有非常多的生态软件镜像可以直接使用，包含所有依赖，一键安装</li></ul><h3><span id="使用场景">使用场景</span></h3><p>试想我们要去交付一个 SaaS 应用，它依赖了 MySQL/ES/Redis 这些数据库和中间件，所有东西都在 Kubernetes 上进行编排，如果没有集群镜像时，要做如下操作：</p><ol><li>找个工具去安装 K8s 集群</li><li><code>helm install mysql es redis...</code> ，如果是离线环境可能还需要导入容器镜像</li><li><code>kubectl apply yoursaas</code></li></ol><p>看似好像也没那么复杂，但其实从整个项目交付的角度来说，以上操作是面向过程极易出错的。</p><p>现在如果提供另外一个方式，只需一条命令就可解决上面的问题，你会不会用？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sealer run your-saas-application-with-mysql-redis-es:latest</span><br></pre></td></tr></table></figure><p>可以看到，只需要 run 一个集群镜像，整个集群就被交付了，细节复杂的操作都被屏蔽掉了，而且任何应用都可以使用相同的方式运行。这个集群镜像是怎么来的呢？</p><p><img src="https://img.hi-linux.com/staticfile/640-20210601154712544-2021-06-01-qHQrjk.jpg" alt></p><p>如上图所示：我们只需要定义一个类似 Dockerfile 的文件，将其称之为 Kubefile, 然后执行 build 命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sealer build -t your-saas-application-with-mysql-redis-es:latest .</span><br></pre></td></tr></table></figure><p>从单机和集群两个纬度进行对比，就可以一目了然：</p><p><img src="https://img.hi-linux.com/staticfile/640-20210601154902708-2021-06-01-w4g4WG.jpg" alt></p><ul><li>docker 通过 Dockerfile 构建一个 docker 镜像，使用 compose 就可以运行容器。</li><li>sealer 通过 Kubefile 构建一个 CloudImage，使用 Clusterfile 启动整个集群。</li></ul><h3><span id="技术原理">技术原理</span></h3><h4><span id="1-写时复制">1. 写时复制</span></h4><p>集群镜像的存储也是通过写时复制的方式实现的。这样做有两个好处：我们可以把同一集群中不同的分布式软件打在不同层，以实现复用；还可以实现直接把集群镜像 push 到 docker 镜像仓库中。</p><h4><span id="2-容器镜像缓存">2. 容器镜像缓存</span></h4><p>build 的过程中 sealer 是如何知道待构建的集群镜像里有哪些容器镜像，以及怎么把容器镜像存储下来呢？其中有一些难点问题:</p><ol><li><p>如何知道分布式软件中有哪些容器镜像？因为我们需要把这些镜像缓存下来，不管是扫描用户的 yaml 文件还是用 helm template 之后扫描都是不完美的。首先不能确定用户的编排方式是什么，其次有些软件不把镜像地址写在编排文件中，而是通过自己的程序去拉起，无法保证 build 成功运行就一定没问题。</p></li><li><p>容器镜像是需要被存储到私有仓库中打包在集群镜像里，那容器镜像仓库地址势必和编排文件中写的不一样，特别是怎么保证用户 alwayPull 的时候还是能够在私有仓库中下载到镜像？</p></li></ol><p>对待第一个问题，sealer 解决方式是：sealer build 的过程中和 Docker build 一样，会拉起一个临时的 Kubernetes 集群，并执行用户在 Kubefile 中定义的 apply 指令。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210601154910492-2021-06-01-GYb2Gl.jpg" alt></p><p>如上图所示，这样就可以保证用户依赖的所有镜像都被打包进去，无论用户使用什么样的编排方式。</p><p>第二个问题，我们打包容器镜像到私有镜像仓库中，怎样使用这个私有镜像也是个难题，假设私有镜像仓库名为 localhost:5000，肯定会和编排文件中写的不一致，对此我们有两种方式解决：</p><ul><li><p>第一种是 hack 和 docker，做了一个只要私有镜像仓库中有就直接从私有镜像中拉取，没有才去公网拉取镜像的能力。</p></li><li><p>第二种方案是无侵入 docke r的 proxy，把 docker 请求全部打给代理，让代理去决定如果私有仓库有就从私有仓库拉取。同时我们还增强了 registry 的能力让 registry 可以 cache 多个远程仓库的能力。</p></li></ul><p><img src="https://img.hi-linux.com/staticfile/640-20210601150651235-2021-06-01-veScxz.jpg" alt></p><p>sealer 的这种方案完美解决了离线场景镜像打包的问题。</p><h4><span id="3-负载均衡">3. 负载均衡</span></h4><p>sealer 的集群高可用使用了轻量级的负载均衡 lvscare。相比其它负载均衡，lvscare 非常小仅有几百行代码，而且 lvscare 只做 ipvs 规则的守护，本身不做负载非常稳定，直接在 node 上监听 apiserver，如果跪了就移除对应的规则，重新起来之后会自动加回，相当于是一个专用的负载均衡器，在 sealos 项目中也用了两年多，有广泛的实践。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210601150651248-2021-06-01-SCS83B.jpg" alt></p><h4><span id="4-运行时">4. 运行时</span></h4><p>运行时就是支撑应用运行的环境，像 base on Kuberentes 的运行时 sealer 就可以透明地支持非常简单，以 istio 为例，用户只需要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM kubernetes:v1.18.3</span><br><span class="line">RUN  curl -L https:&#x2F;&#x2F;istio.io&#x2F;downloadIstio | sh -</span><br></pre></td></tr></table></figure><p>就可以 build 出一个 istio 的运行时供自己应用使用。</p><p>对于不是 base on Kuberentes 的运行时，如 k0s k3s，可以扩展 sealer.Runtime 中的接口，这样以后就可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM k3s:v1.18.3</span><br><span class="line">RUN curl -L https:&#x2F;&#x2F;istio.io&#x2F;downloadIstio | sh -</span><br></pre></td></tr></table></figure><p>更牛的扩展比如扩展 ACK 的 runtime：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM aliyum.com&#x2F;ACK:v1.16.9RUN </span><br><span class="line">curl -L https:&#x2F;&#x2F;istio.io&#x2F;downloadIstio | sh -</span><br></pre></td></tr></table></figure><p>这种镜像会直接帮助用户应用运行到 ACK 上。以上有些能力在 roadmap 中。</p><h4><span id="5-基础设施">5. 基础设施</span></h4><p>现在很多用户都希望在云端运行自己的集群镜像，sealer 自带对接公有云能力，sealer 自己实现的基础设施管理器，得益于我们更精细的退避重试机制，30s 即可完成基础设施构建（阿里云 6 节点）性能是同类工具中的佼佼者，且 API 调用次数大大降低，配置兼容 Clusterfile。</p><h2><span id="快速体验">快速体验</span></h2><h3><span id="安装一个-kubernetes-集群">安装一个 kubernetes 集群</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sealer run kubernetes:v1.19.9 --masters 192.168.0.2 --passwd xxx</span><br></pre></td></tr></table></figure><p>如果是在云上安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ export ACCESSKEYID&#x3D;xxx</span><br><span class="line">$ export ACCESSKEYSECRET&#x3D;xxx</span><br><span class="line">$ sealer run registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;dashboard:latest</span><br><span class="line"># 或者指定节点数量运行集群</span><br><span class="line">$ sealer run registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;dashboard:latest \</span><br><span class="line">  --masters 3 --nodes 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get node</span><br><span class="line">NAME                      STATUS   ROLES    AGE   VERSION</span><br><span class="line">izm5e42unzb79kod55hehvz   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r7z   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r8z   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r9z   Ready    &lt;none&gt;   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7raz   Ready    &lt;none&gt;   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7rbz   Ready    &lt;none&gt;   18h   v1.16.9</span><br></pre></td></tr></table></figure><p>查看镜像默认启动配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sealer inspect -c registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;dashboard:latest</span><br></pre></td></tr></table></figure><h3><span id="使用-clusterfile-拉起一个-k8s-集群">使用 Clusterfile 拉起一个 K8s 集群</span></h3><p>使用已经提供好的官方基础镜像(sealer-io/kubernetes:v1.19.9)就可以快速拉起一个 k8s 集群。</p><ol><li>场景 1：在已存在的服务器上去安装，provider 类型为：BAREMETAL</li></ol><p>Clusterfile 内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: sealer.aliyun.com&#x2F;v1alpha1</span><br><span class="line">kind: Cluster</span><br><span class="line">metadata:</span><br><span class="line">  name: my-cluster</span><br><span class="line">spec:</span><br><span class="line">  image: registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;kubernetes:v1.19.9</span><br><span class="line">  provider: BAREMETAL</span><br><span class="line">  ssh:</span><br><span class="line">    passwd:</span><br><span class="line">    pk: xxx</span><br><span class="line">    pkPasswd: xxx</span><br><span class="line">    user: root</span><br><span class="line">  network:</span><br><span class="line">    interface: eth0</span><br><span class="line">    cniName: calico</span><br><span class="line">    podCIDR: 100.64.0.0&#x2F;10</span><br><span class="line">    svcCIDR: 10.96.0.0&#x2F;22</span><br><span class="line">    withoutCNI: false</span><br><span class="line">  certSANS:</span><br><span class="line">    - aliyun-inc.com</span><br><span class="line">    - 10.0.0.2</span><br><span class="line"></span><br><span class="line">  masters:</span><br><span class="line">    ipList:</span><br><span class="line">     - 172.20.125.234</span><br><span class="line">     - 172.20.126.5</span><br><span class="line">     - 172.20.126.6</span><br><span class="line">  nodes:</span><br><span class="line">    ipList:</span><br><span class="line">     - 172.20.126.8</span><br><span class="line">     - 172.20.126.9</span><br><span class="line">     - 172.20.126.10</span><br></pre></td></tr></table></figure><p>执行如下所示命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sealer apply -f Clusterfile</span><br><span class="line">$ kubectl get node</span><br><span class="line">NAME                      STATUS   ROLES    AGE   VERSION</span><br><span class="line">izm5e42unzb79kod55hehvz   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r7z   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r8z   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r9z   Ready    &lt;none&gt;   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7raz   Ready    &lt;none&gt;   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7rbz   Ready    &lt;none&gt;   18h   v1.16.9</span><br></pre></td></tr></table></figure><ol start="2"><li>场景 2：自动申请阿里云服务器进行安装, provider 类型为：ALI_CLOUD</li></ol><p>Clusterfile 内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: sealer.aliyun.com&#x2F;v1alpha1</span><br><span class="line">kind: Cluster</span><br><span class="line">metadata:</span><br><span class="line">  name: my-cluster</span><br><span class="line">spec:</span><br><span class="line">  image: registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;kubernetes:v1.19.9</span><br><span class="line">  provider: ALI_CLOUD</span><br><span class="line">  ssh:</span><br><span class="line">    passwd:</span><br><span class="line">    pk: xxx</span><br><span class="line">    pkPasswd: xxx</span><br><span class="line">    user: root</span><br><span class="line">  network:</span><br><span class="line">    interface: eth0</span><br><span class="line">    cniName: calico</span><br><span class="line">    podCIDR: 100.64.0.0&#x2F;10</span><br><span class="line">    svcCIDR: 10.96.0.0&#x2F;22</span><br><span class="line">    withoutCNI: false</span><br><span class="line">  certSANS:</span><br><span class="line">    - aliyun-inc.com</span><br><span class="line">    - 10.0.0.2</span><br><span class="line"></span><br><span class="line">  masters:</span><br><span class="line">    cpu: 4</span><br><span class="line">    memory: 4</span><br><span class="line">    count: 3</span><br><span class="line">    systemDisk: 100</span><br><span class="line">    dataDisks:</span><br><span class="line">    - 100</span><br><span class="line">  nodes:</span><br><span class="line">    cpu: 4</span><br><span class="line">    memory: 4</span><br><span class="line">    count: 3</span><br><span class="line">    systemDisk: 100</span><br><span class="line">    dataDisks:</span><br><span class="line">    - 100</span><br></pre></td></tr></table></figure><p>准备好阿里云的 AK 和 SK，并执行如下所示命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ACCESSKEYID&#x3D;xxxxxxx ACCESSKEYSECRET&#x3D;xxxxxxx sealer apply -f Clusterfile</span><br></pre></td></tr></table></figure><p>部署完成后，基础设置的一些源信息会被写入到 Clusterfile 中，存储在 <code>/root/.sealer/[cluster-name]/Clusterfile</code> 中。如果你需要释放集群，可以执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;sealer delete -f &#x2F;root&#x2F;.sealer&#x2F;my-cluster&#x2F;Clusterfile</span><br></pre></td></tr></table></figure><h3><span id="制作一个自定义的集群镜像-这里以制作一个-kubernetes-dashboard-镜像为例">制作一个自定义的集群镜像, 这里以制作一个 Kubernetes Dashboard 镜像为例</span></h3><p>新建一个 dashboard 目录，并创建一个文件 Kubefile 内容为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;kubernetes:v1.19.9</span><br><span class="line">RUN wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.2.0&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml</span><br><span class="line">CMD kubectl apply -f recommended.yaml</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ export ACCESSKEYID&#x3D;xxxxxxx</span><br><span class="line">$ export ACCESSKEYSECRET&#x3D;xxxxxxx</span><br><span class="line">$ sealer build -f Kubefile -t my-kuberentes-cluster-with-dashboard:latest .</span><br></pre></td></tr></table></figure><p>创建一个带有 Kubernetes Dashboard 的自定义集群, 操作同上，替换掉 Clusterfile 中的 image 字段即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: sealer.aliyun.com&#x2F;v1alpha1</span><br><span class="line">kind: Cluster</span><br><span class="line">metadata:</span><br><span class="line">  name: my-cluster</span><br><span class="line">spec:</span><br><span class="line">  image: my-kuberentes-cluster-with-dashboard:latest</span><br><span class="line">  provider: ALI_CLOUD</span><br><span class="line">  ssh:</span><br><span class="line">    passwd:</span><br><span class="line">    pk: xxx</span><br><span class="line">    pkPasswd: xxx</span><br><span class="line">    user: root</span><br><span class="line">  network:</span><br><span class="line">    interface: eth0</span><br><span class="line">    cniName: calico</span><br><span class="line">    podCIDR: 100.64.0.0&#x2F;10</span><br><span class="line">    svcCIDR: 10.96.0.0&#x2F;22</span><br><span class="line">    withoutCNI: false</span><br><span class="line">  certSANS:</span><br><span class="line">    - aliyun-inc.com</span><br><span class="line">    - 10.0.0.2</span><br><span class="line"></span><br><span class="line">  masters:</span><br><span class="line">    cpu: 4</span><br><span class="line">    memory: 4</span><br><span class="line">    count: 3</span><br><span class="line">    systemDisk: 100</span><br><span class="line">    dataDisks:</span><br><span class="line">    - 100</span><br><span class="line">  nodes:</span><br><span class="line">    cpu: 4</span><br><span class="line">    memory: 4</span><br><span class="line">    count: 3</span><br><span class="line">    systemDisk: 100</span><br><span class="line">    dataDisks:</span><br><span class="line">    - 100</span><br></pre></td></tr></table></figure><p>和上面的操作类似，先准备好阿里云的 AK 和 SK，并执行如下所示命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ACCESSKEYID&#x3D;xxxxxxx ACCESSKEYSECRET&#x3D;xxxxxxx sealer apply -f Clusterfile</span><br></pre></td></tr></table></figure><p>到这里，你就部署好一个自带 Kubernetes Dashboard 的集群。</p><p>你还可以把制作好的集群镜像推送到镜像仓库，供其它人进行使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sealer tag my-kuberentes-cluster-with-dashboard:latest registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;my-kuberentes-cluster-with-dashboard:latest</span><br><span class="line">$ sealer push registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;my-kuberentes-cluster-with-dashboard:latest</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>sealer 未来的一些愿景与价值体现：</p><ul><li>sealer 可以以极其简单的方式让用户自定义集群，解决分布式软件制作者与使用者的协作问题。</li><li>极其简单友好的 User Interface，能屏蔽和兼容各种底层技术细节，到处运行。</li><li>生态建设，官方仓库里将会涵盖常用的分布式软件。</li></ul><p>最后我们总结下：</p><ul><li>如果你要整体交付你的分布式 SaaS，请用 sealer。</li><li>如果你要集成多个分布式服务在一起，如数据库消息队列或者微服务运行时，请用 sealer。</li><li>如果你要安装一个分布式应用如 mysql 主备集群，请用 sealer。</li><li>如果你需要安装/管理一个 Kubernetes 高可用集群，请用 sealer。</li><li>如果你要初始化多个数据中心，保持多个数据中心状态强一致，请用 sealer。</li><li>如果你需要在公有云上实现上述场景，请用 sealer。</li></ul><blockquote><p>sealer 项目地址：<a href="https://github.com/alibaba/sealer" target="_blank" rel="noopener">https://github.com/alibaba/sealer</a></p></blockquote><h2><span id="参考文档">参考文档</span></h2><ol><li><a href="https://github.com/alibaba/sealer/blob/main/docs/README_zh.md" target="_blank" rel="noopener">https://github.com/alibaba/sealer/blob/main/docs/README_zh.md</a></li><li><a href="https://mp.weixin.qq.com/s/0SBslzaMWtqn9H8Q57urNA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0SBslzaMWtqn9H8Q57urNA</a></li><li><a href="https://mp.weixin.qq.com/s/0jVykl3DAYp9cQpAi13G-A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0jVykl3DAYp9cQpAi13G-A</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是集群镜像&quot;&gt;什么是集群镜像&lt;/h2&gt;
&lt;p&gt;顾名思义，和操作系统 .iso 镜像或 Docker 镜像类似，集群镜像是&lt;strong&gt;用一定的技术手段把整个集群的所有文件以一定格式打成的一个资源包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/640-20210601143614113-2021-06-01-u9cFX4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对比单机和集群会发现一些的有趣现象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单机有计算、存储、网络等驱动；集群有 CNI/CSI/CRI 实现像是集群的驱动。&lt;/li&gt;
&lt;li&gt;单机有 Ubuntu、Centos 操作系统；集群中可以把 Kubernetes 看成云操作系统。&lt;/li&gt;
&lt;li&gt;单机上可以运行 Docker 容器或虚拟机；相当于一个运行的实例，集群上也有运行着 K8s 的实例。&lt;/li&gt;
&lt;li&gt;单机上有虚拟机镜像，Docker 镜像；随着云计算技术的发展，集群上也会抽象出类似的镜像技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以基于 Kubernetes 的集群镜像为例，里面包含了除操作系统以外的所有文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docker 依赖的二进制与 Systemd 配置、Dockerd 配置，以及一个私有的容器镜像仓库。&lt;/li&gt;
&lt;li&gt;Kubernetes 核心组件二进制、容器镜像、kubelet system 配置等。&lt;/li&gt;
&lt;li&gt;应用需要用到的 yaml 配置或 helm chart，以及应用的容器镜像。&lt;/li&gt;
&lt;li&gt;其它脚本、配置与二进制工具等应用运行需要的所有依赖。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样，集群镜像运行时肯定不是起一个容器或者装在一台机器上，而是这个镜像可以直接安装到多台服务器上或者直接对接到公有云的基础设施上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linux 下优雅的查看系统 CPU 信息</title>
    <link href="https://www.hi-linux.com/posts/13355.html"/>
    <id>https://www.hi-linux.com/posts/13355.html</id>
    <published>2021-05-28T01:00:00.000Z</published>
    <updated>2021-05-28T08:44:37.102Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>我们在进行机器学习的时候，肯定需要使用一个比较好的 <code>GPU</code> 显卡，其次就是一个性能强劲的 <code>CPU</code> 了。主频高的 <code>CPU</code> 在跑程序的时候，真的有时候比使用 <code>GPU</code> 都跑的块，所以如何查看自己机器的 <code>CPU</code> 就是必不可少的步骤了。我们常常选购笔记本或者服务器的时候，总是会看到 <strong>X 核 XG</strong> 这样的表示，今天我们就一起来了解下其中的一些常见术语吧！</p><ul><li><strong>[1] 查看 CPU 型号和频率 - model</strong></li></ul><p>通过 <code>CPU</code> 的型号，我们可以直观的分辨其好坏和优劣，而频率则反馈的是其性能如何。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CPU型号</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"model name"</span> | uniq</span><br><span class="line">model name      : Intel(R) Xeon(R) CPU E5-2640 v4 @ 2.40GHz</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU频率</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"cpu MHz"</span> | uniq</span><br><span class="line">cpu MHz         : 1547.537</span><br><span class="line">cpu MHz         : 1250.590</span><br><span class="line">cpu MHz         : 2183.637</span><br></pre></td></tr></table></figure><ul><li><strong>[2] 查看物理 CPU 个数 - chip</strong></li></ul><p>主板上实际插入的 <code>CPU</code> 数量，可以数不重复的 <code>physical id</code> 字段有几个，即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 物理CPU数量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | sort | uniq | wc -l</span><br><span class="line">2</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><strong>[3] 查看每个物理 CPU 中 core 的个数 - core - 核数</strong></li></ul><p>单块 <code>CPU</code> 上面能处理数据的芯片组的数量，如双核、四核等，成为 <code>cpu cores</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CPU核数</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"cpu cores"</span> | uniq</span><br><span class="line">cpu cores       : 10</span><br></pre></td></tr></table></figure><ul><li><strong>[4] 查看逻辑 CPU 的个数 - processor</strong></li></ul><p>一般情况下，<strong>逻辑 CPU = 物理 CPU 个数 × 每颗核数</strong>，如果不相等的话，则表示服务器的 <code>CPU</code> 支持超线程技术。<strong>超线程技术(HTT)</strong>：简单来说，它可使处理器中的 <code>1</code> 颗内核如 <code>2</code> 颗内核那样在操作系统中发挥作用。这样一来，操作系统可使用的执行资源扩大了一倍，大幅提高了系统的整体性能，此时<strong>逻辑 CPU = 物理 CPU 个数 × 每颗核数 × 2</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逻辑CPU数</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"processor"</span> | wc -l</span><br><span class="line">40</span><br></pre></td></tr></table></figure><ul><li><strong>[5] 查询系统 CPU 是否启用超线程 - HTT</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询方式</span></span><br><span class="line">$ cat /proc/cpuinfo | grep -e <span class="string">"cpu cores"</span>  -e <span class="string">"siblings"</span> | sort | uniq</span><br><span class="line">cpu cores       : 10</span><br><span class="line">siblings        : 20</span><br></pre></td></tr></table></figure><ul><li><p>参考链接地址</p><ol><li><a href="https://wiki.mbalib.com/wiki/%E8%B6%85%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF" target="_blank" rel="noopener">超线程技术</a></li><li><a href="https://blog.csdn.net/ztguang/article/details/83089905" target="_blank" rel="noopener">CPU：chip、core 和 processor 的关系</a></li></ol></li></ul><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/yy2m9ayn" target="_blank" rel="noopener">https://tinyurl.com/yy2m9ayn</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在进行机器学习的时候，肯定需要使用一个比较好的 &lt;code&gt;GPU&lt;/code&gt; 显卡，其次就是一个性能强劲的 &lt;code&gt;CPU&lt;/code&gt; 了。主频高的 &lt;code&gt;CPU&lt;/code&gt; 在跑程序的时候，真的有时候比使用 &lt;code&gt;GPU&lt;/code&gt; 都跑的块，所以如何查看自己机器的 &lt;code&gt;CPU&lt;/code&gt; 就是必不可少的步骤了。我们常常选购笔记本或者服务器的时候，总是会看到 &lt;strong&gt;X 核 XG&lt;/strong&gt; 这样的表示，今天我们就一起来了解下其中的一些常见术语吧！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[1] 查看 CPU 型号和频率 - model&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 &lt;code&gt;CPU&lt;/code&gt; 的型号，我们可以直观的分辨其好坏和优劣，而频率则反馈的是其性能如何。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# CPU型号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat /proc/cpuinfo | grep &lt;span class=&quot;string&quot;&gt;&quot;model name&quot;&lt;/span&gt; | uniq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model name      : Intel(R) Xeon(R) CPU E5-2640 v4 @ 2.40GHz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# CPU频率&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat /proc/cpuinfo | grep &lt;span class=&quot;string&quot;&gt;&quot;cpu MHz&quot;&lt;/span&gt; | uniq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cpu MHz         : 1547.537&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cpu MHz         : 1250.590&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cpu MHz         : 2183.637&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[2] 查看物理 CPU 个数 - chip&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主板上实际插入的 &lt;code&gt;CPU&lt;/code&gt; 数量，可以数不重复的 &lt;code&gt;physical id&lt;/code&gt; 字段有几个，即可。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 物理CPU数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat /proc/cpuinfo | grep &lt;span class=&quot;string&quot;&gt;&quot;physical id&quot;&lt;/span&gt; | sort | uniq | wc -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Shell" scheme="https://www.hi-linux.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>万字总结，体系化带你全面认识 Linux 系统安全强化</title>
    <link href="https://www.hi-linux.com/posts/38523.html"/>
    <id>https://www.hi-linux.com/posts/38523.html</id>
    <published>2021-05-24T01:00:00.000Z</published>
    <updated>2021-05-26T06:08:29.931Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本指南旨在说明如何尽可能地加强 Linux 的安全性和隐私性，并且不限于任何特定的指南。</p><p>免责声明：如果您不确定自己在做什么，请不要尝试在本文中使用任何内容。</p><p>本指南仅关注安全性和隐私性，而不关注性能，可用性或其他内容。</p><p>列出的所有命令都将需要 root 特权。以 <code>$</code> 符号开头的单词表示一个变量，不同终端之间可能会有所不同。</p><h2><span id="选择正确的linux发行版">选择正确的Linux发行版</span></h2><p>选择一个好的 Linux 发行版有很多因素。</p><ul><li><p>避免分发冻结程序包，因为它们在安全更新中通常很落后</p></li><li><p>不使用与 Systemd 机制的发行版。 Systemd 包含许多不必要的攻击面；它尝试做的事情远远超出了必要，并且超出了初始化系统应做的事情。</p></li><li><p>使用 musl 作为默认的 C 库。 Musl 专注于最小化，这会导致很小的攻击面，而其他 C 库（例如 glibc）过于复杂，容易产生漏洞。例如，与 musl 中的极少数漏洞相比，glibc 中的一百多个漏洞已被公开披露。尽管仅靠披露的 CVE 本身通常是不准确的统计信息，但有时这种情况有时可以用来表示过分的问题。 Musl还具有不错的漏洞利用缓解措施，尤其是其新的强化内存分配器。</p></li><li><p>最好默认情况下使用 LibreSSL 而不是 OpenSSL 的发行版。OpenSSL 包含大量完全不必要的攻击面，并且遵循不良的安全做法。例如，它仍然保持 OS / 2和 VMS 支持这些已有数十年历史的古老操作系统。这些令人讨厌的安全做法导致了可怕的 Heartbleed 漏洞。LibreSSL 是 OpenBSD 团队的 OpenSSL 分支，它采用了出色的编程实践并消除了很多攻击面。在 LibreSSL 成立的第一年内，它缓解了许多漏洞，其中包括一些高严重性的漏洞。</p></li></ul><p>用作强化操作系统基础的最佳发行版是 Gentoo Linux，因为它可以让您精确地配置系统，以达到理想的效果，这将非常有用，尤其是参考我们在后面的章节中使用更安全的编译标志。</p><p>但是，由于 Gentoo 的巨大可用性缺陷，它对于许多人来说可能并不顺手。在这种情况下，Void Linux的 Musl 构建是一个很好的折衷方案。</p><a id="more"></a><h2><span id="内核">内核</span></h2><p>内核是操作系统的核心，不幸的是很容易受到攻击。正如Brad Spengler曾经说过的那样，可以将其视为系统上最大，最易受攻击的setuid根二进制文件。因此，对内核进行尽可能多的强化非常重要。</p><h3><span id="stable-vs-lts-内核">Stable vs LTS 内核</span></h3><p>Linux 内核以两种主要形式发布：稳定和长期支持（LTS）。稳定版本是较新的版本，而 LTS 发行版本是较老的稳定版本，长期以来一直受支持。选择上述任何一个发行版本都有许多后果。</p><p>Linux 内核未使用 CVE 标识安全漏洞。这意味着大多数安全漏洞的修复程序不能向后移植到 LTS 内核。但是稳定版本包含到目前为止进行的所有安全修复。</p><p>但是，有了这些修复程序，稳定的内核将包含更多新功能，因此大大增加了内核的攻击面，并引入了大量新错误。相反，LTS 内核的受攻击面较小，因为这些功能没有被不断添加。</p><p>此外，稳定的内核还包括更新的强化功能，以减轻 LTS 内核没有的某些利用。此类功能的一些示例是Lockdown LSM 和 STACKLEAK GCC 插件。</p><p>总而言之，在选择稳定或 LTS 内核时需要权衡取舍。LTS 内核具有较少的强化功能，并且并非当时所有的公共错误修复都已向后移植，但是通常它的攻击面更少，并且引入未知错误的可能性也较小。稳定的内核具有更多的强化功能，并且包括所有已知的错误修复，但它也具有更多的攻击面以及引入更多未知错误的机会更大。最后，最好使用较新的 LTS 分支（如4.19内核）。</p><h3><span id="sysctl">Sysctl</span></h3><p>Sysctl 是允许用户配置某些内核设置并启用各种安全功能或禁用危险功能以减少攻击面的工具。要临时更改设置，您可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w $tunable &#x3D; $value</span><br></pre></td></tr></table></figure><p>要永久更改 sysctls，您可以将要更改的 sysctls 添加到 /etc/sysctl.conf 或 /etc/sysctl.d 中的相应文件，具体取决于您的Linux发行版。</p><p>以下是您应更改的建议 sysctl 设置。</p><h3><span id="kernel-self-protection">Kernel self-protection</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.kptr_restrict&#x3D;2</span><br></pre></td></tr></table></figure><p>内核指针指向内核内存中的特定位置。这些在利用内核方面可能非常有用，但是默认情况下不会隐藏内核指针，例如，通过读取 /proc/kallsyms 的内容即可轻松发现它们。此设置旨在减轻内核指针泄漏。另外，您可以设置 <code>kernel.kptr_restrict = 1</code> 以仅从没有 CAP_SYSLOG 功能的进程中隐藏内核指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.dmesg_restrict&#x3D;1</span><br></pre></td></tr></table></figure><p>dmesg 是内核日志，它公开了大量有用的内核调试信息，但这通常会泄漏敏感信息，例如内核指针。更改上述 sysctl 设置会将内核日志限制为 CAP_SYSLOG 功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.printk&#x3D;3 3 3 3</span><br></pre></td></tr></table></figure><p>尽管 dmesg_restrict 的值，启动过程中内核日志仍将显示在控制台中。能够在引导过程中记录屏幕的恶意软件可能会滥用此恶意软件以获得更高的特权。此选项可防止这些信息泄漏。必须将其与下面描述的某些引导参数结合使用才能完全有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel.unprivileged_bpf_disabled&#x3D;1</span><br><span class="line">net.core.bpf_jit_harden&#x3D;2</span><br></pre></td></tr></table></figure><p>eBPF 暴露了很大的攻击面，因此需加以限制。这些系统将 eBPF 限制为 CAP_BPF 功能（在 5.8 之前的内核版本上为 CAP_SYS_ADMIN ），并启用 JIT 强化技术，例如常量绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev.tty.ldisc_autoload&#x3D;0</span><br></pre></td></tr></table></figure><p>这将加载 TTY 行规则限制为 CAP_SYS_MODULE 功能，以防止非特权的攻击者使用 TIOCSETD ioctl加载易受攻击的线路规则，而该 TIOCSETD ioctl 之前已在许多漏洞利用中被滥用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.unprivileged_userfaultfd&#x3D;0</span><br></pre></td></tr></table></figure><p>userfaultfd() 系统调用经常被滥用以利用“事后使用(use-after-free)”缺陷。因此，该 sysctl 用于将此 syscall 限制为 CAP_SYS_PTRACE 功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.kexec_load_disabled&#x3D;1</span><br></pre></td></tr></table></figure><p>kexec 是一个系统调用，用于在运行时引导另一个内核。可以滥用此功能来加载恶意内核并在内核模式下获得任意代码执行能力，因此该 sysctl 设置将被禁用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.sysrq&#x3D;4</span><br></pre></td></tr></table></figure><p>SysRq 密钥向非特权用户公开了许多潜在的危险调试功能。与通常的假设相反，SysRq 不仅是物理攻击的问题，而且还可以远程触发。该 sysctl 的值使其可以使用户只能使用SAK密钥，这对于安全地访问 root 是必不可少的。或者，您可以简单地将值设置为 0 以完全禁用 SysRq。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.unprivileged_userns_clone&#x3D;0</span><br></pre></td></tr></table></figure><p>用户名称空间是内核中的一项功能，旨在改善沙箱并使非特权用户易于访问它，但是，此功能公开了重要的内核攻击面，以进行特权升级，因此该 sysctl 将用户名称空间的使用限制为 CAP_SYS_ADMIN 功能。对于无特权的沙箱，建议使用具有很少攻击面的 setuid 二进制文件，以最大程度地减少特权升级的可能性。沙箱章节部分将进一步讨论此主题。</p><p>请注意，尽管该 sysctl 仅在某些Linux发行版中存在，因为它需要内核补丁。如果您的内核不包含此补丁，则可以通过设置 user.max_user_namespaces = 0 来完全禁用用户名称空间（包括 root 用户）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.perf_event_paranoid&#x3D;3</span><br></pre></td></tr></table></figure><p>性能事件会增加大量内核攻击面，并导致大量漏洞。此 sysctl 设置将性能事件的所有使用限制为 CAP_PERFMON 功能（5.8 之前的内核版本为 CAP_SYS_ADMIN）。</p><p>请注意，此 sysctl 设置需要在某些发行版中具备相关的内核补丁。否则，此设置等效于<code>kernel.perf_event_paranoid = 2</code>，它仅限制此功能的子集。</p><h3><span id="网络">网络</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies&#x3D;1</span><br></pre></td></tr></table></figure><p>这有助于防止 SYN 泛洪攻击，这种攻击是拒绝服务攻击的一种形式，在这种攻击中，攻击者发送大量虚假的 SYN 请求，以尝试消耗足够的资源以使系统对合法流量不响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_rfc1337&#x3D;1</span><br></pre></td></tr></table></figure><p>这通过丢弃处于时间等待状态的套接字的RST数据包来防止 time-wait 状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.rp_filter&#x3D;1</span><br><span class="line">net.ipv4.conf.default.rp_filter&#x3D;1</span><br></pre></td></tr></table></figure><p>这些启用了源验证，以验证从计算机所有网络接口接收到的数据包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.all.secure_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.secure_redirects&#x3D;0</span><br><span class="line">net.ipv6.conf.all.accept_redirects&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.all.send_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.send_redirects&#x3D;0</span><br></pre></td></tr></table></figure><p>这些设置禁用了 ICMP 重定向，以防止中间人攻击并最大程度地减少信息泄露。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.icmp_echo_ignore_all&#x3D;1</span><br></pre></td></tr></table></figure><p>此设置使您的系统忽略所有 ICMP 请求，以避免 Smurf 攻击，使设备更难以在网络上枚举，并防止通过 ICMP 时间戳识别时钟指纹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.accept_source_route&#x3D;0</span><br><span class="line">net.ipv4.conf.default.accept_source_route&#x3D;0</span><br><span class="line">net.ipv6.conf.all.accept_source_route&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_source_route&#x3D;0</span><br></pre></td></tr></table></figure><p>源路由是一种允许用户重定向网络流量的机制。由于这可用于执行中间人攻击，在中间人攻击中，出于恶意目的将流量重定向，因此上述设置将会禁用此功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.accept_ra&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_ra&#x3D;0</span><br></pre></td></tr></table></figure><p>恶意的 IPv6 路由广告可能会导致中间人攻击，因此应将其禁用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_sack&#x3D;0</span><br><span class="line">net.ipv4.tcp_dsack&#x3D;0</span><br><span class="line">net.ipv4.tcp_fack&#x3D;0</span><br></pre></td></tr></table></figure><p>禁用 TCP SACK。ACK 通常被利用，并且在许多情况下是不必要的，因此如果您不需要它，则应将其禁用。</p><h3><span id="用户空间">用户空间</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.yama.ptrace_scope&#x3D;2</span><br></pre></td></tr></table></figure><p>ptrace 是一个系统调用，它允许程序调试、修改和检查另一个正在运行的进程，从而使攻击者可以轻易修改其他正在运行的程序的内存。设置将 ptrace 的使用限制为仅具有 CAP_SYS_PTRACE 功能的进程。或者，将 sysctl 设置为 3 以完全禁用 ptrace。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.mmap_rnd_bits&#x3D;32</span><br><span class="line">vm.mmap_rnd_compat_bits&#x3D;16</span><br></pre></td></tr></table></figure><p>ASLR 是一种常见的漏洞利用缓解措施，它可以使进程的关键部分在内存中的位置随机化。这可能会使各种各样的漏洞利用更困难，因为它们首先需要信息泄漏。上述设置增加了用于 mmap ASLR 的熵的位数，从而提高了其有效性。</p><p><strong>这些sysctls的值必须根据CPU体系结构进行设置。以上值与x86兼容，但其他体系结构可能有所不同。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.protected_symlinks&#x3D;1</span><br><span class="line">fs.protected_hardlinks&#x3D;1</span><br></pre></td></tr></table></figure><p>仅当在可全局写入的粘性目录之外，当符号链接和关注者的所有者匹配或目录所有者与符号链接的所有者匹配时，才允许遵循符号链接。这还可以防止没有对源文件的读/写访问权限的用户创建硬链接。这两者都阻止了许多常见的 TOCTOU 漏洞（time-of-check-to-time-of-use）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.protected_fifos&#x3D;2</span><br><span class="line">fs.protected_regular&#x3D;2</span><br></pre></td></tr></table></figure><p>这些阻止了在可能由攻击者控制的环境（例如，全局可写目录）中创建文件，从而使数据欺骗攻击更加困难。</p><h3><span id="引导参数">引导参数</span></h3><p>引导参数在引导时使用引导加载程序（bootloader）将设置传递给内核。类似于sysctl，可以使用某些设置来提高安全性。引导加载程序通常在引导参数设置方式上有所不同。下面列出了一些示例，但是您应该研究特定 bootloader 的修改参数的必要步骤。</p><p>如果使用 GRUB 作为引导程序，请编辑 <code>/etc/default/grub</code> 并将参数添加到<code>GRUB_CMDLINE_LINUX_DEFAULT=line</code>。</p><p>如果使用 Syslinux，请编辑 /boot/syslinux/syslinux.cfg 并将它们添加到 APPEND 行中。</p><p>如果使用 systemd-boot，请编辑您的加载程序条目，并将其附加到 linux 行的末尾。</p><p>建议使用以下设置以提高安全性。</p><h3><span id="kernel-self-protection">Kernel self-protection</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slab_nomerge</span><br></pre></td></tr></table></figure><p>这将禁用 slab 合并，这将通过防止覆盖合并的缓存中的对象并使其更难以影响 slab 缓存的布局，从而大大增加了堆利用的难度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slub_debug&#x3D;FZ</span><br></pre></td></tr></table></figure><p>这些启用健全性检查（F）和重新分区（Z）。健全性检查会添加各种检查，以防止某些slab操作中的损坏。重新分区会在 slab 周围添加额外的区域，以检测 slab 何时被覆盖超过其实际大小，从而有助于检测溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_on_alloc&#x3D;1 init_on_free&#x3D;1</span><br></pre></td></tr></table></figure><p>这样可以在分配和空闲时间期间将内存清零，这可以帮助减轻使用后使用的漏洞并清除内存中的敏感信息。如果您的内核版本低于 5.3，则这些选项不存在。而是在上述 slub_debug 选项后面附加 “P”，以获得 slub_debug=FZP 并添加 page_poison=1。由于它们实际上是一种调试功能，刚好具有一些安全性，因此它们在释放时提供的内存擦除形式较弱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page_alloc.shuffle&#x3D;1</span><br></pre></td></tr></table></figure><p>此选项使页分配器空闲列表随机化，从而通过降低页分配的可预测性来提高安全性，同时这也提高了性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pti&#x3D;on</span><br></pre></td></tr></table></figure><p>这将启用内核页表隔离，从而减轻崩溃并防止某些 KASLR 绕过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsyscall&#x3D;none</span><br></pre></td></tr></table></figure><p>这将禁用 vsyscall，因为它们已过时且已被 vDSO 取代。 vsyscall 也在内存中的固定地址上，使其成为 ROP 攻击的潜在目标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugfs&#x3D;off</span><br></pre></td></tr></table></figure><p>这将禁用 debugfs，它会公开许多有关内核的敏感信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oops&#x3D;panic</span><br></pre></td></tr></table></figure><p>有时某些内核漏洞利用会导致所谓的 “oops”。此参数将引发内核对此类事件 panic，从而防止这些攻击。但是，有时错误的驱动程序会导致无害的操作，这会导致系统崩溃，这意味着此引导参数只能在某些硬件上使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.sig_enforce&#x3D;1</span><br></pre></td></tr></table></figure><p>这仅允许加载已使用有效密钥签名的内核模块，使加载恶意内核模块更加困难。</p><p>这可以防止加载所有树外内核模块（包括 DKMS 模块），除非您已对其进行签名，这意味着诸如 VirtualBox 或 Nvidia 驱动程序之类的模块可能不可用，但根据您的设置可能并不重要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lockdown&#x3D;confidentiality</span><br></pre></td></tr></table></figure><p>内核锁定 LSM 可以消除用户空间代码滥用以升级为内核特权并提取敏感信息的许多方法。为了在用户空间和内核之间实现清晰的安全边界，此LSM是必需的。上面的选项在 confidentiality 模式（最严格的选项）中启用此功能。这意味着 <code>module.sig_enforce=1</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mce&#x3D;0</span><br></pre></td></tr></table></figure><p>这将导致内核对 ECC 内存中无法利用的错误 panic，而这些错误可能会被利用。对于没有 ECC 内存的系统，这是不必要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quiet loglevel&#x3D;0</span><br></pre></td></tr></table></figure><p>这些参数可防止引导期间信息泄漏，并且必须与上面的 kernel.printk sysctl 结合使用。</p><h3><span id="cpu缓解">CPU缓解</span></h3><p>最好启用适用于您的CPU的所有CPU缓解措施，以确保您不受已知漏洞的影响。这是启用所有内置缓解措施的列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spectre_v2&#x3D;on spec_store_bypass_disable&#x3D;on tsx&#x3D;off tsx_async_abort&#x3D;full,nosmt mds&#x3D;full,nosmt l1tf&#x3D;full,force nosmt&#x3D;force kvm.nx_huge_pages&#x3D;force</span><br></pre></td></tr></table></figure><p>您必须研究系统受其影响的 CPU 漏洞，并相应地选择上述缓解措施。请记住，您将需要安装微代码更新，以完全免受这些漏洞的影响。但所有这些操作都可能导致性能显着下降。</p><h3><span id="结果">结果</span></h3><p>如果遵循了以上所有建议（不包括特定的 CPU 缓解措施），则将具有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slab_nomerge slub_debug&#x3D;FZ init_on_alloc&#x3D;1 init_on_free&#x3D;1 page_alloc.shuffle&#x3D;1 pti&#x3D;on vsyscall&#x3D;none debugfs&#x3D;off oops&#x3D;panic module.sig_enforce&#x3D;1 lockdown&#x3D;confidentiality mce&#x3D;0 quiet loglevel&#x3D;0</span><br></pre></td></tr></table></figure><p>如果将 GRUB 用作引导加载程序，则可能需要重新生成 GRUB 配置文件才能应用这些文件。</p><h3><span id="hidepid">hidepid</span></h3><p>proc 是一个伪文件系统，其中包含有关系统上当前正在运行的所有进程的信息。默认情况下，所有用户都可以访问此程序，这可能使攻击者可以窥探其他进程。要只允许用户看到自己的进程，而不能看到其他用户的进程，则必须使用 hidepid=2，gid=proc 挂载选项来挂载 /proc。gid=proc 将 proc 组从此功能中排除，因此您可以将特定的用户或进程列入白名单。添加这些选项的一种方法是编辑 /etc/fstab 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc &#x2F;proc proc nosuid,nodev,noexec,hidepid&#x3D;2,gid&#x3D;proc 0 0</span><br></pre></td></tr></table></figure><p>systemd-logind 仍然需要查看其他用户的进程，因此，要使用户会话在 systemd 系统上正常工作，必须创建 <code>/etc/systemd/system/systemd-logind.service.d/hidepid.conf</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">SupplementaryGroups&#x3D;proc</span><br></pre></td></tr></table></figure><h3><span id="减少内核攻击面">减少内核攻击面</span></h3><p>最好禁用不是绝对必要的任何功能，以最大程度地减少潜在的内核攻击面。这些功能不必一定很危险，它们可以只是被删除以减少攻击面的良性代码。切勿禁用您不了解的随机事物。以下是一些可能有用的示例，具体取决于您的设置。</p><h3><span id="引导参数">引导参数</span></h3><p>引导参数通常可以用来减少攻击面，这样的例子之一是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipv6.disable&#x3D;1</span><br></pre></td></tr></table></figure><p>这将禁用整个IPv6堆栈，如果您尚未迁移到该堆栈，则可能不需要该堆栈。如果正在使用的IPv6，请不要使用此引导参数。</p><h3><span id="将内核模块列入黑名单">将内核模块列入黑名单</span></h3><p>内核允许非特权的用户通过模块自动加载来间接导致某些模块被加载。这使攻击者可以自动加载易受攻击的模块，然后加以利用。一个这样的示例是 CVE-2017-6074，其中攻击者可以通过启动DCCP连接来触发DCCP内核模块的加载，然后利用该内核模块中的漏洞。</p><p>可以通过将文件插入 <code>/etc/modprobe.d</code> 并将指定的内核模块列入黑名单的方法，将特定的内核模块列入黑名单。</p><p>Install 参数告诉 modprobe 运行特定命令，而不是像往常一样加载模块。 /bin/false 是仅返回 1 的命令，该命令实际上不会执行任何操作。两者都告诉内核运行 /bin/false 而不是加载模块，这将防止攻击者利用该模块。以下是最有可能不需要的内核模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">install dccp &#x2F;bin&#x2F;false</span><br><span class="line">install sctp &#x2F;bin&#x2F;false</span><br><span class="line">install rds &#x2F;bin&#x2F;false</span><br><span class="line">install tipc &#x2F;bin&#x2F;false</span><br><span class="line">install n-hdlc &#x2F;bin&#x2F;false</span><br><span class="line">install ax25 &#x2F;bin&#x2F;false</span><br><span class="line">install netrom &#x2F;bin&#x2F;false</span><br><span class="line">install x25 &#x2F;bin&#x2F;false</span><br><span class="line">install rose &#x2F;bin&#x2F;false</span><br><span class="line">install decnet &#x2F;bin&#x2F;false</span><br><span class="line">install econet &#x2F;bin&#x2F;false</span><br><span class="line">install af_802154 &#x2F;bin&#x2F;false</span><br><span class="line">install ipx &#x2F;bin&#x2F;false</span><br><span class="line">install appletalk &#x2F;bin&#x2F;false</span><br><span class="line">install psnap &#x2F;bin&#x2F;false</span><br><span class="line">install p8023 &#x2F;bin&#x2F;false</span><br><span class="line">install p8022 &#x2F;bin&#x2F;false</span><br><span class="line">install can &#x2F;bin&#x2F;false</span><br><span class="line">install atm &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>特别是模糊的网络协议会增加大量的远程攻击面。此黑名单：</p><ul><li>DCCP — Datagram Congestion Control Protocol</li><li>SCTP — Stream Control Transmission Protocol</li><li>RDS — Reliable Datagram Sockets</li><li>TIPC — Transparent Inter-process Communication</li><li>HDLC — High-Level Data Link Control</li><li>AX25 — Amateur X.25</li><li>NetRom</li><li>X25</li><li>ROSE</li><li>DECnet</li><li>Econet</li><li>af_802154 — IEEE 802.15.4</li><li>IPX — Internetwork Packet Exchange</li><li>AppleTalk</li><li>PSNAP — Subnetwork Access Protocol</li><li>p8023 — Novell raw IEEE 802.3</li><li>p8022 — IEEE 802.2</li><li>CAN — Controller Area Network</li><li>ATM</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">install cramfs &#x2F;bin&#x2F;false</span><br><span class="line">install freevxfs &#x2F;bin&#x2F;false</span><br><span class="line">install jffs2 &#x2F;bin&#x2F;false</span><br><span class="line">install hfs &#x2F;bin&#x2F;false</span><br><span class="line">install hfsplus &#x2F;bin&#x2F;false</span><br><span class="line">install squashfs &#x2F;bin&#x2F;false</span><br><span class="line">install udf &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>将各种稀有文件系统列入黑名单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">install cifs &#x2F;bin&#x2F;true</span><br><span class="line">install nfs &#x2F;bin&#x2F;true</span><br><span class="line">install nfsv3 &#x2F;bin&#x2F;true</span><br><span class="line">install nfsv4 &#x2F;bin&#x2F;true</span><br><span class="line">install gfs2 &#x2F;bin&#x2F;true</span><br></pre></td></tr></table></figure><p>如果不使用网络文件系统，也可以将其列入黑名单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install vivid &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p><a href="https://href.li/?https://www.kernel.org/doc/html/v4.12/media/v4l-drivers/vivid.html" target="_blank" rel="noopener">vivid driver</a>驱动程序仅用于测试目的，并且是特权提升漏洞的原因，因此应禁用它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install bluetooth &#x2F;bin&#x2F;false</span><br><span class="line">install btusb &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>禁用具有安全问题历史记录的蓝牙。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install uvcvideo &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>这会禁用网络摄像头，以防止其被用来监视您。</p><p>您也可以将麦克风模块列入黑名单，但这在系统之间可能会有所不同。要查找模块的名称，请在 /proc/asound/modules 中查找并将其列入黑名单。例如，一个这样的模块是 snd_hda_intel。</p><p>请注意，尽管有时麦克风的内核模块与扬声器的模块相同。这意味着像这样禁用麦克风也可能会无意中禁用任何扬声器，虽然扬声器也有可能变成麦克风，所以这不一定是消极的结果。</p><p>最好从物理上删除这些设备，或者至少在 BIOS/UEFI 中禁用它们。禁用内核模块并不总是那么有效。</p><h3><span id="rfkill">rfkill</span></h3><p>可以通过rfkill将无线设备列入黑名单，以进一步减少远程攻击面。要将所有无线设备列入黑名单，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill block all</span><br></pre></td></tr></table></figure><p>WiFi可以通过以下方式解锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill unblock wifi</span><br></pre></td></tr></table></figure><p>在使用systemd的系统上，rfkill在所有会话中均保持不变，但是，在使用其他init系统的系统上，您可能必须创建一个init脚本以在引导时执行这些命令。</p><h3><span id="其他内核指针泄漏">其他内核指针泄漏</span></h3><p>前面的部分已经防止了一些内核指针泄漏，但是还有更多泄漏。</p><p>在文件系统上，/boot 中存在内核映像和 System.map 文件。/usr/src和/{,usr/} lib/modules目录中还有其他敏感的内核信息。您应该限制这些目录的文件权限，以使它们只能由root用户读取。您还应该删除 System.map 文件，因为除高级调试外，它们都不需要。</p><p>此外，某些日志记录守护程序（例如 systemd 的 journalctl ）包括内核日志，可用于绕过上述 dmesg_restrict 保护。从 adm 组中删除用户通常足以撤销对以下日志的访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -d $user adm</span><br></pre></td></tr></table></figure><h3><span id="限制对-sysfs-的访问">限制对 sysfs 的访问</span></h3><p>sysfs 是伪文件系统，可提供大量的内核和硬件信息。它通常安装在/sys上。 sysfs 导致大量信息泄漏，尤其是内核指针泄漏。Whonix 的 security-misc 软件包包括 hide-hardware-info 脚本，该脚本限制访问此目录以及 /proc 中的一些脚本，以试图隐藏潜在的硬件标识符并防止内核指针泄漏。该脚本是可配置的，并允许基于组将特定的应用程序列入白名单。建议应用此方法，并使其在启动时使用 init 脚本执行。或者这样<a href="https://href.li/?https://github.com/Whonix/security-misc/blob/master/lib/systemd/system/hide-hardware-info.service" target="_blank" rel="noopener">做成systemd服务</a>。</p><p>为了使基本功能在使用 systemd 的系统上运行，必须将一些系统服务列入白名单。这可以通过创建 <code>/etc/systemd/system/user@.service.d/sysfs.conf</code> 并添加以下内容来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">SupplementaryGroups&#x3D;sysfs</span><br></pre></td></tr></table></figure><p>但是，这不能解决所有问题。许多应用程序可能仍会中断，您需要将它们正确列入白名单。</p><h3><span id="linux强化">Linux强化</span></h3><p>某些发行版（例如 Arch Linux ）包括强化的内核程序包。它包含许多强化补丁程序和更注重安全性的内核配置。如果可能的话，建议安装它。</p><h3><span id="grsecurity">Grsecurity</span></h3><p>Grsecurity 是一组内核修补程序，可以大大提高内核安全性。这些补丁曾经可以免费获得，但是现在<a href="https://href.li/?https://grsecurity.net/passing_the_baton" target="_blank" rel="noopener">需要购买</a>了。如果可用，则强烈建议您获取它。Grsecurity 提供了最新的内核和用户空间保护。</p><h3><span id="内核运行时防护">内核运行时防护</span></h3><p>Linux Kernel Runtime Guard（LKRG）是一个内核模块，可确保运行时内核的完整性并检测漏洞。它可以杀死整个类别的内核漏洞。但这并不是一个完美的缓解方法，因为LKRG在设计上可以绕开。它仅适用于现成的恶意软件。但是，尽管可能性不大，但LKRG本身可能会像其他任何内核模块一样公开新的漏洞。</p><h3><span id="自编译内核">自编译内核</span></h3><p>建议编译您自己的内核，同时启用尽可能少的内核模块和尽可能多的安全性功能，以将内核的受攻击面保持在绝对最低限度。</p><p>另外，应用内核强化补丁，例如如上所述的 linux-hardened 或 grsecurity。</p><p>发行版编译的内核还具有公共内核指针/符号，这对于漏洞利用非常有用。编译自己的内核将为您提供独特的内核符号，连同 kptr_restrict，dmesg_restrict 和其他针对内核指针泄漏的强化措施，将使攻击者更加难以创建依赖于内核指针知识的漏洞利用程序。</p><p>您就可以从<a href="https://href.li/?https://www.whonix.org/wiki/Hardened-kernel" target="_blank" rel="noopener">Whonix的强化内核</a>中汲取灵感或使用它。</p><h2><span id="强制访问措施">强制访问措施</span></h2><p>强制访问控制（MAC）系统对程序可以访问的内容进行细粒度的控制。这意味着您的浏览器将无权访问您的整个主目录或类似目录。</p><p>最常用的 MAC 措施是 SELinux 和 AppArmor。SELinux比AppArmor 更安全，因为它的粒度更细。例如，它是基于inode而不是基于路径的，允许强制执行明显更严格的限制，可以过滤内核 ioctl 等。不幸的是，这是以难以使用和难以学习为代价的，因此某些人可能会首选 AppArmor。</p><p>要在内核中启用 AppArmor，必须设置以下引导参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apparmor&#x3D;1 security&#x3D;apparmor</span><br></pre></td></tr></table></figure><p>要启用 SELinux，请设置以下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selinux&#x3D;1 security&#x3D;selinux</span><br></pre></td></tr></table></figure><p>请记住，仅启用 MAC 措施本身并不能神奇地提高安全性。您必须制定严格的政策才能充分利用它。例如，要创建 AppArmor 配置文件，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa-genprof $path_to_program</span><br></pre></td></tr></table></figure><p>打开程序，然后像往常一样开始使用它。AppArmor 将检测需要访问哪些文件，并将它们添加到配置文件中（如果您选择的话）。但是，仅凭这一点不足以提供高质量的配置文件。请参阅<a href="https://href.li/?https://gitlab.com/apparmor/apparmor/-/wikis/Documentation" target="_blank" rel="noopener">AppArmor文档</a>以获取更多详细信息。</p><p>如果您想更进一步，则可以通过实施 initramfs 勾子来设置一个完整的系统MAC策略，该策略限制每个单个用户空间进程，该挂钩对 init 系统强制实施MAC策略。这就是 Android 使用 SELinux 的方式，以及 Whonix 未来将如何使用 AppArmor 的方式。对于加强实施最小特权原则的强大安全模型是必要的。</p><h2><span id="沙箱">沙箱</span></h2><h3><span id="应用沙箱">应用沙箱</span></h3><p>沙箱可让您在隔离的环境中运行程序，该环境对系统的其余部分具有有限的访问权限或完全没有访问权限。您可以使用它们来保护应用程序安全或运行不受信任的程序。</p><p>建议与 AppArmor 或 SELinux 一起在单独的用户帐户中使用<a href="https://href.li/?https://github.com/containers/bubblewrap" target="_blank" rel="noopener">Bubblewrap</a>到沙箱程序。您也可以考虑改用 gVisor，它的优点是为每个来宾提供了自己的内核。</p><p>这些方法中的任何一个都可以用来创建一个功能强大的沙箱，并且暴露的攻击面最小。如果您不想自己创建沙箱，请在完成后考虑使用 Whonix 的 sandbox-app-launcher。<a href="https://href.li/?https://madaidans-insecurities.github.io/linux.html#firejail" target="_blank" rel="noopener">您不应该使用Firejail</a>。</p><p>诸如 Docker 和 LXC 之类的容器解决方案经常被误导为沙盒形式。它们太宽松了，无法广泛支持各种应用程序，因此不能认为它们是强大的应用程序沙箱。</p><h3><span id="常见沙箱逃逸">常见沙箱逃逸</span></h3><h4><span id="pulseaudio">PulseAudio</span></h4><p>PulseAudio 是一种常见的声音服务器，但在编写时并未考虑隔离或沙盒的问题，这使其成为重复出现的沙盒逃逸漏洞。为了防止这种情况，建议您从沙箱中阻止对 PulseAudio 的访问，或者从系统中完全卸载它。</p><h4><span id="d-bus">D-Bus</span></h4><p>D-Bus 是台式机 Linux 上最流行的进程间通信形式，但它也是沙箱逃逸的另一种常见途径，因为它允许与服务自由交互。这些漏洞的一个例子就是 Firejail。您应该从沙箱中阻止对 D-Bus 的访问，或者通过 MAC 以细粒度的规则进行调解。</p><h4><span id="gui隔离">GUI隔离</span></h4><p>任何 Xorg 窗口都可以访问另一个窗口。这允许琐碎的键盘记录或屏幕截图程序，甚至可以记录诸如 root 密码之类的内容。您可以使用嵌套的 X11 服务器（例如 Xpra 或 Xephyr 和 bubblewrap）将 Xorg 窗口沙箱化。默认情况下，Wayland 将窗口彼此隔离，这将是一个比 Xorg 更好的选择，尽管 Wayland 可能不如 Xorg 普遍可用，因为它在开发中较早。</p><h4><span id="ptrace">ptrace</span></h4><p>如前所述，ptrace 是一个系统调用，可能会被滥用破坏在沙箱外部运行的进程。为避免这种情况，您可以通过 sysctl 启用内核 YAMA ptrace 限制，也可以在 seccomp 过滤器中将 ptrace syscall 列入黑名单。</p><h4><span id="tiocsti">TIOCSTI</span></h4><p>TIOCSTI 是一个 ioctl，它允许注入终端命令，并为攻击者提供了一种简单的机制，可以在同一用户会话内的其他进程之间横向移动。可以通过将 seccomp 过滤器中的 ioctl 列入黑名单或使用 bubblewrap 的 <code>–new-session</code> 参数来缓解这种攻击。</p><h4><span id="systemd-沙箱">Systemd 沙箱</span></h4><p>虽然不建议使用 systemd，但有些系统可能无法切换。这些人至少可以使用沙盒服务，因此他们只能访问所需的内容。这是一个沙箱化 systemd 服务的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">CapabilityBoundingSet&#x3D;CAP_NET_BIND_SERVICE</span><br><span class="line">ProtectSystem&#x3D;strict</span><br><span class="line">ProtectHome&#x3D;true</span><br><span class="line">ProtectKernelTunables&#x3D;true</span><br><span class="line">ProtectKernelModules&#x3D;true</span><br><span class="line">ProtectControlGroups&#x3D;true</span><br><span class="line">ProtectKernelLogs&#x3D;true</span><br><span class="line">ProtectHostname&#x3D;true</span><br><span class="line">ProtectClock&#x3D;true</span><br><span class="line">ProtectProc&#x3D;invisible</span><br><span class="line">ProcSubset&#x3D;pid</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line">PrivateUsers&#x3D;yes</span><br><span class="line">PrivateDevices&#x3D;true</span><br><span class="line">MemoryDenyWriteExecute&#x3D;true</span><br><span class="line">NoNewPrivileges&#x3D;true</span><br><span class="line">LockPersonality&#x3D;true</span><br><span class="line">RestrictRealtime&#x3D;true</span><br><span class="line">RestrictSUIDSGID&#x3D;true</span><br><span class="line">RestrictAddressFamilies&#x3D;AF_INET</span><br><span class="line">RestrictNamespaces&#x3D;yes</span><br><span class="line">SystemCallFilter&#x3D;write read openat close brk fstat lseek mmap mprotect munmap rt_sigaction rt_sigprocmask ioctl nanosleep select access execve getuid arch_prctl set_tid_address set_robust_list prlimit64 pread64 getrandom</span><br><span class="line">SystemCallArchitectures&#x3D;native</span><br><span class="line">UMask&#x3D;0077</span><br><span class="line">IPAddressDeny&#x3D;any</span><br><span class="line">AppArmorProfile&#x3D;&#x2F;etc&#x2F;apparmor.d&#x2F;usr.bin.example</span><br></pre></td></tr></table></figure><p>所有选项的说明：</p><ul><li><code>CapabilityBoundingSet=</code> — Specifies the <a href="https://href.li/?https://madaidans-insecurities.github.io/guides/linux-hardening.html#capabilities" target="_blank" rel="noopener">capabilities</a> the process is given.</li><li><code>ProtectHome=true</code> — Makes all home directories inaccessible.</li><li><code>ProtectKernelTunables=true</code> — Mounts kernel tunables such as those modified through <code>sysctl</code> as read-only.</li><li><code>ProtectKernelModules=true</code> — Denies module loading and unloading.</li><li><code>ProtectControlGroups=true</code> — Mounts all control group hierarchies as read-only.</li><li><code>ProtectKernelLogs=true</code> — Prevents accessing the kernel logs.</li><li><code>ProtectHostname=true</code> — Prevents changes to the system hostname.</li><li><code>ProtectClock</code> — Prevents changes to the system clock.</li><li><code>ProtectProc=invisible</code> — Hides all outside processes.</li><li><code>ProcSubset=pid</code> — Permits access to only the pid subset of <code>/proc</code>.</li><li><code>PrivateTmp=true</code> — Mounts an empty tmpfs over <code>/tmp</code> and <code>/var/tmp</code>, therefore hiding their previous contents.</li><li><code>PrivateUsers=true</code> — Sets up an empty user namespace to hide other user accounts on the system.</li><li><code>PrivateDevices=true</code> — Creates a new <code>/dev</code> mount with minimal devices present.</li><li><code>MemoryDenyWriteExecute=true</code> — Enforces a memory W^X policy.</li><li><code>NoNewPrivileges=true</code> — Prevents escalating privileges.</li><li><code>LockPersonality=true</code> — Locks down the <code>personality()</code> syscall to prevent switching execution domains.</li><li><code>RestrictRealtime=true</code> — Prevents attempts to enable realtime scheduling.</li><li><code>RestrictSUIDSGID=true</code> — Prevents executing setuid or setgid binaries.</li><li><code>RestrictAddressFamilies=AF_INET</code> — Restricts the usable socket address families to IPv4 only (<code>AF_INET</code>).</li><li><code>RestrictNamespaces=true</code> — Prevents creating any new namespaces.</li><li><code>SystemCallFilter=...</code> — Restricts the allowed syscalls to the absolute minimum. If you aren’t willing to maintain your own custom seccomp filter, then systemd provides many [predefined system call sets](<a href="https://href.li/?https://www.freedesktop.org/software/systemd/man/systemd.exec.html#System" target="_blank" rel="noopener">https://www.freedesktop.org/software/systemd/man/systemd.exec.html#System</a> Call Filtering) that you can use. <code>@system-service</code> will be suitable for many use cases.</li><li><code>SystemCallArchitectures=native</code> — Prevents executing syscalls from other CPU architectures.</li><li><code>UMask=0077</code> — Sets the <a href="https://href.li/?https://madaidans-insecurities.github.io/guides/linux-hardening.html#umask" target="_blank" rel="noopener">umask</a> to a more restrictive value.</li><li><code>IPAddressDeny=any</code> — Blocks all incoming and outgoing traffic to/from any IP address. Set <code>IPAddressAllow=</code> to configure a whitelist. Alternatively, setup a network namespace with <code>PrivateNetwork=true</code>.</li><li><code>AppArmorProfile=...</code> — Runs the process under the specified AppArmor profile.</li></ul><p>您不能仅将此示例配置复制到您的配置中，每种服务的要求各不相同，并且必须针对每种服务微调沙箱。要了解有关您可以设置的所有选项的更多信息，请阅读<a href="https://href.li/?https://www.freedesktop.org/software/systemd/man/systemd.exec.html" target="_blank" rel="noopener">systemd.exec手册页</a>。</p><p>如果您使用的系统不是 systemd 而是 init，那么可以使用 bubblewrap 轻松复制所有这些选项。</p><h3><span id="gvisor">gVisor</span></h3><p>普通沙箱固有地与主机共享同一内核。您信任我们已经评估为不安全的内核，可以正确限制这些程序。由于主机内核的整个攻击面已完全暴露，因此沙盒中的内核利用程序可以绕过任何限制。已经进行了一些努力来限制使用 seccomp 的攻击面，但不足以完全解决此问题。</p><p>GVisor 是解决此问题的方法。它为每个应用程序提供了自己的内核，该内核以内存安全的语言重新实现了 Linux 内核的大部分系统调用，从而提供了明显更强的隔离性。</p><h3><span id="虚拟机">虚拟机</span></h3><p>虽然不是传统的 “沙盒”，但虚拟机通过虚拟化全新系统来分离进程，从而提供了非常强大的隔离性。KVM是内核模块，它允许内核充当管理程序，而QEMU是利用KVM的仿真器。Virt-manager 和 GNOME Boxs都是良好且易于使用的 GUI，用于管理 KVM / QEMU 虚拟机。不建议使用 Virtualbox 的<a href="https://href.li/?https://www.whonix.org/wiki/KVM#Why_Use_KVM_Over_VirtualBox.3F" target="_blank" rel="noopener">原因</a>有很多。</p><h2><span id="强化内存分配器">强化内存分配器</span></h2><p>hardened_malloc 是一种硬化的内存分配器，可为堆内存损坏漏洞提供实质性的保护。它很大程度上基于 OpenBSD 的 malloc 设计，但具有许多改进。</p><p>可以通过 LD_PRELOAD 环境变量针对每个应用程序使用 hardened_malloc。例如，假设您编译的库位于 <code>/usr/lib/libhardened_malloc.so</code>，则可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD&#x3D;&quot;&#x2F;usr&#x2F;lib&#x2F;libhardened_malloc.so&quot; $program</span><br></pre></td></tr></table></figure><p>通过全局预加载该库，也可以在系统范围内使用它，这是使用它的推荐方法。为此，请编辑 /etc/ld.so.preload 并插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;lib&#x2F;libhardened_malloc.so</span><br></pre></td></tr></table></figure><p>尽管大多数应用程序都可以正常工作，但 hardened_malloc 可能会破坏某些应用程序。建议使用以下选项编译 hardened_malloc 以最大程度地减少损坏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SLAB_QUARANTINE_RANDOM_LENGTH&#x3D;0 </span><br><span class="line">CONFIG_SLAB_QUARANTINE_QUEUE_LENGTH&#x3D;0 </span><br><span class="line">CONFIG_GUARD_SLABS_INTERVAL&#x3D;8</span><br></pre></td></tr></table></figure><p>您还应该使用sysctl设置以下内容，以适应hardened_malloc创建的大量保护页：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count&#x3D;524240</span><br></pre></td></tr></table></figure><p><a href="https://href.li/?https://www.whonix.org/wiki/Hardened_Malloc" target="_blank" rel="noopener">Whonix项目</a>为基于Debian的发行版提供了hardened_malloc软件包。</p><h2><span id="强化编译标志">强化编译标志</span></h2><p>编译自己的程序可以带来很多好处，因为它使您能够优化程序的安全性。但是，执行完全相反的操作并降低安全性很容易，如果您不确定自己在做什么，请跳过本节。在基于源的发行版（例如Gentoo）上，这将是最简单的，但也可以在其他发行版上这样做。</p><p>某些编译选项可用于添加其他漏洞利用缓解措施，从而消除整个类别的常见漏洞。您可能听说过常规保护，例如位置独立可执行文件，堆栈粉碎保护程序，立即绑定，只读重定位和 FORTIFY_SOURCE，但是本节将不做介绍，因为它们已被广泛采用。相反，它将讨论诸如控制流完整性和影子堆栈之类的现代漏洞利用缓解措施。</p><p>本节涉及主要用 C 或 C ++ 编写的本机程序。您必须使用 Clang 编译器，因为这些功能在 GCC 上不可用。请记住，由于未广泛采用这些缓解措施，因此某些应用程序在启用它们后可能无法运行。</p><ul><li>控制流完整性（CFI）是一种缓解漏洞利用的方法，旨在防止诸如 ROP 或 JOP 之类的代码重用攻击。由于更广泛采用的缓解措施（例如 NX）使过时的利用技术过时了，因此使用这些技术利用了很大一部分漏洞。Clang 支持细粒度的前沿 CFI，这意味着它可以有效缓解JOP攻击。Clang 的 CFI 本身并不能减轻ROP；您还必须使用下面记录的单独机制。要启用此功能，必须应用以下编译标志： <code>-flto -fvisibility=hidden -fsanitize=cfi</code></li><li>影子堆栈通过将程序复制到其他隐藏堆栈中来保护程序的返回地址。然后比较主堆栈和影子堆栈中的返回地址，看两者是否不同。如果是这样，则表明存在攻击，程序将中止，从而减轻了 ROP 攻击。Clang 具有称为 ShadowCallStack 的功能，可以完成此操作，但是，仅在 ARM64 上可用。要启用此功能，必须应用以下编译标志： <code>-fsanitize=shadow-call-stack</code></li><li>如果上述 ShadowCallStack 不是一个选项，则可以选择使用具有相似目标的 SafeStack。但是，不幸的是，此功能有许多漏洞，因此效果不甚理想。如果仍然希望启用此功能，则必须应用以下编译标志： <code>-fsanitize=safe-stack</code></li><li>最常见的内存损坏漏洞之一是未初始化的内存。Clang 有一个选项可以使用零或特定模式自动初始化变量。建议将变量初始化为零，因为使用其他模式比利用漏洞缓解功能更适合发现错误。要启用此功能，必须应用以下编译标志： -ftrivial-auto-var-init=zero -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang 但该选项的存在目前正在<a href="https://href.li/?https://lists.llvm.org/pipermail/cfe-dev/2020-April/065221.html" target="_blank" rel="noopener">辩论</a>中。</li></ul><h2><span id="内存安全语言">内存安全语言</span></h2><p>用内存安全语言编写的程序会自动受到保护，免受各种安全漏洞的影响，这些安全漏洞包括缓冲区溢出，未初始化的变量，售后使用等。</p><p>Microsoft 和 Google 的安全研究人员进行的研究证明，已发现的大多数漏洞都是内存安全问题。这样的内存安全语言的示例包括 Rust，Swift 和 Java，而内存不安全语言的示例包括 C 和 C ++。如果可行，应使用内存安全替代品替换尽可能多的程序。</p><h2><span id="root-账户">Root 账户</span></h2><p>root 可以执行任何操作，并且可以访问您的整个系统。因此，应尽可能将其锁定，以使攻击者无法轻松获得 root 用户访问权限。</p><h3><span id="etcsecuretty">/etc/securetty</span></h3><p>/etc/securetty 文件指定允许您以 root 用户身份登录的位置。该文件应保留为空，以便任何人都不能从终端上这样做。</p><h3><span id="限制-su">限制 su</span></h3><p>su 可让您从终端切换用户。默认情况下，它尝试以 root 用户身份登录。要将 su 的使用限制在 wheel 组中，请编辑 <code>/etc/pam.d/su</code> 和 <code>/etc/pam.d/su-l</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth required pam_wheel.so use_uid</span><br></pre></td></tr></table></figure><p>您应该在 wheel 组中拥有尽可能少的用户。</p><h3><span id="锁定-root-账户">锁定 root 账户</span></h3><p>要锁定 root 帐户以防止任何人以 root 身份登录，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -l root</span><br></pre></td></tr></table></figure><p>在执行此操作之前，请确保您具有获取根的替代方法（例如，从活动 USB 引导并更改为文件系统的chroot ），以免您无意中将自己锁定在系统之外。</p><h3><span id="拒绝通过-ssh-的远程-root-登陆">拒绝通过 SSH 的远程 root 登陆</span></h3><p>为了防止某人通过 SSH 以 root 身份登录，请编辑 <code>/etc/ssh/sshd_config</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br></pre></td></tr></table></figure><h3><span id="增加散列回合数">增加散列回合数</span></h3><p>您可以增加 shadow 使用的哈希回合数，从而通过迫使攻击者计算更多的哈希值来破解您的密码，从而提高哈希密码的安全性。默认情况下，shadow 使用 5000 次回合，但是您可以将其增加到任意数量。尽管配置的回合越多，登录速度就越慢。编辑 /etc/pam.d/passwd 并添加回合选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password required pam_unix.so sha512 shadow nullok rounds&#x3D;65536</span><br></pre></td></tr></table></figure><p>这使 shadow 执行 65536 次散列回合。</p><p>应用此设置后，密码不会自动重新加密，因此您需要使用以下方法重置密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd $username</span><br></pre></td></tr></table></figure><h3><span id="限制-xorg-root-访问">限制 Xorg root 访问</span></h3><p>默认情况下，某些发行版以 root 用户身份运行 Xorg，这是一个问题，因为 Xorg 包含大量古老而又复杂的代码，这增加了巨大的攻击面，并使其更有可能拥有可以获取 root 特权的漏洞利用程序。要阻止它作为 root 用户执行，请编辑 <code>/etc/X11/Xwrapper.config</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">needs_root_rights &#x3D; no</span><br></pre></td></tr></table></figure><h3><span id="安全访问root">安全访问root</span></h3><p>恶意软件可以使用多种方法来嗅探 root 帐户的密码。因此，访问根帐户的传统方式是不安全的，最好根本不访问根，但这实际上是不可行的。本节详细介绍了访问根帐户的最安全方法。在安装操作系统后，应立即应用这些说明，以确保该软件不含恶意软件。</p><p>您绝对不能使用普通用户帐户访问 root，因为 root 可能已被盗用。您也不能直接登录到根帐户。通过执行以下操作，创建一个单独的“管理员”用户帐户，该帐户仅用于访问 root 用户，而不能用于访问其他用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd admin</span><br></pre></td></tr></table></figure><p>执行并来设置一个非常强的密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd admin</span><br></pre></td></tr></table></figure><p>仅允许该帐户使用您首选的权限提升机制。例如，如果使用 sudo，则通过执行以下命令来添加 sudoers异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo -f &#x2F;etc&#x2F;sudoers.d&#x2F;admin-account</span><br></pre></td></tr></table></figure><p>然后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>确保没有其他帐户可以访问 sudo（或您的首选机制）</p><p>现在，要实际登录到该帐户，请先重新启动-例如，这可以防止受损的窗口管理器执行登录欺骗。当提供登录提示时，请通过按键盘上的以下组合键来激活安全注意键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alt + SysRq + k</span><br></pre></td></tr></table></figure><p>这将杀死当前虚拟控制台上的所有应用程序，从而克服登录欺骗攻击。现在，您可以安全地登录到您的管理员帐户，并使用 root 用户执行任务。完成后，注销管理员帐户，然后重新登录到非特权用户帐户。</p><h2><span id="防火墙">防火墙</span></h2><p>防火墙可以控制传入和传出的网络流量，并且可以用来阻止或允许某些类型的流量。除非有特殊原因，否则应始终阻止所有传入流量。建议设置严格的 iptables 或 nftables 防火墙。火墙必须针对您的系统进行微调，并且没有一个适合所有防火墙的规则集。建议您熟悉创建防火墙规则。<a href="https://href.li/?https://wiki.archlinux.org/index.php/Iptables" target="_blank" rel="noopener">Arch Wiki</a>和<a href="https://href.li/?https://linux.die.net/man/8/iptables" target="_blank" rel="noopener">手册页</a>都是很好的资源。</p><p>这是基本 iptables 配置的示例，该配置禁止所有传入的网络流量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD DROP [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">:TCP - [0:0]</span><br><span class="line">:UDP - [0:0]</span><br><span class="line">-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -m conntrack --ctstate INVALID -j DROP</span><br><span class="line">-A INPUT -p udp -m conntrack --ctstate NEW -j UDP</span><br><span class="line">-A INPUT -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP</span><br><span class="line">-A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">-A INPUT -p tcp -j REJECT --reject-with tcp-reset</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-proto-unreachable</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p>但是，您不应尝试在实际系统上使用此示例。它仅适用于某些台式机系统。</p><h2><span id="身份标识">身份标识</span></h2><p>为了保护隐私，最好最大程度地减少可追溯到您的信息量。</p><h3><span id="主机名和用户名">主机名和用户名</span></h3><p>请勿在主机名或用户名中添加唯一标识的内容。将它们保留为通用名称，例如 “host” 和 “user”，以便它们无法识别您。</p><h3><span id="timezones-locales-keymaps">Timezones / Locales / Keymaps</span></h3><p>如果可能，应将您的时区设置为 “UTC”，将区域设置和键盘映射设置为 “US”。</p><h3><span id="机器id">机器ID</span></h3><p>一个独一无二的机器ID被存储在 <code>/var/lib/dbus/machine-id</code> （ systemd 系统是保存在 <code>/etc/machine-id</code> ）这些应编辑为通用名称，例如<a href="https://href.li/?https://github.com/Whonix/dist-base-files/blob/master/etc/machine-id" target="_blank" rel="noopener">Whonix ID</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b08dfa6083e7567a1921a715000001fb</span><br></pre></td></tr></table></figure><h3><span id="mac地址欺骗">MAC地址欺骗</span></h3><p>MAC 地址是分配给网络接口控制器（NIC）的唯一标识符。每次您连接到网络时（ WIFI 或以太网）则您的 MAC 地址已暴露。这使人们可以使用它来跟踪您并在本地网络上唯一地标识您。</p><p>但您不应该完全随机化 MAC 地址。拥有完全随机的 MAC 地址是显而易见的，并且会对您脱颖而出的行为产生不利影响。</p><p>MAC 地址的 OUI（组织唯一标识符）部分标识芯片组的制造商。对 MAC 地址的这一部分进行随机化处理可能会为您提供以前从未使用过的OUI，数十年来从未使用过的 OUI 或在您所在的地区极为罕见的 OUI，因此使您脱颖而出，很明显地表明您在欺骗 MAC 地址。</p><p>MAC 地址的末尾标识您的特定设备，并且可以用来跟踪您的设备。仅对 MAC 地址的这一部分进行随机化可防止您被跟踪，同时仍使MAC地址看起来可信。</p><p>要欺骗这些地址，请首先执行以下命令找出您的网络接口名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure><p>接下来，安装 macchanger 并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">macchanger -e $network_interface</span><br></pre></td></tr></table></figure><p>要在每次引导时随机分配 MAC 地址，您应该为您的特定初始化系统创建一个初始化脚本。这是 systemd的一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;macchanger on eth0</span><br><span class="line">Wants&#x3D;network-pre.target</span><br><span class="line">Before&#x3D;network-pre.target</span><br><span class="line">BindsTo&#x3D;sys-subsystem-net-devices-eth0.device</span><br><span class="line">After&#x3D;sys-subsystem-net-devices-eth0.device</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;macchanger -e eth0</span><br><span class="line">Type&#x3D;oneshot</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>上面的示例在启动时欺骗了 eth0 接口的 MAC 地址。将 eth0 替换为您的网络接口。</p><h3><span id="时间攻击">时间攻击</span></h3><p>几乎每个系统都有不同的时间。这可用于时钟偏斜指纹攻击，几毫秒的差异足以使用户被暴露识别。</p><h4><span id="icmp时间戳">ICMP时间戳</span></h4><p>ICMP 时间戳会在查询答复中泄漏系统时间。阻止这些攻击的最简单方法是利用防火墙阻止传入连接，或者使内核忽略 ICMP 请求。</p><h4><span id="tcp-时间戳">TCP 时间戳</span></h4><p>TCP 时间戳也会泄漏系统时间。内核尝试通过对每个连接使用随机偏移量来解决此问题，但<a href="https://href.li/?https://forums.whonix.org/t/do-ntp-and-tcp-timestamps-really-leak-your-local-time/7824/10" target="_blank" rel="noopener">这不足以解决问题</a>。因此应该禁用 TCP 时间戳，可以通过使用 sysctl 设置以下内容来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps&#x3D;0</span><br></pre></td></tr></table></figure><h4><span id="tcp-初始化序号">TCP 初始化序号</span></h4><p>TCP 初始序列号（ISN）是泄漏系统时间的另一种方法。为了减轻这种情况，您必须<a href="https://href.li/?https://github.com/0xsirus/tirdad" target="_blank" rel="noopener">安装tirdad内核模块</a>，该模块会生成用于连接的随机ISN。</p><h4><span id="时间同步">时间同步</span></h4><p>时间同步对于匿名性和安全性至关重要。错误的系统时钟可能使您遭受时钟偏斜指纹攻击，或者可以用来为您提供过时的 HTTPS 证书，从而绕过证书到期或吊销。</p><p>最流行的时间同步方法 NTP 是不安全的，因为它未经加密和未经身份验证，因此攻击者可以轻易地拦截和修改请求。NTP 还会以 NTP 时间戳格式泄漏本地系统时间，该格式可用于时钟偏斜指纹识别，如前所述。</p><p>因此，您应该卸载所有 NTP 客户端并禁用 systemd-timesyncd（如果正在使用）。您可以通过安全连接（HTTPS或最好是Torion服务）连接到受信任的网站，而不是 NTP，并从 HTTP 标头中提取当前时间。达到此目的的工具是 sdwdate 或我自己的<a href="https://href.li/?https://gitlab.com/madaidan/secure-time-sync" target="_blank" rel="noopener">安全时间同步工具</a>。</p><h3><span id="按键指纹">按键指纹</span></h3><p>可以通过他们在键盘上输入键的方式来对人进行指纹识别。您可以通过键入速度，在两次按键之间的暂停，每次按键被按下和释放的确切时间等方式来唯一地进行指纹识别。可以使用<a href="https://href.li/?https://www.keytrac.net/en/tryout" target="_blank" rel="noopener">KeyTrac</a>在线进行测试。</p><p><a href="https://href.li/?https://github.com/vmonaco/kloak" target="_blank" rel="noopener">Kloak</a>是一种工具，旨在通过混淆按键和释放事件之间的时间间隔来克服这种跟踪方法。当按键被按下时，它会引入随机延迟，然后由应用程序选择。</p><h2><span id="文件权限">文件权限</span></h2><p>默认情况下，文件的权限是非常宽松的。您应该在整个系统中搜索权限不当的文件和目录，并对其进行限制。例如，在诸如 Debian 之类的某些发行版中，用户的 Home 目录是全局可读的。</p><p>这可以通过执行以下操作来限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 &#x2F;home&#x2F;$user</span><br></pre></td></tr></table></figure><p>另外一些示例是/boot，/usr /src和/ {,usr /} lib/modules 它们包含内核映像，System.map和其他各种文件，所有这些文件都可能泄漏有关内核的敏感信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 &#x2F;boot &#x2F;usr&#x2F;src &#x2F;lib&#x2F;modules &#x2F;usr&#x2F;lib&#x2F;modules</span><br></pre></td></tr></table></figure><p>在基于 Debian 的发行版中，必须使用 dpkg-statoverride 保留文件许可权。否则，它们将在更新期间被覆盖。</p><p>Whonix的<a href="https://href.li/?https://www.whonix.org/wiki/SUID_Disabler_and_Permission_Hardener" target="_blank" rel="noopener">SUID Disabler和Permission Hardener</a>会自动应用本节中详细介绍的步骤。</p><h3><span id="setuid-setgid">setuid / setgid</span></h3><p>Setuid / SUID 允许用户使用二进制文件所有者的特权执行二进制文件。这通常用于允许非特权用户使用通常仅为 root 用户保留的某些功能。因此，许多 SUID 二进制文件都有特权升级安全漏洞的历史记录。 Setgid / SGID 类似，但适用于组而不是用户。要使用 setuid 或 setgid 位查找系统上的所有二进制文件，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -type f \( -perm -4000 -o -perm -2000 \)</span><br></pre></td></tr></table></figure><p>然后，您应该删除不使用的程序上的所有不必要的 setuid / setgid 位，或将其替换为功能。要删除 setuid 位，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-s $path_to_program</span><br></pre></td></tr></table></figure><p>要删除 setgid 位，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod g-s $path_to_program</span><br></pre></td></tr></table></figure><p>要向文件添加功能，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcap $capability+ep $path_to_program</span><br></pre></td></tr></table></figure><p>或者，要删除不必要的功能，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcap -r $path_to_program</span><br></pre></td></tr></table></figure><h3><span id="umask">umask</span></h3><p>umask 设置新创建文件的默认文件权限。默认的 umask 是0022，它不是很安全，因为它为系统上的每个用户提供了对新创建文件的读取访问权限。要使所有者以外的任何人都不可读新文件，请编辑 /etc/profile 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask 0077</span><br></pre></td></tr></table></figure><h2><span id="核心转储">核心转储</span></h2><p>核心转储包含特定时间（通常是该程序崩溃时）该程序的已记录内存。它们可能包含敏感信息，例如密码和加密密钥，因此必须将其禁用。</p><p>禁用它们的方法主要有三种：sysctl，systemd 和 ulimit</p><h3><span id="sysctl">sysctl</span></h3><p>通过 sysctl 设置以下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.core_pattern&#x3D;|&#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><h3><span id="systemd">systemd</span></h3><p>创建 <code>/etc/systemd/coredump.conf.d/disable.conf</code> 并添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Coredump]</span><br><span class="line">Storage&#x3D;none</span><br></pre></td></tr></table></figure><h3><span id="ulimit">ulimit</span></h3><p>编辑/etc/security/limits.conf并添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* hard core 0</span><br></pre></td></tr></table></figure><h3><span id="setuid进程">setuid进程</span></h3><p>即使在进行了这些设置之后，以提升的特权运行的进程仍可能会转储其内存。</p><p>为了防止他们这样做，请通过 sysctl 设置以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.suid_dumpable&#x3D;0</span><br></pre></td></tr></table></figure><h2><span id="swap">Swap</span></h2><p>与核心转储类似，交换或分页将部分内存复制到磁盘，其中可能包含敏感信息。应该将内核配置为仅在绝对必要时进行交换，相应的 sysctl 设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness&#x3D;1</span><br></pre></td></tr></table></figure><h2><span id="pam">PAM</span></h2><p>PAM 是用于用户身份验证的框架。这就是您登录时使用的机制。您可以通过要求使用强密码或在失败的登录尝试后强制执行延迟验证来使其更加安全。</p><p>要强制使用强密码，可以使用 pam_pwquality。它强制执行密码的可配置策略。例如，如果您希望密码至少包含 16 个字符（最小），与旧密码（difok）至少 6 个不同的字符，至少 3 个数字（dcredit），至少 2 个大写字母（ucredit），至少 2 个字符小写字母（lcredit）和至少 3 个其他字符（ocredit），然后编辑 /etc/pam.d/passwd 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password required pam_pwquality.so retry&#x3D;2 minlen&#x3D;16 difok&#x3D;6 dcredit&#x3D;-3 ucredit&#x3D;-2 lcredit&#x3D;-2 ocredit&#x3D;-3 enforce_for_root</span><br><span class="line">password required pam_unix.so use_authtok sha512 shadow</span><br></pre></td></tr></table></figure><p>要强制执行延迟验证，可以使用 pam_faildelay。要在两次失败的登录尝试之间添加至少4秒的延迟以阻止暴力破解尝试，请编辑 /etc/pam.d/system-login 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth optional pam_faildelay.so delay&#x3D;4000000</span><br></pre></td></tr></table></figure><p>4000000 是 4 秒（以微秒为单位）。</p><h2><span id="microcode更新">Microcode更新</span></h2><p>Microcode 更新对于修复关键的 CPU 漏洞（如 Meltdown 和 Spectre 等）至关重要。大多数发行版都将这些发行版包含在其软件仓库中，例如<a href="https://href.li/?https://wiki.archlinux.org/index.php/Microcode" target="_blank" rel="noopener">Arch Linux</a>和<a href="https://href.li/?https://wiki.debian.org/Microcode" target="_blank" rel="noopener">Debian</a>。</p><h2><span id="ipv6-隐私扩展">IPv6 隐私扩展</span></h2><p>IPv6 地址是从计算机的 MAC 地址生成的，从而使您的 IPv6 地址是唯一的，并直接绑定到计算机。隐私扩展会生成一个随机的 IPv6 地址，以减轻这种形式的跟踪。请注意，如果您开启了 MAC 地址欺骗机制或禁用了 IPv6，则无需执行这些步骤。</p><p>要启用这些功能，请通过sysctl设置以下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.use_tempaddr&#x3D;2</span><br><span class="line">net.ipv6.conf.default.use_tempaddr&#x3D;2</span><br></pre></td></tr></table></figure><h3><span id="networkmanager">NetworkManager</span></h3><p>要为NetworkManager启用隐私扩展，请编辑 <code>/etc/NetworkManager/NetworkManager.conf</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[connection]</span><br><span class="line">ipv6.ip6-privacy&#x3D;2</span><br></pre></td></tr></table></figure><h3><span id="systemd-networkd">systemd-networkd</span></h3><p>要为 systemd-networkd 启用隐私扩展，请创建 <code>/etc/systemd/network/ipv6-privacy.conf</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Network]</span><br><span class="line">IPv6PrivacyExtensions&#x3D;kernel</span><br></pre></td></tr></table></figure><h3><span id="分区和挂载选项">分区和挂载选项</span></h3><p>文件系统应分为多个分区，以对其权限进行细粒度控制。可以添加不同的安装选项以限制可以执行的操作：</p><ul><li>nodev - 禁止使用设备</li><li>nosuid - 禁止setuid或setgid位</li><li>noexec - 禁止执行任何二进制文件</li></ul><p>这些安装选项应在 /etc/fstab 中尽可能设置。如果您不能使用单独的分区，请创建绑定挂载。一个更安全的 /etc/fstab 的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;        &#x2F;          ext4    defaults                              1 1</span><br><span class="line">&#x2F;home    &#x2F;home      ext4    defaults,nosuid,noexec,nodev          1 2</span><br><span class="line">&#x2F;tmp     &#x2F;tmp       ext4    defaults,bind,nosuid,noexec,nodev     1 2</span><br><span class="line">&#x2F;var     &#x2F;var       ext4    defaults,bind,nosuid                  1 2</span><br><span class="line">&#x2F;boot    &#x2F;boot      ext4    defaults,nosuid,noexec,nodev          1 2</span><br></pre></td></tr></table></figure><p>请注意，可以<a href="https://href.li/?https://chromium.googlesource.com/chromiumos/docs/+/master/security/noexec_shell_scripts.md" target="_blank" rel="noopener">通过shell脚本绕过noexec</a>。</p><h2><span id="熵">熵</span></h2><p>熵基本上反应操作系统信息收集的随机程度，对于诸如加密之类的事情至关重要。因此，最好通过安装其他随机数生成器（如<a href="https://href.li/?http://www.issihosts.com/haveged/" target="_blank" rel="noopener">haveged</a>和<a href="https://href.li/?https://github.com/smuellerDD/jitterentropy-rngd" target="_blank" rel="noopener">jitterentropy</a>）从各种来源收集尽可能多的熵。</p><p>为了使jitterentropy正确运行，必须通过创建 <code>/usr/lib/modules-load.d/jitterentropy.conf</code> 并添加以下内容尽早加载内核模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jitterentropy_rng</span><br></pre></td></tr></table></figure><h3><span id="rdrand">RDRAND</span></h3><p>RDRAN 是提供随机数的 CPU 指令。如果可用，内核会自动将其用作熵源。但是由于它是专有的并且是 CPU 身的一部分，因此无法审核和验证其安全性。您甚至无法对代码进行反向工程。该RNG以前曾遭受过漏洞的攻击，其中有些可能是后门攻击。通过设置以下引导参数可以不信任此功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random.trust_cpu&#x3D;off</span><br></pre></td></tr></table></figure><h2><span id="以-root-身份编辑文件">以 root 身份编辑文件</span></h2><p>建议不要以 root 用户身份运行普通的文本编辑器。大多数文本编辑器可以做的不仅仅是简单地编辑文本文件，而且还可以被利用。例如，以 root 身份打开 vi 并输入：sh。现在，您具有一个可以访问整个系统的 root shell，攻击者可以轻松利用该 shell。</p><p>解决方案是使用 sudoedit。这会将文件复制到一个临时位置，以普通用户身份打开文本编辑器，编辑该临时文件并以root用户身份覆盖原始文件。这样，实际的编辑器就不会以 root 身份运行。要使用 sudoedit，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudoedit $path_to_file</span><br></pre></td></tr></table></figure><p>默认情况下，它使用 vi，但是可以通过 EDITOR 或 SUDO_EDITOR 环境变量来切换默认编辑器。例如，要使用 nano，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR&#x3D;nano sudoedit $path_to_file</span><br></pre></td></tr></table></figure><p>可以在 /etc/environment 中全局设置此环境变量。</p><h2><span id="特定发行版的安全强化">特定发行版的安全强化</span></h2><h3><span id="http包管理器镜像">HTTP包管理器镜像</span></h3><p>默认情况下，Linux发行版通常使用 HTTP 或 HTTP 和 HTTPS 镜像的混合来从其软件存储库下载软件包。人们认为这很好，因为程序包管理器会在安装前验证程序包的签名。但是，从历史上看，已经有很多绕过此方法的地方。您应将软件包管理器配置为从 HTTPS 镜像专门下载以进行深度防御。</p><h3><span id="apt-seccomp-bpf">APT seccomp-bpf</span></h3><p>自软件包管理器 Debian Buster 以来，APT 已支持可选的 seccomp-bpf 过滤。这限制了允许执行APT的系统调用，这可能严重限制攻击者尝试利用APT中的漏洞时对系统造成危害的能力。要启用此功能，请创建 <code>/etc/apt/apt.conf.d/40sandbox</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APT::Sandbox::Seccomp &quot;true&quot;;</span><br></pre></td></tr></table></figure><h2><span id="物理安全">物理安全</span></h2><p>全盘加密可确保对驱动器上的所有数据进行加密，并且不会被物理攻击者读取。大多数发行版都支持在安装过程中启用加密，请确保设置了强密码。您也可以使用<a href="https://href.li/?https://wiki.archlinux.org/index.php/Dm-crypt" target="_blank" rel="noopener">dm-crypt</a>手动加密驱动器。</p><p>请注意，全盘加密不包括 /boot，这样仍然可以修改内核、引导加载程序和其他关键文件。为了完全防止篡改，您还必须实施经过验证的引导。</p><h3><span id="bios-uefi强化">BIOS / UEFI强化</span></h3><p>如果您仍在使用旧版 BIOS，则应迁移到 UEFI，以利用较新的安全功能。大多数 BIOS 或 UEFI 实现都支持设置密码。最好启用它并设置一个非常强壮的密码。虽然这是很弱的保护，因为重置密码很简单。它通常存储在易失性内存中，因此攻击者只需要能够卸下 CMOS 电池几秒钟，或者他们就可以使用某些主板上的跳线将其重置。</p><p>您还应该禁用所有未使用的设备和引导选项，例如USB引导，以减少攻击面。</p><p>别忽略 BIOS 或 UEFI 的更新，确保将其更新。将其与常规操作系统更新一样重要。</p><p>此外，请参阅<a href="https://href.li/?https://github.com/nsacyber/Hardware-and-Firmware-Security-Guidance" target="_blank" rel="noopener">《NSA的硬件和固件安全指南》</a></p><h3><span id="bootloader-密码">Bootloader 密码</span></h3><p>引导加载程序会在引导过程的早期执行，并负责加载操作系统。保护它非常重要，否则，它可能会被篡改。例如，本地攻击者可以通过在启动时使用 <code>init=/bin/bash</code> 作为内核参数来轻松获得 root shell，该命令告诉内核执行 /bin/bash 而不是常规的 init 系统。您可以通过为引导加载程序设置密码来防止这种情况。仅设置引导程序密码不足以完全保护它。还必须按照以下说明设置经过验证的启动。</p><h4><span id="grub">Grub</span></h4><p>要为 GRUB 设置密码，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkpasswd-pbkdf2</span><br></pre></td></tr></table></figure><p>输入您的密码，该密码将生成一个字符串。它将类似于 &quot;grub.pbkdf2.sha512.10000.C4009… &quot; 。创建 <code>/etc/grub.d/40_password</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set superusers&#x3D;&quot;$username&quot;</span><br><span class="line">password_pbkdf2 $username $password</span><br></pre></td></tr></table></figure><p>用 grub-mkpasswd-pbkdf2 生成的字符串替换 “$password”。 “$username” 将用于被允许使用GRUB命令行，编辑菜单项和执行任何菜单项的超级用户。对于大多数人来说，这只是 &quot;root”。</p><p>重新生成您的配置文件，GRUB 现在将受到密码保护。</p><p>要仅限制编辑引导参数并访问 GRUB 控制台，同时仍然允许您引导，请编辑 <code>/boot/grub/grub.cfg</code> 并在 &quot;menuentry $OSName &quot; 旁边添加 <code>-–unrestricted</code> 参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menuentry &#39;Arch Linux&#39; --unrestricted</span><br></pre></td></tr></table></figure><p>您将需要再次重新生成配置文件以应用此更改。</p><h3><span id="syslinux">Syslinux</span></h3><p>Syslinux 可以设置主密码或菜单密码。引导任何条目都需要主密码，而引导特定条目仅需要菜单密码。</p><p>要为 Syslinux 设置主密码，请编辑 <code>/boot/syslinux/syslinux.cfg</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MENU MASTER PASSWD $password</span><br></pre></td></tr></table></figure><p>要设置菜单密码，请编辑 <code>/boot/syslinux/syslinux.cfg</code> ，并在带有您要密码保护的项目的标签内，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MENU PASSWD $password</span><br></pre></td></tr></table></figure><p>将 “$password” 替换为您要设置的密码。</p><p>这些密码可以是纯文本，也可以使用MD5，SHA-1，SHA-256 或 SHA-512 进行散列。建议先使用强哈希算法（例如SHA-256或SHA-512）对密码进行哈希处理，以避免将其存储为明文形式。</p><h3><span id="systemd-boot">systemd-boot</span></h3><p>systemd-boot 具有防止在引导时编辑内核参数的选项。在 loader.conf文件中，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editor no</span><br></pre></td></tr></table></figure><p>systemd-boot 并不正式支持保护内核参数编辑器的密码，但是您可以<a href="https://href.li/?https://github.com/kitsunyan/systemd-boot-password" target="_blank" rel="noopener">使用systemd-boot-password来实现</a>。</p><h3><span id="验证引导">验证引导</span></h3><p>经过验证的引导通过密码验证来确保引导链和基本系统的完整性。这可用于确保物理攻击者无法修改设备上的软件。</p><p>如果没有经过验证的引导，则一旦获得物理访问权限，就可以轻松绕过上述所有预防措施。经过验证的引导不仅像许多人认为的那样是为了物理安全。它还可以用于防止远程恶意软件持久化——如果攻击者设法破坏了整个系统并获得了很高的特权，则经过验证的引导将在重新引导后还原其更改，并确保它们无法持久化。</p><p>经过验证的最常见的引导实现是UEFI安全引导，但是它本身并不是一个完整的实现，因为它仅会验证引导加载程序和内核，这意味着可以通过以下方法：</p><ul><li>仅UEFI安全启动就没有一成不变的信任根，因此物理攻击者仍然可以刷新设备的固件。为了减轻这种情况，请结合使用UEFI安全启动和 Intel Boot Guard 或 AMD Secure Boot。</li><li>远程攻击者（或不使用加密的物理攻击者）可以简单地修改操作系统的任何其他特权部分。例如，如果他们有修改内核的特权，那么他们也可以修改 /sbin/init 来有效地获得相同的结果。因此，仅验证内核和引导加载程序不会对远程攻击者产生任何影响。为了减轻这种情况，您必须使用<a href="https://href.li/?https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/verity.html" target="_blank" rel="noopener">dm-verity</a>验证基本操作系统，尽管由于传统Linux发行版的布局，这非常困难且笨拙。</li></ul><p>通常，很难在传统Linux上实现可靠的经过验证的引导实现。</p><h3><span id="usbs">USBs</span></h3><p>USB设备为物理攻击提供了重要的攻击面。例如<a href="https://href.li/?https://srlabs.de/bites/badusb/" target="_blank" rel="noopener">BadUSB</a>和<a href="https://href.li/?https://en.wikipedia.org/wiki/Stuxnet" target="_blank" rel="noopener">Stuxnet</a>是此类攻击的范例。最佳实践是禁止所有新连接的USB且仅将受信任设备列入白名单，<a href="https://href.li/?https://usbguard.github.io/" target="_blank" rel="noopener">USBGuard</a>对此非常有用。</p><p>您也可以将nousb用作内核引导参数，以禁用内核中的所有USB支持。可以 sysctl 设置kernel.deny_new_usb=1</p><h3><span id="dma攻击">DMA攻击</span></h3><p>直接内存访问（DMA）攻击涉及通过插入某些物理设备来完全访问所有系统内存。这可以通过控制设备可访问的内存区域的<a href="https://href.li/?https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit" target="_blank" rel="noopener">IOMMU</a>或将特别易受攻击的内核模块列入黑名单来缓解。</p><p>要启用 IOMMU，请设置以下内核引导参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intel_iommu&#x3D;on amd_iommu&#x3D;on</span><br></pre></td></tr></table></figure><p>您只需要为特定的 CPU 制造商启用该选项，但同时启用这两个选项就没有问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efi&#x3D;disable_early_pci_dma</span><br></pre></td></tr></table></figure><p>通过在非常早的启动过程中禁用所有 PCI 桥接器上的 busmaster 位，此选项可<a href="https://href.li/?https://mjg59.dreamwidth.org/54433.html" target="_blank" rel="noopener">修复上述IOMMU中的漏洞</a>。</p><p>此外，Thunderbolt 和 FireWire 通常容易受到 DMA 攻击。要禁用它们，请将这些内核模块列入黑名单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install firewire-core &#x2F;bin&#x2F;false</span><br><span class="line">install thunderbolt &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><h3><span id="冷启动攻击">冷启动攻击</span></h3><p>当攻击者在擦除 RAM 中的数据之前对其进行分析时，就会发生<a href="https://href.li/?https://en.wikipedia.org/wiki/Cold_boot_attack" target="_blank" rel="noopener">冷启动攻击</a>。使用现代 RAM 时，冷启动攻击不太实用，因为 RAM 通常会在几秒钟或几分钟内清除，除非将其放入冷却液（如液氮或冷冻机）中。攻击者必须在几秒钟内将设备中的RAM棒拔出并将其暴露于液氮中，而且确保用户不会注意到。</p><p>如果冷启动攻击是威胁模型的一部分，请在关机后保护计算机几分钟，以确保没有人可以访问您的 RAM 记忆棒。您也可以将 RAM 棒焊接到主板上，以使其更难以卡住。如果使用笔记本电脑，请取出电池，然后直接用充电电缆供电。关机后请拔出电缆，以确保RAM彻底断电无法访问。</p><p>在内核自我保护启动参数部分中，空闲时内存清零选项将用零覆盖内存中的敏感数据。此外，强化的内存分配器可以通过 <code>CONFIG_ZERO_ON_FREE</code> 配置选项清除用户空间堆内存中的敏感数据。尽管如此，某些数据仍可能保留在内存中。</p><p>此外，现代内核还包括<a href="https://href.li/?https://lwn.net/Articles/730006/" target="_blank" rel="noopener">复位攻击缓解</a>措施，该命令可命令固件在关机时擦除数据，尽管这需要<a href="https://href.li/?https://www.trustedcomputinggroup.org/wp-content/uploads/Platform-Reset-Attack-Mitigation-Specification.pdf" target="_blank" rel="noopener">固件支持</a>。</p><p>确保正常关闭计算机，以使上述缓解措施可以开始。</p><p>如果以上都不适用您的威胁模型，则可以实施<a href="https://href.li/?https://tails.boum.org/contribute/design/memory_erasure/" target="_blank" rel="noopener">Tails的内存擦除过程</a>，该过程将擦除大部分内存（视频内存除外），并且已被证明是有效的。</p><h2><span id="最佳实践">最佳实践</span></h2><p>一旦对系统进行了尽可能多的加固，就应该遵循良好的隐私和安全性惯例：</p><ul><li>禁用或删除不需要的东西以最小化攻击面。</li><li>保持更新。配置 cron 任务或 init 脚本以每天更新系统。</li><li>不要泄漏有关您或您的系统的任何信息，无论它看起来多么渺小。</li><li>遵循<a href="https://href.li/?https://madaidans-insecurities.github.io/security-privacy-advice.html" target="_blank" rel="noopener">常规的安全和隐私建议</a></li></ul><p>尽管已经进行了强化，但您必须记住 Linux 仍然是一个有缺陷的操作系统，没有任何强化可以完全修复它。</p><h2><span id="其他指南">其他指南</span></h2><p>您应该进行尽可能多的研究，而不要依赖单一的信息来源。最大的安全问题之一就是用户。这些是我认为有价值的其他指南的链接：</p><ul><li><p><a href="https://href.li/?https://wiki.archlinux.org/index.php/Security" target="_blank" rel="noopener">Arch Linux Security wiki page</a></p></li><li><p><a href="https://href.li/?https://www.whonix.org/wiki/Documentation" target="_blank" rel="noopener">Whonix Documentation</a></p></li><li><p><a href="https://href.li/?https://apps.nsa.gov/iaarchive/library/ia-guidance/security-configuration/operating-systems/guide-to-the-secure-configuration-of-red-hat-enterprise.cfm" target="_blank" rel="noopener">NSA RHEL 5 Hardening Guide</a> (稍有过时，但仍包含有用的信息）</p></li><li><p><a href="https://href.li/?https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings" target="_blank" rel="noopener">KSPP recommended kernel settings</a></p></li><li><p><a href="https://href.li/?https://github.com/a13xp0p0v/kconfig-hardened-check/" target="_blank" rel="noopener">kconfig-hardened-check</a></p></li></ul><h2><span id="术语">术语</span></h2><p>您可能需要重新生成 GRUB 配置，以应用对引导加载程序所做的某些更改。在不同的发行版之间，执行此操作的步骤有时可能会有所不同。例如，在诸如 Arch Linux 之类的发行版上，应通过执行以下命令来重新生成配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o $path_to_grub_config</span><br></pre></td></tr></table></figure><p>“$path_to_grub_config” 取决于您如何设置系统。它通常是 <code>/boot/grub/grub.cfg</code>或 <code>/boot/EFI/grub/grub.cfg</code>，但是在执行此命令之前，请务必确保正确。</p><p>另外，在 Debian 或 Ubuntu 等发行版上，您应该执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure><h2><span id="能力">能力</span></h2><p>在 Linux 内核中，“root 特权” 分为各种不同的能力（<a href="https://href.li/?https://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">capabilities</a>）。这在应用最小特权原则时很有帮助——可以给它们仅授予特定的子集，而不是授予进程总的 root 特权。例如，如果程序只需要设置系统时间，则只需要 CAP_SYS_TIME 而不是 root 所有能力。这会限制可能造成的损害，但是，您仍必须谨慎授予能力，因为无论如何，其中许多能力<a href="https://href.li/?https://forums.grsecurity.net/viewtopic.php?t=2522" target="_blank" rel="noopener">可能会被滥用以获取完整的root特权</a>。</p><p>本文翻译自：<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html" target="_blank" rel="noopener">https://madaidans-insecurities.github.io/guides/linux-hardening.html</a></p><p><strong>如需『 Linux 系统安全强化指南 』PDF 高清版，可在公众号对话框回复关键字：「<code>LinuxSecurity</code>」获取。</strong></p><blockquote><p>本文转载自：「 GAO CHAO’S NEW BLOG 」，原文：<a href="http://t.cn/A6VwHzjQ" target="_blank" rel="noopener">http://t.cn/A6VwHzjQ</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本指南旨在说明如何尽可能地加强 Linux 的安全性和隐私性，并且不限于任何特定的指南。&lt;/p&gt;
&lt;p&gt;免责声明：如果您不确定自己在做什么，请不要尝试在本文中使用任何内容。&lt;/p&gt;
&lt;p&gt;本指南仅关注安全性和隐私性，而不关注性能，可用性或其他内容。&lt;/p&gt;
&lt;p&gt;列出的所有命令都将需要 root 特权。以 &lt;code&gt;$&lt;/code&gt; 符号开头的单词表示一个变量，不同终端之间可能会有所不同。&lt;/p&gt;
&lt;h2 id=&quot;选择正确的Linux发行版&quot;&gt;选择正确的Linux发行版&lt;/h2&gt;
&lt;p&gt;选择一个好的 Linux 发行版有很多因素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;避免分发冻结程序包，因为它们在安全更新中通常很落后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用与 Systemd 机制的发行版。 Systemd 包含许多不必要的攻击面；它尝试做的事情远远超出了必要，并且超出了初始化系统应做的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 musl 作为默认的 C 库。 Musl 专注于最小化，这会导致很小的攻击面，而其他 C 库（例如 glibc）过于复杂，容易产生漏洞。例如，与 musl 中的极少数漏洞相比，glibc 中的一百多个漏洞已被公开披露。尽管仅靠披露的 CVE 本身通常是不准确的统计信息，但有时这种情况有时可以用来表示过分的问题。 Musl还具有不错的漏洞利用缓解措施，尤其是其新的强化内存分配器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最好默认情况下使用 LibreSSL 而不是 OpenSSL 的发行版。OpenSSL 包含大量完全不必要的攻击面，并且遵循不良的安全做法。例如，它仍然保持 OS / 2和 VMS 支持这些已有数十年历史的古老操作系统。这些令人讨厌的安全做法导致了可怕的 Heartbleed 漏洞。LibreSSL 是 OpenBSD 团队的 OpenSSL 分支，它采用了出色的编程实践并消除了很多攻击面。在 LibreSSL 成立的第一年内，它缓解了许多漏洞，其中包括一些高严重性的漏洞。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用作强化操作系统基础的最佳发行版是 Gentoo Linux，因为它可以让您精确地配置系统，以达到理想的效果，这将非常有用，尤其是参考我们在后面的章节中使用更安全的编译标志。&lt;/p&gt;
&lt;p&gt;但是，由于 Gentoo 的巨大可用性缺陷，它对于许多人来说可能并不顺手。在这种情况下，Void Linux的 Musl 构建是一个很好的折衷方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="安全" scheme="https://www.hi-linux.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>小白也能看懂的网络基础 | 02 连接设备？</title>
    <link href="https://www.hi-linux.com/posts/50201.html"/>
    <id>https://www.hi-linux.com/posts/50201.html</id>
    <published>2021-05-21T01:00:00.000Z</published>
    <updated>2021-05-21T10:02:25.206Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言">引言</span></h2><p>欢迎来到网络世界，《小白也能看懂的网络基础》系列文章会从零开始帮助你构建网络的基础知识。如果你完全没有接触过网络相关的内容，那我们是一样的，在学习过程中我们肯定遇到了相同的问题！写下这些文章一方面要记录自己的学习历程，另一方面也希望帮到同样想要学习网络基础的小伙伴。</p><p>文章的部分内容与素材是我从【Youtube平台】的【<a href="https://www.youtube.com/channel/UCtuXekfqj-paqsxtqVNCC2A" target="_blank" rel="noopener">Network Direction</a>】发布的系列视频学习和搜集过来的，翻译不易，部分内容可能无法做到尽善尽美，甚至可能会有部分瑕疵，我会尽力让文章内容通俗易懂，覆盖全面。若各位小伙伴发现任何问题，希望能够留言或私信告诉我，在下不胜感激！当然，我也会在第一时间进行更正。</p><p>在往后的每一篇文章中，我都会把看到文章的小伙伴当成是完全没有网络经验的小白，我的目标是和零基础小白一起建立坚实的网络基础，网络大神请略过此系列文章。</p><p>让我们开始网络之旅吧！</p><a id="more"></a><h2><span id="线缆和-wi-fi">线缆和 Wi-Fi</span></h2><h3><span id="1连接设备">1.连接设备</span></h3><p>首先我们需要知道，想要将设备连接到网络，有两种方式可供选择，那就是「<strong>有线和无线</strong>」。</p><p>相信大家对这两兄弟都不陌生了，有线连接从很早以前就出现了，最早可追溯到1960年代，有线网络使用电缆进行连接。</p><p>而无线技术的发展，也已经有相当长的一段历史了，最早可追溯到1990年代。说到无线，我们最先想到的就是与它相关的移动设备，例如：收音机、手机、便携式笔记本电脑等。对于无线技术，我们经常称它为「Wi-Fi」。</p><p><img src="https://img.hi-linux.com/staticfile/a4eb6a3ea8ddc076a20906b97cd2cfa1-2021-03-17-ssNJJ7.gif" alt="有线和无线"></p><h4><span id="1-有线设备">1. 有线设备</span></h4><p>电缆通常使用铜线制成，铜缆更便宜，常用于短距离传输，同时因为它是使用电信号进行信息传播，这就意味着它可能会受到外界电磁干扰的影响，所以，我们常见的网线多由多股线栏缠绕制成，后面的小节会讲到原因。</p><p>光纤通常使用玻璃作为传输介质，可用于较长距离信号传输，因其使用光信号，所以不易受外界信号干扰，但因为其材质的特殊，导致光纤的价格通常都比较昂贵。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140149102-2021-03-16-BzMdPa.png" alt></p><table><thead><tr><th><strong>铜缆</strong></th><th><strong>光纤</strong></th></tr></thead><tbody><tr><td>铜丝制作</td><td>玻璃制作</td></tr><tr><td>更便宜</td><td>更昂贵</td></tr><tr><td>短距离传输</td><td>较长距离传输</td></tr><tr><td>使用电信号</td><td>使用光信号</td></tr><tr><td>容易受到外界干扰</td><td>不受外界干扰</td></tr></tbody></table><h4><span id="2-无线设备">2. 无线设备</span></h4><p>无论是台式机，还是移动笔记本，或者是手机平板电脑，如果想要实现无线连接，就必须配备无线网卡，大部分情况下，台式机是没有无线网卡的，因此需要单独购买无线网卡，可以直接通过USB连接以实现无线上网。</p><h2><span id="以太网协议">以太网协议</span></h2><p>由于 <strong>「以太网」</strong> 构建简单、成本低、可扩展性强、与IP网能够很好地结合等特点，使它成为局域网网络构建中最常用的一种技术。对于 <strong>「以太网协议」</strong>，则代表了接入以太网的节点设备都达成一致的一组规则。想要接入以太网，就必须按 <strong>「合同」</strong> 办事儿。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-4rjH9z.gif" alt="以太网"></p><p><strong>「以太网」</strong> 由许多不同的部分组成，其中一部分描述了 <strong>线缆的类型</strong> 以及 <strong>不同线缆的传输速度</strong>；另一部分则描述了数据应该 <strong>如何进行格式化</strong> 和 <strong>发送</strong> 的操作，这部分被称为 <strong>「媒体访问控制」</strong>。</p><p><strong>「以太网」</strong> 这样来分层的主要原因，是为了兼容不同线缆以不同速度访问不同的设备，却依然能够保证设备间的正常通信，毕竟我们无法保证每台设备、线缆及其传输速度都相同，差异性是不可避免的问题！</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-bpNhFR.gif" alt="本地主机访问服务器"></p><p>举个例子：一个具有 1G b网络带宽的本地主机，想要将数据发送到具有10Gb带宽的服务器上，这中间经历了哪些操作？</p><p>首先，本地主机根据「媒体访问控制」规则准备一条信息，接下来，再根据它必须遵循的物理规则来发送信息；然后，信息通过物理线缆发送到了服务器这边，当服务器收到消息，它会对这段消息进行解码，并通过「媒体访问控制」，传递到服务器主机。</p><p>正是因为本地主机与服务器主机都遵循了以太网的协议规则，才能保证彼此间的通信不会出现问题，并最终将信息传递到目的地。即使双方使用不同的线缆、带宽与设备， 该分层系统仍然畅通无阻 ！</p><h3><span id="1-以太网协议标准">1. 以太网协议标准</span></h3><p>以太网技术诞生以后，IEEE 组织制定了众多以太网不同的技术标准，每一个标准都会用一段代号来命名（就像007和9527一样）。以 802 开头的标准用于局域网技术。而以太网技术的代号是 <strong>802.3</strong> ，再配合一到两个字母就组成了以太网不同的类型。</p><table><thead><tr><th>速度</th><th>常用名称</th><th>非正式名称</th><th>正式名称</th><th>线缆类型</th><th>最大传输距离</th></tr></thead><tbody><tr><td>10Mbps</td><td>以太网</td><td>10BASE-T</td><td>802.3</td><td>双绞线</td><td>100m</td></tr><tr><td>100Mbps</td><td>快速以太网</td><td>100BASE-T</td><td>802.3u</td><td>双绞线</td><td>100m</td></tr><tr><td>1Gbps</td><td>1吉比特以太网</td><td>1000BASE-LX</td><td>802.3z</td><td>光纤</td><td>5000m</td></tr><tr><td>1Gbps</td><td>1吉比特以太网</td><td>1000BASE-T</td><td>802.3ab</td><td>双绞线</td><td>100m</td></tr><tr><td>10Gbpx</td><td>10吉比特以太网</td><td>10GBASE-T</td><td>802.3an</td><td>双绞线</td><td>100m</td></tr></tbody></table><p>单独通过正式名称来记忆这些类型实属不易，因此 IEEE 组织还给我们准备了便于记忆的非正式名称。拿 <strong>10GBASE-T</strong> 来举例，里面的 <strong>10G</strong> 代表了其传输速度为 <strong>「10G比特每秒」</strong>，<strong>「比特」</strong> 是传输速率的单位，比特值越高，其传输速度也越快；<strong>BASE = Baseband</strong>(cables) 是 <strong>基带</strong> 的意思，代表它使用数字信号进行传输（另一种是模拟信号）；而后面的 <strong>T</strong> ，则代表了所使用的线缆类型，T=UTP 也就是双绞线（另一种是LX光纤）。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-gleloB.gif" alt="以太网标准"></p><p>我们已经知道了，电缆使用电信号来传输数据；而光纤使用光信号来传输数据；无论使用哪种信号，这里的数据指的都是我们熟知的 <strong>「01代码」</strong>，接收器会对接收到的 <strong>「01代码」</strong> 进行相应解码，这就是所谓的 <strong>「编码方案」。</strong></p><h3><span id="2-电信号">2. 电信号</span></h3><p>首先我们来看一下电信号，想要发送电信号，就需要拥有电路，这意味着我们需要准备多根电线以传输数据，而我们最常见的线缆称为 <strong>「非屏蔽双绞线」</strong>（UTP，也就是常见的网线），每对电线构成一个电路。</p><p><img src="https://img.hi-linux.com/staticfile/d669b71f87224584ff5ffcc4719382f4-2021-03-16-c7n3d4.gif" alt="非屏蔽双绞线（UTP）"></p><p>听名字我们也知道了，它是非屏蔽的线缆，也就意味着如果外界有电磁干扰，它就会受影响，在初中的时候我们就学习过了，电和磁铁是有一定关系的。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-bzNOtC.gif" alt="电磁干扰"></p><p>电流通过铜缆会产生磁场，同时也生成了电力。问题就出在这里，一对平行运行的电线会产生小的电磁场，如果一对铜线有电流经过，则必定会对其旁边的另一对电线的信号产生电磁干扰，我们称其为 <strong>「串扰」</strong>。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-SvuLn5.gif" alt="串扰"></p><p>为了解决 <strong>「串扰」</strong> 的问题，非屏蔽双绞线则将平行的两根铜缆绞在一起，这样一来，就有效的避免了电磁干扰，而这也是它名字的由来。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-EHSYQH.gif" alt="双绞线"></p><p>如果条件允许的话，你可以找到一条废弃的双绞线，将水晶头去掉，观察一下内部的线缆，就可以清晰的看到，线缆确实是绞在一起的。</p><p><img src="https://img.hi-linux.com/staticfile/1da9a14e0901077a05fd8f67703af114-2021-03-16-7LbeG3.gif" alt="真实的双绞线"></p><h3><span id="3-双绞线">3. 双绞线</span></h3><p>我们可以看到多种不同类型的双绞线，有的中间有塑料芯，有的则是一根细线。通常，我们使用颜色对其进行编码，每对电线都是由<strong>纯色</strong>和<strong>条纹色</strong>组成的，观察图片就不难看出。例如蓝色和蓝白线缆绞在一起，而棕色和棕白线缆绞在一起。</p><p>通常，我们常见的网线都是由四对电线组成的，而在早期的标准中，其线缆并不一定是由四对组成的（例如：10BASE-T 和 100BASE-T 都是由两对绞线组成），但是如果想要让传输速度达到1Gbps或10Gbps，就必须使用全部四对电线才可以。</p><p>不同的以太网标准，需要使用不同的线缆，我们应该都听说过 「5类线」 或 「6类线」 这样的名称，其实这就是不同网线的专用术语，不同的类别对应了不同线缆的标准（例如：线缆的对数、线缆的粗细以及线缆的交合程度）。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140149821-2021-03-16-iD7GHf.png" alt="线缆的不同标准"></p><p>例如：Cat2 仅具有两对线缆，而Cat5具有四对线缆，Cat6 具有比 Cat5 更粗的四对线缆等等</p><p>不同类别的线缆会定义不同的名称，除了数字的不同，后面的英文字母也不同，比如：Cat5e，Cat6，Cat6a，数字越大，标准越新，意味着传输距离越远，速度越高！！</p><p>举一个现实一些的案例，我们可以在 100Mbps 的网络上使用5类线；但如果你想让网速达到千兆，就至少需要使用 Cat5e 这样标准的线缆；而如果你想让网速达到万兆，那就需要使用 Cat6 也就是6类网线才能达到理论速度。</p><p>如果你的带宽达到了万兆，但你的线缆跟不上，仅仅使用5类线 Cat5，那你的实际使用网速肯定达不到万兆，其原因是线缆没法支持那么快的速度！</p><p>所以，回家赶紧看看你家网络的带宽是多少，为什么理论速度达到了，可实际使用却达不到那么快的网速，原因可能就是因为你的线缆太老旧了，扔了换新的吧。</p><table><thead><tr><th>线缆名称</th><th>线缆介绍</th><th>线缆速率</th></tr></thead><tbody><tr><td>CAT-1</td><td>以往用在传统电话的网络线路</td><td>无</td></tr><tr><td>CAT-2</td><td>以往用在令牌环网络</td><td>4 Mbit/s</td></tr><tr><td>CAT-3</td><td>提供16MHz的带宽，曾经常用在 10 Mbit/s 以太网络</td><td>10 Mbit/s</td></tr><tr><td>CAT-4</td><td>提供20MHz的带宽，曾经常用在 16 Mbit/s 的令牌环网</td><td>16 Mbit/s</td></tr><tr><td>CAT-5</td><td>提供100MHz的带宽，目前常用在快速以太网（100 Mbit/s）中</td><td>100 Mbit/s</td></tr><tr><td>CAT-5e</td><td>提供125MHz的带宽，目前常用在快速以太网及千兆以太网（1000Mbit/s）中</td><td>1000 Mbit/s</td></tr><tr><td>CAT-6</td><td>提供250MHz的带宽，比CAT-5与CAT-5e高出一倍半</td><td>2500 Mbit/s</td></tr><tr><td>CAT-6A</td><td>提供500MHz的带宽，使用在万兆以太网（10 Gbit/s）中</td><td>10 Gbit/s</td></tr><tr><td>CAT-7</td><td>设计供以600MHz频率传输信号</td><td>未定</td></tr></tbody></table><h3><span id="4-电缆的连接器">4. 电缆的连接器</span></h3><p>我们的线缆两端都会安装一个连接器，这个连接器的名字叫做 <strong>「rj45连接器」</strong>，其实就是我们所说的水晶头，它们是接入到网卡与交换机端口的部分，该连接器有八个引脚，它们与电缆内部的八根铜线对齐，必须按正确的顺序与引脚对齐才能保证通信。</p><p><img src="https://img.hi-linux.com/staticfile/cf3d4d7d0e9a0c5bf3215eb87e13aff8-2021-03-16-57dxiR.gif" alt="线缆与引脚对齐方式"></p><p>大家应该听到过连接线缆的口诀，那就是「橙白橙，绿白蓝，蓝白绿，棕白棕」，这种连接方式称为「568b」，其实就是图示中的这种顺序，确保顺序正确，再将其与水晶头的8个引脚对齐，这样就大功告成了！</p><p><img src="https://img.hi-linux.com/staticfile/127e61edc2578c46acf2e72bea56647e-2021-03-16-hjQZXx.gif" alt="引脚连接"></p><p>在网络通信中，其实就是将一端的 <strong>引脚1对接另一端的引脚1</strong> ，<strong>引脚2对接另一端的引脚2</strong> ，以此类推，因其线缆直通另一端线缆的特性，我们称这种连接方式为 「 <strong>直通电缆(Straight Through)</strong> 」。</p><p><img src="https://img.hi-linux.com/staticfile/31c4a596fa089776220b84cd1e4b140f-2021-03-16-ReBzhU.gif" alt="数据传输与接收"></p><p>这些线缆中的一部分用于<strong>传输数据</strong>，另一部分则用于<strong>接收数据</strong>，在这里，我们使用TX表示传输，TR表示接收，如图所示，第一对引脚就用来传输数据，而第二对引脚则用来接收数据。</p><p><img src="https://img.hi-linux.com/staticfile/056930b3f4c75795fa01bc7e29f135b9-2021-03-16-xRL1sZ.gif" alt="主机直连到交换机"></p><p>当我们将一台主机通过网线接入到交换机上，交换机非常聪明，在它这一端的水晶头接口处，它知道用第一对引脚来接收数据，用第二对引脚来传输数据。也正因为此，它的名字叫做交换机，交换的就是这个位置的信息。</p><p><img src="https://img.hi-linux.com/staticfile/6d389681f72bb6edfdefba7ac1ad9bff-2021-03-16-glvHXk.gif" alt="主机直连到主机（或交换器）"></p><p>但是，如果我们将这台主机的网线接入到另一台主机或路由器，而不是交换机呢？这会遇到什么情况？引脚的排列顺序不对了，它们使用相同的引脚来收发数据，这就导致数据传不出去了呀！所以，我们这里就不能使用「直通电缆」，而需要使用 <strong>「交叉电缆(Crossover)」</strong>，那就是将用于传输数据一端的引脚对应接收数据的引脚，即可解决问题（将一台交换机接入到另一台交换机，也是同样的道理）。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-5SjT3C.gif" alt="Auto MDI-X 自动引脚逻辑切换功能"></p><p>我能理解你此刻的心情，你肯定会说，这太痛苦了吧？不但要使用不同的以太网线缆或接头，还要保证线序完全对应，我只想说「恕臣无能！」。为了避免我们陷入此困境，我们拥有一项成为「 <strong>Auto MDI-X</strong> 」 的技术，尽管 「 <strong>Auto MDI-X</strong> 」 可以支持的设备可以检测是否使用了错误的线缆，然后，可以再逻辑上切换引脚的功能，使其与电缆相匹配，但是需要注意的是在以太网为 100BASE-T 及以上的标准才可以支持这项技术。</p><p>因为现在我们现在应用的以太网标准基本都处于 100BASE-T 之上，所以我们可以不必担心直通电缆与交叉电缆的问题，不过我们还是应该记住它们两个之间的区别。</p><p>当我们的以太网标准达到 1000BASE-TX 时，情况发生了一些变化，此时，我们会利用所有的四对电线进行数据传输（较旧的标准只需要使用两对），这里有两种工作方式，分别是 1000BASE-T 和 1000BASE-TX。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-Hc2lb6.gif" alt="1000BASE-TX标准"></p><p>1000BASE-TX 的标准是使用两对电线用于传输，另外两对电线用于接收，如果想要使用这种标准的话，我们需要将网线升级到 cat6 或更高级别。</p><p><img src="https://img.hi-linux.com/staticfile/a883ca8bbb5e809ba5f846ebf7beae1b-2021-03-16-fJhz8M.gif" alt="1000BASE-T标准"></p><p>1000BASE-T 的标准是使用所有的四对电线同时进行发送和接受，这是非常特别的一种方式，它只需要使用 cat5e 标准的线缆即可。</p><h3><span id="5-光纤">5. 光纤</span></h3><p><img src="https://img.hi-linux.com/staticfile/Z75exR-2021-03-17-6BfdtD.jpg" alt="光纤"></p><p>铜缆的替代品就是光纤，光纤使用的材质是「玻璃束」，使用这种材质，脉冲信号会从「玻璃束」的一端通过「玻璃束体」向另一端传递。回顾一下我们初中时做的物理实验，将一束光打到流动的弯曲水柱上，光会跟随水柱的方向进行传递，这里用的就是「光的全反射」原理。</p><p><img src="https://img.hi-linux.com/staticfile/4683047a308f46d8d149111d18bbba8a-2021-03-16-T8boZ1.gif" alt="光的全反射"></p><p>光纤通常用在路由器和交换机之类的网络设备之间，也可能用在我们从未见过的服务器中。</p><h3><span id="6-全双工与半双工">6. 全双工与半双工</span></h3><p>我们回过头来看一下全双工和半双工，看看它们是如何工作的。</p><h4><span id="61-全双工full-duplex">6.1 全双工（Full Duplex）</span></h4><p><strong>全双工</strong> 的意思就是，UTP非屏蔽双绞线的线缆需要同时发送和接受信息，如图所示，这需要两端的设备都支持同时发送和接受。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-9j6gVj.gif" alt="全双工"></p><h4><span id="62-半双工half-duplex">6.2 半双工（Half Duplex）</span></h4><p>有时候，两端设备中的某一端可能并不支持同时发送和接受信息，因此，信息发送完毕后，需要等待一会，待收到对方回复信息后，才能再次发送信息，这种方式就是 <strong>「半双工」</strong>。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-6Qy6Kp.gif" alt="半双工"></p><p>根据 <strong>全双工</strong>与<strong>半双工</strong> 的特性，光纤就有两种不同的使用方式：</p><h3><span id="7-单芯光纤与双芯光纤">7. 单芯光纤与双芯光纤</span></h3><h4><span id="71-单芯光纤single-core">7.1 单芯光纤（Single Core）</span></h4><p>由于无法同时发送和接受，因此单芯光纤只能使用半双工模式运行。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-BoiZZt.gif" alt="单芯光纤"></p><h4><span id="72-双芯光纤dual-core">7.2 双芯光纤（Dual Core）</span></h4><p>因其双芯的特性，其中一个芯专用于发送，而另一个芯则用于接收，因此双芯光纤支持全双工模式的运行。</p><p><img src="https://img.hi-linux.com/staticfile/bc47f38f17cebd00f367a8a06a73c8fb-2021-03-16-rwcK3K.gif" alt="双芯光纤"></p><p>如果我们自行连接光纤，却不能正常使用时，可以尝试交换光纤方向，问题也许就可以解决。</p><p><img src="https://img.hi-linux.com/staticfile/x2EUqr-2021-03-17-c7IHR0.jpg" alt="双芯光纤与单芯光纤"></p><p>企业网络通常使用双芯光纤，通常是使用在交换机、路由器和服务器之间。对于家庭中使用的光纤，网络服务提供商通常只会提供单核光纤。</p><h3><span id="8-单模与多模光纤">8. 单模与多模光纤</span></h3><p>接下来，我们来聊一下单模光纤与多模光纤，它们可能看起来很相似，但因为使用光的类型不同而产生了很大的差别。</p><h4><span id="81-单模光纤smfsingle-mode-fibre">8.1 单模光纤（SMF：Single Mode Fibre）</span></h4><p>单模光纤使用激光作为光源，这是其价格更高，但这中广可以传输更远的距离，很容易就可以达到2公里或更长的距离，服务提供商通常会在不同的建筑中使用单模光纤，以方便每栋用户流畅的访问Internet。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140150598-2021-03-16-Nun3KQ.png" alt="单模光纤"></p><h4><span id="82-多模光纤mmfmulti-mode-fibre">8.2 多模光纤（MMF：Multi Mode Fibre）</span></h4><p>多模光纤使用LED作为光源，它并不是特别强的光， 所以只能在较短的距离（500m或更短）传输，通常用于同一栋建筑中的网络连接，效果非常好。同时因为LED的生产成本比较低，因此如果你很在乎价格，可以选择这种类型的光纤。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140150629-2021-03-16-vWgjl5.png" alt="多模光纤"></p><h3><span id="9-光纤弯曲程度">9. 光纤弯曲程度</span></h3><p>尽管光纤是由玻璃制成的，但它具有很强的柔韧性，即便对它进行一定程度的弯曲也不会造成它的损坏。光纤都具有最大弯曲半径（根据光纤的不同而不同），光纤缠绕的程度会导致不同程度的信号衰减（信号衰减或丢失的地方），如果你想知道你家的光纤最大的弯曲程度是多少，可以联系网络服务提供商。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-6c20sX.gif" alt="光纤的弯曲程度"></p><h3><span id="10-光纤的连接器">10. 光纤的连接器</span></h3><p>光纤有非常多不同类型的连接器（接头），这里大家要知道，光纤不仅仅用于网络连接，它可能还会有一些其他用途。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140150728-2021-03-16-NY1h3U.png" alt="光纤连接器"></p><p>例如：LC类型的接头就通常用与与交换机和路由器的连接，我们通常会在双核配置中看到它们；而SC类型的接头属于比较老旧的类型，它看起来更大，通常我们会在配线柜中看到它。</p><p><img src="https://img.hi-linux.com/staticfile/222-2021-03-17-6C0lhd.png" alt="配线柜"></p><p>一些交换机会有一些看起来很空的特殊的接口，而一些交换机则完全由这些接口组成，这些接口都是用于安装收发器模块的，这些接口都可以用于不同目的，但通常情况下，他们都是用于很合匹配不同线缆的接头的，这些收发器接口支持不同的电缆类型，包括了单模和多模光纤。同时它们还支持不同的速度，例如1G或10G的速度；它们也支持不同的电缆长度，例如长40公里电缆的收发器比1公里的收法器要贵得多。</p><p><img src="https://img.hi-linux.com/staticfile/618afb36222910564c757147daa9da90-2021-03-16-gAEahw.gif" alt="交换机上的特殊接口"></p><p>这些交换机准备这么多端口最终原因是为了方便我们搭配不同的收发器，以完成不同的业务场景。我们甚至可以为其安装上「rj45收发器」，以满足我想要安装双绞线的需求。</p><p><img src="https://img.hi-linux.com/staticfile/996b1c608e3680334b1b919f839449ac-2021-03-17-bA5vdN.gif" alt="RJ45收发器"></p><h3><span id="11-wi-fi-连接">11. Wi-Fi 连接</span></h3><p>我们的另一种通信方法就是无线Wi-Fi通信，它不需要使用电缆连接，无线网络就像一个无线的交换机，可以让手机、笔记本之类的无线设备链接到接入点，但这个接入点是需要链接到有线网络的，此时，有线和无线设备可以在同一个网络当中使用。当然，并不是所有的设备都会连接到无线接入点的，例如我们不能把路由器或服务器连接到无线接入点。</p><p><img src="https://img.hi-linux.com/staticfile/2622f77fdd2700d1ee34df375fac4d23-2021-03-16-lOiRLs.gif" alt="无线网络"></p><p>Wi-Fi网络不适用 802.3 的以太网标准，它使用的是 802.11 的标准（802.11 标准描述了信息是如何使用无线电波来格式化和编码信息），虽然它们不是同一个以太网，但它们都是由 IEEE 制定，因此在数据格式化方面有很多相似之处。</p><h3><span id="总结">总结</span></h3><ol><li>网络可以是有线或无线的，网络连接可以使用铜缆或光缆</li><li>以太网标准用于描述了物理连接线缆的类型以及如何格式化数据</li><li>UTP有四对双绞线，其中一些用于数据发送，另一些用于数据接收</li><li>线缆可以以直通方式或交叉方式连接到交换机</li><li>现如今的大部分平台都支持 Auto MDI-X，可自动对线缆进行检测并做出调整</li><li>双工设备可以同时发送和接受数据，半双工则需要收到响应后再发送数据</li><li>双芯光纤支持全双工，单芯光纤支持半双工</li><li>若想要短距离连接，并节省更多成本，可以选择多模光纤</li><li>若想要远距离连接，则需要支付更高的价格，选择单模光纤，同时需采用正确收发器</li><li>如果有线连接无法满足你的需求，可以采用无线网络连接</li></ol><h3><span id="问题">问题</span></h3><ol><li>1000BASE-T以什么速度运行？需要使用什么类型的电缆？</li><li>使用哪种类型的UTP电缆将主机连接到交换机？那种类型的电缆可以将一个交换机连接到另一个交换机？</li><li>哪种情况下我们需要使用 Auto MDI-X 技术？</li><li>那种情况下需要使用光纤代替UTP？什么时候需要单模式光纤而不是多模光纤？</li><li>什么是弯曲半径？使用哪种类型的电缆，需要特别注意弯曲半径？</li><li>请简单阐述全双工工作模式的特点</li></ol><h2><span id="网络寻址">网络寻址</span></h2><p><img src="https://img.hi-linux.com/staticfile/aa699b8601737a0d0ef782babcb58570-2021-03-16-SXOTWq.gif" alt="模拟 soho 网络"></p><p>让我们回到  <strong>「soho网络」</strong> ，一起来看一个比较特殊的案例，我们用下图作为一个模拟的 <strong>「soho网络」</strong> 。假如，我们想通过网络中的一台主机，将需要打印的文件信息传递给打印机，因为打印机已入网，所以我们可以实现这一功能，在这个网络中有多个节点存在，试问一下，我们的电脑主机如何才能知道将信息发送到什么位置呢？</p><p><img src="https://img.hi-linux.com/staticfile/92ed8da29ce74e745fbad62319ea2b55-2021-03-16-pxwChj.gif" alt="soho 网络中的节点同时发送信息"></p><p>虽然，我们可以将打印信息发送给网络中的所有节点，然后让节点去判断这个信息是否是发给自己的，但这样一来信息的安全性且不说，效率低下才是最致命的；试想一下，如果所有的设备同时发送信息，该怎么办？如果网络环境下有多台打印机，该怎么办？会出现什么状况？网络将变得一团糟！所以呢，我们需要一个解决方法。</p><p><img src="https://img.hi-linux.com/staticfile/bef18e90b170848a5d55c0019ccc1290-2021-03-16-ys8kRE.gif" alt="网络设备地址"></p><p>其实，网络上的每台设备都有一个地址，这就类似于我们公司的、家庭的或亲朋好友的家庭住址，这个地址一定是唯一的，因此，我们邮寄包裹或网络购物可以找到准确的位置。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140151841-2021-03-16-LerkaC.png" alt="MAC 地址与 IP 地址"></p><p>在同一个域中，每台设备都会有两个地址，分别是 MAC 地址和 IP 地址，这两个地址的使用方式不同，目前，我们先大概了解它们的特点与基本使用，后面的章节会做展开讲解。</p><h3><span id="1mac地址">1.MAC地址</span></h3><p><img src="https://img.hi-linux.com/staticfile/84fb3871865da2ed8b3a89d1c1ceebcd-2021-03-16-BQaks6.gif" alt="MAC 地址"></p><p>首先来看一下 <strong>「MAC地址」</strong>，每台设备都至少拥有一个 <strong>「MAC地址」</strong>，确切地说，应该是每一块网卡都拥有一个 <strong>「MAC地址」</strong>，如果你的机器有多块网卡，那就会拥有多个 <strong>「MAC地址」</strong>。网卡从被生产出来就会被烧录一个永久的 <strong>「MAC地址」。</strong></p><p>这非常类似于烙印在动物身上的标记，主要是为了方便我们快速寻找并确认这头羊是不是我的，是我的第几头羊……扯远了，回过头来，<strong>「MAC地址」</strong> 就是烙印在网卡上的标记，且可以保证的是，每个 <strong>「MAC地址」</strong> 都是唯一的。</p><p><img src="https://img.hi-linux.com/staticfile/f5b3b6c3bd562a28f1af5d696f9bdc0b-2021-03-16-wGJjBj.gif" alt="MAC 寻址并发送信息"></p><p>在同一网络中，当一台设备想要快速找到另一台设备，可以通过该地址来寻找，因为 <strong>「MAC地址」</strong> 的唯一性，我们可以轻松的找到目标设备，并将信息精确的发送给它。</p><h3><span id="2ip地址">2.IP地址</span></h3><p><img src="https://img.hi-linux.com/staticfile/129b8d43e31e323d1482fc6f377f151f-2021-03-16-kRNHUE.gif" alt="IP 地址"></p><p>除了 <strong>「MAC地址」</strong>，每台设备同时拥有另一个地址，那就是 <strong>「IP地址」</strong>，改地址并不是烙印在设备上的，而是需要网络管理员来给我们分配。相比较 <strong>「MAC地址」</strong> 又长又无规律的特点，<strong>「IP地址」</strong> 显得相对容易记忆，大家可能会问，都已经有一个「MAC 地址 」了，为什么还要用「IP 地址」呢？</p><p>这里我们要考虑一个问题，目前全球有 60 多亿人，如果每个人都拥有一台设备，那就意味着我们拥有 60亿个 <strong>「MAC地址」</strong>，这是一个庞大的 <strong>「MAC地址库」</strong>，在这样庞大的库中查找具体的某一个设备无异于大海捞针。</p><p><img src="https://img.hi-linux.com/staticfile/0ad479635eb0798b0b2dfb7853255fca-2021-03-16-yLWu1i.gif" alt="IP 寻址并发送信息"></p><p>所以 <strong>「MAC地址」</strong> 通常都用于局部网络中的设备查找，而 <strong>「IP地址」</strong> 因为由管理员分配，这意味着每个国家，每个地区，每个城市的「IP地址」都有具体分配的 <strong>「IP地址段」</strong>，这就很方便我们查找了，当我们想要给一个异国他乡的亲友发送信息时，只需要先来确定它的 <strong>「IP地址」</strong> 所在地区，然后再具体查找它的设备，这将变得非常容易。</p><h3><span id="3网络寻址">3.网络寻址</span></h3><p><img src="https://img.hi-linux.com/staticfile/927e9f7bb99a48428d1b5803b3068fdc-2021-03-16-wam8yc.gif" alt="两个局域网连接"></p><p>举个例子，当一个公司的规模越来越大，分公司必然会出现，这种情况下会出现多个网络区域，此时我们需要将两个网络通过路由器连接在一起，这个路由器同时属于两个局域网LAN的一部分，它的工作就是将一个网段的信息传递到另一个网段。</p><p>通过刚才的学习，我们都知道了，MAC地址是用于本地局域网中的地址，因此，当我们想要把一段打印信息发送给另一个网段的打印机时，仅仅使用MAC地址就不够用了，此时我们就可以通过IP地址来定位打印机所处的位置。</p><p><img src="https://img.hi-linux.com/staticfile/1b93b0d809a4a4c659e60ec9d9bcc3e3-2021-03-16-QHiFsP.gif" alt="IP 地址的工作流程"></p><p>我们看一下具体的工作流程，当一个网段中的电脑准备好了要传递给打印机打印信息，我们的电脑会在这段消息上追加一个 <strong>「IP地址」</strong>，这个 <strong>「IP地址」</strong> 就是打印机的 <strong>「IP地址」</strong>。同时，因为该打印机在另一段网络，所以，电脑又在该信息上追加了路由器的 <strong>「MAC地址」</strong>，先找到路由器，路由器接到信息后把这个 <strong>「MAC地址」</strong> 更改成打印机的 <strong>「MAC地址」</strong>，接着，就可以精确的将该信息传递给打印机。</p><h3><span id="总结">总结</span></h3><ol><li>主机都同时拥有一个MAC地址和一个IP地址</li><li>MAC地址常用于一个局域网络</li><li>IP地址可以可以在本地的网段使用，同样可以再其他网段使用</li></ol><h3><span id="问题">问题</span></h3><ol><li>谁把Mac地址分配给计算机？一台计算机有多少个Mac地址？</li><li>要在本地网段中发送消息，是否需要IP地址？</li></ol><h3><span id="结语">结语</span></h3><p>如果你觉得文章很棒，可以转发，评论该文章；如果文章有问题，请留言或私信告诉我，我会在第一时间对内容进行调整，这将会帮助每一位想要学习网络基础的小伙伴，感谢！抱拳！</p><h4><span id="原作者">原作者：</span></h4><ul><li>原文作者：Network Direction</li><li>链接地址：<a href="https://www.youtube.com/watch?v=v8aYhOxZuNg&amp;list=PLDQaRcbiSnqF5U8ffMgZzS7fq1rHUI3Q8&amp;index=16&amp;t=28s" target="_blank" rel="noopener">点击查看</a></li></ul><blockquote><p>本文转载自：「 少数派 」，原文：<a href="https://sspai.com/post/64640" target="_blank" rel="noopener">https://sspai.com/post/64640</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;欢迎来到网络世界，《小白也能看懂的网络基础》系列文章会从零开始帮助你构建网络的基础知识。如果你完全没有接触过网络相关的内容，那我们是一样的，在学习过程中我们肯定遇到了相同的问题！写下这些文章一方面要记录自己的学习历程，另一方面也希望帮到同样想要学习网络基础的小伙伴。&lt;/p&gt;
&lt;p&gt;文章的部分内容与素材是我从【Youtube平台】的【&lt;a href=&quot;https://www.youtube.com/channel/UCtuXekfqj-paqsxtqVNCC2A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Network Direction&lt;/a&gt;】发布的系列视频学习和搜集过来的，翻译不易，部分内容可能无法做到尽善尽美，甚至可能会有部分瑕疵，我会尽力让文章内容通俗易懂，覆盖全面。若各位小伙伴发现任何问题，希望能够留言或私信告诉我，在下不胜感激！当然，我也会在第一时间进行更正。&lt;/p&gt;
&lt;p&gt;在往后的每一篇文章中，我都会把看到文章的小伙伴当成是完全没有网络经验的小白，我的目标是和零基础小白一起建立坚实的网络基础，网络大神请略过此系列文章。&lt;/p&gt;
&lt;p&gt;让我们开始网络之旅吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="https://www.hi-linux.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="网络" scheme="https://www.hi-linux.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你给 Kubernetes Dashboard 增加用户名密码认证功能</title>
    <link href="https://www.hi-linux.com/posts/7928.html"/>
    <id>https://www.hi-linux.com/posts/7928.html</id>
    <published>2021-05-20T01:00:00.000Z</published>
    <updated>2021-05-20T01:22:08.887Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>仪表板是基于 <code>Web</code> 的 <code>Kubernetes</code> 用户界面。您可以使用仪表板将容器化应用程序部署到 <code>Kubernetes</code> 集群，对容器化应用程序进行故障排除，并管理集群本身及其伴随资源。您可以使用仪表板来概述群集上运行的应用程序，以及创建或修改单个 <code>Kubernetes</code> 资源。</p><p><img src="https://img.hi-linux.com/staticfile/use-name-passwd-login-dashborad-2021-04-15-evt2DM.png" alt="Dashboard开启用户名密码登录"></p><p>通过 <code>yaml</code> 文件默认安装完 <code>k8s</code> 集群和 <code>Dashboard</code> 服务之后，都是使用 <strong><code>token</code></strong> 或者 <strong><code>Kubeconfig</code> 文件</strong> 来登录的，这样使用起来比较安全。但是如果我们部署的是测试或者实验环境的话，每次都要输入一长串的 <code>token</code> 还是很方便的。所以，这里我们介绍如何使用 <strong>用户名和密码</strong> 的方式来登录 <code>Dashboard</code> 服务。</p><table><thead><tr><th style="text-align:left">集群环境</th><th style="text-align:left">集群版本</th><th style="text-align:left">搭建方式</th><th style="text-align:left">dashboard 的版本</th></tr></thead><tbody><tr><td style="text-align:left">master</td><td style="text-align:left">v1.20.4</td><td style="text-align:left">kubeadm</td><td style="text-align:left">dashboard:v2.0.4</td></tr><tr><td style="text-align:left">node01</td><td style="text-align:left">v1.20.4</td><td style="text-align:left">kubeadm</td><td style="text-align:left">dashboard:v2.0.4</td></tr><tr><td style="text-align:left">node02</td><td style="text-align:left">v1.20.4</td><td style="text-align:left">kubeadm</td><td style="text-align:left">dashboard:v2.0.4</td></tr></tbody></table><ul><li>创建用户文件<ul><li>格式：<code>user</code>、<code>password</code>、<code>userID</code>、<code>&quot;group1,group2&quot;</code></li><li>注意：<code>userID</code> 不可重复</li></ul></li></ul><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户名密码配置文件</span></span><br><span class="line"><span class="comment"># 在所有的master节点配置用户名密码</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'admin,admin,1'</span> | sudo tee /etc/kubernetes/pki/basic_auth_file</span><br></pre></td></tr></table></figure><ul><li>修改配置文件<ul><li>将上述创建好的用户名密码文件添加到下述文件中</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置修改</span></span><br><span class="line">$ sudo vim /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - <span class="built_in">command</span>:</span><br><span class="line">    - kube-apiserver</span><br><span class="line">    - --advertise-address=192.168.30.30</span><br><span class="line">    - --basic-auth-file=/etc/kubernetes/pki/basic_auth_file</span><br><span class="line">    ......</span><br><span class="line">  volumeMounts:</span><br><span class="line">  – mountPath: /etc/kubernetes/basic_auth_file</span><br><span class="line">    name: basic-auth-file</span><br><span class="line">    readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">  – hostPath:</span><br><span class="line">    name: basic-auth-file</span><br><span class="line">      path: /etc/kubernetes/basic_auth_file</span><br></pre></td></tr></table></figure><ul><li>重启 apiserver 服务<ul><li>使刚才的修改生效</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启</span></span><br><span class="line">$ kubectl apply -f /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">$ kubectl get pod -n kube-system | grep apiserver</span><br><span class="line">kube-apiserver-k8s-01            1/1     Running   0          24s</span><br><span class="line">kube-apiserver-k8s-02            1/1     Running   0          44s</span><br><span class="line">kube-apiserver-k8s-03            1/1     Running   0          50s</span><br></pre></td></tr></table></figure><ul><li>将用户与权限绑定<ul><li>创建集群 <code>admin</code> 角色绑定</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 权限绑定</span></span><br><span class="line">$ kubectl create clusterrolebinding \</span><br><span class="line">    login-on-dashboard-with-cluster-admin \</span><br><span class="line">    --clusterrole=cluster-admin --user=admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看绑定</span></span><br><span class="line">$ kubectl get clusterrolebinding login-on-dashboard-with-cluster-admin</span><br><span class="line">NAME                                    ROLE                        AGE</span><br><span class="line">login-on-dashboard-with-cluster-admin   ClusterRole/cluster-admin   2m23s</span><br></pre></td></tr></table></figure><ul><li>开启 basic 配置<ul><li>修改 <code>kubernetes-dashboard.yaml</code> 配置文件</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim kubernetes-dashboard.yaml</span><br><span class="line">args:</span><br><span class="line">  - --auto-generate-certificates</span><br><span class="line">  - --namespace=kubernetes-dashboard</span><br><span class="line">  - --token-ttl=43200 <span class="comment"># 过期秒数</span></span><br><span class="line">  - --authentication-mode=basic <span class="comment"># 启用basic登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">$ kubectl apply -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><ul><li>登录验证<ul><li>使用用户名和密码登录 <code>Dashboard</code> 服务</li></ul></li></ul><p><img src="https://www.escapelife.site/images/use-name-passwd-login-dashborad-01.png" alt="Dashboard开启用户名密码登录"></p><blockquote><p>本文转载自：「 Ecsape 的博客 」，原文：<a href="http://t.cn/A6c6nQfG" target="_blank" rel="noopener">http://t.cn/A6c6nQfG</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;仪表板是基于 &lt;code&gt;Web&lt;/code&gt; 的 &lt;code&gt;Kubernetes&lt;/code&gt; 用户界面。您可以使用仪表板将容器化应用程序部署到 &lt;code&gt;Kubernetes&lt;/code&gt; 集群，对容器化应用程序进行故障排除，并管理集群本身及其伴随资源。您可以使用仪表板来概述群集上运行的应用程序，以及创建或修改单个 &lt;code&gt;Kubernetes&lt;/code&gt; 资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/use-name-passwd-login-dashborad-2021-04-15-evt2DM.png&quot; alt=&quot;Dashboard开启用户名密码登录&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;yaml&lt;/code&gt; 文件默认安装完 &lt;code&gt;k8s&lt;/code&gt; 集群和 &lt;code&gt;Dashboard&lt;/code&gt; 服务之后，都是使用 &lt;strong&gt;&lt;code&gt;token&lt;/code&gt;&lt;/strong&gt; 或者 &lt;strong&gt;&lt;code&gt;Kubeconfig&lt;/code&gt; 文件&lt;/strong&gt; 来登录的，这样使用起来比较安全。但是如果我们部署的是测试或者实验环境的话，每次都要输入一长串的 &lt;code&gt;token&lt;/code&gt; 还是很方便的。所以，这里我们介绍如何使用 &lt;strong&gt;用户名和密码&lt;/strong&gt; 的方式来登录 &lt;code&gt;Dashboard&lt;/code&gt; 服务。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;集群环境&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;集群版本&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;搭建方式&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;dashboard 的版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;master&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;v1.20.4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;kubeadm&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;dashboard:v2.0.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;node01&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;v1.20.4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;kubeadm&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;dashboard:v2.0.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;node02&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;v1.20.4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;kubeadm&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;dashboard:v2.0.4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;创建用户文件
&lt;ul&gt;
&lt;li&gt;格式：&lt;code&gt;user&lt;/code&gt;、&lt;code&gt;password&lt;/code&gt;、&lt;code&gt;userID&lt;/code&gt;、&lt;code&gt;&amp;quot;group1,group2&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意：&lt;code&gt;userID&lt;/code&gt; 不可重复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
</feed>
