<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇妙的 Linux 世界</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2024-06-03T09:31:47.869Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『极客视界』一站式科技达人综合资讯指南和神秘宝箱，等你来开启</title>
    <link href="https://www.hi-linux.com/posts/22000.html"/>
    <id>https://www.hi-linux.com/posts/22000.html</id>
    <published>2050-06-18T01:00:00.000Z</published>
    <updated>2024-06-03T09:31:47.869Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="️-极客视界科技达人的综合资讯指南">🛠️ 『极客视界』科技达人的综合资讯指南</span></h2><p>你是否常常为寻找最新的技术资讯、工具和资源而感到困扰？或者每次开发时都需要开启无数个标签页，才能找到所需的工具和信息？</p><p>别担心，让我为你介绍一个好地方『极客视界』，这是每位科技达人的福音、必备的综合资讯指南。</p><p>『极客视界』提供了一站式的服务，它包罗万象、功能丰富，直接满足你从资讯获取到开发辅助的全部需求。</p><p>从 GitHub 热榜到 PDF 工具箱，从实时新闻资讯、技术文章到虚拟临时邮箱，样样俱全！</p><a id="more"></a><h3><span id="极客视界">🤓 极客视界</span></h3><p>『极客视界』是一个综合科技资讯的枢纽。如果你喜欢紧跟最新的科技动态、追踪热门项目，或是希望时刻了解技术动向，那这个板块绝对不容错过。</p><h4><span id="github-热榜">🏆 Github 热榜</span></h4><p>每天都有成千上万的项目在 GitHub 上更新，又如何挑选出最热门、最有趣的项目呢？</p><p>别担心，『极客视界』已经为你做了筛选。我们提供的每日更新的 GitHub 热门项目榜单，每天看看就知道哪些项目正火热。</p><p>实时获取最新最火的开源项目，助你快速了解哪些项目正在迅速蹿红，也可以看看有多少大牛在关注同样的项目，再也不用费力翻找。</p><h4><span id="最新-it-新闻和技术文章">📰 最新 IT 新闻和技术文章</span></h4><p>获取行业动态和最新资讯是每个极客的日常标配。在『极客视界』，你能找到最新的 IT 新闻和技术文章。</p><p>我们涵盖了从前沿技术到开发实战，从行业大事件到新兴趋势的一切内容。</p><p>不仅内容丰富，还有专业的编辑团队为你推荐精选文章，让你在最短时间内掌握最有价值的信息。</p><h4><span id="黑客新闻">🧑‍💻 黑客新闻</span></h4><p>这里提供最新、最全的黑客新闻，覆盖广泛的领域。无论是安全漏洞、趋势分析，还是开发者的门道，这里都有。</p><h4><span id="github-热门仓库状态跟踪">📈 Github 热门仓库状态跟踪</span></h4><p>对你关注的热门仓库进行状态跟踪，实时获取更新信息。再也无须手动查询，每天都能知道自己心仪的仓库发生了哪些变化。</p><h4><span id="服务监控">💚 服务监控</span></h4><p>对各种网络服务进行监控，只需轻松设置，关键数据一目了然。实时掌握各种关注服务的状态，确保系统平稳运行。</p><h3><span id="极客秘境">🗞 极客秘境</span></h3><p>这里是技术人的宝藏，包括最新的 IT 新闻、技术文章和深度分析，兼具广度和深度。</p><h4><span id="ai-新世界">🤖 AI 新世界</span></h4><p>这里聚焦人工智能领域的最新资讯和技术动态，想知道 AI 的新突破、新应用，或者最新的研究成果，这里一站搞定。</p><h4><span id="科技周刊汇">📅 科技周刊汇</span></h4><p>每周汇总最具价值的科技新闻，如果你是一周一更新的节奏党，这里绝对不会让你错过任何重要信息。</p><h4><span id="数码潮流">💻 数码潮流</span></h4><p>最新数码产品的资讯和评测，从手机到电脑再到各种智能设备。让你在购买之前就对产品有全面的了解，做个不踩雷的科技买手。</p><h4><span id="知乎热榜">🌐 知乎热榜</span></h4><p>集成知乎的科技热榜，看看大家都在讨论些什么热门话题。知乎神仙们的回答一定会让你豁然开朗。</p><h4><span id="it-之家热榜">🏠 IT 之家热榜</span></h4><p>再也不会错过 IT 之家发布的有趣新闻和深度文章，适合 IT 人必读的榜单，全方位提升知识水平。</p><h4><span id="稀土掘金文章榜">💡 稀土掘金文章榜</span></h4><p>聚集稀土掘金平台的热门技术文章，无论是新工具、新技术，还是各种开发干货，这里都值得一看。</p><h4><span id="hellogithub-热门仓库">🚀 HelloGithub 热门仓库</span></h4><p>专业团队挑选和介绍的 Github 热门仓库，涵盖广泛的编程语言和框架。每期精选，你一定能找到自己感兴趣的项目。</p><h3><span id="it-人必备工具箱">🧰 IT 人必备工具箱</span></h3><p>『IT 人必备工具箱』 是每一位 IT 人都不可或缺的资源宝库，里面收纳着各种专注于技术领域的优质资源和实用工具。</p><p>它如同一座巨大的数字图书馆，为 IT 从业者提供了丰富的资讯和工具。</p><p>让他们在数字世界中驰骋自如，无论是编程开发、网络安全、数据分析还是人工智能。</p><p>这个工具箱都汇聚了各种经典和前沿的资源，为 IT 人士解决难题、提升技能提供了强大的支持。</p><p>无论是初学者还是资深技术大牛，都可以从中汲取灵感，探索未知，不断成长。</p><h3><span id="开发工具箱">🧑‍💻 开发工具箱</span></h3><p>作为开发者，你一定会喜欢我们的开发工具箱。</p><p>这里囊括了各种实用的开发小工具，涵盖了从代码编辑、JSON 解析器、网络调试工具、正则表达式测试器等的一切，应有尽有。</p><p>所有的工具都经过精心挑选和测试，确保能在关键时刻帮到你。减少你在开发过程中寻找工具的时间，提升工作效率。</p><h3><span id="代码图美化">🎨 代码图美化</span></h3><p>代码不仅要运行得好，还要看得美。我们的代码图美化工具，可以将你的一段代码精美地呈现出来。</p><p>它可以帮助你将代码片段转化成美观的图片，它支持高度定制，照顾到每一个细节，让你的代码更具表现力。</p><p>不论是分享给团队成员，还是展示在个人博客上，漂亮的代码图总能让你的工作成果更上一层楼。</p><h3><span id="ip-工具箱">🌍 IP 工具箱</span></h3><p>无论是开发还是运维，IP 信息总是绕不开的问题。『极客视界』为你准备了全面的 IP 工具箱，涵盖从 IP 查找、IP 段查询到地理位置转换等多种功能，让你轻松搞定所有与 IP 相关的难题。</p><p>对于网络管理员和开发者来说，这些功能在日常工作中非常实用。</p><h3><span id="pdf-工具箱">📄 PDF 工具箱</span></h3><p>处理 PDF 文件常常让人头疼，但在『极客视界』这一切都不是问题。我们提供了全方位的 PDF 工具箱，包括 PDF 转换、合并、拆分、压缩等多种功能。</p><p>不管你的需求是什么，这里都有合适的工具帮你搞定，一站解决所有需求，让你轻松应对各种文档格式的转换问题。</p><h3><span id="今日热榜">🔥 今日热榜</span></h3><p>想知道今天哪些内容最火爆？来看看我们的今日热榜吧！这里汇集了各大平台的热门内容，如微博、知乎、抖音等。</p><p>无论是新闻、帖子、视频还是其他内容，最受关注的总能在这里找到。不用再费力刷各大社交媒体，只需一站尽知天下热点，轻松做个潮流达人。</p><h3><span id="虚拟临时邮箱">📫 虚拟临时邮箱</span></h3><p>注册各种网站服务时，常常会担心邮箱被垃圾信息淹没？</p><p>使用我们的虚拟临时邮箱功能吧！它能生成临时邮件地址，帮你保护真实邮箱免受打扰。使用简单方便，一键生成，特别适合短期注册需求。</p><h3><span id="️-手绘画板">🖌️ 手绘画板</span></h3><p>需要临时记录灵感或进行手绘创作？『极客视界』的手绘画板功能正是为你准备的。</p><p>无需下载任何应用，在线即可进行手绘，支持多种笔刷和颜色选择，无论是画草图还是进行简单设计，这里都能得心应手。</p><h3><span id="视频下载">📥 视频下载</span></h3><p>在线遇到好视频想下载，却苦于找不到合适的工具？</p><p>我们提供的在线视频下载工具可以帮你解决这个问题。支持多种视频平台，下载速度快，操作简便，让你轻松保存喜欢的视频内容。</p><h3><span id="️-超级终端">🖥️ 超级终端</span></h3><p>如果你经常需要在的终端工作，这个超级终端你一定会爱不释手。它支持各种命令输出，让你看上去很酷而忙碌，是极客必备的利器。</p><h2><span id="为什么选择极客视界">🤔 为什么选择『极客视界』？</span></h2><h3><span id="集成化一站式服务">🌅 集成化，一站式服务</span></h3><p>无需再奔波于各个网站寻找工具和资讯，『极客视界』将所有常用的开发工具和最新资讯集成在一个平台上，一站式解决你的所有需求。</p><h3><span id="实用性强">📝 实用性强</span></h3><p>我们精心挑选每一项功能和工具，确保它们在实际工作中有用且好用，节省你的时间，提升工作效率。</p><h3><span id="持续更新">📈 持续更新</span></h3><p>科技的发展日新月异，我们的团队时刻关注行业动态，不断更新功能和内容，确保你在『极客视界』获取到最新、最热的资讯和工具。</p><h2><span id="如何开始">🚀 如何开始？</span></h2><p>体验所有这些功能只需一个简单的步骤：访问 <a href="https://bestgeek.org" target="_blank" rel="noopener">https://bestgeek.org</a> 开始你的极客之旅吧！</p><p>然后根据你的需求选择相应的分类开始探索吧！无论你是开发者、设计师还是普通的科技爱好者，『极客视界』都能为你提供你需要的一切。</p><h2><span id="结语">🎉 结语</span></h2><p>上述功能仅仅是『极客视界』的一部分，我们致力于为每一个热爱科技的朋友提供全面的资讯与工具支持。</p><p>『极客视界』不仅是功能齐全的工具和资讯平台，更是每个极客共同的家园。</p><p>在这里，你可以找到志同道合的伙伴，获取最新的技术资讯和最实用的开发工具。让我们一起在这个充满科技乐趣的视界里遨游吧！</p><p>赶快收藏 <a href="https://bestgeek.org" target="_blank" rel="noopener">极客视界</a>，开启你的科技之旅吧！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;🛠️-『极客视界』科技达人的综合资讯指南&quot;&gt;🛠️ 『极客视界』科技达人的综合资讯指南&lt;/h2&gt;
&lt;p&gt;你是否常常为寻找最新的技术资讯、工具和资源而感到困扰？或者每次开发时都需要开启无数个标签页，才能找到所需的工具和信息？&lt;/p&gt;
&lt;p&gt;别担心，让我为你介绍一个好地方『极客视界』，这是每位科技达人的福音、必备的综合资讯指南。&lt;/p&gt;
&lt;p&gt;『极客视界』提供了一站式的服务，它包罗万象、功能丰富，直接满足你从资讯获取到开发辅助的全部需求。&lt;/p&gt;
&lt;p&gt;从 GitHub 热榜到 PDF 工具箱，从实时新闻资讯、技术文章到虚拟临时邮箱，样样俱全！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="IT" scheme="https://www.hi-linux.com/tags/IT/"/>
    
      <category term="程序员" scheme="https://www.hi-linux.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>『IT 人员必备工具箱』：一个专注于 IT 人的优质资源分享导航站</title>
    <link href="https://www.hi-linux.com/posts/53504.html"/>
    <id>https://www.hi-linux.com/posts/53504.html</id>
    <published>2050-03-18T01:00:00.000Z</published>
    <updated>2024-03-14T03:05:50.391Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』是一个专注于 IT 人优质资源分享的导航站，包含大量好玩又实用的 AI、翻译、编程、设计、Linux、网络、云原生、安全等多款应用。</p><p>🏷️  网站地址：<a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a></p><p><img src="https://img.hi-linux.com/staticfile/Tweelet00-2024-03-14-n0S5jR.webp" alt="全站预览图"></p><p>我们的目标是帮助更多 IT 人发现有价值的优质资源，让更多人受益。</p><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』也可以推荐你喜欢的软件和网站呢！如果你有什么好玩有趣又实用的酷软趣站，快『<a href="https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz" target="_blank" rel="noopener">推荐</a>』给我们吧！</p><p>🏷️  趣站酷软推荐收集表: <a href="https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz" target="_blank" rel="noopener">https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz</a></p><a id="more"></a><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』部分截图展示：</p><p><img src="https://img.hi-linux.com/staticfile/Tweelet01-2024-03-14-9hHDLK.png" alt="实用工具"><br><img src="https://img.hi-linux.com/staticfile/Tweelet02-2024-03-14-ejfZrm.png" alt="奇妙的 Linux 世界 + 搜索引擎 + 新闻资讯"><br><img src="https://img.hi-linux.com/staticfile/Tweelet03-2024-03-14-ZkjPxQ.png" alt="电子邮件 + 出行服务 + AI 翻译利器"><br><img src="https://img.hi-linux.com/staticfile/Tweelet04-2024-03-14-NbfprZ.png" alt="AI 新世界 + 云服务"><br><img src="https://img.hi-linux.com/staticfile/Tweelet05-2024-03-14-xTbQV6.png" alt="编程开发"><br><img src="https://img.hi-linux.com/staticfile/Tweelet06-2024-03-14-OvFNBk.png" alt="GitHub 热榜 + 网络调试"><br><img src="https://img.hi-linux.com/staticfile/Tweelet07-2024-03-14-bluwgD.png" alt="绘图设计 + 镜像加速"><br><img src="https://img.hi-linux.com/staticfile/Tweelet08-2024-03-14-G4HEGV.png" alt="云原生容器化 + 安全相关 + 玩转 NixOS + 博客网摘"><br><img src="https://img.hi-linux.com/staticfile/Tweelet09-2024-03-14-FjDHJs.png" alt="职来职往 + 光影时刻 + 音乐之声"><br><img src="https://img.hi-linux.com/staticfile/Tweelet10-2024-03-14-3W7reF.png" alt="趣站酷软"></p><p>📕 关注『<a href="https://mp.weixin.qq.com/s/8iRVr_IN3jB3MnmAdgAOoQ" target="_blank" rel="noopener">奇妙的 Linux 世界</a>』公众号，带你开启有趣新生活！更多好用好玩的软件资源，可访问 <a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a> 免费获取。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IT 人员必备工具箱&lt;/a&gt;』是一个专注于 IT 人优质资源分享的导航站，包含大量好玩又实用的 AI、翻译、编程、设计、Linux、网络、云原生、安全等多款应用。&lt;/p&gt;
&lt;p&gt;🏷️  网站地址：&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://666666.dev&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/Tweelet00-2024-03-14-n0S5jR.webp&quot; alt=&quot;全站预览图&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们的目标是帮助更多 IT 人发现有价值的优质资源，让更多人受益。&lt;/p&gt;
&lt;p&gt;『&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IT 人员必备工具箱&lt;/a&gt;』也可以推荐你喜欢的软件和网站呢！如果你有什么好玩有趣又实用的酷软趣站，快『&lt;a href=&quot;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;推荐&lt;/a&gt;』给我们吧！&lt;/p&gt;
&lt;p&gt;🏷️  趣站酷软推荐收集表: &lt;a href=&quot;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>解锁科技魔法「极客光年」，让你的手机看上去更美，从此与众不同！</title>
    <link href="https://www.hi-linux.com/posts/53528.html"/>
    <id>https://www.hi-linux.com/posts/53528.html</id>
    <published>2024-08-14T01:00:00.000Z</published>
    <updated>2024-08-14T02:52:21.584Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><img src="https://img.hi-linux.com/staticfile/WX20240813-141455@2x-2024-08-13-J7YjX4.png" alt></p><p>你是否厌倦了每次解锁手机，看到的都是那些千篇一律的壁纸？你的朋友是不是总能找到令人惊叹的手机背景，而你只能羡慕嫉妒恨？</p><p>别担心，我们找到了解决方案「极客光年」！这个网站简直就是手机壁纸界的宝藏窟，绝对能让你的屏幕从此与众不同！</p><h2><span id="为什么选择极客光年">为什么选择「极客光年」？</span></h2><ol><li><p><strong>海量高质量壁纸</strong></p><p>想象一下，你打开「极客光年」，就像走进了一个巨大的艺术画廊。从绚丽的风景到可爱的动物，从未来科技到复古怀旧，应有尽有。无论你是喜欢简约风还是奇幻风，这里总有一款适合你。</p></li><li><p><strong>摄影大师的杰作</strong></p><p>极客光年不仅仅是壁纸网站，它还是摄影爱好者的天堂。这里汇集了来自世界各地摄影师的精品照片。谁说你的手机屏幕不能成为一件艺术品？在这里，每次解锁都是一次视觉盛宴！</p></li><li><p><strong>AI 图片，引领潮流</strong></p><p>如果你觉得普通照片已经无法满足你的需求，那就来看看「极客光年」的 AI 图片区吧。这里的图片不是普通的 PS，而是由最先进的 AI 技术生成的艺术品。想象一下，你的手机壁纸可能是这个世界上独一无二的存在，酷不酷？</p></li><li><p><strong>免费又方便</strong></p><p>最棒的是，极客光年完全免费！你不需要注册，不需要付费，只需要点击下载，就能获得心仪的壁纸。省钱又省心，还有比这更好的事吗？</p></li></ol><a id="more"></a><h2><span id="如何使用极客光年">如何使用「极客光年」？</span></h2><blockquote><p>「极客光年」网址：<a href="https://bestgeek.org/pic" target="_blank" rel="noopener">https://bestgeek.org/pic</a></p></blockquote><p>使用「极客光年」简单得连你家的宠物狗都能学会（好吧，可能有点夸张）。只需要三步：</p><ol><li>打开网站</li><li>浏览并选择你喜欢的图片</li><li>点击下载</li></ol><p>就这么简单！你甚至可以在等公交车或排队买咖啡的时候完成这个过程。</p><h2><span id="让你的手机与众不同">让你的手机与众不同</span></h2><p>想象一下，当你和朋友聚会时，大家都在比较手机壁纸。你轻轻一按解锁键，瞬间，所有人的目光都被你的屏幕吸引。</p><p>“哇，这壁纸太酷了！”</p><p>“你从哪里找到的？” 他们会问。而你，只需要微微一笑，优雅地说：“哦，这个啊，我在「极客光年」上找到的。”</p><p>从此以后，你就是朋友圈里的壁纸达人，手机屏幕界的时尚坐标！</p><h2><span id="结语">结语</span></h2><p>亲爱的朋友们，还在等什么？快来「极客光年」，让你的手机焕然一新吧！记住，生活可以平凡，但你的手机壁纸绝不能平凡。让「极客光年」成为你的秘密武器，让你的手机屏幕成为你个性的完美展示。</p><p>别忘了，每一次解锁，都是一次视觉享受。每一张壁纸，都是一个小小的惊喜。现在就行动吧，让你的手机从此与众不同！</p><p>「极客光年」 - 因为你的手机，值得拥有最好的壁纸！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/WX20240813-141455@2x-2024-08-13-J7YjX4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;你是否厌倦了每次解锁手机，看到的都是那些千篇一律的壁纸？你的朋友是不是总能找到令人惊叹的手机背景，而你只能羡慕嫉妒恨？&lt;/p&gt;
&lt;p&gt;别担心，我们找到了解决方案「极客光年」！这个网站简直就是手机壁纸界的宝藏窟，绝对能让你的屏幕从此与众不同！&lt;/p&gt;
&lt;h2 id=&quot;为什么选择「极客光年」？&quot;&gt;为什么选择「极客光年」？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;海量高质量壁纸&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想象一下，你打开「极客光年」，就像走进了一个巨大的艺术画廊。从绚丽的风景到可爱的动物，从未来科技到复古怀旧，应有尽有。无论你是喜欢简约风还是奇幻风，这里总有一款适合你。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;摄影大师的杰作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;极客光年不仅仅是壁纸网站，它还是摄影爱好者的天堂。这里汇集了来自世界各地摄影师的精品照片。谁说你的手机屏幕不能成为一件艺术品？在这里，每次解锁都是一次视觉盛宴！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AI 图片，引领潮流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得普通照片已经无法满足你的需求，那就来看看「极客光年」的 AI 图片区吧。这里的图片不是普通的 PS，而是由最先进的 AI 技术生成的艺术品。想象一下，你的手机壁纸可能是这个世界上独一无二的存在，酷不酷？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;免费又方便&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最棒的是，极客光年完全免费！你不需要注册，不需要付费，只需要点击下载，就能获得心仪的壁纸。省钱又省心，还有比这更好的事吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="壁纸" scheme="https://www.hi-linux.com/tags/%E5%A3%81%E7%BA%B8/"/>
    
      <category term="摄影" scheme="https://www.hi-linux.com/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="手机" scheme="https://www.hi-linux.com/tags/%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>告别复杂命令行，Hollama 让与 Ollama AI 对话丝般顺滑</title>
    <link href="https://www.hi-linux.com/posts/37064.html"/>
    <id>https://www.hi-linux.com/posts/37064.html</id>
    <published>2024-08-12T01:00:00.000Z</published>
    <updated>2024-08-12T01:25:13.312Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言">🌐 引言</span></h2><p>在人工智能快速发展的今天，我们越来越依赖各种 AI 工具来提高工作效率和生活质量。</p><p>Ollama 作为一个强大的本地 AI 模型服务器，为我们提供了丰富的 AI 能力。但是，如何更方便地与 Ollama 进行交互呢？</p><p>这就是 Hollama 的用武之地！Hollama 为 Ollama 服务器提供了一个简洁优雅的 Web 界面，让你可以轻松地与 AI 模型对话，无需复杂的命令行操作。让我们一起来探索 Hollama 的魅力吧！</p><a id="more"></a><h2><span id="hollamaollama-的网页化身">🎭 Hollama：Ollama 的网页化身</span></h2><p>Hollama 是一个为 Ollama 服务器设计的极简 Web 用户界面。它的目标是让用户能够通过直观的 Web 界面与 Ollama 提供的 AI 模型进行交互，而不需要直接使用命令行或复杂的 API 调用。</p><p>✨ Hollama 支持的特性:</p><p>✅ 大型提示字段<br>✅ 带语法高亮的 Markdown 渲染<br>✅ 代码编辑器功能<br>✅ 可定制的系统提示<br>✅ 复制代码片段、信息或整个会话<br>✅ 重试完成<br>✅ 在浏览器本地存储数据<br>✅ 响应式布局<br>✅ 浅色和深色主题</p><p>🏷️ Hollama 项目地址：</p><ul><li><a href="https://github.com/fmaclen/hollama" target="_blank" rel="noopener">https://github.com/fmaclen/hollama</a></li></ul><h2><span id="️-安装-hollama简单快捷">🛠️ 安装 Hollama：简单快捷</span></h2><p>要在本地运行 Hollama 服务器，你需要安装 Docker。以下是安装和启动 Hollama 的步骤：</p><h3><span id="通过-docker-部署">通过 Docker 部署</span></h3><h4><span id="1-安装-docker">1. 安装 Docker</span></h4><ul><li>前往 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker 官方网站</a> 下载并安装 Docker Desktop。</li><li>根据你的操作系统选择相应的安装包，并按照提示完成安装。</li></ul><h4><span id="2-运行-hollama-服务器">2. 运行 Hollama 服务器</span></h4><ul><li>打开你的终端，并输入以下命令以启动 Hollama 服务器：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -d -p 4173:4173 ghcr.io/fmaclen/hollama:latest</span><br></pre></td></tr></table></figure><p>这条命令会在后台启动 Hollama 服务器，并将其映射到本地主机的 4173 端口。</p><h4><span id="3-访问-hollama-网页界面">3. 访问 Hollama 网页界面</span></h4><ul><li>在你的浏览器中访问 <code>http://localhost:4173</code>，即可开始使用 Hollama 的网页界面。</li></ul><h3><span id="下载-hollama-桌面端应用">下载 Hollama 桌面端应用</span></h3><p>此外，Hollama 还提供了桌面端应用程序，支持 macOS、Windows 和 Linux 系统。</p><p>如果你更喜欢桌面应用的使用体验，可以下载 Hollama 的桌面端应用：</p><ul><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-mac-arm64.dmg" target="_blank" rel="noopener">Download for macOS ARM</a></li><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-mac-x64.dmg" target="_blank" rel="noopener">Download for macOS x64</a></li><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-win-x64.exe" target="_blank" rel="noopener">Download for Windows</a></li><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-linux-x64.tar.gz" target="_blank" rel="noopener">Download for Linux</a></li></ul><p>安装完成后，桌面应用将为你提供与网页端相同的功能和使用体验。</p><blockquote><p>注意：如果你使用的是公共托管版本，或者你的 Docker 服务器位于与 Ollama 服务器不同的设备上，你就必须在 OLLAMA_ORIGINS 中设置域。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OLLAMA_ORIGINS&#x3D;https:&#x2F;&#x2F;hollama.fernando.is ollama serve</span><br></pre></td></tr></table></figure><h2><span id="使用-hollama简洁而强大的界面">🚀 使用 Hollama：简洁而强大的界面</span></h2><p><img src="https://img.hi-linux.com/staticfile/tE6uxk-2024-08-08-wyzHFq.png" alt></p><p>Hollama 的网页界面设计简洁明了，主要包括以下几个部分：</p><ol><li><strong>模型选择</strong>：你可以选择想要使用的 AI 模型。</li><li><strong>对话区域</strong>：这里显示你与 AI 的对话历史。</li><li><strong>输入框</strong>：在这里输入你想问的问题或指令。</li><li><strong>发送按钮</strong>：点击发送你的输入给 AI 模型。</li></ol><p>使用步骤非常简单：</p><ol><li>选择想要使用的 AI 模型。</li><li>在输入框中输入你的问题或指令。</li><li>点击发送按钮或按回车键。</li><li>等待 AI 的回复，回复会实时显示在对话区域。</li></ol><h3><span id="实时响应流畅的对话体验">🔄 实时响应：流畅的对话体验</span></h3><p>Hollama 支持流式输出，这意味着你可以看到 AI 正在实时生成的回答。每个字都会在你眼前逐步呈现，让你感受到与 AI 进行真实对话的流畅体验。</p><p><img src="https://img.hi-linux.com/staticfile/Ur5eIG-2024-08-08-Z3ycqQ.png" alt></p><h3><span id="多模型支持丰富你的-ai-体验">🎨 多模型支持：丰富你的 AI 体验</span></h3><p>Hollama 支持 Ollama 服务器上所有可用的模型。你可以轻松切换不同的模型，体验它们各自的特点和能力。无论是需要 GPT 系列的创意写作，还是 CodeLlama 的编程协助，Hollama 都能满足你的需求。</p><p><img src="https://img.hi-linux.com/staticfile/EYtDjX-2024-08-08-wRMtho.png" alt></p><h3><span id="对话历史回顾精彩瞬间">📜 对话历史：回顾精彩瞬间</span></h3><p>Hollama 会在浏览器中保存你的对话历史，让你可以随时回顾之前的对话内容。这个功能特别适合那些需要参考之前讨论结果的场景。</p><h3><span id="安全可靠本地部署更安心">🔐 安全可靠：本地部署更安心</span></h3><p>由于 Hollama 是一个本地运行的网页界面，连接的也是本地的 Ollama 服务器，因此你的所有对话都是在本地进行的。这极大地提高了数据的安全性和隐私保护，特别适合处理敏感信息的场景。</p><h3><span id="自定义选项打造专属体验">🌈 自定义选项：打造专属体验</span></h3><p>Hollama 提供了一些自定义选项，让你可以根据个人喜好调整使用体验：</p><ul><li>可以设置默认的 AI 模型</li><li>调整界面主题（如果支持的话）</li><li>设置最大标记数等参数</li></ul><p><img src="https://img.hi-linux.com/staticfile/uiAPvA-2024-08-08-LSGn3K.png" alt></p><h3><span id="响应式设计随时随地畅聊-ai">📱 响应式设计：随时随地畅聊 AI</span></h3><p>Hollama 采用响应式设计，无论你是使用台式电脑、笔记本还是手机，都能获得良好的使用体验。这意味着你可以随时随地与 AI 进行对话，激发创意灵感。</p><h2><span id="结论">🔚 结论</span></h2><p>Hollama 为 Ollama 服务器提供了一个简洁、直观且功能强大的 Web 界面。</p><p>它让与 AI 模型的交互变得前所未有的简单，无论你是 AI 爱好者、开发者，还是普通用户，都能轻松上手。</p><p>通过 Hollama，你可以充分发挥 Ollama 的潜力，探索 AI 的无限可能。</p><p>从此，与 AI 对话再也不是高深莫测的技术活，而是像聊天一样简单自然。Hollama 不仅仅是一个工具，它是连接你与 AI 世界的桥梁，让 AI 的力量触手可及。</p><p>准备好开始你的 AI 探索之旅了吗？</p><p>安装 Hollama，打开浏览器或桌面应用，让我们一起徜徉在 AI 的海洋中，发现 AI 带来的无限可能吧！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;🌐-引言&quot;&gt;🌐 引言&lt;/h2&gt;
&lt;p&gt;在人工智能快速发展的今天，我们越来越依赖各种 AI 工具来提高工作效率和生活质量。&lt;/p&gt;
&lt;p&gt;Ollama 作为一个强大的本地 AI 模型服务器，为我们提供了丰富的 AI 能力。但是，如何更方便地与 Ollama 进行交互呢？&lt;/p&gt;
&lt;p&gt;这就是 Hollama 的用武之地！Hollama 为 Ollama 服务器提供了一个简洁优雅的 Web 界面，让你可以轻松地与 AI 模型对话，无需复杂的命令行操作。让我们一起来探索 Hollama 的魅力吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="AI" scheme="https://www.hi-linux.com/tags/AI/"/>
    
      <category term="Ollama" scheme="https://www.hi-linux.com/tags/Ollama/"/>
    
      <category term="Hollama" scheme="https://www.hi-linux.com/tags/Hollama/"/>
    
  </entry>
  
  <entry>
    <title>10 个你不知道的 cURL 高级实用技巧</title>
    <link href="https://www.hi-linux.com/posts/21794.html"/>
    <id>https://www.hi-linux.com/posts/21794.html</id>
    <published>2024-08-07T01:00:00.000Z</published>
    <updated>2024-08-07T01:23:09.849Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="10-个例子展示为什么-curl-是一个很棒的命令行工具">10 个例子展示为什么 cURL 是一个很棒的命令行工具</span></h2><p>无论你是开发者、DevOps 工程师、系统管理员、QA 还是其他技术岗位，你一定对 cURL 很熟悉——用于通过 URL 传输数据的命令行工具和库。</p><p>然而，大多数时候，我们都只用 <code>curl</code> 来做一些简单的任务，比如下载文件或检查网站是否可访问，但 <code>curl</code> 能做的远不止这些！</p><p>在这篇文章中，我们将介绍一些很酷的例子和技巧，展示为什么 <code>curl</code> 是一个非常棒且被低估的工具……</p><h2><span id="文件名代换">文件名代换</span></h2><p>首先介绍的是文件名代换，它允许我们用一个 <code>curl</code> 命令发出多个请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/users/[1-3]"</span> | jq -s .</span><br><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/users/[0-10:2]"</span> | jq -s .</span><br><span class="line"></span><br><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/photos/&#123;1,6,35&#125;"</span> | jq -s .</span><br><span class="line"></span><br><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/users/[1-3]"</span> -o <span class="string">"file_#1.json"</span></span><br></pre></td></tr></table></figure><p>前两个命令展示了如何运行一系列请求——第一个命令会产生对 <code>.../users/1</code>、<code>.../users/2</code> 和 <code>.../users/3</code> 的请求，而另一个使用步长选项，产生 2、4、6、8 和 10 的请求。考虑到这些特定请求返回的是 JSON，我们还将它与 <code>jq ...</code> 和 <code>-s</code>（slurp）操作符结合，将单个请求的响应合并为一个数组。</p><p>第三个例子使用了特定数字的列表而不是范围，这也适用于字符和单词。例如，我们可以使用 globbing 发出带有多种协议的请求：<code>{http,https}://...</code></p><p>最后一个例子将 globbing 与输出变量结合，文件名中的 <code>#1</code> 变量指的是范围 <code>[1-3]</code>。这将生成 <code>file_1.json</code>、<code>file_2.json</code> 和 <code>file_3.json</code>。</p><a id="more"></a><h2><span id="配置文件">配置文件</span></h2><p>大多数时候，使用 <code>curl</code> 时我们可能希望传递相同的命令行选项，如代理设置、请求超时、头信息等。这时名为 <code>.curlrc</code> 的 <code>curl</code> 配置文件可能会派上用场：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.curlrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些头信息</span></span><br><span class="line">-H <span class="string">"Upgrade-Insecure-Requests: 1"</span></span><br><span class="line">-H <span class="string">"Accept-Language: en-US,en;q=0.8"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟随重定向</span></span><br><span class="line">--location</span><br></pre></td></tr></table></figure><p>这只是一个文本文件，每行代表一个将传递给 <code>curl</code> 的选项。它会自动从 <code>~/.curlrc</code> 读取，所以你不需要任何额外的标志，但你可以使用 <code>-K</code> 来覆盖或指定不同的位置，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -K .curlrc https://google.com</span><br></pre></td></tr></table></figure><p>类似于标志和选项，有时我们也希望传递凭据。这可以通过 <code>--user</code> 选项来完成，但这会将凭据留在 <code>Shell</code> 历史记录中，所以我们可以利用 <code>curl</code> 支持的 <code>.netrc</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.netrc</span></span><br><span class="line">machine https://authenticationtest.com/HTTPAuth/</span><br><span class="line">login user</span><br><span class="line">password pass</span><br></pre></td></tr></table></figure><p>格式包括 <code>machine</code>（URL）、<code>login</code> 和 <code>password</code>。它们可以在一行中或如上所示，并且我们可以在一个文件中有多个。要使用它，只需将其传递给 <code>curl</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --netrc-file .netrc https://authenticationtest.com/HTTPAuth/</span><br></pre></td></tr></table></figure><h2><span id="并行请求">并行请求</span></h2><p>我们已经在 <code>文件名代换部分</code> 讨论了请求的范围，但并行化呢？好吧，<code>curl</code> 也能做到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -I --parallel --parallel-immediate --parallel-max 3 --config websites.txt</span><br><span class="line"></span><br><span class="line">$ curl -I --parallel --parallel-immediate --parallel-max 3 stackoverflow.com google.com example.com</span><br></pre></td></tr></table></figure><p>我们需要做的只是添加 <code>--parallel</code>（或 <code>-Z</code>），<code>curl</code> 将打开最多 50 个并行连接（可以通过 <code>--parallel-max N</code> 更改）。</p><p>还要注意我们是如何提供 URL 的，第一种方法是通过 <code>--config</code> 参数和一个文本文件，看起来像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"stackoverflow.com"</span></span><br><span class="line">url = <span class="string">"google.com"</span></span><br><span class="line">url = <span class="string">"example.com"</span></span><br></pre></td></tr></table></figure><p>另一个方法是将所有 URL 放在命令行上。这两个选项也适用于非并行请求！</p><h2><span id="格式化和变量">格式化和变量</span></h2><p><code>curl</code> 可以输出很多东西，有时会让人不知所措、冗长且不必要。幸运的是，我们可以使用输出格式化只打印我们感兴趣的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ curl --silent --output /dev/null --show-error -w @format.txt http://example.com/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型: text/html; charset=UTF-8</span></span><br><span class="line"><span class="comment"># 代码: 200</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 从 8.1.0:</span></span><br><span class="line"><span class="comment"># 协议: http</span></span><br><span class="line"><span class="comment"># 主机: example.com</span></span><br><span class="line"><span class="comment"># 端口: 80</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 读取头信息内容 (v7.83.0):</span></span><br><span class="line"><span class="comment"># 服务器: Sat, 29 Jun 2024 13:01:30 GMT</span></span><br></pre></td></tr></table></figure><p>我们通过使用 <code>-w</code> 选项并传递一个格式文件来实现这一点。要生成上述输出，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># format.txt</span></span><br><span class="line">类型: %&#123;content_type&#125;\n代码: %&#123;response_code&#125;\n\n</span><br><span class="line"></span><br><span class="line">从 8.1.0:\n\n</span><br><span class="line"></span><br><span class="line">协议: %&#123;url.scheme&#125;\n</span><br><span class="line">主机: %&#123;url.host&#125;\n</span><br><span class="line">端口: %&#123;url.port&#125;\n</span><br><span class="line"></span><br><span class="line">读取头信息内容 (v7.83.0):\n</span><br><span class="line">%header&#123;date&#125;</span><br></pre></td></tr></table></figure><p>每个变量都用 <code>%{...}</code> 包围。它们可以是简单变量，如 <code>response_code</code>，也可以是 <code>url.&lt;NAME&gt;</code> 的一部分，指的是 URL 组件，如主机或端口。最后，我们还可以使用 <code>%header{HEADER_NAME}</code> 变量输出响应头信息。</p><p>格式化的一个很好的用途是测量请求/响应时间，可以用以下格式来实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># format.txt</span></span><br><span class="line">     域名解析时间:  %&#123;time_namelookup&#125;s\n</span><br><span class="line">        连接时间:  %&#123;time_connect&#125;s\n</span><br><span class="line">     应用连接时间:  %&#123;time_appconnect&#125;s\n</span><br><span class="line">       预传输时间:  %&#123;time_pretransfer&#125;s\n</span><br><span class="line">       重定向时间:  %&#123;time_redirect&#125;s\n</span><br><span class="line">      开始传输时间: %&#123;time_starttransfer&#125;s\n</span><br><span class="line">                ----------\n</span><br><span class="line">          总时间:  %&#123;time_total&#125;s\n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">     域名解析时间:  0.000765s</span><br><span class="line">        连接时间:  0.111908s</span><br><span class="line">     应用连接时间:  0.000000s</span><br><span class="line">       预传输时间:  0.111967s</span><br><span class="line">       重定向时间:  0.000000s</span><br><span class="line">     开始传输时间:  0.223373s</span><br><span class="line">                ----------</span><br><span class="line">          总时间:  0.223992s</span><br></pre></td></tr></table></figure><p>有关完整的变量列表，请参阅 <a href="https://everything.curl.dev/usingcurl/verbose/writeout.html#available---write-out-variables" target="_blank" rel="noopener">文档</a>。</p><h2><span id="测试与故障排除">测试与故障排除</span></h2><p>使用 <code>curl</code> 最常见的方式是进行（网络）故障排除。通常只需对特定 URL 发出请求即可提供足够的信息，但我们可以做更多的事情，例如我们可以强制使用特定的本地网络接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip link show</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 3: wlp5s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DORMANT group default qlen 1000</span></span><br><span class="line"></span><br><span class="line">$ curl --interface wlp5s0 https://example.com</span><br></pre></td></tr></table></figure><p>同样，我们可以强制使用特定的 DNS 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --dns-ipv4-addr 1.1.1.1 https://example.com</span><br></pre></td></tr></table></figure><p>或者我们可以测试超时并捕获退出代码（<a href="https://everything.curl.dev/cmdline/exitcode.html" target="_blank" rel="noopener">退出代码</a>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl --connect-timeout 30 --silent --output /dev/null \</span><br><span class="line">  --show-error -w <span class="string">'总时间: %&#123;time_total&#125;s\n'</span> http://google.com/ || EXIT_CODE=$?</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$EXIT_CODE</span> = 28 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"无法连接（超时）。"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"可以连接。"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这对测试代理服务器是否正常工作非常有用（使用 <code>-x http://proxy.example.com:80</code>）。</p><h2><span id="trurl">Trurl</span></h2><p><code>curl</code> 不只是一个 CLI 工具——该项目还包括 <code>libcurl</code> 以及 <code>trurl</code>，我想在这里展示一下。</p><p><a href="https://curl.se/trurl/" target="_blank" rel="noopener">trurl</a> 是一个用于解析 URL 的专用工具，是 <code>curl</code> 的兄弟项目。可以从源代码安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libcurl4-openssl-dev</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/curl/trurl.git</span><br><span class="line">$ <span class="built_in">cd</span> trurl</span><br><span class="line">$ make</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>这里有几个使用它的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ trurl --url https://example.com/some/path/to/file.html --get <span class="string">'&#123;path&#125;'</span></span><br><span class="line"><span class="comment"># /some/path/to/file.html</span></span><br><span class="line"></span><br><span class="line">$ trurl --url <span class="string">"https://example.com/?name=hello"</span> --append query=key=value</span><br><span class="line"><span class="comment"># https://example.com/?name=hello&amp;key=value</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析为 JSON：</span></span><br><span class="line">$ trurl --url <span class="string">"https://example.com/?name=hello"</span> --json</span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment">#   &#123;</span></span><br><span class="line"><span class="comment">#     "url": "https://example.com/?name=hello",</span></span><br><span class="line"><span class="comment">#     "parts": &#123;</span></span><br><span class="line"><span class="comment">#       "scheme": "https",</span></span><br><span class="line"><span class="comment">#       "host": "example.com",</span></span><br><span class="line"><span class="comment">#       "path": "/",</span></span><br><span class="line"><span class="comment">#       "query": "name=hello"</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     "params": [</span></span><br><span class="line"><span class="comment">#       &#123;</span></span><br><span class="line"><span class="comment">#         "key": "name",</span></span><br><span class="line"><span class="comment">#         "value": "hello"</span></span><br><span class="line"><span class="comment">#       &#125;</span></span><br><span class="line"><span class="comment">#     ]</span></span><br><span class="line"><span class="comment">#   &#125;</span></span><br><span class="line"><span class="comment"># ]</span></span><br></pre></td></tr></table></figure><p>第一个例子展示了如何提取 URL 组件，这里是路径，但也可以是如 url、scheme、user、password、options 或 host 等。</p><p>第二个例子使用 <code>append</code> 功能，向 URL 添加查询参数。</p><p>最后一个例子展示了 <code>--json</code> 选项，它将解析的 URL 输出为 JSON，非常适合进一步处理。</p><p><code>trurl</code> 可以做更多事情，你可以查看 <a href="https://www.youtube.com/watch?v=oDL7DVszr2w" target="_blank" rel="noopener">这个视频</a> 或 <a href="https://curl.se/trurl/manual.html" target="_blank" rel="noopener">手册</a>（底部有例子）。</p><h2><span id="发送上传数据">发送/上传数据</span></h2><p>大多数时候我们使用 <code>curl</code> 下载或请求数据，但它（显然）也可以发送数据。用 <code>curl</code> 发送 POST 数据并不是什么新鲜事，对吧？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST <span class="string">"https://httpbin.org/post"</span> -H <span class="string">"accept: application/json"</span> --json <span class="string">'&#123;"key": "value"&#125;'</span></span><br></pre></td></tr></table></figure><p>但这样发送 JSON，需要在单引号和双引号之间切换，很快就会变得很烦人，但有一个更好的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jo -p key=value | curl -X POST <span class="string">"https://httpbin.org/post"</span> -H <span class="string">"accept: application/json"</span> --json @-</span><br></pre></td></tr></table></figure><p>我想我们都熟悉用 <code>jq</code> 解析 <code>curl</code> 的 JSON 输出，但反过来呢？</p><p>上面我们使用 <code>jo</code> 工具，它可以轻松创建 JSON，然后我们可以使用 <code>--json</code> 选项将其传递给 <code>curl</code>。</p><p>当然，<code>--json</code> 选项也可以从文件中读取输入，例如使用 <code>--json @data.json</code>。</p><h2><span id="协议">协议</span></h2><p>最后但同样重要的是协议 —— 通常我们只会使用 HTTP 或 HTTPS，但 <code>curl</code> 支持 <a href="https://everything.curl.dev/protocols/protocols.html#what-other-protocols-are-there" target="_blank" rel="noopener">很多协议</a>。</p><p>我特别想提到一个是 <code>telnet</code>，它对于测试服务器是否监听特定端口很有用，但如果你在一台没有安装也不能安装 <code>telnet</code> 的服务器/机器上怎么办？只需使用 <code>curl</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同 telnet example.com 1234</span></span><br><span class="line">$ curl telnet://example.com:1234</span><br></pre></td></tr></table></figure><p>一些更为冷门（有趣）的协议选项是用于电子邮件的 IMAP、POP3 和 SMTP，这意味着你可以使用 <code>curl</code> 阅读和发送电子邮件。要阅读它们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --url <span class="string">"imaps://imap.gmail.com:993/Inbox;UID=1"</span> --user <span class="string">"[email protected]:PASSWORD"</span></span><br></pre></td></tr></table></figure><p>要使其在 GMail 上工作，你需要创建 <a href="https://support.google.com/mail/answer/185833?hl=en" target="_blank" rel="noopener">应用密码</a>，这比正常密码更不安全。如果你真的想尝试这个，请查看 <a href="https://developers.google.com/gmail/imap/imap-extensions" target="_blank" rel="noopener">Gmail IMAP 文档</a> 和 <a href="https://gist.github.com/akpoff/53ac391037ae2f2d376214eac4a23634" target="_blank" rel="noopener">这些查询</a> 以获取灵感。</p><p>要发送电子邮件，你可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl smtp://mail.example.com \</span><br><span class="line">  --mail-from [email protected] \</span><br><span class="line">  --mail-rcpt [email protected] \</span><br><span class="line">  --upload-file message.txt \</span><br><span class="line">  -u <span class="string">"[email protected]:PASSWORD"</span></span><br></pre></td></tr></table></figure><p>这里的 <code>message.txt</code> 是实际的电子邮件，需要遵循特定格式，请查看 <a href="https://everything.curl.dev/usingcurl/smtp.html" target="_blank" rel="noopener">这个页面</a> 了解示例。</p><h2><span id="结论">结论</span></h2><p>我们到了最后，我很确定这些例子至少有 10 个（我停止计数了）。但老实说，这只是冰山一角——我们甚至没有触及 <code>curl</code> 的重要级成部分 <code>libcurl</code>。</p><p><code>curl</code> 可以做的事情还有很多，所以我推荐你去探索 <a href="https://curl.se/docs/manpage.html" target="_blank" rel="noopener">文档</a> 和 <a href="https://everything.curl.dev/" target="_blank" rel="noopener">https://everything.curl.dev/</a>。</p><blockquote><p>本文翻译自：「 Martin Heinz 」，原文：<a href="https://martinheinz.dev/blog/113" target="_blank" rel="noopener">https://martinheinz.dev/blog/113</a> ，版权归原作者所有。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;10-个例子展示为什么-cURL-是一个很棒的命令行工具&quot;&gt;10 个例子展示为什么 cURL 是一个很棒的命令行工具&lt;/h2&gt;
&lt;p&gt;无论你是开发者、DevOps 工程师、系统管理员、QA 还是其他技术岗位，你一定对 cURL 很熟悉——用于通过 URL 传输数据的命令行工具和库。&lt;/p&gt;
&lt;p&gt;然而，大多数时候，我们都只用 &lt;code&gt;curl&lt;/code&gt; 来做一些简单的任务，比如下载文件或检查网站是否可访问，但 &lt;code&gt;curl&lt;/code&gt; 能做的远不止这些！&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将介绍一些很酷的例子和技巧，展示为什么 &lt;code&gt;curl&lt;/code&gt; 是一个非常棒且被低估的工具……&lt;/p&gt;
&lt;h2 id=&quot;文件名代换&quot;&gt;文件名代换&lt;/h2&gt;
&lt;p&gt;首先介绍的是文件名代换，它允许我们用一个 &lt;code&gt;curl&lt;/code&gt; 命令发出多个请求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/users/[1-3]&quot;&lt;/span&gt; | jq -s .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/users/[0-10:2]&quot;&lt;/span&gt; | jq -s .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/photos/&amp;#123;1,6,35&amp;#125;&quot;&lt;/span&gt; | jq -s .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/users/[1-3]&quot;&lt;/span&gt; -o &lt;span class=&quot;string&quot;&gt;&quot;file_#1.json&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前两个命令展示了如何运行一系列请求——第一个命令会产生对 &lt;code&gt;.../users/1&lt;/code&gt;、&lt;code&gt;.../users/2&lt;/code&gt; 和 &lt;code&gt;.../users/3&lt;/code&gt; 的请求，而另一个使用步长选项，产生 2、4、6、8 和 10 的请求。考虑到这些特定请求返回的是 JSON，我们还将它与 &lt;code&gt;jq ...&lt;/code&gt; 和 &lt;code&gt;-s&lt;/code&gt;（slurp）操作符结合，将单个请求的响应合并为一个数组。&lt;/p&gt;
&lt;p&gt;第三个例子使用了特定数字的列表而不是范围，这也适用于字符和单词。例如，我们可以使用 globbing 发出带有多种协议的请求：&lt;code&gt;{http,https}://...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后一个例子将 globbing 与输出变量结合，文件名中的 &lt;code&gt;#1&lt;/code&gt; 变量指的是范围 &lt;code&gt;[1-3]&lt;/code&gt;。这将生成 &lt;code&gt;file_1.json&lt;/code&gt;、&lt;code&gt;file_2.json&lt;/code&gt; 和 &lt;code&gt;file_3.json&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="cURL" scheme="https://www.hi-linux.com/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cdebug 容器调试界的瑞士军刀，5 个超能力让你成为调试大师</title>
    <link href="https://www.hi-linux.com/posts/11869.html"/>
    <id>https://www.hi-linux.com/posts/11869.html</id>
    <published>2024-08-06T01:00:00.000Z</published>
    <updated>2024-08-06T01:38:36.591Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>你是否曾经遇到过这样的情况:</p><ul><li>需要调试一个没有 Shell 的容器?</li><li>或者想访问容器内部未公开的端口?</li><li>也许你只是想方便地将容器文件系统导出到本地?</li></ul><p>如果有，那么 <code>cdebug</code> 就是为你量身打造的工具!</p><a id="more"></a><h2><span id="什么是-cdebug">什么是 cdebug?</span></h2><p><code>cdebug</code> 是一个功能强大的容器调试工具，它就像是容器世界的瑞士军刀。无论你是在处理 <code>Docker</code> 容器、<code>Kubernetes Pod</code>，还是其他类型的容器，<code>cdebug</code> 都能给你提供所需的工具和便利。</p><p>想象一下，你有一个神奇的工具箱，里面装满了各种调试工具。现在，你可以随时随地打开这个工具箱，解决容器中遇到的各种问题。这就是 <code>cdebug</code>!</p><ul><li>Github 地址: <a href="https://github.com/iximiuz/cdebug" target="_blank" rel="noopener">https://github.com/iximiuz/cdebug</a></li></ul><h2><span id="cdebug-能做什么">cdebug 能做什么?</span></h2><ol><li><strong>调试 “无 Shell” 容器</strong>: 即使容器内没有 Shell 或调试工具，你也能轻松进入并调试。</li><li><strong>端口魔术师</strong>: 将未公开的端口或 localhost 端口转发到你的主机系统。</li><li><strong>反向通道</strong>: 将主机系统的端点暴露给容器和 Kubernetes 网络。</li><li><strong>文件系统导出专家</strong>: 轻松将镜像或容器的文件系统导出到本地文件夹。</li><li><strong>更多惊喜等你发现…</strong></li></ol><h2><span id="安装-cdebug-简单得不能再简单">安装 cdebug: 简单得不能再简单!</span></h2><p><code>cdebug</code> 是一个静态链接的 <code>Go</code> 二进制文件，安装起来就像变魔术一样简单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于Linux amd64系统</span></span><br><span class="line">GOOS=linux</span><br><span class="line">GOARCH=amd64</span><br><span class="line"></span><br><span class="line">$ curl -Ls https://github.com/iximiuz/cdebug/releases/latest/download/cdebug_<span class="variable">$&#123;GOOS&#125;</span>_<span class="variable">$&#123;GOARCH&#125;</span>.tar.gz | tar xvz</span><br><span class="line"></span><br><span class="line">$ sudo mv cdebug /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><p>如果你是 <code>Homebrew</code> 用户，那就更简单了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install cdebug</span><br></pre></td></tr></table></figure><p>目前支持的系统:</p><ul><li>linux/amd64</li><li>darwin/amd64</li><li>darwin/arm64</li></ul><h2><span id="cdebug-使用指南-让调试变得有趣">cdebug 使用指南: 让调试变得有趣!</span></h2><h3><span id="1-cdebug-exec-你的容器你做主">1. cdebug exec: 你的容器，你做主</span></h3><p>想在一个 “瘦身” 容器中启动一个交互式 Shell? 没问题!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Docker 容器中启动一个 busybox:musl 的 shell</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it mycontainer</span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it docker://mycontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器中执行命令</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> mycontainer cat /etc/os-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用不同的调试工具包镜像</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image=alpine mycontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 nixery.dev 镜像，按需定制你的工具</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image=nixery.dev/shell/vim/ps/tshark mycontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 containerd 容器中执行</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it containerd://mycontainer ...</span><br><span class="line">$ cdebug <span class="built_in">exec</span> --namespace myns -it containerd://mycontainer ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 nerdctl 在容器中执行 </span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it nerdctl://mycontainer ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Kubernetes pod 中启动 shell</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/mypod</span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it k8s://mypod</span><br><span class="line">$ cdebug <span class="built_in">exec</span> --namespace=myns -it pod/mypod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Kubernetes pod 的容器中启动 shell</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/mypod/mycontainer</span><br></pre></td></tr></table></figure><p><code>cdebug exec</code> 就像是 <code>docker exec</code> 和 <code>kubectl debug</code> 的完美结合。它能让你在目标容器中启动一个调试用的 “伴侣” 容器，感觉就像是在使用 <code>docker exec</code>，但功能更强大:</p><ul><li>调试器的根文件系统就是目标容器的根文件系统。</li><li>目标容器不会被重新创建或重启。</li><li>无需额外的卷或复制调试工具。</li><li>调试工具在目标容器中随时可用。</li></ul><h3><span id="2-cdebug-port-forward-端口转发从未如此简单">2. cdebug port-forward: 端口转发从未如此简单</span></h3><p>想要访问容器内部的 “隐藏” 端口? 或者将本地端口暴露给容器? <code>cdebug port-forward</code> 助你轻松搞定!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器的 80 端口发布到主机的随机端口</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器的 localhost:5432 暴露到主机系统</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L 127.0.0.1:5432</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过目标容器将本地流量代理到远程主机</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L &lt;LOCAL_HOST&gt;:&lt;LOCAL_PORT&gt;:&lt;REMOTE_HOST&gt;:&lt;REMOTE_PORT&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 Kubernetes 服务暴露到主机系统</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L 8888:my.svc.cluster.local:443</span><br></pre></td></tr></table></figure><h3><span id="3-实战示例">3. 实战示例</span></h3><h4><span id="示例-1-给-无-shell-容器一个温暖的家">示例 1: 给 “无 Shell” 容器一个温暖的家</span></h4><p>想象你有一个基于 <code>Distroless</code> 的 <code>Node.js</code> 容器，没有 <code>Shell</code>，没有调试工具，简直就是一个 “光秃秃” 的容器。别担心，<code>cdebug</code> 来救场!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先，启动一个目标容器</span></span><br><span class="line">$ $ docker run -d --rm \</span><br><span class="line">  --name my-distroless gcr.io/distroless/nodejs \</span><br><span class="line">  -e <span class="string">'setTimeout(() =&gt; console.log("Done"), 99999999)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后，使用 cdebug 进入容器</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it my-distroless</span><br><span class="line"></span><br><span class="line"><span class="comment"># 瞧!你现在有了一个交互式 shell</span></span><br><span class="line">/ <span class="variable">$#</span> ls -lah</span><br><span class="line">total 60K</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Oct 17 23:49 .</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Oct 17 23:49 ..</span><br><span class="line">👉 lrwxrwxrwx 1 root     root          18 Oct 17 23:49 .cdebug-c153d669 -&gt; /proc/55/root/bin/</span><br><span class="line">-rwxr-xr-x    1 root     root           0 Oct 17 19:49 .dockerenv</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Jan  1  1970 bin</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Jan  1  1970 boot</span><br><span class="line">drwxr-xr-x    5 root     root         340 Oct 17 19:49 dev</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Oct 17 19:49 etc</span><br><span class="line">drwxr-xr-x    3 nonroot  nonroot     4.0K Jan  1  1970 home</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Jan  1  1970 lib</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Jan  1  1970 lib64</span><br><span class="line">drwxr-xr-x    5 root     root        4.0K Jan  1  1970 nodejs</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4><span id="示例-2-给你的容器加上超能力">示例 2: 给你的容器加上超能力</span></h4><p>有时候，<code>busybox</code> 提供的工具可能不够用。没关系，我们可以借助 <code>nixery</code> 项目的力量，给容器加上任何你想要的工具!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想要一个带有 vim 的 shell? 没问题!</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image nixery.dev/shell/vim my-distroless</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要更多高级工具?来吧!</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image nixery.dev/shell/ps/findutils/tshark my-distroless</span><br></pre></td></tr></table></figure><h4><span id="示例-3-调试-containerd-容器无需-docker">示例 3: 调试 containerd 容器（无需 Docker）</span></h4><p>首先，启动目标容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ctr image pull docker.io/library/nginx:latest</span><br><span class="line">$ sudo ctr run -d docker.io/library/nginx:latest nginx-1</span><br></pre></td></tr></table></figure><p>使用简单的 <code>cdebug exec</code> 在目标容器中运行交互式 <code>Shell</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it containerd://nginx-1</span><br><span class="line">/ <span class="variable">$#</span> wget -O- 127.0.0.1</span><br></pre></td></tr></table></figure><p>使用 <code>cdebug exec --image nixery.dev/shell/vim</code> 在目标容器中运行 <code>VIM</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it --rm --image nixery.dev/shell/vim containerd://nginx-1</span><br></pre></td></tr></table></figure><h4><span id="示例-4-调试-nerdctl-容器无需-docker">示例 4: 调试 nerdctl 容器（无需 Docker）</span></h4><p>使用 <code>nerdctl</code> 启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo $(<span class="built_in">which</span> nerdctl) run -d --name nginx-1 nginx</span><br><span class="line">9f8763d82259a6e3e747df83d0ce8b7ee3d33d94269a72cd04e0e3862a3abc5f</span><br></pre></td></tr></table></figure><p>使用 <code>nerdctl://</code> 模式和目标名称运行调试器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it --rm nerdctl://nginx-1</span><br></pre></td></tr></table></figure><p>或者使用 <code>containerd://</code> 模式在上述容器中运行调试会话：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it --rm containerd://9f876</span><br></pre></td></tr></table></figure><h4><span id="示例-5-kubernetes-pod-调试大师">示例 5: Kubernetes Pod 调试大师</span></h4><p>在 Kubernetes 中调试 Pod 不再是噩梦:</p><p>首先，创建一个 Pod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run --image nginx:alpine nginx-1</span><br><span class="line">$ kubectl run --image=nginx:alpine nginx-1 \</span><br><span class="line">  --overrides=<span class="string">'&#123; "apiVersion": "v1", "spec": &#123; "containers": [&#123; "name": "app", "image": "nginx:alpine" &#125;] &#125; &#125;'</span></span><br><span class="line">pod/nginx-1 created</span><br><span class="line"></span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-1   1/1     Running   0         5s</span><br></pre></td></tr></table></figure><p>然后，使用 <code>cdebug</code> 进入Pod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/nginx-1</span><br><span class="line"></span><br><span class="line">Debugger container name: cdebug-3023d11d</span><br><span class="line">Starting debugger container...</span><br><span class="line">Waiting <span class="keyword">for</span> debugger container...</span><br><span class="line">Attaching to debugger container...</span><br><span class="line">If you don<span class="string">'t see a command prompt, try pressing enter.</span></span><br><span class="line"><span class="string">/ # ps auxf</span></span><br><span class="line"><span class="string">PID   USER     TIME  COMMAND</span></span><br><span class="line"><span class="string">    1 root      0:00 sh /.cdebug-entrypoint.sh</span></span><br><span class="line"><span class="string">   10 root      0:00 /bin/sh -i</span></span><br><span class="line"><span class="string">   11 root      0:00 ps auxf</span></span><br></pre></td></tr></table></figure><p>想要直接进入特定的容器? 也是没问题的!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/nginx-1/app</span><br><span class="line"></span><br><span class="line">cdebug <span class="built_in">exec</span> -it pod/nginx-1/app</span><br><span class="line">Debugger container name: cdebug-b44ca485</span><br><span class="line">Starting debugger container...</span><br><span class="line">Waiting <span class="keyword">for</span> debugger container...</span><br><span class="line">Attaching to debugger container...</span><br><span class="line">If you don<span class="string">'t see a command prompt, try pressing enter.</span></span><br><span class="line"><span class="string">/ # ps auxf</span></span><br><span class="line"><span class="string">PID   USER     TIME  COMMAND</span></span><br><span class="line"><span class="string">    1 root      0:00 nginx: master process nginx -g daemon off;</span></span><br><span class="line"><span class="string">   30 nginx     0:00 nginx: worker process</span></span><br><span class="line"><span class="string">   ...</span></span><br><span class="line"><span class="string">   41 nginx     0:00 nginx: worker process</span></span><br><span class="line"><span class="string">   42 root      0:00 sh /.cdebug-entrypoint.sh</span></span><br><span class="line"><span class="string">   51 root      0:00 /bin/ash -i</span></span><br><span class="line"><span class="string">   52 root      0:00 ps auxf</span></span><br></pre></td></tr></table></figure><h4><span id="示例-6-端口转发魔术">示例 6: 端口转发魔术</span></h4><h5><span id="61-忘记发布容器端口了-cdebug-来帮忙">6.1 忘记发布容器端口了? cdebug 来帮忙:</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个nginx容器，不暴露任何端口</span></span><br><span class="line">$ docker run -d --name nginx-1 nginx:1.23</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 cdebug 将本地 8080 端口转发到容器的 80 端口</span></span><br><span class="line">$ cdebug port-forward nginx-1 -L 8080:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在你可以访问 nginx了</span></span><br><span class="line">$ curl localhost:8080</span><br></pre></td></tr></table></figure><h5><span id="62-将本地端口暴露给容器">6.2 将本地端口暴露给容器:</span></h5><p>启动仅监听本地主机的容器化服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name svc-1 python:3-alpine python3 -m <span class="string">'http.server'</span> -b 127.0.0.1 8888</span><br></pre></td></tr></table></figure><p>利用上述服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cdebug port-forward svc-1 -L 127.0.0.1:8888</span><br><span class="line">Pulling forwarder image...</span><br><span class="line">latest: Pulling from shell&#x2F;socat</span><br><span class="line">Digest: sha256:b43b6cf8d22615616b13c744b8ff525f5f6c0ca6c11b37fa3832a951ebb3c20c</span><br><span class="line">Status: Image is up to date for nixery.dev&#x2F;shell&#x2F;socat:latest</span><br><span class="line">Forwarding 127.0.0.1:49176 to 127.0.0.1:8888 through 172.17.0.4:34128</span><br><span class="line"></span><br><span class="line">$ curl localhost:49176</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2><span id="总结-你的容器调试新伙伴">总结: 你的容器调试新伙伴</span></h2><p><code>cdebug</code> 不仅仅是一个工具，它是你在容器世界冒险时的得力助手。无论你是在调试一个顽固的容器，还是需要快速访问一个隐藏的服务，<code>cdebug</code> 都能帮你搞定。</p><p>记住，在容器的海洋中，<code>cdebug</code> 就是你的瑞士军刀。所以，下次当你面对一个看似不可能的容器调试任务时，别忘了问问自己:“我的 <code>cdebug</code> 在哪里?”</p><p>祝你调试愉快，容器世界的冒险家!</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否曾经遇到过这样的情况:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要调试一个没有 Shell 的容器?&lt;/li&gt;
&lt;li&gt;或者想访问容器内部未公开的端口?&lt;/li&gt;
&lt;li&gt;也许你只是想方便地将容器文件系统导出到本地?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果有，那么 &lt;code&gt;cdebug&lt;/code&gt; 就是为你量身打造的工具!&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="cdebug" scheme="https://www.hi-linux.com/tags/cdebug/"/>
    
  </entry>
  
  <entry>
    <title>开发者必备神器，find-container-process 一键让容器进程无所遁形</title>
    <link href="https://www.hi-linux.com/posts/59304.html"/>
    <id>https://www.hi-linux.com/posts/59304.html</id>
    <published>2024-08-05T01:00:00.000Z</published>
    <updated>2024-08-05T01:21:14.549Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>嘿，开发者朋友们！你是否曾经在一堆容器和进程中迷失过方向？</p><p>你是否曾经怀疑你的容器里到底藏了哪些神秘的进程？别担心，我们的 <code>find-container-process</code> 工具来了！</p><p>这个小工具能帮你轻松找到指定的进程所在的容器，并展示详细信息。它简洁实用，让你在调试和管理容器时不再抓狂。</p><h2><span id="find-container-process-功能">find-container-process 功能</span></h2><p><code>find-container-process</code> 有哪些神奇的功能呢？简单来说，它能：</p><ul><li>根据你输入的进程 ID (PID)，找到对应的 Docker 容器。</li><li>显示进程名称、进程 ID、容器名称和容器 ID。</li><li>提供一个整洁的表格视图，让信息一目了然。</li></ul><a id="more"></a><h2><span id="find-container-process-使用方法">find-container-process 使用方法</span></h2><h3><span id="环境要求">环境要求</span></h3><ul><li>需要安装 <code>Docker</code>。</li></ul><h3><span id="在-docker-容器中运行-find-container-process">在 Docker 容器中运行 find-container-process</span></h3><p>运行以下命令启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it --name find-container-process -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/find-container-process</span><br></pre></td></tr></table></figure><h3><span id="find-container-process-操作方法">find-container-process 操作方法</span></h3><ol><li><strong>输入 PID 列表</strong></li></ol><p>程序启动后，会提示你输入一个或多个 PID（用逗号分隔）。</p><p>别担心，这里没有陷阱，只需输入你想要查找的进程 ID，按下回车键即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter the PIDs (comma-separated): 3347139,3347187,3347188,3347189,3347208</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>查看结果</strong></li></ol><p>程序会显示一个漂亮的表格，包含进程名称、进程 ID、容器名称和容器 ID。</p><p>看看，这样是不是清晰多了？</p><p><img src="https://img.hi-linux.com/staticfile/qGFtDH-2024-08-02-l4sKH9.png" alt></p><h3><span id="注意事项">注意事项</span></h3><ul><li>请确保 Docker 正在运行，并且你有足够的权限访问 Docker 守护进程（即你在 Docker 组中）。</li><li>如果你在容器中运行这个工具，请使用 <code>--privileged</code> 选项，并挂载 Docker 套接字：<code>-v /var/run/docker.sock:/var/run/docker.sock</code>。</li><li>我们使用 <code>--pid=host</code> 和 <code>--net=host</code> 来允许容器访问主机的进程和网络命名空间。</li></ul><h2><span id="结语">结语</span></h2><p>好了，朋友们，现在你又拥有了一个强大的 <code>Docker</code> 小工具，它能在容器和进程的迷宫中轻松导航。</p><p><code>find-container-process</code> 将成为你调试和管理 <code>Docker</code> 容器的得力助手。如果你觉得这个工具有趣又实用，别忘了给我们点个星星哦！</p><p>祝你在容器的世界里玩得开心！🚀</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嘿，开发者朋友们！你是否曾经在一堆容器和进程中迷失过方向？&lt;/p&gt;
&lt;p&gt;你是否曾经怀疑你的容器里到底藏了哪些神秘的进程？别担心，我们的 &lt;code&gt;find-container-process&lt;/code&gt; 工具来了！&lt;/p&gt;
&lt;p&gt;这个小工具能帮你轻松找到指定的进程所在的容器，并展示详细信息。它简洁实用，让你在调试和管理容器时不再抓狂。&lt;/p&gt;
&lt;h2 id=&quot;find-container-process-功能&quot;&gt;find-container-process 功能&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;find-container-process&lt;/code&gt; 有哪些神奇的功能呢？简单来说，它能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据你输入的进程 ID (PID)，找到对应的 Docker 容器。&lt;/li&gt;
&lt;li&gt;显示进程名称、进程 ID、容器名称和容器 ID。&lt;/li&gt;
&lt;li&gt;提供一个整洁的表格视图，让信息一目了然。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>一键测速、24 小时实时监控，MySpeed 让你成为网络管理专家</title>
    <link href="https://www.hi-linux.com/posts/55534.html"/>
    <id>https://www.hi-linux.com/posts/55534.html</id>
    <published>2024-07-30T01:00:00.000Z</published>
    <updated>2024-07-30T05:55:03.012Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>你是否曾经遇到过网速突然变慢，但又不知道如何查找原因的情况？或者你想长期监控你的网络性能，但找不到合适的工具？</p><p>别担心，<code>MySpeed</code> 来啦！这个强大而简单的工具可以帮助你轻松测试和监控网络速度。今天，让我们一起深入了解 <code>MySpeed</code>，看看它如何成为你的网络管家!</p><h2><span id="什么是-myspeed">什么是 MySpeed？</span></h2><p><code>MySpeed</code> 是一个开源的网络速度测试和监控工具。它不仅可以测试你的当前网速，还能持续监控网络性能，并以图表形式展示结果。无论你是网络达人还是普通用户，<code>MySpeed</code> 都能满足你的需求。</p><p><code>MySpeed</code> 支持 <code>Ookla</code>、<code>LibreSpeed</code> 和 <code>Cloudflare</code> 多种速度测试服务器。你可以根据自身需求，在它们之间进行任意选择。</p><ul><li>MySpeed 官方地址</li></ul><p><a href="https://myspeed.dev/" target="_blank" rel="noopener">https://myspeed.dev/</a></p><ul><li>MySpeed Github 地址</li></ul><p><a href="https://github.com/gnmyt/myspeed" target="_blank" rel="noopener">https://github.com/gnmyt/myspeed</a></p><a id="more"></a><p>⭐ MySpeed 具有以下特性</p><p>📊 <code>MySpeed</code> 可生成清晰的速度、<code>Ping</code> 等统计数据<br>⏰ <code>MySpeed</code> 可自动进行速度测试，并允许您使用 <code>Cron</code> 表达式设置测试之间的时间间隔<br>🗄️ 直接向 <code>MySpeed</code> 实例添加多个服务器<br>🩺 配置健康检查，以便在出现错误或停机时通过电子邮件、Signal、WhatsApp 或 Telegram 通知您<br>📆 测试结果可存储长达 30 天<br>🔥 支持 <code>Prometheus</code> 和 <code>Grafana</code><br>🗳️ 在 <code>Ookla</code>、<code>LibreSpeed</code> 和 <code>Cloudflare</code> 速度测试服务器之间进行选择</p><h2><span id="为什么选择-myspeed">为什么选择 MySpeed?</span></h2><ol><li><strong>开源免费</strong>: 作为一个开源项目，<code>MySpeed</code> 完全免费使用，你还可以根据需要自定义功能。</li><li><strong>功能强大</strong>: 支持速度测试、长期监控、数据可视化等多种功能。</li><li><strong>使用简单</strong>: 界面友好，操作直观，即使是技术小白也能轻松上手。</li><li><strong>隐私保护</strong>: 所有数据都存储在你的本地设备上，无需担心隐私泄露。</li></ol><p>好了，话不多说，让我们开始 <code>MySpeed</code> 的奇妙之旅吧!</p><h2><span id="安装-myspeed">安装 MySpeed</span></h2><p><code>MySpeed</code> 使用 <code>Node.js</code> 开发，因此你需要先安装 <code>Node.js</code> 和 <code>NPM</code> 包管理器。</p><p>好消息！<code>MySpeed</code> 现在支持 <code>Docker</code> 安装,这意味着你可以在几分钟内就完成安装,而不需要担心复杂的依赖问题。让我们一起来看看如何通过 <code>Docker</code> 轻松部署 <code>MySpeed</code>。</p><h3><span id="准备工作">准备工作</span></h3><p>在开始之前,请确保你的系统已经安装了 <code>Docker</code>。如果还没有安装,可以访问 <code>Docker</code> 官网下载并安装适合你系统的版本。</p><ol><li>步骤 1: 拉取 MySpeed 镜像</li></ol><p>打开你的终端，输入以下命令来拉取 <code>MySpeed</code> 的 <code>Docker</code> 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull germannewsmaker/myspeed:latest</span><br></pre></td></tr></table></figure><p>这个命令会从 <code>Docker</code> 容器仓库下载最新版本的 <code>MySpeed</code> 最新镜像。</p><ol start="2"><li>步骤 2: 运行 MySpeed 容器</li></ol><p>现在，让我们启动 <code>MySpeed</code> 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5216:5216 -v myspeed:/myspeed/data --restart=unless-stopped --name MySpeed germannewsmaker/myspeed</span><br></pre></td></tr></table></figure><p>这个命令做了以下几件事：</p><ul><li><code>-d</code>: 在后台运行容器</li><li><code>-p 5216:5216</code>: 将容器的 5216 端口映射到主机的 5216 端口</li><li><code>-v myspeed_data:/myspeed/data</code>: 创建一个名为 <code>myspeed_data</code> 的卷,用于持久化存储数据</li><li><code>--name myspeed</code>: 给容器取名为 “myspeed”</li></ul><ol start="3"><li>步骤 3: 验证安装</li></ol><p>打开你喜欢的浏览器,访问 <code>http://localhost:5216</code>。如果你看到 <code>MySpeed</code> 的界面，恭喜你，安装成功了！</p><ol start="4"><li>额外提示：更新 MySpeed</li></ol><p>当有新版本发布时，更新 <code>MySpeed</code> 也非常简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5216:5216 --pull always -v myspeed:/myspeed/data --restart=unless-stopped --name MySpeed germannewsmaker/myspeed</span><br></pre></td></tr></table></figure><p>加入的 <code>--pull always</code> 参数的作用是告诉 <code>Docker</code> 始终尝试更新镜像。</p><h2><span id="使用-myspeed">使用 MySpeed</span></h2><h3><span id="访问-web-界面">访问 Web 界面</span></h3><p>打开你喜欢的浏览器，输入<code>http://localhost:5216</code> 。欢迎来到 <code>MySpeed</code> 的世界!</p><h3><span id="进行速度测试">进行速度测试</span></h3><ol><li>在主页上，你会看到一个大大的 “开始测试” 按钮。</li><li>点击它，MySpeed 就会开始测试你的下载和上传速度。</li><li>稍等片刻，结果就会以清晰的图表和数字展示出来。</li></ol><p><img src="https://img.hi-linux.com/staticfile/9AgHIB-2024-07-29-s9nmOK.png" alt></p><h3><span id="查看历史数据">查看历史数据</span></h3><p><code>MySpeed</code> 不仅仅是一个简单的速度测试工具，它还能帮你记录和分析长期的网络性能。</p><ol><li>点击顶部导航栏的 “设置-切换视图” 选项。</li><li>你会看到一个漂亮的图表，展示了你的网络速度变化趋势。</li><li>可以选择不同的时间范围，比如最近 7 天、30 天或自定义时间段。</li></ol><p><img src="https://img.hi-linux.com/staticfile/WFAeZS-2024-07-29-ZqTuef.png" alt></p><h3><span id="设置自动测试">设置自动测试</span></h3><p>想要 24 小时监控你的网络性能吗？<code>MySpeed</code> 可以帮你实现!</p><ol><li>进入 “设置” 页面。</li><li>找到 “设置频率” 选项。</li><li>设置测试频率，比如：每小时一次。</li><li>保存设置，然后放松一下，让 <code>MySpeed</code> 为你工作吧!</li></ol><p><img src="https://img.hi-linux.com/staticfile/sD5KHH-2024-07-29-217a7g.png" alt></p><h3><span id="数据导出">数据导出</span></h3><p>想要深入分析你的网络数据? <code>MySpeed</code> 支持数据导出功能:</p><ol><li>在 “管理存储” 页面，点击 “导出数据” 按钮。</li><li>选择导出格式 (CSV 或 JSON)。</li><li>选择时间范围。</li><li>下载文件，开始你的数据探索之旅!</li></ol><p><img src="https://img.hi-linux.com/staticfile/Jmy0Kz-2024-07-29-cD99EF.png" alt></p><h2><span id="结语">结语</span></h2><p>无论是日常使用还是长期监控，<code>MySpeed</code> 都将成为你的得力助手。记住，好的网络体验始于了解你的网络状况。所以，开始你的 <code>MySpeed</code> 之旅吧，让我们一起享受畅快的网络世界!</p><p>最后，别忘了时不时地查看 <code>MySpeed</code> 的 GitHub 页面，关注最新的更新和功能。</p><p>如果你有什么好点子，也不要犹豫，给开发者提交一个 <code>Pull Request</code>。谁知道呢，也许你的创意会成为 MySpeed 的下一个重要功能!</p><p>现在，开始你的网速探索之旅吧。愿你的网络永远畅通无阻!</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否曾经遇到过网速突然变慢，但又不知道如何查找原因的情况？或者你想长期监控你的网络性能，但找不到合适的工具？&lt;/p&gt;
&lt;p&gt;别担心，&lt;code&gt;MySpeed&lt;/code&gt; 来啦！这个强大而简单的工具可以帮助你轻松测试和监控网络速度。今天，让我们一起深入了解 &lt;code&gt;MySpeed&lt;/code&gt;，看看它如何成为你的网络管家!&lt;/p&gt;
&lt;h2 id=&quot;什么是-MySpeed？&quot;&gt;什么是 MySpeed？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MySpeed&lt;/code&gt; 是一个开源的网络速度测试和监控工具。它不仅可以测试你的当前网速，还能持续监控网络性能，并以图表形式展示结果。无论你是网络达人还是普通用户，&lt;code&gt;MySpeed&lt;/code&gt; 都能满足你的需求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MySpeed&lt;/code&gt; 支持 &lt;code&gt;Ookla&lt;/code&gt;、&lt;code&gt;LibreSpeed&lt;/code&gt; 和 &lt;code&gt;Cloudflare&lt;/code&gt; 多种速度测试服务器。你可以根据自身需求，在它们之间进行任意选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySpeed 官方地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://myspeed.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://myspeed.dev/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySpeed Github 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gnmyt/myspeed&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/gnmyt/myspeed&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="开源" scheme="https://www.hi-linux.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="MySpeed" scheme="https://www.hi-linux.com/tags/MySpeed/"/>
    
  </entry>
  
  <entry>
    <title>一款超实用的 Docker 容器网络实时监控工具，助你轻松掌握 Docker 容器网络状态</title>
    <link href="https://www.hi-linux.com/posts/36215.html"/>
    <id>https://www.hi-linux.com/posts/36215.html</id>
    <published>2024-07-29T01:00:00.000Z</published>
    <updated>2024-07-29T01:24:49.026Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="1-什么是-check-docker-connection">1. 什么是 check-docker-connection</span></h2><p><code>check-docker-connection</code> 主要用于监控 <code>Docker</code> 容器的网络连接情况。它可以显示指定容器的网络连接状态，包括 <code>TCP</code> 和 <code>UDP</code> 连接的数量。</p><p>用户可以通过容器 <code>ID</code> 或名称来指定要监控的容器，或者指定显示连接数最多的前 N 个容器。输出结果以表格形式展示，方便用户查看。</p><h3><span id="check-docker-connection-主要功能包括">check-docker-connection 主要功能包括：</span></h3><p>列出指定容器的网络连接状态，包括：</p><ul><li>已建立连接（ESTABLISHED）</li><li>TIME_WAIT 状态的连接</li><li>FIN_WAIT2 状态的连接</li><li>CLOSE_WAIT 状态的连接</li><li>监听状态（LISTEN）</li><li>SYN_SENT 状态的连接</li><li>SYN_RECV 状态的连接</li><li>UDP 连接数</li></ul><a id="more"></a><h2><span id="2-check-docker-connection-具体使用方法">2. check-docker-connection 具体使用方法</span></h2><h3><span id="环境要求">环境要求</span></h3><ul><li>需要安装 <code>Docker</code>。</li><li>宿主机上必须安装有 <code>netstat</code> 和 <code>nsenter</code> 命令，以便访问容器的网络命名空间。如果没有，请自行安装，各大发行版上通常都是 <code>net-tools</code> 和 <code>util-linux</code> 包。</li></ul><h3><span id="命令行参数">命令行参数</span></h3><ul><li><code>-c</code>: 指定一个或多个容器的 ID 或名称，多个容器用逗号分隔。</li><li><code>-n</code>: 显示连接数最多的前 N 个容器。</li></ul><p>注意：<code>-c</code> 和 <code>-n</code> 参数不能同时使用。</p><h3><span id="运行-check-docker-connection">运行 check-docker-connection</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><code>check-docker-connection</code> 需要访问 <code>Docker socket</code>，所以我们挂载了 <code>/var/run/docker.sock</code>。</li><li>我们使用 <code>--pid=host</code> 和 <code>--net=host</code> 来允许容器访问主机的进程和网络命名空间。</li><li><code>--privileged</code> 标志允许容器使用 <code>nsenter</code> 命令。</li></ol><h2><span id="3-check-docker-connection-使用实例">3. check-docker-connection 使用实例</span></h2><h3><span id="示例-1监控单个容器">示例 1：监控单个容器</span></h3><p>要监控名为 <code>traefik</code> 的容器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -c traefik</span><br></pre></td></tr></table></figure><p>这将输出该容器的所有网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/uyZkmg-2024-07-25-tLw6IA.png" alt></p><h3><span id="示例-2监控多个容器">示例 2：监控多个容器</span></h3><p>要监控多个容器，例如 <code>traefik</code> 和 <code>splayer</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -c traefik,splayer</span><br></pre></td></tr></table></figure><p>这将显示这两个容器的网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/Klvkhf-2024-07-25-N5PIBC.png" alt></p><h3><span id="示例-3显示连接数最多的前-3-个容器">示例 3：显示连接数最多的前 3 个容器</span></h3><p>要显示连接数最多的前 3 个容器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -n 3</span><br></pre></td></tr></table></figure><p>这将输出连接数最多的三个容器的网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/CHYMME-2024-07-25-4rCycb.png" alt></p><p>通过以上示例，用户可以轻松地监控 Docker 容器的网络连接状态，帮助进行网络性能分析和故障排查。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是-check-docker-connection&quot;&gt;1. 什么是 check-docker-connection&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;check-docker-connection&lt;/code&gt; 主要用于监控 &lt;code&gt;Docker&lt;/code&gt; 容器的网络连接情况。它可以显示指定容器的网络连接状态，包括 &lt;code&gt;TCP&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt; 连接的数量。&lt;/p&gt;
&lt;p&gt;用户可以通过容器 &lt;code&gt;ID&lt;/code&gt; 或名称来指定要监控的容器，或者指定显示连接数最多的前 N 个容器。输出结果以表格形式展示，方便用户查看。&lt;/p&gt;
&lt;h3 id=&quot;check-docker-connection-主要功能包括：&quot;&gt;check-docker-connection 主要功能包括：&lt;/h3&gt;
&lt;p&gt;列出指定容器的网络连接状态，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已建立连接（ESTABLISHED）&lt;/li&gt;
&lt;li&gt;TIME_WAIT 状态的连接&lt;/li&gt;
&lt;li&gt;FIN_WAIT2 状态的连接&lt;/li&gt;
&lt;li&gt;CLOSE_WAIT 状态的连接&lt;/li&gt;
&lt;li&gt;监听状态（LISTEN）&lt;/li&gt;
&lt;li&gt;SYN_SENT 状态的连接&lt;/li&gt;
&lt;li&gt;SYN_RECV 状态的连接&lt;/li&gt;
&lt;li&gt;UDP 连接数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>解锁 VSCode 远程 SSH 的隐藏功能 - 跨用户访问文件系统的完美解决方案</title>
    <link href="https://www.hi-linux.com/posts/31204.html"/>
    <id>https://www.hi-linux.com/posts/31204.html</id>
    <published>2024-07-24T01:00:00.000Z</published>
    <updated>2024-07-24T01:49:54.723Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在使用远程服务器（例如: 虚拟机）时，有时您需要切换到不同的用户，例如：短时间内获得更高的权限。</p><p>通常可以使用以下命令之一来完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su &lt;different-user&gt;</span><br><span class="line">$ sudo -i -u &lt;different-user&gt;</span><br></pre></td></tr></table></figure><p>但如果你想使用 <code>VSCode</code> 时更轻松地探索文件系统和编辑代码，这就不那么简单了。比如：登录用户为 <code>mike</code>，而您想在 VSCode 资源管理器中访问 <code>root</code> 用户的主目录。</p><a id="more"></a><p>首先，您需要在 <code>VSCode</code> 配置中启用一些标志，你可以在用户界面 ( 用 <code>ctrl+,</code> 打开设置，搜索 <code>Remote.SSH</code> ) 中启用：</p><p><img src="https://img.hi-linux.com/staticfile/1*zUTsTgGusNzfhdYGQnyA7g-20240719134757890-2024-07-19-zJ7n8x.png" alt></p><p>或 <code>settings.json</code> 中编辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;remote.SSH.useLocalServer&quot;: true,</span><br><span class="line">&quot;remote.SSH.enableRemoteCommand&quot;: true,</span><br></pre></td></tr></table></figure><p>然后，打开 <code>SSH</code> 配置文件（默认为 <code>/home/$USER/.ssh/config</code>），在主机中添加 <code>RemoteCommand</code> 和 <code>RequestTTY</code> 选项。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host example.com</span><br><span class="line">  HostName example.com</span><br><span class="line">  IdentitiesOnly&#x3D;yes</span><br><span class="line">  User my_user</span><br><span class="line">  RequestTTY yes</span><br><span class="line">  RemoteCommand sudo -i -u other_user</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>RequestTTY</code> 选项的作用是指定是否为会话请求伪 TTY。参数可以是：no（从不请求 TTY）、yes（当标准输入为 TTY 时始终请求 TTY）、force（始终请求 TTY）或 auto（打开登录会话时请求 TTY）。该选项与 -t 和 -T 标志相同。如果你不加上这个选项，通过 SSH 命令行登陆时将无法正常登陆。</p></blockquote><p>如果远程服务器可以访问互联网，那就已经配置完成了。</p><p>否则，您需要采取以下两个步骤中的一个。</p><ol><li>远程服务器可通过代理访问互联网</li></ol><p>在这种情况下，请在需要切换用户的主目录下创建一个 <code>.wgetrc</code> 文件。例如: <code>/home/other_user/.wgetrc</code>，内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use_proxy&#x3D;on</span><br><span class="line">http_proxy&#x3D;http:&#x2F;&#x2F;proxy.host:&lt;port&gt;</span><br><span class="line">https_proxy&#x3D;http:&#x2F;&#x2F;proxy.host:&lt;port&gt;</span><br></pre></td></tr></table></figure><p>这是必要的，因为 <code>VSCode</code> 会在会话开始时使用 <code>wget</code> 下载必要的二进制文件。</p><ol start="2"><li>远程服务器根本无法访问互联网</li></ol><p>在这种情况下，您需要在本地下载 <code>VSCode</code> 服务器文件，然后将其复制（例如: 使用 <code>scp</code>）到服务器，具体步骤如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 本地下载</span><br><span class="line">$ commit_id&#x3D;f1e16e1e6214d7c44d078b1f0607b2388f29d729</span><br><span class="line">$ curl -sSL &quot;https:&#x2F;&#x2F;update.code.visualstudio.com&#x2F;commit:$&#123;commit_id&#125;&#x2F;server-linux-x64&#x2F;stable&quot; -o vscode-server-linux-x64.tar.gz</span><br><span class="line">$ scp  vscode-server-linux-x64.tar.gz user@remotehost:&#x2F;home&#x2F;user&#x2F;</span><br><span class="line"></span><br><span class="line"># 远程服务器操作</span><br><span class="line">$ commit_id&#x3D;f1e16e1e6214d7c44d078b1f0607b2388f29d729</span><br><span class="line">$ mkdir -p ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125;</span><br><span class="line">$ tar zxvf ~&#x2F;vscode-server-linux-x64.tar.gz -C ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125; --strip 1</span><br><span class="line">$ touch ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125;&#x2F;0</span><br></pre></td></tr></table></figure><p>更详细步骤可参考：<a href="https://stackoverflow.com/a/57601121/8175198" target="_blank" rel="noopener">https://stackoverflow.com/a/57601121/8175198</a></p><p>或者，先用 <code>VSCode</code> 远程 <code>SSH</code> 连接正常用户，让它传输文件，然后将文件复制到另一个用户的主目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r &#x2F;home&#x2F;mike&#x2F;.vscode-server&#x2F; &#x2F;root&#x2F;</span><br></pre></td></tr></table></figure><p>您还可以将默认设为在客户端上下载 VSCode 服务器文件，并使用 <code>scp</code> 将其传输到主机，而不是先尝试 <code>wget</code> 将其下载到主机上。</p><p><img src="https://img.hi-linux.com/staticfile/1*a-Yc1-R4b707xJSkq8qnwQ-2024-07-19-ngo7vk.png" alt></p><p>您也可以更改这些文件的安装位置</p><p><img src="https://img.hi-linux.com/staticfile/1*61VUKyX8fM13gW4Vb8e1MA-2024-07-19-q2Ii72.png" alt></p><p>参考文档：</p><ol><li><a href="https://medium.com/@krisztian.sala/vs-code-remote-ssh-as-another-user-57d449e20fb1" target="_blank" rel="noopener">https://medium.com/@krisztian.sala/vs-code-remote-ssh-as-another-user-57d449e20fb1</a></li><li><a href="https://stackoverflow.com/a/57601121/8175198" target="_blank" rel="noopener">https://stackoverflow.com/a/57601121/8175198</a></li><li><a href="https://github.com/b01/dl-vscode-server" target="_blank" rel="noopener">https://github.com/b01/dl-vscode-server</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用远程服务器（例如: 虚拟机）时，有时您需要切换到不同的用户，例如：短时间内获得更高的权限。&lt;/p&gt;
&lt;p&gt;通常可以使用以下命令之一来完成：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ su &amp;lt;different-user&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo -i -u &amp;lt;different-user&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但如果你想使用 &lt;code&gt;VSCode&lt;/code&gt; 时更轻松地探索文件系统和编辑代码，这就不那么简单了。比如：登录用户为 &lt;code&gt;mike&lt;/code&gt;，而您想在 VSCode 资源管理器中访问 &lt;code&gt;root&lt;/code&gt; 用户的主目录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="VSCode" scheme="https://www.hi-linux.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>无需 Dockerfile，打造你的专属即时容器镜像--自建 Nixery 私有服务器</title>
    <link href="https://www.hi-linux.com/posts/26894.html"/>
    <id>https://www.hi-linux.com/posts/26894.html</id>
    <published>2024-07-22T01:00:00.000Z</published>
    <updated>2024-07-22T02:17:10.405Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>自建一个 <code>Nixery</code> 实例可以让你在本地或私有服务器上运行 <code>Nixery</code> 服务，从而避免公共服务的不稳定性。以下是一个基本的步骤指南，帮助你在本地或服务器上部署 <code>Nixery</code>。</p><h2><span id="1-准备环境">1. 准备环境</span></h2><p>确保你的系统已经安装了以下软件：</p><ul><li>Nix</li><li>Docker</li><li>Git</li></ul><p><code>Docker</code> 和 <code>Git</code> 属于基础软件，就不再展开讲解安装部分了。<code>Nix</code> 安装你可以参考 <a href="https://nixos.org/download/#nix-install-linux" target="_blank" rel="noopener">Nix 官方文档</a> 进行安装。</p><a id="more"></a><h2><span id="2-克隆-nixery-仓库">2. 克隆 Nixery 仓库</span></h2><p>首先，你需要克隆 <code>Nixery</code> 的代码仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://code.tvl.fyi/depot.git:/tools/nixery.git nixery</span><br><span class="line">$ <span class="built_in">cd</span> nixery</span><br></pre></td></tr></table></figure><h2><span id="3-构建和运行-nixery">3. 构建和运行 Nixery</span></h2><p>使用 <code>Nix</code> 构建 <code>Nixery</code> 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nix-build -A nixery-image</span><br></pre></td></tr></table></figure><p>构建完成后，你会在 <code>result</code> 目录中得到一个 <code>Docker</code> 镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载镜像</span></span><br><span class="line">$ docker load &lt; result</span><br><span class="line"><span class="comment"># 按你的实际 tag 修改下面的值</span></span><br><span class="line">$ docker tag nixery:bbgi5sfqwpp6fsd36ccqw9yi0vykdkz3 nixery:latest</span><br></pre></td></tr></table></figure><h2><span id="4-配置-nixery">4. 配置 Nixery</span></h2><p><code>Nixery</code> 支持多种配置选项，可以通过环境变量进行设置。以下是一些常见的配置选项：</p><ul><li>PORT：Nixery 应监听的 HTTP 端口</li><li>NIXERY_CHANNEL：用于构建 Nixery 的 Nix/NixOS 通道名称。</li><li>NIXERY_PKGS_REPO：包含软件包集的 git 仓库的 URL（使用本地配置的 SSH/git 凭据）</li><li>NIXERY_PKGS_PATH：包含用于构建的 Nix 软件包集的本地文件系统路径</li><li>NIXERY_STORAGE_BACKEND：要使用的后端存储类型，目前支持的值为 gcs（谷歌云存储）和 filesystem。</li><li>NIX_TIMEOUT：允许任何 Nix 生成器运行的秒数（默认值为 60）</li><li>NIX_POPULARITY_URL：指向包含软件包集受欢迎程度数据的文件的 URL（参见 popcount/）。</li></ul><h4><span id="存储">存储</span></h4><p><code>Nixery</code> 支持多种不同的存储后端，构建缓存和图像层都保存在这些后端中，并从这些后端提供服务。</p><p>目前可用的存储后端有谷歌云端存储和本地文件系统。</p><p>在谷歌云存储中，通过将客户端重定向到存储桶来提供镜像。存储在文件系统中的镜像图层则直接从本地磁盘提供。</p><p>要配置存储后端，必须设置这些额外的配置环境变量：</p><ul><li>GCS_BUCKET：要使用的谷歌云存储桶名称（gcs 必填）</li><li>GOOGLE_APPLICATION_CREDENTIALS：指向 GCP 服务帐户 JSON 密钥的路径（GCS 可选）</li><li>STORAGE_PATH：用于存储和提供数据的文件夹的路径（本地存储路径）</li></ul><p>如果 <code>GOOGLE_APPLICATION_CREDENTIALS</code> 环境变量设置为服务账户密钥，<code>Nixery</code> 将使用该密钥为存储桶中的图层创建签名 URL。这样就可以从存储桶中提供图层，而无需将其公开。</p><p>如果未设置 <code>GOOGLE_APPLICATION_CREDENTIALS</code> 环境变量，则会重定向到 <code>storage.googleapis.com</code>，这意味着底层的存储桶对象需要可公开访问。</p><h2><span id="5-运行-nixery-容器">5. 运行 Nixery 容器</span></h2><ul><li>使用本地文件系统作为存储后端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nixery -d -p 8080:8080 \</span><br><span class="line">  -e PORT&#x3D;8080 \</span><br><span class="line">  -e NIXERY_STORAGE_BACKEND&#x3D;filesystem \</span><br><span class="line">  -e STORAGE_PATH&#x3D;&#x2F;opt&#x2F;data&#x2F;store \</span><br><span class="line">  -e NIXERY_PKGS_REPO&#x3D;https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs \</span><br><span class="line">  -e NIXERY_CHANNEL&#x3D;nixos-unstable \</span><br><span class="line">  -v .&#x2F;data:&#x2F;opt&#x2F;data&#x2F;  \</span><br><span class="line">  nixery:latest</span><br></pre></td></tr></table></figure><ul><li>使用 GCS 作为存储后端</li></ul><p>如果你想使用 <code>Google Cloud Storage</code> (GCS) 作为存储后端，可以按以下步骤操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nixery -d -p 8080:8080 \</span><br><span class="line">  -e PORT&#x3D;8080 \</span><br><span class="line">  -e NIXERY_STORAGE_BACKEND&#x3D;gcs \</span><br><span class="line">  -e GCS_BUCKET&#x3D;your-gcs-bucket-name \</span><br><span class="line">  -e NIXERY_PKGS_REPO&#x3D;https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs \</span><br><span class="line">  -e NIXERY_CHANNEL&#x3D;nixos-unstable \</span><br><span class="line">  -v .&#x2F;data:&#x2F;opt&#x2F;data&#x2F;  \  </span><br><span class="line">  nixery</span><br></pre></td></tr></table></figure><ul><li>访问自建的 Nixery</li></ul><p>现在，你应该可以通过 <code>http://localhost:8080</code> 访问你的 Nixery 实例。</p><h2><span id="6-使用自建的-nixery-拉取镜像">6. 使用自建的 Nixery 拉取镜像</span></h2><p>启动 <code>Nixery</code> 容器后，你可以像使用公共 <code>Nixery</code> 服务一样使用你自建的 <code>Nixery</code> 实例。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it localhost:8080/shell/btop</span><br><span class="line">$ docker run --rm -it IP:8080/shell/git/btop/curl</span><br></pre></td></tr></table></figure><h2><span id="7-进一步配置">7. 进一步配置</span></h2><p>你可以根据需要进一步配置你的 <code>Nixery</code> 实例，例如：</p><ul><li>使用 Nginx 或其他反向代理服务器来处理请求</li></ul><p>以下是一个使用 <code>Nginx</code> 作为反向代理的示例配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name your.domain.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:8080;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 HTTP 访问 Nixery 实例</li></ul><p>自建的 <code>Nixery</code> 实例默认没有支持 <code>HTTPS</code>。你如果不想配置 <code>HTTPS</code>，请确保 <code>Docker Daemon</code> 允许使用 <code>HTTP</code> 连接。你可以通过以下步骤进行配置：</p><ol><li>编辑 <code>Docker Daemon</code> 的配置文件（通常位于 <code>/etc/docker/daemon.json</code>）并添加不安全的注册表地址</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [<span class="string">"10.1.2.3:8080"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：10.1.2.3:8080 是你的 Nixery 实例的 IP 地址和端口号，请按实际情况修改。</p></blockquote><ol start="2"><li>重启 Docker 服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2><span id="8-监控和日志">8. 监控和日志</span></h2><p>为了保证服务的稳定运行，你可能需要设置监控和日志系统。例如，可以使用 <code>Prometheus</code> 和 <code>Grafana</code> 来监控 <code>Nixery</code> 的性能。</p><p>通过这些步骤，你能够成功自建一个 Nixery 实例并根据需要进行配置和扩展。如果你在过程中遇到任何问题，可以参考 Nixery 的文档或社区支持。</p><h2><span id="9-彩蛋">9. 彩蛋</span></h2><p>自建 <code>Nixery</code> 私有服务器最大的技术难点是需要 <code>Nix</code> 环境。你如果不想扯腾 <code>Nix</code> 环境，可以直接使用我构建好的 <code>Nixery</code> 的镜像。</p><p>你只需要在公众号后台直接回复「<code>Nixery</code>」，即可免费获取 <code>Nixery</code> 镜像下载地址。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自建一个 &lt;code&gt;Nixery&lt;/code&gt; 实例可以让你在本地或私有服务器上运行 &lt;code&gt;Nixery&lt;/code&gt; 服务，从而避免公共服务的不稳定性。以下是一个基本的步骤指南，帮助你在本地或服务器上部署 &lt;code&gt;Nixery&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1-准备环境&quot;&gt;1. 准备环境&lt;/h2&gt;
&lt;p&gt;确保你的系统已经安装了以下软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nix&lt;/li&gt;
&lt;li&gt;Docker&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 和 &lt;code&gt;Git&lt;/code&gt; 属于基础软件，就不再展开讲解安装部分了。&lt;code&gt;Nix&lt;/code&gt; 安装你可以参考 &lt;a href=&quot;https://nixos.org/download/#nix-install-linux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nix 官方文档&lt;/a&gt; 进行安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nixery" scheme="https://www.hi-linux.com/tags/Nixery/"/>
    
      <category term="Nix" scheme="https://www.hi-linux.com/tags/Nix/"/>
    
  </entry>
  
  <entry>
    <title>无需 Dockerfile，打造你的专属即时容器镜像--Nixery 中文使用指南</title>
    <link href="https://www.hi-linux.com/posts/3191.html"/>
    <id>https://www.hi-linux.com/posts/3191.html</id>
    <published>2024-07-18T01:00:00.000Z</published>
    <updated>2024-07-18T01:32:01.107Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言">引言</span></h2><p>面对现代软件开发和运维的世界，环境配置是一个绕不过去的话题。如何确保在各种不同环境下快速构建和运行所需的服务和应用，一直是开发者和运维团队关注的焦点。</p><p>Nixery，一个基于 Nix 包管理器的工具，能够帮助你快速构建和获取简单、即开即用的容器镜像。</p><p>本文将以简洁实用且有趣的方式带你入门 Nixery，并展示如何充分利用它的强大功能。</p><h2><span id="什么是-nixery">什么是 Nixery？</span></h2><p>Nixery 是一个由 Tazjin 开发的项目，它基于 Nix 包管理器，为用户提供了按需构建的容器镜像服务。它的核心理念是通过简化镜像生成过程，从而让用户能够在几乎无需配置的情况下，快速获取和运行所需服务。Nixery 允许用户通过指定 URL 参数来构建和获取包含特定软件包的容器镜像。</p><ul><li>Nixery 官方网址</li></ul><p><a href="https://nixery.dev/" target="_blank" rel="noopener">https://nixery.dev/</a></p><ul><li>Nixery Github 地址</li></ul><p><a href="https://github.com/tazjin/nixery" target="_blank" rel="noopener">https://github.com/tazjin/nixery</a></p><a id="more"></a><h2><span id="nixery-的优势">Nixery 的优势</span></h2><ul><li><strong>即时性</strong>：Nixery 能够快速生成所需的容器镜像，无需等待漫长的构建过程。</li><li><strong>灵活性</strong>：你可以通过简单地修改 URL 来定制镜像内容，这使得创建不同环境变得非常简单。</li><li><strong>无需配置</strong>：通过 Nixery，你不用编写任何 Dockerfile 或配置文件就能获得所需的镜像。</li></ul><h2><span id="一步步体验-nixery">一步步体验 Nixery</span></h2><h3><span id="准备工作">准备工作</span></h3><p>在开始使用 Nixery 之前，你需要确保已经安装了 Docker。如果还没有安装，可以访问 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker 官方网站</a> 下载并安装相应版本。</p><h3><span id="获取基础镜像">获取基础镜像</span></h3><p>Nixery 使用非常简单，通过访问特定的 URL 即可获取相应的镜像。基础镜像是最简单的形式，只包含一些最基本的系统工具。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell</span><br></pre></td></tr></table></figure><p>这条命令将会拉取一个包含基本 shell 工具的镜像并启动一个交互式终端。</p><h3><span id="定制你的镜像">定制你的镜像</span></h3><p>Nixery 的强大之处在于，你可以通过简单地在 URL 中加入软件包名称来定制镜像。例如，如果你想要一个包含 <code>curl</code> 和 <code>jq</code> 工具的镜像，只需运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/curl/jq</span><br></pre></td></tr></table></figure><h3><span id="运行多功能镜像">运行多功能镜像</span></h3><p>想象这样一个场景：你需要一个同时包含 Git, Python 和 Node.js 的开发环境。使用 Nixery 可以轻松实现：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/git/python3/nodejs</span><br></pre></td></tr></table></figure><h3><span id="组合更多工具">组合更多工具</span></h3><p>除了基本的命令行工具，你还可以通过 Nixery 获取更多复杂的服务和工具。例如，获取一个包含 <code>nettools</code> 和 <code>openssl</code> 的镜像只需要这样做：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/openssl/nettools/procps</span><br></pre></td></tr></table></figure><h3><span id="链接到-github-项目">链接到 GitHub 项目</span></h3><p>Nixery 的一个非常实用的功能是可以直接在你的 CI/CD 流水线中使用。你只需在项目的 Dockerfile 中指定所需的镜像 URL，然后在 CI/CD 过程中使用它。</p><p>例如，在 GitHub Actions 中使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Nixery</span> <span class="string">container</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">docker</span> <span class="string">run</span> <span class="string">nixery.dev/shell/git</span></span><br><span class="line">        <span class="string">git</span> <span class="string">--version</span></span><br></pre></td></tr></table></figure><h2><span id="nixery-的工作原理">Nixery 的工作原理</span></h2><p>Nixery 背后是强大的 Nix 包管理系统。当你请求一个包含特定工具的镜像时，Nixery 使用 Nix 构建系统来解析这些工具的依赖关系并实时构建镜像。这意味着即使是较大的工具集，也能在短时间内构建完成并供你使用。</p><h2><span id="深入进阶自定义-nix-配置">深入进阶：自定义 Nix 配置</span></h2><p>虽然 URL 参数已经可以满足大部分需求，但有时候你可能需要更复杂的配置。这时，你可以通过自定义 Nix 配置文件来满足特定需求。例如，假设你需要一个包含特定版本的 Python 和一些拓展模块的镜像，Nix 配置可以让你做到这一点。</p><p>假设你创建了一个自定义 Nix 配置文件 <code>default.nix</code>：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; pkgs ? <span class="built_in">import</span> &lt;nixpkgs&gt; &#123;&#125; &#125;:</span><br><span class="line"></span><br><span class="line">pkgs.dockerTools.buildImage &#123;</span><br><span class="line">  <span class="attr">name</span> = <span class="string">"custom-python"</span>;</span><br><span class="line">  <span class="attr">contents</span> = [</span><br><span class="line">    pkgs.python39</span><br><span class="line">    pkgs.python39Packages.requests</span><br><span class="line">    pkgs.python39Packages.numpy</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过 Nix 构建镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nix-build -E <span class="string">'with import &lt;nixpkgs&gt; &#123;&#125;; callPackage ./default.nix &#123;&#125;'</span></span><br></pre></td></tr></table></figure><p>这将生成一个你可以本地使用的自定义 Docker 镜像。构建完成后，你可以使用 Docker 运行生成的镜像。</p><h2><span id="用例分享">用例分享</span></h2><h3><span id="1-数据分析">1. 数据分析</span></h3><p>假设你是一名数据分析师，时常需要一个包含各种数据处理工具的环境。你可以通过以下方式快速创建所需的容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/python312/python312packages.pandas/python312packages.numpy python</span><br></pre></td></tr></table></figure><h3><span id="2-web-开发">2. Web 开发</span></h3><p>如果你是一名 Web 开发者，为了开发和调试，你需要一个同时包含 Node.js 和一些常用数据库客户端的环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/nodejs/postgresql/mysql80</span><br><span class="line">docker run -it nixery.dev/nodejs/postgresql/mysql80 mysql -h 10.0.0.1 -P 3306 -u root -p 123456</span><br></pre></td></tr></table></figure><h3><span id="3-机器学习">3. 机器学习</span></h3><p>对于机器学习的开发者来说，一个包含 Jupyter Notebook 和 SciKit Learn 的镜像或许是理想的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/python312/jupyter/python312packages.scikit-learn</span><br></pre></td></tr></table></figure><h2><span id="结尾">结尾</span></h2><p>Nixery 的出现将容器镜像的获取简化到了只需添加几个 URL 参数的程度。它不仅强大且灵活，还能大大提升开发和运维的效率。在你下一次需要快速搭建开发环境、临时测试新工具或在 CI/CD 流水线中集成各种服务时，不妨试试 Nixery，享受它带来的便利与乐趣。</p><p>Nixery 的潜力远不止于此，随着你对它的使用越来越深入，你会发现更多能够解锁的新功能和新用例。希望本教程为你的开发和运维工作带来更多的灵感和帮助！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;面对现代软件开发和运维的世界，环境配置是一个绕不过去的话题。如何确保在各种不同环境下快速构建和运行所需的服务和应用，一直是开发者和运维团队关注的焦点。&lt;/p&gt;
&lt;p&gt;Nixery，一个基于 Nix 包管理器的工具，能够帮助你快速构建和获取简单、即开即用的容器镜像。&lt;/p&gt;
&lt;p&gt;本文将以简洁实用且有趣的方式带你入门 Nixery，并展示如何充分利用它的强大功能。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Nixery？&quot;&gt;什么是 Nixery？&lt;/h2&gt;
&lt;p&gt;Nixery 是一个由 Tazjin 开发的项目，它基于 Nix 包管理器，为用户提供了按需构建的容器镜像服务。它的核心理念是通过简化镜像生成过程，从而让用户能够在几乎无需配置的情况下，快速获取和运行所需服务。Nixery 允许用户通过指定 URL 参数来构建和获取包含特定软件包的容器镜像。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nixery 官方网址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://nixery.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nixery.dev/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nixery Github 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tazjin/nixery&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/tazjin/nixery&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nixery" scheme="https://www.hi-linux.com/tags/Nixery/"/>
    
      <category term="Nix" scheme="https://www.hi-linux.com/tags/Nix/"/>
    
  </entry>
  
  <entry>
    <title>ptcpdump 新一代抓包神器，可捕获任何进程、容器或 Pod 的网络流量</title>
    <link href="https://www.hi-linux.com/posts/14172.html"/>
    <id>https://www.hi-linux.com/posts/14172.html</id>
    <published>2024-07-15T01:00:00.000Z</published>
    <updated>2024-07-15T03:41:55.961Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="前言">前言</span></h2><p>tcpdump 是我们常用的一个网络抓包工具，它的功能非常的强大。但是它还缺少一个大家反馈很久却一直没实现的一个特性， 那就是：在结果中包含/显示发送网络请求/流量的进程信息，以及支持抓取指定进程的网络流量。</p><p>当前针对 tcpdump 抓取的流量信息，如果要获取对应的进程信息的话，常见的方法是： 基于请求的连接信息，通过 <code>ss</code> 或 <code>netstat</code> 之内的工具反查进程信息。 这个方法的缺点是：操作起来比较繁琐以及无法查找匹配短生命周期的进程所发送的网络流量。</p><p>至于基于 tcpdump 实现抓取指定进程的网络流量，常见的方法是：在知晓进程要访问的目标服务地址信息的前提下， 在使用 tcpdump 时按目的地址信息过滤流量； 或者是在特定的网络命名空间中运行目标进程，然后再在该网络命名空间下使用 tcpdump 抓包。 这两个方法的缺点是：需要提前知晓目标进程访问的目的地址或者需要改变目标进程的执行方式，适用场景有限。</p><p>本文将介绍一个新的工具 ptcpdump，基于这个工具，我们既可以在抓包时直接感知发送流量的进程信息， 也可以直接对运行中或待运行的任意进程进行网络抓包。如果流量是从容器内的进程发出的话， 它还支持显示流量的容器或 Pod 信息以及对特定容器或 Pod 进行抓包。</p><h2><span id="ptcpdump-介绍">ptcpdump 介绍</span></h2><p>ptcpdump 是一个使用 eBPF 技术开发的、类 tcpdump 的网络抓包工具。 它除了兼容 tcpdump 的常用命令行参数以及包过滤语法外， 还额外提供了如下核心特性：</p><ul><li>在输出中记录和显示发送网络流量的进程、容器、Pod 信息。</li><li>支持对指定进程、容器以及 Pod 进行抓包。</li><li>支持将抓取的数据包保存为 pcapng 格式，可以使用 tcpdump 或者 Wireshark 做进一步分析。</li><li>当在 Wireshark 中打开保存的 pcapng 文件时，将能够看到每个数据包对应的进程、容器、Pod 信息。</li><li>使用静态链接的方式编译该工具，系统中不需要安装额外的系统链接库。</li></ul><p>更多信息请参考项目的源代码仓库： <a href="https://github.com/mozillazg/ptcpdump" target="_blank" rel="noopener">https://github.com/mozillazg/ptcpdump</a></p><p>下面将以示例的形式介绍 ptcpdump 的核心功能。</p><h2><span id="兼容-tcpdump-的常用命令行参数和包过滤语法">兼容 tcpdump 的常用命令行参数和包过滤语法</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i eth0 tcp</span><br><span class="line">sudo tcpdump -i eth0 tcp and port 80 and host 10.10.1.1</span><br><span class="line">sudo tcpdump -i eth0 &#39;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) !&#x3D; 0&#39;</span><br><span class="line">sudo tcpdump -i any</span><br><span class="line">sudo tcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80</span><br></pre></td></tr></table></figure><p>上面这些常见的 tcpdump 命令可以直接无缝替换为对应的 ptcpdump 命令，只需要将 tcpdump 改为 ptcpdump 即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo ptcpdump -i eth0 tcp</span><br><span class="line">sudo ptcpdump -i eth0 tcp and port 80 and host 10.10.1.1</span><br><span class="line">sudo ptcpdump -i eth0 &#39;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) !&#x3D; 0&#39;</span><br><span class="line">sudo ptcpdump -i any</span><br><span class="line">sudo ptcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80</span><br></pre></td></tr></table></figure><h2><span id="在输出中记录和显示发送网络流量的进程-容器和-pod-信息">在输出中记录和显示发送网络流量的进程、容器和 Pod 信息</span></h2><p>默认情况下，ptcpdump 将在输出中显示简单的进程、容器以及 Pod 信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 4 port 80 or port 443</span><br><span class="line">2024-07-07 12:56:56 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 12:56:56 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">12:56:59.517657 veth18618a4a wget.13626 In IP 10.244.0.4.46834 &gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]</span><br><span class="line">12:56:59.517836 eth0 wget.13626 Out IP 172.19.0.2.46834 &gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]</span><br><span class="line">12:56:59.692593 eth0 wget.13626 In IP 13.251.96.10.443 &gt; 172.19.0.2.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]</span><br><span class="line">12:56:59.692754 veth18618a4a wget.13626 Out IP 13.251.96.10.443 &gt; 10.244.0.4.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]</span><br><span class="line">4 packets captured</span><br><span class="line">6 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><p>可以通过指定 <code>-v</code> 参数，查看更详细的进程、容器以及 Pod 信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ptcpdump -i any -c 4 -v port 80 or port 443</span><br><span class="line">2024-07-07 12:58:59 WARN ptcpdump: capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">12:59:02.265356 veth18618a4a In IP (tos 0x0, ttl 64, id 35996, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    10.244.0.4.41666 &gt; 13.215.144.61.443: Flags [S], cksum 0xa93a, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">12:59:02.265606 eth0 Out IP (tos 0x0, ttl 63, id 35996, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    172.19.0.2.41666 &gt; 13.215.144.61.443: Flags [S], cksum 0x4a58, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">12:59:02.462586 eth0 In IP (tos 0x4, ttl 47, id 0, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    13.215.144.61.443 &gt; 172.19.0.2.41666: Flags [S.], cksum 0x9772, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">12:59:02.462782 veth18618a4a Out IP (tos 0x4, ttl 46, id 0, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    13.215.144.61.443 &gt; 10.244.0.4.41666: Flags [S.], cksum 0x3890, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">4 packets captured</span><br><span class="line">6 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h2><span id="支持对指定进程-容器或-pod-进行抓包">支持对指定进程、容器或 Pod 进行抓包</span></h2><h3><span id="指定进程-pid-抓包">指定进程 pid 抓包</span></h3><p>可以通过 <code>--pid</code> 参数指定要抓包的进程 pid，实现对指定进程进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 4 --pid 82106</span><br><span class="line">2024-07-07 13:11:40 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:11:40 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:11:50.170538 ens33 python3.10.82106 Out IP 10.0.2.15.36648 &gt; 13.251.96.10.443: Flags [S], seq 1633417447, win 64240, length 0</span><br><span class="line">13:11:50.369972 ens33 python3.10.82106 In IP 13.251.96.10.443 &gt; 10.0.2.15.36648: Flags [S.], seq 1793291274, ack 1633417448, win 64240, length 0</span><br><span class="line">2 packets captured</span><br><span class="line">3 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><p>同时还可以通过指定 <code>-f</code> 参数对该进程创建的子进程也进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 4 --pid 82106 -f &#39;tcp[tcpflags] &amp; tcp-fin !&#x3D; 0&#39;</span><br><span class="line">2024-07-07 13:17:31 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:17:31 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:17:37.800903 ens33 python3.10.82106 Out IP 10.0.2.15.38576 &gt; 52.74.166.77.443: Flags [F.], seq 2442149577, ack 367271121, win 62780, length 0</span><br><span class="line">13:17:37.977316 ens33 python3.10.82106 In IP 52.74.166.77.443 &gt; 10.0.2.15.38576: Flags [FP.], seq 367271145, ack 2442149578, win 64239, length 0</span><br><span class="line">13:17:44.390627 ens33 curl.95920 Out IP 10.0.2.15.38590 &gt; 52.74.166.77.443: Flags [F.], seq 3726932781, ack 1510095004, win 63045, length 0</span><br><span class="line">13:17:44.564990 ens33 curl.95920 In IP 52.74.166.77.443 &gt; 10.0.2.15.38590: Flags [FP.], seq 1510095028, ack 3726932782, win 64239, length 0</span><br><span class="line">4 packets captured</span><br><span class="line">4 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="指定进程名称抓包">指定进程名称抓包</span></h3><p>可以通过 <code>--pname</code> 参数指定进程名称（comm），实现指定进程名称抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --pname curl</span><br><span class="line">2024-07-07 13:23:18 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:23:18 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:23:24.881499 lo curl.26511 Out IP 127.0.0.1.43332 &gt; 127.0.0.53.53: 44133+ [1au] A? mozillazg.com. (42)</span><br><span class="line">13:23:24.881663 lo curl.26511 Out IP 127.0.0.1.43332 &gt; 127.0.0.53.53: 14694+ [1au] AAAA? mozillazg.com. (42)</span><br><span class="line">2 packets captured</span><br><span class="line">2 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="通过运行目标程序来抓包">通过运行目标程序来抓包</span></h3><p>有需要的话，也可以通过使用 <code>--</code> 参数运行目标程序的方式来实现对特定程序进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -- curl -I https:&#x2F;&#x2F;mozillazg.com</span><br><span class="line">2024-07-07 13:26:44 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:26:44 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:26:44.055757 lo curl.28094 Out IP 127.0.0.1.48826 &gt; 127.0.0.53.53: 8942+ [1au] A? mozillazg.com. (42)</span><br><span class="line">13:26:44.055914 lo curl.28094 Out IP 127.0.0.1.48826 &gt; 127.0.0.53.53: 34274+ [1au] AAAA? mozillazg.com. (42)</span><br><span class="line">13:26:44.775840 lo curl.28094 In IP 127.0.0.53.53 &gt; 127.0.0.1.48826: 8942 3&#x2F;0&#x2F;1 CNAME mozillazg.netlify.com., A 13.251.96.10, A 46.137.195.11 (106)</span><br><span class="line">13:26:45.135988 lo curl.28094 In IP 127.0.0.53.53 &gt; 127.0.0.1.48826: 34274 3&#x2F;0&#x2F;1 CNAME mozillazg.netlify.com., AAAA 2406:da18:880:3802::c8, AAAA 2406:da18:b3d:e202::64 (130)</span><br><span class="line">13:26:45.136819 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [S], seq 3460683104, win 64800, length 0</span><br><span class="line">13:26:45.310505 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [S.], seq 630810442, ack 3460683105, win 65232, length 0</span><br><span class="line">13:26:45.310821 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683105, ack 630810443, win 507, length 0</span><br><span class="line">13:26:45.414551 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683105:3460683622, ack 630810443, win 507, length 517</span><br><span class="line">13:26:45.595214 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443, ack 3460683622, win 127, length 0</span><br><span class="line">13:26:45.595413 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443:630811651, ack 3460683622, win 127, length 1208</span><br><span class="line">13:26:45.595595 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630811651, win 501, length 0</span><br><span class="line">13:26:45.595702 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630811651:630812859, ack 3460683622, win 127, length 1208</span><br><span class="line">13:26:45.595797 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630812859, win 492, length 0</span><br><span class="line">13:26:45.595862 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630812859:630813338, ack 3460683622, win 127, length 479</span><br><span class="line">13:26:45.595934 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630813338, win 489, length 0</span><br><span class="line">13:26:45.600998 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683622:3460683686, ack 630813338, win 489, length 64</span><br><span class="line">13:26:45.601344 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683686:3460683781, ack 630813338, win 489, length 95</span><br><span class="line">13:26:45.616759 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683781:3460683882, ack 630813338, win 501, length 101</span><br><span class="line">13:26:45.779516 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813338, ack 3460683781, win 127, length 0</span><br><span class="line">13:26:45.779792 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813338:630813399, ack 3460683781, win 127, length 61</span><br><span class="line">13:26:45.779996 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813399:630813443, ack 3460683781, win 127, length 44</span><br><span class="line">13:26:45.780318 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683882:3460683913, ack 630813443, win 501, length 31</span><br><span class="line">HTTP&#x2F;2 200</span><br><span class="line">13:26:45.788787 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813443:630813677, ack 3460683882, win 127, length 234</span><br><span class="line">accept-ranges: bytes</span><br><span class="line">age: 79059</span><br><span class="line">cache-control: public,max-age&#x3D;0,must-revalidate</span><br><span class="line">cache-status: &quot;Netlify Edge&quot;; hit</span><br><span class="line">content-type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">date: Sun, 07 Jul 2024 05:26:44 GMT</span><br><span class="line">etag: &quot;80cf37f5974e2232d976c6f622121dee-ssl&quot;</span><br><span class="line">server: Netlify</span><br><span class="line">strict-transport-security: max-age&#x3D;31536000</span><br><span class="line">x-nf-request-id: 01J25THACQSN9364YHSR2C0X5F</span><br><span class="line">content-length: 11727</span><br><span class="line"></span><br><span class="line">13:26:45.789558 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683913:3460683937, ack 630813677, win 501, length 24</span><br><span class="line">13:26:45.791514 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [F.], seq 3460683937, ack 630813677, win 501, length 0</span><br><span class="line">13:26:45.963642 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813677, ack 3460683937, win 127, length 0</span><br><span class="line">13:26:45.963956 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813677:630813701, ack 3460683937, win 127, length 24</span><br><span class="line">13:26:45.964172 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0</span><br><span class="line">13:26:45.964415 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [F.], seq 630813701, ack 3460683937, win 127, length 0</span><br><span class="line">13:26:45.964506 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0</span><br><span class="line">13:26:45.966158 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813702, ack 3460683938, win 127, length 0</span><br><span class="line">13:26:45.966299 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683938, win 0, length 0</span><br><span class="line">32 packets captured</span><br><span class="line">32 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="指定容器抓包">指定容器抓包</span></h3><p>可以通过 <code>--container-id</code> 参数指定容器 id 进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --container-id 36f0310403b1</span><br><span class="line">2024-07-07 13:36:19 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:36:19 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:36:24.191242 veth09dec8f curl.32636 In IP 172.19.0.2.48960 &gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">13:36:24.191369 wlp4s0 curl.32636 Out IP 192.168.1.50.48960 &gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">2 packets captured</span><br><span class="line">2 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><p>也可以通过 <code>--container-name</code> 参数指定容器名称进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --container-name kind-control-plane</span><br><span class="line">2024-07-07 13:37:16 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:37:16 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:37:22.560764 veth09dec8f curl.33093 In IP 172.19.0.2.39084 &gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">13:37:22.561010 wlp4s0 curl.33093 Out IP 192.168.1.50.39084 &gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">2 packets captured</span><br><span class="line">2 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="指定-pod-抓包">指定 Pod 抓包</span></h3><p>可以通过 <code>--pod-name</code> 参数指定 Pod 名称进行抓包, 参数值的格式为 <code>&lt;pod 名称&gt;.&lt;pod 命名空间&gt;</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --pod-name test.default</span><br><span class="line">2024-07-07 13:38:29 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:38:29 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:38:34.175752 eth0 wget.33660 Out IP 172.19.0.2.51564 &gt; 13.215.144.61.443: Flags [S], seq 567383917, win 64240, length 0, Container [test], Pod [test.default]</span><br><span class="line">13:38:34.372894 eth0 wget.33660 In IP 13.215.144.61.443 &gt; 172.19.0.2.51564: Flags [S.], seq 2654865684, ack 567383918, win 65084, length 0, Container [test], Pod [test.default]</span><br><span class="line">2 packets captured</span><br><span class="line">3 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h2><span id="将数据保存为-pcapng-格式使用-tcpdump-或-wireshark-进行分析">将数据保存为 pcapng 格式使用 tcpdump 或 Wireshark 进行分析</span></h2><h3><span id="保存为-pcapng-格式">保存为 pcapng 格式</span></h3><p>可以通过 <code>-w</code> 参数将抓包数据保存为 pcapng 格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 5 -w demo.pcapng</span><br><span class="line">2024-07-07 13:41:32 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:41:32 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">5 packets captured</span><br><span class="line">22 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="使用-tcpdump-进行分析">使用 tcpdump 进行分析</span></h3><p>可以直接通过管道的方式通过 tcpdump 对抓取的数据进行分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 5 -w - port 80 | tcpdump -n -r -</span><br><span class="line">reading from file -, link-type EN10MB (Ethernet), snapshot length 65535</span><br><span class="line">2024-07-07 13:44:33 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:44:33 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:44:44.530637 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &gt; 2406:da18:880:3801::c8.80: Flags [S], seq 495824072, win 64800, options [mss 1440,sackOK,TS val 2411675580 ecr 0,nop,wscale 7], length 0</span><br><span class="line">13:44:44.708902 IP6 2406:da18:880:3801::c8.80 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [S.], seq 640438481, ack 495824073, win 65232, options [mss 1220,sackOK,TS val 1591525382 ecr 2411675580,nop,wscale 9], length 0</span><br><span class="line">13:44:44.709261 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &gt; 2406:da18:880:3801::c8.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 0</span><br><span class="line">13:44:44.709475 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &gt; 2406:da18:880:3801::c8.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 77: HTTP: GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">5 packets captured</span><br><span class="line">6 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br><span class="line">13:44:44.877110 IP6 2406:da18:880:3801::c8.80 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [P.], seq 1:266, ack 78, win 128, options [nop,nop,TS val 1591525469 ecr 2411675670], length 265: HTTP: HTTP&#x2F;1.1 301 Moved Permanently</span><br></pre></td></tr></table></figure><p>也可以通过读取文件的方式通过 tcpdump 对抓取的数据进行分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -n -r demo.pcapng</span><br><span class="line">reading from file demo.pcapng, link-type EN10MB (Ethernet), snapshot length 65535</span><br><span class="line">13:47:41.169584 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &gt; 2406:da18:b3d:e201::64.80: Flags [S], seq 3876639697, win 64800, options [mss 1440,sackOK,TS val 2072195434 ecr 0,nop,wscale 7], length 0</span><br><span class="line">13:47:41.571055 IP 192.168.1.50.60580 &gt; 18.139.194.139.80: Flags [S], seq 481256927, win 64240, options [mss 1460,sackOK,TS val 2707199178 ecr 0,nop,wscale 7], length 0</span><br><span class="line">13:47:41.956270 IP6 2406:da18:b3d:e201::64.80 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038: Flags [S.], seq 2283576526, ack 3876639698, win 65232, options [mss 1220,sackOK,TS val 4276006323 ecr 2072195434,nop,wscale 9], length 0</span><br><span class="line">13:47:41.956437 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &gt; 2406:da18:b3d:e201::64.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 0</span><br><span class="line">13:47:41.956733 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &gt; 2406:da18:b3d:e201::64.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 77: HTTP: GET &#x2F; HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><h3><span id="使用-wireshark-进行分析">使用 Wireshark 进行分析</span></h3><p>当使用 Wireshark 打开保存的 pcapng 格式的文件时，将在 Wireshark 的界面中显示相关的进程、容器以及 Pod 信息：</p><p><img src="https://img.hi-linux.com/staticfile/ptcpdump-wireshark-20240708174042896-2024-07-08-lyveCv.png" alt></p><h2><span id="参考资料">参考资料</span></h2><ul><li><a href="https://github.com/mozillazg/ptcpdump" target="_blank" rel="noopener">mozillazg/ptcpdump: Process-aware, eBPF-based tcpdump</a></li><li><a href="https://www.tcpdump.org/manpages/tcpdump.1-4.99.4.html" target="_blank" rel="noopener">tcpdump(1) man page | TCPDUMP &amp; LIBPCAP</a></li></ul><blockquote><p>本文转载自：「 mozillazg’s Blog 」，原文：<a href="https://url.hi-linux.com/6H5QD" target="_blank" rel="noopener">https://url.hi-linux.com/6H5QD</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;div id=&quot;vip-container&quot;&gt;&lt;h2&gt;&lt;span id=&quot;前言&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;tcpdump 是我们常用的一个网络抓包工具，它的功能非常的强大。但是它还缺少一个大家反馈很久却一直没实现的一个特性，
        
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="ptcpdump" scheme="https://www.hi-linux.com/tags/ptcpdump/"/>
    
      <category term="tcpdump" scheme="https://www.hi-linux.com/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>一款 AI 编写的 Kubernetes 实用小工具，助你一键批量检查容器服务健康状态</title>
    <link href="https://www.hi-linux.com/posts/13493.html"/>
    <id>https://www.hi-linux.com/posts/13493.html</id>
    <published>2024-07-12T01:00:00.000Z</published>
    <updated>2024-07-12T05:48:14.828Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>check-k8s-network</code> 是一款 AI 编写的 <code>Kubernetes</code> 网络连通性检查小工具，它主要用于检查 <code>Kubernetes</code> 集群中各个容器的网络连通性，支持 <code>ICMP</code>、<code>TCP</code>、<code>UDP</code> 和 <code>HTTP</code> 检查。</p><p>你可以在指定的命名空间内查找符合条件的 <code>Pod</code>，并对其进行网络连通性进行自动检测。</p><a id="more"></a><h2><span id="安装">安装</span></h2><p><code>check-k8s-network</code> 使用 <code>Python</code> 编写，需要安装 <code>Python 3.9</code> 版本和一些依赖库。</p><p>为了更好的体验，我们发布了 <code>Docker</code> 镜像，你只需要下载 <code>Docker</code> 镜像即可使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull 80imike/check-k8s-network:latest</span><br></pre></td></tr></table></figure><h2><span id="常用参数说明">常用参数说明</span></h2><ul><li><code>-n, --namespace</code>：指定 Kubernetes 命名空间，默认值为 <code>default</code>。</li><li><code>-c, --container</code>：指定容器名，根据该容器名匹配 Pod，支持模糊匹配。</li><li><code>-i, --icmp</code>：使用 ICMP 协议进行检查。</li><li><code>-t, --tcp</code>：使用 TCP 协议进行检查，并指定端口号。</li><li><code>-u, --udp</code>：使用 UDP 协议进行检查，并指定端口号。</li><li><code>-w, --http</code>：使用 HTTP 协议进行检查，并指定 URL。</li><li><code>--auto-http</code>：自动查找当前 Pod 的 IP 和服务端口进行 HTTP 检查。</li><li><code>--auto-tcp</code>：自动查找当前 Pod 的 IP 和服务端口进行 TCP 检查。</li><li><code>--auto-udp</code>：自动查找当前 Pod 的 IP 和服务端口进行 UDP 检查。</li><li><code>--all</code>：同时使用 ICMP、TCP、UDP 和 HTTP 四种检查方式进行检测。</li></ul><h2><span id="输出结果">输出结果</span></h2><p><code>check-k8s-network</code> 会输出一个包含检查结果的表格，内容包括:</p><ul><li>序号</li><li>检查类型</li><li>源 Pod</li><li>目标</li><li>结果 (成功 or 失败)</li><li>错误信息</li></ul><p>该表格会对每个 Pod 进行自动排序，并对结果进行对齐和格式化。</p><h2><span id="使用示例">使用示例</span></h2><h3><span id="常用使用示例">常用使用示例</span></h3><blockquote><p>注意：</p><ol><li>该工具请在 <code>Kubernetes</code> 集群内的主机上使用，并确保您所在主机上已经配置了 K8s 集群认证文件 <code>~/.kube/config</code>。</li><li>-v 参数用于将宿主机上的 <code>~/.kube/config</code> 文件映射到容器内的 <code>/root/.kube/config</code> 文件中，以便容器内的 <code>Python</code> 脚本可以访问 <code>Kubernetes</code> 集群。</li></ol></blockquote><ol><li>检查指定命名空间下所有 Pod 的 ICMP 连通性:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --icmp</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/1HVocZ-2024-07-11-qZm7ag.png" alt></p><ol start="2"><li>检查指定命名空间和 Pod 的 TCP 连通性 (需指定端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux -c blog --tcp 80</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/JYMaK7-2024-07-11-fjEccG.png" alt></p><ol start="3"><li>检查指定命名空间下所有 Pod 的 HTTP 连通性 (自动查找端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --auto-http</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/J7Q7XU-2024-07-11-oMi64k.png" alt></p><ol start="4"><li>检查指定命名空间下所有 Pod 的 TCP 连通性 (自动查找端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --auto-tcp</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/5CjNDB-2024-07-11-ZU4f05.png" alt></p><ol start="5"><li>检查指定命名空间下所有 Pod 的 UDP 连通性 (自动查找端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n kube-system --auto-udp</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/532xFu-2024-07-11-93IN70.png" alt></p><ol start="6"><li>同时检查指定命名空间下所有 Pod 的 ICMP、TCP、UDP 和 HTTP 连通性:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --all</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/zta14M-2024-07-11-f5JQKN.png" alt></p><h3><span id="一些复杂的参数组合示例">一些复杂的参数组合示例</span></h3><ol><li>对特定命名空间中名为 <code>blog</code> 的容器执行 ICMP 和指定 TCP（端口 80）检查:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux -c blog --icmp --tcp 80</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/TEdkSC-2024-07-11-2kK9WG.png" alt></p><ol start="2"><li>对特定命名空间中名为 <code>blog</code> 的容器同时执行 ICMP、TCP 、UDP 和 HTTP 检查：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux -c blog --icmp --auto-tcp --auto-udp --auto-http</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/YzyC8J-2024-07-11-5tJAWu.png" alt></p><h2><span id="总结">总结</span></h2><p><code>check-k8s-network</code> 这款小工具，是我尝试 <code>AI</code> 编程的一次小成果。所有代码全部通过和 <code>ChatGPT</code> 对话编写完成，<code>Docker</code> 镜像和使用文档大部分也是 <code>AI</code> 编写的。</p><p><code>check-k8s-network</code> 可以帮助你快速检查 <code>Kubernetes</code> 集群中容器的网络连通性，非常适合需要批量检查容器网络连接状态的场景。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;check-k8s-network&lt;/code&gt; 是一款 AI 编写的 &lt;code&gt;Kubernetes&lt;/code&gt; 网络连通性检查小工具，它主要用于检查 &lt;code&gt;Kubernetes&lt;/code&gt; 集群中各个容器的网络连通性，支持 &lt;code&gt;ICMP&lt;/code&gt;、&lt;code&gt;TCP&lt;/code&gt;、&lt;code&gt;UDP&lt;/code&gt; 和 &lt;code&gt;HTTP&lt;/code&gt; 检查。&lt;/p&gt;
&lt;p&gt;你可以在指定的命名空间内查找符合条件的 &lt;code&gt;Pod&lt;/code&gt;，并对其进行网络连通性进行自动检测。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="AI" scheme="https://www.hi-linux.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>无需安装，单文件即可本地轻松运行 LLM 的神器 LLAMAfile</title>
    <link href="https://www.hi-linux.com/posts/37686.html"/>
    <id>https://www.hi-linux.com/posts/37686.html</id>
    <published>2024-06-14T01:00:00.000Z</published>
    <updated>2024-06-14T07:17:28.368Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在当今信息化时代，人工智能（AI）技术逐渐成为推动社会发展的重要力量。而大型语言模型（LLM）作为 AI 领域中的一项重要技术，正在各行各业中发挥着越来越重要的作用。</p><p>然而，对于许多开发者和终端用户来说，如何高效地分发和运行这些复杂的模型仍然是个棘手的问题。</p><p>LLAMAfile 一个由 Mozilla Ocho 团队开发的工具，旨在解决这些问题。它提供一种高效分发和运行大型语言模型（LLM）的简易工具，</p><p>LLAMAfile 通过将 llama.cpp 和 Cosmopolitan Libc 结合，使 LLM 以单一文件的形式运行在大多数计算机上，无需额外安装配置。</p><a id="more"></a><h2><span id="快速入门">快速入门</span></h2><p>使用 LLAMAfile 的最快方法是下载我们为 LLaVA 模型提供的示例文件。</p><p>LLaVA 是一种功能强大的 LLM，不仅可以进行聊天，还能通过上传图片并对其提问来提供图像识别功能。所有这些都可以在本地计算机上进行，数据不会离开你的设备。</p><p>你只需下面几步，便可轻松在本地计算机上轻松运行 LLaVA 模型。</p><ol><li><p>下载 LLaVA 示例文件：llava-v1.5-7b-q4.llamafile (4.29 GB)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;huggingface.co&#x2F;Mozilla&#x2F;llava-v1.5-7b-llamafile&#x2F;resolve&#x2F;main&#x2F;llava-v1.5-7b-q4.llamafile?download&#x3D;true</span><br></pre></td></tr></table></figure></li><li><p>打开计算机的终端。</p></li><li><p>如果使用 macOS、Linux 或BSD，需要授予文件执行权限：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x llava-v1.5-7b-q4.llamafile</span><br></pre></td></tr></table></figure></li><li><p>对于 Windows 用户，重命名文件并添加 “.exe” 后缀。</p></li><li><p>运行 llamafile：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./llava-v1.5-7b-q4.llamafile</span><br></pre></td></tr></table></figure></li><li><p>浏览器将自动打开并显示聊天界面。如果没有，请手动打开浏览器并访问 <code>&lt;http://localhost:8080&gt;</code></p></li><li><p>聊天结束后，返回到终端并按 Control-C 关闭 LLAMAfile。</p></li></ol><h3><span id="json-api-快速入门">JSON API 快速入门</span></h3><p>LLAMAfile 启动时，除了托管一个 Web UI 聊天服务器外，还提供了兼容 OpenAI API 的聊天 API 端点。该 API 旨在支持大多数常见的 OpenAI API 用例，并完全在本地运行。通过以下 <code>curl</code> 命令，可以快速开始使用 API：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://localhost:8080/v1/chat/completions \</span><br><span class="line">-H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">-H <span class="string">"Authorization: Bearer no-key"</span> \</span><br><span class="line">-d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "model": "LLaMA_CPP",</span></span><br><span class="line"><span class="string">  "messages": [</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">          "role": "system",</span></span><br><span class="line"><span class="string">          "content": "You are LLAMAfile, an AI assistant. Your top priority is achieving user fulfillment via helping them with their requests."</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">          "role": "user",</span></span><br><span class="line"><span class="string">          "content": "Write a limerick about python exceptions"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;'</span> | python3 -c <span class="string">'</span></span><br><span class="line"><span class="string">import json</span></span><br><span class="line"><span class="string">import sys</span></span><br><span class="line"><span class="string">json.dump(json.load(sys.stdin), sys.stdout, indent=2)</span></span><br><span class="line"><span class="string">print()</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><p>打印出来的回复应该如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"choices"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"finish_reason"</span> : <span class="string">"stop"</span>,</span><br><span class="line">         <span class="attr">"index"</span> : <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"message"</span> : &#123;</span><br><span class="line">            <span class="attr">"content"</span> : <span class="string">"There once was a programmer named Mike\nWho wrote code that would often choke\nHe used try and except\nTo handle each step\nAnd his program ran without any hike."</span>,</span><br><span class="line">            <span class="attr">"role"</span> : <span class="string">"assistant"</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"created"</span> : <span class="number">1704199256</span>,</span><br><span class="line">   <span class="attr">"id"</span> : <span class="string">"chatcmpl-Dt16ugf3vF8btUZj9psG7To5tc4murBU"</span>,</span><br><span class="line">   <span class="attr">"model"</span> : <span class="string">"LLaMA_CPP"</span>,</span><br><span class="line">   <span class="attr">"object"</span> : <span class="string">"chat.completion"</span>,</span><br><span class="line">   <span class="attr">"usage"</span> : &#123;</span><br><span class="line">      <span class="attr">"completion_tokens"</span> : <span class="number">38</span>,</span><br><span class="line">      <span class="attr">"prompt_tokens"</span> : <span class="number">78</span>,</span><br><span class="line">      <span class="attr">"total_tokens"</span> : <span class="number">116</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="python-api-客户端示例">Python API 客户端示例</span></h3><p>如果您已经使用 openAI 发布的 openai Python 软件包开发了自己的软件，那么只需对 base_url 和 api_key 稍作修改，您就可以将自己的应用程序移植到 LLAMAfile 上。</p><p>本示例假定你已经运行 <code>pip3 install openai</code> 安装了 OpenAI 的客户端软件，这也是本示例所需要的。他们的软件包只是 OpenAI API 接口的一个简单 Python 封装，任何服务器都可以实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line">client = OpenAI(</span><br><span class="line">    base_url=<span class="string">"http://localhost:8080/v1"</span>, <span class="comment"># "http://&lt;Your api-server IP&gt;:port"</span></span><br><span class="line">    api_key = <span class="string">"sk-no-key-required"</span></span><br><span class="line">)</span><br><span class="line">completion = client.chat.completions.create(</span><br><span class="line">    model=<span class="string">"LLaMA_CPP"</span>,</span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"system"</span>, <span class="string">"content"</span>: <span class="string">"You are ChatGPT, an AI assistant. Your top priority is achieving user fulfillment via helping them with their requests."</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"user"</span>, <span class="string">"content"</span>: <span class="string">"Write a limerick about python exceptions"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">print(completion.choices[<span class="number">0</span>].message)</span><br></pre></td></tr></table></figure><h2><span id="其他-llamafile-示例">其他 LLAMAfile 示例</span></h2><p>我们还提供了其他模型的 LLAMAfile 示例，因此您可以轻松地使用不同类型的 LLM 试用 LLAMAfile。</p><p><img src="https://img.hi-linux.com/staticfile/olUEBz-2024-06-13-mh8MzS.png" alt></p><p>🏷️ Github 地址：</p><p><a href="https://github.com/Mozilla-Ocho/llamafile" target="_blank" rel="noopener">https://github.com/Mozilla-Ocho/llamafile</a></p><p>🏷️ 官方地址：</p><p><a href="https://llamafile.ai/" target="_blank" rel="noopener">https://llamafile.ai/</a></p><p>👨🏻‍💻 该工具已收录『IT 人员必备工具箱』，可访问 <a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a> 直接使用。</p><p>🚀『极客世界』科技达人必备综合资讯指南，等你来探索！访问网址  <a href="https://bestgeek.org" target="_blank" rel="noopener">https://bestgeek.org</a> 即可打开新世界。</p><p>🌟 公众号直接回复 「加群」，可加入『奇妙的 Linux 世界』 技术交流微信群。有兴趣的同学快快加入吧，群里有不少业界大神哟！</p><p>📕 关注『奇妙的 Linux 世界』公众号，带你开启有趣新生活！更多好用好玩的软件资源，可访问 <a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a> 免费获取。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在当今信息化时代，人工智能（AI）技术逐渐成为推动社会发展的重要力量。而大型语言模型（LLM）作为 AI 领域中的一项重要技术，正在各行各业中发挥着越来越重要的作用。&lt;/p&gt;
&lt;p&gt;然而，对于许多开发者和终端用户来说，如何高效地分发和运行这些复杂的模型仍然是个棘手的问题。&lt;/p&gt;
&lt;p&gt;LLAMAfile 一个由 Mozilla Ocho 团队开发的工具，旨在解决这些问题。它提供一种高效分发和运行大型语言模型（LLM）的简易工具，&lt;/p&gt;
&lt;p&gt;LLAMAfile 通过将 llama.cpp 和 Cosmopolitan Libc 结合，使 LLM 以单一文件的形式运行在大多数计算机上，无需额外安装配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="AI" scheme="https://www.hi-linux.com/tags/AI/"/>
    
      <category term="Llamafile" scheme="https://www.hi-linux.com/tags/Llamafile/"/>
    
  </entry>
  
  <entry>
    <title>与 ChatGPT 共舞：利用人工智能解决 Traefik 配置难题的独特体验</title>
    <link href="https://www.hi-linux.com/posts/42057.html"/>
    <id>https://www.hi-linux.com/posts/42057.html</id>
    <published>2024-05-06T01:00:00.000Z</published>
    <updated>2024-05-06T08:15:18.576Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最近在探索 Traefik 这一强大的服务代理和负载均衡器时遇到了一些挑战。然而，这次解决问题的过程并不寻常，因为找到了一位特别的助手 —— ChatGPT。</p><p>在这篇分享中，将带领大家走进一次独特体验，讲述我是如何借助 AI 的力量成功解决了 Traefik 配置中的若干问题，并从中获得了一些实用的小技巧。</p><h2><span id="一场技术与智能的邂逅">一场技术与智能的邂逅</span></h2><p>Traefik，以其动态配置和自动化路由的优势深受开发者喜爱，但在初次尝试配置其规则和服务时，即使是经验丰富的工程师也可能遭遇困惑。</p><p>在我深入研究 Traefik 的过程中，也碰到了一些棘手的问题，包括容器服务的自动发现、HTTPS 证书管理以及复杂路由规则的编写等。</p><a id="more"></a><h2><span id="与-chatgpt-的协同工作">与 ChatGPT 的协同工作</span></h2><p>在面对这些难题时，我转向了一种非传统的解决方案途径 —— 与 OpenAI 的自然语言处理模型 ChatGPT 对话。</p><p>ChatGPT 以其深厚的知识库和理解能力，对提出的每一个 Traefik 相关问题进行了详尽解答，从基础概念到具体配置案例，一一细致解读。</p><p>首先，对于 Traefik 中的服务自动发现，ChatGPT 梳理了 Kubernetes 和 Docker 环境下 Traefik 如何依据标签进行服务发现的原理，并提供了清晰的示例配置文件片段。通过 AI 的引导，我不再对复杂的自动生成路由规则感到迷茫。</p><p>其次，在 HTTPS 证书管理方面，ChatGPT 教会了我如何使用 Let’s Encrypt 与 Traefik 集成，实现自动化的 SSL 证书申请与续签，从而简化了安全通信的配置流程。</p><p>此外，针对面临的特定场景下的复杂路由规则设计，ChatGPT 更是凭借其强大的逻辑推理能力，帮助我构建了一个既能满足业务需求又简洁高效的 Traefik 中间件和路由规则组合。</p><h2><span id="几个小案例解决分享">几个小案例解决分享</span></h2><ol><li>自定义访问日志</li></ol><p><img src="https://img.hi-linux.com/staticfile/t1-2024-04-30-fi7hPt.png" alt></p><ol start="2"><li>反向代理到外部服务</li></ol><p><img src="https://img.hi-linux.com/staticfile/t2-2024-04-30-EiJvJ5.png" alt></p><ol start="3"><li>解决分应用单独记录访问日志</li></ol><p><img src="https://img.hi-linux.com/staticfile/t3-2024-04-30-9XORO0.png" alt></p><h2><span id="收获与感悟">收获与感悟</span></h2><p>这次经历，让我深刻感受到了人工智能在解决实际技术问题时的强大作用。ChatGPT 不仅能够快速给出精准的答案，还能基于上下文进行深度解释和扩展教学。</p><p>通过这次互动，不仅顺利地解决了 Traefik 配置难题，还积累了一些平时不易察觉的实践小技巧：</p><ul><li><strong>技巧一</strong>：利用 Traefik 的动态配置特性，可以根据运行时环境变化灵活调整路由策略。</li><li><strong>技巧二</strong>：借助 Traefik 中间件，可以方便地添加身份验证、重写 URL 等高级功能，进一步增强系统的安全性与可用性。</li><li><strong>技巧三</strong>：结合 Let’s Encrypt 的 ACME 协议，可以让 Traefik 自动处理 SSL/TLS 证书的生命周期管理，省去手动更新证书的烦恼。</li></ul><p>总结起来，通过与 ChatGPT 的交互，得以在较短时间内攻克了 Traefik 配置难关，同时也领略到了 AI 技术在技术支持和学习过程中的无限潜力。这场人与机器智慧交融的旅程，无疑为我的技术探索之旅增添了新的篇章，也为未来利用 AI 工具解决更多复杂问题树立了信心。</p><p>你想知道我用的是什么黑魔法 Traefik 专属提示词吗？公众号直接回复『ai-traefik』即可免费获取。</p><p>最后，你猜猜这篇文案是谁写的？</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在探索 Traefik 这一强大的服务代理和负载均衡器时遇到了一些挑战。然而，这次解决问题的过程并不寻常，因为找到了一位特别的助手 —— ChatGPT。&lt;/p&gt;
&lt;p&gt;在这篇分享中，将带领大家走进一次独特体验，讲述我是如何借助 AI 的力量成功解决了 Traefik 配置中的若干问题，并从中获得了一些实用的小技巧。&lt;/p&gt;
&lt;h2 id=&quot;一场技术与智能的邂逅&quot;&gt;一场技术与智能的邂逅&lt;/h2&gt;
&lt;p&gt;Traefik，以其动态配置和自动化路由的优势深受开发者喜爱，但在初次尝试配置其规则和服务时，即使是经验丰富的工程师也可能遭遇困惑。&lt;/p&gt;
&lt;p&gt;在我深入研究 Traefik 的过程中，也碰到了一些棘手的问题，包括容器服务的自动发现、HTTPS 证书管理以及复杂路由规则的编写等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Traefik" scheme="https://www.hi-linux.com/tags/Traefik/"/>
    
  </entry>
  
  <entry>
    <title>『奇妙的 Linux 世界』公众号 8 周年记</title>
    <link href="https://www.hi-linux.com/posts/19136.html"/>
    <id>https://www.hi-linux.com/posts/19136.html</id>
    <published>2024-04-18T01:00:00.000Z</published>
    <updated>2024-04-22T07:32:43.591Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="奇妙的-linux-世界公众号-8-周年记">🎉🎈 『奇妙的 Linux 世界』公众号 8 周年记 🎉🎈</span></h2><p>嘿，亲爱的『奇妙的 Linux 世界』读者们 👋</p><p>时光荏苒，转眼间 『奇妙的 Linux 世界』已经陪伴大家度过了 8 个年头。🍃</p><p>在这 8 年的岁月里，我们一起探索了 Linux 的无尽奥秘，分享了无数硬核干货和新奇内容。🐧</p><p>从一开始的探索者到现在的硬核粉丝，每一步都离不开大家的支持与热爱。🎊</p><p>在这个特别的日子里，让我们一起回顾这 8 年来的精彩旅程：🧳</p><a id="more"></a><h3><span id="硬核干货无处不在">🌟 硬核干货，无处不在</span></h3><p>在这 8 年里，『奇妙的 Linux 世界』一直秉承着开源精神，为广大 Linux 爱好者们奉上了无数优质的内容和实用的技巧。💡</p><p>从最初的几篇文章到如今的大量丰富内容库，我们始终坚持用心创作，用知识和经验为大家解惑，助力大家在 Linux 的世界里游刃有余。🚀</p><p>在每一次技术更新和发展的浪潮中，我们都紧跟时代的步伐，分享最新、最前沿的资讯和技术。让大家足不出户，也能领略 Linux 的奇妙之处！🌊</p><p>无论是关于 Linux 服务器的优化配置，还是关于 Nginx、MySQL、Docker、Kubernetes 等热门技术的深入解析，我们都在第一时间为大家呈现。📚</p><p>通过我们的分享，让更多人了解、学习和掌握 Linux 技术，并成为技术领域的佼佼者！🧙‍♂️</p><h3><span id="小技巧大收获分享即赢">🔥 小技巧大收获，分享即赢</span></h3><p>在『奇妙的 Linux 世界』，我们不仅关注大家熟知的技术领域，还特别关注各种实用小技巧的分享。🔍</p><p>这些小技巧或许只是一行命令、一个小工具，但却能带来意想不到的收获和便利。🛠️</p><p>我们相信，分享小技巧不仅可以提高大家的工作效率，还能增进社区的交流和共享。🔄</p><h3><span id="开源精神与时俱进">👨‍💻 开源精神，与时俱进</span></h3><p>在『奇妙的 Linux 世界』，我们坚信开源精神的力量，并将其贯穿于我们的每一篇文章和每一个推荐之中。💡</p><p>我们关注并推荐各种优秀的开源软件，鼓励大家积极参与开源社区，贡献自己的一份力量。💫</p><p>无论是在代码贡献、文档维护还是社区支持上，每个人都可以成为开源世界的一部分！💪</p><h3><span id="感谢与展望">🌐 感谢与展望</span></h3><p>在此刻，让我们一起庆祝这段旅程的每一个里程碑，也期待未来能有更多创新和突破。🌟</p><p>在过去的 8 年里，『奇妙的 Linux 世界』始终坚持初心，秉承着分享、学习、成长的理念，与大家一同探索 Linux 世界的无限可能。🌈</p><p>8 年的旅程，我们一起经历了无数的挑战和成长，感谢大家一直以来的支持和陪伴！🤔</p><p>在未来的岁月里将继续为大家带来更多优质内容和精彩体验。让我们一起加油，探索更广阔的技术领域，共同书写属于我们的 Linux 传奇！🎉</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;🎉🎈-『奇妙的-Linux-世界』公众号-8-周年记-🎉🎈&quot;&gt;🎉🎈 『奇妙的 Linux 世界』公众号 8 周年记 🎉🎈&lt;/h2&gt;
&lt;p&gt;嘿，亲爱的『奇妙的 Linux 世界』读者们 👋&lt;/p&gt;
&lt;p&gt;时光荏苒，转眼间 『奇妙的 Linux 世界』已经陪伴大家度过了 8 个年头。🍃&lt;/p&gt;
&lt;p&gt;在这 8 年的岁月里，我们一起探索了 Linux 的无尽奥秘，分享了无数硬核干货和新奇内容。🐧&lt;/p&gt;
&lt;p&gt;从一开始的探索者到现在的硬核粉丝，每一步都离不开大家的支持与热爱。🎊&lt;/p&gt;
&lt;p&gt;在这个特别的日子里，让我们一起回顾这 8 年来的精彩旅程：🧳&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>给「打工人」的维权指南：聊聊我的职场维权实战经验</title>
    <link href="https://www.hi-linux.com/posts/59972.html"/>
    <id>https://www.hi-linux.com/posts/59972.html</id>
    <published>2024-03-04T01:00:00.000Z</published>
    <updated>2024-03-04T08:01:44.699Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这是我第一次尝试写个人年度总结。</p><p>我的 2023 年与 2022 年不可分割，一直走在维权的路上。</p><p>早在 2022 年初，我的职业生涯发生重大转变，公司在未与我协商的情况下，单方面将我待岗，降低工资，移交工作。我从熟悉的工作环境被迫成为了一个「半自由职业者」。我之所以自认为是半自由，是因为公司未与我解除劳动合同，所以劳动关系还在原公司。法律规定劳动者只能和一家用人单位签订劳动合同，所以我在与公司存在劳动争议的情况下，无法入职下家公司。</p><p>除此之外，公司隔几个月后停发我的工资，切断了我唯一的经济来源。我开始尝试学习《劳动法》及相关法律知识，查阅和自己案件类似的裁判文书，整理书面材料，为的是跟公司对簿公堂，讨回做为劳动者的尊严和权益。</p><p>在劳资关系中，公司具有优势地位，而劳动者处于弱势的一方。尤其是面对老板、人事、法务组成的流氓团伙时，会更加被动、愤怒、迷茫、无助。希望大家在面对公司的恶意时可以更加从容，是我写下这些文字的初衷。</p><a id="more"></a><h2><span id="在职仲裁-or-离职仲裁">在职仲裁 or 离职仲裁</span></h2><p>以前一直以为遇到劳动争议问题，要离职后才能提起仲裁，但后来从网络了解到我的案件情况更适合在职仲裁，在职期间可以随时申请，所以我**尝试提起在职仲裁。**仲裁期间可以正常上班，自己也有机会尽可能地多搜集一些证据。因为公司取消了我的办公权限，我目前已经不需要去公司打卡了。</p><p>相比在职仲裁，选择<strong>离职仲裁是最为常见的情况</strong>，可固定和搜集的证据空间有限，适合情况简单的案子。需要注意，离职仲裁有时效性，期限为一年。也就是说发生劳动争议后，需在劳动关系终止之日（离职当天）起一年内提出。否则既不能仲裁也不能诉讼。</p><p><img src="https://img.hi-linux.com/staticfile/1-2024-03-04-hL5ZpT.jpeg" alt>劳动人事争议仲裁流程图（<a href="http://www.bjchy.gov.cn/affair/ldwq/tjzc/8a24fe9767393e2d01673f3dbdc70a21.html" target="_blank" rel="noopener">图源</a>：附件材料）</p><h3><span id="员工不能提供离职证明的解决办法">员工不能提供离职证明的解决办法</span></h3><p>如果已经和公司解除劳动合同， 但公司不配合，我们无法在入职新公司时提供证明该怎么办？</p><h4><span id="正常的法律渠道">正常的法律渠道</span></h4><p>依照法律规定，用人单位有义务在解除劳动合同时出具离职证明。所以我们可以打电话向当地劳动监察大队投诉，或者通过劳动仲裁要求公司出具离职证明并赔偿由此带来的损失。但这么做要花费一定的时间成本。</p><h4><span id="相对简单的解决办法">相对简单的解决办法</span></h4><p>虽然我们不能提供离职证明，但若是在客观事实中，与上一家用人单位的劳动合同已经解除或终止，则公司录用我们时已无法律障碍。我们可以提供与原公司劳动合同解除或终止的相关证明，例如：向原公司提出的《离职申请》、《工作交接记录》、《社保减员证明》等。</p><p>我们还可以向将要入职的公司，出具《承诺函》：<br>本人 A，身份证号：xxx，向 B 公司郑重承诺，本人已经与 C 公司劳动合同解除，若因本人做虚假承诺，给 B 公司造成任何不利后果，都由本人承担。落款：承诺人（签名），x 年 x 月 x 日。</p><h3><span id="提起劳动仲裁前需要注意什么">提起劳动仲裁前需要注意什么</span></h3><p>分享一个我在仲裁前，来自律师的建议：在准备《仲裁申请书》的请求事项中，可以把能想到的都写上（未休年假、加班费、绩效提成等），每项要写清楚详细的计算方式，然后对应去搜集证据，围绕诉求中的主张和证据，阐述事实和理由。</p><p>仲裁委不一定支持当事人的全部主张，但没写在请求事项中的内容一定不会得到支持。</p><p>我将注意事项的重点内容，简单做了如下总结：</p><ol><li>确认本人与用人单位签署了正式劳动合同，排除劳务合同、劳务派遣合同等，并确认自己是否保留了入职以来的全部合同原件。</li><li>如签订劳动合同、请确认合同中是否明确约定了薪酬情况、薪酬构成、工作岗位名称、工作内容、入职时间、工作地点。</li><li>完整保存了与公司沟通协商的往来邮件、微信聊天记录。</li><li>整理好手中现有的证据，列出清单。</li><li>劳动仲裁是必经前置流程，不可直接去法院起诉。</li></ol><h4><span id="提高法律意识留心法律风险">提高法律意识，留心法律风险</span></h4><p>在遇到突发性岗位变动或工作安排，如：调岗、转岗、待岗等，一定要留心这当中的法律风险，不要在任何书面材料上签字，劳动者有权拒绝公司任何不合理不合法的行为。如果跟公司有协商和谈判空间，**可以尝试为自己争取一个不低于心理预期的好结果。**但如果公司想裁员，话HR 找你谈话，连 N 都没有，要诚意没诚意，还不好好说，想套路你，故意搞你心态。别犹豫，拿起法律武器吧。</p><p>法律是每个公民都可以用来保护自己的权利，做为一名普通劳动者，我觉得维权最重要的除了证据和诉讼策略，更重要的是<strong>维权的勇气和决心</strong>。</p><h4><span id="经济补偿金n与-经济赔偿金2n的区别">经济补偿金（N）与 经济赔偿金（2N）的区别</span></h4><p>经常遇到这样一个问题：「员工被公司辞退了，应该赔偿 2N 还是 N+1」？</p><p><strong>经济补偿金</strong>：就是我们大家口中常说的「 N 」，「 N 」是工作年限，用来指代劳动合同法中的经济补偿，计算方式是：经济补偿金= 工作年限 x 月工资。<br>「工作年限」也叫司龄，是补偿金和赔偿金的基数。工作满 1 年支付 1 个月工资。不满 6 个月的，支付 0.5 个月的经济补偿；满 6 个月以上但不满 1 年的，按 1 年支付。<br>「月工资」是指劳动者在劳动合同解除或终止前 12 个月的平均工资（包含奖金、绩效、年终奖等应得收入）。</p><p><strong>经济赔偿金</strong>：公司「违法解除」劳动合同产生的惩罚性赔偿，计算方式是经济补偿金中「N」的 2 倍，也就是「2N 」。如果存在违法解除的情况，</p><p>据我了解，包括大厂在内的绝大多数公司都不守规矩，并不会按照法律标准去执行。有基础法律意识的公司想要裁员时，会尽量规避「违法解除」劳动合同，所以一般来说，「2N」的案子会越来越难打，员工三期（孕期、产期、哺乳期）内遭到公司违法解除劳动合同的情况能相对简单一些。公司会更倾向在「协商解除」的法律框架内做文章。</p><p>《劳动合同法》只规定了「协商解除」的最低标准是「 N 」，另外就是「N +1 」， 1 是指额外支付的 1 个月工资代通知金（即时解除）。除此之外，「N + 2 」 还是「 N + 3 」都没有法律依据。在 N 的基础上，公司想额外支付多少都没有法律限制， 只要双方协商一致，「N + 任何数字」都可以。</p><p>举个例子，公司想裁员找你协商，但你不同意，若公司一意孤行就要裁你，说你绩效不达标，单方面解除了劳动合同，此时就是违法解除，最低是「 2N 」。当然，劳资关系很复杂，公司可以找很多解除劳动合同的理由。如果想打「 2N 」，你需要提供充分的证据证明公司的行为违法，才有可能拿到「2N 」 。</p><p><strong>以下是我整理的关于「2N」的常见情形：</strong></p><table><thead><tr><th style="text-align:center">用人单位解除劳动合同情形</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">情形</td><td style="text-align:center">性质</td><td style="text-align:center">赔偿金</td></tr><tr><td style="text-align:center">劳动者被依法追究刑事责任，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者在试用期间被证明不符合录用条件，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者严重违反用人单位的规章制度，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者严重失职，营私舞弊，给用人单位造成重大损害，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者同时与其他用人单位建立劳动关系，对完成本单位的工作任务造成严重影响，或者经用人单位提出，拒不改正，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者以欺诈、胁迫的手段，或者趁人之危，使对方在违背真实意思表示的情况下订立或者变更劳动合同的情形，致使劳动合同无效，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者处于法定保护期（如孕期、产期、哺乳期），用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">未经劳动者同意，用人单位滥用解除权（如：试用期解除权），擅自解除合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">在本单位连续工作满 15 年，且距法定退休年龄不足 5 年，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">在本单位患职业病或因工负伤并被确认丧失或者部分丧失劳动能力，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">从事接触职业病危害作业的劳动者未进行离岗前职业健康检查，或者疑似职业病，病人在诊断或者医学观察期间，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">患病或者非因工负伤，在规定的医疗期内，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">连续签订 2 次固定期限劳动合同，并且劳动者没有严重过错、没有「不胜任岗位」「不能从事原岗位工作」的情况，合同期满，用人单位不同意不续签。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr></tbody></table><h3><span id="劳动法的有效学习工具">《劳动法》的有效学习工具</span></h3><h4><span id="中国裁判文书网">中国裁判文书网</span></h4><p>中国裁判文书网（简称“<a href="https://wenshu.court.gov.cn/" target="_blank" rel="noopener">裁判文书网</a>”）是由最高人民法院主办的官方网站，主要目的是公开全国各级法院生效裁判文书，以促进司法公正和透明度。</p><p>这是我日常使用频率最高的工具之一，是非常实用的司法实践参考。这个网站提供了丰富的研究素材和数据，可以检索到全国各地法院各类案件的一审、二审或再审判决书，细分选项特别多。</p><p>虽然劳动仲裁裁决书不公开，只允许当事人及其代理人查阅。但我们依然可以从公开的他人判决书中看到一些仲裁信息，如当事人的主张及理由。</p><p>我们可以通过裁判文书网查询和研究先前的判例，了解当地法律趋势，解析审判口径。例如：劳动者和公司双方的争议点是什么，哪些主张和证据被法院支持，为什么会支持，为什么会驳回。以及在结案陈词中法官是如何看待问题的。</p><p><img src="https://img.hi-linux.com/staticfile/1-2024-03-04-K48oE2.png" alt></p><h4><span id="小红书">小红书</span></h4><p>因为小红书有很多人将自己劳动仲裁的相关经历经验以笔记的形式分享，也有很多律师在平台上分享一些办案经验和法律知识，所以我觉得将它非常适合搜索高质量的信息，提前做好功课，多方验证信息，也可以让自己少走些弯路。</p><h4><span id="中国法律快查手册">中国法律快查手册</span></h4><p><a href="https://github.com/RanKKI/LawRefBook" target="_blank" rel="noopener">中国法律快查手册</a>是一个 Github 上的开源项目，内容来源于国家法律法规数据库，这个项目的作者将数据库做了整合和搜索等功能，排版简洁，使用起来简单方便，非常适合平时查询和学习。作者仅提供了手机版（ iOS、iPadOS）和网页版，并未提供电脑端版本，但我在 M1 MacBook Pro 也可以通过 App Store 应用商店安装使用。</p><p>劳动争议的话，建议主要关注《中华人民共和国劳动法》《中华人民共和国劳动合同法》这两个法规。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805474-2024-03-04-SwEcjk.png" alt><a href="https://github.com/RanKKI/LawRefBook?tab=readme-ov-file" target="_blank" rel="noopener">图源</a> / GitHub</p><h2><span id="靠谱律师怎么找">靠谱律师怎么找</span></h2><p>通过研究司法案例以及本地近期公开的劳动争议相关判决书，我学到了一些劳动法基础知识，开始尝试梳理自己的案件情况，并希望可以得到律师的一些专业建议。先说说找律师来代理案子的 2 个常见误区</p><h4><span id="误区-1-律所越大越好名气越高越好">误区 1 ：律所越大越好，名气越高越好。</span></h4><p>名气高的大律所，服务的对象一般是大公司，因为劳动者的案子都是标的金额低的小案子，不赚钱。</p><p>术业有专供，不是所有律师都擅长打劳动仲裁的案子。所以正确的方式是找主要做劳动争议案件的律所，或是主要代理劳动争议的律师。<br>可以是通过熟人（如：朋友、同事、家人）推荐，这样有一定的信任基础，也可以在小红书搜索，看看其他人选择的律师是否口碑好案例多。</p><p>如果在律师的履历介绍中，可以看到他擅长的领域很多，那不一定是好事。我们需要的是履历介绍中更多和劳动争议相关的律师。</p><h4><span id="误区-2-花了钱请律师代理就可交由律师全权负责">误区 2 ：花了钱请律师代理，就可交由律师全权负责</span></h4><p>我们的劳动争议案件虽然标的小且不赚钱，但不妨碍它很复杂。需要投入大量时间研究，准备和开庭，跑仲裁或法院。</p><p>律师也是如此。律师作为法律工作者，是提供专业的法律帮助，而不是代替处理相关全部事项。关于案件中的取证、和有关部门交涉都需要自己来完成，律师只是在这个过程中提供指导。律师可以帮忙争取最好的结果，但不能避免所有的风险。</p><p>作为当事人，我们对公司和自身情况最为了解，庭审时法官会围绕每个细节进行详细询问，这也是为什么自己要重视开庭并亲自参加庭审的原因。为了降低诉讼中存在的风险，我们需要多和律师交流讨论，自己要先厘清思路，整理好证据，做好充足准备，在开庭时才能自如应答，不会因为紧张而遗漏重点。</p><p>通过以上 2 个误区，我们可以对这部分做个小总结：</p><ol><li>专业领域的重要性：我们需要考虑自己的案子类型和律师的专业领域是否匹配</li><li>选择合适的律所和律师：选择有良好声誉和口碑的律师</li><li>律师的角色：请律师并不意味着可以完全放手，律师的角色是指导和争取最佳结果，而不是替代自己处理所有事物。</li><li>当事人的参与：我们做为当事人应对自己的案件有深入了解，并积极参与庭审准备，与律师充分沟通，整理证据，清晰思路，尽可能降低诉讼风险。</li></ol><h3><span id="找律师途径之一中国法律服务网12348-中国法网">找律师途径之一：中国法律服务网（12348 中国法网）</span></h3><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805551-2024-03-04-ac3x5W.png" alt></p><p>这个由司法部建设的网站，是于2018 年 5 月20 日正式上线运行。网站整合并收录了全国范围内的「法律服务机构」和「法律人员数据」。是</p><p>我们可以在里面选择律所或律师，也可以通过网站查询从其他渠道了解到的某家律所，或某位律师（可查询律师执业证号）。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145839669-2024-03-04-Ev0UoP.png" alt></p><h3><span id="为找律师我做了哪些尝试">为找律师我做了哪些尝试</span></h3><p>算下来，我前后共咨询了 3 位律师（不包含法律援助）。我寻求律师帮助的路径是：在线咨询律师 A（付费）—— 线下咨询律师 B （付费）—— 线下咨询律师 C （付费）</p><h4><span id="在线咨询律师-a">在线咨询律师 A</span></h4><p>最开始我先尝试了在网上找律师付费咨询，<br>虽然付费价格（支付 168 元）比线下咨询律师便宜很多，但是与价格相对等的是提问有次数、字数、时间限制（只能文字沟通不能语音），如果在律师不了解相关背景情况下进行提问，这将导致律师因无法判断案情而无法提供合理化建议。</p><p>于是我尝试尽量精简文字表述，将提问内容分为：事件背景（时间线）、我的现状、核心问题，制作成一张图片发送给律师。律师对我提问的内容一一做了解答，但是我结合自身情况，判断出律师提出的解决方案存在的风险比较高，所以我没有采纳。</p><h4><span id="线下咨询律师-b">线下咨询律师 B</span></h4><p>在律师朋友的介绍下，我联系上了一位主要代理劳动争议案件的律师，律所离我也不算远，约了时间线下面谈。这次收获蛮大的，之前担心的问题基本都得到了解决，心里也更踏实了，只不过我的情况比较被动，需要看公司下一步的动作。</p><h4><span id="线下咨询律师-c">线下咨询律师 C</span></h4><p>律师 C 是同事推荐，对于劳动仲裁案件的经验非常丰富。也是我综合考量后，选择了律师 C 委托代理我的一审案子。</p><p>关于律师咨询费。北京这边 200 - 3000 元 / 小时不等，我在线下咨询律师 B 两次，每次都是 500 元 / 小时。</p><p>关于律师代理费。根据案子标的额的百分比收取，不同审判阶段（仲裁、一审、二审），费用也不同。</p><h2><span id="少走弯路准备证据和录音技巧">少走弯路：准备证据和录音技巧</span></h2><h3><span id="准备证据">准备证据</span></h3><h4><span id="一键下载仲裁所需的全部材料">一键下载仲裁所需的全部材料</span></h4><p>包含劳动仲裁立案申请、证据交换、出庭使用的材料模板，可以通过<a href="http://www.bjchy.gov.cn/affair/ldwq/tjzc/8a24fe9767393e2d01673f3dbdc70a21.html" target="_blank" rel="noopener">北京市朝阳区人民政府官网</a>页面底部的「点击此处下载相关附件」获取。文档中还有相关办理流程、注意事项，内容非常全面，可以仔细查阅。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805703-2024-03-04-nYvF2T.png" alt></p><h4><span id="自助打印银行工资流水凭证">自助打印银行工资流水凭证</span></h4><p><strong>本人带上身份证原件直接去附近银行营业厅的自助机上打印</strong>，可自行在机器上操作，省去拿号排队去窗口的过程，在使用银行自助机的过程中，有任何问题都可以找身边的银行经理帮忙解决，非常高效。<strong>建议在打印前了解相关费用标准并做好准备</strong>，有的银行会限制每月免费打印次数，超过则按张收取费用。我的工资是由公司通过 3 家银行（北京、交通、招商）发放，所以我需要去 3 家银行分别打印流水，北京银行和交通银行的自助机没有对流水单设立打印限制，但招商银行的打印限制我记得是 4 张 / 月，超过按 20 元 / 张收费。</p><p>在银行自助机操作时，我总结了 3 个重点：选择时间范围、筛选交易类型、包含银行盖章。</p><p><strong>选择时间范围</strong>：依据劳动争议涉及的时间来选择流水打印范围，需按年选择，不可跨年。</p><p><strong>筛选交易类型</strong>：要在筛选栏勾选交易类型（工资），指定筛选条件的目的，是为了方便自己和他人在查看银行流水单时，让工资发放情况一目了然，我们只需要工资流水的相关证明，不需要其他交易记录。</p><p><strong>包含银行公章</strong>：银行自助机打印的工资明细一般默认包含公章，但也有个别银行需要在打印前勾选相关选项后，才可打印出盖了章的流水单。公章名称一般叫「回单专用章」或「会计业务章」。打印前后一定要留意打印的流水单是否包含银行的公章，如果没有公章则证据无效。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145849891-2024-03-04-4TsJZE.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805946-2024-03-04-Opd8Qi.png" alt></p><p>我的银行流水单盖章（左：北京银行 ；右：交通银行）</p><h4><span id="利用-iphone-备忘录扫描劳动合同复印件">利用 iPhone 备忘录扫描《劳动合同》复印件</span></h4><p>因为打印出来的纸张是黑白效果，如果直接使用手机将《劳动合同》拍照、，会导致部分信息模糊不清，这里有个便捷好用的小技巧：利用 iPhone 备忘录中的「扫描」功能，逐页将《劳动合同》扫描成 PDF 文件后再打印（相比直接打印效果更清晰，相比复印更省事）。可以避免因提交材料不合格导致返工的情况（不要重蹈我的覆辙）。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145806016-2024-03-04-FtagF1.png" alt>iPhone 备忘录中的「扫描文稿」功能</p><h4><span id="打工人必备app-权利卫士">打工人必备App —— 权利卫士</span></h4><p>这是一款由国家知识产权局推出，具有法律效率的<a href="https://www.tsa.cn/" target="_blank" rel="noopener">电子取证工具</a>（仅支持 iOS、Android ），被法律工作者广泛使用。可生成不可篡改的带有时间戳的电子证据。取证范围包含：拍照、录像、录音、录屏、网页。在 App 中实名认证就可正常使用。</p><p>如果有些证据比较重要，可以选择这个工具。例如：在公司对我的办公软件停用前，我就使用了权利卫士的录屏功能，对组织架构、个人信息等情况进行了证据固定。法律规定谁主张谁举证的原则，在提起仲裁或诉讼时，我就有了通过权利卫士保存的电子版基础证据。</p><p>权利卫士可以很大程度上代替传统的公正取证方式。正确使用权利卫士，可以在价格低廉的同时，让取证变得更快捷。但它终归只是一个取证工具，证据的真实性没问题，但是否会被采纳，能发挥多大作用，是需要深度思考的问题。如果拿不准可以在律师的指导下使用，毕竟每次取证都需要付费。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145806077-2024-03-04-UkvPbG.png" alt>权利卫士官网</p><h3><span id="录音技巧">录音技巧</span></h3><ol><li>时间：录音证据宜早不宜晚</li><li>设备：无论面谈与否，要全程录音，能清晰听清双方谈话内容的设备皆可。如果是电话沟通，并且是苹果手机，没有通话录音功能，可以向朋友借一台手机用来录音。</li><li>操作：手机可以开启飞行模式，防止突然来电导致录音中断</li></ol><h4><span id="注意事项">注意事项</span></h4><p>录音证据大多情况都不能被仲裁庭采纳，主要原因是录音中的谈话内容，缺少适格主体等关键信息，例如：公司法人张三、人力资源负责人李四。录音属于锦上添花，能有更好，如果获取不到有用信息也没有关系。</p><p>录音的目的是通过谈话，问清事实情况，便于进一步固定证据。不能威胁恐吓对方（态度友好），否则证据无效。值得一提的是，录音证据的目的是为了佐证其他关联证据，形成证据链，不能单独使用。</p><p>谈话中不仅<strong>问题要清晰明确</strong>，还需要做到谈话人身份明确，内容清晰，具有客观真实和连贯性。可以先理清思路，再写成书面材料，通话前尝试练习几遍。</p><h4><span id="提交录音">提交录音</span></h4><p>需要注意的是，录音做为证据时，要做两件事：一是要将未被剪接或者伪造，内容未被改变，无疑点的<strong>完整音频文件刻录成光盘</strong>，二是要将全部<strong>对话内容整理成文字版书面材料。</strong></p><p>**录音内容文字版：**建议写明这些信息：时间、地点、设备、时长、当事人信息（本人名字、公司负责人职称和名字）。最后，在《证据目录》中标记好录音文件的位置，将录音光盘、文字版随其他证据一起提交。</p><p>另外，录音原视文件和载体（如手机）要保留好，用于庭审时查验。</p><h4><span id="我的录音沟通提纲">我的录音沟通提纲</span></h4><ol><li>确认双方主体和身份</li><li>确认相关的事实</li><li>履行友好协商的态度，明确提出自己的主张</li></ol><h4><span id="我的通话前录音内容">我的通话前录音内容</span></h4><ol><li>对着录音自我介绍并陈述事实：我是 xxx，身份证号 xxx，自 x 年 x 月 x 日在 x 公司，x 部门，担任 x 职位。<br>x 年 x 月 x 日起，公司 xx（简短陈述事实内容），我现在要给公司人力资源部总监 xx （全名）拨打电话，协商解决方案。Ta 的电话是 xxx。</li></ol><p><img src="https://img.hi-linux.com/staticfile/1-20240304145904400-2024-03-04-LCFi9Y.jpeg" alt>证据材料清单样表（<a href="http://www.bjchy.gov.cn/affair/ldwq/tjzc/8a24fe9767393e2d01673f3dbdc70a21.html" target="_blank" rel="noopener">图源</a>：附件材料)</p><h3><span id="寻求免费的法律援助">寻求免费的法律援助</span></h3><p>法律援助更像是针对「特殊群体」设立的专项服务，主要服务于农民工或年纪较大的人。</p><p>朝阳劳动仲裁委员会也设立了法律援助咨询窗口，在服务总台领号排队，与仲裁立案窗口同在一个大厅。或许是我的案子具有复杂性，也可能窗口的工作人员并没太多时间帮我深度分析，我将手里的证据给到对方，尝试了解对于我这种情况的政策和裁判口径，但我并未收获到有用的信息和指导性建议。</p><p>所以，大家可以尝试性去咨询，但不要对法援抱有太大期望。也不要轻信仲裁委门口主动发卡片的律师咨询，我从没见过有执业证的律师需要揽客，这些卡片上的律师，很可能就不是律师，十有八九不靠谱，有很多被人被骗。</p><h3><span id="我的完整仲裁流程">我的完整仲裁流程</span></h3><p>在仲裁阶段，我选择的是自己走完全流程，委托律师代理的是一审诉讼。<br>一是因为北漂多年，有过仲裁经历。<br>二是因为之前外籍二房东不退押金，并大放厥词可以去法院告他。于是我就听了他的建议，自己写诉状去法院起诉，所以有一些民事诉讼的经验。</p><p>劳动仲裁的立案、交换证据流程和法院诉讼在某些方面有相似之处，。所以我觉得仲裁相比诉讼来说在准备充分的情况下要简单很多，我的劳动争议案子偏复杂，需要经过法院审理。</p><p>以北京朝阳区为例，可以在北京人社局官网提前预约，预约后会短信告知线下提交立案材料的时间。疫情时官网预约后需要等 1 个月以上，现在要等的时间不好说。</p><p>也可以选择可以直接去线下领号立案（更推荐这种方式，更高效）。建议准备好材料，在 8 点前到门口排队， 10点前拿到号。否则可能会由于人多无法当天立案。我在<strong>疫情时和疫情后</strong>分别成功立案 2 次，是针对劳动争议中的不同时间段的仲裁请求。现在疫情已经过去，流程也简化了不少，相对来说更省事儿了。</p><h4><span id="仲裁地点">仲裁地点</span></h4><p>北京市朝阳区劳动人事争议仲裁院<br>电 话：010-87983310<br>地 址：北京市朝阳区将台路5号院15号楼B座、C座</p><h4><span id="准备材料">准备材料</span></h4><ul><li>身份证原件</li><li>身份证复印件 x 3</li><li>申请书 x 3</li><li>地址确认书 x 1</li></ul><p>建议检查好相关材料，并将电子版备份到 U 盘，最好是带上笔记本电脑，若书面材料不符合立案窗口要求，可以即时用自己电脑修改，若有漏打材料，也可在服务台旁边的打印区付费打印。</p><h4><span id="立案流程">立案流程</span></h4><ol><li>去总服务台领取地址确认书填好，领取初审号码（可以提前打印好，直接领A 开头初审号码）</li><li>初审后收到 B 开头立案号码，等待叫号。</li><li>立案窗口工作人员可能会让填一个劳动调解表。（这步可以直接放弃调解，直接走程序省时间，因为开庭前仲裁员还会再次调解）</li></ol><h4><span id="完成立案">完成立案</span></h4><p>成功立案后，窗口会现场出具举证通知等书面材料，立案后有 30 天的调解时间，期间会有工作人员打电话给当事人（公司、劳动者）双方，询问是否同意调解。接下来会收到朝阳仲裁委关于交换证据的通知邮件，以及短信提醒。</p><h4><span id="交换证据">交换证据</span></h4><p>需要注意，自己和公司方的交换时间是一样的，务必要按照规定时间内到达指定窗口，办理举证及证据交换，必须是本人，否则过时不候。提交完成并签字确认后就可以离场了，如果在现场遇到公司的人也必理会。</p><h4><span id="等待庭审">等待庭审</span></h4><p>接下来，等待开庭通知就好。开庭时要携带身份证原件、证据原件。需要注意开庭时间， **如果开庭当天本人迟到，会被视为撤诉。**仲裁开庭也比较简单，不会法院审理案件那样细致。主要是仲裁员通过问询双方当事人，录入双方确认的一些信息，如争议时间、质证理由、社保状态、薪资情况等。<br>仲裁案件都是随机分别仲裁员，我是2022 年底立案， 2023 年初开庭，直到 2023 年 10 月才收到裁决书。大家可以多联系自己案件的仲裁员，催问进度。</p><h4><span id="仲裁结果">仲裁结果</span></h4><p>身边总有朋友认为，收到的劳动仲裁裁决书上支持了相关请求事项，就是胜利的信号，但仲裁是以调解为主，并不能最大限度维护劳动者自身权益。例如：法律规定协商解除劳动合同的最低标准是 N ，假设 N 是 10 个月，仲裁员会和公司、劳动者分别协商，讨价还价后，最终 N 可能是 6 或者 4，甚至更低，看似减少了劳动者维权的时间成本，实际最大受益者却是公司一方，公司试图用远低于法律规定的标准，带有恶意性、针对性、侮辱性的手段，低成本实现裁员目的。</p><p>所以劳动仲裁对劳动者来说只是维权之路的起点，还要经历一审诉讼、二审诉讼，即使最终赢了官司，还可能面临向法院申请强制执行的情况。</p><h2><span id="写在最后">写在最后</span></h2><p>遇见过一些 HR ，千方百计地学习裁员套路和话术。一个员工为企业服务这么多年，非但不感谢员工多年的辛苦付出，反而为了达成裁员目的搞手段，扣帽子。想法设法压榨剥削打工人，员工不和你死磕跟谁磕？员工就是一个个普普通通的人，不止看重钱，还很在乎你怎么对他。</p><p>这个世界很奇妙。代理我案子的律师最近就遇见了一个离谱案件，将这个真实案例用一句话概括就是：职场当中套路虽多，但涉及底线的东西并不适用于套路。谁也说不准，后面被搞心态以及被裁的，会不会是自己。</p><blockquote><p>本文转载自：「 少数派 」，原文：<a href="https://url.hi-linux.com/jpw6C" target="_blank" rel="noopener">https://url.hi-linux.com/jpw6C</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我第一次尝试写个人年度总结。&lt;/p&gt;
&lt;p&gt;我的 2023 年与 2022 年不可分割，一直走在维权的路上。&lt;/p&gt;
&lt;p&gt;早在 2022 年初，我的职业生涯发生重大转变，公司在未与我协商的情况下，单方面将我待岗，降低工资，移交工作。我从熟悉的工作环境被迫成为了一个「半自由职业者」。我之所以自认为是半自由，是因为公司未与我解除劳动合同，所以劳动关系还在原公司。法律规定劳动者只能和一家用人单位签订劳动合同，所以我在与公司存在劳动争议的情况下，无法入职下家公司。&lt;/p&gt;
&lt;p&gt;除此之外，公司隔几个月后停发我的工资，切断了我唯一的经济来源。我开始尝试学习《劳动法》及相关法律知识，查阅和自己案件类似的裁判文书，整理书面材料，为的是跟公司对簿公堂，讨回做为劳动者的尊严和权益。&lt;/p&gt;
&lt;p&gt;在劳资关系中，公司具有优势地位，而劳动者处于弱势的一方。尤其是面对老板、人事、法务组成的流氓团伙时，会更加被动、愤怒、迷茫、无助。希望大家在面对公司的恶意时可以更加从容，是我写下这些文字的初衷。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="教程" scheme="https://www.hi-linux.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="职场" scheme="https://www.hi-linux.com/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>简单一招，轻松把 Nginx 服务器性能提升 50 倍</title>
    <link href="https://www.hi-linux.com/posts/52460.html"/>
    <id>https://www.hi-linux.com/posts/52460.html</id>
    <published>2024-02-05T01:00:00.000Z</published>
    <updated>2024-02-05T08:27:29.121Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="用-nginx-gzip-进行静态加速">用 Nginx Gzip 进行静态加速</span></h2><p>这绝对是你应该做的事情。<br>并不是特别麻烦，而且效果也很突出。</p><p>这里解释了 <a href="https://nginx.p2hp.com/" target="_blank" rel="noopener">Nginx</a> 中的 gzip_static。</p><h3><span id="1不使用-gzip-static-时的-gzip-处理">1.不使用 gzip static 时的 gzip 处理</span></h3><p><img src="https://img.hi-linux.com/staticfile/N56H1Z-2024-02-05-yyBwlC.png" alt="Nginx 不使用 gzip_static 时 gzip 处理的说明"></p><p><strong>如果你不使用 gzip_static 而只是 “gzip on”，它每次都会被压缩并发送。</strong></p><p>虽然它实际上可能缓存在内存中，但传统观点是 “每次都会执行压缩处理，因此 CPU 负载很大。”</p><p>因此，我每次都想停止处理它。</p><p>“gzip_static” 可以实现这一点。</p><a id="more"></a><h3><span id="2使用-gzip-static-时的-gzip-处理">2.使用 gzip static 时的 gzip 处理</span></h3><p><img src="https://img.hi-linux.com/staticfile/g3KBwu-2024-02-05-TfefNK.png" alt="Nginx 中开启 gzip_static 时 gzip 处理的说明"></p><p><strong>它将搜索 “gz” 文件并为您使用！</strong></p><p>如果是 “style.css”，它将自动搜索文件 “style.css.gz”。<br>如果找到，则返回它；如果没有，则照常压缩 “style.css”。<br>因此，如果提前创建压缩文件，就不会产生 CPU 负载，处理速度也会更快。</p><p>更好的是压缩级别。</p><h3><span id="3使用-gzip-static-的优点">3.使用 gzip static 的优点</span></h3><p><img src="https://img.hi-linux.com/staticfile/WXg4zd-2024-02-05-j5SCrt.png" alt="将 gzip_static 与 Nginx 一起使用的最大优点是可以将压缩级别设置为 9。"></p><p><strong>它可以以最大压缩率保存。</strong></p><p>通常情况下，不可能使用最高压缩设置，因为它会给 CPU 带来沉重的负载，但<br>由于你可以提前慢慢创建它，所以我通常将其保存在最高压缩级别（级别9）。<br>文件大小肯定会减小。</p><h3><span id="4-需要一个模块才能在-nginx-中使用-gzip-static">4. 需要一个模块才能在 Nginx 中使用 gzip static</span></h3><p><strong>ngx_http_gzip_static_module 是必需的。</strong></p><p>请使用以下命令检查是否已安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V 2&gt;&amp;1 | tr <span class="string">' '</span> <span class="string">'n'</span>|egrep _module | sed -e <span class="string">'s/--with-//g'</span></span><br></pre></td></tr></table></figure><p>如果未安装，系统会要求您重新安装 Nginx（可能）。<br>您必须使用 “–with-http_gzip_static_module” 安装它。<br>但是，当我从存储库安装时，所有内容都已包含在内，而无需执行任何操作。</p><p>请先检查一下。</p><h3><span id="5如何在-nginx-上配置-gzip-静态">5.如何在 Nginx 上配置 gzip 静态</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gzip_static on;</span><br><span class="line">gzip on;</span><br><span class="line">gzip_comp_level 1;</span><br><span class="line">gzip_min_length 1024;</span><br><span class="line">gzip_vary on;</span><br><span class="line">gzip_proxied any;</span><br><span class="line">gzip_types text&#x2F;plain text&#x2F;css text&#x2F;javascript application&#x2F;javascript application&#x2F;x-javascript application&#x2F;json application&#x2F;ld json text&#x2F;xml application&#x2F;xml application&#x2F;xhtml xml application&#x2F;atom xml application&#x2F;xml rss application&#x2F;rss xml image&#x2F;x-icon image&#x2F;svg xml image&#x2F;bmp;</span><br></pre></td></tr></table></figure><p><strong>只需在常规内容中添加 “gzip_static on” 即可。</strong></p><p>这就是启用它所需要做的全部工作，所以很简单。</p><p>我建议你只设置这个。</p><p>如果你用谷歌搜索，你会看到很多人指定 “gzip_static always”，<br>这意味着在任何情况下都使用 gz 文件。<br>假设所有目标文件都被压缩并保存（理想情况）。</p><p>在这种情况下，将不会显示不支持的用户，因此您还需要指定 “gunzip on;”。<br>如果客户端不支持 gzip，文件会在服务器端解压后发送。</p><p>详情请参阅以下页面。</p><p><a href="http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html" target="_blank" rel="noopener">官方解释：ngx_http_gzip_static_module 模块</a></p><h3><span id="6-如何使用-gzip-压缩">6. 如何使用 gzip 压缩</span></h3><p>&lt;对于 PHP&gt;</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzencode(<span class="variable">$file</span>, 9)</span><br></pre></td></tr></table></figure><p>&lt;对于 ubuntu（Linux）&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -9 -k style.css</span><br></pre></td></tr></table></figure><p>每次更新时我都会自动使用 PHP 创建它。</p><h3><span id="7-需要压缩的文件">7. 需要压缩的文件</span></h3><p><strong>一般文本文件如 css、js、xml 等</strong></p><p>可以将其视为图像之外的其他内容。</p><p>基本上，它将是 “gzip_types” 指定的文件。</p><p>但是，如果将压缩级别设置为 9，图像通常会变小。<br>如果你比较讲究的话，请用各种方式压缩一下看看。</p><p>这是 Nginx中 gzip static 的解释。</p><p>它非常有效，所以请尝试一下。</p><p>原文链接 <a href="https://doudonn.com/saba/2331/" target="_blank" rel="noopener">https://doudonn.com/saba/2331/</a></p><blockquote><p>本文转载自：「 Lenix Blog 」，原文：<a href="https://url.hi-linux.com/o1BAZ" target="_blank" rel="noopener">https://url.hi-linux.com/o1BAZ</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;用-Nginx-Gzip-进行静态加速&quot;&gt;用 Nginx Gzip 进行静态加速&lt;/h2&gt;
&lt;p&gt;这绝对是你应该做的事情。&lt;br&gt;
并不是特别麻烦，而且效果也很突出。&lt;/p&gt;
&lt;p&gt;这里解释了 &lt;a href=&quot;https://nginx.p2hp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nginx&lt;/a&gt; 中的 gzip_static。&lt;/p&gt;
&lt;h3 id=&quot;1-不使用-gzip-static-时的-gzip-处理&quot;&gt;1.不使用 gzip static 时的 gzip 处理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/N56H1Z-2024-02-05-yyBwlC.png&quot; alt=&quot;Nginx 不使用 gzip_static 时 gzip 处理的说明&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你不使用 gzip_static 而只是 “gzip on”，它每次都会被压缩并发送。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然它实际上可能缓存在内存中，但传统观点是 “每次都会执行压缩处理，因此 CPU 负载很大。”&lt;/p&gt;
&lt;p&gt;因此，我每次都想停止处理它。&lt;/p&gt;
&lt;p&gt;“gzip_static” 可以实现这一点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>史上最全 SSH 暗黑技巧详解</title>
    <link href="https://www.hi-linux.com/posts/60266.html"/>
    <id>https://www.hi-linux.com/posts/60266.html</id>
    <published>2024-01-23T01:00:00.000Z</published>
    <updated>2024-01-23T02:11:04.393Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>我见过太多的老鸟、新手对 SSH 基本只限于 SSH 到远程机器，实际这个命令我们一天要用很多次，但是对它的了解太少了，他的强大远远超出你的想象。当于你也许会说够用就够了，确实没错，但是你考虑过效率没有，或者还有哪些脑洞大开的功能会让你爱死他，这些功能又仅仅是一行命令就够了。</p><p>疫情期间一行 SSH 命令让我节省了 70% 的出差时间，来，让我们一起走一遍，看看会不会让你大开眼界。</p><a id="more"></a><h2><span id="本文试图解决的问题">本文试图解决的问题</span></h2><ul><li>如何通过 SSH 命令正确上网</li><li>Docker 镜像、Golang 仓库总是被墙怎么办</li><li>公司跳板机要输入动态 Token，太麻烦了，如何省略掉这个 Token；</li><li>比如多机房总是要走跳板机，如何 <code>绕过</code> 跳板机直连；</li><li>我的开发测试机器如何免打通、免密码、直达；</li><li>如何访问隔离环境中( K8s )的 Web 服务 – 将隔离环境中的web端口映射到本地</li><li>如何让隔离环境的机器用上 Yum、APT</li><li>如何将服务器的图形界面映射到本地(类似 VNC 的作用)</li><li>SSH 如何调试诊断，这才是终极技能……</li></ul><h2><span id="注意事项">注意事项</span></h2><ul><li>SSH 是指的 openSSH 命令工具</li><li>本文适用于各种 Linux、macOS 下命令行操作，Windows 的话各种可视化工具都可以复制 Session、配置 Tunnel 来实现类似功能。</li><li>如果文章中提到的文件、文件夹不存在可以直接创建出来。</li><li>所有配置都是在你的笔记本上（相当于 SSH Client上）</li></ul><h2><span id="正确上网">正确上网</span></h2><p>有时候正确上网还得靠自己，一行 SSH 命令来正确上网:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ssh -qTfnN -D 127.0.0.1:38080 root@1.1.1.1 &quot;vmstat 10&quot; 2&gt;&amp;1 &gt;&#x2F;dev&#x2F;null &amp;</span><br></pre></td></tr></table></figure><p>上面的 1.1.1.1 是你在境外的一台服务器，已经做好了免密登陆（免密见后面，要不你还得输一下密码），这句话的意思就是在本地启动一个 38080 的端口，上面收到的任何东西都会转发给 1.1.1.1:22（做了 SSH 加密），1.1.1.1:22 会解密收到的东西，然后把他们转发给 Google 之类的网站（比如你要访问的是 Google），结果依然通过原路返回</p><p>127.0.0.1:38080  就是要填入到你的浏览器中的 Socks5 代理服务器，什么都不需要装，非常简单。</p><p><img src="https://img.hi-linux.com/staticfile/n3mrq5-2024-01-22-7OPIZB.png" alt></p><p>原理图如下(灰色矩形框就是你本地 SSH 命令，SSH 线就是在穿墙， 国外服务器就是命令中的 1.1.1.1)：</p><p><img src="https://img.hi-linux.com/staticfile/Wqm4wS-2024-01-22-UmMYjx.png" alt></p><h3><span id="正确上网之-http-特殊代理-利用-ssh-本地转发是-http-协议">正确上网之 HTTP 特殊代理 – 利用 SSH 本地转发是 HTTP 协议</span></h3><p>前面所说的代理是 Socks5 代理，一般浏览器都有插件支持，但是比如你的 Docker（或者其他程序）需要通过 HTTP 去拉取镜像就会出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon 8.704 kB</span><br><span class="line">Step 1 : FROM k8s.gcr.io&#x2F;kube-cross:v1.10.1-1</span><br><span class="line">Get https:&#x2F;&#x2F;k8s.gcr.io&#x2F;v1&#x2F;_ping: dial tcp 108.177.125.82:443: i&#x2F;o timeout</span><br></pre></td></tr></table></figure><p><a href="https://www.atatech.org/articles/102153" target="_blank" rel="noopener">如果是 Git 这样的应用内部可以配置 Socks5 和 HTTP 代理服务器，请参考另外一篇文章</a>，但是有些应用就不能配置了，当然最终通过 SSH 大法还是可以解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssh -L 443:108.177.125.82:443 root@1.1.1.1 &#x2F;&#x2F; 在本地监听 443，转发给远程 108.177.125.82 的 443 端口</span><br></pre></td></tr></table></figure><p>然后再在 <code>/etc/hosts</code> 中将域名 <a href="http://k8s.gcr.io" target="_blank" rel="noopener">k8s.gcr.io</a> 指向 127.0.0.1， 那么本来要访问 <a href="http://k8s.gcr.io:443" target="_blank" rel="noopener">k8s.gcr.io:443</a> 的，变成了访问本地 127.0.0.1:443 而 127.0.0.1:443 又通过 SSH 重定向到了 108.177.125.82:443 这样就实现了 HTTP 代理或者说这种特殊情况下的正确上网。这个方案不需要装任何东西，但是每个访问目标都要这样处理，好在这种情况不多。</p><h2><span id="内部堡垒机-跳板机都需要密码动态码太复杂了怎么解">内部堡垒机、跳板机都需要密码+动态码，太复杂了，怎么解？</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/config </span></span><br><span class="line"><span class="meta">#</span><span class="bash">reuse the same connection --关键配置</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~/tmp/ssh_mux_%h_%p_%r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查了下 ControlPersist 是在 OpenSSH5.6 加入的，5.3还不支持</span></span><br><span class="line"><span class="meta">#</span><span class="bash">不支持的话直接把这行删了，不影响功能</span></span><br><span class="line"><span class="meta">#</span><span class="bash">keep one connection <span class="keyword">in</span> 72hour</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ControlPersist 72h</span></span><br><span class="line"><span class="meta">#</span><span class="bash">复用连接的配置到这里，后面的配置与复用无关</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">其它也很有用的配置</span></span><br><span class="line">GSSAPIAuthentication=no</span><br><span class="line"><span class="meta">#</span><span class="bash">这个配置在公网因为安全原因请谨慎关闭</span></span><br><span class="line">StrictHostKeyChecking=no</span><br><span class="line">TCPKeepAlive=yes</span><br><span class="line">CheckHostIP=no</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"ServerAliveInterval [seconds]"</span> configuration <span class="keyword">in</span> the SSH configuration so that your ssh client sends a <span class="string">"dummy packet"</span> on a regular interval so that the router thinks that the connection is active even <span class="keyword">if</span> it<span class="string">'s particularly quiet</span></span></span><br><span class="line">ServerAliveInterval=15</span><br><span class="line"><span class="meta">#</span><span class="bash">ServerAliveCountMax=6</span></span><br><span class="line">ForwardAgent=yes</span><br><span class="line"></span><br><span class="line">UserKnownHostsFile /dev/null</span><br></pre></td></tr></table></figure><p>在你的 SSH 配置文件增加上述参数，意味着 72 小时内登录同一台跳板机只有第一次需要输入密码，以后都是重用之前的连接，所以也就不再需要输入密码了。</p><p>加了如上参数后的登录过程就有这样的东东(默认没有，这是 Debug 信息)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">debug1: setting up multiplex master socket</span><br><span class="line">debug3: muxserver_listen: temporary control path   &#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.**_22_corp.86g3C34vy36tvCtn</span><br><span class="line">debug2: fd 3 setting O_NONBLOCK</span><br><span class="line">debug3: fd 3 is O_NONBLOCK</span><br><span class="line">debug3: fd 3 is O_NONBLOCK</span><br><span class="line">debug1: channel 0: new [&#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.*.*_22_corp]</span><br><span class="line">debug3: muxserver_listen: mux listener channel 0 fd 3</span><br><span class="line">debug1: control_persist_detach: backgrounding master process</span><br><span class="line">debug2: control_persist_detach: background process is 15154</span><br><span class="line">debug2: fd 3 setting O_NONBLOCK</span><br><span class="line">debug1: forking to background</span><br><span class="line">debug1: Entering interactive session.</span><br><span class="line">debug2: set_control_persist_exit_time: schedule exit in 259200 seconds</span><br><span class="line">debug1: multiplexing control connection</span><br></pre></td></tr></table></figure><p><code>/home/ren/tmp/ssh_mux_10.16.*.*_22_corp</code> 这个就是保存好的 Socket，下次可以重用，免密码。 in 259200 seconds 对应 72小时</p><h2><span id="我有很多不同机房或者说不同客户的机器都需要跳板机来登录能一次直接-ssh-上去吗">我有很多不同机房（或者说不同客户）的机器都需要跳板机来登录，能一次直接 SSH 上去吗？</span></h2><p>比如有一批客户机房的机器 IP 都是 192.168.<em>.</em>, 然后需要走跳板机 100.10.1.2 才能访问到，那么我希望以后<strong>在笔记本上直接 ssh 192.168.1.5 就能直接连上</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;ssh&#x2F;ssh_config</span><br><span class="line"></span><br><span class="line">Host 192.168.*.*</span><br><span class="line">ProxyCommand ssh -l ali-renxijun 100.10.1.2 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br></pre></td></tr></table></figure><p>上面配置的意思是执行 <code>ssh 192.168.1.5</code> 的时候命中规则 <code>Host 192.168.*.*</code> 所以执行 <code>ProxyCommand</code> 先连上跳板机再通过跳板机连向 192.168.1.5 。这样在你的笔记本上就跟 192.168.<em>.</em> 的机器仿佛在一起，SSH 可以上去，但是 ping 不通这个 192.168.1.5 的 IP</p><p><strong>划重点：公司的线上跳板机做了特殊限制，限制了这个技能。日常环境跳板机支持这个功能</strong></p><p>比如我的跳板配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#到美国的机器用美国的跳板机速度更快</span><br><span class="line">Host 10.74.*</span><br><span class="line">ProxyCommand ssh -l user us.jump exec &#x2F;bin&#x2F;nc %h %p 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">#到中国的机器用中国的跳板机速度更快</span><br><span class="line">Host 10.70.*</span><br><span class="line">ProxyCommand ssh -l user cn.jump exec &#x2F;bin&#x2F;nc %h %p 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">   </span><br><span class="line">Host 192.168.0.*</span><br><span class="line">ProxyCommand ssh -l user 1.1.1.1 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br></pre></td></tr></table></figure><p>其实我的配置文件里面还有很多规则，懒得一个个隐藏 IP 了，这些规则是可以重复匹配的</p><p>来看一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ren@ren-VirtualBox:&#x2F;$ ping -c 1 10.16.1.*</span><br><span class="line">        PING 10.16.1.* (10.16.1.*) 56(84) bytes of data.^C</span><br><span class="line">    --- 10.16.1.* ping statistics ---</span><br><span class="line">    1 packets transmitted, 0 received, 100% packet loss, time 0ms</span><br><span class="line">    </span><br><span class="line">ren@ren-VirtualBox:~$ ssh -l corp 10.16.1.* -vvv</span><br><span class="line">OpenSSH_6.7p1 Ubuntu-5ubuntu1, OpenSSL 1.0.1f 6 Jan 2014</span><br><span class="line">debug1: Reading configuration data &#x2F;home&#x2F;ren&#x2F;.ssh&#x2F;config</span><br><span class="line">debug1: Reading configuration data &#x2F;etc&#x2F;ssh&#x2F;ssh_config</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 28: Applying options for *</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 44: Applying options for 10.16.*.*</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 68: Applying options for *</span><br><span class="line">debug1: auto-mux: Trying existing master</span><br><span class="line">debug1: Control socket &quot;&#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.1.*_22_corp&quot; does not exist</span><br><span class="line">debug1: Executing proxy command: exec ssh -l corp 139.*.*.* exec &#x2F;usr&#x2F;bin&#x2F;nc 10.16.1* 22</span><br></pre></td></tr></table></figure><p>本来我的笔记本跟 10.16.1.* 是不通的(ping 不通），但是 SSH 可以直接连上，实际 SSH 登录过程中自动走跳板机 139.<em>.</em>.* 就连上了</p><p><code>-vvv</code> 参数是 debug，把 SSH 登录过程的日志全部打印出来。</p><h2><span id="将隔离环境中的-web-端口映射到本地本地代理">将隔离环境中的 Web 端口映射到本地（本地代理）</span></h2><p>远程机器部署了 Web Server（端口 8083），需要通过浏览器来访问这个 WEB 服务，但是 server 在隔离环境中，只能通过 SSH 访问到。一般来说会在隔离环境中部署一个 Windows 机器，通过这个 Windows 机器来访问到这个 Web Server。能不能省掉这个 Windows 机器呢？</p><p>现在我们试着用 SSH 来实现本地浏览器直接访问到这个隔离环境中的 Web Server。</p><p>假设 Web Server 是：10.1.1.123:8083， SSH 账号是：user</p><p>先配置好本地直接 <code>ssh user@10.1.1.123</code> （参考前面的 <code>ProxyCommand</code> 配置过程，最好是免密也配置好），然后在你的笔记本上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CNfL 0.0.0.0:8088:10.1.1.123:8083 user@10.1.1.123</span><br></pre></td></tr></table></figure><p>或者：(<a href="mailto:root@100.1.2.3">root@100.1.2.3</a> -p 54900 是可达10.1.1.123的代理服务器)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CNfL 0.0.0.0:8089:10.1.1.123:8083 root@100.1.2.3 -p 54900</span><br></pre></td></tr></table></figure><p>这表示在本地启动一个 8088 的端口，将这个 8088 端口映射到 10.1.1.123 的 8083 端口上，用的 SSH 账号是 user</p><p>然后在笔记本上的浏览器中输入：127.0.0.1:8088 就看到了如下界面：</p><p><img src="https://img.hi-linux.com/staticfile/bOUSWh-2024-01-22-CPWM1b.png" alt></p><p>反过来，<strong>也可以让隔离环境机器通过代理上网，比如安装 yum</strong></p><h2><span id="为什么有时候-ssh-比较慢比如总是需要-30-秒钟后才能正常登录">为什么有时候 SSH 比较慢，比如总是需要 30 秒钟后才能正常登录</span></h2><p>先了解如下知识点，在 ~/.ssh/config 配置文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GSSAPIAuthentication&#x3D;no</span><br></pre></td></tr></table></figure><p>禁掉 GSSAPI 认证，GSSAPIAuthentication 是个什么鬼东西请自行 Google (多一次没必要的授权认证过程，然后等待超时)。 这里要理解 SSH 登录的时候有很多种认证方式（公钥、密码等等），具体怎么调试请记住强大的命令参数 <code>ssh -vvv</code> 上面讲到的技巧都能通过 <code>-vvv</code> 看到具体过程。</p><p>比如我第一次碰到 ssh 比较慢总是需要 30 秒后才登录，不能忍受，于是登录的时候加上 -vvv 明显看到控制台停在了：GSSAPIAuthentication 然后 Google 了一下，禁掉就好了</p><p>当然还有去掉每次 SSH 都需要先输入 Yes</p><h2><span id="批量打通所有机器之间的-ssh-登录免密码">批量打通所有机器之间的 SSH 登录免密码</span></h2><p><strong>Expect 在有些公司是被禁止的</strong></p><p>SSH 免密码的原理是将本机的 Pubkey 复制到目标机器的 <code>~/.ssh/authorized_keys</code> 里面。可以手工复制粘贴，也可以 ssh-copy-id 等。</p><p>如果有 100 台机器，互相两两打通还是比较费事（大概需要100*99次 copy key）。 下面通过 expect 来解决输入密码，然后配合 Shell 脚本来批量解决这个问题。</p><p><img src="https://img.hi-linux.com/staticfile/OkaCp5-2024-01-22-dxXOti.png" alt></p><p>这个脚本需要四个参数：目标IP、用户名、密码、Home 目录，也就是 SSH 到一台机器的时候帮我们自动填上 yes，和密码，这样就不需要人肉一个个输入了。</p><p>再在外面写一个循环对每个 IP 执行如下操作：</p><p><img src="https://img.hi-linux.com/staticfile/S3qQYl-2024-01-22-BqCQTy.png" alt></p><p>if 代码部分检查本机 ~/.ssh/ 下有没有 id_rsa.pub，也就是是否以前生成过密钥对，没生成的话就帮忙生成一次。</p><p>for 循环部分一次把生成的密钥对和 authorized_keys 复制到所有机器上，这样所有机器之间都不需要输入密码就能互相登陆了（当然本机也不需要输入密码登录所有机器）</p><p>最后一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh $user@$n &quot;hostname -i&quot;</span><br></pre></td></tr></table></figure><p>验证一下没有输密码是否能成功 SSH 上去。</p><p><strong>思考一下，为什么这么做就可以打通两两之间的免密码登录，这里没有把所有机器的 PubKey 复制到其他所有机器上去啊</strong></p><blockquote><p>答案：其实这个脚本做了一个取巧投机的事，那就是让所有机器共享一套公钥、私钥。<br>有时候我也会把我的 Windows 笔记本和我专用的某台虚拟机共享一套秘钥，这样任何新申请的机器打通一次账号就可以在两台机器上随便登录。请保护好自己的私钥</p></blockquote><p>如果免密写入 authorized_keys 成功，但是通过 SSH Pubkey 认证的时候还是有可能失败，这是因为 Pubkey 认证要求：</p><ul><li>authorized_keys  文件权限要对</li><li>.ssh 文件夹权限要对</li><li>/home/user 文件夹权限要对 ----这个容易忽视掉</li></ul><h2><span id="留个作业第一次-ssh-某台机器的时候总是出来一个警告需要-yes-确认才能往下走怎么干掉他">留个作业：第一次 SSH 某台机器的时候总是出来一个警告，需要 Yes 确认才能往下走，怎么干掉他？</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; StrictHostKeyChecking&#x3D;no</span><br><span class="line">&gt; UserKnownHostsFile&#x3D;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p><strong>这里只是帮大家入门了解 SSH ，掌握好这些配置文件和 -vvv 后有好多好玩的可以去挖掘，同时也请在留言中说出你的黑技能</strong></p><h2><span id="~sshconfig-参考配置">~/.ssh/config 参考配置</span></h2><p>下面是我个人常用的 SSH Config 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat ~/.ssh/config</span></span><br><span class="line"><span class="meta">#</span><span class="bash">GSSAPIAuthentication=no</span></span><br><span class="line">StrictHostKeyChecking=no</span><br><span class="line"><span class="meta">#</span><span class="bash">TCPKeepAlive=yes</span></span><br><span class="line">CheckHostIP=no</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"ServerAliveInterval [seconds]"</span> configuration <span class="keyword">in</span> the SSH configuration so that your ssh client sends a <span class="string">"dummy packet"</span> on a regular interval so that the router thinks that the connection is active even <span class="keyword">if</span> it<span class="string">'s particularly quiet</span></span></span><br><span class="line">ServerAliveInterval=15</span><br><span class="line"><span class="meta">#</span><span class="bash">ServerAliveCountMax=6</span></span><br><span class="line">ForwardAgent=yes</span><br><span class="line"></span><br><span class="line">UserKnownHostsFile /dev/null</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">reuse the same connection</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath /tmp/ssh_mux_%h_%p_%r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">keep one connection <span class="keyword">in</span> 72hour</span></span><br><span class="line">ControlPersist 72h</span><br><span class="line"></span><br><span class="line">Host 192.168.1.*</span><br><span class="line">ProxyCommand ssh user@us.jump exec /usr/bin/nc %h %p 2&gt;/dev/null</span><br><span class="line">Host 192.168.2.*</span><br><span class="line">ProxyCommand ssh user@cn.jump exec /usr/bin/nc %h %p 2&gt;/dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash">ProxyCommand /bin/nc -x localhost:12346 %h %p</span></span><br><span class="line"></span><br><span class="line">Host 172</span><br><span class="line">    HostName 10.172.1.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump root@1.2.3.4:12345</span><br><span class="line"></span><br><span class="line">Host 176</span><br><span class="line">    HostName 10.176.1.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump admin@1.2.3.4:12346</span><br><span class="line">    </span><br><span class="line">Host 10.5.*.*, 10.*.*.*</span><br><span class="line">    port 22</span><br><span class="line">user root</span><br><span class="line">ProxyJump plantegg@1.2.3.4:12347</span><br></pre></td></tr></table></figure><p>ProxyJump 完全可以取代 ProxyCommand，比如 ProxyJump 不再依赖 nc、也更灵活一些。</p><h2><span id="etcsshssh_config-参考配置">/etc/ssh/ssh_config 参考配置</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">Protocol 2</span><br><span class="line">ServerAliveInterval 30</span><br><span class="line">User admin</span><br><span class="line"></span><br><span class="line">host 10.10.55.*</span><br><span class="line">ProxyCommand ssh -l admin admin.jump  exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line"># uos is a hostname</span><br><span class="line">Host 10.10.1.13* 192.168.2.133 uos</span><br><span class="line">ProxyCommand ssh -l root -p 54900 1.1.1.1 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line">#debug for git proxy</span><br><span class="line">Host github.com</span><br><span class="line">#    LogLevel DEBUG3</span><br><span class="line">#    ProxyCommand ssh  -l root gfw.jump exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line">#    ProxyCommand ssh -oProxyCommand&#x3D;&#39;ssh -l admin gfw.jump:22&#39; -l root gfw.jump2 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ForwardAgent yes</span><br><span class="line">ForwardX11 yes</span><br><span class="line">ForwardX11Trusted yes</span><br><span class="line"></span><br><span class="line">    SendEnv LANG LC_*</span><br><span class="line">    HashKnownHosts yes</span><br><span class="line">    GSSAPIAuthentication no</span><br><span class="line">    GSSAPIDelegateCredentials no</span><br><span class="line">    Compression yes</span><br></pre></td></tr></table></figure><h2><span id="其他知识点">其他知识点</span></h2><p>参数的优先级是：<strong>命令行配置选项 &gt; ~/.ssh/config &gt; /etc/ssh/ssh_config</strong></p><p>在 SSH 的 <strong>身份验证阶段，SSH只支持服务端保留公钥，客户端保留私钥的方式</strong>，所以方式只有两种：客户端生成密钥对，将公钥分发给服务端；服务端生成密钥对，将私钥分发给客户端。只不过出于安全性和便利性，一般都是客户端生成密钥对并分发公钥（阿里云服务器秘钥对–服务器将一对密钥中的公钥放在 authorized_keys, 私钥给client登陆用）</p><p>服务器上的 <code>/etc/ssh/ssh_host*</code> 是用来验证服务器身份的秘钥对（对应 Client的 Known_hosts), <strong>在主机验证阶段，服务端持有的是私钥，客户端保存的是来自于服务端的公钥。注意，这和身份验证阶段密钥的持有方是相反的。</strong></p><p>SSH 支持多种身份验证机制，<strong>它们的验证顺序如下：gssapi-with-mic,hostbased,publickey,keyboard-interactive,password</strong>，但常见的是密码认证机制 (password) 和公钥认证机制 (public key). 当公钥认证机制未通过时，再进行密码认证机制的验证。这些认证顺序可以通过 SSH 配置文件(注意，不是sshd 的配置文件)中的指令 PreferredAuthentications 改变。</p><h3><span id="永久隧道">永久隧道</span></h3><p>大多时候隧道会失效，或者断开，我们需要有重连机制，一般可以通过 autossh（需要单独安装）搞定自动重连，再配合 Systemd 或者 Crond 搞定永久自动重连</p><p>比如以下代码在 gf 开启 2 个远程转发端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">remote_port&#x3D;(30081 30082)</span><br><span class="line">for port in &quot;$&#123;remote_port[@]&#125;&quot;</span><br><span class="line">do</span><br><span class="line">    line&#x3D;&#96;ps aux |grep ssh |grep $port | wc -l&#96;</span><br><span class="line">    if [[ &quot;$line&quot; -lt 1 ]]; then</span><br><span class="line">        autossh -M 0 -fNR gf:$port:127.0.0.1:22 root@gf</span><br><span class="line">    fi;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">line&#x3D;&#96;ps aux |grep ssh |grep 13129 | wc -l&#96;</span><br><span class="line">if [[ &quot;$line&quot; -lt 1 ]]; then</span><br><span class="line">    nohup ssh -fNR gf:13129:172.16.1.2:3129 root@gf</span><br><span class="line">fi;</span><br><span class="line"></span><br><span class="line">#cat &#x2F;etc&#x2F;cron.d&#x2F;jump</span><br><span class="line">#* * * * * root sh &#x2F;root&#x2F;drds_private_cloud&#x2F;jump.sh</span><br></pre></td></tr></table></figure><p>或者另外创建一个 Service 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;AutoSSH tunnel on 31081 to gf server</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment&#x3D;&quot;AUTOSSH_GATETIME&#x3D;0&quot;</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;autossh -M 0 -q -N -o &quot;ServerAliveInterval 60&quot; -o &quot;ServerAliveCountMax 3&quot; -NR gf:31081:172.16.1.2:22 -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa root@gf</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><h3><span id="调试-ssh终极大招">调试 SSH–终极大招</span></h3><p>好多问题我都是 Debug 发现的</p><ul><li>客户端增加参数 -vvv 会把所有流程在控制台显示出来。卡在哪个环节；密码不对还是 Key 不对一看就知道</li><li>server 端还可以：<code>/usr/sbin/sshd -ddd -p 2222</code> 在 2222 端口对 sshd 进行 Debug，看输出信息验证为什么 pubkey 不能 Login 等. 一般都是权限不对，/root 以及 /root/.ssh 文件夹的权限和owner都要对，更不要说 /root/.ssh/authorized_keys 了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;sshd -ddd -p 2222</span><br></pre></td></tr></table></figure><h3><span id="ssh-提示信息"></span></h3><p>可以用一下脚本生成一个彩色文件，放到 /etc/motd 中就行</p><p>Basic colors are numbered:</p><ul><li>1 – Red</li><li>2 – Green</li><li>3 – Yellow</li><li>4 – Blue</li><li>5 – Magenta</li><li>6 – Cyan</li><li>7 – White</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">export TERM=xterm-256color</span><br><span class="line"></span><br><span class="line">read one five fifteen rest &lt; /proc/loadavg</span><br><span class="line">echo "$(tput setaf 2)</span><br><span class="line">Kernel: `uname -v | awk -v OFS=' ' '&#123;print $4, $5&#125;'`</span><br><span class="line">                                                                                                                                   </span><br><span class="line">        \\   ^__^</span><br><span class="line">         \\  (oo)\\_______</span><br><span class="line">            (__)\\       )\\\/\\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br><span class="line"></span><br><span class="line">本机器为长稳测试环境, 千万不要kill进程, 不要跑负载过重的任务</span><br><span class="line"></span><br><span class="line">有任何需要请联系 ** 多谢!</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput setaf 4)Load Averages......: <span class="variable">$&#123;one&#125;</span>, <span class="variable">$&#123;five&#125;</span>, <span class="variable">$&#123;fifteen&#125;</span> (1, 5, 15 min)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput setaf 5)</span></span><br><span class="line"> ______________</span><br><span class="line">本机器为长稳测试环境, 千万不要kill进程, 不要跑负载过重的任务</span><br><span class="line"></span><br><span class="line">有任何需要请联系 ** 多谢!</span><br><span class="line"> --------------</span><br><span class="line">        \\   ^__^</span><br><span class="line">         \\  (oo)\\_______</span><br><span class="line">            (__)\\       )\\\/\\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput sgr0)<span class="string">"</span></span></span><br></pre></td></tr></table></figure><p>以上脚本运行结果</p><p><img src="https://img.hi-linux.com/staticfile/8Hcheo-2024-01-22-Cpn0tg.png" alt></p><h3><span id="sshd-banner">SSHD Banner</span></h3><p><code>Banner</code>指定用户登录后，sshd 向其展示的信息文件（<code>Banner /usr/local/etc/warning.txt</code>），默认不展示任何内容。</p><p>或者配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"># no default banner path</span><br><span class="line">#Banner none</span><br><span class="line">#在配置文件末尾添加Banner &#x2F;etc&#x2F;ssh&#x2F;my_banner这一行内容：</span><br><span class="line">Banner &#x2F;etc&#x2F;ssh&#x2F;my_banner</span><br></pre></td></tr></table></figure><p><code>/etc/ssh/my_banner</code> 中可以放置提示内容。</p><h3><span id="验证秘钥对">验证秘钥对</span></h3><p><strong>-y</strong> Read a private OpenSSH format file and print an OpenSSH public key to stdout.</p><blockquote><p>cd ~/.ssh/ ; ssh-keygen -y -f id_rsa | cut -d’ ’ -f 2  ;  cut -d’ ’ -f 2 id_rsa.pub</p></blockquote><p><code>ssh-keygen -y -e -f &lt;private key&gt;</code>获取一个私钥并打印相应的公钥，该公钥可以直接与您可用的公钥进行比较</p><h3><span id="github-上你的公钥">Github 上你的公钥</span></h3><p>Github 可以取到你的公钥，如果别人让你查看他的服务器，直接给 <a href="https://github.com/plantegg.keys" target="_blank" rel="noopener">https://github.com/plantegg.keys</a> 这个链接，让他把下载的 Key 加到 ~/.ssh/authorized_keys 里面就行了。</p><h3><span id="通过-ssh-keygen-生成公钥">通过 ssh-keygen 生成公钥</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &lt;&lt;&lt;y</span><br><span class="line">ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &lt;&lt;&lt;y &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">//修改 Passphrase</span><br><span class="line">ssh-keygen -p -P "12345" -N "abcde" -f .ssh/id_rsa</span><br><span class="line">//ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]</span><br><span class="line">//或者直接通过提示一步步修改：</span><br><span class="line">ssh-keygen -p</span><br></pre></td></tr></table></figure><p>删除或者修改 Passphrase</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; run &#96;ssh-keygen -p&#96; in a terminal. It will then prompt you for a keyfile (defaulted to the correct file for me, &#96;~&#x2F;.ssh&#x2F;id_rsa&#96;), the old passphrase (enter what you have now) and the new passphrase (enter nothing). </span><br><span class="line"></span><br><span class="line">[要注意 OpenSSH 不同版本使用的不同 format](https:&#x2F;&#x2F;www.ibm.com&#x2F;support&#x2F;pages&#x2F;openssl-wont-understand-rsa-keys-rfc4716-format)，用 OpenSSH 8.0 默认用 &quot;RFC4716&quot; 格式，老的 4.0 默认是 PKCS8 格式</span><br><span class="line"></span><br><span class="line">去修改 DSA 密钥后 Openssh 4.0 不认。 </span><br><span class="line"></span><br><span class="line">&gt; -m key_format</span><br><span class="line">&gt;         Specify a key format for the -i (import) or -e (export) conversion options.  The sup‐</span><br><span class="line">&gt;         ported key formats are: “RFC4716” (RFC 4716&#x2F;SSH2 public or private key), “PKCS8” (PEM</span><br><span class="line">&gt;         PKCS8 public key) or “PEM” (PEM public key).  The default conversion format is</span><br><span class="line">&gt;         “RFC4716”.</span><br></pre></td></tr></table></figure><p>如果用 8.0 去修改 PKCS8 格式的 key 可以指定格式参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p  -m &quot;PKCS8&quot; -f .&#x2F;id_dsa</span><br></pre></td></tr></table></figure><h3><span id="ssh-agent">SSH-Agent</span></h3><p>私钥设置了密码以后，每次使用都必须输入密码，有时让人感觉非常麻烦。比如，连续使用<code>scp</code>命令远程拷贝文件时，每次都要求输入密码。</p><p><code>ssh-agent</code>命令就是为了解决这个问题而设计的，它让用户在整个 Bash 对话（session）之中，只在第一次使用 SSH 命令时输入密码，然后将私钥保存在内存中，后面都不需要再输入私钥的密码了。</p><p>第一步，使用下面的命令新建一次命令行对话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval &#96;ssh-agent&#96;</span><br></pre></td></tr></table></figure><p>上面命令中，<code>ssh-agent</code> 会先自动在后台运行，并将需要设置的环境变量输出在屏幕上，类似下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent</span><br><span class="line">SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-barrett&#x2F;ssh-22841-agent; export SSH_AUTH_SOCK;</span><br><span class="line">SSH_AGENT_PID&#x3D;22842; export SSH_AGENT_PID;</span><br><span class="line">echo Agent pid 22842;</span><br></pre></td></tr></table></figure><p><code>eval</code>命令的作用，就是运行上面的 <code>ssh-agent</code> 命令的输出，设置环境变量。</p><p>第二步，在新建的 Shell 对话里面，使用 <code>ssh-add</code> 命令添加默认的私钥（比如<code>~/.ssh/id_rsa</code>，或<code>~/.ssh/id_dsa</code>，或<code>~/.ssh/id_ecdsa</code>，或<code>~/.ssh/id_ed25519</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add</span><br><span class="line">Enter passphrase for &#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa: ********</span><br><span class="line">Identity added: &#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa (&#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa)</span><br></pre></td></tr></table></figure><p>上面例子中，添加私钥时，会要求输入密码。以后，在这个对话里面再使用密钥时，就不需要输入私钥的密码了，因为私钥已经加载到内存里面了。</p><p>如果添加的不是默认私钥，<code>ssh-add</code>命令需要显式指定私钥文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add my-other-key-file</span><br></pre></td></tr></table></figure><p>上面的命令中，<code>my-other-key-file</code>就是用户指定的私钥文件。</p><p>SSH agent 程序能够将您的已解密的私钥缓存起来，在需要的时候用它来解密key chanllge返回给 SSHD  <a href="https://webcache.googleusercontent.com/search?q=cache:7OfvSBFki10J:https://www.ibm.com/developerworks/cn/linux/security/openssh/part2/+&amp;cd=7&amp;hl=en&amp;ct=clnk&amp;gl=hk" target="_blank" rel="noopener">https://webcache.googleusercontent.com/search?q=cache:7OfvSBFki10J:https://www.ibm.com/developerworks/cn/linux/security/openssh/part2/+&amp;cd=7&amp;hl=en&amp;ct=clnk&amp;gl=hk</a> keychain介绍</p><h3><span id="安装-sshd-和-debug">安装 sshd 和 debug</span></h3><p>sshd 有自己的一对或多对密钥。它使用密钥向客户端证明自己的身份。所有密钥都是公钥和私钥成对出现，公钥的文件名一般是私钥文件名加上后缀<code>.pub</code>。</p><p>DSA 格式的密钥文件默认为 <code>/etc/ssh/ssh_host_dsa_key</code>（公钥为<code>ssh_host_dsa_key.pub</code>），RSA 格式的密钥为 <code>/etc/ssh/ssh_host_rsa_key</code>（公钥为 <code>ssh_host_rsa_key.pub</code>）。如果需要支持 SSH 1 协议，则必须有密钥<code>/etc/ssh/ssh_host_key</code>。</p><p>如果密钥不是默认文件，那么可以通过配置文件 <code>sshd_config</code> 的 <code>HostKey</code> 配置项指定。默认密钥的 <code>HostKey</code> 设置如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># HostKey for protocol version 1</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_key</span><br><span class="line"></span><br><span class="line"># HostKeys for protocol version 2</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_key</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_dsa_ke</span><br></pre></td></tr></table></figure><p>注意，如果重装 sshd，<code>/etc/ssh</code>下的密钥都会重新生成（这些密钥对用于验证Server的身份），导致客户端重新 ssh 连接服务器时，会跳出警告，拒绝连接。为了避免这种情况，可以在重装 sshd 时，先备份<code>/etc/ssh</code>目录，重装后再恢复这个目录。</p><blockquote><p>调试：非后台(-D)和debug(-d)模式启动sshd，同时监听2222和3333端口</p><p>sshd -D -d -p 2222 -p 3333</p></blockquote><p>sshd config 配置多端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line">Port 22022</span><br><span class="line">Port 22</span><br><span class="line">#AddressFamily any</span><br><span class="line">#ListenAddress 0.0.0.0</span><br></pre></td></tr></table></figure><h3><span id="scp-设置-socks-代理">Scp 设置 socks 代理</span></h3><blockquote><p>scp -o “ProxyCommand=nc -X 5 -x <strong>[SOCKS_HOST]</strong>:<strong>[SOCKS_PORT]</strong> %h %p” <strong>[LOCAL/FILE/PATH]</strong> <strong>[REMOTE_USER]</strong>@<strong>[REMOTE_HOST]</strong>:<strong>[REMOTE/FILE/PATH]</strong></p></blockquote><p>其中[SOCKS_HOST]和[SOCKS_PORT]是 Socks 代理的 LOCAL_ADDRESS 和 LOCAL_PORT。[LOCAL/FILE/PATH]、[REMOTE_USER]、[REMOTE_HOST]和[REMOTE/FILE/PATH] 分别是要复制文件的本地路径、要复制到的远端主机的用户名、要复制到的远端主机名、要复制文件的远端路径，这些参数与不使用代理时一样。“ProxyCommand=nc” 表示当前运行命令的主机上需要有 nc 命令。</p><h3><span id="proxycommand">ProxyCommand</span></h3><blockquote><p>Specifies the proxy command for the connection. This command is launched prior to making the connection to Hostname. %h is replaced with the host defined in HostName and %p is replaced with 22 or is overridden by a Port directive.</p></blockquote><p>在 SSH 连接目标主机前先执行 ProxyCommand 中的命令，比如 <code>.ssh/config</code> 中有如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">host remote-host</span><br><span class="line">ProxyCommand ssh -l root -p 52146 1.2.3.4 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以上配置等价下面的命令</span><br><span class="line">ssh -o ProxyCommand&#x3D;&quot;ssh -l root -p 52146 1.2.3.4 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p&quot; remote-host</span><br><span class="line">&#x2F;&#x2F;or 等价</span><br><span class="line">ssh -o ProxyCommand&#x3D;&quot;ssh -l root -p 52146 -W %h:%p 1.2.3.4 &quot; remote-host</span><br><span class="line">&#x2F;&#x2F;or 等价 debug1: Setting implicit ProxyCommand from ProxyJump: ssh -l root -p 52146 -vvv -W &#39;[%h]:%p&#39; 1.2.3.4</span><br><span class="line">ssh -J root@1.2.3.4:52146 remote-host</span><br></pre></td></tr></table></figure><p>如上配置指的是，如果执行ssh remote-host 命中host规则，那么先执行命令 ssh -l root -p 52146 1.2.3.4 exec /usr/bin/nc 同时把remote-host和端口(默认22)传给nc</p><p>ProxyCommand 和 ProxyJump 很类似，ProxyJump 使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ssh到centos8机器上，走的是gf这台跳板机，本地一般和centos8不通</span><br><span class="line">ssh -J gf:22 centos8</span><br></pre></td></tr></table></figure><h3><span id="proxyjump">ProxyJump</span></h3><p>需要 <code>OpenSSH 7.3</code> 以上版本才可以使用 <code>ProxyJump</code>, 相对 ProxyCommand 更简洁方便些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ssh 116 就可以通过 jumpserver:50023 连上 root@1.116.2.1:22</span><br><span class="line">Host 116</span><br><span class="line">    HostName 1.116.2.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump admin@jumpserver:50023</span><br><span class="line"></span><br><span class="line">#ssh 1.112.任意ip 都会默认走 jumpserver 跳转过去</span><br><span class="line">Host 1.112.*.*</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump root@jumpserver</span><br></pre></td></tr></table></figure><h3><span id="加密算法"></span></h3><p>列出本地所支持默认的加密算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#ssh -Q key                                                            </span><br><span class="line">ssh-ed25519</span><br><span class="line">ssh-ed25519-cert-v01@openssh.com</span><br><span class="line">ssh-rsa</span><br><span class="line">ssh-dss</span><br><span class="line">ecdsa-sha2-nistp256</span><br><span class="line">ecdsa-sha2-nistp384</span><br><span class="line">ecdsa-sha2-nistp521</span><br><span class="line">ssh-rsa-cert-v01@openssh.com</span><br><span class="line">ssh-dss-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp256-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp384-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp521-cert-v01@openssh.com</span><br><span class="line"></span><br><span class="line">ssh -Q cipher       # List supported ciphers</span><br><span class="line">ssh -Q mac          # List supported MACs</span><br><span class="line">ssh -Q key          # List supported public key types</span><br><span class="line">ssh -Q kex          # List supported key exchange algorithms</span><br></pre></td></tr></table></figure><p>比如连服务器报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug1: kex: algorithm: (no match)</span><br><span class="line">Unable to negotiate with server port 22: no matching key exchange method found. Their offer: diffie-hellman-group1-sha1,diffie-hellman-group14-sha1</span><br></pre></td></tr></table></figure><p>表示服务端支持 diffie-hellman-group1-sha1,diffie-hellman-group14-sha1 加密，但是client端不支持，那么可以指定算法来强制client端使用某种和server一致的加密方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh  -oKexAlgorithms&#x3D;+diffie-hellman-group14-sha1 -l user</span><br><span class="line"></span><br><span class="line">或者config中配置：</span><br><span class="line">host server_ip</span><br><span class="line">KexAlgorithms +diffie-hellman-group1-sha1</span><br></pre></td></tr></table></figure><p>如果仍然报以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debug2: first_kex_follows 0</span><br><span class="line">debug2: reserved 0</span><br><span class="line">debug1: kex: algorithm: diffie-hellman-group14-sha1</span><br><span class="line">debug1: kex: host key algorithm: (no match)</span><br><span class="line">Unable to negotiate with server_ip port 22: no matching host key type found. Their offer: ssh-rsa</span><br></pre></td></tr></table></figure><p>那么可以配置来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">    HostKeyAlgorithms +ssh-rsa</span><br><span class="line">    PubkeyAcceptedKeyTypes +ssh-rsa</span><br></pre></td></tr></table></figure><p>When an SSH client connects to a server, each side offers lists of connection parameters to the other. These are, with the corresponding <a href="https://man.openbsd.org/ssh_config.5" target="_blank" rel="noopener">ssh_config</a> keyword:</p><ul><li><code>KexAlgorithms</code>: the key exchange methods that are used to generate per-connection keys</li><li><code>HostkeyAlgorithms</code>: the public key algorithms accepted for an SSH server to authenticate itself to an SSH client</li><li><code>Ciphers</code>: the ciphers to encrypt the connection</li><li><code>MACs</code>: the message authentication codes used to detect traffic modification</li></ul><h2><span id="无所不能的-ssh-三大转发模式">无所不能的 SSH 三大转发模式</span></h2><p>了解完前面的一些小知识，再来看看无所不能的三大杀招。上面的各种代理基本都是由这三种转发模式实现的。</p><p>SSH 能够做动态转发、本地转发、远程转发。先简要概述下他们的特点和使用场景</p><p><strong><a href="https://www.skywind.me/blog/archives/2546" target="_blank" rel="noopener">三个转发模式的比较</a>：</strong></p><ul><li>动态转发完全可以代替本地转发，只是动态转发是 <code>socks5协议</code>，当正确上网用，本地转发是 TCP 协议</li><li>本地转发完全是把动态转发特例化到访问某个固定目标的转发，类似 Iptable 的 Port Forwarding</li><li>远程转发是启动转端口的机器同时连上两端的两个机器，把本来不连通的两端拼接起来，中间显得多了个节点。</li><li>三个转发模式可以串联使用</li></ul><p>动态转发常用来正确上网，本地转发用来打洞，这两种转发启动的端口都是在本地；远程转发也是打洞的一种，只不过启用的端口在远程机器上。</p><p><img src="https://img.hi-linux.com/staticfile/sKbEgK-2024-01-22-mnPbqn.png" alt></p><h3><span id="动态转发-d-socks5-协议">动态转发 (-D)  SOCKS5 协议</span></h3><p>动态转发指的是，本机与 SSH 服务器之间创建了一个加密连接，然后本机内部针对某个端口的通信，都通过这个加密连接转发。它的一个使用场景就是，访问所有外部网站，都通过 SSH 转发。</p><p>动态转发需要把本地端口绑定到 SSH 服务器。<strong>至于 SSH 服务器要去访问哪一个网站，完全是动态的，取决于原始通信，所以叫做动态转发</strong>。</p><p>动态的意思就是：需要访问的目标、端口还不确定。后面要讲的本地转发、远程转发都是针对具体 IP、Port 的转发。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -D 4444 ssh-server -N</span></span><br><span class="line">//或者如下方式：</span><br><span class="line">nohup ssh -qTfnN -D *:13658 root@jump vmstat 10  &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>注意，这种转发采用了 SOCKS5 协议。访问外部网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。<code>-N</code>参数表示，这个 SSH 连接不能执行远程命令，只能充当隧道。</p><p><img src="https://img.hi-linux.com/staticfile/8wIxNP-2024-01-22-qJOasK.png" alt></p><p>下面是 SSH  隧道建立后的一个<strong>使用实例</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -x socks5://localhost:4444 http://www.example.com</span><br><span class="line">or</span><br><span class="line">curl --socks5-hostname localhost:4444 https://www.twitter.com</span><br></pre></td></tr></table></figure><p>上面命令中，curl 的 <code>-x</code> 参数指定代理服务器，即通过 SOCKS5 协议的本地<code>3000</code>端口，访问<code>http://www.example.com</code>。</p><p>官方文档关于 <code>-D</code> 的介绍</p><blockquote><p>-D [bind_address:]port<br>Specifies a local “dynamic” application-level port forwarding.  This works by allocat‐<br>ing a socket to listen to port on the local side, optionally bound to the specified<br>bind_address.  Whenever a connection is made to this port, the connection is forwarded<br>over the secure channel, and the application protocol is then used to determine where<br>to connect to from the remote machine.  Currently the SOCKS4 and SOCKS5 protocols are<br>supported, and ssh will act as a SOCKS server.  Only root can forward privileged ports.<br>Dynamic port forwardings can also be specified in the configuration file.</p></blockquote><p>特别注意，如果 <code>ssh -D</code> 要启动的本地 Port 已经被占用了是不会报错的，但是实际 Socks 代理会没启动成功。</p><h3><span id="本地转发-l">本地转发 (-L)</span></h3><p>本地转发（Local Forwarding）指的是，SSH 服务器作为中介的跳板机，建立本地计算机与特定<code>目标网站</code>之间的加密连接。本地转发是在本地计算机的 SSH 客户端建立的转发规则。</p><p>典型使用场景就是，打洞，经过跳板机访问无法直接连通的服务。</p><p>它会指定一个本地端口（Local-Port），所有发向那个端口的请求，都会转发到 SSH 跳板机（ssh-server），然后 SSH 跳板机作为中介，将收到的请求发到目标服务器（target-host）的目标端口（target-port）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -L :<span class="built_in">local</span>-port:target-host:target-port ssh-server  //target-host是ssh-server的target-host, target-host 域名解析、路由都是由 ssh-server 完成</span></span><br></pre></td></tr></table></figure><p>上面命令中，<code>-L</code>参数表示本地转发，<code>local-port</code>是本地端口，<code>target-host</code>是你想要访问的目标服务器，<code>target-port</code>是目标服务器的端口，<code>ssh-server</code> 是 SSH 跳板机。当你访问 localhost:local-port 的时候会通过 ssh-server 把请求转给 target-host:target-port</p><p><img src="https://img.hi-linux.com/staticfile/INjeHZ-2024-01-22-EWAI33.png" alt></p><p>上图对应的命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 53682:remote-server:53682 ssh-server</span><br></pre></td></tr></table></figure><p>然后，访问本机的 53682 端口，就是访问 <code>remote-server</code> 的 53682 端口.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;localhost:53682</span><br></pre></td></tr></table></figure><p>注意，<strong>本地端口转发采用 HTTP 协议，不用转成 SOCKS5 协议</strong>。如果需要 HTTP 的动态代理，可以先起 Socks5 动态代理，然后再起一个本地转发给动态代理的 Socks5 端口，这样就有一个 HTTP 代理了，能给 Yum、Docker 之类的使用。</p><p>这个命令最好加上<code>-N</code>参数，表示不在 SSH 跳板机执行远程命令，让 SSH 只充当隧道。另外还有一个<code>-f</code>参数表示 SSH 连接在后台运行。</p><p>如果经常使用本地转发，可以将设置写入 SSH 客户端的用户个人配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host test.example.com</span><br><span class="line">LocalForward client-IP:client-port server-IP:server-port</span><br></pre></td></tr></table></figure><h3><span id="远程转发-r">远程转发(-R)</span></h3><p>远程端口指的是在远程 SSH 服务器建立的转发规则。主要是执行 SSH 转发的机器别人连不上，所以需要一台 Client 能连上的机器当远程转发端口，要不就是本地转发了。</p><p>由于本机无法访问内网 SSH 跳板机，就无法从外网发起 SSH 隧道，建立端口转发。必须反过来，从 SSH 跳板机发起隧道，建立端口转发，这时就形成了远程端口转发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -fNR 30.1.2.3:30081:166.100.64.1:3128 root@30.1.2.3 -p 2728</span><br></pre></td></tr></table></figure><p>上面的命令，首先需要注意，<strong>不是在 30.1.2.3 或者 166.100.64.1 上执行的，而是找一台能联通 30.1.2.3 和 166.100.64.1 的机器来执行</strong>，在执行前 Remote Clients 能连上 30.1.2.3 但是 30.1.2.3 和 166.100.64.1 不通，所以需要一个中介将 30.1.2.3 和166.100.64.1打通，这个中介就是下图中的MobaXterm所在的机器，命令在 MobaXterm 机器上执行</p><p><img src="https://img.hi-linux.com/staticfile/PER8yY-2024-01-22-IvkyqB.png" alt></p><p>执行上面的命令以后，跳板机 30.1.2.3 到 166.100.64.1 的隧道已经建立了，这个隧道是依赖两边都能连通的 MobaXterm 机器。然后，就可以从 Remote Client 访问目标服务器了，即在 Remote Client 上执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;30.1.2.3:30081</span><br></pre></td></tr></table></figure><p>执行上面的命令以后，命令就会输出服务器 166.100.64.1 的3128端口返回的内容。</p><p>如果经常执行远程端口转发，可以将设置写入 SSH 客户端的用户个人配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host test.example.com</span><br><span class="line">RemoteForward local-IP:local-port target-ip:target-port</span><br></pre></td></tr></table></figure><p>注意远程转发需要：</p><blockquote><ol><li>sshd_config 里要打开 <code>AllowTcpForwarding</code> 选项，否则 <code>-R</code> 远程端口转发会失败。</li><li>默认转发到远程主机上的端口绑定的是 <code>127.0.0.1</code>，<a href="https://serverfault.com/questions/997124/ssh-r-binds-to-127-0-0-1-only-on-remote" target="_blank" rel="noopener">如要绑定 <code>0.0.0.0</code> 需要打开 sshd_config 里的 <code>GatewayPorts</code> 选项(然后ssh -R 后加上 *:port )</a>。这个选项如果由于权限没法打开也有办法，可配合 <code>ssh -L</code> 将端口绑定到 <code>0.0.0.0</code>。</li></ol></blockquote><p>开通远程转发后，如果需要动态代理（比如访问所有 Web 服务），那么可以在 30081 端口机器上(30.1.2.3)执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ssh -qTfnN -D *:13658 root@127.0.0.1 -p 30081 vmstat 10  &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>表示在 30081 机器上(30.1.2.3)启动了一个 Socks5 动态代理服务</p><h2><span id="调试转发-代理是否能联通">调试转发、代理是否能联通</span></h2><h3><span id="通过-curl-调试"></span></h3><blockquote><p>curl -I --socks5-hostname localhost:13659 <a href="http://twitter.com" target="_blank" rel="noopener">twitter.com</a></p><p>curl -x socks5://localhost:13659 <a href="http://twitter.com" target="_blank" rel="noopener">twitter.com</a></p></blockquote><p>Suppose you have a socks5 proxy running on localhost:13659 .</p><p><a href="https://blog.emacsos.com/use-socks5-proxy-in-curl.html" target="_blank" rel="noopener">In curl &gt;= 7.21.7, you can use</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -x socks5h://localhost:13659 http://www.google.com/</span><br></pre></td></tr></table></figure><blockquote><p>In a proxy string, socks5h:// and socks4a:// mean that the hostname is<br>resolved by the SOCKS server. socks5:// and socks4:// mean that the<br>hostname is resolved locally. socks4a:// means to use SOCKS4a, which is<br>an extension of SOCKS4. Let’s make urllib3 honor it.</p></blockquote><p>In curl &gt;= 7.18.0, you can use</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --socks5-hostname localhost:13659 http://www.google.com/</span><br></pre></td></tr></table></figure><p><code>--proxy</code> 参数含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The --socks5 option is basically considered obsolete since curl 7.21.7. This is because starting in that release, you can now specify the proxy protocol directly in the string that you specify the proxy host name and port number with already. The server you specify with --proxy. If you use a socks5:&#x2F;&#x2F; scheme, curl will go with SOCKS5 with local name resolve but if you instead use socks5h:&#x2F;&#x2F; it will pick SOCKS5 with proxy-resolved host name.</span><br></pre></td></tr></table></figure><h3><span id="wget">wget</span></h3><p><strong>指定命令行参数</strong>,通过命令行指定 HTTP 代理服务器的方式如下：</p><blockquote><p>wget -Y on -e “http_proxy=http://<strong>[HTTP_HOST]</strong>:<strong>[HTTP_PORT]</strong>” <a href="http://facebook.com/" target="_blank" rel="noopener">http://facebook.com/</a></p></blockquote><p>其中：[HTTP_HOST]和[HTTP_PORT]是 HTTP Proxy 的 ADDRESS 和 PORT。</p><ul><li>-Y 表示是否使用代理，on表示使用代理。</li><li>-e 执行后面跟的命令，相当于在.wgetrc配置文件中添加了一条命令，将 http_proxy 设置为需要使用的代理服务器。</li><li>–limit-rate=2.5k 限制下载速度，进行测试</li></ul><h2><span id="pki-public-key-infrastructure证书">PKI (Public Key Infrastructure)证书</span></h2><p>X.509 只是一种常用的证书格式，一般以PEM编码，PEM 编码的证书通常以 <strong><code>.pem</code>、<code>.crt</code> 或 <code>.cer</code></strong> 为后缀。再次提醒，这只是“通常”情况，实际上某些工具可能并不遵循这些惯例。通过pem证书可以访问需要认证的 HTTPS 服务(比如Etcd、Apiserver 等)</p><ul><li><strong>ASN.1 用于定义数据类型</strong>，例如证书（certificate）和秘钥（key）——就像用 JSON 定义一个 request body —— X.509 用 ASN.1 定义。</li><li>DER 是一组将 ASN.1 编码成二进制（比特和字节）的编码规则（encoding rules）。</li><li>PKCS#7 and PKCS#12 是比 X.509 更大的数据结构（封装格式），也用 ASN.1 定义，其中能包含除了证书之外的其他东西。二者分别在 Java 和 Microsoft 产品中使用较多。</li><li>DER 编码之后是二进制数据，不方便复制粘贴，因此大部分证书都是用 PEM 编码的，它用 base64 对 DER 进行编码，然后再加上自己的 label。</li><li>私钥通常用是 PEM 编码的 PKCS#8 对象，但有时也会用密码来加密。</li></ul><p>通过命令 <code>cat /etc/kubernetes/pki/ca.crt | openssl x509 -text</code> 也可以得到下图信息</p><p><img src="https://img.hi-linux.com/staticfile/6ET22D-2024-01-22-hjfjim.png" alt></p><h3><span id="公钥-私钥常见扩展名">公钥、私钥常见扩展名</span></h3><ul><li>公钥：<code>.pub</code> or <code>.pem</code>，<code>ca.crt</code></li><li>私钥：<code>.prv,</code> <code>.key</code>, or <code>.pem</code> , <code>ca.key</code>。</li></ul><h3><span id="证书生成过程演示">证书生成过程演示</span></h3><p>并不是所有的场景都需要向这些大型的 CA 机构申请公钥证书，在任何一个企业，组织或是团体内都可以自己形这样的“小王国”，也就是说，你可以自行生成这样的证书，只需要你自己保证自己的生成证书的私钥的安全，以及不需要扩散到整个互联网。下面，我们用 <code>openssl</code>命令来演示这个过程。</p><ol><li>生成 CA 机构的证书（公钥） <code>ca.crt</code> 和私钥 <code>ca.key</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 \</span><br><span class="line">    -new -nodes -x509 \</span><br><span class="line">    -days 365 \</span><br><span class="line">    -out ca.crt \</span><br><span class="line">    -keyout ca.key \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;SO&#x2F;ST&#x3D;Earth&#x2F;L&#x3D;Mountain&#x2F;O&#x3D;CoolShell&#x2F;OU&#x3D;HQ&#x2F;CN&#x3D;localhost&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>生成 alice 的私钥</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out alice.key 2048</span><br></pre></td></tr></table></figure><ol start="3"><li>生成 Alice 的 CSR – Certificate Signing Request</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key alice.key -days 365 -out alice.csr \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;CN&#x2F;ST&#x3D;Beijing&#x2F;L&#x3D;Haidian&#x2F;O&#x3D;CoolShell&#x2F;OU&#x3D;Test&#x2F;CN&#x3D;localhost.alice&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 CA 给 Alice 签名证书</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl x509  -req -in alice.csr \</span><br><span class="line">    -extfile &lt;(printf &quot;subjectAltName&#x3D;DNS:localhost.alice&quot;) \ </span><br><span class="line">    -CA ca.crt -CAkey ca.key  \</span><br><span class="line">    -days 365 -sha256 -CAcreateserial \</span><br><span class="line">    -out alice.crt</span><br></pre></td></tr></table></figure><h2><span id="参考资料">参考资料：</span></h2><ul><li><a href="http://docs.corp-inc.com/pages/editpage.action?pageId=203555361" target="_blank" rel="noopener">http://docs.corp-inc.com/pages/editpage.action?pageId=203555361</a></li><li><a href="https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/SSH_keys_(简体中文)</a></li><li><a href="https://wangdoc.com/ssh/key.html" target="_blank" rel="noopener">https://wangdoc.com/ssh/key.html</a></li><li><a href="https://robotmoon.com/ssh-tunnels/" target="_blank" rel="noopener">https://robotmoon.com/ssh-tunnels/</a></li><li><a href="https://blog.gwlab.page/vpn-over-ssh-the-socks-proxy-8a8d7bdc7028" target="_blank" rel="noopener">通过SSH动态转发来建立Socks代以及各种场景应用案例</a></li><li><a href="https://daniel.haxx.se/blog/2020/05/26/curl-ootw-socks5/" target="_blank" rel="noopener">https://daniel.haxx.se/blog/2020/05/26/curl-ootw-socks5/</a></li><li><a href="http://www.allanjude.com/bsd/AsiaBSDCon2017_-_SSH_Performance.pdf" target="_blank" rel="noopener">SSH Performance</a></li><li><a href="https://stackoverflow.com/questions/8849240/why-when-i-transfer-a-file-through-sftp-it-takes-longer-than-ftp" target="_blank" rel="noopener">Why when I transfer a file through SFTP, it takes longer than FTP?</a></li><li><a href="https://zhuanlan.zhihu.com/p/413732839" target="_blank" rel="noopener">一行代码解决scp在Internet传输慢的问题</a></li><li><a href="https://www.cnxct.com/everything-about-pki-zh/" target="_blank" rel="noopener">关于证书（certificate）和公钥基础设施（PKI）的一切</a></li><li><a href="https://coolshell.cn/articles/21708.html" target="_blank" rel="noopener">网络数字身份认证术</a></li></ul><blockquote><p>本文转载自：「 plantegg 的博客 」，原文：<a href="http://tinyurl.com/25py66n3" target="_blank" rel="noopener">http://tinyurl.com/25py66n3</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我见过太多的老鸟、新手对 SSH 基本只限于 SSH 到远程机器，实际这个命令我们一天要用很多次，但是对它的了解太少了，他的强大远远超出你的想象。当于你也许会说够用就够了，确实没错，但是你考虑过效率没有，或者还有哪些脑洞大开的功能会让你爱死他，这些功能又仅仅是一行命令就够了。&lt;/p&gt;
&lt;p&gt;疫情期间一行 SSH 命令让我节省了 70% 的出差时间，来，让我们一起走一遍，看看会不会让你大开眼界。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="https://www.hi-linux.com/categories/SSH/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="SSH" scheme="https://www.hi-linux.com/tags/SSH/"/>
    
  </entry>
  
</feed>
