<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇妙的 Linux 世界</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2024-06-03T09:31:47.869Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『极客视界』一站式科技达人综合资讯指南和神秘宝箱，等你来开启</title>
    <link href="https://www.hi-linux.com/posts/22000.html"/>
    <id>https://www.hi-linux.com/posts/22000.html</id>
    <published>2050-06-18T01:00:00.000Z</published>
    <updated>2024-06-03T09:31:47.869Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="️-极客视界科技达人的综合资讯指南">🛠️ 『极客视界』科技达人的综合资讯指南</span></h2><p>你是否常常为寻找最新的技术资讯、工具和资源而感到困扰？或者每次开发时都需要开启无数个标签页，才能找到所需的工具和信息？</p><p>别担心，让我为你介绍一个好地方『极客视界』，这是每位科技达人的福音、必备的综合资讯指南。</p><p>『极客视界』提供了一站式的服务，它包罗万象、功能丰富，直接满足你从资讯获取到开发辅助的全部需求。</p><p>从 GitHub 热榜到 PDF 工具箱，从实时新闻资讯、技术文章到虚拟临时邮箱，样样俱全！</p><a id="more"></a><h3><span id="极客视界">🤓 极客视界</span></h3><p>『极客视界』是一个综合科技资讯的枢纽。如果你喜欢紧跟最新的科技动态、追踪热门项目，或是希望时刻了解技术动向，那这个板块绝对不容错过。</p><h4><span id="github-热榜">🏆 Github 热榜</span></h4><p>每天都有成千上万的项目在 GitHub 上更新，又如何挑选出最热门、最有趣的项目呢？</p><p>别担心，『极客视界』已经为你做了筛选。我们提供的每日更新的 GitHub 热门项目榜单，每天看看就知道哪些项目正火热。</p><p>实时获取最新最火的开源项目，助你快速了解哪些项目正在迅速蹿红，也可以看看有多少大牛在关注同样的项目，再也不用费力翻找。</p><h4><span id="最新-it-新闻和技术文章">📰 最新 IT 新闻和技术文章</span></h4><p>获取行业动态和最新资讯是每个极客的日常标配。在『极客视界』，你能找到最新的 IT 新闻和技术文章。</p><p>我们涵盖了从前沿技术到开发实战，从行业大事件到新兴趋势的一切内容。</p><p>不仅内容丰富，还有专业的编辑团队为你推荐精选文章，让你在最短时间内掌握最有价值的信息。</p><h4><span id="黑客新闻">🧑‍💻 黑客新闻</span></h4><p>这里提供最新、最全的黑客新闻，覆盖广泛的领域。无论是安全漏洞、趋势分析，还是开发者的门道，这里都有。</p><h4><span id="github-热门仓库状态跟踪">📈 Github 热门仓库状态跟踪</span></h4><p>对你关注的热门仓库进行状态跟踪，实时获取更新信息。再也无须手动查询，每天都能知道自己心仪的仓库发生了哪些变化。</p><h4><span id="服务监控">💚 服务监控</span></h4><p>对各种网络服务进行监控，只需轻松设置，关键数据一目了然。实时掌握各种关注服务的状态，确保系统平稳运行。</p><h3><span id="极客秘境">🗞 极客秘境</span></h3><p>这里是技术人的宝藏，包括最新的 IT 新闻、技术文章和深度分析，兼具广度和深度。</p><h4><span id="ai-新世界">🤖 AI 新世界</span></h4><p>这里聚焦人工智能领域的最新资讯和技术动态，想知道 AI 的新突破、新应用，或者最新的研究成果，这里一站搞定。</p><h4><span id="科技周刊汇">📅 科技周刊汇</span></h4><p>每周汇总最具价值的科技新闻，如果你是一周一更新的节奏党，这里绝对不会让你错过任何重要信息。</p><h4><span id="数码潮流">💻 数码潮流</span></h4><p>最新数码产品的资讯和评测，从手机到电脑再到各种智能设备。让你在购买之前就对产品有全面的了解，做个不踩雷的科技买手。</p><h4><span id="知乎热榜">🌐 知乎热榜</span></h4><p>集成知乎的科技热榜，看看大家都在讨论些什么热门话题。知乎神仙们的回答一定会让你豁然开朗。</p><h4><span id="it-之家热榜">🏠 IT 之家热榜</span></h4><p>再也不会错过 IT 之家发布的有趣新闻和深度文章，适合 IT 人必读的榜单，全方位提升知识水平。</p><h4><span id="稀土掘金文章榜">💡 稀土掘金文章榜</span></h4><p>聚集稀土掘金平台的热门技术文章，无论是新工具、新技术，还是各种开发干货，这里都值得一看。</p><h4><span id="hellogithub-热门仓库">🚀 HelloGithub 热门仓库</span></h4><p>专业团队挑选和介绍的 Github 热门仓库，涵盖广泛的编程语言和框架。每期精选，你一定能找到自己感兴趣的项目。</p><h3><span id="it-人必备工具箱">🧰 IT 人必备工具箱</span></h3><p>『IT 人必备工具箱』 是每一位 IT 人都不可或缺的资源宝库，里面收纳着各种专注于技术领域的优质资源和实用工具。</p><p>它如同一座巨大的数字图书馆，为 IT 从业者提供了丰富的资讯和工具。</p><p>让他们在数字世界中驰骋自如，无论是编程开发、网络安全、数据分析还是人工智能。</p><p>这个工具箱都汇聚了各种经典和前沿的资源，为 IT 人士解决难题、提升技能提供了强大的支持。</p><p>无论是初学者还是资深技术大牛，都可以从中汲取灵感，探索未知，不断成长。</p><h3><span id="开发工具箱">🧑‍💻 开发工具箱</span></h3><p>作为开发者，你一定会喜欢我们的开发工具箱。</p><p>这里囊括了各种实用的开发小工具，涵盖了从代码编辑、JSON 解析器、网络调试工具、正则表达式测试器等的一切，应有尽有。</p><p>所有的工具都经过精心挑选和测试，确保能在关键时刻帮到你。减少你在开发过程中寻找工具的时间，提升工作效率。</p><h3><span id="代码图美化">🎨 代码图美化</span></h3><p>代码不仅要运行得好，还要看得美。我们的代码图美化工具，可以将你的一段代码精美地呈现出来。</p><p>它可以帮助你将代码片段转化成美观的图片，它支持高度定制，照顾到每一个细节，让你的代码更具表现力。</p><p>不论是分享给团队成员，还是展示在个人博客上，漂亮的代码图总能让你的工作成果更上一层楼。</p><h3><span id="ip-工具箱">🌍 IP 工具箱</span></h3><p>无论是开发还是运维，IP 信息总是绕不开的问题。『极客视界』为你准备了全面的 IP 工具箱，涵盖从 IP 查找、IP 段查询到地理位置转换等多种功能，让你轻松搞定所有与 IP 相关的难题。</p><p>对于网络管理员和开发者来说，这些功能在日常工作中非常实用。</p><h3><span id="pdf-工具箱">📄 PDF 工具箱</span></h3><p>处理 PDF 文件常常让人头疼，但在『极客视界』这一切都不是问题。我们提供了全方位的 PDF 工具箱，包括 PDF 转换、合并、拆分、压缩等多种功能。</p><p>不管你的需求是什么，这里都有合适的工具帮你搞定，一站解决所有需求，让你轻松应对各种文档格式的转换问题。</p><h3><span id="今日热榜">🔥 今日热榜</span></h3><p>想知道今天哪些内容最火爆？来看看我们的今日热榜吧！这里汇集了各大平台的热门内容，如微博、知乎、抖音等。</p><p>无论是新闻、帖子、视频还是其他内容，最受关注的总能在这里找到。不用再费力刷各大社交媒体，只需一站尽知天下热点，轻松做个潮流达人。</p><h3><span id="虚拟临时邮箱">📫 虚拟临时邮箱</span></h3><p>注册各种网站服务时，常常会担心邮箱被垃圾信息淹没？</p><p>使用我们的虚拟临时邮箱功能吧！它能生成临时邮件地址，帮你保护真实邮箱免受打扰。使用简单方便，一键生成，特别适合短期注册需求。</p><h3><span id="️-手绘画板">🖌️ 手绘画板</span></h3><p>需要临时记录灵感或进行手绘创作？『极客视界』的手绘画板功能正是为你准备的。</p><p>无需下载任何应用，在线即可进行手绘，支持多种笔刷和颜色选择，无论是画草图还是进行简单设计，这里都能得心应手。</p><h3><span id="视频下载">📥 视频下载</span></h3><p>在线遇到好视频想下载，却苦于找不到合适的工具？</p><p>我们提供的在线视频下载工具可以帮你解决这个问题。支持多种视频平台，下载速度快，操作简便，让你轻松保存喜欢的视频内容。</p><h3><span id="️-超级终端">🖥️ 超级终端</span></h3><p>如果你经常需要在的终端工作，这个超级终端你一定会爱不释手。它支持各种命令输出，让你看上去很酷而忙碌，是极客必备的利器。</p><h2><span id="为什么选择极客视界">🤔 为什么选择『极客视界』？</span></h2><h3><span id="集成化一站式服务">🌅 集成化，一站式服务</span></h3><p>无需再奔波于各个网站寻找工具和资讯，『极客视界』将所有常用的开发工具和最新资讯集成在一个平台上，一站式解决你的所有需求。</p><h3><span id="实用性强">📝 实用性强</span></h3><p>我们精心挑选每一项功能和工具，确保它们在实际工作中有用且好用，节省你的时间，提升工作效率。</p><h3><span id="持续更新">📈 持续更新</span></h3><p>科技的发展日新月异，我们的团队时刻关注行业动态，不断更新功能和内容，确保你在『极客视界』获取到最新、最热的资讯和工具。</p><h2><span id="如何开始">🚀 如何开始？</span></h2><p>体验所有这些功能只需一个简单的步骤：访问 <a href="https://bestgeek.org" target="_blank" rel="noopener">https://bestgeek.org</a> 开始你的极客之旅吧！</p><p>然后根据你的需求选择相应的分类开始探索吧！无论你是开发者、设计师还是普通的科技爱好者，『极客视界』都能为你提供你需要的一切。</p><h2><span id="结语">🎉 结语</span></h2><p>上述功能仅仅是『极客视界』的一部分，我们致力于为每一个热爱科技的朋友提供全面的资讯与工具支持。</p><p>『极客视界』不仅是功能齐全的工具和资讯平台，更是每个极客共同的家园。</p><p>在这里，你可以找到志同道合的伙伴，获取最新的技术资讯和最实用的开发工具。让我们一起在这个充满科技乐趣的视界里遨游吧！</p><p>赶快收藏 <a href="https://bestgeek.org" target="_blank" rel="noopener">极客视界</a>，开启你的科技之旅吧！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;🛠️-『极客视界』科技达人的综合资讯指南&quot;&gt;🛠️ 『极客视界』科技达人的综合资讯指南&lt;/h2&gt;
&lt;p&gt;你是否常常为寻找最新的技术资讯、工具和资源而感到困扰？或者每次开发时都需要开启无数个标签页，才能找到所需的工具和信息？&lt;/p&gt;
&lt;p&gt;别担心，让我为你介绍一个好地方『极客视界』，这是每位科技达人的福音、必备的综合资讯指南。&lt;/p&gt;
&lt;p&gt;『极客视界』提供了一站式的服务，它包罗万象、功能丰富，直接满足你从资讯获取到开发辅助的全部需求。&lt;/p&gt;
&lt;p&gt;从 GitHub 热榜到 PDF 工具箱，从实时新闻资讯、技术文章到虚拟临时邮箱，样样俱全！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="IT" scheme="https://www.hi-linux.com/tags/IT/"/>
    
      <category term="程序员" scheme="https://www.hi-linux.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>『IT 人员必备工具箱』：一个专注于 IT 人的优质资源分享导航站</title>
    <link href="https://www.hi-linux.com/posts/53504.html"/>
    <id>https://www.hi-linux.com/posts/53504.html</id>
    <published>2050-03-18T01:00:00.000Z</published>
    <updated>2024-03-14T03:05:50.391Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』是一个专注于 IT 人优质资源分享的导航站，包含大量好玩又实用的 AI、翻译、编程、设计、Linux、网络、云原生、安全等多款应用。</p><p>🏷️  网站地址：<a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a></p><p><img src="https://img.hi-linux.com/staticfile/Tweelet00-2024-03-14-n0S5jR.webp" alt="全站预览图"></p><p>我们的目标是帮助更多 IT 人发现有价值的优质资源，让更多人受益。</p><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』也可以推荐你喜欢的软件和网站呢！如果你有什么好玩有趣又实用的酷软趣站，快『<a href="https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz" target="_blank" rel="noopener">推荐</a>』给我们吧！</p><p>🏷️  趣站酷软推荐收集表: <a href="https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz" target="_blank" rel="noopener">https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz</a></p><a id="more"></a><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』部分截图展示：</p><p><img src="https://img.hi-linux.com/staticfile/Tweelet01-2024-03-14-9hHDLK.png" alt="实用工具"><br><img src="https://img.hi-linux.com/staticfile/Tweelet02-2024-03-14-ejfZrm.png" alt="奇妙的 Linux 世界 + 搜索引擎 + 新闻资讯"><br><img src="https://img.hi-linux.com/staticfile/Tweelet03-2024-03-14-ZkjPxQ.png" alt="电子邮件 + 出行服务 + AI 翻译利器"><br><img src="https://img.hi-linux.com/staticfile/Tweelet04-2024-03-14-NbfprZ.png" alt="AI 新世界 + 云服务"><br><img src="https://img.hi-linux.com/staticfile/Tweelet05-2024-03-14-xTbQV6.png" alt="编程开发"><br><img src="https://img.hi-linux.com/staticfile/Tweelet06-2024-03-14-OvFNBk.png" alt="GitHub 热榜 + 网络调试"><br><img src="https://img.hi-linux.com/staticfile/Tweelet07-2024-03-14-bluwgD.png" alt="绘图设计 + 镜像加速"><br><img src="https://img.hi-linux.com/staticfile/Tweelet08-2024-03-14-G4HEGV.png" alt="云原生容器化 + 安全相关 + 玩转 NixOS + 博客网摘"><br><img src="https://img.hi-linux.com/staticfile/Tweelet09-2024-03-14-FjDHJs.png" alt="职来职往 + 光影时刻 + 音乐之声"><br><img src="https://img.hi-linux.com/staticfile/Tweelet10-2024-03-14-3W7reF.png" alt="趣站酷软"></p><p>📕 关注『<a href="https://mp.weixin.qq.com/s/8iRVr_IN3jB3MnmAdgAOoQ" target="_blank" rel="noopener">奇妙的 Linux 世界</a>』公众号，带你开启有趣新生活！更多好用好玩的软件资源，可访问 <a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a> 免费获取。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IT 人员必备工具箱&lt;/a&gt;』是一个专注于 IT 人优质资源分享的导航站，包含大量好玩又实用的 AI、翻译、编程、设计、Linux、网络、云原生、安全等多款应用。&lt;/p&gt;
&lt;p&gt;🏷️  网站地址：&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://666666.dev&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/Tweelet00-2024-03-14-n0S5jR.webp&quot; alt=&quot;全站预览图&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们的目标是帮助更多 IT 人发现有价值的优质资源，让更多人受益。&lt;/p&gt;
&lt;p&gt;『&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IT 人员必备工具箱&lt;/a&gt;』也可以推荐你喜欢的软件和网站呢！如果你有什么好玩有趣又实用的酷软趣站，快『&lt;a href=&quot;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;推荐&lt;/a&gt;』给我们吧！&lt;/p&gt;
&lt;p&gt;🏷️  趣站酷软推荐收集表: &lt;a href=&quot;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>如何同时向两个远程 Git 仓库推送代码</title>
    <link href="https://www.hi-linux.com/posts/45935.html"/>
    <id>https://www.hi-linux.com/posts/45935.html</id>
    <published>2024-08-26T01:00:00.000Z</published>
    <updated>2024-08-26T07:16:00.270Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>在日常开发中，我们有时需要将代码推送到多个远程仓库以确保代码备份和同步。本篇文章将介绍如何配置和操作 Git，同时推送代码到两个远程仓库。</p></blockquote><h2><span id="为什么需要多个远程仓库">为什么需要多个远程仓库？</span></h2><p>多个远程仓库的常见场景包括：</p><ul><li>备份：确保代码在不同平台上有备份，例如 <code>GitHub</code> 和 <code>GitLab</code>。</li><li>协作：团队成员在不同的远程仓库上工作，需要确保代码同步。</li></ul><h2><span id="配置多个远程仓库">配置多个远程仓库</span></h2><p>假设我们已经有一个远程仓库 <code>origin</code>，现在需要添加一个名为 <code>backup</code> 的远程仓库。</p><a id="more"></a><h3><span id="步骤-1-添加第二个远程仓库">步骤 1: 添加第二个远程仓库</span></h3><p>首先，添加 <code>backup</code> 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add backup https://gitlab.com/user/backup-repo.git</span><br></pre></td></tr></table></figure><h3><span id="步骤-2-验证远程仓库">步骤 2: 验证远程仓库</span></h3><p>确保远程仓库添加成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><p>你应该看到类似如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">origin    https://github.com/user/main-repo.git (push)</span><br><span class="line">backup    https://gitlab.com/user/backup-repo.git (fetch)</span><br><span class="line">backup    https://gitlab.com/user/backup-repo.git (push)</span><br></pre></td></tr></table></figure><h3><span id="步骤-3-推送到两个远程仓库">步骤 3: 推送到两个远程仓库</span></h3><h4><span id="方法-1-分别推送">方法 1: 分别推送</span></h4><p>你可以分别推送到两个远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin &lt;branch-name&gt;</span><br><span class="line">$ git push backup &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h4><span id="方法-2-创建自定义的-remote">方法 2: 创建自定义的 remote</span></h4><p>创建一个自定义的 remote，将两个远程仓库的 URL 都添加到这个 remote 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">set</span>-url --add --push origin https://github.com/user/main-repo.git</span><br><span class="line">$ git remote <span class="built_in">set</span>-url --add --push origin https://gitlab.com/user/backup-repo.git</span><br></pre></td></tr></table></figure><h4><span id="方法-3-使用-git-config">方法 3: 使用 <code>git config</code></span></h4><p>通过配置文件来设置多个 push URL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --add remote.origin.pushurl https://gitlab.com/user/backup-repo.git</span><br></pre></td></tr></table></figure><h2><span id="推送代码">推送代码</span></h2><p>现在，你可以使用以下命令将代码推送到两个远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>或者推送到默认的分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin</span><br></pre></td></tr></table></figure><p>这会将代码推送到 <code>origin</code> 配置的两个 URL，即 <code>origin</code> 和 <code>backup</code> 仓库。</p><h2><span id="推送所有分支">推送所有分支</span></h2><p>如果你想推送所有分支，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --all origin</span><br></pre></td></tr></table></figure><p>这样，你的所有分支都会被推送到 <code>origin</code> 的两个 URL。</p><h2><span id="示例">示例</span></h2><p>假设你的主仓库 URL 是 <code>https://github.com/user/main-repo.git</code>，备份仓库 URL 是 <code>https://gitlab.com/user/backup-repo.git</code>：</p><ol><li>添加备份仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add backup https://gitlab.com/user/backup-repo.git</span><br></pre></td></tr></table></figure><ol start="2"><li>设置 <code>origin</code> 同时推送到两个仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">set</span>-url --add --push origin https://github.com/user/main-repo.git</span><br><span class="line">$ git remote <span class="built_in">set</span>-url --add --push origin https://gitlab.com/user/backup-repo.git</span><br></pre></td></tr></table></figure><ol start="3"><li>推送到两个远程仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>通过以上步骤，你可以轻松配置 Git，同时将代码推送到多个远程仓库，确保代码的备份和同步。希望这篇文章对你有所帮助，如果有任何问题，欢迎在评论区讨论。</p><blockquote><p>本文转载自：「框架師」，原文：<a href="https://url.hi-linux.com/FF4aQ" target="_blank" rel="noopener">https://url.hi-linux.com/FF4aQ</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在日常开发中，我们有时需要将代码推送到多个远程仓库以确保代码备份和同步。本篇文章将介绍如何配置和操作 Git，同时推送代码到两个远程仓库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么需要多个远程仓库？&quot;&gt;为什么需要多个远程仓库？&lt;/h2&gt;
&lt;p&gt;多个远程仓库的常见场景包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;备份：确保代码在不同平台上有备份，例如 &lt;code&gt;GitHub&lt;/code&gt; 和 &lt;code&gt;GitLab&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;协作：团队成员在不同的远程仓库上工作，需要确保代码同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;配置多个远程仓库&quot;&gt;配置多个远程仓库&lt;/h2&gt;
&lt;p&gt;假设我们已经有一个远程仓库 &lt;code&gt;origin&lt;/code&gt;，现在需要添加一个名为 &lt;code&gt;backup&lt;/code&gt; 的远程仓库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Git" scheme="https://www.hi-linux.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>如何实现同一端口代理不同的后端服务</title>
    <link href="https://www.hi-linux.com/posts/34227.html"/>
    <id>https://www.hi-linux.com/posts/34227.html</id>
    <published>2024-08-26T01:00:00.000Z</published>
    <updated>2024-08-26T07:16:00.270Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在网络通信中，端口是用于区分不同服务的重要资源。通常，每个服务会绑定到一个特定端口上，但有时我们需要通过同一个端口来代理不同的服务。这种技术被称为端口复用。本文将介绍端口复用的场景、用途、协议特性，并分别使用 Nginx 和 HAProxy 进行端口复用配置。</p><h2><span id="端口复用的场景与用途">端口复用的场景与用途</span></h2><p>端口复用在以下场景中非常有用：</p><ol><li><strong>资源限制</strong>：在IP地址和端口资源有限的环境中，通过同一端口提供多个服务可以最大化利用现有资源。</li><li><strong>简化配置</strong>：简化客户端配置，使其无需关心不同服务使用不同端口的问题。</li><li><strong>负载均衡与高可用性</strong>：在负载均衡器或反向代理服务器上，通过同一端口代理不同的后端服务，提高服务的可用性和可靠性。</li></ol><a id="more"></a><h2><span id="协议特性">协议特性</span></h2><p>端口复用的实现依赖于协议特性。通过分析协议的特定字段或数据包的前几个字节，可以判断请求的类型并将其转发到相应的后端服务。</p><p>通过 Wireshark 抓包来分析协议特性，下面是分析 MySQL 协议特性的例子：</p><p><img src="https://img.hi-linux.com/staticfile/457511833-20240722142721859-2024-07-22-2p5cXp.png" alt></p><p>从抓包中，可以发现 MySQL 握手包前面 5 个字节是相对固定的 <code>0x490000000a</code>，特别需要注意的是，MySQL 握手包的第一个字节表示包长度，在不同的版本中，长度可能是不一样的，比如说在 8.0.38 版本中，前一个字节是<code>0x4a</code>，需要你抓包确认。</p><p><img src="https://img.hi-linux.com/staticfile/2833408640-20240722142722152-2024-07-22-Jmz8Rf.png" alt></p><p>特别说明一下，MySQL 不能做端口复用，你抓包看MySQL的协议交互会发现，TCP 三次握手之后，第一个包是服务端向客户端发的，这种交互方式在代理层是无法做数据判断的。</p><p>以下是一些常见协议的特性示例：</p><p>在 http 协议中，数据包的前几个字节是<code>GET</code>, <code>POST</code>,<code>PUT</code>,<code>DELETE</code>等，因为长度不一样，通常分析前3字节即可。</p><table><thead><tr><th>协议</th><th>协议特性</th></tr></thead><tbody><tr><td>HTTP(GET)</td><td>payload(0,3) = 474554</td></tr><tr><td>HTTP(POS)</td><td>payload(0,3) = 504f53</td></tr><tr><td>HTTP(PUT)</td><td>payload(0,3) = 505554</td></tr><tr><td>HTTP(DEL)</td><td>payload(0,3) = 44454c</td></tr><tr><td>HTTP(OPT)</td><td>payload(0,3) = 4f5054</td></tr><tr><td>HTTP(HEA)</td><td>payload(0,3) = 484541</td></tr><tr><td>HTTP(CON)</td><td>payload(0,3) = 434f4e</td></tr><tr><td>HTTP(TRA)</td><td>payload(0,3) = 545241</td></tr><tr><td>SSH</td><td>payload(0,3) = 535348</td></tr><tr><td>FTP</td><td>payload(0,3) = 535348</td></tr><tr><td>Redis</td><td>payload(0,4) = 2a320d0a</td></tr></tbody></table><h2><span id="使用-nginx-实现端口复用">使用 Nginx 实现端口复用</span></h2><p>Nginx 是一款高性能的 HTTP 和反向代理服务器。通过结合 Nginx 的 Stream 模块和 Lua 脚本，我们可以根据 payload 的前几个字节实现端口复用。</p><h3><span id="安装必要的软件">安装必要的软件</span></h3><p>首先，确保你安装了带有 Lua 支持的 Nginx，推荐使用 OpenResty，它集成了 Nginx 和 LuaJIT。</p><h3><span id="配置-openresty">配置 OpenResty</span></h3><p>以下是一个 OpenResty 的配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    lua_shared_dict protocol_cache 10m;</span><br><span class="line">    upstream redis_backend &#123;</span><br><span class="line">        server localhost:6379;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    upstream http_backend &#123;</span><br><span class="line">        server localhost:80;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    upstream ssh_backend &#123;</span><br><span class="line">        server localhost:22;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_add_variable $backend;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 3000;</span><br><span class="line">        preread_by_lua_block &#123;</span><br><span class="line">            local sock &#x3D; ngx.req.socket()</span><br><span class="line">            local data, err &#x3D; sock:peek(3)  -- 读取数据包前3个字节</span><br><span class="line">            if not data then</span><br><span class="line">                ngx.log(ngx.ERR, &quot;接收数据失败: &quot;, err)</span><br><span class="line">                return ngx.exit(ngx.ERROR)</span><br><span class="line">            end</span><br><span class="line">            -- 判断payload内容</span><br><span class="line">            if data &#x3D;&#x3D; &quot;\x47\x45\x54&quot; or data &#x3D;&#x3D; &quot;\x50\x4f\x53&quot; or data &#x3D;&#x3D; &quot;\x50\x55\x54&quot; or data &#x3D;&#x3D; &quot;\x44\x45\x4c&quot; or data &#x3D;&#x3D; &quot;\x4f\x50\x54&quot; or data &#x3D;&#x3D; &quot;\x48\x45\x41&quot; or data &#x3D;&#x3D; &quot;\x43\x4f\x4e&quot; or data &#x3D;&#x3D; &quot;\x54\x52\x41&quot; then  -- http</span><br><span class="line">                ngx.var.backend &#x3D; &quot;http_backend&quot;</span><br><span class="line">            elseif data &#x3D;&#x3D; &quot;\x2a\x32\x0d&quot; then -- redis</span><br><span class="line">                ngx.var.backend &#x3D; &quot;redis_backend&quot;</span><br><span class="line">            elseif data &#x3D;&#x3D; &quot;\x53\x53\x48&quot; then -- ssh</span><br><span class="line">                ngx.var.backend &#x3D; &quot;ssh_backend&quot;</span><br><span class="line">            end</span><br><span class="line">        &#125;</span><br><span class="line">        proxy_pass $backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="使用-haproxy-实现端口复用">使用 HAProxy 实现端口复用</span></h2><p>HAProxy 是一款高性能的 TCP/HTTP 负载均衡器。通过配置 HAProxy，我们也可以根据 payload 内容实现端口复用。</p><h3><span id="安装-haproxy">安装 HAProxy</span></h3><p>确保你已经安装了 HAProxy，可以使用包管理器进行安装，如 <code>apt-get install haproxy</code>。</p><h3><span id="配置-haproxy">配置 HAProxy</span></h3><p>以下是一个基于TCP协议的示例配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">frontend main_front</span><br><span class="line">    bind *:3000</span><br><span class="line">    mode tcp</span><br><span class="line">    tcp-request inspect-delay 5s</span><br><span class="line">    </span><br><span class="line">    acl is_http req.payload(0,3) ‐m bin 474554 504f53 505554 44454c 4f5054 484541 434f4e 545241</span><br><span class="line">    acl is_redis req.payload(0,3) ‐m bin 535348</span><br><span class="line">    acl is_ssh req.payload(0,3) ‐m bin 535348</span><br><span class="line">    use_backend http_backend if is_http</span><br><span class="line">    use_backend redis_backend if is_redis</span><br><span class="line">    use_backend ssh_backend if is_ssh</span><br><span class="line">    default_backend another_backend</span><br><span class="line">backend http_backend</span><br><span class="line">    mode tcp</span><br><span class="line">    server server1 localhost:80</span><br><span class="line">backend redis_backend</span><br><span class="line">    mode tcp</span><br><span class="line">    server server1 localhost:6379</span><br><span class="line">backend ssh_backend</span><br><span class="line">    mode tcp</span><br><span class="line">    server server1 localhost:22</span><br><span class="line">backend another_backend</span><br><span class="line">    mode tcp</span><br><span class="line">    server server1 localhost:9000</span><br></pre></td></tr></table></figure><h2><span id="小结">小结</span></h2><p>端口复用能够在资源受限的环境中提高服务的灵活性和可用性。通过分析协议特性，我们可以在同一端口上代理不同的服务。Nginx 和 HAProxy 都提供了强大的功能来实现这一需求，HAProxy 配置更简单明朗。</p><blockquote><p>本文转载自：「 哈希 」，原文：<a href="https://url.hi-linux.com/l3u8n" target="_blank" rel="noopener">https://url.hi-linux.com/l3u8n</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网络通信中，端口是用于区分不同服务的重要资源。通常，每个服务会绑定到一个特定端口上，但有时我们需要通过同一个端口来代理不同的服务。这种技术被称为端口复用。本文将介绍端口复用的场景、用途、协议特性，并分别使用 Nginx 和 HAProxy 进行端口复用配置。&lt;/p&gt;
&lt;h2 id=&quot;端口复用的场景与用途&quot;&gt;端口复用的场景与用途&lt;/h2&gt;
&lt;p&gt;端口复用在以下场景中非常有用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;资源限制&lt;/strong&gt;：在IP地址和端口资源有限的环境中，通过同一端口提供多个服务可以最大化利用现有资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化配置&lt;/strong&gt;：简化客户端配置，使其无需关心不同服务使用不同端口的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡与高可用性&lt;/strong&gt;：在负载均衡器或反向代理服务器上，通过同一端口代理不同的后端服务，提高服务的可用性和可靠性。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>一分钟上手 PG Back Web，让你的 PostgreSQL 备份高枕无忧</title>
    <link href="https://www.hi-linux.com/posts/46814.html"/>
    <id>https://www.hi-linux.com/posts/46814.html</id>
    <published>2024-08-15T01:00:00.000Z</published>
    <updated>2024-08-15T02:15:18.068Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言">引言</span></h2><p>在当今数据驱动的世界中，数据库备份的重要性不言而喻。无论是开发者还是系统管理员，确保数据的安全和可用性都是至关重要的任务。</p><p>然而，手动备份不仅繁琐，还容易出错。幸运的是，有了 PG Back Web，这一切变得轻而易举。本文将带领大家深入了解 pgbackweb 的强大功能，并教你如何使用它来简化 PostgreSQL 的备份任务。</p><h2><span id="什么是-pg-back-web">什么是 PG Back Web？</span></h2><p>PG Back Web 是一个专为 PostgreSQL 数据库设计的备份工具，其核心特点是提供了一个用户友好的网页界面，让备份工作变得简单直观。</p><p>无论你是个人开发者还是团队的一员，PG Back Web 都能帮助你自动化备份任务，节省时间，减少手动操作的麻烦。</p><p>项目地址：<a href="https://github.com/eduardolat/pgbackweb" target="_blank" rel="noopener">https://github.com/eduardolat/pgbackweb</a></p><a id="more"></a><h2><span id="功能介绍">功能介绍</span></h2><h3><span id="简洁直观的网页界面">📦 简洁直观的网页界面</span></h3><p>PG Back Web 提供了一个直观的网页界面，让你无需数据库专业知识也能轻松管理备份。通过这个界面，你可以方便地创建、管理和恢复备份。</p><h3><span id="定时备份">📅 定时备份</span></h3><p>设置定时备份任务，让 PG Back Web 自动化你的备份流程。从此，你再也不用担心忘记手动备份了。</p><h3><span id="备份监控">📈 备份监控</span></h3><p>通过执行日志，你可以可视化地查看备份的状态，确保每次备份都顺利完成。</p><h3><span id="即时下载与恢复">📤 即时下载与恢复</span></h3><p>需要恢复备份？没问题！你可以直接从网页界面下载或恢复你的备份，快速应对各种突发状况。</p><h3><span id="多版本支持">🖥 多版本支持</span></h3><p>PG Back Web 兼容 PostgreSQL 13、14、15 和 16 版本，无论你使用的是哪个版本，都能轻松集成。</p><h3><span id="本地与-s3-存储">📁 本地与 S3 存储</span></h3><p>你可以选择将备份存储在本地，或者添加多个 S3 存储桶，以获得更大的灵活性。</p><h3><span id="安全加密">🔒 安全加密</span></h3><p>PG Back Web 使用 PGP 加密来保护你的敏感信息，确保数据的安全性。</p><h3><span id="️-开源与可信赖">🛡️ 开源与可信赖</span></h3><p>PG Back Web 是一个开源项目，代码公开透明，使用了稳健的 pg_dump 工具，值得信赖。</p><h3><span id="黑暗模式">🌚 黑暗模式</span></h3><p>喜欢黑暗模式？PG Back Web 也提供了这个选项，让你在夜晚操作时更舒适。</p><h2><span id="安装指南">安装指南</span></h2><p>PG Back Web 作为 Docker 镜像提供，你只需要设置两个环境变量就可以开始使用。以下是使用 Docker Compose 运行 PG Back Web 的示例配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">pgbackweb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">eduardolat/pgbackweb:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8085:8085"</span> <span class="comment"># Access the web interface at http://localhost:8085</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./backups:/backups</span> <span class="comment"># If you only use S3 destinations, you don't need this volume</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">PBW_ENCRYPTION_KEY:</span> <span class="string">"my_secret_key"</span></span><br><span class="line">      <span class="attr">PBW_POSTGRES_CONN_STRING:</span> <span class="string">"postgresql://postgres:password@postgres:5432/pgbackweb?sslmode=disable"</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">postgres:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:16</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">pgbackweb</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"5432:5432"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/postgresql/data</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="string">["CMD-SHELL",</span> <span class="string">"pg_isready -U postgres"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>只需将上面的配置保存为 <code>docker-compose.yml</code> 文件，然后运行 <code>docker-compose up -d</code> 命令即可启动 PG Back Web。</p><h2><span id="配置说明">配置说明</span></h2><p>你只需配置以下两个环境变量：</p><ul><li><code>PBW_ENCRYPTION_KEY</code>：你的加密密钥。请生成一个强密码并妥善保存，PG Back Web 会使用它来加密敏感数据。</li><li><code>PBW_POSTGRES_CONN_STRING</code>：用于存储 PG Back Web 数据的 PostgreSQL 数据库连接字符串。</li></ul><h2><span id="截图展示">截图展示</span></h2><p>以下是 PG Back Web 的一些界面截图：</p><p><img src="https://img.hi-linux.com/staticfile/summary-2024-08-14-Wc4Z4o.png" alt="Summary"></p><p><img src="https://img.hi-linux.com/staticfile/backups-2024-08-14-9Wk0wU.png" alt="Backups"></p><p><img src="https://img.hi-linux.com/staticfile/executions-2024-08-14-LaQJTO.png" alt="Executions"></p><h2><span id="重置密码">重置密码</span></h2><p>如果你需要重置 PG Back Web 的密码，可以在运行 PG Back Web 的服务器上执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it &lt;container_name_or_id&gt; sh -c change-password</span><br></pre></td></tr></table></figure><p>将 <code>&lt;container_name_or_id&gt;</code> 替换为 PG Back Web 容器的名称或 ID，然后按照提示操作即可。</p><h2><span id="结论">结论</span></h2><p>PG Back Web 是一个强大且易于使用的 PostgreSQL 备份工具，通过其直观的网页界面和自动化功能，可以大大简化你的备份任务。</p><p>无论你是个人开发者还是团队的一员，PG Back Web 都是你不可或缺的助手。</p><p>立即尝试 PG Back Web，让你的 PostgreSQL 数据备份变得前所未有的简单和高效！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;在当今数据驱动的世界中，数据库备份的重要性不言而喻。无论是开发者还是系统管理员，确保数据的安全和可用性都是至关重要的任务。&lt;/p&gt;
&lt;p&gt;然而，手动备份不仅繁琐，还容易出错。幸运的是，有了 PG Back Web，这一切变得轻而易举。本文将带领大家深入了解 pgbackweb 的强大功能，并教你如何使用它来简化 PostgreSQL 的备份任务。&lt;/p&gt;
&lt;h2 id=&quot;什么是-PG-Back-Web？&quot;&gt;什么是 PG Back Web？&lt;/h2&gt;
&lt;p&gt;PG Back Web 是一个专为 PostgreSQL 数据库设计的备份工具，其核心特点是提供了一个用户友好的网页界面，让备份工作变得简单直观。&lt;/p&gt;
&lt;p&gt;无论你是个人开发者还是团队的一员，PG Back Web 都能帮助你自动化备份任务，节省时间，减少手动操作的麻烦。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/eduardolat/pgbackweb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/eduardolat/pgbackweb&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="PostgreSQL" scheme="https://www.hi-linux.com/tags/PostgreSQL/"/>
    
      <category term="备份" scheme="https://www.hi-linux.com/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>解锁科技魔法「极客光年」，让你的手机看上去更美，从此与众不同！</title>
    <link href="https://www.hi-linux.com/posts/53528.html"/>
    <id>https://www.hi-linux.com/posts/53528.html</id>
    <published>2024-08-14T01:00:00.000Z</published>
    <updated>2024-08-14T02:52:21.584Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><img src="https://img.hi-linux.com/staticfile/WX20240813-141455@2x-2024-08-13-J7YjX4.png" alt></p><p>你是否厌倦了每次解锁手机，看到的都是那些千篇一律的壁纸？你的朋友是不是总能找到令人惊叹的手机背景，而你只能羡慕嫉妒恨？</p><p>别担心，我们找到了解决方案「极客光年」！这个网站简直就是手机壁纸界的宝藏窟，绝对能让你的屏幕从此与众不同！</p><h2><span id="为什么选择极客光年">为什么选择「极客光年」？</span></h2><ol><li><p><strong>海量高质量壁纸</strong></p><p>想象一下，你打开「极客光年」，就像走进了一个巨大的艺术画廊。从绚丽的风景到可爱的动物，从未来科技到复古怀旧，应有尽有。无论你是喜欢简约风还是奇幻风，这里总有一款适合你。</p></li><li><p><strong>摄影大师的杰作</strong></p><p>极客光年不仅仅是壁纸网站，它还是摄影爱好者的天堂。这里汇集了来自世界各地摄影师的精品照片。谁说你的手机屏幕不能成为一件艺术品？在这里，每次解锁都是一次视觉盛宴！</p></li><li><p><strong>AI 图片，引领潮流</strong></p><p>如果你觉得普通照片已经无法满足你的需求，那就来看看「极客光年」的 AI 图片区吧。这里的图片不是普通的 PS，而是由最先进的 AI 技术生成的艺术品。想象一下，你的手机壁纸可能是这个世界上独一无二的存在，酷不酷？</p></li><li><p><strong>免费又方便</strong></p><p>最棒的是，极客光年完全免费！你不需要注册，不需要付费，只需要点击下载，就能获得心仪的壁纸。省钱又省心，还有比这更好的事吗？</p></li></ol><a id="more"></a><h2><span id="如何使用极客光年">如何使用「极客光年」？</span></h2><blockquote><p>「极客光年」网址：<a href="https://bestgeek.org/pic" target="_blank" rel="noopener">https://bestgeek.org/pic</a></p></blockquote><p>使用「极客光年」简单得连你家的宠物狗都能学会（好吧，可能有点夸张）。只需要三步：</p><ol><li>打开网站</li><li>浏览并选择你喜欢的图片</li><li>点击下载</li></ol><p>就这么简单！你甚至可以在等公交车或排队买咖啡的时候完成这个过程。</p><h2><span id="让你的手机与众不同">让你的手机与众不同</span></h2><p>想象一下，当你和朋友聚会时，大家都在比较手机壁纸。你轻轻一按解锁键，瞬间，所有人的目光都被你的屏幕吸引。</p><p>“哇，这壁纸太酷了！”</p><p>“你从哪里找到的？” 他们会问。而你，只需要微微一笑，优雅地说：“哦，这个啊，我在「极客光年」上找到的。”</p><p>从此以后，你就是朋友圈里的壁纸达人，手机屏幕界的时尚坐标！</p><h2><span id="结语">结语</span></h2><p>亲爱的朋友们，还在等什么？快来「极客光年」，让你的手机焕然一新吧！记住，生活可以平凡，但你的手机壁纸绝不能平凡。让「极客光年」成为你的秘密武器，让你的手机屏幕成为你个性的完美展示。</p><p>别忘了，每一次解锁，都是一次视觉享受。每一张壁纸，都是一个小小的惊喜。现在就行动吧，让你的手机从此与众不同！</p><p>「极客光年」 - 因为你的手机，值得拥有最好的壁纸！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/WX20240813-141455@2x-2024-08-13-J7YjX4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;你是否厌倦了每次解锁手机，看到的都是那些千篇一律的壁纸？你的朋友是不是总能找到令人惊叹的手机背景，而你只能羡慕嫉妒恨？&lt;/p&gt;
&lt;p&gt;别担心，我们找到了解决方案「极客光年」！这个网站简直就是手机壁纸界的宝藏窟，绝对能让你的屏幕从此与众不同！&lt;/p&gt;
&lt;h2 id=&quot;为什么选择「极客光年」？&quot;&gt;为什么选择「极客光年」？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;海量高质量壁纸&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想象一下，你打开「极客光年」，就像走进了一个巨大的艺术画廊。从绚丽的风景到可爱的动物，从未来科技到复古怀旧，应有尽有。无论你是喜欢简约风还是奇幻风，这里总有一款适合你。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;摄影大师的杰作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;极客光年不仅仅是壁纸网站，它还是摄影爱好者的天堂。这里汇集了来自世界各地摄影师的精品照片。谁说你的手机屏幕不能成为一件艺术品？在这里，每次解锁都是一次视觉盛宴！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AI 图片，引领潮流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得普通照片已经无法满足你的需求，那就来看看「极客光年」的 AI 图片区吧。这里的图片不是普通的 PS，而是由最先进的 AI 技术生成的艺术品。想象一下，你的手机壁纸可能是这个世界上独一无二的存在，酷不酷？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;免费又方便&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最棒的是，极客光年完全免费！你不需要注册，不需要付费，只需要点击下载，就能获得心仪的壁纸。省钱又省心，还有比这更好的事吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="壁纸" scheme="https://www.hi-linux.com/tags/%E5%A3%81%E7%BA%B8/"/>
    
      <category term="摄影" scheme="https://www.hi-linux.com/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="手机" scheme="https://www.hi-linux.com/tags/%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>告别复杂命令行，Hollama 让与 Ollama AI 对话丝般顺滑</title>
    <link href="https://www.hi-linux.com/posts/37064.html"/>
    <id>https://www.hi-linux.com/posts/37064.html</id>
    <published>2024-08-12T01:00:00.000Z</published>
    <updated>2024-08-12T01:25:13.312Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言">🌐 引言</span></h2><p>在人工智能快速发展的今天，我们越来越依赖各种 AI 工具来提高工作效率和生活质量。</p><p>Ollama 作为一个强大的本地 AI 模型服务器，为我们提供了丰富的 AI 能力。但是，如何更方便地与 Ollama 进行交互呢？</p><p>这就是 Hollama 的用武之地！Hollama 为 Ollama 服务器提供了一个简洁优雅的 Web 界面，让你可以轻松地与 AI 模型对话，无需复杂的命令行操作。让我们一起来探索 Hollama 的魅力吧！</p><a id="more"></a><h2><span id="hollamaollama-的网页化身">🎭 Hollama：Ollama 的网页化身</span></h2><p>Hollama 是一个为 Ollama 服务器设计的极简 Web 用户界面。它的目标是让用户能够通过直观的 Web 界面与 Ollama 提供的 AI 模型进行交互，而不需要直接使用命令行或复杂的 API 调用。</p><p>✨ Hollama 支持的特性:</p><p>✅ 大型提示字段<br>✅ 带语法高亮的 Markdown 渲染<br>✅ 代码编辑器功能<br>✅ 可定制的系统提示<br>✅ 复制代码片段、信息或整个会话<br>✅ 重试完成<br>✅ 在浏览器本地存储数据<br>✅ 响应式布局<br>✅ 浅色和深色主题</p><p>🏷️ Hollama 项目地址：</p><ul><li><a href="https://github.com/fmaclen/hollama" target="_blank" rel="noopener">https://github.com/fmaclen/hollama</a></li></ul><h2><span id="️-安装-hollama简单快捷">🛠️ 安装 Hollama：简单快捷</span></h2><p>要在本地运行 Hollama 服务器，你需要安装 Docker。以下是安装和启动 Hollama 的步骤：</p><h3><span id="通过-docker-部署">通过 Docker 部署</span></h3><h4><span id="1-安装-docker">1. 安装 Docker</span></h4><ul><li>前往 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker 官方网站</a> 下载并安装 Docker Desktop。</li><li>根据你的操作系统选择相应的安装包，并按照提示完成安装。</li></ul><h4><span id="2-运行-hollama-服务器">2. 运行 Hollama 服务器</span></h4><ul><li>打开你的终端，并输入以下命令以启动 Hollama 服务器：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -d -p 4173:4173 ghcr.io/fmaclen/hollama:latest</span><br></pre></td></tr></table></figure><p>这条命令会在后台启动 Hollama 服务器，并将其映射到本地主机的 4173 端口。</p><h4><span id="3-访问-hollama-网页界面">3. 访问 Hollama 网页界面</span></h4><ul><li>在你的浏览器中访问 <code>http://localhost:4173</code>，即可开始使用 Hollama 的网页界面。</li></ul><h3><span id="下载-hollama-桌面端应用">下载 Hollama 桌面端应用</span></h3><p>此外，Hollama 还提供了桌面端应用程序，支持 macOS、Windows 和 Linux 系统。</p><p>如果你更喜欢桌面应用的使用体验，可以下载 Hollama 的桌面端应用：</p><ul><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-mac-arm64.dmg" target="_blank" rel="noopener">Download for macOS ARM</a></li><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-mac-x64.dmg" target="_blank" rel="noopener">Download for macOS x64</a></li><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-win-x64.exe" target="_blank" rel="noopener">Download for Windows</a></li><li><a href="https://github.com/fmaclen/hollama/releases/download/0.8.2/Hollama_0.8.2-linux-x64.tar.gz" target="_blank" rel="noopener">Download for Linux</a></li></ul><p>安装完成后，桌面应用将为你提供与网页端相同的功能和使用体验。</p><blockquote><p>注意：如果你使用的是公共托管版本，或者你的 Docker 服务器位于与 Ollama 服务器不同的设备上，你就必须在 OLLAMA_ORIGINS 中设置域。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OLLAMA_ORIGINS&#x3D;https:&#x2F;&#x2F;hollama.fernando.is ollama serve</span><br></pre></td></tr></table></figure><h2><span id="使用-hollama简洁而强大的界面">🚀 使用 Hollama：简洁而强大的界面</span></h2><p><img src="https://img.hi-linux.com/staticfile/tE6uxk-2024-08-08-wyzHFq.png" alt></p><p>Hollama 的网页界面设计简洁明了，主要包括以下几个部分：</p><ol><li><strong>模型选择</strong>：你可以选择想要使用的 AI 模型。</li><li><strong>对话区域</strong>：这里显示你与 AI 的对话历史。</li><li><strong>输入框</strong>：在这里输入你想问的问题或指令。</li><li><strong>发送按钮</strong>：点击发送你的输入给 AI 模型。</li></ol><p>使用步骤非常简单：</p><ol><li>选择想要使用的 AI 模型。</li><li>在输入框中输入你的问题或指令。</li><li>点击发送按钮或按回车键。</li><li>等待 AI 的回复，回复会实时显示在对话区域。</li></ol><h3><span id="实时响应流畅的对话体验">🔄 实时响应：流畅的对话体验</span></h3><p>Hollama 支持流式输出，这意味着你可以看到 AI 正在实时生成的回答。每个字都会在你眼前逐步呈现，让你感受到与 AI 进行真实对话的流畅体验。</p><p><img src="https://img.hi-linux.com/staticfile/Ur5eIG-2024-08-08-Z3ycqQ.png" alt></p><h3><span id="多模型支持丰富你的-ai-体验">🎨 多模型支持：丰富你的 AI 体验</span></h3><p>Hollama 支持 Ollama 服务器上所有可用的模型。你可以轻松切换不同的模型，体验它们各自的特点和能力。无论是需要 GPT 系列的创意写作，还是 CodeLlama 的编程协助，Hollama 都能满足你的需求。</p><p><img src="https://img.hi-linux.com/staticfile/EYtDjX-2024-08-08-wRMtho.png" alt></p><h3><span id="对话历史回顾精彩瞬间">📜 对话历史：回顾精彩瞬间</span></h3><p>Hollama 会在浏览器中保存你的对话历史，让你可以随时回顾之前的对话内容。这个功能特别适合那些需要参考之前讨论结果的场景。</p><h3><span id="安全可靠本地部署更安心">🔐 安全可靠：本地部署更安心</span></h3><p>由于 Hollama 是一个本地运行的网页界面，连接的也是本地的 Ollama 服务器，因此你的所有对话都是在本地进行的。这极大地提高了数据的安全性和隐私保护，特别适合处理敏感信息的场景。</p><h3><span id="自定义选项打造专属体验">🌈 自定义选项：打造专属体验</span></h3><p>Hollama 提供了一些自定义选项，让你可以根据个人喜好调整使用体验：</p><ul><li>可以设置默认的 AI 模型</li><li>调整界面主题（如果支持的话）</li><li>设置最大标记数等参数</li></ul><p><img src="https://img.hi-linux.com/staticfile/uiAPvA-2024-08-08-LSGn3K.png" alt></p><h3><span id="响应式设计随时随地畅聊-ai">📱 响应式设计：随时随地畅聊 AI</span></h3><p>Hollama 采用响应式设计，无论你是使用台式电脑、笔记本还是手机，都能获得良好的使用体验。这意味着你可以随时随地与 AI 进行对话，激发创意灵感。</p><h2><span id="结论">🔚 结论</span></h2><p>Hollama 为 Ollama 服务器提供了一个简洁、直观且功能强大的 Web 界面。</p><p>它让与 AI 模型的交互变得前所未有的简单，无论你是 AI 爱好者、开发者，还是普通用户，都能轻松上手。</p><p>通过 Hollama，你可以充分发挥 Ollama 的潜力，探索 AI 的无限可能。</p><p>从此，与 AI 对话再也不是高深莫测的技术活，而是像聊天一样简单自然。Hollama 不仅仅是一个工具，它是连接你与 AI 世界的桥梁，让 AI 的力量触手可及。</p><p>准备好开始你的 AI 探索之旅了吗？</p><p>安装 Hollama，打开浏览器或桌面应用，让我们一起徜徉在 AI 的海洋中，发现 AI 带来的无限可能吧！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;🌐-引言&quot;&gt;🌐 引言&lt;/h2&gt;
&lt;p&gt;在人工智能快速发展的今天，我们越来越依赖各种 AI 工具来提高工作效率和生活质量。&lt;/p&gt;
&lt;p&gt;Ollama 作为一个强大的本地 AI 模型服务器，为我们提供了丰富的 AI 能力。但是，如何更方便地与 Ollama 进行交互呢？&lt;/p&gt;
&lt;p&gt;这就是 Hollama 的用武之地！Hollama 为 Ollama 服务器提供了一个简洁优雅的 Web 界面，让你可以轻松地与 AI 模型对话，无需复杂的命令行操作。让我们一起来探索 Hollama 的魅力吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="AI" scheme="https://www.hi-linux.com/tags/AI/"/>
    
      <category term="Ollama" scheme="https://www.hi-linux.com/tags/Ollama/"/>
    
      <category term="Hollama" scheme="https://www.hi-linux.com/tags/Hollama/"/>
    
  </entry>
  
  <entry>
    <title>10 个你不知道的 cURL 高级实用技巧</title>
    <link href="https://www.hi-linux.com/posts/21794.html"/>
    <id>https://www.hi-linux.com/posts/21794.html</id>
    <published>2024-08-07T01:00:00.000Z</published>
    <updated>2024-08-07T01:23:09.849Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="10-个例子展示为什么-curl-是一个很棒的命令行工具">10 个例子展示为什么 cURL 是一个很棒的命令行工具</span></h2><p>无论你是开发者、DevOps 工程师、系统管理员、QA 还是其他技术岗位，你一定对 cURL 很熟悉——用于通过 URL 传输数据的命令行工具和库。</p><p>然而，大多数时候，我们都只用 <code>curl</code> 来做一些简单的任务，比如下载文件或检查网站是否可访问，但 <code>curl</code> 能做的远不止这些！</p><p>在这篇文章中，我们将介绍一些很酷的例子和技巧，展示为什么 <code>curl</code> 是一个非常棒且被低估的工具……</p><h2><span id="文件名代换">文件名代换</span></h2><p>首先介绍的是文件名代换，它允许我们用一个 <code>curl</code> 命令发出多个请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/users/[1-3]"</span> | jq -s .</span><br><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/users/[0-10:2]"</span> | jq -s .</span><br><span class="line"></span><br><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/photos/&#123;1,6,35&#125;"</span> | jq -s .</span><br><span class="line"></span><br><span class="line">$ curl -s <span class="string">"https://jsonplaceholder.typicode.com/users/[1-3]"</span> -o <span class="string">"file_#1.json"</span></span><br></pre></td></tr></table></figure><p>前两个命令展示了如何运行一系列请求——第一个命令会产生对 <code>.../users/1</code>、<code>.../users/2</code> 和 <code>.../users/3</code> 的请求，而另一个使用步长选项，产生 2、4、6、8 和 10 的请求。考虑到这些特定请求返回的是 JSON，我们还将它与 <code>jq ...</code> 和 <code>-s</code>（slurp）操作符结合，将单个请求的响应合并为一个数组。</p><p>第三个例子使用了特定数字的列表而不是范围，这也适用于字符和单词。例如，我们可以使用 globbing 发出带有多种协议的请求：<code>{http,https}://...</code></p><p>最后一个例子将 globbing 与输出变量结合，文件名中的 <code>#1</code> 变量指的是范围 <code>[1-3]</code>。这将生成 <code>file_1.json</code>、<code>file_2.json</code> 和 <code>file_3.json</code>。</p><a id="more"></a><h2><span id="配置文件">配置文件</span></h2><p>大多数时候，使用 <code>curl</code> 时我们可能希望传递相同的命令行选项，如代理设置、请求超时、头信息等。这时名为 <code>.curlrc</code> 的 <code>curl</code> 配置文件可能会派上用场：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.curlrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些头信息</span></span><br><span class="line">-H <span class="string">"Upgrade-Insecure-Requests: 1"</span></span><br><span class="line">-H <span class="string">"Accept-Language: en-US,en;q=0.8"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟随重定向</span></span><br><span class="line">--location</span><br></pre></td></tr></table></figure><p>这只是一个文本文件，每行代表一个将传递给 <code>curl</code> 的选项。它会自动从 <code>~/.curlrc</code> 读取，所以你不需要任何额外的标志，但你可以使用 <code>-K</code> 来覆盖或指定不同的位置，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -K .curlrc https://google.com</span><br></pre></td></tr></table></figure><p>类似于标志和选项，有时我们也希望传递凭据。这可以通过 <code>--user</code> 选项来完成，但这会将凭据留在 <code>Shell</code> 历史记录中，所以我们可以利用 <code>curl</code> 支持的 <code>.netrc</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.netrc</span></span><br><span class="line">machine https://authenticationtest.com/HTTPAuth/</span><br><span class="line">login user</span><br><span class="line">password pass</span><br></pre></td></tr></table></figure><p>格式包括 <code>machine</code>（URL）、<code>login</code> 和 <code>password</code>。它们可以在一行中或如上所示，并且我们可以在一个文件中有多个。要使用它，只需将其传递给 <code>curl</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --netrc-file .netrc https://authenticationtest.com/HTTPAuth/</span><br></pre></td></tr></table></figure><h2><span id="并行请求">并行请求</span></h2><p>我们已经在 <code>文件名代换部分</code> 讨论了请求的范围，但并行化呢？好吧，<code>curl</code> 也能做到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -I --parallel --parallel-immediate --parallel-max 3 --config websites.txt</span><br><span class="line"></span><br><span class="line">$ curl -I --parallel --parallel-immediate --parallel-max 3 stackoverflow.com google.com example.com</span><br></pre></td></tr></table></figure><p>我们需要做的只是添加 <code>--parallel</code>（或 <code>-Z</code>），<code>curl</code> 将打开最多 50 个并行连接（可以通过 <code>--parallel-max N</code> 更改）。</p><p>还要注意我们是如何提供 URL 的，第一种方法是通过 <code>--config</code> 参数和一个文本文件，看起来像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"stackoverflow.com"</span></span><br><span class="line">url = <span class="string">"google.com"</span></span><br><span class="line">url = <span class="string">"example.com"</span></span><br></pre></td></tr></table></figure><p>另一个方法是将所有 URL 放在命令行上。这两个选项也适用于非并行请求！</p><h2><span id="格式化和变量">格式化和变量</span></h2><p><code>curl</code> 可以输出很多东西，有时会让人不知所措、冗长且不必要。幸运的是，我们可以使用输出格式化只打印我们感兴趣的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ curl --silent --output /dev/null --show-error -w @format.txt http://example.com/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型: text/html; charset=UTF-8</span></span><br><span class="line"><span class="comment"># 代码: 200</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 从 8.1.0:</span></span><br><span class="line"><span class="comment"># 协议: http</span></span><br><span class="line"><span class="comment"># 主机: example.com</span></span><br><span class="line"><span class="comment"># 端口: 80</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 读取头信息内容 (v7.83.0):</span></span><br><span class="line"><span class="comment"># 服务器: Sat, 29 Jun 2024 13:01:30 GMT</span></span><br></pre></td></tr></table></figure><p>我们通过使用 <code>-w</code> 选项并传递一个格式文件来实现这一点。要生成上述输出，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># format.txt</span></span><br><span class="line">类型: %&#123;content_type&#125;\n代码: %&#123;response_code&#125;\n\n</span><br><span class="line"></span><br><span class="line">从 8.1.0:\n\n</span><br><span class="line"></span><br><span class="line">协议: %&#123;url.scheme&#125;\n</span><br><span class="line">主机: %&#123;url.host&#125;\n</span><br><span class="line">端口: %&#123;url.port&#125;\n</span><br><span class="line"></span><br><span class="line">读取头信息内容 (v7.83.0):\n</span><br><span class="line">%header&#123;date&#125;</span><br></pre></td></tr></table></figure><p>每个变量都用 <code>%{...}</code> 包围。它们可以是简单变量，如 <code>response_code</code>，也可以是 <code>url.&lt;NAME&gt;</code> 的一部分，指的是 URL 组件，如主机或端口。最后，我们还可以使用 <code>%header{HEADER_NAME}</code> 变量输出响应头信息。</p><p>格式化的一个很好的用途是测量请求/响应时间，可以用以下格式来实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># format.txt</span></span><br><span class="line">     域名解析时间:  %&#123;time_namelookup&#125;s\n</span><br><span class="line">        连接时间:  %&#123;time_connect&#125;s\n</span><br><span class="line">     应用连接时间:  %&#123;time_appconnect&#125;s\n</span><br><span class="line">       预传输时间:  %&#123;time_pretransfer&#125;s\n</span><br><span class="line">       重定向时间:  %&#123;time_redirect&#125;s\n</span><br><span class="line">      开始传输时间: %&#123;time_starttransfer&#125;s\n</span><br><span class="line">                ----------\n</span><br><span class="line">          总时间:  %&#123;time_total&#125;s\n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">     域名解析时间:  0.000765s</span><br><span class="line">        连接时间:  0.111908s</span><br><span class="line">     应用连接时间:  0.000000s</span><br><span class="line">       预传输时间:  0.111967s</span><br><span class="line">       重定向时间:  0.000000s</span><br><span class="line">     开始传输时间:  0.223373s</span><br><span class="line">                ----------</span><br><span class="line">          总时间:  0.223992s</span><br></pre></td></tr></table></figure><p>有关完整的变量列表，请参阅 <a href="https://everything.curl.dev/usingcurl/verbose/writeout.html#available---write-out-variables" target="_blank" rel="noopener">文档</a>。</p><h2><span id="测试与故障排除">测试与故障排除</span></h2><p>使用 <code>curl</code> 最常见的方式是进行（网络）故障排除。通常只需对特定 URL 发出请求即可提供足够的信息，但我们可以做更多的事情，例如我们可以强制使用特定的本地网络接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip link show</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 3: wlp5s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DORMANT group default qlen 1000</span></span><br><span class="line"></span><br><span class="line">$ curl --interface wlp5s0 https://example.com</span><br></pre></td></tr></table></figure><p>同样，我们可以强制使用特定的 DNS 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --dns-ipv4-addr 1.1.1.1 https://example.com</span><br></pre></td></tr></table></figure><p>或者我们可以测试超时并捕获退出代码（<a href="https://everything.curl.dev/cmdline/exitcode.html" target="_blank" rel="noopener">退出代码</a>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl --connect-timeout 30 --silent --output /dev/null \</span><br><span class="line">  --show-error -w <span class="string">'总时间: %&#123;time_total&#125;s\n'</span> http://google.com/ || EXIT_CODE=$?</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$EXIT_CODE</span> = 28 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"无法连接（超时）。"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"可以连接。"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这对测试代理服务器是否正常工作非常有用（使用 <code>-x http://proxy.example.com:80</code>）。</p><h2><span id="trurl">Trurl</span></h2><p><code>curl</code> 不只是一个 CLI 工具——该项目还包括 <code>libcurl</code> 以及 <code>trurl</code>，我想在这里展示一下。</p><p><a href="https://curl.se/trurl/" target="_blank" rel="noopener">trurl</a> 是一个用于解析 URL 的专用工具，是 <code>curl</code> 的兄弟项目。可以从源代码安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libcurl4-openssl-dev</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/curl/trurl.git</span><br><span class="line">$ <span class="built_in">cd</span> trurl</span><br><span class="line">$ make</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>这里有几个使用它的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ trurl --url https://example.com/some/path/to/file.html --get <span class="string">'&#123;path&#125;'</span></span><br><span class="line"><span class="comment"># /some/path/to/file.html</span></span><br><span class="line"></span><br><span class="line">$ trurl --url <span class="string">"https://example.com/?name=hello"</span> --append query=key=value</span><br><span class="line"><span class="comment"># https://example.com/?name=hello&amp;key=value</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析为 JSON：</span></span><br><span class="line">$ trurl --url <span class="string">"https://example.com/?name=hello"</span> --json</span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment">#   &#123;</span></span><br><span class="line"><span class="comment">#     "url": "https://example.com/?name=hello",</span></span><br><span class="line"><span class="comment">#     "parts": &#123;</span></span><br><span class="line"><span class="comment">#       "scheme": "https",</span></span><br><span class="line"><span class="comment">#       "host": "example.com",</span></span><br><span class="line"><span class="comment">#       "path": "/",</span></span><br><span class="line"><span class="comment">#       "query": "name=hello"</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     "params": [</span></span><br><span class="line"><span class="comment">#       &#123;</span></span><br><span class="line"><span class="comment">#         "key": "name",</span></span><br><span class="line"><span class="comment">#         "value": "hello"</span></span><br><span class="line"><span class="comment">#       &#125;</span></span><br><span class="line"><span class="comment">#     ]</span></span><br><span class="line"><span class="comment">#   &#125;</span></span><br><span class="line"><span class="comment"># ]</span></span><br></pre></td></tr></table></figure><p>第一个例子展示了如何提取 URL 组件，这里是路径，但也可以是如 url、scheme、user、password、options 或 host 等。</p><p>第二个例子使用 <code>append</code> 功能，向 URL 添加查询参数。</p><p>最后一个例子展示了 <code>--json</code> 选项，它将解析的 URL 输出为 JSON，非常适合进一步处理。</p><p><code>trurl</code> 可以做更多事情，你可以查看 <a href="https://www.youtube.com/watch?v=oDL7DVszr2w" target="_blank" rel="noopener">这个视频</a> 或 <a href="https://curl.se/trurl/manual.html" target="_blank" rel="noopener">手册</a>（底部有例子）。</p><h2><span id="发送上传数据">发送/上传数据</span></h2><p>大多数时候我们使用 <code>curl</code> 下载或请求数据，但它（显然）也可以发送数据。用 <code>curl</code> 发送 POST 数据并不是什么新鲜事，对吧？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST <span class="string">"https://httpbin.org/post"</span> -H <span class="string">"accept: application/json"</span> --json <span class="string">'&#123;"key": "value"&#125;'</span></span><br></pre></td></tr></table></figure><p>但这样发送 JSON，需要在单引号和双引号之间切换，很快就会变得很烦人，但有一个更好的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jo -p key=value | curl -X POST <span class="string">"https://httpbin.org/post"</span> -H <span class="string">"accept: application/json"</span> --json @-</span><br></pre></td></tr></table></figure><p>我想我们都熟悉用 <code>jq</code> 解析 <code>curl</code> 的 JSON 输出，但反过来呢？</p><p>上面我们使用 <code>jo</code> 工具，它可以轻松创建 JSON，然后我们可以使用 <code>--json</code> 选项将其传递给 <code>curl</code>。</p><p>当然，<code>--json</code> 选项也可以从文件中读取输入，例如使用 <code>--json @data.json</code>。</p><h2><span id="协议">协议</span></h2><p>最后但同样重要的是协议 —— 通常我们只会使用 HTTP 或 HTTPS，但 <code>curl</code> 支持 <a href="https://everything.curl.dev/protocols/protocols.html#what-other-protocols-are-there" target="_blank" rel="noopener">很多协议</a>。</p><p>我特别想提到一个是 <code>telnet</code>，它对于测试服务器是否监听特定端口很有用，但如果你在一台没有安装也不能安装 <code>telnet</code> 的服务器/机器上怎么办？只需使用 <code>curl</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同 telnet example.com 1234</span></span><br><span class="line">$ curl telnet://example.com:1234</span><br></pre></td></tr></table></figure><p>一些更为冷门（有趣）的协议选项是用于电子邮件的 IMAP、POP3 和 SMTP，这意味着你可以使用 <code>curl</code> 阅读和发送电子邮件。要阅读它们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --url <span class="string">"imaps://imap.gmail.com:993/Inbox;UID=1"</span> --user <span class="string">"[email protected]:PASSWORD"</span></span><br></pre></td></tr></table></figure><p>要使其在 GMail 上工作，你需要创建 <a href="https://support.google.com/mail/answer/185833?hl=en" target="_blank" rel="noopener">应用密码</a>，这比正常密码更不安全。如果你真的想尝试这个，请查看 <a href="https://developers.google.com/gmail/imap/imap-extensions" target="_blank" rel="noopener">Gmail IMAP 文档</a> 和 <a href="https://gist.github.com/akpoff/53ac391037ae2f2d376214eac4a23634" target="_blank" rel="noopener">这些查询</a> 以获取灵感。</p><p>要发送电子邮件，你可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl smtp://mail.example.com \</span><br><span class="line">  --mail-from [email protected] \</span><br><span class="line">  --mail-rcpt [email protected] \</span><br><span class="line">  --upload-file message.txt \</span><br><span class="line">  -u <span class="string">"[email protected]:PASSWORD"</span></span><br></pre></td></tr></table></figure><p>这里的 <code>message.txt</code> 是实际的电子邮件，需要遵循特定格式，请查看 <a href="https://everything.curl.dev/usingcurl/smtp.html" target="_blank" rel="noopener">这个页面</a> 了解示例。</p><h2><span id="结论">结论</span></h2><p>我们到了最后，我很确定这些例子至少有 10 个（我停止计数了）。但老实说，这只是冰山一角——我们甚至没有触及 <code>curl</code> 的重要级成部分 <code>libcurl</code>。</p><p><code>curl</code> 可以做的事情还有很多，所以我推荐你去探索 <a href="https://curl.se/docs/manpage.html" target="_blank" rel="noopener">文档</a> 和 <a href="https://everything.curl.dev/" target="_blank" rel="noopener">https://everything.curl.dev/</a>。</p><blockquote><p>本文翻译自：「 Martin Heinz 」，原文：<a href="https://martinheinz.dev/blog/113" target="_blank" rel="noopener">https://martinheinz.dev/blog/113</a> ，版权归原作者所有。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;10-个例子展示为什么-cURL-是一个很棒的命令行工具&quot;&gt;10 个例子展示为什么 cURL 是一个很棒的命令行工具&lt;/h2&gt;
&lt;p&gt;无论你是开发者、DevOps 工程师、系统管理员、QA 还是其他技术岗位，你一定对 cURL 很熟悉——用于通过 URL 传输数据的命令行工具和库。&lt;/p&gt;
&lt;p&gt;然而，大多数时候，我们都只用 &lt;code&gt;curl&lt;/code&gt; 来做一些简单的任务，比如下载文件或检查网站是否可访问，但 &lt;code&gt;curl&lt;/code&gt; 能做的远不止这些！&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将介绍一些很酷的例子和技巧，展示为什么 &lt;code&gt;curl&lt;/code&gt; 是一个非常棒且被低估的工具……&lt;/p&gt;
&lt;h2 id=&quot;文件名代换&quot;&gt;文件名代换&lt;/h2&gt;
&lt;p&gt;首先介绍的是文件名代换，它允许我们用一个 &lt;code&gt;curl&lt;/code&gt; 命令发出多个请求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/users/[1-3]&quot;&lt;/span&gt; | jq -s .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/users/[0-10:2]&quot;&lt;/span&gt; | jq -s .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/photos/&amp;#123;1,6,35&amp;#125;&quot;&lt;/span&gt; | jq -s .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s &lt;span class=&quot;string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/users/[1-3]&quot;&lt;/span&gt; -o &lt;span class=&quot;string&quot;&gt;&quot;file_#1.json&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前两个命令展示了如何运行一系列请求——第一个命令会产生对 &lt;code&gt;.../users/1&lt;/code&gt;、&lt;code&gt;.../users/2&lt;/code&gt; 和 &lt;code&gt;.../users/3&lt;/code&gt; 的请求，而另一个使用步长选项，产生 2、4、6、8 和 10 的请求。考虑到这些特定请求返回的是 JSON，我们还将它与 &lt;code&gt;jq ...&lt;/code&gt; 和 &lt;code&gt;-s&lt;/code&gt;（slurp）操作符结合，将单个请求的响应合并为一个数组。&lt;/p&gt;
&lt;p&gt;第三个例子使用了特定数字的列表而不是范围，这也适用于字符和单词。例如，我们可以使用 globbing 发出带有多种协议的请求：&lt;code&gt;{http,https}://...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后一个例子将 globbing 与输出变量结合，文件名中的 &lt;code&gt;#1&lt;/code&gt; 变量指的是范围 &lt;code&gt;[1-3]&lt;/code&gt;。这将生成 &lt;code&gt;file_1.json&lt;/code&gt;、&lt;code&gt;file_2.json&lt;/code&gt; 和 &lt;code&gt;file_3.json&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="cURL" scheme="https://www.hi-linux.com/tags/cURL/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>cdebug 容器调试界的瑞士军刀，5 个超能力让你成为调试大师</title>
    <link href="https://www.hi-linux.com/posts/11869.html"/>
    <id>https://www.hi-linux.com/posts/11869.html</id>
    <published>2024-08-06T01:00:00.000Z</published>
    <updated>2024-08-06T01:38:36.591Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>你是否曾经遇到过这样的情况:</p><ul><li>需要调试一个没有 Shell 的容器?</li><li>或者想访问容器内部未公开的端口?</li><li>也许你只是想方便地将容器文件系统导出到本地?</li></ul><p>如果有，那么 <code>cdebug</code> 就是为你量身打造的工具!</p><a id="more"></a><h2><span id="什么是-cdebug">什么是 cdebug?</span></h2><p><code>cdebug</code> 是一个功能强大的容器调试工具，它就像是容器世界的瑞士军刀。无论你是在处理 <code>Docker</code> 容器、<code>Kubernetes Pod</code>，还是其他类型的容器，<code>cdebug</code> 都能给你提供所需的工具和便利。</p><p>想象一下，你有一个神奇的工具箱，里面装满了各种调试工具。现在，你可以随时随地打开这个工具箱，解决容器中遇到的各种问题。这就是 <code>cdebug</code>!</p><ul><li>Github 地址: <a href="https://github.com/iximiuz/cdebug" target="_blank" rel="noopener">https://github.com/iximiuz/cdebug</a></li></ul><h2><span id="cdebug-能做什么">cdebug 能做什么?</span></h2><ol><li><strong>调试 “无 Shell” 容器</strong>: 即使容器内没有 Shell 或调试工具，你也能轻松进入并调试。</li><li><strong>端口魔术师</strong>: 将未公开的端口或 localhost 端口转发到你的主机系统。</li><li><strong>反向通道</strong>: 将主机系统的端点暴露给容器和 Kubernetes 网络。</li><li><strong>文件系统导出专家</strong>: 轻松将镜像或容器的文件系统导出到本地文件夹。</li><li><strong>更多惊喜等你发现…</strong></li></ol><h2><span id="安装-cdebug-简单得不能再简单">安装 cdebug: 简单得不能再简单!</span></h2><p><code>cdebug</code> 是一个静态链接的 <code>Go</code> 二进制文件，安装起来就像变魔术一样简单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于Linux amd64系统</span></span><br><span class="line">GOOS=linux</span><br><span class="line">GOARCH=amd64</span><br><span class="line"></span><br><span class="line">$ curl -Ls https://github.com/iximiuz/cdebug/releases/latest/download/cdebug_<span class="variable">$&#123;GOOS&#125;</span>_<span class="variable">$&#123;GOARCH&#125;</span>.tar.gz | tar xvz</span><br><span class="line"></span><br><span class="line">$ sudo mv cdebug /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><p>如果你是 <code>Homebrew</code> 用户，那就更简单了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install cdebug</span><br></pre></td></tr></table></figure><p>目前支持的系统:</p><ul><li>linux/amd64</li><li>darwin/amd64</li><li>darwin/arm64</li></ul><h2><span id="cdebug-使用指南-让调试变得有趣">cdebug 使用指南: 让调试变得有趣!</span></h2><h3><span id="1-cdebug-exec-你的容器你做主">1. cdebug exec: 你的容器，你做主</span></h3><p>想在一个 “瘦身” 容器中启动一个交互式 Shell? 没问题!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Docker 容器中启动一个 busybox:musl 的 shell</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it mycontainer</span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it docker://mycontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器中执行命令</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> mycontainer cat /etc/os-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用不同的调试工具包镜像</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image=alpine mycontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 nixery.dev 镜像，按需定制你的工具</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image=nixery.dev/shell/vim/ps/tshark mycontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 containerd 容器中执行</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it containerd://mycontainer ...</span><br><span class="line">$ cdebug <span class="built_in">exec</span> --namespace myns -it containerd://mycontainer ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 nerdctl 在容器中执行 </span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it nerdctl://mycontainer ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Kubernetes pod 中启动 shell</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/mypod</span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it k8s://mypod</span><br><span class="line">$ cdebug <span class="built_in">exec</span> --namespace=myns -it pod/mypod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Kubernetes pod 的容器中启动 shell</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/mypod/mycontainer</span><br></pre></td></tr></table></figure><p><code>cdebug exec</code> 就像是 <code>docker exec</code> 和 <code>kubectl debug</code> 的完美结合。它能让你在目标容器中启动一个调试用的 “伴侣” 容器，感觉就像是在使用 <code>docker exec</code>，但功能更强大:</p><ul><li>调试器的根文件系统就是目标容器的根文件系统。</li><li>目标容器不会被重新创建或重启。</li><li>无需额外的卷或复制调试工具。</li><li>调试工具在目标容器中随时可用。</li></ul><h3><span id="2-cdebug-port-forward-端口转发从未如此简单">2. cdebug port-forward: 端口转发从未如此简单</span></h3><p>想要访问容器内部的 “隐藏” 端口? 或者将本地端口暴露给容器? <code>cdebug port-forward</code> 助你轻松搞定!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器的 80 端口发布到主机的随机端口</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器的 localhost:5432 暴露到主机系统</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L 127.0.0.1:5432</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过目标容器将本地流量代理到远程主机</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L &lt;LOCAL_HOST&gt;:&lt;LOCAL_PORT&gt;:&lt;REMOTE_HOST&gt;:&lt;REMOTE_PORT&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 Kubernetes 服务暴露到主机系统</span></span><br><span class="line">$ cdebug port-forward &lt;target&gt; -L 8888:my.svc.cluster.local:443</span><br></pre></td></tr></table></figure><h3><span id="3-实战示例">3. 实战示例</span></h3><h4><span id="示例-1-给-无-shell-容器一个温暖的家">示例 1: 给 “无 Shell” 容器一个温暖的家</span></h4><p>想象你有一个基于 <code>Distroless</code> 的 <code>Node.js</code> 容器，没有 <code>Shell</code>，没有调试工具，简直就是一个 “光秃秃” 的容器。别担心，<code>cdebug</code> 来救场!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先，启动一个目标容器</span></span><br><span class="line">$ $ docker run -d --rm \</span><br><span class="line">  --name my-distroless gcr.io/distroless/nodejs \</span><br><span class="line">  -e <span class="string">'setTimeout(() =&gt; console.log("Done"), 99999999)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后，使用 cdebug 进入容器</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it my-distroless</span><br><span class="line"></span><br><span class="line"><span class="comment"># 瞧!你现在有了一个交互式 shell</span></span><br><span class="line">/ <span class="variable">$#</span> ls -lah</span><br><span class="line">total 60K</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Oct 17 23:49 .</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Oct 17 23:49 ..</span><br><span class="line">👉 lrwxrwxrwx 1 root     root          18 Oct 17 23:49 .cdebug-c153d669 -&gt; /proc/55/root/bin/</span><br><span class="line">-rwxr-xr-x    1 root     root           0 Oct 17 19:49 .dockerenv</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Jan  1  1970 bin</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Jan  1  1970 boot</span><br><span class="line">drwxr-xr-x    5 root     root         340 Oct 17 19:49 dev</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Oct 17 19:49 etc</span><br><span class="line">drwxr-xr-x    3 nonroot  nonroot     4.0K Jan  1  1970 home</span><br><span class="line">drwxr-xr-x    1 root     root        4.0K Jan  1  1970 lib</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Jan  1  1970 lib64</span><br><span class="line">drwxr-xr-x    5 root     root        4.0K Jan  1  1970 nodejs</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4><span id="示例-2-给你的容器加上超能力">示例 2: 给你的容器加上超能力</span></h4><p>有时候，<code>busybox</code> 提供的工具可能不够用。没关系，我们可以借助 <code>nixery</code> 项目的力量，给容器加上任何你想要的工具!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想要一个带有 vim 的 shell? 没问题!</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image nixery.dev/shell/vim my-distroless</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要更多高级工具?来吧!</span></span><br><span class="line">$ cdebug <span class="built_in">exec</span> -it --image nixery.dev/shell/ps/findutils/tshark my-distroless</span><br></pre></td></tr></table></figure><h4><span id="示例-3-调试-containerd-容器无需-docker">示例 3: 调试 containerd 容器（无需 Docker）</span></h4><p>首先，启动目标容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ctr image pull docker.io/library/nginx:latest</span><br><span class="line">$ sudo ctr run -d docker.io/library/nginx:latest nginx-1</span><br></pre></td></tr></table></figure><p>使用简单的 <code>cdebug exec</code> 在目标容器中运行交互式 <code>Shell</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it containerd://nginx-1</span><br><span class="line">/ <span class="variable">$#</span> wget -O- 127.0.0.1</span><br></pre></td></tr></table></figure><p>使用 <code>cdebug exec --image nixery.dev/shell/vim</code> 在目标容器中运行 <code>VIM</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it --rm --image nixery.dev/shell/vim containerd://nginx-1</span><br></pre></td></tr></table></figure><h4><span id="示例-4-调试-nerdctl-容器无需-docker">示例 4: 调试 nerdctl 容器（无需 Docker）</span></h4><p>使用 <code>nerdctl</code> 启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo $(<span class="built_in">which</span> nerdctl) run -d --name nginx-1 nginx</span><br><span class="line">9f8763d82259a6e3e747df83d0ce8b7ee3d33d94269a72cd04e0e3862a3abc5f</span><br></pre></td></tr></table></figure><p>使用 <code>nerdctl://</code> 模式和目标名称运行调试器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it --rm nerdctl://nginx-1</span><br></pre></td></tr></table></figure><p>或者使用 <code>containerd://</code> 模式在上述容器中运行调试会话：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cdebug <span class="built_in">exec</span> -it --rm containerd://9f876</span><br></pre></td></tr></table></figure><h4><span id="示例-5-kubernetes-pod-调试大师">示例 5: Kubernetes Pod 调试大师</span></h4><p>在 Kubernetes 中调试 Pod 不再是噩梦:</p><p>首先，创建一个 Pod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run --image nginx:alpine nginx-1</span><br><span class="line">$ kubectl run --image=nginx:alpine nginx-1 \</span><br><span class="line">  --overrides=<span class="string">'&#123; "apiVersion": "v1", "spec": &#123; "containers": [&#123; "name": "app", "image": "nginx:alpine" &#125;] &#125; &#125;'</span></span><br><span class="line">pod/nginx-1 created</span><br><span class="line"></span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-1   1/1     Running   0         5s</span><br></pre></td></tr></table></figure><p>然后，使用 <code>cdebug</code> 进入Pod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/nginx-1</span><br><span class="line"></span><br><span class="line">Debugger container name: cdebug-3023d11d</span><br><span class="line">Starting debugger container...</span><br><span class="line">Waiting <span class="keyword">for</span> debugger container...</span><br><span class="line">Attaching to debugger container...</span><br><span class="line">If you don<span class="string">'t see a command prompt, try pressing enter.</span></span><br><span class="line"><span class="string">/ # ps auxf</span></span><br><span class="line"><span class="string">PID   USER     TIME  COMMAND</span></span><br><span class="line"><span class="string">    1 root      0:00 sh /.cdebug-entrypoint.sh</span></span><br><span class="line"><span class="string">   10 root      0:00 /bin/sh -i</span></span><br><span class="line"><span class="string">   11 root      0:00 ps auxf</span></span><br></pre></td></tr></table></figure><p>想要直接进入特定的容器? 也是没问题的!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cdebug <span class="built_in">exec</span> -it pod/nginx-1/app</span><br><span class="line"></span><br><span class="line">cdebug <span class="built_in">exec</span> -it pod/nginx-1/app</span><br><span class="line">Debugger container name: cdebug-b44ca485</span><br><span class="line">Starting debugger container...</span><br><span class="line">Waiting <span class="keyword">for</span> debugger container...</span><br><span class="line">Attaching to debugger container...</span><br><span class="line">If you don<span class="string">'t see a command prompt, try pressing enter.</span></span><br><span class="line"><span class="string">/ # ps auxf</span></span><br><span class="line"><span class="string">PID   USER     TIME  COMMAND</span></span><br><span class="line"><span class="string">    1 root      0:00 nginx: master process nginx -g daemon off;</span></span><br><span class="line"><span class="string">   30 nginx     0:00 nginx: worker process</span></span><br><span class="line"><span class="string">   ...</span></span><br><span class="line"><span class="string">   41 nginx     0:00 nginx: worker process</span></span><br><span class="line"><span class="string">   42 root      0:00 sh /.cdebug-entrypoint.sh</span></span><br><span class="line"><span class="string">   51 root      0:00 /bin/ash -i</span></span><br><span class="line"><span class="string">   52 root      0:00 ps auxf</span></span><br></pre></td></tr></table></figure><h4><span id="示例-6-端口转发魔术">示例 6: 端口转发魔术</span></h4><h5><span id="61-忘记发布容器端口了-cdebug-来帮忙">6.1 忘记发布容器端口了? cdebug 来帮忙:</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个nginx容器，不暴露任何端口</span></span><br><span class="line">$ docker run -d --name nginx-1 nginx:1.23</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 cdebug 将本地 8080 端口转发到容器的 80 端口</span></span><br><span class="line">$ cdebug port-forward nginx-1 -L 8080:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在你可以访问 nginx了</span></span><br><span class="line">$ curl localhost:8080</span><br></pre></td></tr></table></figure><h5><span id="62-将本地端口暴露给容器">6.2 将本地端口暴露给容器:</span></h5><p>启动仅监听本地主机的容器化服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name svc-1 python:3-alpine python3 -m <span class="string">'http.server'</span> -b 127.0.0.1 8888</span><br></pre></td></tr></table></figure><p>利用上述服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cdebug port-forward svc-1 -L 127.0.0.1:8888</span><br><span class="line">Pulling forwarder image...</span><br><span class="line">latest: Pulling from shell&#x2F;socat</span><br><span class="line">Digest: sha256:b43b6cf8d22615616b13c744b8ff525f5f6c0ca6c11b37fa3832a951ebb3c20c</span><br><span class="line">Status: Image is up to date for nixery.dev&#x2F;shell&#x2F;socat:latest</span><br><span class="line">Forwarding 127.0.0.1:49176 to 127.0.0.1:8888 through 172.17.0.4:34128</span><br><span class="line"></span><br><span class="line">$ curl localhost:49176</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2><span id="总结-你的容器调试新伙伴">总结: 你的容器调试新伙伴</span></h2><p><code>cdebug</code> 不仅仅是一个工具，它是你在容器世界冒险时的得力助手。无论你是在调试一个顽固的容器，还是需要快速访问一个隐藏的服务，<code>cdebug</code> 都能帮你搞定。</p><p>记住，在容器的海洋中，<code>cdebug</code> 就是你的瑞士军刀。所以，下次当你面对一个看似不可能的容器调试任务时，别忘了问问自己:“我的 <code>cdebug</code> 在哪里?”</p><p>祝你调试愉快，容器世界的冒险家!</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否曾经遇到过这样的情况:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要调试一个没有 Shell 的容器?&lt;/li&gt;
&lt;li&gt;或者想访问容器内部未公开的端口?&lt;/li&gt;
&lt;li&gt;也许你只是想方便地将容器文件系统导出到本地?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果有，那么 &lt;code&gt;cdebug&lt;/code&gt; 就是为你量身打造的工具!&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="cdebug" scheme="https://www.hi-linux.com/tags/cdebug/"/>
    
  </entry>
  
  <entry>
    <title>开发者必备神器，find-container-process 一键让容器进程无所遁形</title>
    <link href="https://www.hi-linux.com/posts/59304.html"/>
    <id>https://www.hi-linux.com/posts/59304.html</id>
    <published>2024-08-05T01:00:00.000Z</published>
    <updated>2024-08-05T01:21:14.549Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>嘿，开发者朋友们！你是否曾经在一堆容器和进程中迷失过方向？</p><p>你是否曾经怀疑你的容器里到底藏了哪些神秘的进程？别担心，我们的 <code>find-container-process</code> 工具来了！</p><p>这个小工具能帮你轻松找到指定的进程所在的容器，并展示详细信息。它简洁实用，让你在调试和管理容器时不再抓狂。</p><h2><span id="find-container-process-功能">find-container-process 功能</span></h2><p><code>find-container-process</code> 有哪些神奇的功能呢？简单来说，它能：</p><ul><li>根据你输入的进程 ID (PID)，找到对应的 Docker 容器。</li><li>显示进程名称、进程 ID、容器名称和容器 ID。</li><li>提供一个整洁的表格视图，让信息一目了然。</li></ul><a id="more"></a><h2><span id="find-container-process-使用方法">find-container-process 使用方法</span></h2><h3><span id="环境要求">环境要求</span></h3><ul><li>需要安装 <code>Docker</code>。</li></ul><h3><span id="在-docker-容器中运行-find-container-process">在 Docker 容器中运行 find-container-process</span></h3><p>运行以下命令启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it --name find-container-process -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/find-container-process</span><br></pre></td></tr></table></figure><h3><span id="find-container-process-操作方法">find-container-process 操作方法</span></h3><ol><li><strong>输入 PID 列表</strong></li></ol><p>程序启动后，会提示你输入一个或多个 PID（用逗号分隔）。</p><p>别担心，这里没有陷阱，只需输入你想要查找的进程 ID，按下回车键即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter the PIDs (comma-separated): 3347139,3347187,3347188,3347189,3347208</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>查看结果</strong></li></ol><p>程序会显示一个漂亮的表格，包含进程名称、进程 ID、容器名称和容器 ID。</p><p>看看，这样是不是清晰多了？</p><p><img src="https://img.hi-linux.com/staticfile/qGFtDH-2024-08-02-l4sKH9.png" alt></p><h3><span id="注意事项">注意事项</span></h3><ul><li>请确保 Docker 正在运行，并且你有足够的权限访问 Docker 守护进程（即你在 Docker 组中）。</li><li>如果你在容器中运行这个工具，请使用 <code>--privileged</code> 选项，并挂载 Docker 套接字：<code>-v /var/run/docker.sock:/var/run/docker.sock</code>。</li><li>我们使用 <code>--pid=host</code> 和 <code>--net=host</code> 来允许容器访问主机的进程和网络命名空间。</li></ul><h2><span id="结语">结语</span></h2><p>好了，朋友们，现在你又拥有了一个强大的 <code>Docker</code> 小工具，它能在容器和进程的迷宫中轻松导航。</p><p><code>find-container-process</code> 将成为你调试和管理 <code>Docker</code> 容器的得力助手。如果你觉得这个工具有趣又实用，别忘了给我们点个星星哦！</p><p>祝你在容器的世界里玩得开心！🚀</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嘿，开发者朋友们！你是否曾经在一堆容器和进程中迷失过方向？&lt;/p&gt;
&lt;p&gt;你是否曾经怀疑你的容器里到底藏了哪些神秘的进程？别担心，我们的 &lt;code&gt;find-container-process&lt;/code&gt; 工具来了！&lt;/p&gt;
&lt;p&gt;这个小工具能帮你轻松找到指定的进程所在的容器，并展示详细信息。它简洁实用，让你在调试和管理容器时不再抓狂。&lt;/p&gt;
&lt;h2 id=&quot;find-container-process-功能&quot;&gt;find-container-process 功能&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;find-container-process&lt;/code&gt; 有哪些神奇的功能呢？简单来说，它能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据你输入的进程 ID (PID)，找到对应的 Docker 容器。&lt;/li&gt;
&lt;li&gt;显示进程名称、进程 ID、容器名称和容器 ID。&lt;/li&gt;
&lt;li&gt;提供一个整洁的表格视图，让信息一目了然。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>一键测速、24 小时实时监控，MySpeed 让你成为网络管理专家</title>
    <link href="https://www.hi-linux.com/posts/55534.html"/>
    <id>https://www.hi-linux.com/posts/55534.html</id>
    <published>2024-07-30T01:00:00.000Z</published>
    <updated>2024-07-30T05:55:03.012Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>你是否曾经遇到过网速突然变慢，但又不知道如何查找原因的情况？或者你想长期监控你的网络性能，但找不到合适的工具？</p><p>别担心，<code>MySpeed</code> 来啦！这个强大而简单的工具可以帮助你轻松测试和监控网络速度。今天，让我们一起深入了解 <code>MySpeed</code>，看看它如何成为你的网络管家!</p><h2><span id="什么是-myspeed">什么是 MySpeed？</span></h2><p><code>MySpeed</code> 是一个开源的网络速度测试和监控工具。它不仅可以测试你的当前网速，还能持续监控网络性能，并以图表形式展示结果。无论你是网络达人还是普通用户，<code>MySpeed</code> 都能满足你的需求。</p><p><code>MySpeed</code> 支持 <code>Ookla</code>、<code>LibreSpeed</code> 和 <code>Cloudflare</code> 多种速度测试服务器。你可以根据自身需求，在它们之间进行任意选择。</p><ul><li>MySpeed 官方地址</li></ul><p><a href="https://myspeed.dev/" target="_blank" rel="noopener">https://myspeed.dev/</a></p><ul><li>MySpeed Github 地址</li></ul><p><a href="https://github.com/gnmyt/myspeed" target="_blank" rel="noopener">https://github.com/gnmyt/myspeed</a></p><a id="more"></a><p>⭐ MySpeed 具有以下特性</p><p>📊 <code>MySpeed</code> 可生成清晰的速度、<code>Ping</code> 等统计数据<br>⏰ <code>MySpeed</code> 可自动进行速度测试，并允许您使用 <code>Cron</code> 表达式设置测试之间的时间间隔<br>🗄️ 直接向 <code>MySpeed</code> 实例添加多个服务器<br>🩺 配置健康检查，以便在出现错误或停机时通过电子邮件、Signal、WhatsApp 或 Telegram 通知您<br>📆 测试结果可存储长达 30 天<br>🔥 支持 <code>Prometheus</code> 和 <code>Grafana</code><br>🗳️ 在 <code>Ookla</code>、<code>LibreSpeed</code> 和 <code>Cloudflare</code> 速度测试服务器之间进行选择</p><h2><span id="为什么选择-myspeed">为什么选择 MySpeed?</span></h2><ol><li><strong>开源免费</strong>: 作为一个开源项目，<code>MySpeed</code> 完全免费使用，你还可以根据需要自定义功能。</li><li><strong>功能强大</strong>: 支持速度测试、长期监控、数据可视化等多种功能。</li><li><strong>使用简单</strong>: 界面友好，操作直观，即使是技术小白也能轻松上手。</li><li><strong>隐私保护</strong>: 所有数据都存储在你的本地设备上，无需担心隐私泄露。</li></ol><p>好了，话不多说，让我们开始 <code>MySpeed</code> 的奇妙之旅吧!</p><h2><span id="安装-myspeed">安装 MySpeed</span></h2><p><code>MySpeed</code> 使用 <code>Node.js</code> 开发，因此你需要先安装 <code>Node.js</code> 和 <code>NPM</code> 包管理器。</p><p>好消息！<code>MySpeed</code> 现在支持 <code>Docker</code> 安装,这意味着你可以在几分钟内就完成安装,而不需要担心复杂的依赖问题。让我们一起来看看如何通过 <code>Docker</code> 轻松部署 <code>MySpeed</code>。</p><h3><span id="准备工作">准备工作</span></h3><p>在开始之前,请确保你的系统已经安装了 <code>Docker</code>。如果还没有安装,可以访问 <code>Docker</code> 官网下载并安装适合你系统的版本。</p><ol><li>步骤 1: 拉取 MySpeed 镜像</li></ol><p>打开你的终端，输入以下命令来拉取 <code>MySpeed</code> 的 <code>Docker</code> 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull germannewsmaker/myspeed:latest</span><br></pre></td></tr></table></figure><p>这个命令会从 <code>Docker</code> 容器仓库下载最新版本的 <code>MySpeed</code> 最新镜像。</p><ol start="2"><li>步骤 2: 运行 MySpeed 容器</li></ol><p>现在，让我们启动 <code>MySpeed</code> 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5216:5216 -v myspeed:/myspeed/data --restart=unless-stopped --name MySpeed germannewsmaker/myspeed</span><br></pre></td></tr></table></figure><p>这个命令做了以下几件事：</p><ul><li><code>-d</code>: 在后台运行容器</li><li><code>-p 5216:5216</code>: 将容器的 5216 端口映射到主机的 5216 端口</li><li><code>-v myspeed_data:/myspeed/data</code>: 创建一个名为 <code>myspeed_data</code> 的卷,用于持久化存储数据</li><li><code>--name myspeed</code>: 给容器取名为 “myspeed”</li></ul><ol start="3"><li>步骤 3: 验证安装</li></ol><p>打开你喜欢的浏览器,访问 <code>http://localhost:5216</code>。如果你看到 <code>MySpeed</code> 的界面，恭喜你，安装成功了！</p><ol start="4"><li>额外提示：更新 MySpeed</li></ol><p>当有新版本发布时，更新 <code>MySpeed</code> 也非常简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5216:5216 --pull always -v myspeed:/myspeed/data --restart=unless-stopped --name MySpeed germannewsmaker/myspeed</span><br></pre></td></tr></table></figure><p>加入的 <code>--pull always</code> 参数的作用是告诉 <code>Docker</code> 始终尝试更新镜像。</p><h2><span id="使用-myspeed">使用 MySpeed</span></h2><h3><span id="访问-web-界面">访问 Web 界面</span></h3><p>打开你喜欢的浏览器，输入<code>http://localhost:5216</code> 。欢迎来到 <code>MySpeed</code> 的世界!</p><h3><span id="进行速度测试">进行速度测试</span></h3><ol><li>在主页上，你会看到一个大大的 “开始测试” 按钮。</li><li>点击它，MySpeed 就会开始测试你的下载和上传速度。</li><li>稍等片刻，结果就会以清晰的图表和数字展示出来。</li></ol><p><img src="https://img.hi-linux.com/staticfile/9AgHIB-2024-07-29-s9nmOK.png" alt></p><h3><span id="查看历史数据">查看历史数据</span></h3><p><code>MySpeed</code> 不仅仅是一个简单的速度测试工具，它还能帮你记录和分析长期的网络性能。</p><ol><li>点击顶部导航栏的 “设置-切换视图” 选项。</li><li>你会看到一个漂亮的图表，展示了你的网络速度变化趋势。</li><li>可以选择不同的时间范围，比如最近 7 天、30 天或自定义时间段。</li></ol><p><img src="https://img.hi-linux.com/staticfile/WFAeZS-2024-07-29-ZqTuef.png" alt></p><h3><span id="设置自动测试">设置自动测试</span></h3><p>想要 24 小时监控你的网络性能吗？<code>MySpeed</code> 可以帮你实现!</p><ol><li>进入 “设置” 页面。</li><li>找到 “设置频率” 选项。</li><li>设置测试频率，比如：每小时一次。</li><li>保存设置，然后放松一下，让 <code>MySpeed</code> 为你工作吧!</li></ol><p><img src="https://img.hi-linux.com/staticfile/sD5KHH-2024-07-29-217a7g.png" alt></p><h3><span id="数据导出">数据导出</span></h3><p>想要深入分析你的网络数据? <code>MySpeed</code> 支持数据导出功能:</p><ol><li>在 “管理存储” 页面，点击 “导出数据” 按钮。</li><li>选择导出格式 (CSV 或 JSON)。</li><li>选择时间范围。</li><li>下载文件，开始你的数据探索之旅!</li></ol><p><img src="https://img.hi-linux.com/staticfile/Jmy0Kz-2024-07-29-cD99EF.png" alt></p><h2><span id="结语">结语</span></h2><p>无论是日常使用还是长期监控，<code>MySpeed</code> 都将成为你的得力助手。记住，好的网络体验始于了解你的网络状况。所以，开始你的 <code>MySpeed</code> 之旅吧，让我们一起享受畅快的网络世界!</p><p>最后，别忘了时不时地查看 <code>MySpeed</code> 的 GitHub 页面，关注最新的更新和功能。</p><p>如果你有什么好点子，也不要犹豫，给开发者提交一个 <code>Pull Request</code>。谁知道呢，也许你的创意会成为 MySpeed 的下一个重要功能!</p><p>现在，开始你的网速探索之旅吧。愿你的网络永远畅通无阻!</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否曾经遇到过网速突然变慢，但又不知道如何查找原因的情况？或者你想长期监控你的网络性能，但找不到合适的工具？&lt;/p&gt;
&lt;p&gt;别担心，&lt;code&gt;MySpeed&lt;/code&gt; 来啦！这个强大而简单的工具可以帮助你轻松测试和监控网络速度。今天，让我们一起深入了解 &lt;code&gt;MySpeed&lt;/code&gt;，看看它如何成为你的网络管家!&lt;/p&gt;
&lt;h2 id=&quot;什么是-MySpeed？&quot;&gt;什么是 MySpeed？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MySpeed&lt;/code&gt; 是一个开源的网络速度测试和监控工具。它不仅可以测试你的当前网速，还能持续监控网络性能，并以图表形式展示结果。无论你是网络达人还是普通用户，&lt;code&gt;MySpeed&lt;/code&gt; 都能满足你的需求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MySpeed&lt;/code&gt; 支持 &lt;code&gt;Ookla&lt;/code&gt;、&lt;code&gt;LibreSpeed&lt;/code&gt; 和 &lt;code&gt;Cloudflare&lt;/code&gt; 多种速度测试服务器。你可以根据自身需求，在它们之间进行任意选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySpeed 官方地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://myspeed.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://myspeed.dev/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySpeed Github 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gnmyt/myspeed&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/gnmyt/myspeed&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="开源" scheme="https://www.hi-linux.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="MySpeed" scheme="https://www.hi-linux.com/tags/MySpeed/"/>
    
  </entry>
  
  <entry>
    <title>一款超实用的 Docker 容器网络实时监控工具，助你轻松掌握 Docker 容器网络状态</title>
    <link href="https://www.hi-linux.com/posts/36215.html"/>
    <id>https://www.hi-linux.com/posts/36215.html</id>
    <published>2024-07-29T01:00:00.000Z</published>
    <updated>2024-07-29T01:24:49.026Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="1-什么是-check-docker-connection">1. 什么是 check-docker-connection</span></h2><p><code>check-docker-connection</code> 主要用于监控 <code>Docker</code> 容器的网络连接情况。它可以显示指定容器的网络连接状态，包括 <code>TCP</code> 和 <code>UDP</code> 连接的数量。</p><p>用户可以通过容器 <code>ID</code> 或名称来指定要监控的容器，或者指定显示连接数最多的前 N 个容器。输出结果以表格形式展示，方便用户查看。</p><h3><span id="check-docker-connection-主要功能包括">check-docker-connection 主要功能包括：</span></h3><p>列出指定容器的网络连接状态，包括：</p><ul><li>已建立连接（ESTABLISHED）</li><li>TIME_WAIT 状态的连接</li><li>FIN_WAIT2 状态的连接</li><li>CLOSE_WAIT 状态的连接</li><li>监听状态（LISTEN）</li><li>SYN_SENT 状态的连接</li><li>SYN_RECV 状态的连接</li><li>UDP 连接数</li></ul><a id="more"></a><h2><span id="2-check-docker-connection-具体使用方法">2. check-docker-connection 具体使用方法</span></h2><h3><span id="环境要求">环境要求</span></h3><ul><li>需要安装 <code>Docker</code>。</li><li>宿主机上必须安装有 <code>netstat</code> 和 <code>nsenter</code> 命令，以便访问容器的网络命名空间。如果没有，请自行安装，各大发行版上通常都是 <code>net-tools</code> 和 <code>util-linux</code> 包。</li></ul><h3><span id="命令行参数">命令行参数</span></h3><ul><li><code>-c</code>: 指定一个或多个容器的 ID 或名称，多个容器用逗号分隔。</li><li><code>-n</code>: 显示连接数最多的前 N 个容器。</li></ul><p>注意：<code>-c</code> 和 <code>-n</code> 参数不能同时使用。</p><h3><span id="运行-check-docker-connection">运行 check-docker-connection</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><code>check-docker-connection</code> 需要访问 <code>Docker socket</code>，所以我们挂载了 <code>/var/run/docker.sock</code>。</li><li>我们使用 <code>--pid=host</code> 和 <code>--net=host</code> 来允许容器访问主机的进程和网络命名空间。</li><li><code>--privileged</code> 标志允许容器使用 <code>nsenter</code> 命令。</li></ol><h2><span id="3-check-docker-connection-使用实例">3. check-docker-connection 使用实例</span></h2><h3><span id="示例-1监控单个容器">示例 1：监控单个容器</span></h3><p>要监控名为 <code>traefik</code> 的容器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -c traefik</span><br></pre></td></tr></table></figure><p>这将输出该容器的所有网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/uyZkmg-2024-07-25-tLw6IA.png" alt></p><h3><span id="示例-2监控多个容器">示例 2：监控多个容器</span></h3><p>要监控多个容器，例如 <code>traefik</code> 和 <code>splayer</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -c traefik,splayer</span><br></pre></td></tr></table></figure><p>这将显示这两个容器的网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/Klvkhf-2024-07-25-N5PIBC.png" alt></p><h3><span id="示例-3显示连接数最多的前-3-个容器">示例 3：显示连接数最多的前 3 个容器</span></h3><p>要显示连接数最多的前 3 个容器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -n 3</span><br></pre></td></tr></table></figure><p>这将输出连接数最多的三个容器的网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/CHYMME-2024-07-25-4rCycb.png" alt></p><p>通过以上示例，用户可以轻松地监控 Docker 容器的网络连接状态，帮助进行网络性能分析和故障排查。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是-check-docker-connection&quot;&gt;1. 什么是 check-docker-connection&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;check-docker-connection&lt;/code&gt; 主要用于监控 &lt;code&gt;Docker&lt;/code&gt; 容器的网络连接情况。它可以显示指定容器的网络连接状态，包括 &lt;code&gt;TCP&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt; 连接的数量。&lt;/p&gt;
&lt;p&gt;用户可以通过容器 &lt;code&gt;ID&lt;/code&gt; 或名称来指定要监控的容器，或者指定显示连接数最多的前 N 个容器。输出结果以表格形式展示，方便用户查看。&lt;/p&gt;
&lt;h3 id=&quot;check-docker-connection-主要功能包括：&quot;&gt;check-docker-connection 主要功能包括：&lt;/h3&gt;
&lt;p&gt;列出指定容器的网络连接状态，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已建立连接（ESTABLISHED）&lt;/li&gt;
&lt;li&gt;TIME_WAIT 状态的连接&lt;/li&gt;
&lt;li&gt;FIN_WAIT2 状态的连接&lt;/li&gt;
&lt;li&gt;CLOSE_WAIT 状态的连接&lt;/li&gt;
&lt;li&gt;监听状态（LISTEN）&lt;/li&gt;
&lt;li&gt;SYN_SENT 状态的连接&lt;/li&gt;
&lt;li&gt;SYN_RECV 状态的连接&lt;/li&gt;
&lt;li&gt;UDP 连接数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>解锁 VSCode 远程 SSH 的隐藏功能 - 跨用户访问文件系统的完美解决方案</title>
    <link href="https://www.hi-linux.com/posts/31204.html"/>
    <id>https://www.hi-linux.com/posts/31204.html</id>
    <published>2024-07-24T01:00:00.000Z</published>
    <updated>2024-07-24T01:49:54.723Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在使用远程服务器（例如: 虚拟机）时，有时您需要切换到不同的用户，例如：短时间内获得更高的权限。</p><p>通常可以使用以下命令之一来完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su &lt;different-user&gt;</span><br><span class="line">$ sudo -i -u &lt;different-user&gt;</span><br></pre></td></tr></table></figure><p>但如果你想使用 <code>VSCode</code> 时更轻松地探索文件系统和编辑代码，这就不那么简单了。比如：登录用户为 <code>mike</code>，而您想在 VSCode 资源管理器中访问 <code>root</code> 用户的主目录。</p><a id="more"></a><p>首先，您需要在 <code>VSCode</code> 配置中启用一些标志，你可以在用户界面 ( 用 <code>ctrl+,</code> 打开设置，搜索 <code>Remote.SSH</code> ) 中启用：</p><p><img src="https://img.hi-linux.com/staticfile/1*zUTsTgGusNzfhdYGQnyA7g-20240719134757890-2024-07-19-zJ7n8x.png" alt></p><p>或 <code>settings.json</code> 中编辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;remote.SSH.useLocalServer&quot;: true,</span><br><span class="line">&quot;remote.SSH.enableRemoteCommand&quot;: true,</span><br></pre></td></tr></table></figure><p>然后，打开 <code>SSH</code> 配置文件（默认为 <code>/home/$USER/.ssh/config</code>），在主机中添加 <code>RemoteCommand</code> 和 <code>RequestTTY</code> 选项。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host example.com</span><br><span class="line">  HostName example.com</span><br><span class="line">  IdentitiesOnly&#x3D;yes</span><br><span class="line">  User my_user</span><br><span class="line">  RequestTTY yes</span><br><span class="line">  RemoteCommand sudo -i -u other_user</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>RequestTTY</code> 选项的作用是指定是否为会话请求伪 TTY。参数可以是：no（从不请求 TTY）、yes（当标准输入为 TTY 时始终请求 TTY）、force（始终请求 TTY）或 auto（打开登录会话时请求 TTY）。该选项与 -t 和 -T 标志相同。如果你不加上这个选项，通过 SSH 命令行登陆时将无法正常登陆。</p></blockquote><p>如果远程服务器可以访问互联网，那就已经配置完成了。</p><p>否则，您需要采取以下两个步骤中的一个。</p><ol><li>远程服务器可通过代理访问互联网</li></ol><p>在这种情况下，请在需要切换用户的主目录下创建一个 <code>.wgetrc</code> 文件。例如: <code>/home/other_user/.wgetrc</code>，内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use_proxy&#x3D;on</span><br><span class="line">http_proxy&#x3D;http:&#x2F;&#x2F;proxy.host:&lt;port&gt;</span><br><span class="line">https_proxy&#x3D;http:&#x2F;&#x2F;proxy.host:&lt;port&gt;</span><br></pre></td></tr></table></figure><p>这是必要的，因为 <code>VSCode</code> 会在会话开始时使用 <code>wget</code> 下载必要的二进制文件。</p><ol start="2"><li>远程服务器根本无法访问互联网</li></ol><p>在这种情况下，您需要在本地下载 <code>VSCode</code> 服务器文件，然后将其复制（例如: 使用 <code>scp</code>）到服务器，具体步骤如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 本地下载</span><br><span class="line">$ commit_id&#x3D;f1e16e1e6214d7c44d078b1f0607b2388f29d729</span><br><span class="line">$ curl -sSL &quot;https:&#x2F;&#x2F;update.code.visualstudio.com&#x2F;commit:$&#123;commit_id&#125;&#x2F;server-linux-x64&#x2F;stable&quot; -o vscode-server-linux-x64.tar.gz</span><br><span class="line">$ scp  vscode-server-linux-x64.tar.gz user@remotehost:&#x2F;home&#x2F;user&#x2F;</span><br><span class="line"></span><br><span class="line"># 远程服务器操作</span><br><span class="line">$ commit_id&#x3D;f1e16e1e6214d7c44d078b1f0607b2388f29d729</span><br><span class="line">$ mkdir -p ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125;</span><br><span class="line">$ tar zxvf ~&#x2F;vscode-server-linux-x64.tar.gz -C ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125; --strip 1</span><br><span class="line">$ touch ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125;&#x2F;0</span><br></pre></td></tr></table></figure><p>更详细步骤可参考：<a href="https://stackoverflow.com/a/57601121/8175198" target="_blank" rel="noopener">https://stackoverflow.com/a/57601121/8175198</a></p><p>或者，先用 <code>VSCode</code> 远程 <code>SSH</code> 连接正常用户，让它传输文件，然后将文件复制到另一个用户的主目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r &#x2F;home&#x2F;mike&#x2F;.vscode-server&#x2F; &#x2F;root&#x2F;</span><br></pre></td></tr></table></figure><p>您还可以将默认设为在客户端上下载 VSCode 服务器文件，并使用 <code>scp</code> 将其传输到主机，而不是先尝试 <code>wget</code> 将其下载到主机上。</p><p><img src="https://img.hi-linux.com/staticfile/1*a-Yc1-R4b707xJSkq8qnwQ-2024-07-19-ngo7vk.png" alt></p><p>您也可以更改这些文件的安装位置</p><p><img src="https://img.hi-linux.com/staticfile/1*61VUKyX8fM13gW4Vb8e1MA-2024-07-19-q2Ii72.png" alt></p><p>参考文档：</p><ol><li><a href="https://medium.com/@krisztian.sala/vs-code-remote-ssh-as-another-user-57d449e20fb1" target="_blank" rel="noopener">https://medium.com/@krisztian.sala/vs-code-remote-ssh-as-another-user-57d449e20fb1</a></li><li><a href="https://stackoverflow.com/a/57601121/8175198" target="_blank" rel="noopener">https://stackoverflow.com/a/57601121/8175198</a></li><li><a href="https://github.com/b01/dl-vscode-server" target="_blank" rel="noopener">https://github.com/b01/dl-vscode-server</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用远程服务器（例如: 虚拟机）时，有时您需要切换到不同的用户，例如：短时间内获得更高的权限。&lt;/p&gt;
&lt;p&gt;通常可以使用以下命令之一来完成：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ su &amp;lt;different-user&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo -i -u &amp;lt;different-user&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但如果你想使用 &lt;code&gt;VSCode&lt;/code&gt; 时更轻松地探索文件系统和编辑代码，这就不那么简单了。比如：登录用户为 &lt;code&gt;mike&lt;/code&gt;，而您想在 VSCode 资源管理器中访问 &lt;code&gt;root&lt;/code&gt; 用户的主目录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="VSCode" scheme="https://www.hi-linux.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>无需 Dockerfile，打造你的专属即时容器镜像--自建 Nixery 私有服务器</title>
    <link href="https://www.hi-linux.com/posts/26894.html"/>
    <id>https://www.hi-linux.com/posts/26894.html</id>
    <published>2024-07-22T01:00:00.000Z</published>
    <updated>2024-07-22T02:17:10.405Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>自建一个 <code>Nixery</code> 实例可以让你在本地或私有服务器上运行 <code>Nixery</code> 服务，从而避免公共服务的不稳定性。以下是一个基本的步骤指南，帮助你在本地或服务器上部署 <code>Nixery</code>。</p><h2><span id="1-准备环境">1. 准备环境</span></h2><p>确保你的系统已经安装了以下软件：</p><ul><li>Nix</li><li>Docker</li><li>Git</li></ul><p><code>Docker</code> 和 <code>Git</code> 属于基础软件，就不再展开讲解安装部分了。<code>Nix</code> 安装你可以参考 <a href="https://nixos.org/download/#nix-install-linux" target="_blank" rel="noopener">Nix 官方文档</a> 进行安装。</p><a id="more"></a><h2><span id="2-克隆-nixery-仓库">2. 克隆 Nixery 仓库</span></h2><p>首先，你需要克隆 <code>Nixery</code> 的代码仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://code.tvl.fyi/depot.git:/tools/nixery.git nixery</span><br><span class="line">$ <span class="built_in">cd</span> nixery</span><br></pre></td></tr></table></figure><h2><span id="3-构建和运行-nixery">3. 构建和运行 Nixery</span></h2><p>使用 <code>Nix</code> 构建 <code>Nixery</code> 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nix-build -A nixery-image</span><br></pre></td></tr></table></figure><p>构建完成后，你会在 <code>result</code> 目录中得到一个 <code>Docker</code> 镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载镜像</span></span><br><span class="line">$ docker load &lt; result</span><br><span class="line"><span class="comment"># 按你的实际 tag 修改下面的值</span></span><br><span class="line">$ docker tag nixery:bbgi5sfqwpp6fsd36ccqw9yi0vykdkz3 nixery:latest</span><br></pre></td></tr></table></figure><h2><span id="4-配置-nixery">4. 配置 Nixery</span></h2><p><code>Nixery</code> 支持多种配置选项，可以通过环境变量进行设置。以下是一些常见的配置选项：</p><ul><li>PORT：Nixery 应监听的 HTTP 端口</li><li>NIXERY_CHANNEL：用于构建 Nixery 的 Nix/NixOS 通道名称。</li><li>NIXERY_PKGS_REPO：包含软件包集的 git 仓库的 URL（使用本地配置的 SSH/git 凭据）</li><li>NIXERY_PKGS_PATH：包含用于构建的 Nix 软件包集的本地文件系统路径</li><li>NIXERY_STORAGE_BACKEND：要使用的后端存储类型，目前支持的值为 gcs（谷歌云存储）和 filesystem。</li><li>NIX_TIMEOUT：允许任何 Nix 生成器运行的秒数（默认值为 60）</li><li>NIX_POPULARITY_URL：指向包含软件包集受欢迎程度数据的文件的 URL（参见 popcount/）。</li></ul><h4><span id="存储">存储</span></h4><p><code>Nixery</code> 支持多种不同的存储后端，构建缓存和图像层都保存在这些后端中，并从这些后端提供服务。</p><p>目前可用的存储后端有谷歌云端存储和本地文件系统。</p><p>在谷歌云存储中，通过将客户端重定向到存储桶来提供镜像。存储在文件系统中的镜像图层则直接从本地磁盘提供。</p><p>要配置存储后端，必须设置这些额外的配置环境变量：</p><ul><li>GCS_BUCKET：要使用的谷歌云存储桶名称（gcs 必填）</li><li>GOOGLE_APPLICATION_CREDENTIALS：指向 GCP 服务帐户 JSON 密钥的路径（GCS 可选）</li><li>STORAGE_PATH：用于存储和提供数据的文件夹的路径（本地存储路径）</li></ul><p>如果 <code>GOOGLE_APPLICATION_CREDENTIALS</code> 环境变量设置为服务账户密钥，<code>Nixery</code> 将使用该密钥为存储桶中的图层创建签名 URL。这样就可以从存储桶中提供图层，而无需将其公开。</p><p>如果未设置 <code>GOOGLE_APPLICATION_CREDENTIALS</code> 环境变量，则会重定向到 <code>storage.googleapis.com</code>，这意味着底层的存储桶对象需要可公开访问。</p><h2><span id="5-运行-nixery-容器">5. 运行 Nixery 容器</span></h2><ul><li>使用本地文件系统作为存储后端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nixery -d -p 8080:8080 \</span><br><span class="line">  -e PORT&#x3D;8080 \</span><br><span class="line">  -e NIXERY_STORAGE_BACKEND&#x3D;filesystem \</span><br><span class="line">  -e STORAGE_PATH&#x3D;&#x2F;opt&#x2F;data&#x2F;store \</span><br><span class="line">  -e NIXERY_PKGS_REPO&#x3D;https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs \</span><br><span class="line">  -e NIXERY_CHANNEL&#x3D;nixos-unstable \</span><br><span class="line">  -v .&#x2F;data:&#x2F;opt&#x2F;data&#x2F;  \</span><br><span class="line">  nixery:latest</span><br></pre></td></tr></table></figure><ul><li>使用 GCS 作为存储后端</li></ul><p>如果你想使用 <code>Google Cloud Storage</code> (GCS) 作为存储后端，可以按以下步骤操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nixery -d -p 8080:8080 \</span><br><span class="line">  -e PORT&#x3D;8080 \</span><br><span class="line">  -e NIXERY_STORAGE_BACKEND&#x3D;gcs \</span><br><span class="line">  -e GCS_BUCKET&#x3D;your-gcs-bucket-name \</span><br><span class="line">  -e NIXERY_PKGS_REPO&#x3D;https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs \</span><br><span class="line">  -e NIXERY_CHANNEL&#x3D;nixos-unstable \</span><br><span class="line">  -v .&#x2F;data:&#x2F;opt&#x2F;data&#x2F;  \  </span><br><span class="line">  nixery</span><br></pre></td></tr></table></figure><ul><li>访问自建的 Nixery</li></ul><p>现在，你应该可以通过 <code>http://localhost:8080</code> 访问你的 Nixery 实例。</p><h2><span id="6-使用自建的-nixery-拉取镜像">6. 使用自建的 Nixery 拉取镜像</span></h2><p>启动 <code>Nixery</code> 容器后，你可以像使用公共 <code>Nixery</code> 服务一样使用你自建的 <code>Nixery</code> 实例。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it localhost:8080/shell/btop</span><br><span class="line">$ docker run --rm -it IP:8080/shell/git/btop/curl</span><br></pre></td></tr></table></figure><h2><span id="7-进一步配置">7. 进一步配置</span></h2><p>你可以根据需要进一步配置你的 <code>Nixery</code> 实例，例如：</p><ul><li>使用 Nginx 或其他反向代理服务器来处理请求</li></ul><p>以下是一个使用 <code>Nginx</code> 作为反向代理的示例配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name your.domain.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:8080;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 HTTP 访问 Nixery 实例</li></ul><p>自建的 <code>Nixery</code> 实例默认没有支持 <code>HTTPS</code>。你如果不想配置 <code>HTTPS</code>，请确保 <code>Docker Daemon</code> 允许使用 <code>HTTP</code> 连接。你可以通过以下步骤进行配置：</p><ol><li>编辑 <code>Docker Daemon</code> 的配置文件（通常位于 <code>/etc/docker/daemon.json</code>）并添加不安全的注册表地址</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [<span class="string">"10.1.2.3:8080"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：10.1.2.3:8080 是你的 Nixery 实例的 IP 地址和端口号，请按实际情况修改。</p></blockquote><ol start="2"><li>重启 Docker 服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2><span id="8-监控和日志">8. 监控和日志</span></h2><p>为了保证服务的稳定运行，你可能需要设置监控和日志系统。例如，可以使用 <code>Prometheus</code> 和 <code>Grafana</code> 来监控 <code>Nixery</code> 的性能。</p><p>通过这些步骤，你能够成功自建一个 Nixery 实例并根据需要进行配置和扩展。如果你在过程中遇到任何问题，可以参考 Nixery 的文档或社区支持。</p><h2><span id="9-彩蛋">9. 彩蛋</span></h2><p>自建 <code>Nixery</code> 私有服务器最大的技术难点是需要 <code>Nix</code> 环境。你如果不想扯腾 <code>Nix</code> 环境，可以直接使用我构建好的 <code>Nixery</code> 的镜像。</p><p>你只需要在公众号后台直接回复「<code>Nixery</code>」，即可免费获取 <code>Nixery</code> 镜像下载地址。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自建一个 &lt;code&gt;Nixery&lt;/code&gt; 实例可以让你在本地或私有服务器上运行 &lt;code&gt;Nixery&lt;/code&gt; 服务，从而避免公共服务的不稳定性。以下是一个基本的步骤指南，帮助你在本地或服务器上部署 &lt;code&gt;Nixery&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1-准备环境&quot;&gt;1. 准备环境&lt;/h2&gt;
&lt;p&gt;确保你的系统已经安装了以下软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nix&lt;/li&gt;
&lt;li&gt;Docker&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 和 &lt;code&gt;Git&lt;/code&gt; 属于基础软件，就不再展开讲解安装部分了。&lt;code&gt;Nix&lt;/code&gt; 安装你可以参考 &lt;a href=&quot;https://nixos.org/download/#nix-install-linux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nix 官方文档&lt;/a&gt; 进行安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nixery" scheme="https://www.hi-linux.com/tags/Nixery/"/>
    
      <category term="Nix" scheme="https://www.hi-linux.com/tags/Nix/"/>
    
  </entry>
  
  <entry>
    <title>无需 Dockerfile，打造你的专属即时容器镜像--Nixery 中文使用指南</title>
    <link href="https://www.hi-linux.com/posts/3191.html"/>
    <id>https://www.hi-linux.com/posts/3191.html</id>
    <published>2024-07-18T01:00:00.000Z</published>
    <updated>2024-07-18T01:32:01.107Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言">引言</span></h2><p>面对现代软件开发和运维的世界，环境配置是一个绕不过去的话题。如何确保在各种不同环境下快速构建和运行所需的服务和应用，一直是开发者和运维团队关注的焦点。</p><p>Nixery，一个基于 Nix 包管理器的工具，能够帮助你快速构建和获取简单、即开即用的容器镜像。</p><p>本文将以简洁实用且有趣的方式带你入门 Nixery，并展示如何充分利用它的强大功能。</p><h2><span id="什么是-nixery">什么是 Nixery？</span></h2><p>Nixery 是一个由 Tazjin 开发的项目，它基于 Nix 包管理器，为用户提供了按需构建的容器镜像服务。它的核心理念是通过简化镜像生成过程，从而让用户能够在几乎无需配置的情况下，快速获取和运行所需服务。Nixery 允许用户通过指定 URL 参数来构建和获取包含特定软件包的容器镜像。</p><ul><li>Nixery 官方网址</li></ul><p><a href="https://nixery.dev/" target="_blank" rel="noopener">https://nixery.dev/</a></p><ul><li>Nixery Github 地址</li></ul><p><a href="https://github.com/tazjin/nixery" target="_blank" rel="noopener">https://github.com/tazjin/nixery</a></p><a id="more"></a><h2><span id="nixery-的优势">Nixery 的优势</span></h2><ul><li><strong>即时性</strong>：Nixery 能够快速生成所需的容器镜像，无需等待漫长的构建过程。</li><li><strong>灵活性</strong>：你可以通过简单地修改 URL 来定制镜像内容，这使得创建不同环境变得非常简单。</li><li><strong>无需配置</strong>：通过 Nixery，你不用编写任何 Dockerfile 或配置文件就能获得所需的镜像。</li></ul><h2><span id="一步步体验-nixery">一步步体验 Nixery</span></h2><h3><span id="准备工作">准备工作</span></h3><p>在开始使用 Nixery 之前，你需要确保已经安装了 Docker。如果还没有安装，可以访问 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker 官方网站</a> 下载并安装相应版本。</p><h3><span id="获取基础镜像">获取基础镜像</span></h3><p>Nixery 使用非常简单，通过访问特定的 URL 即可获取相应的镜像。基础镜像是最简单的形式，只包含一些最基本的系统工具。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell</span><br></pre></td></tr></table></figure><p>这条命令将会拉取一个包含基本 shell 工具的镜像并启动一个交互式终端。</p><h3><span id="定制你的镜像">定制你的镜像</span></h3><p>Nixery 的强大之处在于，你可以通过简单地在 URL 中加入软件包名称来定制镜像。例如，如果你想要一个包含 <code>curl</code> 和 <code>jq</code> 工具的镜像，只需运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/curl/jq</span><br></pre></td></tr></table></figure><h3><span id="运行多功能镜像">运行多功能镜像</span></h3><p>想象这样一个场景：你需要一个同时包含 Git, Python 和 Node.js 的开发环境。使用 Nixery 可以轻松实现：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/git/python3/nodejs</span><br></pre></td></tr></table></figure><h3><span id="组合更多工具">组合更多工具</span></h3><p>除了基本的命令行工具，你还可以通过 Nixery 获取更多复杂的服务和工具。例如，获取一个包含 <code>nettools</code> 和 <code>openssl</code> 的镜像只需要这样做：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/openssl/nettools/procps</span><br></pre></td></tr></table></figure><h3><span id="链接到-github-项目">链接到 GitHub 项目</span></h3><p>Nixery 的一个非常实用的功能是可以直接在你的 CI/CD 流水线中使用。你只需在项目的 Dockerfile 中指定所需的镜像 URL，然后在 CI/CD 过程中使用它。</p><p>例如，在 GitHub Actions 中使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Nixery</span> <span class="string">container</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">docker</span> <span class="string">run</span> <span class="string">nixery.dev/shell/git</span></span><br><span class="line">        <span class="string">git</span> <span class="string">--version</span></span><br></pre></td></tr></table></figure><h2><span id="nixery-的工作原理">Nixery 的工作原理</span></h2><p>Nixery 背后是强大的 Nix 包管理系统。当你请求一个包含特定工具的镜像时，Nixery 使用 Nix 构建系统来解析这些工具的依赖关系并实时构建镜像。这意味着即使是较大的工具集，也能在短时间内构建完成并供你使用。</p><h2><span id="深入进阶自定义-nix-配置">深入进阶：自定义 Nix 配置</span></h2><p>虽然 URL 参数已经可以满足大部分需求，但有时候你可能需要更复杂的配置。这时，你可以通过自定义 Nix 配置文件来满足特定需求。例如，假设你需要一个包含特定版本的 Python 和一些拓展模块的镜像，Nix 配置可以让你做到这一点。</p><p>假设你创建了一个自定义 Nix 配置文件 <code>default.nix</code>：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; pkgs ? <span class="built_in">import</span> &lt;nixpkgs&gt; &#123;&#125; &#125;:</span><br><span class="line"></span><br><span class="line">pkgs.dockerTools.buildImage &#123;</span><br><span class="line">  <span class="attr">name</span> = <span class="string">"custom-python"</span>;</span><br><span class="line">  <span class="attr">contents</span> = [</span><br><span class="line">    pkgs.python39</span><br><span class="line">    pkgs.python39Packages.requests</span><br><span class="line">    pkgs.python39Packages.numpy</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过 Nix 构建镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nix-build -E <span class="string">'with import &lt;nixpkgs&gt; &#123;&#125;; callPackage ./default.nix &#123;&#125;'</span></span><br></pre></td></tr></table></figure><p>这将生成一个你可以本地使用的自定义 Docker 镜像。构建完成后，你可以使用 Docker 运行生成的镜像。</p><h2><span id="用例分享">用例分享</span></h2><h3><span id="1-数据分析">1. 数据分析</span></h3><p>假设你是一名数据分析师，时常需要一个包含各种数据处理工具的环境。你可以通过以下方式快速创建所需的容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/python312/python312packages.pandas/python312packages.numpy python</span><br></pre></td></tr></table></figure><h3><span id="2-web-开发">2. Web 开发</span></h3><p>如果你是一名 Web 开发者，为了开发和调试，你需要一个同时包含 Node.js 和一些常用数据库客户端的环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/nodejs/postgresql/mysql80</span><br><span class="line">docker run -it nixery.dev/nodejs/postgresql/mysql80 mysql -h 10.0.0.1 -P 3306 -u root -p 123456</span><br></pre></td></tr></table></figure><h3><span id="3-机器学习">3. 机器学习</span></h3><p>对于机器学习的开发者来说，一个包含 Jupyter Notebook 和 SciKit Learn 的镜像或许是理想的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/python312/jupyter/python312packages.scikit-learn</span><br></pre></td></tr></table></figure><h2><span id="结尾">结尾</span></h2><p>Nixery 的出现将容器镜像的获取简化到了只需添加几个 URL 参数的程度。它不仅强大且灵活，还能大大提升开发和运维的效率。在你下一次需要快速搭建开发环境、临时测试新工具或在 CI/CD 流水线中集成各种服务时，不妨试试 Nixery，享受它带来的便利与乐趣。</p><p>Nixery 的潜力远不止于此，随着你对它的使用越来越深入，你会发现更多能够解锁的新功能和新用例。希望本教程为你的开发和运维工作带来更多的灵感和帮助！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;面对现代软件开发和运维的世界，环境配置是一个绕不过去的话题。如何确保在各种不同环境下快速构建和运行所需的服务和应用，一直是开发者和运维团队关注的焦点。&lt;/p&gt;
&lt;p&gt;Nixery，一个基于 Nix 包管理器的工具，能够帮助你快速构建和获取简单、即开即用的容器镜像。&lt;/p&gt;
&lt;p&gt;本文将以简洁实用且有趣的方式带你入门 Nixery，并展示如何充分利用它的强大功能。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Nixery？&quot;&gt;什么是 Nixery？&lt;/h2&gt;
&lt;p&gt;Nixery 是一个由 Tazjin 开发的项目，它基于 Nix 包管理器，为用户提供了按需构建的容器镜像服务。它的核心理念是通过简化镜像生成过程，从而让用户能够在几乎无需配置的情况下，快速获取和运行所需服务。Nixery 允许用户通过指定 URL 参数来构建和获取包含特定软件包的容器镜像。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nixery 官方网址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://nixery.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nixery.dev/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nixery Github 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tazjin/nixery&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/tazjin/nixery&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nixery" scheme="https://www.hi-linux.com/tags/Nixery/"/>
    
      <category term="Nix" scheme="https://www.hi-linux.com/tags/Nix/"/>
    
  </entry>
  
  <entry>
    <title>ptcpdump 新一代抓包神器，可捕获任何进程、容器或 Pod 的网络流量</title>
    <link href="https://www.hi-linux.com/posts/14172.html"/>
    <id>https://www.hi-linux.com/posts/14172.html</id>
    <published>2024-07-15T01:00:00.000Z</published>
    <updated>2024-07-15T03:41:55.961Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="前言">前言</span></h2><p>tcpdump 是我们常用的一个网络抓包工具，它的功能非常的强大。但是它还缺少一个大家反馈很久却一直没实现的一个特性， 那就是：在结果中包含/显示发送网络请求/流量的进程信息，以及支持抓取指定进程的网络流量。</p><p>当前针对 tcpdump 抓取的流量信息，如果要获取对应的进程信息的话，常见的方法是： 基于请求的连接信息，通过 <code>ss</code> 或 <code>netstat</code> 之内的工具反查进程信息。 这个方法的缺点是：操作起来比较繁琐以及无法查找匹配短生命周期的进程所发送的网络流量。</p><p>至于基于 tcpdump 实现抓取指定进程的网络流量，常见的方法是：在知晓进程要访问的目标服务地址信息的前提下， 在使用 tcpdump 时按目的地址信息过滤流量； 或者是在特定的网络命名空间中运行目标进程，然后再在该网络命名空间下使用 tcpdump 抓包。 这两个方法的缺点是：需要提前知晓目标进程访问的目的地址或者需要改变目标进程的执行方式，适用场景有限。</p><p>本文将介绍一个新的工具 ptcpdump，基于这个工具，我们既可以在抓包时直接感知发送流量的进程信息， 也可以直接对运行中或待运行的任意进程进行网络抓包。如果流量是从容器内的进程发出的话， 它还支持显示流量的容器或 Pod 信息以及对特定容器或 Pod 进行抓包。</p><h2><span id="ptcpdump-介绍">ptcpdump 介绍</span></h2><p>ptcpdump 是一个使用 eBPF 技术开发的、类 tcpdump 的网络抓包工具。 它除了兼容 tcpdump 的常用命令行参数以及包过滤语法外， 还额外提供了如下核心特性：</p><ul><li>在输出中记录和显示发送网络流量的进程、容器、Pod 信息。</li><li>支持对指定进程、容器以及 Pod 进行抓包。</li><li>支持将抓取的数据包保存为 pcapng 格式，可以使用 tcpdump 或者 Wireshark 做进一步分析。</li><li>当在 Wireshark 中打开保存的 pcapng 文件时，将能够看到每个数据包对应的进程、容器、Pod 信息。</li><li>使用静态链接的方式编译该工具，系统中不需要安装额外的系统链接库。</li></ul><p>更多信息请参考项目的源代码仓库： <a href="https://github.com/mozillazg/ptcpdump" target="_blank" rel="noopener">https://github.com/mozillazg/ptcpdump</a></p><p>下面将以示例的形式介绍 ptcpdump 的核心功能。</p><h2><span id="兼容-tcpdump-的常用命令行参数和包过滤语法">兼容 tcpdump 的常用命令行参数和包过滤语法</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i eth0 tcp</span><br><span class="line">sudo tcpdump -i eth0 tcp and port 80 and host 10.10.1.1</span><br><span class="line">sudo tcpdump -i eth0 &#39;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) !&#x3D; 0&#39;</span><br><span class="line">sudo tcpdump -i any</span><br><span class="line">sudo tcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80</span><br></pre></td></tr></table></figure><p>上面这些常见的 tcpdump 命令可以直接无缝替换为对应的 ptcpdump 命令，只需要将 tcpdump 改为 ptcpdump 即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo ptcpdump -i eth0 tcp</span><br><span class="line">sudo ptcpdump -i eth0 tcp and port 80 and host 10.10.1.1</span><br><span class="line">sudo ptcpdump -i eth0 &#39;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) !&#x3D; 0&#39;</span><br><span class="line">sudo ptcpdump -i any</span><br><span class="line">sudo ptcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80</span><br></pre></td></tr></table></figure><h2><span id="在输出中记录和显示发送网络流量的进程-容器和-pod-信息">在输出中记录和显示发送网络流量的进程、容器和 Pod 信息</span></h2><p>默认情况下，ptcpdump 将在输出中显示简单的进程、容器以及 Pod 信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 4 port 80 or port 443</span><br><span class="line">2024-07-07 12:56:56 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 12:56:56 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">12:56:59.517657 veth18618a4a wget.13626 In IP 10.244.0.4.46834 &gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]</span><br><span class="line">12:56:59.517836 eth0 wget.13626 Out IP 172.19.0.2.46834 &gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]</span><br><span class="line">12:56:59.692593 eth0 wget.13626 In IP 13.251.96.10.443 &gt; 172.19.0.2.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]</span><br><span class="line">12:56:59.692754 veth18618a4a wget.13626 Out IP 13.251.96.10.443 &gt; 10.244.0.4.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]</span><br><span class="line">4 packets captured</span><br><span class="line">6 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><p>可以通过指定 <code>-v</code> 参数，查看更详细的进程、容器以及 Pod 信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ptcpdump -i any -c 4 -v port 80 or port 443</span><br><span class="line">2024-07-07 12:58:59 WARN ptcpdump: capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">12:59:02.265356 veth18618a4a In IP (tos 0x0, ttl 64, id 35996, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    10.244.0.4.41666 &gt; 13.215.144.61.443: Flags [S], cksum 0xa93a, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">12:59:02.265606 eth0 Out IP (tos 0x0, ttl 63, id 35996, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    172.19.0.2.41666 &gt; 13.215.144.61.443: Flags [S], cksum 0x4a58, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">12:59:02.462586 eth0 In IP (tos 0x4, ttl 47, id 0, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    13.215.144.61.443 &gt; 172.19.0.2.41666: Flags [S.], cksum 0x9772, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">12:59:02.462782 veth18618a4a Out IP (tos 0x4, ttl 46, id 0, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    13.215.144.61.443 &gt; 10.244.0.4.41666: Flags [S.], cksum 0x3890, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">4 packets captured</span><br><span class="line">6 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h2><span id="支持对指定进程-容器或-pod-进行抓包">支持对指定进程、容器或 Pod 进行抓包</span></h2><h3><span id="指定进程-pid-抓包">指定进程 pid 抓包</span></h3><p>可以通过 <code>--pid</code> 参数指定要抓包的进程 pid，实现对指定进程进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 4 --pid 82106</span><br><span class="line">2024-07-07 13:11:40 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:11:40 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:11:50.170538 ens33 python3.10.82106 Out IP 10.0.2.15.36648 &gt; 13.251.96.10.443: Flags [S], seq 1633417447, win 64240, length 0</span><br><span class="line">13:11:50.369972 ens33 python3.10.82106 In IP 13.251.96.10.443 &gt; 10.0.2.15.36648: Flags [S.], seq 1793291274, ack 1633417448, win 64240, length 0</span><br><span class="line">2 packets captured</span><br><span class="line">3 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><p>同时还可以通过指定 <code>-f</code> 参数对该进程创建的子进程也进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 4 --pid 82106 -f &#39;tcp[tcpflags] &amp; tcp-fin !&#x3D; 0&#39;</span><br><span class="line">2024-07-07 13:17:31 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:17:31 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:17:37.800903 ens33 python3.10.82106 Out IP 10.0.2.15.38576 &gt; 52.74.166.77.443: Flags [F.], seq 2442149577, ack 367271121, win 62780, length 0</span><br><span class="line">13:17:37.977316 ens33 python3.10.82106 In IP 52.74.166.77.443 &gt; 10.0.2.15.38576: Flags [FP.], seq 367271145, ack 2442149578, win 64239, length 0</span><br><span class="line">13:17:44.390627 ens33 curl.95920 Out IP 10.0.2.15.38590 &gt; 52.74.166.77.443: Flags [F.], seq 3726932781, ack 1510095004, win 63045, length 0</span><br><span class="line">13:17:44.564990 ens33 curl.95920 In IP 52.74.166.77.443 &gt; 10.0.2.15.38590: Flags [FP.], seq 1510095028, ack 3726932782, win 64239, length 0</span><br><span class="line">4 packets captured</span><br><span class="line">4 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="指定进程名称抓包">指定进程名称抓包</span></h3><p>可以通过 <code>--pname</code> 参数指定进程名称（comm），实现指定进程名称抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --pname curl</span><br><span class="line">2024-07-07 13:23:18 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:23:18 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:23:24.881499 lo curl.26511 Out IP 127.0.0.1.43332 &gt; 127.0.0.53.53: 44133+ [1au] A? mozillazg.com. (42)</span><br><span class="line">13:23:24.881663 lo curl.26511 Out IP 127.0.0.1.43332 &gt; 127.0.0.53.53: 14694+ [1au] AAAA? mozillazg.com. (42)</span><br><span class="line">2 packets captured</span><br><span class="line">2 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="通过运行目标程序来抓包">通过运行目标程序来抓包</span></h3><p>有需要的话，也可以通过使用 <code>--</code> 参数运行目标程序的方式来实现对特定程序进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -- curl -I https:&#x2F;&#x2F;mozillazg.com</span><br><span class="line">2024-07-07 13:26:44 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:26:44 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:26:44.055757 lo curl.28094 Out IP 127.0.0.1.48826 &gt; 127.0.0.53.53: 8942+ [1au] A? mozillazg.com. (42)</span><br><span class="line">13:26:44.055914 lo curl.28094 Out IP 127.0.0.1.48826 &gt; 127.0.0.53.53: 34274+ [1au] AAAA? mozillazg.com. (42)</span><br><span class="line">13:26:44.775840 lo curl.28094 In IP 127.0.0.53.53 &gt; 127.0.0.1.48826: 8942 3&#x2F;0&#x2F;1 CNAME mozillazg.netlify.com., A 13.251.96.10, A 46.137.195.11 (106)</span><br><span class="line">13:26:45.135988 lo curl.28094 In IP 127.0.0.53.53 &gt; 127.0.0.1.48826: 34274 3&#x2F;0&#x2F;1 CNAME mozillazg.netlify.com., AAAA 2406:da18:880:3802::c8, AAAA 2406:da18:b3d:e202::64 (130)</span><br><span class="line">13:26:45.136819 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [S], seq 3460683104, win 64800, length 0</span><br><span class="line">13:26:45.310505 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [S.], seq 630810442, ack 3460683105, win 65232, length 0</span><br><span class="line">13:26:45.310821 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683105, ack 630810443, win 507, length 0</span><br><span class="line">13:26:45.414551 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683105:3460683622, ack 630810443, win 507, length 517</span><br><span class="line">13:26:45.595214 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443, ack 3460683622, win 127, length 0</span><br><span class="line">13:26:45.595413 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443:630811651, ack 3460683622, win 127, length 1208</span><br><span class="line">13:26:45.595595 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630811651, win 501, length 0</span><br><span class="line">13:26:45.595702 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630811651:630812859, ack 3460683622, win 127, length 1208</span><br><span class="line">13:26:45.595797 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630812859, win 492, length 0</span><br><span class="line">13:26:45.595862 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630812859:630813338, ack 3460683622, win 127, length 479</span><br><span class="line">13:26:45.595934 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630813338, win 489, length 0</span><br><span class="line">13:26:45.600998 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683622:3460683686, ack 630813338, win 489, length 64</span><br><span class="line">13:26:45.601344 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683686:3460683781, ack 630813338, win 489, length 95</span><br><span class="line">13:26:45.616759 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683781:3460683882, ack 630813338, win 501, length 101</span><br><span class="line">13:26:45.779516 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813338, ack 3460683781, win 127, length 0</span><br><span class="line">13:26:45.779792 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813338:630813399, ack 3460683781, win 127, length 61</span><br><span class="line">13:26:45.779996 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813399:630813443, ack 3460683781, win 127, length 44</span><br><span class="line">13:26:45.780318 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683882:3460683913, ack 630813443, win 501, length 31</span><br><span class="line">HTTP&#x2F;2 200</span><br><span class="line">13:26:45.788787 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813443:630813677, ack 3460683882, win 127, length 234</span><br><span class="line">accept-ranges: bytes</span><br><span class="line">age: 79059</span><br><span class="line">cache-control: public,max-age&#x3D;0,must-revalidate</span><br><span class="line">cache-status: &quot;Netlify Edge&quot;; hit</span><br><span class="line">content-type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">date: Sun, 07 Jul 2024 05:26:44 GMT</span><br><span class="line">etag: &quot;80cf37f5974e2232d976c6f622121dee-ssl&quot;</span><br><span class="line">server: Netlify</span><br><span class="line">strict-transport-security: max-age&#x3D;31536000</span><br><span class="line">x-nf-request-id: 01J25THACQSN9364YHSR2C0X5F</span><br><span class="line">content-length: 11727</span><br><span class="line"></span><br><span class="line">13:26:45.789558 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683913:3460683937, ack 630813677, win 501, length 24</span><br><span class="line">13:26:45.791514 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [F.], seq 3460683937, ack 630813677, win 501, length 0</span><br><span class="line">13:26:45.963642 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813677, ack 3460683937, win 127, length 0</span><br><span class="line">13:26:45.963956 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813677:630813701, ack 3460683937, win 127, length 24</span><br><span class="line">13:26:45.964172 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0</span><br><span class="line">13:26:45.964415 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [F.], seq 630813701, ack 3460683937, win 127, length 0</span><br><span class="line">13:26:45.964506 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0</span><br><span class="line">13:26:45.966158 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813702, ack 3460683938, win 127, length 0</span><br><span class="line">13:26:45.966299 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683938, win 0, length 0</span><br><span class="line">32 packets captured</span><br><span class="line">32 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="指定容器抓包">指定容器抓包</span></h3><p>可以通过 <code>--container-id</code> 参数指定容器 id 进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --container-id 36f0310403b1</span><br><span class="line">2024-07-07 13:36:19 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:36:19 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:36:24.191242 veth09dec8f curl.32636 In IP 172.19.0.2.48960 &gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">13:36:24.191369 wlp4s0 curl.32636 Out IP 192.168.1.50.48960 &gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">2 packets captured</span><br><span class="line">2 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><p>也可以通过 <code>--container-name</code> 参数指定容器名称进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --container-name kind-control-plane</span><br><span class="line">2024-07-07 13:37:16 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:37:16 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:37:22.560764 veth09dec8f curl.33093 In IP 172.19.0.2.39084 &gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">13:37:22.561010 wlp4s0 curl.33093 Out IP 192.168.1.50.39084 &gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">2 packets captured</span><br><span class="line">2 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="指定-pod-抓包">指定 Pod 抓包</span></h3><p>可以通过 <code>--pod-name</code> 参数指定 Pod 名称进行抓包, 参数值的格式为 <code>&lt;pod 名称&gt;.&lt;pod 命名空间&gt;</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --pod-name test.default</span><br><span class="line">2024-07-07 13:38:29 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:38:29 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:38:34.175752 eth0 wget.33660 Out IP 172.19.0.2.51564 &gt; 13.215.144.61.443: Flags [S], seq 567383917, win 64240, length 0, Container [test], Pod [test.default]</span><br><span class="line">13:38:34.372894 eth0 wget.33660 In IP 13.215.144.61.443 &gt; 172.19.0.2.51564: Flags [S.], seq 2654865684, ack 567383918, win 65084, length 0, Container [test], Pod [test.default]</span><br><span class="line">2 packets captured</span><br><span class="line">3 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h2><span id="将数据保存为-pcapng-格式使用-tcpdump-或-wireshark-进行分析">将数据保存为 pcapng 格式使用 tcpdump 或 Wireshark 进行分析</span></h2><h3><span id="保存为-pcapng-格式">保存为 pcapng 格式</span></h3><p>可以通过 <code>-w</code> 参数将抓包数据保存为 pcapng 格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 5 -w demo.pcapng</span><br><span class="line">2024-07-07 13:41:32 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:41:32 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">5 packets captured</span><br><span class="line">22 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="使用-tcpdump-进行分析">使用 tcpdump 进行分析</span></h3><p>可以直接通过管道的方式通过 tcpdump 对抓取的数据进行分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 5 -w - port 80 | tcpdump -n -r -</span><br><span class="line">reading from file -, link-type EN10MB (Ethernet), snapshot length 65535</span><br><span class="line">2024-07-07 13:44:33 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:44:33 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:44:44.530637 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &gt; 2406:da18:880:3801::c8.80: Flags [S], seq 495824072, win 64800, options [mss 1440,sackOK,TS val 2411675580 ecr 0,nop,wscale 7], length 0</span><br><span class="line">13:44:44.708902 IP6 2406:da18:880:3801::c8.80 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [S.], seq 640438481, ack 495824073, win 65232, options [mss 1220,sackOK,TS val 1591525382 ecr 2411675580,nop,wscale 9], length 0</span><br><span class="line">13:44:44.709261 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &gt; 2406:da18:880:3801::c8.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 0</span><br><span class="line">13:44:44.709475 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &gt; 2406:da18:880:3801::c8.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 77: HTTP: GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">5 packets captured</span><br><span class="line">6 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br><span class="line">13:44:44.877110 IP6 2406:da18:880:3801::c8.80 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [P.], seq 1:266, ack 78, win 128, options [nop,nop,TS val 1591525469 ecr 2411675670], length 265: HTTP: HTTP&#x2F;1.1 301 Moved Permanently</span><br></pre></td></tr></table></figure><p>也可以通过读取文件的方式通过 tcpdump 对抓取的数据进行分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -n -r demo.pcapng</span><br><span class="line">reading from file demo.pcapng, link-type EN10MB (Ethernet), snapshot length 65535</span><br><span class="line">13:47:41.169584 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &gt; 2406:da18:b3d:e201::64.80: Flags [S], seq 3876639697, win 64800, options [mss 1440,sackOK,TS val 2072195434 ecr 0,nop,wscale 7], length 0</span><br><span class="line">13:47:41.571055 IP 192.168.1.50.60580 &gt; 18.139.194.139.80: Flags [S], seq 481256927, win 64240, options [mss 1460,sackOK,TS val 2707199178 ecr 0,nop,wscale 7], length 0</span><br><span class="line">13:47:41.956270 IP6 2406:da18:b3d:e201::64.80 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038: Flags [S.], seq 2283576526, ack 3876639698, win 65232, options [mss 1220,sackOK,TS val 4276006323 ecr 2072195434,nop,wscale 9], length 0</span><br><span class="line">13:47:41.956437 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &gt; 2406:da18:b3d:e201::64.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 0</span><br><span class="line">13:47:41.956733 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &gt; 2406:da18:b3d:e201::64.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 77: HTTP: GET &#x2F; HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><h3><span id="使用-wireshark-进行分析">使用 Wireshark 进行分析</span></h3><p>当使用 Wireshark 打开保存的 pcapng 格式的文件时，将在 Wireshark 的界面中显示相关的进程、容器以及 Pod 信息：</p><p><img src="https://img.hi-linux.com/staticfile/ptcpdump-wireshark-20240708174042896-2024-07-08-lyveCv.png" alt></p><h2><span id="参考资料">参考资料</span></h2><ul><li><a href="https://github.com/mozillazg/ptcpdump" target="_blank" rel="noopener">mozillazg/ptcpdump: Process-aware, eBPF-based tcpdump</a></li><li><a href="https://www.tcpdump.org/manpages/tcpdump.1-4.99.4.html" target="_blank" rel="noopener">tcpdump(1) man page | TCPDUMP &amp; LIBPCAP</a></li></ul><blockquote><p>本文转载自：「 mozillazg’s Blog 」，原文：<a href="https://url.hi-linux.com/6H5QD" target="_blank" rel="noopener">https://url.hi-linux.com/6H5QD</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;div id=&quot;vip-container&quot;&gt;&lt;h2&gt;&lt;span id=&quot;前言&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;tcpdump 是我们常用的一个网络抓包工具，它的功能非常的强大。但是它还缺少一个大家反馈很久却一直没实现的一个特性，
        
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="ptcpdump" scheme="https://www.hi-linux.com/tags/ptcpdump/"/>
    
      <category term="tcpdump" scheme="https://www.hi-linux.com/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>一款 AI 编写的 Kubernetes 实用小工具，助你一键批量检查容器服务健康状态</title>
    <link href="https://www.hi-linux.com/posts/13493.html"/>
    <id>https://www.hi-linux.com/posts/13493.html</id>
    <published>2024-07-12T01:00:00.000Z</published>
    <updated>2024-07-12T05:48:14.828Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>check-k8s-network</code> 是一款 AI 编写的 <code>Kubernetes</code> 网络连通性检查小工具，它主要用于检查 <code>Kubernetes</code> 集群中各个容器的网络连通性，支持 <code>ICMP</code>、<code>TCP</code>、<code>UDP</code> 和 <code>HTTP</code> 检查。</p><p>你可以在指定的命名空间内查找符合条件的 <code>Pod</code>，并对其进行网络连通性进行自动检测。</p><a id="more"></a><h2><span id="安装">安装</span></h2><p><code>check-k8s-network</code> 使用 <code>Python</code> 编写，需要安装 <code>Python 3.9</code> 版本和一些依赖库。</p><p>为了更好的体验，我们发布了 <code>Docker</code> 镜像，你只需要下载 <code>Docker</code> 镜像即可使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull 80imike/check-k8s-network:latest</span><br></pre></td></tr></table></figure><h2><span id="常用参数说明">常用参数说明</span></h2><ul><li><code>-n, --namespace</code>：指定 Kubernetes 命名空间，默认值为 <code>default</code>。</li><li><code>-c, --container</code>：指定容器名，根据该容器名匹配 Pod，支持模糊匹配。</li><li><code>-i, --icmp</code>：使用 ICMP 协议进行检查。</li><li><code>-t, --tcp</code>：使用 TCP 协议进行检查，并指定端口号。</li><li><code>-u, --udp</code>：使用 UDP 协议进行检查，并指定端口号。</li><li><code>-w, --http</code>：使用 HTTP 协议进行检查，并指定 URL。</li><li><code>--auto-http</code>：自动查找当前 Pod 的 IP 和服务端口进行 HTTP 检查。</li><li><code>--auto-tcp</code>：自动查找当前 Pod 的 IP 和服务端口进行 TCP 检查。</li><li><code>--auto-udp</code>：自动查找当前 Pod 的 IP 和服务端口进行 UDP 检查。</li><li><code>--all</code>：同时使用 ICMP、TCP、UDP 和 HTTP 四种检查方式进行检测。</li></ul><h2><span id="输出结果">输出结果</span></h2><p><code>check-k8s-network</code> 会输出一个包含检查结果的表格，内容包括:</p><ul><li>序号</li><li>检查类型</li><li>源 Pod</li><li>目标</li><li>结果 (成功 or 失败)</li><li>错误信息</li></ul><p>该表格会对每个 Pod 进行自动排序，并对结果进行对齐和格式化。</p><h2><span id="使用示例">使用示例</span></h2><h3><span id="常用使用示例">常用使用示例</span></h3><blockquote><p>注意：</p><ol><li>该工具请在 <code>Kubernetes</code> 集群内的主机上使用，并确保您所在主机上已经配置了 K8s 集群认证文件 <code>~/.kube/config</code>。</li><li>-v 参数用于将宿主机上的 <code>~/.kube/config</code> 文件映射到容器内的 <code>/root/.kube/config</code> 文件中，以便容器内的 <code>Python</code> 脚本可以访问 <code>Kubernetes</code> 集群。</li></ol></blockquote><ol><li>检查指定命名空间下所有 Pod 的 ICMP 连通性:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --icmp</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/1HVocZ-2024-07-11-qZm7ag.png" alt></p><ol start="2"><li>检查指定命名空间和 Pod 的 TCP 连通性 (需指定端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux -c blog --tcp 80</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/JYMaK7-2024-07-11-fjEccG.png" alt></p><ol start="3"><li>检查指定命名空间下所有 Pod 的 HTTP 连通性 (自动查找端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --auto-http</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/J7Q7XU-2024-07-11-oMi64k.png" alt></p><ol start="4"><li>检查指定命名空间下所有 Pod 的 TCP 连通性 (自动查找端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --auto-tcp</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/5CjNDB-2024-07-11-ZU4f05.png" alt></p><ol start="5"><li>检查指定命名空间下所有 Pod 的 UDP 连通性 (自动查找端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n kube-system --auto-udp</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/532xFu-2024-07-11-93IN70.png" alt></p><ol start="6"><li>同时检查指定命名空间下所有 Pod 的 ICMP、TCP、UDP 和 HTTP 连通性:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --all</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/zta14M-2024-07-11-f5JQKN.png" alt></p><h3><span id="一些复杂的参数组合示例">一些复杂的参数组合示例</span></h3><ol><li>对特定命名空间中名为 <code>blog</code> 的容器执行 ICMP 和指定 TCP（端口 80）检查:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux -c blog --icmp --tcp 80</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/TEdkSC-2024-07-11-2kK9WG.png" alt></p><ol start="2"><li>对特定命名空间中名为 <code>blog</code> 的容器同时执行 ICMP、TCP 、UDP 和 HTTP 检查：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux -c blog --icmp --auto-tcp --auto-udp --auto-http</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/YzyC8J-2024-07-11-5tJAWu.png" alt></p><h2><span id="总结">总结</span></h2><p><code>check-k8s-network</code> 这款小工具，是我尝试 <code>AI</code> 编程的一次小成果。所有代码全部通过和 <code>ChatGPT</code> 对话编写完成，<code>Docker</code> 镜像和使用文档大部分也是 <code>AI</code> 编写的。</p><p><code>check-k8s-network</code> 可以帮助你快速检查 <code>Kubernetes</code> 集群中容器的网络连通性，非常适合需要批量检查容器网络连接状态的场景。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;check-k8s-network&lt;/code&gt; 是一款 AI 编写的 &lt;code&gt;Kubernetes&lt;/code&gt; 网络连通性检查小工具，它主要用于检查 &lt;code&gt;Kubernetes&lt;/code&gt; 集群中各个容器的网络连通性，支持 &lt;code&gt;ICMP&lt;/code&gt;、&lt;code&gt;TCP&lt;/code&gt;、&lt;code&gt;UDP&lt;/code&gt; 和 &lt;code&gt;HTTP&lt;/code&gt; 检查。&lt;/p&gt;
&lt;p&gt;你可以在指定的命名空间内查找符合条件的 &lt;code&gt;Pod&lt;/code&gt;，并对其进行网络连通性进行自动检测。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="AI" scheme="https://www.hi-linux.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>无需安装，单文件即可本地轻松运行 LLM 的神器 LLAMAfile</title>
    <link href="https://www.hi-linux.com/posts/37686.html"/>
    <id>https://www.hi-linux.com/posts/37686.html</id>
    <published>2024-06-14T01:00:00.000Z</published>
    <updated>2024-06-14T07:17:28.368Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在当今信息化时代，人工智能（AI）技术逐渐成为推动社会发展的重要力量。而大型语言模型（LLM）作为 AI 领域中的一项重要技术，正在各行各业中发挥着越来越重要的作用。</p><p>然而，对于许多开发者和终端用户来说，如何高效地分发和运行这些复杂的模型仍然是个棘手的问题。</p><p>LLAMAfile 一个由 Mozilla Ocho 团队开发的工具，旨在解决这些问题。它提供一种高效分发和运行大型语言模型（LLM）的简易工具，</p><p>LLAMAfile 通过将 llama.cpp 和 Cosmopolitan Libc 结合，使 LLM 以单一文件的形式运行在大多数计算机上，无需额外安装配置。</p><a id="more"></a><h2><span id="快速入门">快速入门</span></h2><p>使用 LLAMAfile 的最快方法是下载我们为 LLaVA 模型提供的示例文件。</p><p>LLaVA 是一种功能强大的 LLM，不仅可以进行聊天，还能通过上传图片并对其提问来提供图像识别功能。所有这些都可以在本地计算机上进行，数据不会离开你的设备。</p><p>你只需下面几步，便可轻松在本地计算机上轻松运行 LLaVA 模型。</p><ol><li><p>下载 LLaVA 示例文件：llava-v1.5-7b-q4.llamafile (4.29 GB)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;huggingface.co&#x2F;Mozilla&#x2F;llava-v1.5-7b-llamafile&#x2F;resolve&#x2F;main&#x2F;llava-v1.5-7b-q4.llamafile?download&#x3D;true</span><br></pre></td></tr></table></figure></li><li><p>打开计算机的终端。</p></li><li><p>如果使用 macOS、Linux 或BSD，需要授予文件执行权限：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x llava-v1.5-7b-q4.llamafile</span><br></pre></td></tr></table></figure></li><li><p>对于 Windows 用户，重命名文件并添加 “.exe” 后缀。</p></li><li><p>运行 llamafile：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./llava-v1.5-7b-q4.llamafile</span><br></pre></td></tr></table></figure></li><li><p>浏览器将自动打开并显示聊天界面。如果没有，请手动打开浏览器并访问 <code>&lt;http://localhost:8080&gt;</code></p></li><li><p>聊天结束后，返回到终端并按 Control-C 关闭 LLAMAfile。</p></li></ol><h3><span id="json-api-快速入门">JSON API 快速入门</span></h3><p>LLAMAfile 启动时，除了托管一个 Web UI 聊天服务器外，还提供了兼容 OpenAI API 的聊天 API 端点。该 API 旨在支持大多数常见的 OpenAI API 用例，并完全在本地运行。通过以下 <code>curl</code> 命令，可以快速开始使用 API：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://localhost:8080/v1/chat/completions \</span><br><span class="line">-H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">-H <span class="string">"Authorization: Bearer no-key"</span> \</span><br><span class="line">-d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "model": "LLaMA_CPP",</span></span><br><span class="line"><span class="string">  "messages": [</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">          "role": "system",</span></span><br><span class="line"><span class="string">          "content": "You are LLAMAfile, an AI assistant. Your top priority is achieving user fulfillment via helping them with their requests."</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">          "role": "user",</span></span><br><span class="line"><span class="string">          "content": "Write a limerick about python exceptions"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;'</span> | python3 -c <span class="string">'</span></span><br><span class="line"><span class="string">import json</span></span><br><span class="line"><span class="string">import sys</span></span><br><span class="line"><span class="string">json.dump(json.load(sys.stdin), sys.stdout, indent=2)</span></span><br><span class="line"><span class="string">print()</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><p>打印出来的回复应该如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"choices"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"finish_reason"</span> : <span class="string">"stop"</span>,</span><br><span class="line">         <span class="attr">"index"</span> : <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"message"</span> : &#123;</span><br><span class="line">            <span class="attr">"content"</span> : <span class="string">"There once was a programmer named Mike\nWho wrote code that would often choke\nHe used try and except\nTo handle each step\nAnd his program ran without any hike."</span>,</span><br><span class="line">            <span class="attr">"role"</span> : <span class="string">"assistant"</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"created"</span> : <span class="number">1704199256</span>,</span><br><span class="line">   <span class="attr">"id"</span> : <span class="string">"chatcmpl-Dt16ugf3vF8btUZj9psG7To5tc4murBU"</span>,</span><br><span class="line">   <span class="attr">"model"</span> : <span class="string">"LLaMA_CPP"</span>,</span><br><span class="line">   <span class="attr">"object"</span> : <span class="string">"chat.completion"</span>,</span><br><span class="line">   <span class="attr">"usage"</span> : &#123;</span><br><span class="line">      <span class="attr">"completion_tokens"</span> : <span class="number">38</span>,</span><br><span class="line">      <span class="attr">"prompt_tokens"</span> : <span class="number">78</span>,</span><br><span class="line">      <span class="attr">"total_tokens"</span> : <span class="number">116</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="python-api-客户端示例">Python API 客户端示例</span></h3><p>如果您已经使用 openAI 发布的 openai Python 软件包开发了自己的软件，那么只需对 base_url 和 api_key 稍作修改，您就可以将自己的应用程序移植到 LLAMAfile 上。</p><p>本示例假定你已经运行 <code>pip3 install openai</code> 安装了 OpenAI 的客户端软件，这也是本示例所需要的。他们的软件包只是 OpenAI API 接口的一个简单 Python 封装，任何服务器都可以实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line">client = OpenAI(</span><br><span class="line">    base_url=<span class="string">"http://localhost:8080/v1"</span>, <span class="comment"># "http://&lt;Your api-server IP&gt;:port"</span></span><br><span class="line">    api_key = <span class="string">"sk-no-key-required"</span></span><br><span class="line">)</span><br><span class="line">completion = client.chat.completions.create(</span><br><span class="line">    model=<span class="string">"LLaMA_CPP"</span>,</span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"system"</span>, <span class="string">"content"</span>: <span class="string">"You are ChatGPT, an AI assistant. Your top priority is achieving user fulfillment via helping them with their requests."</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"user"</span>, <span class="string">"content"</span>: <span class="string">"Write a limerick about python exceptions"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">print(completion.choices[<span class="number">0</span>].message)</span><br></pre></td></tr></table></figure><h2><span id="其他-llamafile-示例">其他 LLAMAfile 示例</span></h2><p>我们还提供了其他模型的 LLAMAfile 示例，因此您可以轻松地使用不同类型的 LLM 试用 LLAMAfile。</p><p><img src="https://img.hi-linux.com/staticfile/olUEBz-2024-06-13-mh8MzS.png" alt></p><p>🏷️ Github 地址：</p><p><a href="https://github.com/Mozilla-Ocho/llamafile" target="_blank" rel="noopener">https://github.com/Mozilla-Ocho/llamafile</a></p><p>🏷️ 官方地址：</p><p><a href="https://llamafile.ai/" target="_blank" rel="noopener">https://llamafile.ai/</a></p><p>👨🏻‍💻 该工具已收录『IT 人员必备工具箱』，可访问 <a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a> 直接使用。</p><p>🚀『极客世界』科技达人必备综合资讯指南，等你来探索！访问网址  <a href="https://bestgeek.org" target="_blank" rel="noopener">https://bestgeek.org</a> 即可打开新世界。</p><p>🌟 公众号直接回复 「加群」，可加入『奇妙的 Linux 世界』 技术交流微信群。有兴趣的同学快快加入吧，群里有不少业界大神哟！</p><p>📕 关注『奇妙的 Linux 世界』公众号，带你开启有趣新生活！更多好用好玩的软件资源，可访问 <a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a> 免费获取。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在当今信息化时代，人工智能（AI）技术逐渐成为推动社会发展的重要力量。而大型语言模型（LLM）作为 AI 领域中的一项重要技术，正在各行各业中发挥着越来越重要的作用。&lt;/p&gt;
&lt;p&gt;然而，对于许多开发者和终端用户来说，如何高效地分发和运行这些复杂的模型仍然是个棘手的问题。&lt;/p&gt;
&lt;p&gt;LLAMAfile 一个由 Mozilla Ocho 团队开发的工具，旨在解决这些问题。它提供一种高效分发和运行大型语言模型（LLM）的简易工具，&lt;/p&gt;
&lt;p&gt;LLAMAfile 通过将 llama.cpp 和 Cosmopolitan Libc 结合，使 LLM 以单一文件的形式运行在大多数计算机上，无需额外安装配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="AI" scheme="https://www.hi-linux.com/tags/AI/"/>
    
      <category term="Llamafile" scheme="https://www.hi-linux.com/tags/Llamafile/"/>
    
  </entry>
  
  <entry>
    <title>与 ChatGPT 共舞：利用人工智能解决 Traefik 配置难题的独特体验</title>
    <link href="https://www.hi-linux.com/posts/42057.html"/>
    <id>https://www.hi-linux.com/posts/42057.html</id>
    <published>2024-05-06T01:00:00.000Z</published>
    <updated>2024-05-06T08:15:18.576Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最近在探索 Traefik 这一强大的服务代理和负载均衡器时遇到了一些挑战。然而，这次解决问题的过程并不寻常，因为找到了一位特别的助手 —— ChatGPT。</p><p>在这篇分享中，将带领大家走进一次独特体验，讲述我是如何借助 AI 的力量成功解决了 Traefik 配置中的若干问题，并从中获得了一些实用的小技巧。</p><h2><span id="一场技术与智能的邂逅">一场技术与智能的邂逅</span></h2><p>Traefik，以其动态配置和自动化路由的优势深受开发者喜爱，但在初次尝试配置其规则和服务时，即使是经验丰富的工程师也可能遭遇困惑。</p><p>在我深入研究 Traefik 的过程中，也碰到了一些棘手的问题，包括容器服务的自动发现、HTTPS 证书管理以及复杂路由规则的编写等。</p><a id="more"></a><h2><span id="与-chatgpt-的协同工作">与 ChatGPT 的协同工作</span></h2><p>在面对这些难题时，我转向了一种非传统的解决方案途径 —— 与 OpenAI 的自然语言处理模型 ChatGPT 对话。</p><p>ChatGPT 以其深厚的知识库和理解能力，对提出的每一个 Traefik 相关问题进行了详尽解答，从基础概念到具体配置案例，一一细致解读。</p><p>首先，对于 Traefik 中的服务自动发现，ChatGPT 梳理了 Kubernetes 和 Docker 环境下 Traefik 如何依据标签进行服务发现的原理，并提供了清晰的示例配置文件片段。通过 AI 的引导，我不再对复杂的自动生成路由规则感到迷茫。</p><p>其次，在 HTTPS 证书管理方面，ChatGPT 教会了我如何使用 Let’s Encrypt 与 Traefik 集成，实现自动化的 SSL 证书申请与续签，从而简化了安全通信的配置流程。</p><p>此外，针对面临的特定场景下的复杂路由规则设计，ChatGPT 更是凭借其强大的逻辑推理能力，帮助我构建了一个既能满足业务需求又简洁高效的 Traefik 中间件和路由规则组合。</p><h2><span id="几个小案例解决分享">几个小案例解决分享</span></h2><ol><li>自定义访问日志</li></ol><p><img src="https://img.hi-linux.com/staticfile/t1-2024-04-30-fi7hPt.png" alt></p><ol start="2"><li>反向代理到外部服务</li></ol><p><img src="https://img.hi-linux.com/staticfile/t2-2024-04-30-EiJvJ5.png" alt></p><ol start="3"><li>解决分应用单独记录访问日志</li></ol><p><img src="https://img.hi-linux.com/staticfile/t3-2024-04-30-9XORO0.png" alt></p><h2><span id="收获与感悟">收获与感悟</span></h2><p>这次经历，让我深刻感受到了人工智能在解决实际技术问题时的强大作用。ChatGPT 不仅能够快速给出精准的答案，还能基于上下文进行深度解释和扩展教学。</p><p>通过这次互动，不仅顺利地解决了 Traefik 配置难题，还积累了一些平时不易察觉的实践小技巧：</p><ul><li><strong>技巧一</strong>：利用 Traefik 的动态配置特性，可以根据运行时环境变化灵活调整路由策略。</li><li><strong>技巧二</strong>：借助 Traefik 中间件，可以方便地添加身份验证、重写 URL 等高级功能，进一步增强系统的安全性与可用性。</li><li><strong>技巧三</strong>：结合 Let’s Encrypt 的 ACME 协议，可以让 Traefik 自动处理 SSL/TLS 证书的生命周期管理，省去手动更新证书的烦恼。</li></ul><p>总结起来，通过与 ChatGPT 的交互，得以在较短时间内攻克了 Traefik 配置难关，同时也领略到了 AI 技术在技术支持和学习过程中的无限潜力。这场人与机器智慧交融的旅程，无疑为我的技术探索之旅增添了新的篇章，也为未来利用 AI 工具解决更多复杂问题树立了信心。</p><p>你想知道我用的是什么黑魔法 Traefik 专属提示词吗？公众号直接回复『ai-traefik』即可免费获取。</p><p>最后，你猜猜这篇文案是谁写的？</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在探索 Traefik 这一强大的服务代理和负载均衡器时遇到了一些挑战。然而，这次解决问题的过程并不寻常，因为找到了一位特别的助手 —— ChatGPT。&lt;/p&gt;
&lt;p&gt;在这篇分享中，将带领大家走进一次独特体验，讲述我是如何借助 AI 的力量成功解决了 Traefik 配置中的若干问题，并从中获得了一些实用的小技巧。&lt;/p&gt;
&lt;h2 id=&quot;一场技术与智能的邂逅&quot;&gt;一场技术与智能的邂逅&lt;/h2&gt;
&lt;p&gt;Traefik，以其动态配置和自动化路由的优势深受开发者喜爱，但在初次尝试配置其规则和服务时，即使是经验丰富的工程师也可能遭遇困惑。&lt;/p&gt;
&lt;p&gt;在我深入研究 Traefik 的过程中，也碰到了一些棘手的问题，包括容器服务的自动发现、HTTPS 证书管理以及复杂路由规则的编写等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Traefik" scheme="https://www.hi-linux.com/tags/Traefik/"/>
    
  </entry>
  
  <entry>
    <title>『奇妙的 Linux 世界』公众号 8 周年记</title>
    <link href="https://www.hi-linux.com/posts/19136.html"/>
    <id>https://www.hi-linux.com/posts/19136.html</id>
    <published>2024-04-18T01:00:00.000Z</published>
    <updated>2024-04-22T07:32:43.591Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="奇妙的-linux-世界公众号-8-周年记">🎉🎈 『奇妙的 Linux 世界』公众号 8 周年记 🎉🎈</span></h2><p>嘿，亲爱的『奇妙的 Linux 世界』读者们 👋</p><p>时光荏苒，转眼间 『奇妙的 Linux 世界』已经陪伴大家度过了 8 个年头。🍃</p><p>在这 8 年的岁月里，我们一起探索了 Linux 的无尽奥秘，分享了无数硬核干货和新奇内容。🐧</p><p>从一开始的探索者到现在的硬核粉丝，每一步都离不开大家的支持与热爱。🎊</p><p>在这个特别的日子里，让我们一起回顾这 8 年来的精彩旅程：🧳</p><a id="more"></a><h3><span id="硬核干货无处不在">🌟 硬核干货，无处不在</span></h3><p>在这 8 年里，『奇妙的 Linux 世界』一直秉承着开源精神，为广大 Linux 爱好者们奉上了无数优质的内容和实用的技巧。💡</p><p>从最初的几篇文章到如今的大量丰富内容库，我们始终坚持用心创作，用知识和经验为大家解惑，助力大家在 Linux 的世界里游刃有余。🚀</p><p>在每一次技术更新和发展的浪潮中，我们都紧跟时代的步伐，分享最新、最前沿的资讯和技术。让大家足不出户，也能领略 Linux 的奇妙之处！🌊</p><p>无论是关于 Linux 服务器的优化配置，还是关于 Nginx、MySQL、Docker、Kubernetes 等热门技术的深入解析，我们都在第一时间为大家呈现。📚</p><p>通过我们的分享，让更多人了解、学习和掌握 Linux 技术，并成为技术领域的佼佼者！🧙‍♂️</p><h3><span id="小技巧大收获分享即赢">🔥 小技巧大收获，分享即赢</span></h3><p>在『奇妙的 Linux 世界』，我们不仅关注大家熟知的技术领域，还特别关注各种实用小技巧的分享。🔍</p><p>这些小技巧或许只是一行命令、一个小工具，但却能带来意想不到的收获和便利。🛠️</p><p>我们相信，分享小技巧不仅可以提高大家的工作效率，还能增进社区的交流和共享。🔄</p><h3><span id="开源精神与时俱进">👨‍💻 开源精神，与时俱进</span></h3><p>在『奇妙的 Linux 世界』，我们坚信开源精神的力量，并将其贯穿于我们的每一篇文章和每一个推荐之中。💡</p><p>我们关注并推荐各种优秀的开源软件，鼓励大家积极参与开源社区，贡献自己的一份力量。💫</p><p>无论是在代码贡献、文档维护还是社区支持上，每个人都可以成为开源世界的一部分！💪</p><h3><span id="感谢与展望">🌐 感谢与展望</span></h3><p>在此刻，让我们一起庆祝这段旅程的每一个里程碑，也期待未来能有更多创新和突破。🌟</p><p>在过去的 8 年里，『奇妙的 Linux 世界』始终坚持初心，秉承着分享、学习、成长的理念，与大家一同探索 Linux 世界的无限可能。🌈</p><p>8 年的旅程，我们一起经历了无数的挑战和成长，感谢大家一直以来的支持和陪伴！🤔</p><p>在未来的岁月里将继续为大家带来更多优质内容和精彩体验。让我们一起加油，探索更广阔的技术领域，共同书写属于我们的 Linux 传奇！🎉</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;🎉🎈-『奇妙的-Linux-世界』公众号-8-周年记-🎉🎈&quot;&gt;🎉🎈 『奇妙的 Linux 世界』公众号 8 周年记 🎉🎈&lt;/h2&gt;
&lt;p&gt;嘿，亲爱的『奇妙的 Linux 世界』读者们 👋&lt;/p&gt;
&lt;p&gt;时光荏苒，转眼间 『奇妙的 Linux 世界』已经陪伴大家度过了 8 个年头。🍃&lt;/p&gt;
&lt;p&gt;在这 8 年的岁月里，我们一起探索了 Linux 的无尽奥秘，分享了无数硬核干货和新奇内容。🐧&lt;/p&gt;
&lt;p&gt;从一开始的探索者到现在的硬核粉丝，每一步都离不开大家的支持与热爱。🎊&lt;/p&gt;
&lt;p&gt;在这个特别的日子里，让我们一起回顾这 8 年来的精彩旅程：🧳&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
</feed>
