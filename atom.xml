<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>运维之美</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2020-05-16T04:33:24.280Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 1 期 )</title>
    <link href="https://www.hi-linux.com/posts/43626.html"/>
    <id>https://www.hi-linux.com/posts/43626.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T04:33:24.280Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h3 id="业界资讯">业界资讯</h3><p>1、<a href="https://www.williamlong.info/archives/5747.html" target="_blank" rel="noopener">中国设立互联网根服务器</a></p><p>近日，中国工信部官网一篇题为 “工业和信息化部关于同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及域名根服务器运行机构的批复” 的文章引起外界广泛关注。工信部当天的消息称，同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及成为域名根服务器运行机构，负责运行、维护和管理相关域名根服务器。</p><p>链接：<a href="https://www.williamlong.info/archives/5747.html" target="_blank" rel="noopener">https://www.williamlong.info/archives/5747.html</a></p><p>2、<a href="https://www.solidot.org/story?sid=61096" target="_blank" rel="noopener">微软正式发布 Windows Terminal 预览版</a></p><p>微软在 Microsoft Store 发布了 Windows Terminal 的预览版。</p><p>Windows Terminal 是微软上个月在开发者大会上宣布的新命令行终端，源代码发布在 GitHub 上。Windows Terminal 支持多标签、Unicode 和 UTF-8 字符、GPU 加速 DirectWrite/DirectX 文本渲染引擎，定制主题、样式和配置。更多特性详细介绍可参考<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487033&amp;idx=1&amp;sn=2cc918c4a2f9ddf7da341e7996183872&amp;chksm=eac52f10ddb2a606ee40e98646dc8eb8b4409ef88169c6172f5b42ead00c866c4693d7a3387f&amp;token=1817029934&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a> 。</p><p>下载安装 Windows Terminal  需要 Windows 10 version 18362.0 及更新版本。</p><p>链接：<a href="https://www.solidot.org/story?sid=61096" target="_blank" rel="noopener">https://www.solidot.org/story?sid=61096</a></p><p><img src="https://i.loli.net/2019/07/29/5d3ebfc2aaafd80489.jpg" alt=""></p><p>3、<a href="https://www.oschina.net/news/107833/dns-over-https-ga" target="_blank" rel="noopener">谷歌宣布 DNS Over HTTPS 服务普遍可用</a></p><p>谷歌于 2009 年推出 Google Public DNS，并于 2016 年在此基础上推出 DNS Over HTTPS，这是一项实验性服务，旨在加强 DNS 的安全性，此前的服务入口是 <a href="http://dns.google.com/experimental%E3%80%82" target="_blank" rel="noopener">dns.google.com/experimental。</a></p><p>现在谷歌宣布 DoH 已经正式普遍可用，并且完全支持 RFC 8484 文档，同时继续提供对 2016 年推出的 JSON API 的支持。用户可以使用 dns.google 域中的 DoH 解析 DNS，其中包含与常规 DNS 服务相同的任播地址，如 8.8.8.8。新的访问入口是：<a href="https://dns.google/dns-query" target="_blank" rel="noopener">https://dns.google/dns-query</a> ((RFC 8484) 和 <a href="https://dns.google/resolve" target="_blank" rel="noopener">https://dns.google/resolve</a> (JSON API)。</p><p>链接：<a href="https://www.oschina.net/news/107833/dns-over-https-ga" target="_blank" rel="noopener">https://www.oschina.net/news/107833/dns-over-https-ga</a></p><p><img src="https://oscimg.oschina.net/oscnet/fe994bc0e5e401523320b7953a92696045f.jpg" alt=""></p><p>4、<a href="http://news.51cto.com/art/201906/598801.htm" target="_blank" rel="noopener">Mozilla 发布下一代移动浏览器 Firefox Preview</a></p><p>Mozilla 已于近日在 Google Play 正式上架面向 Android 的全新移动浏览器 Firefox Preview。</p><p>与现已推出与大多数浏览器所采用的 Bink 渲染引擎不同，Firefox Preview 的渲染引擎 GeckoView 由 Mozilla 自己开发，这种独立性一定程度上避免了互联网被单一的科技巨头控制。</p><p>虽然已经公开发布，不过 Mozilla 表示 Firefox Preview 仍处于测试阶段，真正的大招会憋到今年秋季再放，届时将提供更丰富的功能和更精美的界面。</p><p>链接：<a href="http://news.51cto.com/art/201906/598801.htm" target="_blank" rel="noopener">http://news.51cto.com/art/201906/598801.htm</a></p><p><img src="https://s4.51cto.com/oss/201907/01/da021001f2e94c283777ac8f67a880b8.jpg-wh_651x-s_2719880675.jpg" alt=""></p><p>5、<a href="https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop" target="_blank" rel="noopener">OpenJDK Docker 镜像存在错误版本漏洞</a></p><p>OpenJDK 邮件列表确认，OpenJDK 的官方 Docker 镜像中包含错误标记版本号，这表明部分 JRE 应包含的安全补丁实际上并不存在。</p><p>该问题已经通过 OpenJDK 和 Debian 间的跨社区协作得以解决。该 “官方” 版本是由 Docker 和其他方制作的，因为 OpenJDK 社区没有创建镜像或生成构建。该 Docker 镜像已被下载超过一千万次。</p><p>链接：<a href="https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop" target="_blank" rel="noopener">https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop</a></p><p>6、<a href="https://www.oschina.net/news/107663/v-lang-source-code-released" target="_blank" rel="noopener">安全的全新编程语言 V 发布首个可用版本</a></p><p>日前，一种新的静态类型编程语言 V 语言正式开源了，并发布了首个可用版本。</p><p>据了解，V 语言全名叫：Vlang。V 语言是一个结合 Go 语言的简洁以及 Rust 的安全特性的新语言，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。</p><p>链接：<a href="https://www.oschina.net/news/107663/v-lang-source-code-released" target="_blank" rel="noopener">https://www.oschina.net/news/107663/v-lang-source-code-released</a></p><p><img src="https://raw.githubusercontent.com/vlang/v/master/examples/tetris/screenshot.png" alt=""></p><a id="more"></a><h3 id="趣站酷软">趣站酷软</h3><p>1、<a href="https://github.com/Eugeny/terminus" target="_blank" rel="noopener">Terminus</a></p><p>Terminus 是一个高度可配置的终端模拟器，适用于 Windows、macOS 和 Linux。</p><p>项目地址: <a href="https://github.com/Eugeny/terminus" target="_blank" rel="noopener">https://github.com/Eugeny/terminus</a></p><p><img src="https://raw.githubusercontent.com/Eugeny/terminus/master/docs/readme.png" alt=""></p><p>2、<a href="https://github.com/ovity/octotree" target="_blank" rel="noopener">Octotree</a></p><p>一个浏览器插件，可以将 GitHub 的仓库变成文件浏览器，提供便于查看的树状文件结构。</p><p>项目地址: <a href="https://github.com/ovity/octotree" target="_blank" rel="noopener">https://github.com/ovity/octotree</a></p><p><img src="https://raw.githubusercontent.com/ovity/octotree/v3/docs/chrome-github.png" alt=""></p><p>3、<a href="https://github.com/Peltoche/lsd" target="_blank" rel="noopener">LSD</a></p><p>文件列表命令 ls 的替代品。</p><p>项目地址: <a href="https://github.com/Peltoche/lsd" target="_blank" rel="noopener">https://github.com/Peltoche/lsd</a></p><p><img src="https://raw.githubusercontent.com/Peltoche/lsd/assets/screen_lsd.png" alt=""></p><p>4、<a href="https://github.com/marcenacp/kubeasy" target="_blank" rel="noopener">Kubeasy</a></p><p>一个用来管理 Kubernetes 集群的 CLI 工具，提供了沉浸式的命令行界面。</p><p>项目地址: <a href="https://github.com/marcenacp/kubeasy" target="_blank" rel="noopener">https://github.com/marcenacp/kubeasy</a></p><p><img src="https://raw.githubusercontent.com/marcenacp/kubeasy/master/public/kubeasy.gif" alt=""></p><p>5、<a href="https://github.com/wercker/stern" target="_blank" rel="noopener">Stern</a></p><p>Stern 是 Kubernetes 下多容器日志查看工具，如果你有需求一次看多个 Pod 的日志，Stern 这个工具可以将日志从多个 Pod 中拉出来，非常方便实用。</p><p>Stern 支持正则表达式，只需以 Pod 部署名称开头就可以跟踪所有部署 Pod 中的日志，并不需要知道每个 Pod 的确切名称。</p><p>项目地址: <a href="https://github.com/wercker/stern" target="_blank" rel="noopener">https://github.com/wercker/stern</a></p><p><img src="https://static001.infoq.cn/resource/image/b4/8a/b4b4400dc8666b0c4176871d829dcf8a.png" alt=""></p><p>6、<a href="https://github.com/wfxr/tmux-fzf-url" target="_blank" rel="noopener">tmux-fzf-url</a></p><p>tmux-fzf-url 是一个Tmux 插件，可以帮助你解放鼠标，提高工作效率的 CLI 工具。它可以从终端快速打开屏幕中的 URL，当 URL 有多个的时候，还可以通过 FZF 进行交互式地筛选，同时打开所有选中的链接，全程无需使用鼠标。（ 配合浏览器插件 cVim、Surfingkeys 等使用更佳）</p><p>项目地址: <a href="https://github.com/wfxr/tmux-fzf-url" target="_blank" rel="noopener">https://github.com/wfxr/tmux-fzf-url</a></p><p><img src="https://raw.githubusercontent.com/wfxr/i/master/tmux-fzf-url.gif" alt=""></p><p>7、<a href="https://github.com/jiansiting/Decryption-Tools" target="_blank" rel="noopener">Decryption-Tools</a></p><p>一个勒索病毒解密工具的仓库，上面收集了各种勒索病毒解密工具, 希望对大家有用。</p><p>项目地址: <a href="https://github.com/jiansiting/Decryption-Tools" target="_blank" rel="noopener">https://github.com/jiansiting/Decryption-Tools</a></p><h3 id="技术文章">技术文章</h3><p>1、<a href="https://tonybai.com/2019/06/25/using-git-with-svn-repo/" target="_blank" rel="noopener">使用 Git 操作 SVN 仓库</a></p><p>如今，虽然 Git 已经大行其道，但是仍有很多 IT 公司和组织依旧在使用集中式的版本控制系统 Subversion，尤其是一些传统软件公司，他们倾向于集中式的联网开发。</p><p>如果你是一个 Git Fans，并且你要是遇到代码仓库依旧是使用 Subversion 进行版本控制的情况，你又该如何施展呢？</p><p>本文将介绍一种如何优雅的使用 Git 对 Subversion 仓库进行操作的方法。</p><p>链接：<a href="https://tonybai.com/2019/06/25/using-git-with-svn-repo/" target="_blank" rel="noopener">https://tonybai.com/2019/06/25/using-git-with-svn-repo/</a></p><p>2、<a href="http://dockone.io/article/8832" target="_blank" rel="noopener">容器发展简史</a></p><p>在过去四年中（2015-2019），云以及分布式计算成为最受欢迎的技术之一，它们从小众技能逐渐变成更被雇主看重的突出技能。容器化技术是云经济和 IT 生态系统中最新潮的技术之一。这篇文章可能会帮助您理解有关 Docker 和容器的一些令人困惑的概念。我们还将看到容器化生态系统在 2019 年的现状以及演变方向。</p><p>链接：<a href="http://dockone.io/article/8832" target="_blank" rel="noopener">http://dockone.io/article/8832</a></p><p>3、<a href="https://zhuanlan.zhihu.com/p/69554144" target="_blank" rel="noopener">怎样去理解 Linux 用户态和内核态？</a></p><p>在 Linux 技术讨论中经常会用户态和内核态术语脱口而出，可你们想过吗？用户态和内核态代表是什么？本片文章，就来谈一谈这个话题。</p><p>链接：<a href="https://zhuanlan.zhihu.com/p/69554144" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69554144</a></p><p>4、<a href="https://www.sysgeek.cn/configure-dns-over-https-in-firefox/" target="_blank" rel="noopener">如何为 Firefox 浏览器配置 DNS Over HTTPS 支持</a></p><p>DNS 查询在当今互联网上扮演着不可或缺的重要角色，当您在浏览器地址栏中输入域名访问网站时，就是由 DNS 服务进行名称查询并解析为对应服务端的 IP 地址，这些由客户端自动发起的 DNS 查询通常都没有任何形式的加密、防偷窥或防篡改措施。</p><p>DNS over HTTPS 是一项相对较新的安全新功能，它可以提高 DNS 查询的隐私性、安全性和连接可靠性，主要由 Google、Cloudflare 和 Mozilla 等领先技术的科技公司在产品中使用。</p><p>本文将介绍如何在 Firefox 浏览器中启用 DNS Over HTTPS 的方法。</p><p>链接 1：<a href="https://www.sysgeek.cn/configure-dns-over-https-in-firefox/" target="_blank" rel="noopener">https://www.sysgeek.cn/configure-dns-over-https-in-firefox/</a><br>链接 2：<a href="https://zhuanlan.zhihu.com/p/42468805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42468805</a></p><p>5、<a href="https://www.oschina.net/news/107847/geckoview-in-2019" target="_blank" rel="noopener">聊聊 Firefox Preview 背后的渲染引擎 GeckoView</a></p><p>通过将 GeckoView 引擎与 Firefox 应用程序相分离，开发团队创建了一种更新、更快和更容易维护的方式来开发 Android 应用程序。这种方法利用了 Gecko 卓越的性能、隐私和对最新 Web 标准的支持。</p><p>本文将介绍一些关于 GeckoView 的特性和应用案例。</p><p>链接：<a href="https://www.oschina.net/news/107847/geckoview-in-2019" target="_blank" rel="noopener">https://www.oschina.net/news/107847/geckoview-in-2019</a></p><h3 id="每周观点">每周观点</h3><p>1、钓鱼的两个原则：一是在有鱼的地方钓鱼，二是不要忘记第一条原则。投资的道理也是一样的。在一些地方，无论你是多好的渔夫，你也不可能钓到很多鱼。生活是一场持久的比赛，接受生活，竭尽全力地做事。如果你能够活到很大的年纪，你会获得很多机遇，可能总共是两种机遇，但抓住其中一个机遇就好啦。—— 查理∙芒格</p><p>2、向那些狂妄之徒致敬。那些特立独行的，桀骜不驯的，那些惹是生非的，格格不入的。那些喜欢另辟蹊径，绝不墨守成规，从不安于现状的家伙。你可以赞美他们，引述他们，反对他们，质疑他们，颂扬或是诋毁他们，却惟独不能忽视他们，因为他们改变了事物。他们发明，想象，治愈，他们探索，创造，启迪，他们推动人类进步。他们或有不得不疯狂的理由。你能于白纸之上看到美妙的画作么？你能于寂静之中听见动人的乐声么？你能于星空之中想到神奇的太空轮么？我们为这些家伙制造良机。别人看到的或为疯子，我们看到的却是天才。因为，只有那些疯狂到以为自己能够改变世界的人，才能真正地改变世界。——「Think Different，1997 年 Apple 广告」</p><p>3、想换个方式喜欢你了，不追逐、不逢迎、无风雨、无喜悲。——德卡先生的信箱</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h3 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.williamlong.info/archives/5747.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中国设立互联网根服务器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，中国工信部官网一篇题为 “工业和信息化部关于同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及域名根服务器运行机构的批复” 的文章引起外界广泛关注。工信部当天的消息称，同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及成为域名根服务器运行机构，负责运行、维护和管理相关域名根服务器。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.williamlong.info/archives/5747.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.williamlong.info/archives/5747.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.solidot.org/story?sid=61096&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软正式发布 Windows Terminal 预览版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软在 Microsoft Store 发布了 Windows Terminal 的预览版。&lt;/p&gt;
&lt;p&gt;Windows Terminal 是微软上个月在开发者大会上宣布的新命令行终端，源代码发布在 GitHub 上。Windows Terminal 支持多标签、Unicode 和 UTF-8 字符、GPU 加速 DirectWrite/DirectX 文本渲染引擎，定制主题、样式和配置。更多特性详细介绍可参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487033&amp;amp;idx=1&amp;amp;sn=2cc918c4a2f9ddf7da341e7996183872&amp;amp;chksm=eac52f10ddb2a606ee40e98646dc8eb8b4409ef88169c6172f5b42ead00c866c4693d7a3387f&amp;amp;token=1817029934&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;下载安装 Windows Terminal  需要 Windows 10 version 18362.0 及更新版本。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.solidot.org/story?sid=61096&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.solidot.org/story?sid=61096&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/29/5d3ebfc2aaafd80489.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/107833/dns-over-https-ga&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谷歌宣布 DNS Over HTTPS 服务普遍可用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;谷歌于 2009 年推出 Google Public DNS，并于 2016 年在此基础上推出 DNS Over HTTPS，这是一项实验性服务，旨在加强 DNS 的安全性，此前的服务入口是 &lt;a href=&quot;http://dns.google.com/experimental%E3%80%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dns.google.com/experimental。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在谷歌宣布 DoH 已经正式普遍可用，并且完全支持 RFC 8484 文档，同时继续提供对 2016 年推出的 JSON API 的支持。用户可以使用 dns.google 域中的 DoH 解析 DNS，其中包含与常规 DNS 服务相同的任播地址，如 8.8.8.8。新的访问入口是：&lt;a href=&quot;https://dns.google/dns-query&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dns.google/dns-query&lt;/a&gt; ((RFC 8484) 和 &lt;a href=&quot;https://dns.google/resolve&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dns.google/resolve&lt;/a&gt; (JSON API)。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/107833/dns-over-https-ga&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/107833/dns-over-https-ga&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/fe994bc0e5e401523320b7953a92696045f.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;http://news.51cto.com/art/201906/598801.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mozilla 发布下一代移动浏览器 Firefox Preview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mozilla 已于近日在 Google Play 正式上架面向 Android 的全新移动浏览器 Firefox Preview。&lt;/p&gt;
&lt;p&gt;与现已推出与大多数浏览器所采用的 Bink 渲染引擎不同，Firefox Preview 的渲染引擎 GeckoView 由 Mozilla 自己开发，这种独立性一定程度上避免了互联网被单一的科技巨头控制。&lt;/p&gt;
&lt;p&gt;虽然已经公开发布，不过 Mozilla 表示 Firefox Preview 仍处于测试阶段，真正的大招会憋到今年秋季再放，届时将提供更丰富的功能和更精美的界面。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://news.51cto.com/art/201906/598801.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://news.51cto.com/art/201906/598801.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s4.51cto.com/oss/201907/01/da021001f2e94c283777ac8f67a880b8.jpg-wh_651x-s_2719880675.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenJDK Docker 镜像存在错误版本漏洞&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OpenJDK 邮件列表确认，OpenJDK 的官方 Docker 镜像中包含错误标记版本号，这表明部分 JRE 应包含的安全补丁实际上并不存在。&lt;/p&gt;
&lt;p&gt;该问题已经通过 OpenJDK 和 Debian 间的跨社区协作得以解决。该 “官方” 版本是由 Docker 和其他方制作的，因为 OpenJDK 社区没有创建镜像或生成构建。该 Docker 镜像已被下载超过一千万次。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.infoq.cn/article/I_Wfu4eIJY7c52Prqoop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://www.oschina.net/news/107663/v-lang-source-code-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安全的全新编程语言 V 发布首个可用版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;日前，一种新的静态类型编程语言 V 语言正式开源了，并发布了首个可用版本。&lt;/p&gt;
&lt;p&gt;据了解，V 语言全名叫：Vlang。V 语言是一个结合 Go 语言的简洁以及 Rust 的安全特性的新语言，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/107663/v-lang-source-code-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/107663/v-lang-source-code-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/vlang/v/master/examples/tetris/screenshot.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 2 期 )</title>
    <link href="https://www.hi-linux.com/posts/43609.html"/>
    <id>https://www.hi-linux.com/posts/43609.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T04:44:06.740Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你想我们一起交流，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h3 id="业界资讯">业界资讯</h3><p>1、<a href="https://www.cnbeta.com/articles/soft/862853.htm" target="_blank" rel="noopener">GitHub 官方中文文档上线</a></p><p>GitHub 推出官方中文帮助文档，这是继日文版之后第二个非英语语种的帮助文档。GitHub 希望借此能够帮助中文开发者更好的理解 GitHub 操作规范，更加熟悉对 GitHub 的操作。</p><p>链接：<a href="https://www.cnbeta.com/articles/soft/862853.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/soft/862853.htm</a></p><p><img src="https://static.cnbetacdn.com/article/2019/0701/81c468f1fc60c58.jpeg" alt=""></p><p>2、<a href="https://github.com/microsoft/WSL2-Linux-Kernel" target="_blank" rel="noopener">微软正式开源 WSL 2 内核源码</a></p><p>微软在今年 5 月举办的 Build 2019 上宣布了第二代 Windows 的 Linux 子系统 WSL 2。与第一代相比，WSL 2 重新设计了架构，使用真正的 Linux 内核，支持在 Windows 上运行 ELF64 Linux 二进制文件。</p><p>近日，微软正式开源了 WSL 2 的内核源码，并将代码托管在 GitHub 上。</p><p>链接：<a href="https://github.com/microsoft/WSL2-Linux-Kernel" target="_blank" rel="noopener">https://github.com/microsoft/WSL2-Linux-Kernel</a></p><p><img src="https://www.hi-linux.com/img/linux/wsl2.jpeg" alt=""></p><p>3、<a href="https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1" target="_blank" rel="noopener">Gitlab 从 12.1 版本开始将不再支持 MySQL</a></p><p>Gitlab 官方宣布，将从 12.1 版本开始不再支持 MySQL 数据库。</p><p>链接：<a href="https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1" target="_blank" rel="noopener">https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1</a></p><p><img src="https://about.gitlab.com/images/blogimages/gitlab-blog-cover.png" alt=""></p><p>4、<a href="https://www.oschina.net/news/108045/debian-10-released" target="_blank" rel="noopener">Debian 10 Buster 正式发布</a></p><p>经历了 25 个月的开发后，Debian 团队于 2019 年 7 月 6 日正式宣布推出代号为 「Buster」 的 Debian 10 稳定版。</p><p>Debian 10 是一个主要版本，带来了许多更新的组件和许多新功能和改进。此版本将在未来 5 年获得由 Debian 安全团队和 Debian 长期支持团队提供的技术支持。</p><p>链接：<a href="https://www.oschina.net/news/108045/debian-10-released" target="_blank" rel="noopener">https://www.oschina.net/news/108045/debian-10-released</a></p><p><img src="https://static.oschina.net/uploads/space/2019/0707/142126_FSUH_2720166.png" alt=""></p><p>5、<a href="https://www.leikeji.com/article/27315" target="_blank" rel="noopener">Chrome 代码出现广告拦截功能，谷歌或将治理网页广告乱象</a></p><p>几乎每一个网民都逃不开广告的影响，它已经深刻地进入到我们的生活之中。无论是刷新信息流还是访问某个具体的内容，广告都会在那里出现，从不在乎你是否想看到。有一部分广告明显影响到了访问网页时的体验，有的会让内容难以查看，有的则会大幅占用系统资源，甚至让电脑操作变慢。</p><p>作为当前市场占有率最大的浏览器 Chrome 打算为用户分担一部分烦恼。根据 9to5google 的报道，Chrome 浏览器的开源代码中出现了内置广告拦截功能的踪影，这项功能将帮用户屏蔽掉部分广告。</p><p>根据页面相关描述，Chrome 会对广告对系统资源的占用进行分析，然后找出那些使用了太多带宽或者 CPU 能力的广告并屏蔽掉它们。最后用户只会看到广告被屏蔽后 “该广告已经移除” 提示。</p><p>链接：<a href="https://www.leikeji.com/article/27315" target="_blank" rel="noopener">https://www.leikeji.com/article/27315</a></p><p><img src="https://www.hi-linux.com/img/linux/chrome.png" alt=""></p><p>6、<a href="https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat" target="_blank" rel="noopener">IBM 340 亿美元红帽收购案完成：定义混合云的开放未来</a></p><p>7 月 9 日晚，IBM 宣布以 340 亿美元（约合人民币 2340 亿）正式收购红帽。早在去年 10 月 29 日，IBM 和红帽就共同宣布两家公司已达成最终协议。根据协议，IBM 将收购红帽所有已发行的普通股，每股 190 美元，总企业价值约 340 亿美元。现在，这次庞大的收购终于完成。</p><p>IBM 表示，本次收购重新定义了企业级云市场。红帽开放的混合云技术，与 IBM 广泛且深入的创新和行业洞察，以及在超过 175 个国家和地区领先的销售能力相结合，通过提供下一代混合多云平台，将共同加速企业创新。基于 Linux 和 Kubernetes 等开源技术，该平台可以使企业在本地、私有云以及多个公有云平台上安全部署、运行、管理数据及应用。</p><p>链接：<a href="https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat" target="_blank" rel="noopener">https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat</a></p><p><img src="https://oscimg.oschina.net/oscnet/30975bdc2ed93d5937c918fca2f46814f05.jpg" alt=""></p><a id="more"></a><h3 id="趣站酷软">趣站酷软</h3><p>1、<a href="https://github.com/IBM/kui" target="_blank" rel="noopener">Kui</a></p><p>Kui 是一款由 IBM 开源的用来管理 Kubernetes 集群的 CLI 工具，Kui 使用 Electron 提供 GUI 能力。</p><p>Kui 结合了原有 CLI 的强大功能，并提供一种可视化的方式，方便我们对 Kubernetes 中 YAML 或者 JSON 格式数据的处理。</p><p>项目地址: <a href="https://github.com/IBM/kui" target="_blank" rel="noopener">https://github.com/IBM/kui</a></p><p><img src="https://raw.githubusercontent.com/IBM/kui/master/docs/readme/images/kubectl-examples.jpg" alt=""></p><p>2、<a href="https://github.com/sentialx/multrin" target="_blank" rel="noopener">Multrin</a></p><p>Multrin 是一个基于 Electron、React、样式组件与 TypeScript 的应用，它可以将不同应用组织在一个 tab 标签下，大大提高生产力。</p><p>目前支持 Windows 与 macOS，Linux 支持正在开发中。</p><p>项目地址: <a href="https://github.com/sentialx/multrin" target="_blank" rel="noopener">https://github.com/sentialx/multrin</a></p><p><img src="https://github.com/sentialx/multrin/raw/master/screenshots/screen1.gif" alt=""></p><p>3、<a href="https://github.com/huangjianke/Gitter" target="_blank" rel="noopener">Gitter</a></p><p>一个 GitHub 的微信小程序客户端，可能是目前颜值最高的。</p><p>项目地址: <a href="https://github.com/huangjianke/Gitter" target="_blank" rel="noopener">https://github.com/huangjianke/Gitter</a></p><p><img src="https://raw.githubusercontent.com/huangjianke/Gitter/master/images/img00.png" alt=""></p><p>4、<a href="https://github.com/derailed/popeye" target="_blank" rel="noopener">Popeye</a></p><p>Popeye 是一个 Kubernetes 集群资源清理的实用程序，它可以实时扫描 Kubernetes 集群并报告已部署资源和配置的潜在问题。</p><p>Popeye 根据部署的内容而不是磁盘上的内容来清理群集。 通过扫描您的群集，它可以检测到错误配置并确保最佳实践，从而防止潜在问题发生。</p><p>Popeye 是一个只读工具，它不会以任何方式改变你的任何 Kubernetes 资源。</p><p>项目地址: <a href="https://github.com/derailed/popeye" target="_blank" rel="noopener">https://github.com/derailed/popeye</a></p><p><img src="https://github.com/derailed/popeye/raw/master/assets/a_score.png" alt=""></p><p>5、<a href="https://github.com/hiroppy/fusuma" target="_blank" rel="noopener">Fusuma</a></p><p>Fusuma 是一个简单方便的使用 Markdown 创建幻灯片的工具。</p><p>你只需要写好想要作为幻灯片展示的 Markdown，并按照顺序整理好目录结构，再写好需要的 CSS 文件之后，这个项目就能够让你简单的使用浏览器展示它们，或者是把它整体导出为一个 PDF 文件。</p><p>项目地址: <a href="https://github.com/hiroppy/fusuma" target="_blank" rel="noopener">https://github.com/hiroppy/fusuma</a></p><p><img src="https://raw.githubusercontent.com/hiroppy/fusuma/master/site/docs/assets/live-mode-comments.png" alt=""></p><p>6、<a href="https://github.com/jesseduffield/lazydocker" target="_blank" rel="noopener">LazyDocker</a></p><p>这是一个为了能在终端中更方便管理 Docker 和 Docker-Compose 的简单终端 UI 工具。</p><p>作者表示记住 Docker 命令很难，并且在多个终端窗口中跟踪容器几乎是不可能的。LazyDocker 正是为了解决这种问题而产生的，它可以在一个终端窗口中拥有所需的所有信息，并且每个 Docker 常用命令都可以绑定快捷键，同时可以添加自定义命令。</p><p>项目地址: <a href="https://github.com/jesseduffield/lazydocker" target="_blank" rel="noopener">https://github.com/jesseduffield/lazydocker</a></p><p><img src="https://oscimg.oschina.net/oscnet/4ad1a013236976fa04761509d03d4fbeecf.jpg" alt=""></p><h3 id="技术文章">技术文章</h3><p>1、<a href="https://www.cnblogs.com/xuxinkun/p/11025020.html" target="_blank" rel="noopener">Docker/Kubernetes 国内镜像源解决方式</a></p><p>本文整理了国内的一些 Docker/Kubernetes 可用的镜像源，非常实用。</p><p>链接：<a href="https://www.cnblogs.com/xuxinkun/p/11025020.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuxinkun/p/11025020.html</a></p><p>2、<a href="https://free.com.tw/mojave-dark-menu-bar-dock/" target="_blank" rel="noopener">如何让 macOS Mojave 只有菜单列和 Dock 使用深色模式？</a></p><p>你可能觉得 macOS 浅色介面有点刺眼，但 Mojave 深色模式又太过深邃？</p><p>至少我使用起来并不是那么愉快，反而花更多时间在辨识不太清楚的文字或图标，甚至有点怀念更早之前的暗色选单（Mojave 以后已经没有这个选项），如果你跟我一样，或许可以考虑透过一个小设定来为现在的 macOS Mojave 开启深色菜单和 Dock 功能。</p><p>链接：<a href="https://free.com.tw/mojave-dark-menu-bar-dock/" target="_blank" rel="noopener">https://free.com.tw/mojave-dark-menu-bar-dock/</a></p><p>3、<a href="https://www.jianshu.com/p/68384978c0a3" target="_blank" rel="noopener">对运维开发工作的一些思考</a></p><p>运维开发这个岗位与普通的业务开发不同，与日常的运维工作也不同，要求兼顾开发与运维两种能力。既要掌握不弱于业务开发的开发技术，又要负责 SRE 同学日常的运维能力。上线之前，还要像 QA 同学一样，对自己的服务进行测试和分级变更。本文将针对运维领域「自动化平台开发」的工作对 DevOPS 进行探讨。</p><p>链接：<a href="https://www.jianshu.com/p/68384978c0a3" target="_blank" rel="noopener">https://www.jianshu.com/p/68384978c0a3</a></p><p>4、<a href="http://blog.ihipop.info/2019/07/5212.html" target="_blank" rel="noopener">记录一次磁盘镜像的 LVM 分区缩小调整过程</a></p><p>本文将分享一些 LVM 分区大小调整的技巧。</p><p>链接：<a href="http://blog.ihipop.info/2019/07/5212.html" target="_blank" rel="noopener">http://blog.ihipop.info/2019/07/5212.html</a></p><p>5、使用斐讯 N1 作为 Prometheus 监控服务器</p><p>新出的树莓派 4，性能方面可以说对于老的 3B+ 的版本可以说是有全面的提升。但价格方面 4G 内存配置的就已经需要 50$，已经逼近台 x86 的准系统。同时因为树莓派是裸板，如果想要在生产环境使用，后面还需要自己增加存储、外壳等，全套上去其实性价比已经不高。</p><p>本文作者另辟蹊径采用斐讯的 N1 来部署了一个 Prometheus 监控服务器。</p><p>链接：<a href="https://www.gracecode.com/posts/3184.html" target="_blank" rel="noopener">https://www.gracecode.com/posts/3184.html</a></p><p><img src="https://friable.rocks/_/2019_07_01/1561965398165370.png" alt=""></p><h3 id="每周观点">每周观点</h3><p>1、梦想可以天花乱坠，理想是我们一步一个脚印踩出来的坎坷道路。—— 三毛<br>2、没事早点睡，有空多挣钱。—— 佚名<br>3、在你我生命中，都不需要完美。做自己的萤火，温暖少数人就足够了。—— 佚名<br>4、人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以至始至终陪着走完，当陪你的人要下车时，即使不舍，也该心存感激，然后挥手道别。—— 宫崎骏「千与千寻」</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你想我们一起交流，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h3 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnbeta.com/articles/soft/862853.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 官方中文文档上线&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub 推出官方中文帮助文档，这是继日文版之后第二个非英语语种的帮助文档。GitHub 希望借此能够帮助中文开发者更好的理解 GitHub 操作规范，更加熟悉对 GitHub 的操作。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/soft/862853.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/soft/862853.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.cnbetacdn.com/article/2019/0701/81c468f1fc60c58.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://github.com/microsoft/WSL2-Linux-Kernel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软正式开源 WSL 2 内核源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软在今年 5 月举办的 Build 2019 上宣布了第二代 Windows 的 Linux 子系统 WSL 2。与第一代相比，WSL 2 重新设计了架构，使用真正的 Linux 内核，支持在 Windows 上运行 ELF64 Linux 二进制文件。&lt;/p&gt;
&lt;p&gt;近日，微软正式开源了 WSL 2 的内核源码，并将代码托管在 GitHub 上。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://github.com/microsoft/WSL2-Linux-Kernel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/microsoft/WSL2-Linux-Kernel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/wsl2.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gitlab 从 12.1 版本开始将不再支持 MySQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitlab 官方宣布，将从 12.1 版本开始不再支持 MySQL 数据库。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/107948/gitlab-will-removing-mysql-support-in-12-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://about.gitlab.com/images/blogimages/gitlab-blog-cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.oschina.net/news/108045/debian-10-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Debian 10 Buster 正式发布&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经历了 25 个月的开发后，Debian 团队于 2019 年 7 月 6 日正式宣布推出代号为 「Buster」 的 Debian 10 稳定版。&lt;/p&gt;
&lt;p&gt;Debian 10 是一个主要版本，带来了许多更新的组件和许多新功能和改进。此版本将在未来 5 年获得由 Debian 安全团队和 Debian 长期支持团队提供的技术支持。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108045/debian-10-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108045/debian-10-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2019/0707/142126_FSUH_2720166.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.leikeji.com/article/27315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome 代码出现广告拦截功能，谷歌或将治理网页广告乱象&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;几乎每一个网民都逃不开广告的影响，它已经深刻地进入到我们的生活之中。无论是刷新信息流还是访问某个具体的内容，广告都会在那里出现，从不在乎你是否想看到。有一部分广告明显影响到了访问网页时的体验，有的会让内容难以查看，有的则会大幅占用系统资源，甚至让电脑操作变慢。&lt;/p&gt;
&lt;p&gt;作为当前市场占有率最大的浏览器 Chrome 打算为用户分担一部分烦恼。根据 9to5google 的报道，Chrome 浏览器的开源代码中出现了内置广告拦截功能的踪影，这项功能将帮用户屏蔽掉部分广告。&lt;/p&gt;
&lt;p&gt;根据页面相关描述，Chrome 会对广告对系统资源的占用进行分析，然后找出那些使用了太多带宽或者 CPU 能力的广告并屏蔽掉它们。最后用户只会看到广告被屏蔽后 “该广告已经移除” 提示。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.leikeji.com/article/27315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.leikeji.com/article/27315&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/chrome.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IBM 340 亿美元红帽收购案完成：定义混合云的开放未来&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7 月 9 日晚，IBM 宣布以 340 亿美元（约合人民币 2340 亿）正式收购红帽。早在去年 10 月 29 日，IBM 和红帽就共同宣布两家公司已达成最终协议。根据协议，IBM 将收购红帽所有已发行的普通股，每股 190 美元，总企业价值约 340 亿美元。现在，这次庞大的收购终于完成。&lt;/p&gt;
&lt;p&gt;IBM 表示，本次收购重新定义了企业级云市场。红帽开放的混合云技术，与 IBM 广泛且深入的创新和行业洞察，以及在超过 175 个国家和地区领先的销售能力相结合，通过提供下一代混合多云平台，将共同加速企业创新。基于 Linux 和 Kubernetes 等开源技术，该平台可以使企业在本地、私有云以及多个公有云平台上安全部署、运行、管理数据及应用。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108120/ibm-closes-acquisition-of-red-hat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/30975bdc2ed93d5937c918fca2f46814f05.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 3 期 )</title>
    <link href="https://www.hi-linux.com/posts/27209.html"/>
    <id>https://www.hi-linux.com/posts/27209.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T04:52:42.443Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.cnbeta.com/articles/soft/865277.htm" target="_blank" rel="noopener">Linux Kernel 5.2 正式版发布，代号为 Bobtail Squid</a></p><p>经历了 7 个 RC 候选版本之后，Linus Torvalds 正式宣布了 Linux Kernel 5.2 正式版。本次主要版本更新在改进驱动程序和核心组件之外，还引入了一些有趣的特性和增强功能。不过需要注意的是 Linux Kernel 5.2 并非长期支持（LTS）分支，因此推荐注重稳定的用户还是使用当前的 LTS 内核。</p><p>链接：<a href="https://www.cnbeta.com/articles/soft/865277.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/soft/865277.htm</a></p><p><img src="https://static.cnbetacdn.com/thumb/article/2019/0708/1cb25fe820d7a25.jpg" alt=""></p><p>2、<a href="https://www.cnbeta.com/articles/tech/865885.htm" target="_blank" rel="noopener">知名 DNS 解析服务商 CloudXNS 将停止免费服务</a></p><p>国内知名 DNS 解析服务商「CloudXNS」发布了 “关于停止免费用户解析服务的公告”。该公告表示：“为贯彻国家网络安全政策法规，加强监管力度，更好地服务于 VIP 客户，CloudXNS 将停止免费用户使用 CloudXNS 的解析服务。”</p><p>链接：<a href="https://www.cnbeta.com/articles/tech/865885.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/tech/865885.htm</a></p><p>3、<a href="https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html" target="_blank" rel="noopener">Google 开源 robots.txt 解析器，推动 REP 标准化</a></p><p>Google 在其博客上发布了一个重要消息，它宣布 Google 开源了存储 robots.txt 解析器的 C++ 库，以便推动 REP（Robots Exclusion Protocol，也称爬虫协议、机器人协议）成为互联网标准。</p><p>链接：<a href="https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html" target="_blank" rel="noopener">https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html</a></p><p><img src="https://static.leiphone.com/uploads/new/images/20190702/5d1b31955ff60.png" alt=""></p><p>4、<a href="https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC" target="_blank" rel="noopener">阿里云 PHP Composer 全量镜像正式上线</a></p><p>阿里云正式上线 PHP Composer 全量镜像，所有 PHP 开发者都可以通过我们的开发者社区 <a href="http://developer.aliyun.com/composer" target="_blank" rel="noopener">developer.aliyun.com/composer</a> 加速 Composer 安装器。</p><p>这款镜像工具的最大优势是快，几乎实现与 PHP Packagist 官方实时同步，每隔 30 秒刷新全国 CDN 缓存。它基于阿里云的对象存储 OSS 和 CDN 研发同步系统，通过任务分发，实现同步的快速和稳定。</p><p>链接：<a href="https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC" target="_blank" rel="noopener">https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC</a></p><p>5、 <a href="https://www.oschina.net/news/108197/coredns-1-5-2-released" target="_blank" rel="noopener">CoreDNS v1.5.2 发布</a></p><p>CoreDNS 1.5.2 发布了，该版本包含一些小的 Bug 修复。在此版本中，一个重要的变更便是移除掉了 upstream 插件相关的所有文档和说明。在此次变更之后， upstream 配置行便可直接移除。</p><p>链接：<a href="https://www.oschina.net/news/108197/coredns-1-5-2-released" target="_blank" rel="noopener">https://www.oschina.net/news/108197/coredns-1-5-2-released</a></p><p><img src="https://www.hi-linux.com/img/linux/coredns.jpeg" alt=""></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://browserframe.com/" target="_blank" rel="noopener">BrowserFrame</a></p><p>「BrowserFrame」是一个很好用的在线工具，可以将截图或任何图片加上浏览器外框。</p><p>BrowserFrame 提供了两种方式来生成截图，分别是上传本地截图和输入网址生成截图。后者输入网址生产截图由于会受到网页加载速度的影响，生成速度可能会比较慢，容易出现「生成失败」的情况，建议选择直接上传本地截图的方法。</p><p>BrowserFrame 支持多种平台的多款浏览器样式，包括 Google Chrome、Firefox、Safari、Opera、IE 和 Edge 等。你不仅可以根据自己喜好选择不同的样式，还可以自定义一些细节设置，比如：窗口顏色、宽度、高度或间距等等。</p><p>项目地址: <a href="https://browserframe.com/" target="_blank" rel="noopener">https://browserframe.com/</a></p><p><img src="https://www.hi-linux.com/img/linux/BrowserFrame.jpeg" alt=""></p><p>2、<a href="https://github.com/thegreatjavascript/FakeScreenshot" target="_blank" rel="noopener">FakeScreenshot</a></p><p>这是一个可以伪造微博、知乎、豆瓣、简书等网站界面截图的项目，该项目能够非常简单的生成一个能够以假乱真的截图。</p><p>实际上想要做一张假截图是很简单的事情，不管是模仿还是干脆 PS 合成一个，导致很多时候这些截图会被拿去传播谣言。这个项目的意义在于告诉人们看到任何截图的时候都应该保持怀疑。</p><p>项目地址: <a href="https://github.com/thegreatjavascript/FakeScreenshot" target="_blank" rel="noopener">https://github.com/thegreatjavascript/FakeScreenshot</a></p><p><img src="https://openingsource.org/wp-content/uploads/2019/06/473-1.png" alt=""></p><p>3、<a href="https://mdnice.com/" target="_blank" rel="noopener">Markdown Nice</a></p><p>Markdown Nice 是一个开源的专门针对微信公众号文章排版而设计的 Markdown 在线编辑器。编写完成即排版完成，复制到公众号文章编辑器即可，非常好用。</p><p>Markdown Nice 还有很多特色功能，比如：支持自定义样式、浏览器中实时保存和预览内容样式、支持零配置图床、脚注、代码、公式等。</p><p>项目地址: <a href="https://mdnice.com/" target="_blank" rel="noopener">https://mdnice.com/</a></p><p><img src="https://www.hi-linux.com/img/linux/mdnice.jpeg" alt=""></p><p>4、<a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a></p><p><a href="http://SM.MS" target="_blank" rel="noopener">SM.MS</a> 是由 V2EX 的 Showfom 自建的一个免费图床，图床速度还不错，已经运行四年多了。该图床免注册且永久存储，且无外链、无流量限制，支持 HTTPS。</p><p>图床图片上传限制：每个图片最大 5M，每次最多上传 10 张。</p><p>项目地址：<a href="https://sm.ms" target="_blank" rel="noopener">https://sm.ms</a></p><p><img src="https://www.hi-linux.com/img/linux/smms.jpeg" alt=""></p><p>5、<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a></p><p>PicGo 是一款开源跨平台的免费图片上传工具以及图床相册管理软件，支持 Windows、macOS 和 Linux 系统。</p><p>PicGo 使用非常简单，它能帮你快速地将图片上传到微博、又拍云、阿里云 OSS、腾讯云 COS、七牛、GitHub、<a href="http://sm.ms" target="_blank" rel="noopener">sm.ms</a>、Imgur 等常见的免费图床网站或云存储服务上，并自动复制图片的链接到剪贴板里，使用上非常高效便捷。</p><p>项目地址：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></p><p><img src="https://i.loli.net/2019/05/08/5cd2dc258f927.png" alt=""></p><p>6、<a href="https://www.pexels.com" target="_blank" rel="noopener">Pexels</a></p><p>Pexels 堪称最值得推荐的免费图库之一，它的特色是将许多大大小小图库及素材来源整合在同一网站，加入搜索、分类及标签等功能，让使用者在找图片时更快更准确。</p><p>Pexels 提供各种尺寸的相片，甚至有 HD 高画质的原始图片，无须注册就能下载，更棒的是还能依照使用者需求，设定尺寸后自动在线上裁剪，节省下载后必须自行编辑所耗费的时间。</p><p>项目地址：<a href="https://www.pexels.com/" target="_blank" rel="noopener">https://www.pexels.com/</a></p><p><img src="https://www.hi-linux.com/img/linux/Pexels.jpeg" alt=""></p><p>7、<a href="https://github.com/sxfad/porter" target="_blank" rel="noopener">Porter</a></p><p>Porter 是一款数据同步中间件，主要用于解决同构/异构数据库之间的表级别数据同步问题。</p><p>Porter 是一个插件友好型的数据聚合、分发中间件，提供源端、目标端、数据过滤等插件自定义开发的能力，能够根据场景需要轻松定制同步任务。</p><p>项目地址：<a href="https://github.com/sxfad/porter" target="_blank" rel="noopener">https://github.com/sxfad/porter</a></p><p><img src="https://raw.githubusercontent.com/sxfad/porter/master/doc/img/Home.png" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="https://cloud.tencent.com/developer/article/1448440" target="_blank" rel="noopener">如何在 MySQL 8.0.16 在组复制中启用成员自动重新加入</a></p><p>随着 MySQL 8.0.16 的发布，MGR 添加了一些功能以增强其高可用性。其中一个功能是能够在某些情况下启用已离开组的成员自动重新加入，而无需用户干预。本文将介绍这一新特性所带来的变化。</p><p>链接：<a href="https://cloud.tencent.com/developer/article/1448440" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1448440</a></p><p>2、<a href="https://www.yichya.dev/dns-poisoning-and-countering/" target="_blank" rel="noopener">DNS 污染和攻击</a></p><p>DNS 污染极为简单易行且效果极佳，这篇文章将介绍一下常见的 DNS 投毒现象，以及几种避免 DNS 攻击的解决方案。</p><p>链接：<a href="https://www.yichya.dev/dns-poisoning-and-countering/" target="_blank" rel="noopener">https://www.yichya.dev/dns-poisoning-and-countering/</a></p><p>3、<a href="https://arkingc.github.io/2018/12/11/2018-12-11-docker-storage-persist" target="_blank" rel="noopener">Docker 容器数据持久化</a></p><p>本文介绍了三种常用的 Docker 数据持久化的使用方法和适用的场景。</p><p>链接：<a href="https://arkingc.github.io/2018/12/11/2018-12-11-docker-storage-persist/" target="_blank" rel="noopener">https://arkingc.github.io/2018/12/11/2018-12-11-docker-storage-persist/</a></p><p>4、<a href="https://sspai.com/post/55703" target="_blank" rel="noopener">如何在 macOS Mojave 中将 U 盘格式化成通用格式</a></p><p>本文将介绍如何在 macOS Mojave 中将 APFS 格式的 U 盘在系统自带的磁盘工具中格式化成通用格式的方法。</p><p>链接：<a href="https://sspai.com/post/55703" target="_blank" rel="noopener">https://sspai.com/post/55703</a></p><h2 id="每周观点">每周观点</h2><p>1、人生重要的不是所站的位置，而是所朝的方向。—— 李嘉诚</p><p>2、如果不继续成长，就会开始走向死亡。—— 华特·迪士尼</p><p>3、这个世界如此美好，值得为它奋战。—— 海明威</p><p>4、这世界不缺少发现，而是缺少发现后的思考。—— 牛根生</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnbeta.com/articles/soft/865277.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux Kernel 5.2 正式版发布，代号为 Bobtail Squid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经历了 7 个 RC 候选版本之后，Linus Torvalds 正式宣布了 Linux Kernel 5.2 正式版。本次主要版本更新在改进驱动程序和核心组件之外，还引入了一些有趣的特性和增强功能。不过需要注意的是 Linux Kernel 5.2 并非长期支持（LTS）分支，因此推荐注重稳定的用户还是使用当前的 LTS 内核。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/soft/865277.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/soft/865277.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.cnbetacdn.com/thumb/article/2019/0708/1cb25fe820d7a25.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnbeta.com/articles/tech/865885.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知名 DNS 解析服务商 CloudXNS 将停止免费服务&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;国内知名 DNS 解析服务商「CloudXNS」发布了 “关于停止免费用户解析服务的公告”。该公告表示：“为贯彻国家网络安全政策法规，加强监管力度，更好地服务于 VIP 客户，CloudXNS 将停止免费用户使用 CloudXNS 的解析服务。”&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/tech/865885.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/tech/865885.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google 开源 robots.txt 解析器，推动 REP 标准化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google 在其博客上发布了一个重要消息，它宣布 Google 开源了存储 robots.txt 解析器的 C++ 库，以便推动 REP（Robots Exclusion Protocol，也称爬虫协议、机器人协议）成为互联网标准。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.leiphone.com/news/201907/rPrJiMyrHkOxiFdn.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/images/20190702/5d1b31955ff60.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里云 PHP Composer 全量镜像正式上线&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里云正式上线 PHP Composer 全量镜像，所有 PHP 开发者都可以通过我们的开发者社区 &lt;a href=&quot;http://developer.aliyun.com/composer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;developer.aliyun.com/composer&lt;/a&gt; 加速 Composer 安装器。&lt;/p&gt;
&lt;p&gt;这款镜像工具的最大优势是快，几乎实现与 PHP Packagist 官方实时同步，每隔 30 秒刷新全国 CDN 缓存。它基于阿里云的对象存储 OSS 和 CDN 研发同步系统，通过任务分发，实现同步的快速和稳定。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.infoq.cn/article/lmpwEtgNKUCF_u9JgktC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、 &lt;a href=&quot;https://www.oschina.net/news/108197/coredns-1-5-2-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CoreDNS v1.5.2 发布&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CoreDNS 1.5.2 发布了，该版本包含一些小的 Bug 修复。在此版本中，一个重要的变更便是移除掉了 upstream 插件相关的所有文档和说明。在此次变更之后， upstream 配置行便可直接移除。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108197/coredns-1-5-2-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108197/coredns-1-5-2-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/coredns.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 4 期 )</title>
    <link href="https://www.hi-linux.com/posts/43583.html"/>
    <id>https://www.hi-linux.com/posts/43583.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:21:30.148Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.williamlong.info/archives/5771.html" target="_blank" rel="noopener">谷歌确认回归中国的 Dragonfly 计划彻底终止</a></p><p>近日，谷歌副总裁巴提亚（Karan Bhatia）出席美国参议院司法委员会举行的听证会时确认谷歌已经终止了在中国推出审查搜索引擎的 “蜻蜓计划”，该计划原打算推出中国定制版、通过中国法律审查的搜索引擎。</p><p>链接：<a href="https://www.williamlong.info/archives/5771.html" target="_blank" rel="noopener">https://www.williamlong.info/archives/5771.html</a></p><p><img src="https://i.loli.net/2019/07/22/5d355ee15057b67703.jpg" alt=""></p><p>2、<a href="https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code" target="_blank" rel="noopener">微软计划将 Rust 作为 C 和 C++ 的安全替代品</a></p><p>微软正在探索使用 Rust 编程语言作为 C、C++ 和其他语言的替代方案，以此来改善应用程序的安全状况。</p><p>链接：<a href="https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code" target="_blank" rel="noopener">https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code</a></p><p><img src="https://oscimg.oschina.net/oscnet/a6c6690735238bf57e020b1beb346f77686.jpg" alt=""></p><p>3、<a href="https://www.oschina.net/news/108462/develop-with-python-on-windows" target="_blank" rel="noopener">微软官方上线 Python 配置教程</a></p><p>微软近日上线了一套 Python 配置教程 《Develop with Python on Windows》，文档内容包括设置 Python 开发环境、在 Windows 与 WSL 子系统中安装相应开发工具，以及集成 VS Code 与 Git 工具并进行开发等。</p><p>链接：<a href="https://www.oschina.net/news/108462/develop-with-python-on-windows" target="_blank" rel="noopener">https://www.oschina.net/news/108462/develop-with-python-on-windows</a></p><p><img src="https://i.loli.net/2019/07/23/5d36cacdacd2d91648.jpg" alt=""></p><p>4、<a href="https://www.oschina.net/news/108481/docker-ce-19-03-0-released" target="_blank" rel="noopener">Docker CE 19.03 正式发布，无需 root 权限</a></p><p>Docker CE 19.03 和 EE 3.0 都已经正式发布，19.03 主要内容包括无需 root 权限、支持 GPU 的增强功能和 CLI 插件更新等等。Docker CE 19.03 现在是允许非 root 用户运行守护程序，启用 Rootless 模式可以防止攻击者夺取主机的 root 权限，即使 Docker 存在漏洞或设置错误。</p><p>链接：<a href="https://www.oschina.net/news/108481/docker-ce-19-03-0-released" target="_blank" rel="noopener">https://www.oschina.net/news/108481/docker-ce-19-03-0-released</a></p><p>5、<a href="https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb" target="_blank" rel="noopener">华为将开源全球首个 AI 原生数据库 GaussDB 内核</a></p><p>日前，华为在正在进行的鲲鹏计算产业论坛上宣布将开源其内部大规模使用的 GaussDB 数据库内核。该内核具备超越现有开源 MySQL、PostgreSQL 的极致性能，在鲲鹏 920 服务器上 TPC-C 性能能够达到 150 万 TPMC。并具备业内最快的故障恢复时间，完全满足各种高端企业用户的 Oracle 替代需求。</p><p>链接：<a href="https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb" target="_blank" rel="noopener">https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb</a></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://github.com/guanpengchn/markdown-resume" target="_blank" rel="noopener">Markdown-Resume</a></p><p>Markdown-Resume 是一个支持 Markdown 和富文本的在线简历排版工具，如果你想快速的制作一个好用又好看的简历，不妨试试哟~</p><p>项目地址: <a href="https://github.com/guanpengchn/markdown-resume" target="_blank" rel="noopener">https://github.com/guanpengchn/markdown-resume</a></p><p><img src="https://www.hi-linux.com/img/linux/markdown-resume.jpeg" alt=""></p><p>2、<a href="https://github.com/joeblau/gitignore.io" target="_blank" rel="noopener">gitignore.io</a></p><p>项目地址: <a href="https://github.com/joeblau/gitignore.io" target="_blank" rel="noopener">https://github.com/joeblau/gitignore.io</a></p><p>这是由 Uber 一名工程师 joeblau 所开发的 .gitignore 文件快速生成工具，开发者只需要在网站上搜索当前正在使用的操作系统、IDE、编程语言，它便会自动生成一个特定的 .gitignore 配置文件。</p><p>如果你不想用网站进行搜索，还可以安装下它的命令行工具。安装完成后，就可以使用 gi 命令来快速生成 .gitignore 配置文件啦，超级方便！</p><p><img src="https://www.hi-linux.com/img/linux/gitignore.jpeg" alt=""></p><p>3、<a href="https://github.com/crossoverJie/blog.toolbox/" target="_blank" rel="noopener">blog.toolbox</a></p><p>这是一个图床搬家工具，可以很方便的帮你将图片批量的从失效的图床搬到新的图床中。</p><p>项目地址: <a href="https://github.com/crossoverJie/blog.toolbox/" target="_blank" rel="noopener">https://github.com/crossoverJie/blog.toolbox/</a></p><p><img src="https://www.hi-linux.com/img/linux/blog-toolbox.gif" alt=""></p><p>4、<a href="https://iplist.cc" target="_blank" rel="noopener">IPList</a></p><p>IPList 是一个在线 IP、Hostname 查询工具，支持 IPv4、IPv6。只要输入查询内容就会显示出相关信息，也可看到打开网站你目前的 IP 地址。</p><p>IPList 实际上一个免费的 IP 信息查询 API，可供开发者快速取得某个 IP 或 Hostname 的信息，只要把查询的对象拼接在 <a href="https://iplist.cc/api/" target="_blank" rel="noopener">https://iplist.cc/api/</a> 网址后面就会得到结果。</p><p>项目地址: <a href="https://iplist.cc/" target="_blank" rel="noopener">https://iplist.cc/</a></p><p><img src="https://www.hi-linux.com/img/linux/iplist.jpeg" alt=""></p><p>5、<a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">Learn-Regex</a></p><p>这个项目是一个关于正则表达式的教程，不仅收录了学习资料，还提供了一个在线的学习网站帮助巩固所学，在实操中多练习一下能够让你更快的达到不需要每次使用的时候都翻开教程的境界，熟能生巧，这种东西还是全记下来用的才方便。</p><p>项目地址: <a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">https://github.com/ziishaned/learn-regex</a></p><p><img src="https://www.hi-linux.com/img/linux/Learn-Regex.png" alt=""></p><p>6、<a href="https://github.com/chubin/cheat.sh" target="_blank" rel="noopener">cheat.sh</a></p><p>一个在线查询 Linux 命令快速使用方法的网站。比如要查询 tar 命令的用法， 只需要执行 curl <a href="http://cht.sh/tar" target="_blank" rel="noopener">cht.sh/tar</a> 就可以很快得到 tar 命令的常用方法，结果比 man 命令简洁实用得多。</p><p>项目地址: <a href="https://github.com/chubin/cheat.sh" target="_blank" rel="noopener">https://github.com/chubin/cheat.sh</a></p><p><img src="https://www.hi-linux.com/img/linux/cheat.jpeg" alt=""></p><p>7、<a href="https://virtual-kubelet.io/" target="_blank" rel="noopener">Virtual Kubelet</a></p><p>Virtual Kubelet 是一个开源的 Kubernetes Kubelet 实现。它伪装成 Kubelet，目的是将 Kubernetes 连接到其他 API，这允许节点得到其他服务(如 ACI、AWS Fargate、IoT Edge 等)的支持。Virtual Kubelet 的主要场景是将Kubernetes API 扩展到无服务器的容器平台（如 ACI 和 Fargate ）。</p><p>Virtual Kubelet 提供一个库，开发者可以在项目中使用这个库来构建自定义 Kubernetes 节点代理。</p><p>项目地址: <a href="https://virtual-kubelet.io/" target="_blank" rel="noopener">https://virtual-kubelet.io/</a></p><p><img src="https://www.hi-linux.com/img/linux/Virtual-Kubelet.png" alt=""></p><p>8、<a href="https://github.com/eryajf/magic-of-sysuse-scripts" target="_blank" rel="noopener">magic-of-sysuse-scripts</a></p><p>一个可快速初始化服务器环境和安装常用软件环境的运维小工具。(@李启龙 投稿)</p><p>项目地址: <a href="https://github.com/eryajf/magic-of-sysuse-scripts" target="_blank" rel="noopener">https://github.com/eryajf/magic-of-sysuse-scripts</a></p><p><img src="https://i.loli.net/2019/07/23/5d36c5cada13b68380.gif" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="https://github.com/aCoder2013/blog/issues/35" target="_blank" rel="noopener">API 网关从入门到放弃</a></p><p>本文将以电商平台为例讲解设计 API 网关的要点和 API 网关的优劣势。</p><p>链接：<a href="https://github.com/aCoder2013/blog/issues/35" target="_blank" rel="noopener">https://github.com/aCoder2013/blog/issues/35</a></p><p><img src="https://www.hi-linux.com/img/linux/api-gateway.jpeg" alt=""></p><p>2、<a href="https://github.com/caicloud/kube-ladder" target="_blank" rel="noopener">Kubernetes 学习路径</a></p><p>本文由才云科技（Caicloud）于 2019 年内部推出，现以开源的形式进行维护。文档旨在为广大从业者提供一个 Kubernetes 学习路径，为大家提供一定的指引。我们最终的目标是让所有人剥茧抽丝般地了解 Kubernetes，不仅仅知道怎么用 Kubernetes，还知道 Kubernetes 各个功能是如何设计的。</p><p>链接：<a href="https://github.com/caicloud/kube-ladder" target="_blank" rel="noopener">https://github.com/caicloud/kube-ladder</a></p><p>3、<a href="https://github.com/blueboay/ceph-study" target="_blank" rel="noopener">Ceph-Study</a></p><p>Ceph 是一个可靠、自动均衡、自动恢复的分布式存储系统，通常可用于对象存储，块设备存储和文件系统存储。Ceph-Study 是网友整理的一份 Ceph 学习指南，写的十分详细，欢迎初学者浏览学习。</p><p>链接：<a href="https://github.com/blueboay/ceph-study" target="_blank" rel="noopener">https://github.com/blueboay/ceph-study</a></p><p><img src="https://i.loli.net/2019/07/22/5d356ee51461d56865.png" alt=""></p><p>4、<a href="https://github.com/jwasham/coding-interview-university" target="_blank" rel="noopener">Coding Interview University</a></p><p>这份指南里面包含 Google 相关的介绍视频、面试过程、教学资源，同时也有数据结构、算法、密码学等计算机专业的知识讲解。</p><p>链接：<a href="https://github.com/jwasham/coding-interview-university" target="_blank" rel="noopener">https://github.com/jwasham/coding-interview-university</a></p><p>为了便于国内开发者查看，掘金翻译团队已将该指南译为中文。</p><p>链接：<a href="https://github.com/jwasham/coding-interview-university/blob/master/translations/README-cn.md" target="_blank" rel="noopener">https://github.com/jwasham/coding-interview-university/blob/master/translations/README-cn.md</a></p><p><img src="https://i.loli.net/2019/07/23/5d366e052e79a91004.jpg" alt=""></p><p>5、<a href="https://github.com/selfteaching/the-craft-of-selfteaching" target="_blank" rel="noopener">自学是门手艺</a></p><blockquote><p>没有自学能力的人没有未来。</p></blockquote><p>「自学是门手艺」是李笑来开源的一本电子书，介绍了掌握自学能力的重要性，并以学习 Python 编程为例子讲解如何进行有效的自学的方法。</p><p>链接：<a href="https://github.com/selfteaching/the-craft-of-selfteaching" target="_blank" rel="noopener">https://github.com/selfteaching/the-craft-of-selfteaching</a></p><p>在线版链接：<a href="http://the-craft-of-selfteaching.surge.sh" target="_blank" rel="noopener">http://the-craft-of-selfteaching.surge.sh</a></p><h2 id="每周观点">每周观点</h2><p>1、美妙人生的关键在于你能迷上什么东西。——「球状闪电」</p><p>2、工作上的执着，实际上是人的一种意志。—— 张近东</p><p>3、生活是属于每个人自己的感受，不属于任何别人的看法。——「活着」</p><p>4、人生的某些障碍，你是逃不掉的。与其费尽周折绕过去，不如勇敢的地攀越，或许这会铸就你人生的高点。—— 宫崎骏「龙猫」</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.williamlong.info/archives/5771.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谷歌确认回归中国的 Dragonfly 计划彻底终止&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，谷歌副总裁巴提亚（Karan Bhatia）出席美国参议院司法委员会举行的听证会时确认谷歌已经终止了在中国推出审查搜索引擎的 “蜻蜓计划”，该计划原打算推出中国定制版、通过中国法律审查的搜索引擎。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.williamlong.info/archives/5771.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.williamlong.info/archives/5771.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/22/5d355ee15057b67703.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软计划将 Rust 作为 C 和 C++ 的安全替代品&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软正在探索使用 Rust 编程语言作为 C、C++ 和其他语言的替代方案，以此来改善应用程序的安全状况。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108368/microsoft-is-exploring-to-use-rust-as-more-secure-code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/a6c6690735238bf57e020b1beb346f77686.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/108462/develop-with-python-on-windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软官方上线 Python 配置教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微软近日上线了一套 Python 配置教程 《Develop with Python on Windows》，文档内容包括设置 Python 开发环境、在 Windows 与 WSL 子系统中安装相应开发工具，以及集成 VS Code 与 Git 工具并进行开发等。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108462/develop-with-python-on-windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108462/develop-with-python-on-windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/23/5d36cacdacd2d91648.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.oschina.net/news/108481/docker-ce-19-03-0-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker CE 19.03 正式发布，无需 root 权限&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker CE 19.03 和 EE 3.0 都已经正式发布，19.03 主要内容包括无需 root 权限、支持 GPU 的增强功能和 CLI 插件更新等等。Docker CE 19.03 现在是允许非 root 用户运行守护程序，启用 Rootless 模式可以防止攻击者夺取主机的 root 权限，即使 Docker 存在漏洞或设置错误。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108481/docker-ce-19-03-0-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108481/docker-ce-19-03-0-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;华为将开源全球首个 AI 原生数据库 GaussDB 内核&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;日前，华为在正在进行的鲲鹏计算产业论坛上宣布将开源其内部大规模使用的 GaussDB 数据库内核。该内核具备超越现有开源 MySQL、PostgreSQL 的极致性能，在鲲鹏 920 服务器上 TPC-C 性能能够达到 150 万 TPMC。并具备业内最快的故障恢复时间，完全满足各种高端企业用户的 Oracle 替代需求。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108474/huawei-will-opensource-gaussdb&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Android Pie 私人 DNS 使用教程</title>
    <link href="https://www.hi-linux.com/posts/32399.html"/>
    <id>https://www.hi-linux.com/posts/32399.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.394Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最近手机更新到了最新的 Android Pie (9.0) 系统，随着系统的更新，就可以体验到 Android Pie 带来了一系列的新特性。比如：全新设计的导航栏以及多任务界面、数字应用、安全和隐私等新功能。其中有一项更新是非常实用的，该功能可以提升用户上网过程中的安全性，它就是：DNS over TLS，在 Android 里叫做 Private DNS（私人 DNS）。</p><p><img src="https://cdn.laod.wang/wp-content/uploads/2018/11/tls.png" alt=""></p><p>默认情况下，如果网络的 DNS 服务器支持，设备会自动使用 DNS over TLS，但如果用户不希望使用 DNS over TLS，可选择将其关闭。</p><p>Android Pie 的 新功能简化了在 Android 配置自定义安全的 DNS 解析程序。当网站提供 DNS 服务时，客户端和网站服务器就会自动进行加密，第三方无法窥视 DNS 查询。因为 Android 9 内置对 DNS over TLS 的支持。同时该 TLS 还负责自动默认 HTTPS 访问网站，在地址栏可看到绿色安全锁图标。这可确保不会被 ISP、移动运营商以及客户端与 DNS 解析程序之间的第三方篡改内容或无法解析。</p><p>在讲这个功能之前先来了解一下什么是 DNS 和 DNS 污染。</p><a id="more"></a><h3 id="原理">原理</h3><p>既然说起 DNS 和其污染问题，就不得不先看看 DNS 系统是如何工作的。</p><p>互联网所有通信都是建立在 TCP/IP 的基础上，如果想访问目标网络，就必须知道目标 IP。不过 IP 的数量有限，还有 IP 是由一串数字或十六进制组成的，不是那么好记，所以有了域名。域名本身不具有访问性，它如果想被访问，必须绑定一个或多个 IP，一个 IP 可以绑定一个或多个域名。这时候就有一个问题，如何知道域名指向的是哪个 IP。所以需要一项服务，它记载着所有域名和IP的关系，需要的时候询问它就可以了，这就是 DNS（域名系统）。</p><p>以访问 Wikipedia 网站为例。</p><p><img src="https://kyle.ai/blog/wp-content/uploads/2017/09/563px-An_example_of_theoretical_DNS_recursion.svg_.png" alt=""></p><p>DNS 解析流程图</p><p>图中可以看到我们的 ISP 的 DNS 服务器在图中叫做 DNS Recurser，在解析一个域名的时候，总共经过了以下的步骤：</p><ol><li>向 root 服务器获取该 gTLD 的管辖服务器，图中为 org 结尾的域名。</li><li>root 服务器返回 org 的管辖服务器。</li><li>向 org 的管辖服务器查询，谁来负责解析 <a href="http://wikipedia.org" target="_blank" rel="noopener">wikipedia.org</a> 这个域名的。</li><li>org 的管辖服务器返回解析 <a href="http://wikipedia.org" target="_blank" rel="noopener">wikipedia.org</a> 的服务器 IP 地址。</li><li>向 <a href="http://wikipedia.org" target="_blank" rel="noopener">wikipedia.org</a> 的解析服务器发出查询，解析 <a href="http://www.wikipedia.org" target="_blank" rel="noopener">www.wikipedia.org</a> 的 IP 地址。</li><li>拿到最终要的 IP 地址。</li></ol><p>从上面的 DNS 解析流程可以看出，解析一个域名一共要经历 6 个步骤。</p><p>由于 DNS 的数据是以明文传输，所以 DNS 服务器返回的数据在传输的过程中是有可能被篡改的，导致域名指向错误的 IP，引导用户访问错误或恶意的网站。比如：在最后一次查询的时候，有人假冒了 <a href="http://wikipedia.org" target="_blank" rel="noopener">wikipedia.org</a> 的解析服务器，则可以在中间进行欺骗攻击，致使用户最后得到的 IP 地址不是真实的地址。如图所示，</p><p><img src="https://kyle.ai/blog/wp-content/uploads/2017/09/563px-An_example_of_theoretical_DNS_recursion.svg_1.png" alt=""></p><p>解析请求被劫持</p><h3 id="为什么要使用私有-dns">为什么要使用私有 DNS？</h3><p>从上面的例子我们可以看出，DNS 是存在被劫持和污染的风险的。为了保护用户的上网安全，一些 DNS 加密查询技术因此应运而生。常见的有：DNS over HTTPS、DNSCrypt 和 DNS over TLS。这三种的技术原理大致一样，都是通过一些手段加密用户与 DNS 服务器之间的通信，避免 DNS 污染。</p><blockquote><p>TLS (Transport Layer Security，传输层安全协议)，TLS 是 IETF（Internet Engineering Task Force，Internet 工程任务组）制定的一种新的协议。TLS 是在其前身 SSL （Secure Sockets Layer，安全套接层）的基础上发展来的。SSL 也是一种安全协议，其目的是为互联网通信提供安全及数据完整性保障。TLS 它建立在 SSL 3.0 协议规范之上，是 SSL 3.0 的后续版本，可以理解为 SSL 3.1。TLS 协议由两层组成：TLS 记录层（TLS Record）和 TLS 传输层（TLS Handshake）。较低的层为 TLS 记录层协议，位于某个可靠的传输协议（例如：TCP）上面。记录层协议确定传输层数据的封装格式。传输层安全协议使用 X.509 认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p></blockquote><p>目前支持 DNS over TLS 的平台不多， Android Pie 就是其中这一。如果你的系统暂时不支持 DNS over TLS，你可以暂时使用 SmartDNS 这个程序来作为本地 DNS 服务器，它支持将 DNS over TLS 作为 DNS 上游服务器。</p><p>SmartDNS 项目地址：<a href="https://github.com/pymumu/smartdns" target="_blank" rel="noopener">https://github.com/pymumu/smartdns</a></p><h3 id="在-android-pie-上启用-dns-over-tls">在 Android Pie 上启用  DNS over TLS</h3><p>在 Android Pie 上启用  DNS over TLS 的方法非常简单。下面以一加 5 为例，大概需要如下步骤：</p><ol><li>打开 [设置] → [WLAN 和互联网] → [私人 DNS] → [私人 DNS 提供商主机名] → 输入 DNS over TLS 提供商提供的主机名 → 保存。</li></ol><p>保存以后，如果私人 DNS 下方显示主机名代表配置成功。</p><blockquote><ol><li><p>私有 DNS 字段并不接受类似 1.1.1.1 这样简单的 IP 地址，而是需要一个主机名。如：dns.google。Google 之所以要求私有 DNS 字段是主机名而非 IP 地址，这是因为考虑到移动运营商需要兼顾 IPv4 和 IPv6 共存的问题。</p></li><li><p>如果你使用原生 Android Pie 可使用 [设置] → [网络和互联网] → [高级] → [私人 DNS] 。</p></li></ol></blockquote><p>验证是否生效</p><ul><li><p>如果你使用的是 Cloudflare 提供的私人 DNS，可以访问 <a href="https://1.1.1.1/help" target="_blank" rel="noopener">https://1.1.1.1/help</a> 进行验证。如果 “使用 DNS over TLS（DoT）” 显示为 “是” 就表示配置成功了。</p></li><li><p>你也可以访问 <a href="https://whoer.net/zh" target="_blank" rel="noopener">https://whoer.net/zh</a> 这个网站来测试 DNS 匿名性。</p></li></ul><p>一些可用的 DNS over TLS 提供商</p><blockquote><p>Google: dns.google</p><p>Cloudflare: <a href="http://1dot1dot1dot1.cloudflare-dns.com" target="_blank" rel="noopener">1dot1dot1dot1.cloudflare-dns.com</a></p><p>Quad9: <a href="http://dns.quad9.net" target="_blank" rel="noopener">dns.quad9.net</a></p><p>CleanBrowsing: <a href="http://security-filter-dns.cleanbrowsing.org" target="_blank" rel="noopener">security-filter-dns.cleanbrowsing.org</a></p><p>红鱼 DNS: <a href="http://dns.rubyfish.cn" target="_blank" rel="noopener">dns.rubyfish.cn</a></p></blockquote><p>祝大家早日吃上 Andorid Pie。最后我们来搞个小投票，看看大家所使用的手机品牌和系统。</p><h3 id="参考文档">参考文档</h3><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="http://t.cn/EicGa97" target="_blank" rel="noopener">http://t.cn/EicGa97</a></li><li><a href="http://t.cn/EiVVF4K" target="_blank" rel="noopener">http://t.cn/EiVVF4K</a></li><li><a href="http://t.cn/EiVfk7i" target="_blank" rel="noopener">http://t.cn/EiVfk7i</a></li><li><a href="http://t.cn/EiVc5Uf" target="_blank" rel="noopener">http://t.cn/EiVc5Uf</a></li><li><a href="http://t.cn/E2m0Ytz" target="_blank" rel="noopener">http://t.cn/E2m0Ytz</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近手机更新到了最新的 Android Pie (9.0) 系统，随着系统的更新，就可以体验到 Android Pie 带来了一系列的新特性。比如：全新设计的导航栏以及多任务界面、数字应用、安全和隐私等新功能。其中有一项更新是非常实用的，该功能可以提升用户上网过程中的安全性，它就是：DNS over TLS，在 Android 里叫做 Private DNS（私人 DNS）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.laod.wang/wp-content/uploads/2018/11/tls.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，如果网络的 DNS 服务器支持，设备会自动使用 DNS over TLS，但如果用户不希望使用 DNS over TLS，可选择将其关闭。&lt;/p&gt;
&lt;p&gt;Android Pie 的 新功能简化了在 Android 配置自定义安全的 DNS 解析程序。当网站提供 DNS 服务时，客户端和网站服务器就会自动进行加密，第三方无法窥视 DNS 查询。因为 Android 9 内置对 DNS over TLS 的支持。同时该 TLS 还负责自动默认 HTTPS 访问网站，在地址栏可看到绿色安全锁图标。这可确保不会被 ISP、移动运营商以及客户端与 DNS 解析程序之间的第三方篡改内容或无法解析。&lt;/p&gt;
&lt;p&gt;在讲这个功能之前先来了解一下什么是 DNS 和 DNS 污染。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Android" scheme="https://www.hi-linux.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Linux 并行处理神器 GNU Parallel 简明教程</title>
    <link href="https://www.hi-linux.com/posts/32794.html"/>
    <id>https://www.hi-linux.com/posts/32794.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.396Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Bash</code> 命令通常单线程运行，这意味着所有的处理工作只在单个 CPU 上执行。随着 CPU 规模的扩大以及核心数目的增加，这意味着只有一小部分的 CPU 资源用于处理任务，这样就造成了很大的资源浪费。 这种情况在进行多媒体转换（比如：图片和视频转换）以及数据压缩中经常遇到。</p><p>本文我们将介绍如何使用 GNU Parallel 程序在所有 CPU 核上并行地执行计算任务。</p><h3 id="parallel-介绍">Parallel 介绍</h3><blockquote><p>GNU Parallel 是一种通用的并行化程序，可以在同一台机器上或在您具有 SSH 访问权限的多台机器上轻松并行运行作业。</p></blockquote><p>如果要在 4 个 CPU 上运行 32 个不同的作业，并行化的一种直接方法是在每个 CPU 上运行8个作业。</p><p><a href="https://upload-images.jianshu.io/upload_images/27460-5b784effa2396844.png" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/27460-5b784effa2396844.png</a></p><p>GNU Parallel 会在完成后生成一个新进程，并保持 CPU 处于活动状态，从而节省时间。</p><p><a href="https://upload-images.jianshu.io/upload_images/27460-2901afa31279f8ff.png" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/27460-2901afa31279f8ff.png</a></p><h3 id="parallel-安装">Parallel 安装</h3><ol><li>通过包安装</li></ol><ul><li>CentOS / RHEL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install parallel</span><br></pre></td></tr></table></figure><ul><li>Ubuntu / Debian</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install parallel</span><br></pre></td></tr></table></figure><ol start="2"><li>通过脚本安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ (wget -O - pi.dk&#x2F;3 || curl pi.dk&#x2F;3&#x2F;) | bash</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="parallel-使用">Parallel 使用</h3><h4 id="parallel-语法简介">Parallel 语法简介</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">parallel [options] [command [arguments]] &lt; list_of_arguments</span><br><span class="line">parallel [options] [command [arguments]] (::: arguments|:::: argfile(s))...</span><br><span class="line">cat ... | parallel --pipe [options] [command [arguments]]</span><br></pre></td></tr></table></figure><ul><li>Parallel 常用选项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">::: 后面接参数。</span><br><span class="line">:::: 后面接文件。</span><br><span class="line">-j、--jobs   并行任务数，不想并行执行可以设为 1。若不加 -j，则预设为每个 CPU 执行一个 job。</span><br><span class="line">-N  每次输入的参数数量。</span><br><span class="line">-L N: 一次最多读取 N 行。</span><br><span class="line">--xargs 会在一行中输入尽可能多的参数。</span><br><span class="line">-xapply 从每一个源获取一个参数（或文件一行）。</span><br><span class="line">--header  把每一行输入中的第一个值做为参数名。</span><br><span class="line">-m   表示每个 job 不重复输出“背景”（context）。</span><br><span class="line">-X   与 -m 相反，会重复输出“背景文本”。</span><br><span class="line">-q  保护后面的命令。</span><br><span class="line">--trim lr 去除参数两头的空格，只能去除空格，换行符和 tab 都不能去除。</span><br><span class="line">--keep-order&#x2F;-k   强制使输出与参数保持顺序 --keep-order&#x2F;-k。</span><br><span class="line">--tmpdir&#x2F; --results   都是保存文件，但是后者可以有结构的保存。</span><br><span class="line">--delay  延迟每个任务启动时间。</span><br><span class="line">--halt  终止任务。</span><br><span class="line">--pipe    该参数使得我们可以将输入（stdin）分为多块（block），再将 stdin 的资料分给各个 jobs。</span><br><span class="line">--block  参数可以指定每块的大小。</span><br></pre></td></tr></table></figure><h4 id="parallel-用法简介">Parallel 用法简介</h4><ol><li>输入源</li></ol><p>GNU Parallel 的输入源支持文件、命令行和标准输入（ Stdin 或 Pipe）。</p><ul><li>以命令行做为输入源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo ::: a b c d e | tee a.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><ul><li>以 Stdin（标准输入）作为输入源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat a.txt | parallel echo</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><ul><li>GNU Parallel 支持通过命令行指定多个输入源，它会生成所有的组合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo ::: A B C ::: D E F | tee b.txt</span><br><span class="line">A D</span><br><span class="line">A E</span><br><span class="line">A F</span><br><span class="line">B D</span><br><span class="line">B E</span><br><span class="line">B F</span><br><span class="line">C D</span><br><span class="line">C E</span><br><span class="line">C F</span><br></pre></td></tr></table></figure><ul><li>多个文件作为输入，此时多个文件中的内容也会像上面那样进行组合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -a a.txt -a b.txt echo</span><br></pre></td></tr></table></figure><ul><li>Stdin（标准输入）作为文件源中的一个，使用 -， 输出结果同上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat a.txt |parallel -a - -a b.txt echo</span><br></pre></td></tr></table></figure><ul><li>使用 <code>::::</code> 代替 <code>-a</code>，后面可接多个文件名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat a.txt | parallel echo :::: - b.txt</span><br></pre></td></tr></table></figure><ul><li><code>:::</code> 和 <code>::::</code> 可以同时使用，同样的输出结果也会进行组合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo ::: a b :::: b.txt</span><br></pre></td></tr></table></figure><ul><li>当然，若不想像上面那样进行组合，可使用 --xapply 参数从每一个源获取一个参数（或文件一行），这个参数有些类似 R 中的函数，具有广播作用。如果其中一个输入源的长度比较短，它的值会被重复。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --xapply echo ::: A B C ::: D E F</span><br><span class="line">A D</span><br><span class="line">B E</span><br><span class="line">C F</span><br><span class="line"></span><br><span class="line">$ parallel --xapply echo ::: A B C ::: D E F G H I</span><br><span class="line">A D</span><br><span class="line">B E</span><br><span class="line">C F</span><br><span class="line">A G</span><br><span class="line">B H</span><br><span class="line">C I</span><br></pre></td></tr></table></figure><ol start="2"><li>改变参数分隔符</li></ol><p>GNU Parallel 可以通过 <code>--arg-sep</code> 和 <code>--arg-file-sep</code> 指定分隔符替代 <code>:::</code> 或 <code>::::</code>，当这两个符号被其它命令占用的时候会特别有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -k --arg-sep ,,, echo ,,, a b ,,, c d | tee c.txt </span><br><span class="line">a c</span><br><span class="line">a d</span><br><span class="line">b c</span><br><span class="line">b d</span><br><span class="line"></span><br><span class="line">$ parallel --xapply --arg-file-sep ,,,, echo ,,,, a.txt  b.txt </span><br><span class="line"></span><br><span class="line">a A D</span><br><span class="line">b A E</span><br><span class="line">c A F</span><br><span class="line">d B D</span><br><span class="line">e B E</span><br><span class="line">a B F</span><br><span class="line">b C D</span><br><span class="line">c C E</span><br><span class="line">d C F</span><br></pre></td></tr></table></figure><ol start="3"><li>改变输入分隔符</li></ol><p>GNU Parallel 默认把一行做为一个参数。使用 <code>\n</code> 做为参数定界符，可以使用 <code>-d</code> 改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -d b echo :::: a.txt </span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><ol start="4"><li>提前结束和跳过空行</li></ol><p>GNU Parallel 支持通过 <code>-E</code> 参数指定一个值做为结束标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -E stop echo ::: A B stop C D</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>GNU Parallel 使用 <code>--no-run-if-empty</code> 来跳过空行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ (echo 1; echo; echo 2) | parallel --no-run-if-empty echo</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><ol start="5"><li>构建命令行</li></ol><p>如果 Parallel 之后没有给定命令，那么这些参数会被当做命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ parallel ::: ls &#39;echo foo&#39; pwd</span><br><span class="line">a.txt</span><br><span class="line">b.txt</span><br><span class="line">c.txt</span><br><span class="line">jianchen</span><br><span class="line">mypipe</span><br><span class="line">scripts</span><br><span class="line">snake_test</span><br><span class="line">WGS_snake</span><br><span class="line">foo</span><br><span class="line">&#x2F;home&#x2F;sxuan</span><br></pre></td></tr></table></figure><p>此外，命令还可以是一个脚本文件，一个二进制可执行文件或一个 <code>Bash</code> 的函数（须用 export -f 导出函数）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;echo \$*&quot; &gt; s.sh</span><br><span class="line">$ parallel .&#x2F;s.sh ::: &quot;a b c f&quot; &quot;1 2 3 4&quot;</span><br><span class="line">a b c f</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><ol start="6"><li>替换字符串</li></ol><p>GNU Parallel 支持多种替换字符串，默认使用 {}，使用 <code>-I</code> 改变替换字符串符号 {}。</p><p>其最常见的字符串替换包括以下几种：</p><ul><li>{.}，去掉扩展名</li><li>{/},去掉路径，只保留文件名</li><li>{//}，只保留路径</li><li>{/.}，同时去掉路径和扩展名</li><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo ::: A&#x2F;B.C ; parallel echo &#123;&#125; ::: A&#x2F;B.C ; parallel -I ,, echo ,, ::: A&#x2F;B.C</span><br><span class="line">A&#x2F;B.C</span><br><span class="line">A&#x2F;B.C</span><br><span class="line">A&#x2F;B.C</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;.&#125; ::: A&#x2F;B.C ; parallel --extensionreplace ,, echo ,, ::: A&#x2F;B.C</span><br><span class="line">A&#x2F;B</span><br><span class="line">A&#x2F;B</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;&#x2F;&#125; ::: A&#x2F;B.C ; parallel --basenamereplace ,, echo ,, ::: A&#x2F;B.C</span><br><span class="line">B.C</span><br><span class="line">B.C</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;&#x2F;&#x2F;&#125; ::: A&#x2F;B.C ; parallel --dirnamereplace ,, echo ,, ::: A&#x2F;B.C </span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;&#x2F;.&#125; ::: A&#x2F;B.C ; parallel --basenameextensionreplace ,, echo ,, ::: A&#x2F;B.C</span><br><span class="line">B</span><br><span class="line">B</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;#&#125; ::: A B C ; parallel --seqreplace ,, echo ,, ::: A B C</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>同时，如果有多个输入源时，可以通过 {编号} 指定某一个输入源的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --xapply  echo &#123;1&#125; and &#123;2&#125; ::: A B ::: C D</span><br><span class="line">A and C</span><br><span class="line">B and D</span><br></pre></td></tr></table></figure><p>可以使用 / // /. 和 . 改变指定替换字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo &#x2F;&#x3D;&#123;1&#x2F;&#125; &#x2F;&#x2F;&#x3D;&#123;1&#x2F;&#x2F;&#125; &#x2F;.&#x3D;&#123;1&#x2F;.&#125; .&#x3D;&#123;1.&#125; ::: A&#x2F;B.C D&#x2F;E.F</span><br><span class="line">&#x2F;&#x3D;B.C &#x2F;&#x2F;&#x3D;A &#x2F;.&#x3D;B .&#x3D;A&#x2F;B</span><br><span class="line">&#x2F;&#x3D;E.F &#x2F;&#x2F;&#x3D;D &#x2F;.&#x3D;E .&#x3D;D&#x2F;E</span><br></pre></td></tr></table></figure><p>位置可以是负数，表示倒着数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ parallel echo 1&#x3D;&#123;1&#125; 2&#x3D;&#123;2&#125; 3&#x3D;&#123;3&#125; -1&#x3D;&#123;-1&#125; -2&#x3D;&#123;-2&#125; -3&#x3D;&#123;-3&#125; ::: A B ::: C D ::: E F</span><br><span class="line">1&#x3D;A 2&#x3D;C 3&#x3D;E -1&#x3D;E -2&#x3D;C -3&#x3D;A</span><br><span class="line">1&#x3D;A 2&#x3D;C 3&#x3D;F -1&#x3D;F -2&#x3D;C -3&#x3D;A</span><br><span class="line">1&#x3D;A 2&#x3D;D 3&#x3D;E -1&#x3D;E -2&#x3D;D -3&#x3D;A</span><br><span class="line">1&#x3D;A 2&#x3D;D 3&#x3D;F -1&#x3D;F -2&#x3D;D -3&#x3D;A</span><br><span class="line">1&#x3D;B 2&#x3D;C 3&#x3D;E -1&#x3D;E -2&#x3D;C -3&#x3D;B</span><br><span class="line">1&#x3D;B 2&#x3D;C 3&#x3D;F -1&#x3D;F -2&#x3D;C -3&#x3D;B</span><br><span class="line">1&#x3D;B 2&#x3D;D 3&#x3D;E -1&#x3D;E -2&#x3D;D -3&#x3D;B</span><br><span class="line">1&#x3D;B 2&#x3D;D 3&#x3D;F -1&#x3D;F -2&#x3D;D -3&#x3D;B</span><br></pre></td></tr></table></figure><ol start="7"><li>按列输入和指定参数名</li></ol><p>使用 <code>--header</code> 把每一行输入中的第一个值做为参数名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --xapply --header : echo f1&#x3D;&#123;f1&#125; f2&#x3D;&#123;f2&#125; ::: f1 A B ::: f2 C D | tee d.txt</span><br><span class="line">f1&#x3D;A f2&#x3D;C</span><br><span class="line">f1&#x3D;B f2&#x3D;D</span><br></pre></td></tr></table></figure><p>使用 <code>--colsep</code> 把文件中的行切分为列，做为输入参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ perl -e &#39;printf &quot;f1\tf2\nA\tB\nC\tD\n&quot;&#39; &gt; tsv-file.tsv</span><br><span class="line">$ parallel --header : --colsep &#39;\t&#39; echo f1&#x3D;&#123;f1&#125; f2&#x3D;&#123;f2&#125; :::: tsv-file.tsv </span><br><span class="line">f1&#x3D;A f2&#x3D;B</span><br><span class="line">f1&#x3D;C f2&#x3D;D</span><br></pre></td></tr></table></figure><ol start="8"><li>多参数</li></ol><p><code>--xargs</code> 会在一行中输入尽可能多的参数（与参数字符串长度有关），通过 <code>-s</code> 可指定一行中参数的上限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ perl -e &#39;for(1..30000)&#123;print &quot;$_\n&quot;&#125;&#39; &gt; num30000</span><br><span class="line">$ cat num30000 | parallel --xargs echo | wc -l</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">$ cat num30000 | parallel --xargs -s 10000 echo | wc -l</span><br><span class="line">17</span><br></pre></td></tr></table></figure><p>为了获得更好的并发性，GNU Parallel 会在文件读取结束后再分发参数。</p><p>GNU Parallel 在读取完最后一个参数之后，才开始第二个任务，此时会把所有的参数平均分配到 4 个任务（如果指定了4个任务）。</p><p>第一个任务与上面使用 <code>--xargs</code> 的例子一样，但是第二个任务会被平均的分成 4 个任务，最终一共 5 个任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat num30000 | parallel --jobs 4 -m echo | wc -l</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>将 1-10 分参数分配到4个任务可以看得更清晰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --jobs 4 -m echo ::: &#123;1..10&#125;</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>替换字符串可以是输出字符的一部分，使用 <code>-m</code> 参数表示每个 job 不重复输出 “背景”（context），<code>-X</code> 则与 <code>-m</code> 相反，会重复输出 “背景文本”，具体通过下面几个例子进行理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --jobs 4 echo pre-&#123;&#125;-post ::: A B C D E F G</span><br><span class="line">pre-A-post</span><br><span class="line">pre-B-post</span><br><span class="line">pre-C-post</span><br><span class="line">pre-D-post</span><br><span class="line">pre-E-post</span><br><span class="line">pre-F-post</span><br><span class="line">pre-G-post</span><br><span class="line"></span><br><span class="line">$ parallel --jobs 4 -m echo pre-&#123;&#125;-post ::: A B C D E F G</span><br><span class="line">pre-A B-post</span><br><span class="line">pre-C D-post</span><br><span class="line">pre-E F-post</span><br><span class="line">pre-G-post</span><br><span class="line"></span><br><span class="line">$ parallel --jobs 4 -X echo pre-&#123;&#125;-post ::: A B C D E F G</span><br><span class="line">pre-A-post pre-B-post</span><br><span class="line">pre-C-post pre-D-post</span><br><span class="line">pre-E-post pre-F-post</span><br><span class="line">pre-G-post</span><br></pre></td></tr></table></figure><p>使用 <code>-N</code> 限制每行参数的个数，其中 <code>-N0</code> 表示一次只读取一个参数，且不输入这个参数（作为计数器来使用）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -N4 echo 1&#x3D;&#123;1&#125; 2&#x3D;&#123;2&#125; 3&#x3D;&#123;3&#125; ::: A B C D E F G H</span><br><span class="line">1&#x3D;A 2&#x3D;B 3&#x3D;C</span><br><span class="line">1&#x3D;E 2&#x3D;F 3&#x3D;G</span><br><span class="line">$ parallel -N0 echo foo ::: 1 2 3</span><br><span class="line">foo</span><br><span class="line">foo</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><ol start="9"><li>引用</li></ol><p>如果命令行中包含特殊字符，就需要使用引号保护起来。</p><p>Perl 脚本 <code>'print &quot;@ARGV\n&quot;'</code> 与 Linux 的 <code>echo</code> 的功能一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ perl -e &#39;print &quot;@ARGV\n&quot;&#39; A</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>使用 GNU Parallel 运行这条命令的时候，Perl 命令需要用引号包起来，也可以使用 <code>-q</code> 保护 <code>Perl</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ parallel perl -e &#39;print &quot;@ARGV\n&quot;&#39; ::: This wont work</span><br><span class="line">$ parallel -q perl -e &#39;print &quot;@ARGV\n&quot;&#39; ::: This works</span><br><span class="line">This</span><br><span class="line">works</span><br><span class="line">$ parallel perl -e \&#39;&#39;print &quot;@ARGV\n&quot;&#39;\&#39; ::: This works, too</span><br><span class="line">This</span><br><span class="line">works,</span><br><span class="line">too</span><br></pre></td></tr></table></figure><ol start="10"><li>去除空格</li></ol><p>使用 --trim 去除参数两头的空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --trim r echo pre-&#123;&#125;-post ::: &#39; A &#39;</span><br><span class="line">pre- A-post</span><br><span class="line"></span><br><span class="line">$ parallel --trim l echo pre-&#123;&#125;-post ::: &#39; A &#39;</span><br><span class="line">pre-A -post</span><br><span class="line"></span><br><span class="line">$ parallel --trim lr echo pre-&#123;&#125;-post ::: &#39; A &#39;</span><br><span class="line">pre-A-post</span><br></pre></td></tr></table></figure><ol start="11"><li>控制输出</li></ol><p>使用 <code>--tag</code> 以参数做为输出前缀，使用 <code>--tagstring</code> 修改输出前缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --tag echo foo-&#123;&#125; ::: A B C</span><br><span class="line">A   foo-A</span><br><span class="line">B   foo-B</span><br><span class="line">C   foo-C</span><br><span class="line"></span><br><span class="line">$ parallel --tagstring &#123;&#125;-bar echo foo-&#123;&#125; ::: A B C</span><br><span class="line">A-bar   foo-A</span><br><span class="line">B-bar   foo-B</span><br><span class="line">C-bar   foo-C</span><br></pre></td></tr></table></figure><p><code>--dryrun</code> 作用类似于 echo 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --dryrun echo &#123;&#125; ::: A B C</span><br><span class="line">echo A</span><br><span class="line">echo B</span><br><span class="line">echo C</span><br><span class="line"></span><br><span class="line">$ parallel echo &#123;&#125; ::: A B C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p><code>--verbose</code> 则在运行之前先打印命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --verbose echo &#123;&#125; ::: A B C</span><br><span class="line">echo A</span><br><span class="line">echo B</span><br><span class="line">echo C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>一般来说，GNU Parallel 会延迟输出，直到一组命令执行完成。使用 <code>--ungroup</code>，可立刻打印输出已完成部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -j2 &#39;printf &quot;%s-start\n%s&quot; &#123;&#125; &#123;&#125;;sleep &#123;&#125;;printf &quot;%s\n&quot; -middle;echo &#123;&#125;-end&#39; ::: 4 2 1</span><br><span class="line">2-start</span><br><span class="line">2-middle</span><br><span class="line">2-end</span><br><span class="line">1-start</span><br><span class="line">1-middle</span><br><span class="line">1-end</span><br><span class="line">4-start</span><br><span class="line">4-middle</span><br><span class="line">4-end</span><br><span class="line"></span><br><span class="line">$ parallel -j2 --ungroup &#39;printf &quot;%s-start\n%s&quot; &#123;&#125; &#123;&#125;;sleep &#123;&#125;;printf &quot;%s\n&quot; -middle;echo &#123;&#125;-end&#39; ::: 4 2 1</span><br><span class="line">4-start</span><br><span class="line">42-start</span><br><span class="line">2-middle</span><br><span class="line">2-end</span><br><span class="line">1-start</span><br><span class="line">1-middle</span><br><span class="line">1-end</span><br><span class="line">-middle</span><br><span class="line">4-end</span><br></pre></td></tr></table></figure><p>使用 <code>--ungroup</code> 会很快，但会导致输出错乱，一个任务的行输出可能会被另一个任务的输出截断。像上例所示，第二行输出混合了两个任务：‘4-middle’ ‘2-start’。使用 <code>--linebuffer</code> 避免这个问题（稍慢一点）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4-start</span><br><span class="line">2-start</span><br><span class="line">2-middle</span><br><span class="line">2-end</span><br><span class="line">1-start</span><br><span class="line">1-middle</span><br><span class="line">1-end</span><br><span class="line">4-middle</span><br><span class="line">4-end</span><br></pre></td></tr></table></figure><p>强制使输出与参数保持顺序 <code>--keep-order/-k</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -j2 -k &#39;printf &quot;%s-start\n%s&quot; &#123;&#125; &#123;&#125;;sleep &#123;&#125;;printf &quot;%s\n&quot; -middle;echo &#123;&#125;-end&#39; ::: 4 2 1</span><br><span class="line">4-start</span><br><span class="line">4-middle</span><br><span class="line">4-end</span><br><span class="line">2-start</span><br><span class="line">2-middle</span><br><span class="line">2-end</span><br><span class="line">1-start</span><br><span class="line">1-middle</span><br><span class="line">1-end</span><br></pre></td></tr></table></figure><ol start="12"><li>将输出保存到文件</li></ol><p>GNU Parallel 可以把每一个任务的输出保存到文件中，临时文件默认保存在 /tmp 中，可以使用 <code>--tmpdir</code> 改变（或者修改 $TMPDIR）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --files ::: A B C</span><br><span class="line">&#x2F;tmp&#x2F;parfmNTJ.par</span><br><span class="line">&#x2F;tmp&#x2F;parmioFz.par</span><br><span class="line">&#x2F;tmp&#x2F;pargaTxf.par</span><br><span class="line"></span><br><span class="line">$ parallel --tmpdir ~ --files ::: A B C</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;parLEXH7.par</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;parXsKsR.par</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;parZxytI.par</span><br><span class="line"></span><br><span class="line">$ TMPDIR&#x3D;~ parallel --files ::: A B C</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;par2tX6C.par</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;parorPJy.par</span><br><span class="line">&#x2F;home&#x2F;sxuan&#x2F;pari5TkI.par</span><br></pre></td></tr></table></figure><p>输出文件可以有结构的保存 <code>--results</code>，输出文件不仅包含标准输出（stdout）也会包含标准错误输出（stderr）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --results outdir echo ::: A B C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line"></span><br><span class="line">$ tree outdir&#x2F;</span><br><span class="line">outdir&#x2F;</span><br><span class="line">└── 1</span><br><span class="line">    ├── A</span><br><span class="line">    │   ├── seq</span><br><span class="line">    │   ├── stderr</span><br><span class="line">    │   └── stdout</span><br><span class="line">    ├── B</span><br><span class="line">    │   ├── seq</span><br><span class="line">    │   ├── stderr</span><br><span class="line">    │   └── stdout</span><br><span class="line">    └── C</span><br><span class="line">        ├── seq</span><br><span class="line">        ├── stderr</span><br><span class="line">        └── stdout</span><br><span class="line"></span><br><span class="line">4 directories, 9 files</span><br></pre></td></tr></table></figure><p>在使用多个变量的时候会显得很有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># --header : will take the first value as name and use that in the directory structure.</span><br><span class="line"></span><br><span class="line">$ parallel --header : --results outdir echo ::: f1 A B ::: f2 C D</span><br><span class="line">A C</span><br><span class="line">A D</span><br><span class="line">B C</span><br><span class="line">B D</span><br><span class="line"></span><br><span class="line">$ tree outdir&#x2F;</span><br><span class="line">outdir&#x2F;</span><br><span class="line">└── f1</span><br><span class="line">    ├── A</span><br><span class="line">    │   └── f2</span><br><span class="line">    │       ├── C</span><br><span class="line">    │       │   ├── seq</span><br><span class="line">    │       │   ├── stderr</span><br><span class="line">    │       │   └── stdout</span><br><span class="line">    │       └── D</span><br><span class="line">    │           ├── seq</span><br><span class="line">    │           ├── stderr</span><br><span class="line">    │           └── stdout</span><br><span class="line">    └── B</span><br><span class="line">        └── f2</span><br><span class="line">            ├── C</span><br><span class="line">            │   ├── seq</span><br><span class="line">            │   ├── stderr</span><br><span class="line">            │   └── stdout</span><br><span class="line">            └── D</span><br><span class="line">                ├── seq</span><br><span class="line">                ├── stderr</span><br><span class="line">                └── stdout</span><br><span class="line"></span><br><span class="line">9 directories, 12 files</span><br></pre></td></tr></table></figure><ol start="13"><li>控制执行</li></ol><p>使用 <code>--jobs/-j</code> 指定并行任务数。</p><p>使用 64 个任务执行 128 个休眠命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ time parallel -N0 -j64 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m2.759s</span><br><span class="line">user    0m0.657s</span><br><span class="line">sys 0m1.345s</span><br></pre></td></tr></table></figure><p>默认情况下并行任务数与 Cpu 核心数相同, 所以这条命令会比每个 Cpu 两个任务的耗时多一倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ time parallel -N0 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m3.478s</span><br><span class="line">user    0m0.656s</span><br><span class="line">sys 0m1.344s</span><br><span class="line"></span><br><span class="line"># 每个 Cpu 两个任务</span><br><span class="line">$ time parallel -N0 --jobs 200% sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m2.659s</span><br><span class="line">user    0m0.734s</span><br><span class="line">sys 0m1.423s</span><br></pre></td></tr></table></figure><p>使用 <code>--jobs 0</code> 表示执行尽可能多的并行任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ time parallel -N0 --jobs 0 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m2.135s</span><br><span class="line">user    0m0.651s</span><br><span class="line">sys 0m1.477s</span><br></pre></td></tr></table></figure><p>除了基于 Cpu 使用率之外，也可以基于 Cpu 数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ time parallel --use-cpus-instead-of-cores -N0 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    1m5.499s</span><br><span class="line">user    0m0.950s</span><br><span class="line">sys 0m1.897s</span><br></pre></td></tr></table></figure><ol start="14"><li>交互</li></ol><p>通过使用 <code>--interactive</code> 在一个任务执行之前让用户决定是否执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --interactive echo ::: 1 2 3</span><br><span class="line">echo 1 ?...y</span><br><span class="line">echo 2 ?...y</span><br><span class="line">echo 3 ?...y</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><ol start="15"><li>耗时</li></ol><p>当 job 有大量的 IO 操作时，为避免“惊群效应”，可使用 <code>--delay</code> 参数指定各个 job 开始的时间间隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --delay 2.5 echo Starting &#123;&#125;\;date ::: 1 2 3</span><br><span class="line">Starting 1</span><br><span class="line">Tue Apr 17 15:21:41 CST 2018</span><br><span class="line">Starting 2</span><br><span class="line">Tue Apr 17 15:21:44 CST 2018</span><br><span class="line">Starting 3</span><br><span class="line">Tue Apr 17 15:21:46 CST 2018</span><br></pre></td></tr></table></figure><p>若已知任务超过一定时间未反应则为失败则可以通过 <code>--timeout</code> 指定等待时间避免无谓的等待。</p><p>GNU Parallel 能计算所有任务运行时间的中位数，因此可以指定时间为中位数的倍数关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --timeout 4.1 sleep &#123;&#125;\; echo &#123;&#125; ::: 2 4 6 8</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">$ parallel --timeout 200% sleep &#123;&#125;\; echo &#123;&#125; ::: 2.1 2.2 3 7 2.3</span><br><span class="line">2.1</span><br><span class="line">2.2</span><br><span class="line">2.3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><ol start="16"><li>显示任务进度信息</li></ol><p>GNU Parallel 有多种方式可用来动态的显示任务进度信息，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --eta sleep ::: 1 3 2 2 1 3 3 2 1</span><br><span class="line">$ parallel --progress sleep ::: 1 3 2 2 1 3 3 2 1</span><br><span class="line">$ seq 1000 | parallel -j10 --bar &#39;(echo -n &#123;&#125;;sleep 0.1)&#39;  2&gt; &gt;(zenity --progress --auto-kill --auto-close)</span><br></pre></td></tr></table></figure><p>使用 <code>--joblog</code> 参数能够生成各个任务的日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --joblog &#x2F;tmp&#x2F;log exit  ::: 1 2 3 0</span><br><span class="line">$ cat &#x2F;tmp&#x2F;log </span><br><span class="line">Seq Host    Starttime   JobRuntime  Send    Receive Exitval Signal  Command</span><br><span class="line">1   :   1523950890.344       0.018  0   0   1   0   exit 1</span><br><span class="line">2   :   1523950890.350       0.014  0   0   2   0   exit 2</span><br><span class="line">3   :   1523950890.357       0.006  0   0   3   0   exit 3</span><br><span class="line">4   :   1523950890.363       0.006  0   0   0   0   exit 0</span><br></pre></td></tr></table></figure><p>通过 <code>--resume-failed</code> 参数可以重新运行失败的任务。</p><p><code>--retry-failed</code> 的作用与 <code>--resume-failed</code>类似，只是 <code>--resume-failed</code> 从命令行读取失败任务，而 <code>--retry-failed</code> 则是从日志文件中读取失败任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --resume-failed --joblog &#x2F;tmp&#x2F;log exit  ::: 1 2 3 0 0 0</span><br><span class="line">$ cat &#x2F;tmp&#x2F;log</span><br><span class="line">Seq Host    Starttime   JobRuntime  Send    Receive Exitval Signal  Command</span><br><span class="line">1   :   1523950890.344       0.018  0   0   1   0   exit 1</span><br><span class="line">2   :   1523950890.350       0.014  0   0   2   0   exit 2</span><br><span class="line">3   :   1523950890.357       0.006  0   0   3   0   exit 3</span><br><span class="line">4   :   1523950890.363       0.006  0   0   0   0   exit 0</span><br><span class="line">1   :   1523951289.575       0.029  0   0   1   0   exit 1</span><br><span class="line">2   :   1523951289.580       0.025  0   0   2   0   exit 2</span><br><span class="line">3   :   1523951289.585       0.019  0   0   3   0   exit 3</span><br><span class="line">5   :   1523951289.591       0.013  0   0   0   0   exit 0</span><br><span class="line">6   :   1523951289.604       0.004  0   0   0   0   exit 0</span><br><span class="line"></span><br><span class="line">$ parallel --retry-failed --joblog &#x2F;tmp&#x2F;log</span><br><span class="line">$ cat &#x2F;tmp&#x2F;log</span><br><span class="line">Seq Host    Starttime   JobRuntime  Send    Receive Exitval Signal  Command</span><br><span class="line">1   :   1523950890.344       0.018  0   0   1   0   exit 1</span><br><span class="line">2   :   1523950890.350       0.014  0   0   2   0   exit 2</span><br><span class="line">3   :   1523950890.357       0.006  0   0   3   0   exit 3</span><br><span class="line">4   :   1523950890.363       0.006  0   0   0   0   exit 0</span><br><span class="line">1   :   1523951289.575       0.029  0   0   1   0   exit 1</span><br><span class="line">2   :   1523951289.580       0.025  0   0   2   0   exit 2</span><br><span class="line">3   :   1523951289.585       0.019  0   0   3   0   exit 3</span><br><span class="line">5   :   1523951289.591       0.013  0   0   0   0   exit 0</span><br><span class="line">6   :   1523951289.604       0.004  0   0   0   0   exit 0</span><br><span class="line">1   :   1523951445.089       0.013  0   0   1   0   exit 1</span><br><span class="line">2   :   1523951445.094       0.009  0   0   2   0   exit 2</span><br><span class="line">3   :   1523951445.102       0.007  0   0   3   0   exit 3</span><br></pre></td></tr></table></figure><ol start="17"><li>终止任务</li></ol><p>GNU Parallel 支持在某一情况下（如第一个失败或成功时，或者 20% 任务失败时）终止任务。</p><p>终止任务又有两种类型：</p><ul><li>其一为立即终止（通过 <code>--halt now</code> 指定），杀死所有正在运行的任务并停止生成新的任务。</li><li>其二为稍后终止（通过 <code>--halt soon</code> 指定），停止生成新任务并等待正在运行任务完成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -j2 --halt soon,fail&#x3D;1 echo &#123;&#125;\; exit &#123;&#125; ::: 0 0 1 2 3</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 1; exit 1</span><br><span class="line">parallel: Starting no more jobs. Waiting for 1 jobs to finish.</span><br><span class="line">2</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 2; exit 2</span><br><span class="line"></span><br><span class="line">$ parallel -j2 --halt now,fail&#x3D;1 echo &#123;&#125;\; exit &#123;&#125; ::: 0 0 1 2 3</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 1; exit 1</span><br><span class="line"></span><br><span class="line">$ parallel -j2 --halt soon,fail&#x3D;20% echo &#123;&#125;\; exit &#123;&#125; ::: 0 1 2 3 4 5 6 7 8 9</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 1; exit 1</span><br><span class="line">2</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 2; exit 2</span><br><span class="line">parallel: Starting no more jobs. Waiting for 1 jobs to finish.</span><br><span class="line">3</span><br><span class="line">parallel: This job failed:</span><br><span class="line">echo 3; exit 3</span><br><span class="line"></span><br><span class="line">$ parallel -j2 --halt now,success&#x3D;1 echo &#123;&#125;\; exit &#123;&#125; ::: 1 2 3 0 4 5 6</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">parallel: This job succeeded:</span><br><span class="line">echo 0; exit 0</span><br></pre></td></tr></table></figure><p>GNU Parallel 还支持在任务失败后重试运行 <code>--retries</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -k --retries 3 &#39;echo tried &#123;&#125; &gt;&gt;&#x2F;tmp&#x2F;runs; echo completed &#123;&#125;; exit &#123;&#125;&#39; ::: 1 2 0</span><br><span class="line">completed 1</span><br><span class="line">completed 2</span><br><span class="line">completed 0</span><br><span class="line"></span><br><span class="line">$ cat &#x2F;tmp&#x2F;runs </span><br><span class="line">tried 1</span><br><span class="line">tried 2</span><br><span class="line">tried 0</span><br><span class="line">tried 1</span><br><span class="line">tried 2</span><br><span class="line">tried 1</span><br><span class="line">tried 2</span><br></pre></td></tr></table></figure><p>关于终止信号的高级用法参考官方入门文档。</p><ol start="18"><li>资源限制</li></ol><p>GNU Parallel 能够在开始一个新的任务前检查系统的负载情况防止过载（通过 <code>--load</code> 可指定负载），同时还能检查系统是否使用了交换空间 Swap（通过 <code>--noswap</code> 限制使用 Swap）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --load 100% echo load is less than &#123;&#125; job per cpu ::: 1</span><br><span class="line">load is less than 1 job per cpu</span><br><span class="line"></span><br><span class="line">$ parallel --noswap echo the system is not swapping ::: now</span><br><span class="line">the system is not swapping now</span><br></pre></td></tr></table></figure><p>同时，对于某些占用内存较多的程序，Parallel 会检查内存只有内存满足时才启动任务（通过 <code>--memfree</code> 指定需要内存大小），而且在启动任务后内存不够 50% 时会杀掉最新开始的任务，直到这个任务完成再重新开始那些杀死的任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --memfree 1G echo will run if more than 1 GB is ::: free</span><br><span class="line">will run if more than 1 GB is free</span><br></pre></td></tr></table></figure><p>还可以通过 <code>--nice</code> 来指定任务的优先级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --nice 17 echo this is being run with nice -n ::: 17</span><br><span class="line">this is being run with nice -n 17</span><br></pre></td></tr></table></figure><ol start="19"><li>远程操作</li></ol><p>可使用 <code>-S host</code>来进行远程登陆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -S username@$SERVER1 echo running on ::: username@$SERVER1</span><br></pre></td></tr></table></figure><ol start="20"><li>文件传输</li></ol><p>GNU Parallel 文件传输使用的是 Rsync。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo This is input_file &gt; input_file</span><br><span class="line">$ parallel -S $SERVER1 --transferfile &#123;&#125; cat ::: input_file</span><br></pre></td></tr></table></figure><p>更多远程操作参见官方入门文档。</p><ol start="21"><li>–pipe</li></ol><p><code>--pipe</code> 参数使得我们可以将输入（stdin）分为多块（block），然后分配给多个任务多个 Cpu 以达到负载均衡，最后的结果顺序与原始顺序一致。</p><p>使用 <code>--block</code> 参数可以指定每块的大小，默认为 1M。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ perl -e &#39;for(1..1000000)&#123;print &quot;$_\n&quot;&#125;&#39; &gt; num1000000</span><br><span class="line">$ cat num1000000 | parallel --pipe wc</span><br><span class="line"> 165668  165668 1048571</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line">  85352   85352  597465</span><br></pre></td></tr></table></figure><p>如果不关心结果顺序，只想要快速的得到结果，可使用 <code>--round-robin</code> 参数。</p><p>没有这个参数时每块文件都会启动一个命令，使用这个参数后会将这些文件块分配给 job 数任务（通过 <code>--jobs</code> 进行指定）。若想分配更为均匀还可同时指定 <code>--block</code> 参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat num1000000 | parallel --pipe -j4 --round-robin wc</span><br><span class="line"> 299592  299592 2097144</span><br><span class="line"> 315464  315464 2097143</span><br><span class="line"> 149796  149796 1048572</span><br><span class="line"> 235148  235148 1646037</span><br><span class="line"></span><br><span class="line">$ cat num1000000 | parallel --pipe -j4 --block 2M --round-robin wc</span><br><span class="line"> 299593  299593 2097151</span><br><span class="line"> 315465  315465 2097150</span><br><span class="line"> 299593  299593 2097151</span><br><span class="line">  85349   85349  597444</span><br></pre></td></tr></table></figure><h3 id="parallel-使用实例">Parallel 使用实例</h3><p>下面这些实际的使用 Parallel 的例子可能会更容易理解一些。</p><ul><li>使用 Parallel 来进行 JPEG 压缩</li></ul><p>下面是一个普通的 <code>find</code> 命令，用来找出当前目录中的所有 .jpg 文件，然后通过 MozJPEG 包中提供的图像压缩工具 <code>cjpeg</code> 对其进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -name &quot;*.jpg&quot; -exec cjpeg -outfile LoRes&#x2F;&#123;&#125; &#123;&#125; &#39;;&#39;</span><br></pre></td></tr></table></figure><p>总共耗时 0m44.114s。从 top 运行结果可以看到，虽然有 8 个核可用，但实际只有单个线程在用单个核。</p><p><a href="https://img.linux.net.cn/data/attachment/album/201712/22/223442u13nq87a61an9z9q.png" target="_blank" rel="noopener">https://img.linux.net.cn/data/attachment/album/201712/22/223442u13nq87a61an9z9q.png</a></p><p>下面用 Parallel 来运行相同的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -name &quot;*.jpg&quot; | parallel cjpeg -outfile LoRes&#x2F;&#123;&#125; &#123;&#125;</span><br></pre></td></tr></table></figure><p>这次压缩所有图像的时间缩减到了 0m10.814s。从 top 运行结果可以看到，所有 CPU 核都满负荷运行，有 8 个线程对应使用 8 个 CPU 核。</p><p><a href="https://img.linux.net.cn/data/attachment/album/201712/22/223519h7n30u47omdqhzmu.png" target="_blank" rel="noopener">https://img.linux.net.cn/data/attachment/album/201712/22/223519h7n30u47omdqhzmu.png</a></p><h3 id="参考文档">参考文档</h3><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a><br><a href="http://t.cn/E6KnjtP" target="_blank" rel="noopener">http://t.cn/E6KnjtP</a><br><a href="http://t.cn/E6KB5Rr" target="_blank" rel="noopener">http://t.cn/E6KB5Rr</a><br><a href="http://t.cn/E69yv3g" target="_blank" rel="noopener">http://t.cn/E69yv3g</a><br><a href="http://t.cn/Rm9X2WC" target="_blank" rel="noopener">http://t.cn/Rm9X2WC</a><br><a href="http://t.cn/E6Wr74r" target="_blank" rel="noopener">http://t.cn/E6Wr74r</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Bash&lt;/code&gt; 命令通常单线程运行，这意味着所有的处理工作只在单个 CPU 上执行。随着 CPU 规模的扩大以及核心数目的增加，这意味着只有一小部分的 CPU 资源用于处理任务，这样就造成了很大的资源浪费。 这种情况在进行多媒体转换（比如：图片和视频转换）以及数据压缩中经常遇到。&lt;/p&gt;
&lt;p&gt;本文我们将介绍如何使用 GNU Parallel 程序在所有 CPU 核上并行地执行计算任务。&lt;/p&gt;
&lt;h3 id=&quot;Parallel-介绍&quot;&gt;Parallel 介绍&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;GNU Parallel 是一种通用的并行化程序，可以在同一台机器上或在您具有 SSH 访问权限的多台机器上轻松并行运行作业。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果要在 4 个 CPU 上运行 32 个不同的作业，并行化的一种直接方法是在每个 CPU 上运行8个作业。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://upload-images.jianshu.io/upload_images/27460-5b784effa2396844.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://upload-images.jianshu.io/upload_images/27460-5b784effa2396844.png&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GNU Parallel 会在完成后生成一个新进程，并保持 CPU 处于活动状态，从而节省时间。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://upload-images.jianshu.io/upload_images/27460-2901afa31279f8ff.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://upload-images.jianshu.io/upload_images/27460-2901afa31279f8ff.png&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Parallel-安装&quot;&gt;Parallel 安装&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过包安装&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;CentOS / RHEL&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ yum install parallel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu / Debian&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt install parallel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;通过脚本安装&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ (wget -O - pi.dk&amp;#x2F;3 || curl pi.dk&amp;#x2F;3&amp;#x2F;) | bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Parallel" scheme="https://www.hi-linux.com/tags/Parallel/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 5 期 )</title>
    <link href="https://www.hi-linux.com/posts/27183.html"/>
    <id>https://www.hi-linux.com/posts/27183.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.398Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019" target="_blank" rel="noopener">微软宣布 SQL Server 2019 免费支持 Java</a></p><p>近日，微软宣布SQL Server 2019 将免费支持 Java。从新发布的 SQL Server 2019 社区技术预览(CTP) 3.2 开始，包括 Azul System 的 Zulu，可以直接嵌入到 SQL Server 中使用 Java 的所有场景（ PolyBase、Apache SPark、Java 可扩展性等等）。除了为 SQL Server 支付的费用外，不用其他任何成本。</p><p>链接：<a href="https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019" target="_blank" rel="noopener">https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019</a></p><p><img src="https://cloudblogs.microsoft.com/uploads/prod/sites/32/2019/07/SQL-Server-loves-Java-white.png" alt=""></p><p>2、<a href="https://www.oschina.net/news/108643/github-account-reactivation-request-form" target="_blank" rel="noopener">GitHub 被爆开始实名制，以便于执行美国贸易制裁</a></p><p>从上周开始，GitHub 封禁部分国家、地区开发者账号的新闻持续发酵。从克里米亚地区的俄罗斯籍开发者到全部伊朗境内开发者再到定居芬兰的伊朗籍开发者，统统遭遇了账号被封无法创建私有库并且已经创建的私有库遭到关闭，且并未得到提前通知，没有给出任何缓冲备份时间。</p><p>有消息指出 “GitHub 被曝按过往登录 IP 址判定用户的国别来执行美国贸易制裁，即使只逗留，而 Account Reactivation Request Form 要求照片身份证副本（a copy of your photo identification (ID)）、自拍（a selfie）和身份号（the ID number），故 GitHub 正渐行实名制。”</p><p>链接：<a href="https://www.oschina.net/news/108643/github-account-reactivation-request-form" target="_blank" rel="noopener">https://www.oschina.net/news/108643/github-account-reactivation-request-form</a></p><p><img src="https://i.loli.net/2019/07/31/5d40f0a8c9fee14930.png" alt=""></p><p>3、<a href="https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released" target="_blank" rel="noopener">GitLab 再次发布安全补丁，受影响涉及版本 12.1.2、12.0.4 和 11.11.7</a></p><p>GitLab 再次发布了全系的安全更新补丁，这些安全问题影响 GitLab CE/EE 10.6 以及以后的版本。版本涉及 12.1.2、12.0.4 和 11.11.7，包括社区版和企业版。这些版本包含重要的安全更新，强烈建议所有 GitLab 安装立即更新！</p><p>链接：<a href="https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released" target="_blank" rel="noopener">https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released</a></p><p>4、<a href="https://www.cnbeta.com/articles/tech/873537.htm" target="_blank" rel="noopener">Ubuntu 18.04 和 16.04 LTS 迎来 Linux 内核实时补丁， 修复 5 个安全漏洞</a></p><p>Canonical 为长期支持（LTS）的 Ubuntu 18.04 和 16.04 操作系统提供了最新的 Linux 内核安全更新，Bionic Beaver 和 Xenial Xerus 用户可借助实时补丁服务（Livepatch Service）实施免重启的操作系统内核更新。本次实时补丁主要修复了五个安全问题，比如 CVE-2019-11815 竞争条件漏洞。其可能导致 Linux 内核的可靠数据包套接字（RDS）协议被攻击者利用，导致系统崩溃或执行任意代码。</p><p>链接：<a href="https://www.cnbeta.com/articles/tech/873537.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/tech/873537.htm</a></p><p><img src="https://i.loli.net/2019/07/31/5d413bb393e0497615.jpg" alt=""></p><p>5、<a href="https://www.oschina.net/news/108657/chrome-76-released" target="_blank" rel="noopener">Chrome 76 稳定版发布，默认屏蔽 Flash，禁用了隐身模式检测等</a></p><p>Google 发布了 Chrome 76，默认屏蔽 Flash，禁用了隐身模式检测。网站不再能利用脚本检测用户是否使用了隐身模式。其它功能还有简化 Progressive Web Apps 的安装、支持暗黑模式、更多开发者工具功能等等。</p><p>链接：<a href="https://www.oschina.net/news/108657/chrome-76-released" target="_blank" rel="noopener">https://www.oschina.net/news/108657/chrome-76-released</a></p><p><img src="https://i.loli.net/2019/07/31/5d413d1c5886c15984.jpg" alt=""></p><p>6、<a href="https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/" target="_blank" rel="noopener">Docker 深化与 K8s 的集成</a></p><p>Docker 宣布推出 Docker Enterprise v3.0，新版本进一步加强了应用程序平台 Docker 和容器编排标准 Kubernetes 的联系。</p><p>根据 Docker 官方博客，新版本中针对 Kubernetes 中集成的安全性和稳定性的改进，该更新还解决了企业用户将容器转移到生产中常遇到的软件错误。</p><p>链接：<a href="https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/" target="_blank" rel="noopener">https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/</a></p><p><img src="https://i.loli.net/2019/07/31/5d414134d085458878.png" alt=""></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://github.com/18601949127/DiDiCallCar" target="_blank" rel="noopener">DiDiCallCar</a></p><p>一个仿滴滴打车的 Android 出行项目，主要针对滴滴等出行平台一直饱受质疑的 “人车不符” 问题，以及当前越发火热的国际化和出海战略。</p><p>项目地址: <a href="https://github.com/18601949127/DiDiCallCar" target="_blank" rel="noopener">https://github.com/18601949127/DiDiCallCar</a></p><p><img src="https://i.loli.net/2019/07/31/5d414d9b5b0fa61934.gif" alt=""></p><p>2、<a href="https://github.com/noplay/python-mysql-replication" target="_blank" rel="noopener">Python-MySQL-Replication</a></p><p>Python-MySQL-Replication 是基于 Python 实现的 MySQL 复制协议工具。我们可以用它来解析 Binlog 获取日志的 Insert，Update，Delete 等事件 ，并基于此做其他业务需求。比如：数据更改时失效缓存，监听 DML 事件通知下游业务方做对应处理。</p><p>项目地址: <a href="https://github.com/noplay/python-mysql-replication" target="_blank" rel="noopener">https://github.com/noplay/python-mysql-replication</a></p><p>3、<a href="https://github.com/danfengcao/binlog2sql" target="_blank" rel="noopener">Binlog2SQL</a></p><p>Binlog2SQL 是大众点评开源的一款用于解析 Binlog 的工具，Binlog2SQL 解析 Binlog 的能力就是基于上面提到的 Python-MySQL-Replication 的。</p><p>Binlog2SQL 可以从 MySQL Binlog 解析出你要的 SQL。根据不同选项，你可以得到原始SQL、回滚SQL、去除主键的 INSERT SQL 等。</p><p>项目地址: <a href="https://github.com/danfengcao/binlog2sql" target="_blank" rel="noopener">https://github.com/danfengcao/binlog2sql</a></p><p>4、<a href="https://github.com/matomo-org/matomo" target="_blank" rel="noopener">Matomo</a></p><p>Matomo 的前身是 Piwik，类似 Google Analytics，是个非常出名的开源网站统计分析程序。提供了关键字和搜索引擎、首页网址、页面标题、用户国家、提供商、操作系统、浏览器市场份额、屏幕分辨率、网站停留时间、顶级入口/出口页面、下载文件等等的分析结果。</p><p>项目地址: <a href="https://github.com/matomo-org/matomo" target="_blank" rel="noopener">https://github.com/matomo-org/matomo</a></p><p><img src="https://i.loli.net/2019/07/31/5d414df75f22f24767.jpg" alt=""></p><p>5、<a href="https://github.com/elsesiy/qrgo" target="_blank" rel="noopener">qrgo</a></p><p>一个用 Go 语言开发的在命令行生成二维码的工具。</p><p>项目地址: <a href="https://github.com/elsesiy/qrgo" target="_blank" rel="noopener">https://github.com/elsesiy/qrgo</a></p><p>6、<a href="https://github.com/talos-systems/talos" target="_blank" rel="noopener">Talos</a></p><p>Talos 是一款专门用于部署 Kubernetes 的操作系统。相对于 CoreOS、RancherOS 或者 LinuxKit 这些容器操作系统，Talos 更为精简。</p><p>项目地址: <a href="https://github.com/talos-systems/talos" target="_blank" rel="noopener">https://github.com/talos-systems/talos</a></p><p><img src="https://i.loli.net/2019/07/31/5d414eafe22db50582.jpg" alt=""></p><p>7、<a href="https://github.com/Ladicle/kubectl-bindrole" target="_blank" rel="noopener">kubectl-bindrole</a></p><p>kubectl-bindrole 是一款 Kubectl 插件，可用于帮助查找 Kubernetes 集群中指定 SA/Group/User 的权限等信息。</p><p>项目地址: <a href="https://github.com/Ladicle/kubectl-bindrole" target="_blank" rel="noopener">https://github.com/Ladicle/kubectl-bindrole</a></p><p><img src="https://i.loli.net/2019/07/31/5d414f1e457da81308.jpg" alt=""></p><p>8、<a href="https://www.katacoda.com" target="_blank" rel="noopener">Katacoda</a></p><p>Katacoda 是一个在线学习平台，在 Web 上提供学习需要的服务器终端，里面包含学习所需的环境。Katacoda 包含了很多当下热门的平台，比如：Docker、Kubernetes、Prometheus、Service Meshes 等。</p><p>项目地址: <a href="https://www.katacoda.com" target="_blank" rel="noopener">https://www.katacoda.com</a></p><p><img src="https://i.loli.net/2019/07/31/5d414f63f1cba80498.jpg" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北</a></p><p>使用中文文档排版时,有许多细节是需要通过统一来实现美感，比如：中英文的空格、标点的使用、专有名词的书写等等。达成最起码的排版统一可以让团队更像一支团队，本文档将介绍一些中文文档排版时的规范和技巧。</p><p>链接：<a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">https://github.com/sparanoid/chinese-copywriting-guidelines</a></p><p><img src="https://i.loli.net/2019/07/23/5d367afed0d7d68854.jpg" alt=""></p><p>2、<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python-100-Days</a></p><p>GitHub 上非常热门的一个 Python 学习的项目。在这个项目中，作者详细给出了一个 100 天的 Python 学习计划，包括每天需要掌握的内容、学习周期、资料库等。</p><p>从怎么安装 Python 到如何使用 Django 开发一个完整项目，共 100 天，11 个阶段，每完成一个阶段，都能让你成就感爆棚！</p><p>链接：<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">https://github.com/jackfrued/Python-100-Days</a></p><p><img src="https://i.loli.net/2019/07/24/5d380876973b171503.jpg" alt=""></p><p>3、<a href="https://my.oschina.net/u/1000241/blog/3080057" target="_blank" rel="noopener">从技术平台到 aPaaS 平台</a></p><p>本文将介绍 aPaaS 平台的基本概念和使用场景，以及和 PaaS 平台的区别。</p><p>链接：<a href="https://my.oschina.net/u/1000241/blog/3080057" target="_blank" rel="noopener">https://my.oschina.net/u/1000241/blog/3080057</a></p><p><img src="https://i.loli.net/2019/07/31/5d4137e6a9c5d51924.jpg" alt=""></p><h2 id="每周观点">每周观点</h2><p>1、在你生命力最旺盛的时候，你要想清楚几件事，第一件事你要想清楚说我这辈子最喜欢的工作是什么，就我热爱什么东西，这个是最关键的事情；第二要让自己成为一个专业的人；第三你愿意用未来的二十年时间去完成，这件你喜欢的工作和你专业的事情。—— 吴晓波</p><p>2、奈何一个人随着年龄增长，梦想便不复轻盈；他开始用双手掂量生活，更看重果实而非花朵。—— 威廉.巴特勒.叶芝「凯尔特的薄暮」</p><p>3、越是试着忘记，越是记得深刻。—— 宫崎骏「天空之城」</p><p>4、当你的才华还撑不起你的野心的时候，你就应该静下心来学习；当你的能力还驾驭不了你的目标时，就应该沉下心来历练；梦想，不是浮躁，而是沉淀和积累。只有拼出来的美丽，没有等出来的辉煌。机会永远是留给最渴望的那个人，学会与内心深处的你对话，问问自己，想要怎样的人生，静心学习，耐心沉淀，送给自己，共勉。—— 莫言</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软宣布 SQL Server 2019 免费支持 Java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，微软宣布SQL Server 2019 将免费支持 Java。从新发布的 SQL Server 2019 社区技术预览(CTP) 3.2 开始，包括 Azul System 的 Zulu，可以直接嵌入到 SQL Server 中使用 Java 的所有场景（ PolyBase、Apache SPark、Java 可扩展性等等）。除了为 SQL Server 支付的费用外，不用其他任何成本。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108534/free-supported-java-in-sql-server-2019&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloudblogs.microsoft.com/uploads/prod/sites/32/2019/07/SQL-Server-loves-Java-white.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.oschina.net/news/108643/github-account-reactivation-request-form&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 被爆开始实名制，以便于执行美国贸易制裁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从上周开始，GitHub 封禁部分国家、地区开发者账号的新闻持续发酵。从克里米亚地区的俄罗斯籍开发者到全部伊朗境内开发者再到定居芬兰的伊朗籍开发者，统统遭遇了账号被封无法创建私有库并且已经创建的私有库遭到关闭，且并未得到提前通知，没有给出任何缓冲备份时间。&lt;/p&gt;
&lt;p&gt;有消息指出 “GitHub 被曝按过往登录 IP 址判定用户的国别来执行美国贸易制裁，即使只逗留，而 Account Reactivation Request Form 要求照片身份证副本（a copy of your photo identification (ID)）、自拍（a selfie）和身份号（the ID number），故 GitHub 正渐行实名制。”&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108643/github-account-reactivation-request-form&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108643/github-account-reactivation-request-form&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/31/5d40f0a8c9fee14930.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitLab 再次发布安全补丁，受影响涉及版本 12.1.2、12.0.4 和 11.11.7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitLab 再次发布了全系的安全更新补丁，这些安全问题影响 GitLab CE/EE 10.6 以及以后的版本。版本涉及 12.1.2、12.0.4 和 11.11.7，包括社区版和企业版。这些版本包含重要的安全更新，强烈建议所有 GitLab 安装立即更新！&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108624/security-release-gitlab-12-dot-1-dot-2-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.cnbeta.com/articles/tech/873537.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu 18.04 和 16.04 LTS 迎来 Linux 内核实时补丁， 修复 5 个安全漏洞&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Canonical 为长期支持（LTS）的 Ubuntu 18.04 和 16.04 操作系统提供了最新的 Linux 内核安全更新，Bionic Beaver 和 Xenial Xerus 用户可借助实时补丁服务（Livepatch Service）实施免重启的操作系统内核更新。本次实时补丁主要修复了五个安全问题，比如 CVE-2019-11815 竞争条件漏洞。其可能导致 Linux 内核的可靠数据包套接字（RDS）协议被攻击者利用，导致系统崩溃或执行任意代码。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/tech/873537.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/tech/873537.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/31/5d413bb393e0497615.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.oschina.net/news/108657/chrome-76-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome 76 稳定版发布，默认屏蔽 Flash，禁用了隐身模式检测等&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google 发布了 Chrome 76，默认屏蔽 Flash，禁用了隐身模式检测。网站不再能利用脚本检测用户是否使用了隐身模式。其它功能还有简化 Progressive Web Apps 的安装、支持暗黑模式、更多开发者工具功能等等。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108657/chrome-76-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108657/chrome-76-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/31/5d413d1c5886c15984.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker 深化与 K8s 的集成&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker 宣布推出 Docker Enterprise v3.0，新版本进一步加强了应用程序平台 Docker 和容器编排标准 Kubernetes 的联系。&lt;/p&gt;
&lt;p&gt;根据 Docker 官方博客，新版本中针对 Kubernetes 中集成的安全性和稳定性的改进，该更新还解决了企业用户将容器转移到生产中常遇到的软件错误。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.docker.com/2019/07/announcing-docker-enterprise-3-0-ga/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/31/5d414134d085458878.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 7 期 )</title>
    <link href="https://www.hi-linux.com/posts/43532.html"/>
    <id>https://www.hi-linux.com/posts/43532.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.399Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.cnbeta.com/articles/tech/876919.htm" target="_blank" rel="noopener">华为正式发布自研操作系统鸿蒙 HarmonyOS</a></p><p>华为消费者业务首届的开发者大会上，华为公布了自研操作系统 “鸿蒙”。鸿蒙 OS 的英文是 “HarmonyOS”，亦可理解为和谐系统。</p><p>华为公司消费者业务 CEO 余承东表示：鸿蒙是全世界第一个面向全场景微内核的分布式 OS，鸿蒙 OS 将向全球开发者开源，并推动成立开源基金会，建立开源社区。</p><p>据华为方面介绍，将在智慧屏产品中率先使用鸿蒙 OS 1.0。未来三年，除完善相关技术外，鸿蒙 OS 会逐步应用在可穿戴、智慧屏、车机等更多智能设备中。</p><p>链接：<a href="https://www.cnbeta.com/articles/tech/876919.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/tech/876919.htm</a></p><p><img src="https://i.loli.net/2019/08/09/68uqFnrfUB9gIoz.jpg" alt=""></p><p>2、<a href="https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation" target="_blank" rel="noopener">Red Hat 加入 RISC-V 基金会</a></p><p>Red Hat 加入了 RISC-V 基金会，以帮助开发开源处理器 ISA。目前 RISC-V 成员已有谷歌、NVIDIA、高通(Qualcomm)、SiFive、WesternDigital、IBM 和三星等。</p><p>Red Hat 一直在积极推广 RISC-V 作为一种开源处理器指令集体系结构，Red Hat 开发人员已经在 Fedora 的 RISC-V 支持方面提供了帮助，该公司正通过加入 RISC-V 基金会，来提供更多的帮助并是实现他们的承诺。</p><p>链接：<a href="https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation" target="_blank" rel="noopener">https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation</a></p><p><img src="https://i.loli.net/2019/08/09/1lsCXmES7ZzBgu6.jpg" alt=""></p><p>3、<a href="https://www.oschina.net/news/108903/grafana-6-3-0-released" target="_blank" rel="noopener">Grafana 6.3.0 版本发布</a></p><p>Grafana 6.3.0 发布了，Grafana 是一个功能丰富的指标标准仪表板和图形编辑器，用于分析和监控 Graphite、Elasticsearch、OpenTSDB、Prometheus 和 InfluxDB。</p><p>链接：<a href="https://www.oschina.net/news/108903/grafana-6-3-0-released" target="_blank" rel="noopener">https://www.oschina.net/news/108903/grafana-6-3-0-released</a></p><p><img src="https://i.loli.net/2019/08/09/PpiodSvr6TCcKwh.png" alt=""></p><p>4、<a href="http://t.cn/AiHyJZCh" target="_blank" rel="noopener">GitHub Actions 集成 CI/CD 功能，所有开源项目可免费使用</a></p><p>近日，GitHub 官方博客发文称 Github Actions 已支持内置持续集成和交付 (CI/CD) 功能，并对所有开源项目免费！</p><p>目前该功能可以在 Beta 版本中测试使用，11 月 13 日 GitHub Actions 将在 GitHub Universe 上正式发布！</p><p>链接：<a href="http://t.cn/AiHyJZCh" target="_blank" rel="noopener">http://t.cn/AiHyJZCh</a></p><p><img src="https://i.loli.net/2019/08/13/yMQgZnHczPAOqpe.png" alt=""></p><p>5、<a href="http://t.cn/AiHyKWDI" target="_blank" rel="noopener">VS Code 1.37 发布，多个图标迎来全新设计</a></p><p>近日，微软发布了 Visual Studio Code 1.37 版本。多个图标迎来全新设计，此次图标更新包含了侧边栏、文件管理器、搜索、调试等区域。</p><p>链接：<a href="http://t.cn/AiHyKWDI" target="_blank" rel="noopener">http://t.cn/AiHyKWDI</a></p><p><img src="https://i.loli.net/2019/08/13/kQgqbzBd7m5XE6G.gif" alt=""></p><p>6、<a href="http://t.cn/AiHy0fzc" target="_blank" rel="noopener">Chrome 爆新特性，可在多平台上共享剪贴板</a></p><p>根据 softpedia 报道，Chrome 添加了一个新功能。不管浏览器运行在哪个平台上，允许用户在一个设备上复制内容，并将其粘贴到另一个设备上。该功能也就是一个共享剪贴板，该剪贴板将可以在 Windows、Linux、MacOS 和 Android 上的 Google Chrome 中使用。</p><p>链接：<a href="http://t.cn/AiHy0fzc" target="_blank" rel="noopener">http://t.cn/AiHy0fzc</a></p><p><img src="https://i.loli.net/2019/08/13/GKQZasf5vRInX94.png" alt=""></p><p>7、<a href="https://news.mydrivers.com/1/641/641041.htm" target="_blank" rel="noopener">全球百大流量网站榜出炉：谷歌第一，百度第四</a></p><p>通过来自 SimilarWeb 的数据，Visualcapitalist 用图标地形式列出了全球互联网上 100 个流量规模最大的网站，其中谷歌、Youtube、Facebook、百度、维基百科、Twitter、雅虎、P站、Instagram、x站排名前十。</p><p>链接：<a href="http://t.cn/AiHabsGl" target="_blank" rel="noopener">http://t.cn/AiHabsGl</a></p><p><img src="https://i.loli.net/2019/08/15/zKEn3bTc6fRDdvQ.jpg" alt=""></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://github.com/luong-komorebi/Awesome-Linux-Software" target="_blank" rel="noopener">Awesome-Linux-Software</a></p><p>该项目收集整理了一批优质的开源 Linux 软件，包含电子书工具、命令行工具、文件管理器等多个分类。</p><p>项目地址: <a href="https://github.com/luong-komorebi/Awesome-Linux-Software" target="_blank" rel="noopener">https://github.com/luong-komorebi/Awesome-Linux-Software</a></p><p><img src="https://i.loli.net/2019/08/15/6VAuw4Tl7ML1GeK.jpg" alt=""></p><p>2、<a href="https://github.com/hanchuanchuan/goInception" target="_blank" rel="noopener">goInception</a></p><p>一个集审核、执行、备份及生成回滚语句于一身的 MySQL 运维工具。</p><p>项目地址: <a href="https://github.com/hanchuanchuan/goInception" target="_blank" rel="noopener">https://github.com/hanchuanchuan/goInception</a></p><p><img src="https://i.loli.net/2019/08/15/JRICdAy4QjM5hVk.jpg" alt=""></p><p>3、<a href="https://github.com/sindresorhus/refined-github" target="_blank" rel="noopener">Refined GitHub</a></p><p>Refined GitHub 是一个简化 GitHub 界面并增加很多实用功能的浏览器扩展程序。支持 Chrome、Firefox 与 Opera。</p><p>项目地址: <a href="https://github.com/sindresorhus/refined-github" target="_blank" rel="noopener">https://github.com/sindresorhus/refined-github</a></p><p><img src="https://i.loli.net/2019/07/22/5d3561a2713da78142.png" alt=""></p><p>4、<a href="https://github.com/huashengdun/webssh" target="_blank" rel="noopener">WebSSH</a></p><p>一个开源的 Python 编写的 Web 端 SSH 工具，可以通过浏览器进行远程服务器 SSH 登录。</p><p>项目地址: <a href="https://github.com/huashengdun/webssh" target="_blank" rel="noopener">https://github.com/huashengdun/webssh</a></p><p><img src="https://i.loli.net/2019/08/15/EdksjaNlyIG7unw.png" alt=""></p><p>5、<a href="https://github.com/checkly/puppeteer-recorder" target="_blank" rel="noopener">Puppeteer Recorder</a></p><p>Puppeteer 是一个 Node 库，它提供了一个高级 API 来控制 DevTools 协议上的 Chrome 或 Chromium，常用于爬虫、自动化测试等，你在浏览器手动完成的大多数事情都可以使用它来完成。</p><p>无论是爬虫还是自动化测试，你都要先写 Puppeteer 脚本，而 Puppeteer Recorder 是 一个 Chrome 扩展程序，可录制你的浏览器交互操作并生成 Puppeteer 脚本。</p><p>项目地址: <a href="https://github.com/checkly/puppeteer-recorder" target="_blank" rel="noopener">https://github.com/checkly/puppeteer-recorder</a></p><p><img src="https://i.loli.net/2019/07/22/5d35638927ba854572.png" alt=""></p><p>6、<a href="https://github.com/ksky521/nodeppt" target="_blank" rel="noopener">NodePPT</a></p><p>一个基于 NodeJS、HTML、CSS 等技术，将 Markdown 文档转成幻灯片。在浏览器上实现类似 Power Point / KeyNote 效果的一个工具。</p><p>项目地址: <a href="https://github.com/ksky521/nodeppt" target="_blank" rel="noopener">https://github.com/ksky521/nodeppt</a></p><p><img src="https://i.loli.net/2019/07/22/5d3567df109a010849.png" alt=""></p><p>7、<a href="https://github.com/wagoodman/dive" target="_blank" rel="noopener">dive</a></p><p>这是一款用于分析 Docker 镜像的镜像层内容以及探索缩小 Docker 镜像大小方法的工具。</p><p>项目地址: <a href="https://github.com/wagoodman/dive" target="_blank" rel="noopener">https://github.com/wagoodman/dive</a></p><p><img src="https://i.loli.net/2019/07/22/5d356ace3b9b839934.gif" alt=""></p><p>8、<a href="https://github.com/vicanso/diving" target="_blank" rel="noopener">diving</a></p><p>一个基于 Dive 分析 Docker 镜像，并可以在 Web 页面上方便地浏览镜像信息。比如镜像每层的变动（增加、修改、删除等）、用户层数据大小等信息。</p><p>项目地址: <a href="https://github.com/vicanso/diving" target="_blank" rel="noopener">https://github.com/vicanso/diving</a></p><p><img src="https://i.loli.net/2019/07/22/5d35694d6a88f96238.gif" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="http://t.cn/AiHylYV7" target="_blank" rel="noopener">Kubernetes 容器运行时演进</a></p><p>Kubernetes 已经成为容器编排调度领域的事实标准，其优良的架构不仅保证了丰富的容器编排调度功能，同时也提供了各个层次的扩展接口以满足用户的定制化需求。其中，容器运行时作为 Kubernetes 管理和运行容器的关键组件，当然也提供了简便易用的扩展接口，也就是 CRI（Container Runtime Interface）。本文将介绍 CRI 的由来、演进以及未来展望，主要内容分为四个部分：Kubernetes架构简介、容器运行时接口的基本原理、容器运行时的演进以及未来的展望。</p><p>链接：<a href="http://t.cn/AiHylYV7" target="_blank" rel="noopener">http://t.cn/AiHylYV7</a></p><p>2、<a href="http://t.cn/AiHXPPm0" target="_blank" rel="noopener">Kubernetes 网络疑难杂症排查分享</a></p><p>本文分享几个比较复杂的 Kubernetes 网络方面的问题排查和解决思路，深入分析并展开相关知识，信息量巨大。当完全看懂后我相信你的功底会更加扎实，解决问题的能力会大大提升。</p><p>链接：<a href="http://t.cn/AiHXPPm0" target="_blank" rel="noopener">http://t.cn/AiHXPPm0</a></p><p>3、<a href="http://t.cn/AiHXznn0" target="_blank" rel="noopener">从大数据的角度来谈谈运维监控这件事儿</a></p><p>做运维的人对监控这件事儿都太熟悉了，但是对于监控这么一件老生常谈的事儿，本文将从大数据的角度来看看有什么新的发现。</p><p>链接：<a href="http://t.cn/AiHXznn0" target="_blank" rel="noopener">http://t.cn/AiHXznn0</a></p><h2 id="每周观点">每周观点</h2><p>1、人生的美妙之处在于迷上一样东西。人生苦短，少做些虚无缥缈的事。 —— 刘慈欣「三体」</p><p>2、有目标者，意志竟成。—— 弗兰克尔</p><p>3、竞争总是件好事，它促使我们竭尽全力。垄断使人自满，满足于做平庸之辈。—— 南希·皮尔西</p><p>4、人生的磨难是很多的，所以我们不可对于每一件轻微的伤害都过于敏感。在生活磨难面前，精神上的坚强和无动于衷是我们抵抗罪恶和人生意外的最好武器。—— 洛克</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnbeta.com/articles/tech/876919.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;华为正式发布自研操作系统鸿蒙 HarmonyOS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为消费者业务首届的开发者大会上，华为公布了自研操作系统 “鸿蒙”。鸿蒙 OS 的英文是 “HarmonyOS”，亦可理解为和谐系统。&lt;/p&gt;
&lt;p&gt;华为公司消费者业务 CEO 余承东表示：鸿蒙是全世界第一个面向全场景微内核的分布式 OS，鸿蒙 OS 将向全球开发者开源，并推动成立开源基金会，建立开源社区。&lt;/p&gt;
&lt;p&gt;据华为方面介绍，将在智慧屏产品中率先使用鸿蒙 OS 1.0。未来三年，除完善相关技术外，鸿蒙 OS 会逐步应用在可穿戴、智慧屏、车机等更多智能设备中。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.cnbeta.com/articles/tech/876919.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnbeta.com/articles/tech/876919.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/09/68uqFnrfUB9gIoz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Red Hat 加入 RISC-V 基金会&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Red Hat 加入了 RISC-V 基金会，以帮助开发开源处理器 ISA。目前 RISC-V 成员已有谷歌、NVIDIA、高通(Qualcomm)、SiFive、WesternDigital、IBM 和三星等。&lt;/p&gt;
&lt;p&gt;Red Hat 一直在积极推广 RISC-V 作为一种开源处理器指令集体系结构，Red Hat 开发人员已经在 Fedora 的 RISC-V 支持方面提供了帮助，该公司正通过加入 RISC-V 基金会，来提供更多的帮助并是实现他们的承诺。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108910/red-hat-join-risc-v-foundation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/09/1lsCXmES7ZzBgu6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.oschina.net/news/108903/grafana-6-3-0-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Grafana 6.3.0 版本发布&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Grafana 6.3.0 发布了，Grafana 是一个功能丰富的指标标准仪表板和图形编辑器，用于分析和监控 Graphite、Elasticsearch、OpenTSDB、Prometheus 和 InfluxDB。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108903/grafana-6-3-0-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108903/grafana-6-3-0-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/09/PpiodSvr6TCcKwh.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;http://t.cn/AiHyJZCh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub Actions 集成 CI/CD 功能，所有开源项目可免费使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，GitHub 官方博客发文称 Github Actions 已支持内置持续集成和交付 (CI/CD) 功能，并对所有开源项目免费！&lt;/p&gt;
&lt;p&gt;目前该功能可以在 Beta 版本中测试使用，11 月 13 日 GitHub Actions 将在 GitHub Universe 上正式发布！&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://t.cn/AiHyJZCh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/AiHyJZCh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/yMQgZnHczPAOqpe.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;http://t.cn/AiHyKWDI&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VS Code 1.37 发布，多个图标迎来全新设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，微软发布了 Visual Studio Code 1.37 版本。多个图标迎来全新设计，此次图标更新包含了侧边栏、文件管理器、搜索、调试等区域。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://t.cn/AiHyKWDI&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/AiHyKWDI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/kQgqbzBd7m5XE6G.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;http://t.cn/AiHy0fzc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome 爆新特性，可在多平台上共享剪贴板&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据 softpedia 报道，Chrome 添加了一个新功能。不管浏览器运行在哪个平台上，允许用户在一个设备上复制内容，并将其粘贴到另一个设备上。该功能也就是一个共享剪贴板，该剪贴板将可以在 Windows、Linux、MacOS 和 Android 上的 Google Chrome 中使用。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://t.cn/AiHy0fzc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/AiHy0fzc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/GKQZasf5vRInX94.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&quot;https://news.mydrivers.com/1/641/641041.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;全球百大流量网站榜出炉：谷歌第一，百度第四&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过来自 SimilarWeb 的数据，Visualcapitalist 用图标地形式列出了全球互联网上 100 个流量规模最大的网站，其中谷歌、Youtube、Facebook、百度、维基百科、Twitter、雅虎、P站、Instagram、x站排名前十。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://t.cn/AiHabsGl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/AiHabsGl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/15/zKEn3bTc6fRDdvQ.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>使用 Mirror 协议实现 Ubuntu 访问多软件源</title>
    <link href="https://www.hi-linux.com/posts/56051.html"/>
    <id>https://www.hi-linux.com/posts/56051.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.400Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知 Ubuntu 官方软件源访问速度一直都是比较慢的，通常情况下我们为了高效的通过软件源安装软件会使用国内的镜像源。国内虽然有很多可用的镜像源，但有时某些源偶尔也会出现访问故障(比如：清华、北大等镜像源)。出现这样情况的时候通常的解决方法就是更换一个可用的镜像源，但是如果涉及的机器特别多的时候就会非常的麻烦。</p><p>难道这是一个无解的问题？当然不是，只能说你运气真好，来对了地方。你一定是上辈子拯救了银河系才有这样的好运，哈哈哈。其实 Apt 源是支持 Mirror 协议的，可以从多个镜像源中自动选择可用的一个。本文将介绍如何利用 Mirror 协议来解决类似问题。</p><h3 id="什么是-mirror-协议">什么是 Mirror 协议</h3><p>Mirror 协议的实现方法非常的简单，它通过一个 mirrors.txt 的文件对提供的多个源地址进行封装，Apt 会根据 mirror.txt 文件中自动解析并确定最合理的源地址。 以下为官方提供的  mirrors.txt 文件内容示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirror.lzu.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.cqu.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.cn99.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.yun-idc.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.njupt.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;ftp.sjtu.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.nwafu.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.sohu.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;repository&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.nju.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.shu.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="使用-mirror-协议">使用 Mirror 协议</h3><p>要使用 Mirror 协议来进行多源更新的方法其实很简单，只需将 /etc/apt/sources.list 文件中的指定的软件源地址修改为使用 Mirror 协议的地址就可以了。这里以 Ubuntu 18.04 为例：</p><p>将如下软件源地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;cn.archive.ubuntu.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>修改为以下类似即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>这里提供一个完整的使用 Mirror 协议的 Ubuntu 18.04 的软件源配置文件，有需要的同学可以直接拿去用哟~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">###### Ubuntu Main Repos</span><br><span class="line">deb mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic main restricted universe multiverse</span><br><span class="line">deb-src mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">###### Ubuntu Update Repos</span><br><span class="line">deb mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-security main restricted universe multiverse</span><br><span class="line">deb mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-updates main restricted universe multiverse</span><br><span class="line">deb mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-security main restricted universe multiverse</span><br><span class="line">deb-src mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src mirror:&#x2F;&#x2F;mirrors.ubuntu.com&#x2F;mirrors.txt bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>当使用 Mirror 协议后，执行 Apt 相关操作时会首先访问 <a href="http://mirrors.ubuntu.com/mirrors.txt" target="_blank" rel="noopener">mirrors.ubuntu.com/mirrors.txt</a> 文本中所有的可用镜像地址，得到列表后 Apt 会自动选择一个速度最快的进行下载。官方还根据所在地区不同，提供指定国家的 mirror.txt。比如：中国可以设置为 <a href="http://mirrors.ubuntu.com/CN.txt%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E9%83%BD%E6%98%AF%E5%9B%BD%E5%86%85%E7%9A%84%E9%95%9C%E5%83%8F%E6%BA%90%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E9%95%9C%E5%83%8F%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E3%80%82" target="_blank" rel="noopener">mirrors.ubuntu.com/CN.txt，这样使用的都是国内的镜像源，就可以保证镜像源的访问速度。</a></p><p>使用 Mirror 协议后由于同时存在多个可用的镜像源地址，这样就可以很好的避免某个单一镜像源临时不可用的问题。</p><h3 id="自定义-mirror-地址">自定义 Mirror 地址</h3><p>由于官方提供的 mirrors.txt 中的镜像源地址包含了很多教育站点地址，这些地址可能有时访问速度并不是很快。这时我们可以根据需要自定义 mirror.txt 这个源列表，自定义可用的源列表的方法非常的简单，只需要开启一个标准的 HTTP Server 能返回 mirror.txt 这个文本即可。</p><p>mirrors.txt 中推荐优先选阿里云、网易、华为、清华大学等比较知名的镜像源地址，比如下面这些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;repository&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.yun-idc.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.cn99.com&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.sohu.com&#x2F;ubuntu&#x2F;</span><br></pre></td></tr></table></figure><h3 id="参考文档">参考文档</h3><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="http://t.cn/ExNkmSY" target="_blank" rel="noopener">http://t.cn/ExNkmSY</a></li><li><a href="http://t.cn/ExpvuQ6" target="_blank" rel="noopener">http://t.cn/ExpvuQ6</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知 Ubuntu 官方软件源访问速度一直都是比较慢的，通常情况下我们为了高效的通过软件源安装软件会使用国内的镜像源。国内虽然有很多可用的镜像源，但有时某些源偶尔也会出现访问故障(比如：清华、北大等镜像源)。出现这样情况的时候通常的解决方法就是更换一个可用的镜像源，但是如果涉及的机器特别多的时候就会非常的麻烦。&lt;/p&gt;
&lt;p&gt;难道这是一个无解的问题？当然不是，只能说你运气真好，来对了地方。你一定是上辈子拯救了银河系才有这样的好运，哈哈哈。其实 Apt 源是支持 Mirror 协议的，可以从多个镜像源中自动选择可用的一个。本文将介绍如何利用 Mirror 协议来解决类似问题。&lt;/p&gt;
&lt;h3 id=&quot;什么是-Mirror-协议&quot;&gt;什么是 Mirror 协议&lt;/h3&gt;
&lt;p&gt;Mirror 协议的实现方法非常的简单，它通过一个 mirrors.txt 的文件对提供的多个源地址进行封装，Apt 会根据 mirror.txt 文件中自动解析并确定最合理的源地址。 以下为官方提供的  mirrors.txt 文件内容示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.aliyun.com&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirror.lzu.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.cqu.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.cn99.com&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.yun-idc.com&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.njupt.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;ftp.sjtu.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.nwafu.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.sohu.com&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.huaweicloud.com&amp;#x2F;repository&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.ustc.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.nju.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.tuna.tsinghua.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;mirrors.shu.edu.cn&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;archive.ubuntu.com&amp;#x2F;ubuntu&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Ubuntu" scheme="https://www.hi-linux.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>使用 Sealos 在 3 分钟内快速部署一个生产级别的 Kubernetes 高可用集群</title>
    <link href="https://www.hi-linux.com/posts/18971.html"/>
    <id>https://www.hi-linux.com/posts/18971.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.401Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>前段时间，我们在 ​「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247488666&amp;idx=1&amp;sn=de46a87cf59f8564ad75337b7c0cf7f6&amp;chksm=eac535b3ddb2bca5de2a923ec6cfa427e87f0135b31193efd1b904dff4c7b473f1dc9af82903&amp;token=212816651&amp;lang=zh_CN#rd" target="_blank" rel="noopener">使用 Kind 在 5 分钟内快速部署一个 Kubernetes 高可用集群</a>」一文中介绍了如何使用 <code>Kind</code> 这个开箱即可快速部署 <code>Kubernetes</code> 高可用集群的神器，相信不少同学用上这个神器后大大的降低了 <code>Kubernetes</code> 集群的部署难度和提高了 <code>Kubernetes</code> 集群的部署速度。不过有一点比较遗憾的是 <code>Kind</code> 当前仅仅支持在本地快速构建一个开发或者测试环境，目前暂时还是不支持在生产环境中部署 <code>Kubernetes</code> 高可用集群的。</p><p>今天，我们就要给大家介绍另一款可以支持在生产环境中部署 <code>Kubernetes</code> 高可用集群的利器 <code>Sealos</code>。</p><h2 id="什么是-sealos">什么是 Sealos ？</h2><p><code>Sealos</code> 是一个 Go 语言开发的简单干净且轻量的 <code>Kubernetes</code> 集群部署工具，<code>Sealos</code> 能很好的支持在生产环境中部署高可用的 <code>Kubernetes</code> 集群。</p><p><img src="https://raw.githubusercontent.com/fanux/sealos/master/arch.png" alt=""></p><p><code>Sealos</code> 架构图</p><p><strong>Sealos 特性与优势</strong></p><ol><li><p>支持离线安装，工具与部署资源包分离，方便不同版本间快速升级。</p></li><li><p>证书有效期默认延期至 99 年。</p></li><li><p>工具使用非常简单。</p></li><li><p>支持使用自定义配置文件，可灵活完成集群环境定制。</p></li><li><p>使用内核进行本地负载，稳定性极高，故障排查也极其简单。</p></li></ol><a id="more"></a><h2 id="sealos-设计原则和工作原理">Sealos 设计原则和工作原理</h2><h3 id="1-为什么不使用-ansilbe-实现">1. 为什么不使用 Ansilbe 实现</h3><p><code>Sealos 1.0</code> 版本时是使用 <code>Ansible</code> 实现的，这样在使用时就必须先安装 <code>Ansible</code> 及一些 <code>Python</code> 的依赖包和进行一些必须的相关环境配置，使用起来还是比较复杂的。</p><p>为了解决这个问题，目前新版本的 <code>Sealos</code> 采用二进制文件方式提供。新版本 <code>Sealos</code> 没有任何依赖，开箱即用。</p><blockquote><p>文件分发与远程命令都通过调用对应 <code>SDK</code> 实现，不依赖其它任何环境。</p></blockquote><h3 id="2-为什么不用-keepalived-和-haproxy-实现集群高可用">2. 为什么不用 KeepAlived 和 HAProxy 实现集群高可用</h3><p>无论是通过 <code>KeepAlived</code> 还是 <code>HAProxy</code> 进行高可用集群调度都会存在以下一些劣势。</p><ol><li><p>软件源不一致可能导致容器中安装的软件版本也不一致，进而会引起相应检查脚本不生效等故障。</p></li><li><p>可能因为系统依赖库问题，在某些特定环境下就直接无法完成安装。</p></li><li><p>只依靠检测 <code>HAProxy</code> 进程是否存活是无法保证集群高可用的，正确的检测方式应该是判断 <code>ApiServer</code> 是否 <code>healthz</code> 状态。</p></li><li><p><code>Keepalived</code> 可能存在 <code>Cpu</code> 占满的情况。</p></li></ol><h3 id="3-本地负载为什么不使用-envoy-或者-nginx-实现">3. 本地负载为什么不使用 Envoy 或者 Nginx 实现</h3><p><code>Sealos</code> 高可用实现是通过本地负载方式完成的。本地负载实现方式有多种，比如：<code>IPVS</code>、<code>Envoy</code>、<code>Nginx</code> 等，而 <code>Sealos</code> 采用的是通过内核  <code>IPVS</code> 来实现的。</p><blockquote><p>本地负载：在每个 <code>Node</code> 节点上都启动一个负载均衡，同时监听集群中的多个 <code>Master</code> 节点。</p></blockquote><p><code>Sealos</code> 选择通过内核 <code>IPVS</code> 来实现主要有以下几个原因：</p><ul><li><p>如果使用 <code>Envoy</code> 等需要在每个节点上都跑一个进程，消耗更多资源。虽然 <code>IPVS</code> 实际上也会多跑一个 <code>lvscare</code> 进程 ，但是 <code>lvscare</code> 只是负责管理 <code>IPVS</code> 规则，原理和 <code>Kube-Proxy</code>类似。真正的流量直接从内核层面走，不需要把数据包先走到用户态中去处理。</p></li><li><p>使用 <code>Envoy</code> 存在启动优先级的问题，比如：Join 集群时，如果负载均衡没有建立，Kubelet 就会启动失败。使用 <code>IPVS</code> 则不会存在这样的问题，因为我们可以在 Join 集群前先建立好转发规则。</p></li></ul><p><strong>3.1 本地内核负载工作原理</strong></p><p><code>Sealos</code> 通过本地内核负载的方式实现每个 <code>Node</code> 节点负载均衡访问所有 <code>Master</code> 节点，具体参见下图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+----------+                       +---------------+  virturl server: 127.0.0.1:6443</span><br><span class="line">| mater0   |&lt;----------------------| ipvs nodes    |    real servers:</span><br><span class="line">+----------+                      |+---------------+            10.103.97.200:6443</span><br><span class="line">                                  |                             10.103.97.201:6443</span><br><span class="line">+----------+                      |                             10.103.97.202:6443</span><br><span class="line">| mater1   |&lt;---------------------+</span><br><span class="line">+----------+                      |</span><br><span class="line">                                  |</span><br><span class="line">+----------+                      |</span><br><span class="line">| mater2   |&lt;---------------------+</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure><p>在所有 <code>Node</code> 节点上启动一个包含 <code>lvscare</code> 进程的 <code>Static Pod</code> 对 <code>IPVS</code> 进行守护。 如果检测到 <code>ApiServer</code> 不可用时，<code>Sealos</code> 会自动清理掉所有 <code>Node</code> 节点上对应的主节点 <code>IPVS</code> 转发规则。直到 <code>Master</code> 节点恢复正常时，再自动生成对应规则。为了实现以上功能，我们在 <code>Node</code> 节点上增加了下面这些内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 增加了一个 lvscare 的 Static Pod</span><br><span class="line">$ cat &#x2F;etc&#x2F;kubernetes&#x2F;manifests</span><br><span class="line"></span><br><span class="line"># 自动创建的一些 IPVS 规则</span><br><span class="line">$ ipvsadm -Ln            </span><br><span class="line"></span><br><span class="line"># 增加了对虚拟 IP 的地址解析</span><br><span class="line">$ cat &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><h3 id="4-为什么要定制-kubeadm">4. 为什么要定制 Kubeadm</h3><ul><li><p>解决默认证书有效期只有一年的问题。</p></li><li><p>更方便的实现本地负载。</p></li><li><p>核心的功能均集成到 Kubeadm 中了，Sealos 只管分发和执行上层命令，相对就更轻量了。</p></li></ul><h3 id="5-sealos-执行流程">5. Sealos 执行流程</h3><ol><li><p>通过 <code>SFTP</code> 或者 <code>Wget</code> 命令把离线安装包拷贝到目标机器上，包括所有 <code>Master</code> 和 <code>Node</code> 节点。</p></li><li><p>在 <code>Master 0</code> 节点上执行 <code>kubeadm init</code> 命令。</p></li><li><p>在其它 <code>Master</code> 节点上执行 <code>kubeadm join</code> 命令并设置控制面。这个过程中多个 <code>Master</code> 节点上的 <code>Etcd</code> 会自动组成一个 <code>Etcd</code> 集群，并启动相应控制组件。</p></li><li><p>所有 <code>Node</code> 节点都加入到集群中，这个过程中会在 <code>Node</code> 节点上进行 <code>IPVS</code> 转发规则和 <code>/etc/hosts</code> 配置。</p></li></ol><blockquote><p><code>Node</code> 节点对 <code>ApiServer</code> 的访问均是通过域名进行的。因为 <code>Node</code> 节点需要通过 <code>虚拟 IP</code> 连接到多个 <code>Master</code> 上，但是每个 <code>Node</code> 节点的 <code>Kubelet</code> 与 <code>Kube-Proxy</code> 访问 <code>ApiServer</code> 的地址是不同的，所以这里使用域名来解析每个节点上 <code>ApiServer</code> 不同的 <code>IP</code> 地址。</p></blockquote><h2 id="使用-sealos-部署高可用-kubernetes-集群">使用 Sealos 部署高可用 Kubernetes 集群</h2><h3 id="1-安装相关环境依赖">1. 安装相关环境依赖</h3><p>通过 <code>Sealos</code> 进行 <code>Kubernetes</code> 集群部署，你需要先准备好以下环境。</p><ol><li><p>在所有要部署的机器上，先完成 <code>Docker</code> 的安装和启动。</p></li><li><p>下载 <code>Kubernetes</code> 离线安装包。</p></li><li><p>下载最新版本 <code>Sealos</code>。</p></li><li><p>对所有服务器进行时间同步。</p></li></ol><blockquote><p>Sealos 项目地址：<a href="https://github.com/fanux/sealos/releases" target="_blank" rel="noopener">https://github.com/fanux/sealos/releases</a></p><p>Kubernetes 离线安装包：<a href="https://github.com/sealstore/cloud-kernel/releases/" target="_blank" rel="noopener">https://github.com/sealstore/cloud-kernel/releases/</a></p></blockquote><h3 id="2-通过-sealos-部署高可用-kubernetes-集群">2. 通过 Sealos 部署高可用 Kubernetes 集群</h3><p>目前 <code>Sealos</code> 已经支持最新版本 <code>Kubernetes 1.16.0</code> 的高可用集群安装。</p><h4 id="21-sealos-常用参数说明">2.1 Sealos 常用参数说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--master   Master 节点服务器地址列表</span><br><span class="line">--node     Node 节点服务器地址列表</span><br><span class="line">--user     服务器 SSH 用户名</span><br><span class="line">--passwd   服务器 SSH 用户密码</span><br><span class="line">--pkg-url  离线包所在位置，可以是本地目录，也可以是一个 HTTP 地址</span><br><span class="line">--version  指定需要部署的 Kubernetes 版本</span><br><span class="line">--pk       指定 SSH 私钥所在位置，默认为 &#x2F;root&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line"></span><br><span class="line">Other flags:</span><br><span class="line"></span><br><span class="line"> --kubeadm-config string   kubeadm-config.yaml 用于指定自定义 kubeadm 配置文件</span><br><span class="line"> --vip string              virtual ip (default &quot;10.103.97.2&quot;) 本地负载时虚拟 IP ，不推荐修改，集群外不可访问</span><br></pre></td></tr></table></figure><h4 id="22-部署一个单主节点的-kubernetes-集群">2.2 部署一个单主节点的 Kubernetes 集群</h4><p>通过 <code>Sealos</code> 部署 <code>Kubernetes</code> 集群是非常简单的 ，通常只需以下两条指令就可以完成安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;fanux&#x2F;sealos&#x2F;releases&#x2F;download&#x2F;v2.0.7&#x2F;sealos &amp;&amp; \</span><br><span class="line">    chmod +x sealos &amp;&amp; mv sealos &#x2F;usr&#x2F;bin </span><br><span class="line"></span><br><span class="line">$ sealos init --passwd YOUR_SERVER_PASSWD \</span><br><span class="line">--master 192.168.0.2  --master 192.168.0.3  --master 192.168.0.4  \</span><br><span class="line">--node 192.168.0.5 \</span><br><span class="line">--pkg-url https:&#x2F;&#x2F;sealyun.oss-cn-beijing.aliyuncs.com&#x2F;cf6bece970f6dab3d8dc8bc5b588cc18-1.16.0&#x2F;kube1.16.0.tar.gz \</span><br><span class="line">--version v1.16.0</span><br></pre></td></tr></table></figure><p>如果你的服务器已经配置了 <code>SSH</code> 免密登陆，你可以直接使用对应密钥进行部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sealos init --master 192.168.0.2 \</span><br><span class="line">    --node 192.168.0.3 \</span><br><span class="line">    --pkg-url https:&#x2F;&#x2F;YOUR_HTTP_SERVER&#x2F;kube1.15.0.tar.gz \</span><br><span class="line">    --pk &#x2F;root&#x2F;kubernetes.pem \</span><br><span class="line">    --version v1.16.0</span><br></pre></td></tr></table></figure><p>如果你需要其它 <code>Kubernetes</code> 版本离线包，可到 <code>Sealos</code> 官网 <a href="http://store.lameleg.com/" target="_blank" rel="noopener">http://store.lameleg.com/</a> 进行下载。</p><h4 id="23-部署一个多主节点的高可用-kubernetes-集群">2.3 部署一个多主节点的高可用 Kubernetes 集群</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sealos init --master 192.168.0.2 \</span><br><span class="line">    --master 192.168.0.3 \</span><br><span class="line">    --master 192.168.0.4 \</span><br><span class="line">    --node 192.168.0.5 \</span><br><span class="line">    --user root \</span><br><span class="line">    --passwd your-server-password \</span><br><span class="line">    --version v1.16.0 \</span><br><span class="line">    --pkg-url &#x2F;root&#x2F;kube1.16.0.tar.gz</span><br></pre></td></tr></table></figure><h4 id="24-验证部署是否成功">2.4 验证部署是否成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get node</span><br><span class="line">NAME                      STATUS   ROLES    AGE     VERSION</span><br><span class="line">izj6cdqfqw4o4o9tc0q44rz   Ready    master   2m25s   v1.16.0</span><br><span class="line">izj6cdqfqw4o4o9tc0q44sz   Ready    master   119s    v1.16.0</span><br><span class="line">izj6cdqfqw4o4o9tc0q44tz   Ready    master   63s     v1.16.0</span><br><span class="line">izj6cdqfqw4o4o9tc0q44uz   Ready    &lt;none&gt;   38s     v1.16.0</span><br><span class="line"></span><br><span class="line">$ kubectl get pod --all-namespaces</span><br><span class="line">NAMESPACE     NAME                                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   calico-kube-controllers-5cbcccc885-9n2p8          1&#x2F;1     Running   0          3m1s</span><br><span class="line">kube-system   calico-node-656zn                                 1&#x2F;1     Running   0          93s</span><br><span class="line">kube-system   calico-node-bv5hn                                 1&#x2F;1     Running   0          2m54s</span><br><span class="line">kube-system   calico-node-f2vmd                                 1&#x2F;1     Running   0          3m1s</span><br><span class="line">kube-system   calico-node-tbd5l                                 1&#x2F;1     Running   0          118s</span><br><span class="line">kube-system   coredns-fb8b8dccf-8bnkv                           1&#x2F;1     Running   0          3m1s</span><br><span class="line">kube-system   coredns-fb8b8dccf-spq7r                           1&#x2F;1     Running   0          3m1s</span><br><span class="line">kube-system   etcd-izj6cdqfqw4o4o9tc0q44rz                      1&#x2F;1     Running   0          2m25s</span><br><span class="line">kube-system   etcd-izj6cdqfqw4o4o9tc0q44sz                      1&#x2F;1     Running   0          2m53s</span><br><span class="line">kube-system   etcd-izj6cdqfqw4o4o9tc0q44tz                      1&#x2F;1     Running   0          118s</span><br><span class="line">kube-system   kube-apiserver-izj6cdqfqw4o4o9tc0q44rz            1&#x2F;1     Running   0          2m15s</span><br><span class="line">kube-system   kube-apiserver-izj6cdqfqw4o4o9tc0q44sz            1&#x2F;1     Running   0          2m54s</span><br><span class="line">kube-system   kube-apiserver-izj6cdqfqw4o4o9tc0q44tz            1&#x2F;1     Running   1          47s</span><br><span class="line">kube-system   kube-controller-manager-izj6cdqfqw4o4o9tc0q44rz   1&#x2F;1     Running   1          2m43s</span><br><span class="line">kube-system   kube-controller-manager-izj6cdqfqw4o4o9tc0q44sz   1&#x2F;1     Running   0          2m54s</span><br><span class="line">kube-system   kube-controller-manager-izj6cdqfqw4o4o9tc0q44tz   1&#x2F;1     Running   0          63s</span><br><span class="line">kube-system   kube-proxy-b9b9z                                  1&#x2F;1     Running   0          2m54s</span><br><span class="line">kube-system   kube-proxy-nf66n                                  1&#x2F;1     Running   0          3m1s</span><br><span class="line">kube-system   kube-proxy-q2bqp                                  1&#x2F;1     Running   0          118s</span><br><span class="line">kube-system   kube-proxy-s5g2k                                  1&#x2F;1     Running   0          93s</span><br><span class="line">kube-system   kube-scheduler-izj6cdqfqw4o4o9tc0q44rz            1&#x2F;1     Running   1          2m43s</span><br><span class="line">kube-system   kube-scheduler-izj6cdqfqw4o4o9tc0q44sz            1&#x2F;1     Running   0          2m54s</span><br><span class="line">kube-system   kube-scheduler-izj6cdqfqw4o4o9tc0q44tz            1&#x2F;1     Running   0          61s</span><br><span class="line">kube-system   kube-sealyun-lvscare-izj6cdqfqw4o4o9tc0q44uz      1&#x2F;1     Running   0          86s</span><br></pre></td></tr></table></figure><h4 id="25-最简单粗暴的视频教程">2.5 最简单粗暴的视频教程</h4><p>如果你觉得上面的教程还是不够直观，现在就给你一个更简单粗暴的学习方式。猛击<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247488905&amp;idx=1&amp;sn=c42f9baeb1a48970ded0f42a520c91a5&amp;chksm=eac534a0ddb2bdb6cb072ec6e2ba60cf53a5447d7f36aa8e8b6a48ca9877ab82837213252133&amp;token=2039868521&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>的视频，开始吧！</p><h4 id="26-升级-kubernetes-集群版本">2.6 升级 Kubernetes 集群版本</h4><p><code>Kubernetes</code> 集群目前处于一个高速迭代期，每个新版本的发布都提供了不少新的特性。升级 <code>Kubernetes</code> 集群版本也就成了家常便饭，<code>Sealos</code> 也为大家提供非常方便的功能来帮助大家快速完成 <code>Kubernetes</code> 集群升级。<code>Kubernetes</code> 集群升级大致需要以下几个步骤：</p><ol><li><p>升级所有节点的 <code>Kubeadm</code> 并导入新的镜像。</p></li><li><p>升级 <code>Master</code> 节点上的 <code>Kubelet</code>。</p></li><li><p>升级其它 <code>Master</code> 节点。</p></li><li><p>升级 <code>Node</code> 节点。</p></li><li><p>验证集群状态。</p></li></ol><p><strong>2.6.1 升级 Kubeadm</strong></p><p>这一步主要用于更新 <code>Kubeadm</code>、<code>Kubectl</code>、<code>Kubelet</code> 等二进制文件，并导入新版本的镜像。升级方法很简单，只需复制离线包到所有节点并执行以下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd kube&#x2F;shell &amp;&amp; sh init.sh</span><br></pre></td></tr></table></figure><p><strong>2.6.2 升级 Master 节点上的 Kubelet</strong></p><p>升级 <code>Kubelet</code> 还是很简单的，只需要把新版本的 <code>Kubelet</code> 复制到 <code>/usr/bin</code> 目录下替换旧版本，然后重启 <code>Kubelet</code> 服务即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm upgrade plan</span><br><span class="line">$ kubeadm upgrade apply v1.16.0</span><br><span class="line"></span><br><span class="line"># 重启 Kubelet</span><br><span class="line">$ systemctl restart kubelet</span><br></pre></td></tr></table></figure><p>其中最重要的 <code>kubeadm upgrade apply</code> 命令主要完成以下一些操作。</p><ul><li><p>验证集群是否可升级并执行版本升级策略。</p></li><li><p>确认离线包中相关镜像是否可用。</p></li><li><p>对控制组件的容器进行升级，失败就回滚。</p></li><li><p>对 <code>Kube-DNS</code> 和 <code>Kube-Proxy</code> 进行升级。</p></li><li><p>创建新的证书文件并备份旧的证书文件。</p></li></ul><p><strong>2.6.3 升级其它 Master 节点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm upgrade apply</span><br></pre></td></tr></table></figure><p><strong>2.6.4 升级 Node 节点</strong></p><p>升级 <code>Node</code> 节点前，首先要驱逐节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl drain $NODE --ignore-daemonsets</span><br></pre></td></tr></table></figure><p>其次，是更新 <code>Kubelet</code> 的配置文件和升级 <code>Node</code> 节点的 <code>Kubelet</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm upgrade node config --kubelet-version v1.16.0</span><br><span class="line"></span><br><span class="line"># 同样是替换二进制文件并重启 Kubelet</span><br><span class="line">$ systemctl restart kubelet</span><br></pre></td></tr></table></figure><p>最后，恢复 <code>Node</code> 节点为可调度状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl uncordon $NODE</span><br></pre></td></tr></table></figure><p><strong>2.6.5 验证集群是否升级成功</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br></pre></td></tr></table></figure><p>如果输出的节点的版本信息是和升级的版本一致的话，一切就搞定了！</p><h3 id="3-集群清理">3. 集群清理</h3><p>如果你需要快速清理已部署的 <code>Kubernetes</code> 集群环境，你可以使用下面的命令快速完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sealos clean \</span><br><span class="line">    --master 192.168.0.2 \</span><br><span class="line">    --master 192.168.0.3 \</span><br><span class="line">    --master 192.168.0.4 \</span><br><span class="line">    --node 192.168.0.5 \</span><br><span class="line">    --user root \</span><br><span class="line">    --passwd your-server-password</span><br></pre></td></tr></table></figure><p>至此，使用 <code>Sealos</code> 快速部署一个生产级别的 <code>Kubernetes</code> 高可用集群的基本方法就介绍完了。如果你对 <code>Sealos</code> 非常的感兴趣，你还可以去官网探索更多高级功能哟！</p><p>对于在生产环境中快速部署 <code>Kubernetes</code> 高可用集群，你还有哪些更好用高效的方法呢？欢迎大家在留言讨论哟！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间，我们在 ​「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247488666&amp;amp;idx=1&amp;amp;sn=de46a87cf59f8564ad75337b7c0cf7f6&amp;amp;chksm=eac535b3ddb2bca5de2a923ec6cfa427e87f0135b31193efd1b904dff4c7b473f1dc9af82903&amp;amp;token=212816651&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用 Kind 在 5 分钟内快速部署一个 Kubernetes 高可用集群&lt;/a&gt;」一文中介绍了如何使用 &lt;code&gt;Kind&lt;/code&gt; 这个开箱即可快速部署 &lt;code&gt;Kubernetes&lt;/code&gt; 高可用集群的神器，相信不少同学用上这个神器后大大的降低了 &lt;code&gt;Kubernetes&lt;/code&gt; 集群的部署难度和提高了 &lt;code&gt;Kubernetes&lt;/code&gt; 集群的部署速度。不过有一点比较遗憾的是 &lt;code&gt;Kind&lt;/code&gt; 当前仅仅支持在本地快速构建一个开发或者测试环境，目前暂时还是不支持在生产环境中部署 &lt;code&gt;Kubernetes&lt;/code&gt; 高可用集群的。&lt;/p&gt;
&lt;p&gt;今天，我们就要给大家介绍另一款可以支持在生产环境中部署 &lt;code&gt;Kubernetes&lt;/code&gt; 高可用集群的利器 &lt;code&gt;Sealos&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Sealos-？&quot;&gt;什么是 Sealos ？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Sealos&lt;/code&gt; 是一个 Go 语言开发的简单干净且轻量的 &lt;code&gt;Kubernetes&lt;/code&gt; 集群部署工具，&lt;code&gt;Sealos&lt;/code&gt; 能很好的支持在生产环境中部署高可用的 &lt;code&gt;Kubernetes&lt;/code&gt; 集群。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fanux/sealos/master/arch.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sealos&lt;/code&gt; 架构图&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sealos 特性与优势&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;支持离线安装，工具与部署资源包分离，方便不同版本间快速升级。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;证书有效期默认延期至 99 年。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工具使用非常简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持使用自定义配置文件，可灵活完成集群环境定制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用内核进行本地负载，稳定性极高，故障排查也极其简单。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>推荐几个不追踪隐私的搜索引擎</title>
    <link href="https://www.hi-linux.com/posts/392.html"/>
    <id>https://www.hi-linux.com/posts/392.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.402Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>毫无疑问，在中文搜索领域，「百度」独占鳌头。但众所周知，至少在目前，与「百度」这个浪漫的命名截然相反的是，百度是个口碑极其糟糕的产品。但是对于大多数的用户，彻底避免使用「百度」是一件较为困难的事情。</p><p><strong>为什么不用「Google 搜索」？</strong></p><p>因为谷歌的商业模式决定了它需要收集用户隐私，当然更重要的是你在国内也是不可用的。</p><p><strong>为什么不用「百度搜索」？</strong></p><p>没有为什么，谁用谁知道百度是什么。</p><p><strong>为什么不用「 DuckDuckGo」？</strong></p><p>因为在国内同样不可用，没有其它了。</p><blockquote><p>DuckDuckGo 是一款互联网搜索引擎，其注重用户隐私以及避免个性化检索所致的过滤气泡。它与其它搜索引擎不同的地方在于其不会分析自己的用户、对所有使用同一组关键词的用户显示同样的结果。它也强调返回最佳结果，而不是最多网站链接之结果。</p></blockquote><p><strong>为什么不用其它的主流搜索引擎？</strong></p><p>必应、搜狗等搜索引擎不但也会收集用户隐私，而搜索结果也不尽如人意。</p><p>在这样的大环境下，寻找百度替代品一直是很多用户所关注的事情。因此，也应运而生了很多优秀的搜索引擎产品，今天就给大家推荐几款清爽、简洁、快速、无广告且不收集个人隐私的搜索引擎产品。</p><a id="more"></a><h2 id="多吉搜索">多吉搜索</h2><p>DogeDoge，又称多吉搜索，是国内一款个人开发者主导的搜索引擎产品，宗旨是不追踪用户隐私，不误导用户。多吉搜索的愿景是做中国的 DuckDuckGo，成为百度的替代方案之一。</p><p>多吉搜索有着极简的页面设计风格，没有热门文章推荐、没有热点新闻推送，搜索结果不添加任何广告，只专注于搜索本身！一句话形容就是 “高效、纯粹” 。</p><p>官网地址：<a href="https://dogedoge.com" target="_blank" rel="noopener">https://dogedoge.com</a></p><p><img src="https://i.loli.net/2019/08/05/rqadoExhT8uYV6J.png" alt=""></p><p>除了网页搜索之外，目前多吉搜索也支持部分即时结果 (Instant Result)，比如查询 IP、汇率转换等等。未来可能还会增加一些诸如：技术文档、天气查询、节气查询、热门人物、景点、影视等等功能。</p><p><img src="https://i.loli.net/2019/08/05/UKe7nsYo2jvwTaH.jpg" alt=""></p><h2 id="秘迹搜索">秘迹搜索</h2><p>秘迹搜索一个是基于开源项目 Searx 进行二次开发的可以保护个人隐私的网络搜索服务。</p><p>因为 Searx 采用的开源协议是 AGPL-3.0，所以秘迹搜索也严格遵守这一开源协议，秘迹搜索所有的改动也是完全开源的。如果你对网络隐私防护感兴趣也可以加入开发和维护中，其项目地址是：<a href="https://github.com/entropage/mijisou" target="_blank" rel="noopener">https://github.com/entropage/mijisou</a> 。</p><p>官网地址：<a href="https://mijisou.com/" target="_blank" rel="noopener">https://mijisou.com/</a></p><p><img src="https://i.loli.net/2019/08/06/WHuPLmAb26Yy9cT.png" alt=""></p><h3 id="秘迹搜索工作原理">秘迹搜索工作原理</h3><p>当一个用户使用秘迹搜索的时候:</p><ol><li>使用浏览器打开 <a href="https://mijisou.com" target="_blank" rel="noopener">https://mijisou.com</a>，输入查询关键字。</li><li>发起的网络请求传递到秘迹搜索的服务器上。但是秘迹搜索的服务器没有记录用户的任何信息(不光没有记录用户输入的检索词，从用户浏览器中带过来的 IP 地址、UserAgent、HTTP Header等信息，也统统没有记录)。</li><li>最后，秘迹搜索将结果数据返回给用户的浏览器。</li></ol><p><img src="https://i.loli.net/2019/08/06/ZS7oY6WBlgpKAJM.png" alt=""></p><p>秘迹搜索没有存储任何的用户信息，也没有使用任何追踪用户的黑科技(tracking scripts, tracking pixels, tracking tags)，甚至连浏览器 Cookie 都没有使用, 也就自然不会泄漏用户的隐私信息了。</p><h3 id="秘迹搜索特色功能">秘迹搜索特色功能</h3><ol><li>提供聚合和过滤功能</li></ol><p>秘迹搜索的结果聚合了各种搜索引擎的检索结果，并在后台帮助用户过滤掉一切追踪脚本和可以过滤掉的广告信息，最终提供给用户的都是干净的结果信息。</p><p><img src="https://i.loli.net/2019/08/06/Bh5gLKIX3exTDPz.png" alt=""></p><ol start="2"><li>提供匿名访问功能</li></ol><p>除了提供搜索服务外，秘迹搜索对于检索到的结果还提供匿名访问功能，见下图所示。</p><p><img src="https://i.loli.net/2019/08/06/iEgTqufB8zLkP7Y.png" alt=""></p><p>匿名访问功能本质上是一个代理服务，比如你想访问秘迹搜索结果页中的 <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a> 网站，如果通过匿名访问来浏览, 我们会通过代理服务 <a href="http://proxy.mijisou.com" target="_blank" rel="noopener">proxy.mijisou.com</a> 去获得 <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a> 网站上的有用信息，然后再把有用信息中转展示给用户。</p><blockquote><p>该代理服务是秘迹的独立服务，不会记录任何请求日志，会完全保护用户免受各种追踪和骚扰。</p></blockquote><h2 id="萌搜">萌搜</h2><p>萌搜致力于打造一款无色情、无暴力、不涉政的绿色搜索引擎，对色情内容、涉政内容等做过高度严格的完全过滤。</p><p>萌搜主要是针对技术领域的问题进行深度优化；编程程领域建议使用纯英文进行查找。</p><p>官网地址：<a href="https://mengso.com/" target="_blank" rel="noopener">https://mengso.com/</a></p><p><img src="https://i.loli.net/2019/08/06/l9q8cs5VbTAguSh.png" alt=""></p><blockquote><p>关于隐私方面，萌搜会记录您搜索的关键词。有两点原因：一是为了优化语料库；二是因为监管层需求。</p></blockquote><h2 id="如何设置成浏览器默认搜索引擎">如何设置成浏览器默认搜索引擎？</h2><p>以 Chrome 为例：一般情况下，在搜索引擎中搜索过一次以后，就能在 Chrome 的偏好设置的搜索引擎设置中选择对应搜索引擎，然后设置为默认搜索引擎即可。</p><p>当然也可以自定义添加搜索字符串，下面我们以设置多吉搜索为例：</p><ol><li>在浏览器地址栏输入 <code>chrome://settings/searchEngines</code> 打开浏览器默认搜索引擎设置界面。</li><li>输入对应搜索引擎的搜索字符串即可。</li></ol><ul><li>多吉搜索字符串：<a href="https://dogedoge.com/results?q=%25s" target="_blank" rel="noopener">https://dogedoge.com/results?q=%s</a></li><li>秘迹搜索字符串：<a href="https://mijisou.com/search?q=%25s" target="_blank" rel="noopener">https://mijisou.com/search?q=%s</a></li><li>萌搜搜索字符串：<a href="https://mengso.com/search?q=%25s" target="_blank" rel="noopener">https://mengso.com/search?q=%s</a></li></ul><p><img src="https://i.loli.net/2019/08/05/GHTqPLaf2iZ974w.png" alt=""></p><p>如果你有更好用的不追踪隐私的搜索引擎推荐，请在评论区留言分享出来吧！</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="https://liulanmi.com/zt/13243.html" target="_blank" rel="noopener">https://liulanmi.com/zt/13243.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/54285064" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54285064</a></li><li><a href="https://www.ugediao.com/dogedoge-chinese-search-engine.html" target="_blank" rel="noopener">https://www.ugediao.com/dogedoge-chinese-search-engine.html</a></li><li><a href="https://zhuanfou.com/article/77813574_063" target="_blank" rel="noopener">https://zhuanfou.com/article/77813574_063</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毫无疑问，在中文搜索领域，「百度」独占鳌头。但众所周知，至少在目前，与「百度」这个浪漫的命名截然相反的是，百度是个口碑极其糟糕的产品。但是对于大多数的用户，彻底避免使用「百度」是一件较为困难的事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不用「Google 搜索」？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为谷歌的商业模式决定了它需要收集用户隐私，当然更重要的是你在国内也是不可用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不用「百度搜索」？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没有为什么，谁用谁知道百度是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不用「 DuckDuckGo」？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为在国内同样不可用，没有其它了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DuckDuckGo 是一款互联网搜索引擎，其注重用户隐私以及避免个性化检索所致的过滤气泡。它与其它搜索引擎不同的地方在于其不会分析自己的用户、对所有使用同一组关键词的用户显示同样的结果。它也强调返回最佳结果，而不是最多网站链接之结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么不用其它的主流搜索引擎？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;必应、搜狗等搜索引擎不但也会收集用户隐私，而搜索结果也不尽如人意。&lt;/p&gt;
&lt;p&gt;在这样的大环境下，寻找百度替代品一直是很多用户所关注的事情。因此，也应运而生了很多优秀的搜索引擎产品，今天就给大家推荐几款清爽、简洁、快速、无广告且不收集个人隐私的搜索引擎产品。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款轻量级 HTTP(S) 代理 TinyProxy</title>
    <link href="https://www.hi-linux.com/posts/15200.html"/>
    <id>https://www.hi-linux.com/posts/15200.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.403Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，我们常用的 <code>Web</code> 服务器 <code>Nginx</code> / <code>Apache</code> 都可以很方便的用来做为正向或反向代理服务器使用。但是它们都并不支持 <code>HTTPS</code> 的正向代理。</p><blockquote><p>Nginx 做为正向代理不支持 HTTPS 的原因是因为 Nginx 没有实现 HTTP 1.1 Connect 方法。隧道的含义大约就是帮助无法完成 TLS 握手的代理服务器透传可以完成 TLS 握手的客户端请求，而不再解析流量中的内容。</p></blockquote><p>关于 Connect 和 隧道技术，可详见以下文章：</p><ul><li><p>RFC 2817 （<a href="http://t.cn/EaoC0qf%EF%BC%89" target="_blank" rel="noopener">http://t.cn/EaoC0qf）</a></p></li><li><p>什么是 HTTP 隧道，怎么理解 HTTP 隧道呢？ （<a href="http://t.cn/EaoCveH%EF%BC%89" target="_blank" rel="noopener">http://t.cn/EaoCveH）</a></p></li></ul><p>今天我们来介绍一款同时支持 <code>HTTP/HTTPS</code> 的轻量级代理软件 <code>TinyProxy</code>，<code>TinyProxy</code> 支持以下功能特性：</p><ul><li>支持匿名模式。</li><li>支持 HTTPS，可以通过 CONNECT 请求来转发 HTTPS 连接。</li><li>远程监视：可远程查看日志和访问信息。</li><li>负载监视：可配置成当负载达到某个程度时，拒绝新的代理请求。</li><li>访问控制：可设置特定的 IP 地址或者 IP 段才可访问。</li><li>安全：不需要 root 权限。</li><li>轻量化：只需要极小的系统资源。</li><li>支持基于 URL 的过滤。</li><li>支持透明代理。</li><li>支持多级代理。</li></ul><p>TinyProxy 项目地址：<a href="https://github.com/tinyproxy/tinyproxy" target="_blank" rel="noopener">https://github.com/tinyproxy/tinyproxy</a></p><h3 id="安装-tinyproxy">安装 TinyProxy</h3><ol><li>通过软件包安装</li></ol><p><code>TinyProxy</code> 目前已支持大多数发行版通过软件包安装，下面介绍下比较常用的几个平台的安装方式。</p><ul><li>CentOS / RHEL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 需要 EPEL 仓库</span><br><span class="line">$ yum install -y tinyproxy</span><br></pre></td></tr></table></figure><ul><li>Ubuntu / Debian</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get -y install tinyproxy</span><br></pre></td></tr></table></figure><p>如果你使用的是其它平台，更多的安装方式可直接参考官方文档：<a href="https://tinyproxy.github.io/" target="_blank" rel="noopener">https://tinyproxy.github.io/</a></p><ol start="2"><li>通过源码安装</li></ol><p>如果你使用的平台，官方还不支持通过软件包安装。你也可以通过源码进行编译安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;tinyproxy&#x2F;tinyproxy.git</span><br><span class="line">$ cd tinyproxy</span><br><span class="line">$ .&#x2F;autogen.sh</span><br><span class="line">$ .&#x2F;configure</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="配置-tinyproxy">配置 TinyProxy</h3><p><code>TinyProxy</code> 默认配置文件路径为 <code>/etc/tinyproxy/tinyproxy.conf​</code>。如果你要自定义配置文件位置，可以在启动 <code>TinyProxy</code> 时 通过 <code>-c</code> 参数来指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;tinyproxy&#x2F;tinyproxy.conf​</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## tinyproxy.conf -- tinyproxy daemon configuration file</span><br><span class="line">##</span><br><span class="line">## This example tinyproxy.conf file contains example settings</span><br><span class="line">## with explanations in comments. For decriptions of all</span><br><span class="line">## parameters, see the tinproxy.conf(5) manual page.</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># User&#x2F;Group: This allows you to set the user and group that will be</span><br><span class="line"># used for tinyproxy after the initial binding to the port has been done</span><br><span class="line"># as the root user. Either the user or group name or the UID or GID</span><br><span class="line"># number may be used.</span><br><span class="line">#</span><br><span class="line">User nobody</span><br><span class="line">Group nobody</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Port: Specify the port which tinyproxy will listen on.  Please note</span><br><span class="line"># that should you choose to run on a port lower than 1024 you will need</span><br><span class="line"># to start tinyproxy using root.</span><br><span class="line">#</span><br><span class="line">Port 8888</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Listen: If you have multiple interfaces this allows you to bind to</span><br><span class="line"># only one. If this is commented out, tinyproxy will bind to all</span><br><span class="line"># interfaces present.</span><br><span class="line">#</span><br><span class="line"># Listen 192.168.0.1</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Bind: This allows you to specify which interface will be used for</span><br><span class="line"># outgoing connections.  This is useful for multi-home&#39;d machines where</span><br><span class="line"># you want all traffic to appear outgoing from one particular interface.</span><br><span class="line">#</span><br><span class="line">#Bind 192.168.0.1</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># BindSame: If enabled, tinyproxy will bind the outgoing connection to the</span><br><span class="line"># ip address of the incoming connection.</span><br><span class="line">#</span><br><span class="line">#BindSame yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Timeout: The maximum number of seconds of inactivity a connection is</span><br><span class="line"># allowed to have before it is closed by tinyproxy.</span><br><span class="line">#</span><br><span class="line">Timeout 600</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># ErrorFile: Defines the HTML file to send when a given HTTP error</span><br><span class="line"># occurs.  You will probably need to customize the location to your</span><br><span class="line"># particular install.  The usual locations to check are:</span><br><span class="line">#   &#x2F;usr&#x2F;local&#x2F;share&#x2F;tinyproxy</span><br><span class="line">#   &#x2F;usr&#x2F;share&#x2F;tinyproxy</span><br><span class="line">#   &#x2F;etc&#x2F;tinyproxy</span><br><span class="line">#</span><br><span class="line">#ErrorFile 404 &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;404.html&quot;</span><br><span class="line">#ErrorFile 400 &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;400.html&quot;</span><br><span class="line">#ErrorFile 503 &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;503.html&quot;</span><br><span class="line">#ErrorFile 403 &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;403.html&quot;</span><br><span class="line">#ErrorFile 408 &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;408.html&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># DefaultErrorFile: The HTML file that gets sent if there is no</span><br><span class="line"># HTML file defined with an ErrorFile keyword for the HTTP error</span><br><span class="line"># that has occured.</span><br><span class="line">#</span><br><span class="line">DefaultErrorFile &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;default.html&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># StatHost: This configures the host name or IP address that is treated</span><br><span class="line"># as the stat host: Whenever a request for this host is received,</span><br><span class="line"># Tinyproxy will return an internal statistics page instead of</span><br><span class="line"># forwarding the request to that host.  The default value of StatHost is</span><br><span class="line"># tinyproxy.stats.</span><br><span class="line">#</span><br><span class="line">#StatHost &quot;tinyproxy.stats&quot;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># StatFile: The HTML file that gets sent when a request is made</span><br><span class="line"># for the stathost.  If this file doesn&#39;t exist a basic page is</span><br><span class="line"># hardcoded in tinyproxy.</span><br><span class="line">#</span><br><span class="line">StatFile &quot;&#x2F;usr&#x2F;share&#x2F;tinyproxy&#x2F;stats.html&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># LogFile: Allows you to specify the location where information should</span><br><span class="line"># be logged to.  If you would prefer to log to syslog, then disable this</span><br><span class="line"># and enable the Syslog directive.  These directives are mutually</span><br><span class="line"># exclusive. If neither Syslog nor LogFile are specified, output goes</span><br><span class="line"># to stdout.</span><br><span class="line">#</span><br><span class="line">LogFile &quot;&#x2F;var&#x2F;log&#x2F;tinyproxy&#x2F;tinyproxy.log&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Syslog: Tell tinyproxy to use syslog instead of a logfile.  This</span><br><span class="line"># option must not be enabled if the Logfile directive is being used.</span><br><span class="line"># These two directives are mutually exclusive.</span><br><span class="line">#</span><br><span class="line">#Syslog On</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># LogLevel: Warning</span><br><span class="line">#</span><br><span class="line"># Set the logging level. Allowed settings are:</span><br><span class="line">#Critical(least verbose)</span><br><span class="line">#Error</span><br><span class="line">#Warning</span><br><span class="line">#Notice</span><br><span class="line">#Connect(to log connections without Info&#39;s noise)</span><br><span class="line">#Info(most verbose)</span><br><span class="line">#</span><br><span class="line"># The LogLevel logs from the set level and above. For example, if the</span><br><span class="line"># LogLevel was set to Warning, then all log messages from Warning to</span><br><span class="line"># Critical would be output, but Notice and below would be suppressed.</span><br><span class="line">#</span><br><span class="line">LogLevel Info</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># PidFile: Write the PID of the main tinyproxy thread to this file so it</span><br><span class="line"># can be used for signalling purposes.</span><br><span class="line"># If not specified, no pidfile will be written.</span><br><span class="line">#</span><br><span class="line">PidFile &quot;&#x2F;var&#x2F;run&#x2F;tinyproxy&#x2F;tinyproxy.pid&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># XTinyproxy: Tell Tinyproxy to include the X-Tinyproxy header, which</span><br><span class="line"># contains the client&#39;s IP address.</span><br><span class="line">#</span><br><span class="line">#XTinyproxy Yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Upstream:</span><br><span class="line">#</span><br><span class="line"># Turns on upstream proxy support.</span><br><span class="line">#</span><br><span class="line"># The upstream rules allow you to selectively route upstream connections</span><br><span class="line"># based on the host&#x2F;domain of the site being accessed.</span><br><span class="line">#</span><br><span class="line"># Syntax: upstream type (user:pass@)ip:port (&quot;domain&quot;)</span><br><span class="line"># Or:     upstream none &quot;domain&quot;</span><br><span class="line"># The parts in parens are optional.</span><br><span class="line"># Possible types are http, socks4, socks5, none</span><br><span class="line">#</span><br><span class="line"># For example:</span><br><span class="line">#  # connection to test domain goes through testproxy</span><br><span class="line">#  upstream http testproxy:8008 &quot;.test.domain.invalid&quot;</span><br><span class="line">#  upstream http testproxy:8008 &quot;.our_testbed.example.com&quot;</span><br><span class="line">#  upstream http testproxy:8008 &quot;192.168.128.0&#x2F;255.255.254.0&quot;</span><br><span class="line">#</span><br><span class="line">#  # upstream proxy using basic authentication</span><br><span class="line">#  upstream http user:pass@testproxy:8008 &quot;.test.domain.invalid&quot;</span><br><span class="line">#</span><br><span class="line">#  # no upstream proxy for internal websites and unqualified hosts</span><br><span class="line">#  upstream none &quot;.internal.example.com&quot;</span><br><span class="line">#  upstream none &quot;www.example.com&quot;</span><br><span class="line">#  upstream none &quot;10.0.0.0&#x2F;8&quot;</span><br><span class="line">#  upstream none &quot;192.168.0.0&#x2F;255.255.254.0&quot;</span><br><span class="line">#  upstream none &quot;.&quot;</span><br><span class="line">#</span><br><span class="line">#  # connection to these boxes go through their DMZ firewalls</span><br><span class="line">#  upstream http cust1_firewall:8008 &quot;testbed_for_cust1&quot;</span><br><span class="line">#  upstream http cust2_firewall:8008 &quot;testbed_for_cust2&quot;</span><br><span class="line">#</span><br><span class="line">#  # default upstream is internet firewall</span><br><span class="line">#  upstream http firewall.internal.example.com:80</span><br><span class="line">#</span><br><span class="line"># You may also use SOCKS4&#x2F;SOCKS5 upstream proxies:</span><br><span class="line">#  upstream socks4 127.0.0.1:9050</span><br><span class="line">#  upstream socks5 socksproxy:1080</span><br><span class="line">#</span><br><span class="line"># The LAST matching rule wins the route decision.  As you can see, you</span><br><span class="line"># can use a host, or a domain:</span><br><span class="line">#  name     matches host exactly</span><br><span class="line">#  .name    matches any host in domain &quot;name&quot;</span><br><span class="line">#  .        matches any host with no domain (in &#39;empty&#39; domain)</span><br><span class="line">#  IP&#x2F;bits  matches network&#x2F;mask</span><br><span class="line">#  IP&#x2F;mask  matches network&#x2F;mask</span><br><span class="line">#</span><br><span class="line">#Upstream http some.remote.proxy:port</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># MaxClients: This is the absolute highest number of threads which will</span><br><span class="line"># be created. In other words, only MaxClients number of clients can be</span><br><span class="line"># connected at the same time.</span><br><span class="line">#</span><br><span class="line">MaxClients 100</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># MinSpareServers&#x2F;MaxSpareServers: These settings set the upper and</span><br><span class="line"># lower limit for the number of spare servers which should be available.</span><br><span class="line">#</span><br><span class="line"># If the number of spare servers falls below MinSpareServers then new</span><br><span class="line"># server processes will be spawned.  If the number of servers exceeds</span><br><span class="line"># MaxSpareServers then the extras will be killed off.</span><br><span class="line">#</span><br><span class="line">MinSpareServers 5</span><br><span class="line">MaxSpareServers 20</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># StartServers: The number of servers to start initially.</span><br><span class="line">#</span><br><span class="line">StartServers 10</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># MaxRequestsPerChild: The number of connections a thread will handle</span><br><span class="line"># before it is killed. In practise this should be set to 0, which</span><br><span class="line"># disables thread reaping. If you do notice problems with memory</span><br><span class="line"># leakage, then set this to something like 10000.</span><br><span class="line">#</span><br><span class="line">MaxRequestsPerChild 0</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Allow: Customization of authorization controls. If there are any</span><br><span class="line"># access control keywords then the default action is to DENY. Otherwise,</span><br><span class="line"># the default action is ALLOW.</span><br><span class="line">#</span><br><span class="line"># The order of the controls are important. All incoming connections are</span><br><span class="line"># tested against the controls based on order.</span><br><span class="line">#</span><br><span class="line">Allow 127.0.0.1</span><br><span class="line"></span><br><span class="line"># BasicAuth: HTTP &quot;Basic Authentication&quot; for accessing the proxy.</span><br><span class="line"># If there are any entries specified, access is only granted for authenticated</span><br><span class="line"># users.</span><br><span class="line">#BasicAuth user password</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># AddHeader: Adds the specified headers to outgoing HTTP requests that</span><br><span class="line"># Tinyproxy makes. Note that this option will not work for HTTPS</span><br><span class="line"># traffic, as Tinyproxy has no control over what headers are exchanged.</span><br><span class="line">#</span><br><span class="line">#AddHeader &quot;X-My-Header&quot; &quot;Powered by Tinyproxy&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># ViaProxyName: The &quot;Via&quot; header is required by the HTTP RFC, but using</span><br><span class="line"># the real host name is a security concern.  If the following directive</span><br><span class="line"># is enabled, the string supplied will be used as the host name in the</span><br><span class="line"># Via header; otherwise, the server&#39;s host name will be used.</span><br><span class="line">#</span><br><span class="line">ViaProxyName &quot;tinyproxy&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># DisableViaHeader: When this is set to yes, Tinyproxy does NOT add</span><br><span class="line"># the Via header to the requests. This virtually puts Tinyproxy into</span><br><span class="line"># stealth mode. Note that RFC 2616 requires proxies to set the Via</span><br><span class="line"># header, so by enabling this option, you break compliance.</span><br><span class="line"># Don&#39;t disable the Via header unless you know what you are doing...</span><br><span class="line">#</span><br><span class="line">#DisableViaHeader Yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Filter: This allows you to specify the location of the filter file.</span><br><span class="line">#</span><br><span class="line">Filter &quot;&#x2F;etc&#x2F;tinyproxy&#x2F;filter&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># FilterURLs: Filter based on URLs rather than domains.</span><br><span class="line">#</span><br><span class="line">#FilterURLs On</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># FilterExtended: Use POSIX Extended regular expressions rather than</span><br><span class="line"># basic.</span><br><span class="line">#</span><br><span class="line">#FilterExtended On</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># FilterCaseSensitive: Use case sensitive regular expressions.</span><br><span class="line">#</span><br><span class="line">#FilterCaseSensitive On</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># FilterDefaultDeny: Change the default policy of the filtering system.</span><br><span class="line"># If this directive is commented out, or is set to &quot;No&quot; then the default</span><br><span class="line"># policy is to allow everything which is not specifically denied by the</span><br><span class="line"># filter file.</span><br><span class="line">#</span><br><span class="line"># However, by setting this directive to &quot;Yes&quot; the default policy becomes</span><br><span class="line"># to deny everything which is _not_ specifically allowed by the filter</span><br><span class="line"># file.</span><br><span class="line">#</span><br><span class="line">#FilterDefaultDeny Yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Anonymous: If an Anonymous keyword is present, then anonymous proxying</span><br><span class="line"># is enabled.  The headers listed are allowed through, while all others</span><br><span class="line"># are denied. If no Anonymous keyword is present, then all headers are</span><br><span class="line"># allowed through.  You must include quotes around the headers.</span><br><span class="line">#</span><br><span class="line"># Most sites require cookies to be enabled for them to work correctly, so</span><br><span class="line"># you will need to allow Cookies through if you access those sites.</span><br><span class="line">#</span><br><span class="line">#Anonymous &quot;Host&quot;</span><br><span class="line">#Anonymous &quot;Authorization&quot;</span><br><span class="line">#Anonymous &quot;Cookie&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># ConnectPort: This is a list of ports allowed by tinyproxy when the</span><br><span class="line"># CONNECT method is used.  To disable the CONNECT method altogether, set</span><br><span class="line"># the value to 0.  If no ConnectPort line is found, all ports are</span><br><span class="line"># allowed.</span><br><span class="line">#</span><br><span class="line"># The following two ports are used by SSL.</span><br><span class="line">#</span><br><span class="line">#ConnectPort 443</span><br><span class="line">#ConnectPort 563</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Configure one or more ReversePath directives to enable reverse proxy</span><br><span class="line"># support. With reverse proxying it&#39;s possible to make a number of</span><br><span class="line"># sites appear as if they were part of a single site.</span><br><span class="line">#</span><br><span class="line"># If you uncomment the following two directives and run tinyproxy</span><br><span class="line"># on your own computer at port 8888, you can access Google using</span><br><span class="line"># http:&#x2F;&#x2F;localhost:8888&#x2F;google&#x2F; and Wired News using</span><br><span class="line"># http:&#x2F;&#x2F;localhost:8888&#x2F;wired&#x2F;news&#x2F;. Neither will actually work</span><br><span class="line"># until you uncomment ReverseMagic as they use absolute linking.</span><br><span class="line">#</span><br><span class="line">#ReversePath &quot;&#x2F;google&#x2F;&quot;&quot;http:&#x2F;&#x2F;www.google.com&#x2F;&quot;</span><br><span class="line">#ReversePath &quot;&#x2F;wired&#x2F;&quot;&quot;http:&#x2F;&#x2F;www.wired.com&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># When using tinyproxy as a reverse proxy, it is STRONGLY recommended</span><br><span class="line"># that the normal proxy is turned off by uncommenting the next directive.</span><br><span class="line">#</span><br><span class="line">#ReverseOnly Yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Use a cookie to track reverse proxy mappings. If you need to reverse</span><br><span class="line"># proxy sites which have absolute links you must uncomment this.</span><br><span class="line">#</span><br><span class="line">#ReverseMagic Yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># The URL that&#39;s used to access this reverse proxy. The URL is used to</span><br><span class="line"># rewrite HTTP redirects so that they won&#39;t escape the proxy. If you</span><br><span class="line"># have a chain of reverse proxies, you&#39;ll need to put the outermost</span><br><span class="line"># URL here (the address which the end user types into his&#x2F;her browser).</span><br><span class="line">#</span><br><span class="line"># If not set then no rewriting occurs.</span><br><span class="line">#</span><br><span class="line">#ReverseBaseURL &quot;http:&#x2F;&#x2F;localhost:8888&#x2F;&quot;</span><br></pre></td></tr></table></figure><p>下面我们来看下几个主要的配置参数：</p><ul><li>User</li></ul><p>指定运行 <code>TinyProxy</code> 的用户，默认为 nobody。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User nobody</span><br></pre></td></tr></table></figure><ul><li>Group</li></ul><p>指定运行 <code>TinyProxy</code> 的用户组，默认为 nobody。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Group nobody</span><br></pre></td></tr></table></figure><ul><li>Listen</li></ul><p>指定 <code>TinyProxy</code> 绑定的网卡接口，默认是绑定到所有可用的网卡接口的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Listen 192.168.0.1</span><br></pre></td></tr></table></figure><p>如需绑定到指定网卡接口，只需去掉对应的注释并指定网卡对应 IP 地址即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Listen 192.168.1.100</span><br></pre></td></tr></table></figure><ul><li>Port</li></ul><p>指定 <code>TinyProxy</code> 的监听端口, 默认为 8888。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Port 8888</span><br></pre></td></tr></table></figure><ul><li>Allow</li></ul><p>指定可访问 <code>TinyProxy</code> 设备的 <code>IP</code> 或网段，默认仅允许本机访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allow 127.0.0.1</span><br></pre></td></tr></table></figure><p>如果你想允许所有人使用该代理，注释 Allow 选项即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Allow 127.0.0.1</span><br></pre></td></tr></table></figure><p>如果你想增加多个可访问的网段，可以用多个 <code>Allow</code> 选项同时定义不同网段即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 添加多段 IP 地址</span><br><span class="line">Allow 10.10.6.0&#x2F;24</span><br><span class="line">Allow 192.168.8.0&#x2F;24</span><br><span class="line">Allow 172.16.1.13</span><br></pre></td></tr></table></figure><ul><li>BindSame</li></ul><p>在多网卡的情况下，设置出口 <code>IP</code> 是否与入口 <code>IP</code> 相同。默认情况下是关闭的。</p><p>例如：服务器上存在 <code>IP</code> 1.2.3.4，当你请求该 <code>IP</code> 对应的 <code>Tinyproxy</code> 代理时，<code>Tinyproxy</code> 也通过 1.2.3.4 做为出口访问目标网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#BindSame yes</span><br></pre></td></tr></table></figure><ul><li>StartServers</li></ul><p>指定 <code>TinyProxy</code> 初始启动的子进程数量， 默认是 10 个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StartServers 10</span><br></pre></td></tr></table></figure><ul><li>MaxClients</li></ul><p>设置最大客户端链接数，默认为 100。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxClients 100</span><br></pre></td></tr></table></figure><ul><li>Logfile</li></ul><p>指定日志文件位置, 默认为 /var/log/tinyproxy/tinyproxy.log。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogFile &#x2F;var&#x2F;log&#x2F;tinyproxy&#x2F;tinyproxy.log</span><br></pre></td></tr></table></figure><ul><li>Syslog</li></ul><p>指定 <code>TinyProxy</code> 是否开启 <code>Syslog</code> 来记录日志，默认为关闭的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Syslog On</span><br></pre></td></tr></table></figure><blockquote><p>注：Logfile 和 Syslog 只能同时启用一个。如果两个都不启用的话 <code>TinyProxy</code> 会将日志直接输出到终端的标准输出。</p></blockquote><ul><li>PidFile</li></ul><p>指定 <code>Pid</code> 文件位置, 默认为 /var/run/tinyproxy/tinyproxy.pid，在 <code>PidFile</code> 文件不存在时会运行失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PidFile &quot;&#x2F;var&#x2F;run&#x2F;tinyproxy&#x2F;tinyproxy.pid&quot;</span><br></pre></td></tr></table></figure><ul><li>DisableViaHeader</li></ul><p>指定是否在 Header 中显示 Tinyproxy 相关信息，默认是关闭的。如果开启将不会在 Header 中显示 Tinyproxy 相关信息，相当于 Tinyproxy 是隐身模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#DisableViaHeader Yes</span><br></pre></td></tr></table></figure><ul><li>Filter</li></ul><p>指定设置过滤内容文件的位置，默认为 /etc/tinyproxy/filter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Filter &quot;&#x2F;etc&#x2F;tinyproxy&#x2F;filter&quot;</span><br></pre></td></tr></table></figure><ul><li>FilterURLs</li></ul><p>设置使用 <code>URL</code> 或是域名方式进行过滤，默认是基于 <code>URL</code> 方式过滤的。域名过滤只检查域名段，<code>URL</code> 过滤则检查整个 <code>URL</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterURLs On</span><br></pre></td></tr></table></figure><ul><li>FilterExtended</li></ul><p>设置使用 <code>POSIX</code> 基本或者扩展的正则表达式来匹配过滤规则，默认为使用基本的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># FilterExtended On</span><br></pre></td></tr></table></figure><ul><li>FilterCaseSensitive</li></ul><p>设置是否使用区分大小写的正则表达式，默认为不区分大小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#FilterCaseSensitive On</span><br></pre></td></tr></table></figure><ul><li>FilterDefaultDeny</li></ul><p>设置默认过滤策略。如果将该指令注释掉或设为 No，过滤规则为禁止访问规则。该值默认为 Yes，过滤规则为只允许访问过滤文件中的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterDefaultDeny Yes</span><br></pre></td></tr></table></figure><p>过滤规则配置示例：</p><ol><li>在 /etc/tinyproxy/filter 文件中添加代理允许或拒绝的域名地址。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi-linux.com</span><br></pre></td></tr></table></figure><p>过滤文件中的域名地址也是支持正则表达式的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\.google\.com$</span><br><span class="line">^hi-linux\.com$</span><br></pre></td></tr></table></figure><ol start="2"><li>仅允许代理请求 <a href="http://hi-linux.com" target="_blank" rel="noopener">hi-linux.com</a> 的内容，配置如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filter &quot;&#x2F;etc&#x2F;tinyproxy&#x2F;filter&quot;</span><br><span class="line">FilterURLs On</span><br><span class="line">FilterDefaultDeny Yes</span><br></pre></td></tr></table></figure><ol start="3"><li>仅允许代理请求除 <a href="http://hi-linux.com" target="_blank" rel="noopener">hi-linux.com</a> 域名以外的内容，配置如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filter &quot;&#x2F;etc&#x2F;tinyproxy&#x2F;filter&quot;</span><br><span class="line">FilterURLs On</span><br><span class="line">FilterDefaultDeny No</span><br></pre></td></tr></table></figure><h3 id="运行-tinyproxy">运行 TinyProxy</h3><ul><li>运行 TinyProxy 非常简单，使用官方提供的脚本即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 启动 TinyProxy</span><br><span class="line">$ service tinyproxy start</span><br><span class="line"></span><br><span class="line"># 停止 TinyProxy</span><br><span class="line">$ service tinyproxy stop</span><br><span class="line"></span><br><span class="line"># 重启 TinyProxy</span><br><span class="line">$ service tinyproxy restart</span><br></pre></td></tr></table></figure><ul><li>如果服务器有启用防火墙，记得开放相应的 TinyProxy 端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -I INPUT -p tcp –dport 8888 -j ACCEPT</span><br></pre></td></tr></table></figure><ul><li>查看 TinyProxy 请求日志</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f &#x2F;var&#x2F;log&#x2F;tinyproxy&#x2F;tinyproxy.log</span><br></pre></td></tr></table></figure><ul><li>测试代理是否正常工作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --proxy 192.168.1.100:8888 -k https:&#x2F;&#x2F;www.hi-linux.com&#x2F;</span><br></pre></td></tr></table></figure><p>如果出现对应网页的源代码，则证明代理工作正常。</p><h3 id="参考文档">参考文档</h3><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a><br><a href="http://t.cn/Eaat4mz" target="_blank" rel="noopener">http://t.cn/Eaat4mz</a><br><a href="http://t.cn/EaXdVh9" target="_blank" rel="noopener">http://t.cn/EaXdVh9</a><br><a href="http://t.cn/Eao7ll2" target="_blank" rel="noopener">http://t.cn/Eao7ll2</a><br><a href="http://t.cn/EaobIbE" target="_blank" rel="noopener">http://t.cn/EaobIbE</a><br><a href="http://t.cn/EaoK33b" target="_blank" rel="noopener">http://t.cn/EaoK33b</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，我们常用的 &lt;code&gt;Web&lt;/code&gt; 服务器 &lt;code&gt;Nginx&lt;/code&gt; / &lt;code&gt;Apache&lt;/code&gt; 都可以很方便的用来做为正向或反向代理服务器使用。但是它们都并不支持 &lt;code&gt;HTTPS&lt;/code&gt; 的正向代理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nginx 做为正向代理不支持 HTTPS 的原因是因为 Nginx 没有实现 HTTP 1.1 Connect 方法。隧道的含义大约就是帮助无法完成 TLS 握手的代理服务器透传可以完成 TLS 握手的客户端请求，而不再解析流量中的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于 Connect 和 隧道技术，可详见以下文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RFC 2817 （&lt;a href=&quot;http://t.cn/EaoC0qf%EF%BC%89&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/EaoC0qf）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么是 HTTP 隧道，怎么理解 HTTP 隧道呢？ （&lt;a href=&quot;http://t.cn/EaoCveH%EF%BC%89&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://t.cn/EaoCveH）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天我们来介绍一款同时支持 &lt;code&gt;HTTP/HTTPS&lt;/code&gt; 的轻量级代理软件 &lt;code&gt;TinyProxy&lt;/code&gt;，&lt;code&gt;TinyProxy&lt;/code&gt; 支持以下功能特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持匿名模式。&lt;/li&gt;
&lt;li&gt;支持 HTTPS，可以通过 CONNECT 请求来转发 HTTPS 连接。&lt;/li&gt;
&lt;li&gt;远程监视：可远程查看日志和访问信息。&lt;/li&gt;
&lt;li&gt;负载监视：可配置成当负载达到某个程度时，拒绝新的代理请求。&lt;/li&gt;
&lt;li&gt;访问控制：可设置特定的 IP 地址或者 IP 段才可访问。&lt;/li&gt;
&lt;li&gt;安全：不需要 root 权限。&lt;/li&gt;
&lt;li&gt;轻量化：只需要极小的系统资源。&lt;/li&gt;
&lt;li&gt;支持基于 URL 的过滤。&lt;/li&gt;
&lt;li&gt;支持透明代理。&lt;/li&gt;
&lt;li&gt;支持多级代理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TinyProxy 项目地址：&lt;a href=&quot;https://github.com/tinyproxy/tinyproxy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/tinyproxy/tinyproxy&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装-TinyProxy&quot;&gt;安装 TinyProxy&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过软件包安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;TinyProxy&lt;/code&gt; 目前已支持大多数发行版通过软件包安装，下面介绍下比较常用的几个平台的安装方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS / RHEL&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 需要 EPEL 仓库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ yum install -y tinyproxy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu / Debian&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-get -y install tinyproxy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你使用的是其它平台，更多的安装方式可直接参考官方文档：&lt;a href=&quot;https://tinyproxy.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tinyproxy.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;通过源码安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你使用的平台，官方还不支持通过软件包安装。你也可以通过源码进行编译安装。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;tinyproxy&amp;#x2F;tinyproxy.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd tinyproxy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ .&amp;#x2F;autogen.sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ .&amp;#x2F;configure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ make&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ make install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="代理" scheme="https://www.hi-linux.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux 爱好者周刊 ( 第 6 期 )</title>
    <link href="https://www.hi-linux.com/posts/27164.html"/>
    <id>https://www.hi-linux.com/posts/27164.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.404Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。</p><p>欢迎投稿或推荐你自己的项目，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a> 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247487968&amp;idx=2&amp;sn=476c03c6edfae6907020c23094496791&amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;token=1973230270&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这里</a>」加入技术交流群。</p><h2 id="业界资讯">业界资讯</h2><p>1、<a href="https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html" target="_blank" rel="noopener">华为正式发布方舟编译器，相关源码已开放下载</a></p><p>华为正式对外发布了此前已经对外公布的编译工具——方舟编译器。方舟编译器是基于 GCC（GNU Compiler Collection，GNU 编译器套件） 开发的交叉编译器套件，它包括了 C、C++、Fortran 的前端，也包括了这些语言的库（如 libstdc++、libgcc 等）。HCC（即华为方舟编译器） 运行在 X86 Linux 架构服务器上，生成的二进制运行在 Aarch64 架构服务器上。</p><p>链接：<a href="https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html" target="_blank" rel="noopener">https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html</a></p><p><img src="https://i.loli.net/2019/08/06/FjlqCm9bU4iWBS1.png" alt=""></p><p>2、<a href="https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release" target="_blank" rel="noopener">Windows Terminal 0.3 发布：一系列改进和错误修复</a></p><p>Windows terminal 0.3 更新已经在 Microsoft Store 发布。提供了一系列改进和错误修复，包括拖动标题栏、自定义选项卡标题等功能。</p><p>链接：<a href="https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release" target="_blank" rel="noopener">https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release</a></p><p><img src="https://i.loli.net/2019/08/06/3DCA6SmwLjbUyog.jpg" alt=""></p><p>3、<a href="https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products" target="_blank" rel="noopener">Google 更新图片搜索：全新预览设计及更多产品细节</a></p><p>Google 更新了全新的图片搜索界面，主要的改变是让比较不同的照片变得更容易。最直观的差异，就是点选图片后原本是在下面展开一个详细内容的深色横条，而现在则是被改成在右边栏展开了。如此一来，当你继续向下卷动时，之前点选的图片会继续留在右边，让你和新出现的图片做比较。</p><p>链接：<a href="https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products" target="_blank" rel="noopener">https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products</a></p><p><img src="https://i.loli.net/2019/08/07/9rTXN3E5qQAbWSu.jpg" alt=""></p><p>4、<a href="https://tech.qq.com/a/20190807/005725.htm" target="_blank" rel="noopener">支付宝/微信均上线电子结婚证</a></p><p>近日，支付宝宣布已有 5 省市上线电子结婚证。已经登记结婚的夫妻，上支付宝搜 “电子结婚证”，进入当地一网通办小程序，选择电子证件，刷脸就能领取到和实体证相对应的电子结婚证。同时也可办理补领婚姻证预约、婚姻登记信息核验等服务。福建、江西、江苏、浙江、重庆 5 省市首批支持。</p><p>链接：<a href="https://www.pingwest.com/w/192406" target="_blank" rel="noopener">https://www.pingwest.com/w/192406</a></p><p><img src="https://i.loli.net/2019/08/07/u6s9yPCTZfNaxE5.jpg" alt=""></p><p>据悉，全国 14 省市用户现已可通过 “中国政务服务平台” 微信小程序 “刷脸” 关联电子结婚证。目前支持北京、河北、上海、江苏、浙江、安徽、湖北、江西、湖南、广东、重庆、四川、贵州、福建等省市的用户。</p><p>链接：<a href="https://tech.qq.com/a/20190807/005725.htm" target="_blank" rel="noopener">https://tech.qq.com/a/20190807/005725.htm</a></p><p><img src="https://i.loli.net/2019/08/07/3s4oF8vApW1x65z.jpg" alt=""></p><p>5、<a href="https://segmentfault.com/a/1190000019975092" target="_blank" rel="noopener">灵雀云开源 Helm v3 Controller 组件 Captain，完善云原生应用管理功能</a></p><p>近日，灵雀云宣布发布 Helm v3 Controller 组件 “Captain”，并正式将其在 Github 上开源。Captain 是 Helm 官方社区发布的 Helm v3 proposal 的第一个 Controller 实现示例，帮助用户简化 Helm 资源描述，更便捷、高效地实现 K8s 应用的管理和控制，推进 Helm 项目向原生 K8s 迈进的步伐。目前 Captain 项目代码已经在Github 上开源，项目地址为：<a href="https://github.com/alauda/captain%E3%80%82" target="_blank" rel="noopener">https://github.com/alauda/captain。</a></p><p>链接：<a href="https://segmentfault.com/a/1190000019975092" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019975092</a></p><p><img src="https://i.loli.net/2019/08/08/qF5p3gyzrQ4VIRt.jpg" alt=""></p><p>6、<a href="https://www.solidot.org/story?sid=61641" target="_blank" rel="noopener">Let’s Encrypt 推出中文版</a></p><p>旨在让每个网站都能使用 HTTPS 加密的非赢利组织 Let’s Encrypt 发布了简体中文版，方便中文用户使用 Let’s Encrypt 签发的证书 。中文版主要是汉化了一下主页和文档，而文档实际上还没有完成翻译，感兴趣的志愿者可以通过 GitHub 帮助它翻译网站文档。Let’s Encrypt 目前支持包括中文在内的七种语言，它的证书已获得了主要浏览器开发商的信任。</p><p>链接：<a href="https://www.solidot.org/story?sid=61641" target="_blank" rel="noopener">https://www.solidot.org/story?sid=61641</a></p><p><img src="https://i.loli.net/2019/08/08/ptWmNUMJy5QACqB.png" alt=""></p><p>7、<a href="https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china" target="_blank" rel="noopener">中国首个开源协议诞生，比 Apache 许可证友好</a></p><p>近日，中国开源云联盟官网上线了 “木兰宽松许可证”（MulanPSL），据传这是中国首个开源协议。木兰宽松许可证第 1 版包含了版权许可、专利许可和无商标许可，可自由重新分发，但必须提供许可证的副本，并保留版权、商标、专利及免责声明。许可具体内容请查看：<a href="http://license.coscl.org.cn/MulanPSL%E3%80%82" target="_blank" rel="noopener">http://license.coscl.org.cn/MulanPSL。</a></p><p>链接：<a href="https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china" target="_blank" rel="noopener">https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china</a></p><p><img src="https://i.loli.net/2019/08/08/xAsLIPBby4zGjW7.png" alt=""></p><a id="more"></a><h2 id="趣站酷软">趣站酷软</h2><p>1、<a href="https://github.com/redhat-developer/vscode-yaml" target="_blank" rel="noopener">YAML</a></p><p>这是一个 YAML 语法高亮的 VSCode 插件，支持 Kubernetes 和 Kedge 语法，由 Red Hat 开发的。要支持 Kubernetes 语法，需要先安装 VSCode 的 Kubernetes 插件。</p><p>项目地址: <a href="https://github.com/redhat-developer/vscode-yaml" target="_blank" rel="noopener">https://github.com/redhat-developer/vscode-yaml</a></p><p><img src="https://i.loli.net/2019/08/08/bBYNMdRvFOS2uk5.jpg" alt=""></p><p>2、<a href="https://github.com/zeromake/docker-debug" target="_blank" rel="noopener">docker-debug</a></p><p>docker-debug 是一个运行中 Docker 容器的故障排除程序，它允许用户在 Docker 中运行新容器以进行调试，并将目标容器的 pid, network, uses, filesystem 和 ipc 命名空间注入到新的容器里。因此，您可以使用任意故障排除工具，而无需在生产容器镜像中预先安装额外的工具环境。</p><p>项目地址: <a href="https://github.com/zeromake/docker-debug" target="_blank" rel="noopener">https://github.com/zeromake/docker-debug</a></p><p><img src="https://i.loli.net/2019/08/08/hBAvsOcEo6ILjNR.jpg" alt=""></p><p>3、<a href="https://github.com/robscott/kube-capacity" target="_blank" rel="noopener">kube-capacity</a></p><p>kube-capacity 是一个简单的 CLI 工具，它概述了 Kubernetes 集群中的资源请求、限制和利用率。它将 kubectl top 和 kubectl describe 的最佳部分组合到一个易于使用的 CLI 中，方便集群资源的管理。</p><p>项目地址: <a href="https://github.com/robscott/kube-capacity" target="_blank" rel="noopener">https://github.com/robscott/kube-capacity</a></p><p><img src="https://i.loli.net/2019/08/08/IOjD9V8xXs1eGhN.png" alt=""></p><p>4、<a href="https://github.com/donnemartin/gitsome" target="_blank" rel="noopener">gitsome</a></p><p>一个非常实用的 GitHub 命令行工具，支持在命令行中查看 GitHub 通知、搜索创建 Issue、浏览动态、生成 LICENSE 等，功能十分强大。如果你是 GitHub 重度用户，那相信你一定会爱上这个工具。</p><p>项目地址：<a href="https://github.com/donnemartin/gitsome" target="_blank" rel="noopener">https://github.com/donnemartin/gitsome</a></p><p><img src="https://i.loli.net/2019/08/08/NtacI6Zf12kzHEK.gif" alt=""></p><p>5、<a href="https://github.com/dutchcoders/transfer.sh" target="_blank" rel="noopener">Transfer.sh</a></p><p><a href="http://Transfer.sh" target="_blank" rel="noopener">Transfer.sh</a> 是一个简单、方便快捷的命令行文件分享服务。只需要一条命令就可以将文件快速分享出去，它允许您免费上传最大 10GB 的数据，文件可以存储 14 天。</p><p>项目地址：<a href="https://github.com/dutchcoders/transfer.sh" target="_blank" rel="noopener">https://github.com/dutchcoders/transfer.sh</a></p><p><img src="https://i.loli.net/2019/08/08/WRfxCA4iXQ5vSzG.jpg" alt=""></p><p>6、<a href="https://github.com/DimitarPetrov/stegify" target="_blank" rel="noopener">stegify</a></p><p>一款神奇的命令行工具，能将任意文件隐藏到图片里面。</p><p>项目地址：<a href="https://github.com/DimitarPetrov/stegify" target="_blank" rel="noopener">https://github.com/DimitarPetrov/stegify</a></p><p>来看一个示例：第 3 张图片为 1、2 两张图片合成的，但是从视觉上却完全看不到第 2 张图片的存在。</p><p><img src="https://i.loli.net/2019/08/08/x9PgGb2AMy3D8k7.jpg" alt=""></p><p>7、<a href="https://github.com/instantbox/instantbox" target="_blank" rel="noopener">Instantbox</a></p><p>Instantbox 是一个基于 Docker 的临时 Linux 系统创建工具，它可以快速创建一个开箱即用的 Linux 系统。目前 Instantbox 支持了 Ubuntu、CentOS、Debian、Alpine 等主流系统。</p><p>项目地址：<a href="https://github.com/instantbox/instantbox" target="_blank" rel="noopener">https://github.com/instantbox/instantbox</a></p><p><img src="https://i.loli.net/2019/08/08/FGgbs1R6pAKzPoH.jpg" alt=""></p><p>8、<a href="https://github.com/vvo/gifify" target="_blank" rel="noopener">gifify</a></p><p>gifify 是一款将视频转换成 GIF 图片的工具，支持任何格式的视频以及选取某个时间段进行转换。</p><p>项目地址：<a href="https://github.com/vvo/gifify" target="_blank" rel="noopener">https://github.com/vvo/gifify</a></p><p><img src="https://i.loli.net/2019/08/08/poyJj5ZNIbWQhGz.jpg" alt=""></p><p>9、<a href="https://github.com/zdict/zdict" target="_blank" rel="noopener">zdict</a></p><p>一个运行在终端的在线字典工具，支持多款字典切换查询，并支持查询结果高亮。</p><p>项目地址：<a href="https://github.com/zdict/zdict" target="_blank" rel="noopener">https://github.com/zdict/zdict</a></p><p><img src="https://i.loli.net/2019/08/08/iKC7zIaMAog21mf.jpg" alt=""></p><h2 id="技术文章">技术文章</h2><p>1、<a href="https://github.com/0voice/from_coder_to_expert" target="_blank" rel="noopener">2019 年各互联网大厂最新内部技术分享的文档集合</a></p><p>2019 年各互联网大厂最新内部技术分享的文档 PDF、PPT 集合。从程序员到 CTO，从专业走向卓越。</p><p>链接：<a href="https://github.com/0voice/from_coder_to_expert" target="_blank" rel="noopener">https://github.com/0voice/from_coder_to_expert</a></p><p><img src="https://i.loli.net/2019/08/01/5d42a33fbc4d259157.png" alt=""></p><p>2、<a href="http://www.tianshouzhi.com/api/tutorials/canal/404" target="_blank" rel="noopener">异地多活场景下的数据同步之道</a></p><p>在当今互联网行业，大多数人互联网从业者对&quot;单元化&quot;、&quot;异地多活&quot;这些词汇已经耳熟能详。而数据同步是异地多活的基础，所有具备数据存储能力的组件如：数据库、缓存、MQ等，数据都可以进行同步，形成一个庞大而复杂的数据同步拓扑。</p><p>本文将先从概念上介绍单元化、异地多活、就近访问等基本概念。之后，将以数据库为例，讲解在数据同步的情况下，如何解决数据回环、数据冲突、数据重复等典型问题。</p><p>链接：<a href="http://www.tianshouzhi.com/api/tutorials/canal/404" target="_blank" rel="noopener">http://www.tianshouzhi.com/api/tutorials/canal/404</a></p><p><img src="https://i.loli.net/2019/08/08/syufeXaqUDE4ISc.png" alt=""></p><p>3、<a href="https://github.com/hcymysql/mgr_failover_vip" target="_blank" rel="noopener">MySQL 8.0 MGR（组复制）高可用 VIP 切换脚本</a></p><p>MGR（组复制）官方推荐用 MySQL Router 中间件去做 MGR 高可用故障转移，但其多过了一层网络，会造成性能下降。并且需要额外维护一套中间件，运维成本过高。本文将介绍一个类似 MHA 的 master_ip_failover 脚本的方法来实现 VIP 切换。</p><p>链接：<a href="https://github.com/hcymysql/mgr_failover_vip" target="_blank" rel="noopener">https://github.com/hcymysql/mgr_failover_vip</a></p><h2 id="每周观点">每周观点</h2><p>1、知识使人自由，或者起码渴望自由。—— 特雷弗·诺亚「天生有罪」</p><p>2、失败只是给了我们一个重新开始的机会，而这次我们变得更加聪明。—— 亨利·福特</p><p>3、如果人们过度重视决策的直接结果而忽视后续和再后续的结果，他们就很难实现目标。这是因为直接结果和后续结果的值得追求性通常是相反的，这会造成决策的重大错误。—— 雷·达里欧</p><p>4、生活坏到一定程度就会好起来，因为它无法更坏。努力过后，才知道许多事情，坚持坚持就过来了。—— 宫崎骏「龙猫」</p><p>5、生命可以随心所欲，但不能随波逐流。—— 宫崎骏「猫的报恩」</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将分享一些最新运维相关技术和业界资讯的精彩内容，每周五发布。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐你自己的项目，投稿邮箱: &lt;a href=&quot;mailto:editor@hi-linux.com&quot;&gt;editor@hi-linux.com&lt;/a&gt; 。如果你对周刊有什么建议和意见，或者想与大家一起讨论技术问题，也可以戳「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247487968&amp;amp;idx=2&amp;amp;sn=476c03c6edfae6907020c23094496791&amp;amp;chksm=eac530c9ddb2b9dfa28b928a36b38c24dc40969accffc6e634592e97f7f9c85bfa0d30bb1a55&amp;amp;token=1973230270&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;」加入技术交流群。&lt;/p&gt;
&lt;h2 id=&quot;业界资讯&quot;&gt;业界资讯&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;华为正式发布方舟编译器，相关源码已开放下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为正式对外发布了此前已经对外公布的编译工具——方舟编译器。方舟编译器是基于 GCC（GNU Compiler Collection，GNU 编译器套件） 开发的交叉编译器套件，它包括了 C、C++、Fortran 的前端，也包括了这些语言的库（如 libstdc++、libgcc 等）。HCC（即华为方舟编译器） 运行在 X86 Linux 架构服务器上，生成的二进制运行在 Aarch64 架构服务器上。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.leiphone.com/news/201908/VAOO46axcJNNiTcL.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/06/FjlqCm9bU4iWBS1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows Terminal 0.3 发布：一系列改进和错误修复&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows terminal 0.3 更新已经在 Microsoft Store 发布。提供了一系列改进和错误修复，包括拖动标题栏、自定义选项卡标题等功能。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-3-release&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/06/3DCA6SmwLjbUyog.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google 更新图片搜索：全新预览设计及更多产品细节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google 更新了全新的图片搜索界面，主要的改变是让比较不同的照片变得更容易。最直观的差异，就是点选图片后原本是在下面展开一个详细内容的深色横条，而现在则是被改成在右边栏展开了。如此一来，当你继续向下卷动时，之前点选的图片会继续留在右边，让你和新出现的图片做比较。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.engadget.com/2019/08/06/google-updates-images-to-make-it-easier-to-compare-products&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/07/9rTXN3E5qQAbWSu.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://tech.qq.com/a/20190807/005725.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;支付宝/微信均上线电子结婚证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，支付宝宣布已有 5 省市上线电子结婚证。已经登记结婚的夫妻，上支付宝搜 “电子结婚证”，进入当地一网通办小程序，选择电子证件，刷脸就能领取到和实体证相对应的电子结婚证。同时也可办理补领婚姻证预约、婚姻登记信息核验等服务。福建、江西、江苏、浙江、重庆 5 省市首批支持。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.pingwest.com/w/192406&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.pingwest.com/w/192406&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/07/u6s9yPCTZfNaxE5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;据悉，全国 14 省市用户现已可通过 “中国政务服务平台” 微信小程序 “刷脸” 关联电子结婚证。目前支持北京、河北、上海、江苏、浙江、安徽、湖北、江西、湖南、广东、重庆、四川、贵州、福建等省市的用户。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://tech.qq.com/a/20190807/005725.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tech.qq.com/a/20190807/005725.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/07/3s4oF8vApW1x65z.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://segmentfault.com/a/1190000019975092&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;灵雀云开源 Helm v3 Controller 组件 Captain，完善云原生应用管理功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，灵雀云宣布发布 Helm v3 Controller 组件 “Captain”，并正式将其在 Github 上开源。Captain 是 Helm 官方社区发布的 Helm v3 proposal 的第一个 Controller 实现示例，帮助用户简化 Helm 资源描述，更便捷、高效地实现 K8s 应用的管理和控制，推进 Helm 项目向原生 K8s 迈进的步伐。目前 Captain 项目代码已经在Github 上开源，项目地址为：&lt;a href=&quot;https://github.com/alauda/captain%E3%80%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/alauda/captain。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://segmentfault.com/a/1190000019975092&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000019975092&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/08/qF5p3gyzrQ4VIRt.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://www.solidot.org/story?sid=61641&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Let’s Encrypt 推出中文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;旨在让每个网站都能使用 HTTPS 加密的非赢利组织 Let’s Encrypt 发布了简体中文版，方便中文用户使用 Let’s Encrypt 签发的证书 。中文版主要是汉化了一下主页和文档，而文档实际上还没有完成翻译，感兴趣的志愿者可以通过 GitHub 帮助它翻译网站文档。Let’s Encrypt 目前支持包括中文在内的七种语言，它的证书已获得了主要浏览器开发商的信任。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.solidot.org/story?sid=61641&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.solidot.org/story?sid=61641&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/08/ptWmNUMJy5QACqB.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&quot;https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中国首个开源协议诞生，比 Apache 许可证友好&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近日，中国开源云联盟官网上线了 “木兰宽松许可证”（MulanPSL），据传这是中国首个开源协议。木兰宽松许可证第 1 版包含了版权许可、专利许可和无商标许可，可自由重新分发，但必须提供许可证的副本，并保留版权、商标、专利及免责声明。许可具体内容请查看：&lt;a href=&quot;http://license.coscl.org.cn/MulanPSL%E3%80%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://license.coscl.org.cn/MulanPSL。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/108840/mulanpsl-the-1st-opensource-license-of-china&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/08/xAsLIPBby4zGjW7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="周刊" scheme="https://www.hi-linux.com/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>50 个你必须掌握的 Kubernetes 面试题</title>
    <link href="https://www.hi-linux.com/posts/2742.html"/>
    <id>https://www.hi-linux.com/posts/2742.html</id>
    <published>2020-05-16T01:00:00.000Z</published>
    <updated>2020-05-16T10:12:40.281Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Kubernetes 一直是当今业界的流行语，也是最好的编排工具。它吸引了许多想要提升自己职业生涯的经验丰富的专业人士。</p><p>Huwaei、Pokemon、Box、eBay、Ing、Yahoo Japan、SAP、纽约时报、Open AI、Sound Cloud 等跨国公司也使用 Kubernetes。我相信你已经知道这些事实，这也是促使你打开这个 Kubernetes 面试问题文章原因。</p><p>在这篇关于 Kubernetes 面试问题的文章中，我将讨论在面试中提出的与 Kubernetes 相关的最重要问题。因此，为了您的理解，我将此文内容分为以下 4 个部分：</p><ul><li>Kubernetes 基本面试问题</li><li>基于架构的面试问题</li><li>基于场景的面试问题</li><li>多项选择题</li></ul><p>现在，让我们开始吧!</p><h2 id="基本的-kubernetes-面试问题">基本的 Kubernetes 面试问题</h2><p>这部分问题将包含您需要了解的与 Kubernetes 工作相关的所有基本问题。</p><p><strong>Q1、Kubernetes 与 Docker Swarm 的区别如何？</strong></p><p><img src="https://miro.medium.com/max/700/1*xzLZVPBlFvLsVPaqtracvw.png" alt=""></p><p><strong>Q2、什么是 Kubernetes？</strong></p><p><img src="https://miro.medium.com/max/321/1*jhzU7LO0pvfMJzrViu6tiA.png" alt=""></p><p>Kubernetes 是一个开源容器管理工具，负责容器部署，容器扩缩容以及负载平衡。作为 Google 的创意之作，它提供了出色的社区，并与所有云提供商合作。因此，我们可以说 Kubernetes 不是一个容器化平台，而是一个多容器管理解决方案。</p><p><strong>Q3、Kubernetes 与 Docker 有什么关系？</strong></p><p>众所周知，Docker 提供容器的生命周期管理和 Docker 镜像构建运行时容器。但是，由于这些单独的容器有时必须跨主机通信，这时我们需要使用 Kubernetes 来解决这个问题。</p><p>因此，我们说 Docker 构建容器，但这些容器通过 Kubernetes 来进行跨主机相互通信。我们还可以使用 Kubernetes 手动关联和编排在多个主机上运行的容器。</p><p><strong>Q4、在主机和容器上部署应用程序有什么区别？</strong></p><p><img src="https://miro.medium.com/max/700/1*R_5hio_I-hK4f-bOfTHstA.png" alt=""></p><p>请参考上图。左侧架构表示在主机上部署应用程序。因此，这种架构将具有操作系统，然后操作系统将具有内核，该内核将在应用程序所需的操作系统上安装各种库。因此，在这种框架中，您可以拥有 N 个应用程序，并且所有应用程序将共享该操作系统中存在的库，而在容器中部署应用程序时，体系结构则略有不同。</p><p>这种架构将有一个内核，这是唯一一个在所有应用程序之间唯一共同的东西。因此，如果有一个需要 Java 的特定应用程序，那么我们将获得访问 Java 的特定应用程序，如果有另一个需要 Python 的应用程序，则只有该特定应用程序才能访问 Python。</p><p>您可以在图表右侧看到的各个块基本上是容器化的，并且这些块与其他应用程序隔离。因此，应用程序具有与系统其余部分隔离的必要库和二进制文件，并且不能被任何其他应用程序侵占。</p><a id="more"></a><p><strong>Q5、什么是 Container Orchestration？</strong></p><p>考虑一个应用程序有 5-6 个微服务的场景。</p><p>现在，这些微服务被放在单独的容器中，但如果没有容器编排就无法进行通信。因此，由于编排意味着所有乐器在音乐中和谐共处，所以类似的容器编排意味着各个容器中的所有服务协同工作以满足单个服务器的需求。</p><p><strong>Q6、Container Orchestration 需要什么？</strong></p><p>考虑到你有 5-6 个微服务用于执行各种任务的单个应用程序，所有这些微服务都放在容器中。现在，为了确保这些容器彼此通信，我们需要容器编排。</p><p><img src="https://miro.medium.com/max/700/1*69m4EpkxBFafy7tdu6gxjA.png" alt=""></p><p>正如您在上图中所看到的，在没有使用容器编排的情况下，还存在许多挑战。因此，为了克服这些挑战，容器编排就到位了。</p><p><strong>Q7、Kubernetes 有什么特点？</strong></p><p>Kubernetes 的功能如下：</p><p><img src="https://miro.medium.com/max/700/1*MNasEMnDO45erWjsQXCJ_Q.png" alt=""></p><p><strong>Q8、Kubernetes 如何简化容器化部署？</strong></p><p>由于典型应用程序将具有跨多个主机运行的容器集群，因此所有这些容器都需要相互通信。因此，要做到这一点，你需要一些能够负载均衡、扩展和监控容器的东西。</p><p>由于 Kubernetes 与云无关并且可以在任何公共/私有提供商上运行，因此必须是您简化容器化部署的选择。</p><p><strong>Q9、您对 Kubernetes 的集群了解多少？</strong></p><p>Kubernetes 背后的基础是我们可以实施所需的状态管理，我的意思是我们可以提供特定配置的集群服务，并且集群服务将在基础架构中运行并运行该配置。</p><p><img src="https://miro.medium.com/max/700/1*FSWh9wJLuVuKcXQB97xiJA.png" alt=""></p><p>因此，正如您在上图中所看到的，部署文件将具有提供给集群服务所需的所有配置。</p><p>现在，部署文件将被提供给 API，然后由集群服务决定如何在环境中安排这些 Pod，并确保正确运行的 Pod 的数量。</p><p>因此，位于服务前面的 API，工作节点和节点运行的 Kubelet 进程，共同构成了 Kubernetes 集群。</p><p><strong>Q10、什么是 Google 容器引擎？</strong></p><p>Google Container Engine（GKE）是 Docker 容器和集群的开源管理平台。这个基于 Kubernetes 的引擎仅支持在 Google 的公共云服务中运行的群集。</p><p><strong>Q11、什么是 Heapster？</strong></p><p>Heapster 是由每个节点上运行的 Kubelet 提供的集群范围的数据聚合器。</p><p>此容器管理工具在 Kubernetes 集群上本机支持，并作为 Pod 运行，就像集群中的任何其他 Pod 一样。因此，它基本上可以发现集群中的所有节点，并通过本机上 Kubernetes 代理查询集群中 Kubernetes 节点的使用信息。</p><p><strong>Q12、什么是 Minikube？</strong></p><p>Minikube 是一种工具，可以在本地轻松运行 Kubernetes 集群。它是在虚拟机中运行一个单节点 Kubernetes 群集。</p><p><strong>Q13、什么是 Kubectl？</strong></p><p>Kubectl 是一个命令行工具，您可以使用该工具将命令传递给集群。</p><p>因此，它基本上为 CLI 提供了针对 Kubernetes 集群运行命令的方法，以及创建和管理 Kubernetes 组件的各种方法。</p><p><strong>Q14、什么是 Kubelet？</strong></p><p>这是一个代理服务，它在每个节点上运行，并使从服务器与主服务器通信。因此，Kubelet 处理 PodSpec 中提供给它的容器的描述，并确保 PodSpec 中描述的容器运行正常。</p><p><strong>Q15、你对 Kubernetes 的一个节点有什么了解？</strong></p><p><img src="https://miro.medium.com/max/700/1*zH_jWTgLYnXyOgMVF4NUqw.png" alt=""></p><h2 id="基于-kubernetes-架构的问题">基于 Kubernetes 架构的问题</h2><p>这部分问题将涉及到与 Kubernetes 架构相关的问题。</p><p><strong>Q1、Kubernetes Architecture 的不同组件有哪些？</strong></p><p>Kubernetes Architecture 主要有两个组件：主节点和工作节点。</p><p>如下图所示，Master 和 Worker 节点中包含许多内置组件。主节点具有 kube-controller-manager、kube-apiserver、kube-scheduler 等。而工作节点具有在每个节点上运行的 kubelet 和 kube-proxy。</p><p><img src="https://miro.medium.com/max/700/1*AhUFtwKbexYirzGpsig10A.png" alt=""></p><p><strong>Q2、你对 Kube-proxy 有什么了解？</strong></p><p>Kube-proxy 可以在每个节点上运行，并且可以跨后端网络服务进行简单的 TCP/UDP 数据包转发。</p><p>基本上，它是一个网络代理，它反映了每个节点上 Kubernetes API 中配置的服务。因此，Docker 可链接的兼容环境变量由代理打开的群集 IP 和端口提供。</p><p><strong>Q3、您能否介绍一下 Kubernetes 中主节点的工作情况？</strong></p><p>Kubernetes master 控制器存在的节点和节点内部。现在，这些单独的容器包含在容器内部和每个容器内部，您可以根据配置和要求拥有不同数量的容器。</p><p>因此，如果必须部署 Pod，则可以使用用户界面或命令行界面部署它们。然后，在节点上调度这些 Pod，并根据资源需求将 Pod 分配给这些节点。</p><p>Kube-apiserver 确保在 Kubernetes 节点和主要组件之间建立通信。</p><p><img src="https://miro.medium.com/max/700/1*sik3NLZD5_0ZwsVgNfgwSw.png" alt=""></p><p><strong>Q4、Kube-apiserver 和 Kube-scheduler 的作用是什么？</strong></p><p>Kube-apiserver 遵循横向扩展架构，是主节点控制面板的前端。这将公开 Kubernetes 主节点组件的所有 API，并负责在 Kubernetes 节点和 Kubernetes 主组件之间建立通信。</p><p>kube-scheduler 负责工作节点上工作负载的分配和管理。因此，它根据资源需求选择最合适的节点来运行未调度的 Pod，并跟踪资源利用率。它确保不在已满的节点上调度工作负载。</p><p><strong>Q5、你能简要介绍一下 Kubernetes 控制管理器吗？</strong></p><p>多个控制器进程在主节点上运行，但是一起编译为单个进程运行，即 Kubernetes 控制器管理器。因此，Controller Manager 是一个嵌入控制器并执行命名空间创建和垃圾收集的守护程序。它拥有与 API 服务器通信以管理端点的责任。</p><p>因此，主节点上运行的不同类型的控制器管理器是：</p><p><img src="https://miro.medium.com/max/700/1*a80TjjE7oav01nAtfW271A.png" alt=""></p><p><strong>Q6、什么是 Etcd？</strong></p><p>Etcd 是用 Go 编程语言编写的一个分布式键值存储，用于协调分布式工作的软件。因此，Etcd 用来存储 Kubernetes 集群的配置数据，这些数据代表在任何给定时间点的集群状态。</p><p><strong>Q7、Kubernetes 有哪些不同类型的服务？</strong></p><p>以下是使用的不同类型的服务：</p><p><img src="https://miro.medium.com/max/700/1*aiJ1kIkna1MP3Lcy2RqFYw.png" alt=""></p><p><strong>Q8、你对 Kubernetes 的负载均衡器有什么了解？</strong></p><p>负载均衡器是暴露服务的最常见和标准方式之一。</p><p>根据工作环境使用两种类型的负载均衡器，即内部负载均衡器或外部负载均衡器。内部负载均衡器自动平衡负载并使用所需配置分配容器，而外部负载均衡器将流量从外部负载引导至后端容器。</p><p><strong>Q9、什么是 Ingress 网络，它是如何工作的？</strong></p><p>Ingress 网络是一组规则，充当 Kubernetes 集群的入口点。</p><p>这允许入站连接，可以将其配置为通过可访问的 URL 负载平衡流量或通过提供基于名称的虚拟主机从外部提供服务。因此，Ingress 是一个API对象，通常通过 HTTP 管理集群中服务的外部访问，是暴露服务的最有效方式。</p><p>现在，让我以一个例子向您解释 Ingress 网络的工作。</p><p>有 2 个节点具有带有 Linux 桥接器的 Pod 和根网络命名空间。除此之外，还有一个名为 flannel0（网络插件）的新虚拟以太网设备被添加到根网络中。</p><p>现在，假设我们希望数据包从 Pod1 流向 Pod4。请参阅下图：</p><p><img src="https://miro.medium.com/max/700/1*9myghoRGWbV6ReilzUOuuA.png" alt=""></p><ul><li><p>因此，数据包将 Pod1 的网络保留在 eth0，并进入 veth0 的根网络。</p></li><li><p>然后它被传递给 cbr0，这使得 ARP 请求找到目的地，并且发现该节点上没有人具有目的地 IP 地址。</p></li><li><p>因此，桥接器将数据包发送到 flannel0，因为节点的路由表配置了 flannel0。</p></li><li><p>现在，flannel 守护程序与 Kubernetes 的 API 服务器通信，以了解所有 Pod IP 及其各自的节点，以创建 Pods IP 到节点 IP 的映射。</p></li><li><p>网络插件将此数据包封装在 UDP 数据包中，其中额外的标头将源和目标 IP 更改为各自的节点，并通过 eth0 发送此数据包。</p></li><li><p>现在，由于路由表已经知道如何在节点之间路由流量，因此它将数据包发送到目标节点2。</p></li><li><p>数据包到达 node2 的 eth0 并返回到 flannel0 以解封装并在根网络命名空间中将其发回。</p></li><li><p>同样，数据包被转发到 Linux 网桥以发出 ARP 请求以找出属于 veth1 的 IP。</p></li><li><p>数据包最终穿过根网络并到达目标 Pod4。</p></li></ul><p><strong>Q10、您对云控制器管理器有何了解？</strong></p><p>Cloud Controller Manager 负责持久存储、网络路由，从核心 Kubernetes 特定代码中抽象出特定于云的代码，以及管理与底层云服务的通信。</p><p>它可能会分成几个不同的容器，具体取决于您运行的是哪个云平台，然后它可以使云供应商和 Kubernetes 代码在没有任何相互依赖的情况下开发。因此，云供应商开发他们的代码并在运行 Kubernetes 时与 Kubernetes 云控制器管理器连接。</p><p>各种类型的云控制器管理器如下：</p><p><img src="https://miro.medium.com/max/700/1*dDqDw5-B23iyHX1nnmiitQ.png" alt=""></p><p><strong>Q11、什么是 Container 资源监控？</strong></p><p>对于用户而言，了解应用程序的性能和所有不同抽象层的资源利用率非常重要，Kubernetes 通过在容器、Pod、服务和整个集群等不同级别创建抽象来考虑集群的管理。现在，可以监视每个级别，这只是容器资源监视。</p><p>各种容器资源监控工具如下：</p><p><img src="https://miro.medium.com/max/700/1*kKjL4d5289z4f6jwdf9DUw.png" alt=""></p><p><strong>Q12、Replica Set 和 Replication Controller 之间有什么区别？</strong></p><p>Replica Set 和 Replication Controller 几乎完全相同。它们都确保在任何给定时间运行指定数量的 Pod 副本。不同之处在于复制 Pod 使用的选择器。Replica Set 使用基于集合的选择器，而 Replication Controller 使用基于权限的选择器。</p><ul><li><p>Equity-Based 选择器：这种类型的选择器允许按标签键和值进行过滤。因此，在外行术语中，基于 Equity 的选择器将仅查找与标签具有完全相同短语的 Pod。 示例：假设您的标签键表示 app = nginx，那么使用此选择器，您只能查找标签应用程序等于 nginx 的那些 Pod。</p></li><li><p>Selector-Based 选择器：此类型的选择器允许根据一组值过滤键。因此，换句话说，基于 Selector 的选择器将查找已在集合中提及其标签的 Pod。 示例：假设您的标签键在（nginx、NPS、Apache）中显示应用程序。然后，使用此选择器，如果您的应用程序等于任何 nginx、NPS或 Apache，则选择器将其视为真实结果。</p></li></ul><p><strong>Q13、什么是 Headless Service？</strong></p><p>Headless Service 类似于 “普通” 服务，但没有群集 IP。此服务使您可以直接访问 Pod，而无需通过代理访问它。</p><p><strong>Q14、使用 Kubernetes 时可以采取哪些最佳安全措施？</strong></p><p>以下是使用 Kubernetes 时可以遵循的最佳安全措施：</p><p><img src="https://miro.medium.com/max/700/1*YxuRlWza8917nABh6sqw2g.png" alt=""></p><p><strong>Q15、什么是集群联邦？</strong></p><p>在联邦集群的帮助下，可以将多个 Kubernetes 集群作为单个集群进行管理。因此，您可以在数据中心/云中创建多个 Kubernetes集群，并使用联邦来在一个位置控制/管理它们。</p><p>联邦集群可以通过执行以下两项操作来实现此目的。请参考下图。</p><p><img src="https://miro.medium.com/max/700/1*q5lG05884iXhzZfU15gPKA.png" alt=""></p><h2 id="基于场景的面试问题">基于场景的面试问题</h2><p>这部分问题将包含您在面试中可能遇到的各种基于场景的问题。</p><p><strong>场景1</strong></p><p>假设一家基于单一架构的公司处理众多产品。现在，随着公司在当今的扩展行业的扩展，他们的单一架构开始引发问题。</p><p>您如何看待公司从单一服务转向微服务并部署其服务容器？</p><p>解：由于公司的目标是从单一应用程序转向微服务，它们最终可以逐个构建，并行构建，只需在后台切换配置。然后他们可以将这些内置微服务放在 Kubernetes 平台上。因此，他们可以从一次或两次迁移服务开始，并监控它们以确保一切运行稳定。一旦他们觉得一切顺利，他们就可以将其余的应用程序迁移到他们的 Kubernetes 集群中。</p><p><strong>场景2</strong></p><p>考虑一家拥有分布式系统的跨国公司，拥有大量数据中心，虚拟机和许多从事各种任务的员工。</p><p>您认为这样的公司如何以 Kubernetes 一致的方式管理所有任务？</p><p>解：正如我们所有人都知道 IT 部门推出了数千个容器，其任务在分布式系统中遍布全球众多节点。在这种情况下，公司可以使用能够为基于云的应用程序提供敏捷性，横向扩展功能和 DevOps 实践的东西。因此，该公司可以使用 Kubernetes 来定制他们的调度架构并支持多种容器格式。这使得容器任务之间的亲和性成为可能，从而提供更高的效率，并为各种容器网络解决方案和容器存储提供广泛支持。</p><p><strong>场景3</strong></p><p>考虑一种情况，即公司希望通过维持最低成本来提高其效率和技术运营速度。您认为公司将如何实现这一目标？</p><p>解：公司可以通过构建 CI/CD 管道来实现 DevOps 方法，但是这里可能出现的一个问题是配置可能需要一段时间才能启动并运行。因此，在实施 CI/CD 管道之后，公司的下一步应该是在云环境中工作。一旦他们开始处理云环境，他们就可以在集群上安排容器，并可以在 Kubernetes 的帮助下进行协调。这种方法将有助于公司缩短部署时间，并在各种环境中加快速度。</p><p><strong>场景4</strong></p><p>假设一家公司想要修改它的部署方法，并希望建立一个更具可扩展性和响应性的平台。您如何看待这家公司能够实现这一目标以满足客户需求？</p><p>解：为了给数百万客户提供他们期望的数字体验，公司需要一个可扩展且响应迅速的平台，以便他们能够快速地将数据发送到客户网站。现在，要做到这一点，公司应该从他们的私有数据中心（如果他们使用任何）转移到任何云环境，如 AWS。不仅如此，他们还应该实现微服务架构，以便他们可以开始使用 Docker 容器。一旦他们准备好基础框架，他们就可以开始使用最好的编排平台，即 Kubernetes。这将使团队能够自主地构建应用程序并快速交付它们。</p><p><strong>场景5</strong></p><p>考虑一家拥有非常分散的系统的跨国公司，期待解决整体代码库问题。您认为公司如何解决他们的问题？</p><p>解：那么，为了解决这个问题，我们可以将他们的单片代码库转移到微服务设计，然后每个微服务都可以被视为一个容器。因此，所有这些容器都可以在 Kubernetes 的帮助下进行部署和协调。</p><p><strong>场景6</strong></p><p>我们所有人都知道，从单片到微服务的转变解决了开发方面的问题，但却增加了部署方面的问题。公司如何解决部署方面的问题？</p><p>解：团队可以试验容器编排平台，例如：Kubernetes，并在数据中心运行。因此，通过这种方式，公司可以生成模板化应用程序，在五分钟内部署它，并在此时将实际实例集中在暂存环境中。这种 Kubernetes 项目将有数十个并行运行的微服务，以提高生产率，即使节点出现故障，也可以立即重新安排，而不会影响性能。</p><p><strong>场景7</strong></p><p>假设一家公司希望通过采用新技术来优化其工作负载的分配。公司如何有效地实现这种资源分配？</p><p>解：这个问题的解决方案就是 Kubernetes。Kubernetes 确保资源得到有效优化，并且只使用特定应用程序所需的那些资源。因此，通过使用最佳容器编排工具，公司可以有效地实现资源分配。</p><p><strong>场景8</strong></p><p>考虑一家拼车公司希望通过同时扩展其平台来增加服务器数量。您认为公司如何处理服务器及其安装？</p><p>解：公司可以采用集装箱化的概念。一旦他们将所有应用程序部署到容器中，他们就可以使用 Kubernetes 进行编排，并使用像 Prometheus 这样的容器监视工具来监视容器中的操作。因此，利用容器的这种使用，在数据中心中为它们提供更好的容量规划，因为它们现在将受到更少的限制，因为服务和它们运行的​​硬件之间存在抽象。</p><p><strong>场景9</strong></p><p>考虑一种情况，公司希望向具有各种环境的客户提供所有必需的分发。您认为他们如何以动态的方式实现这一关键目标？</p><p>解：该公司可以使用 Docker环境，组建一个横截面团队，使用 Kubernetes 构建 Web 应用程序。这种框架将帮助公司实现在最短的时间内将所需产品投入生产的目标。因此，在这样的机器运行的情况下，公司可以向所有具有各种环境的客户发放电子邮件。</p><p><strong>场景10</strong></p><p>假设公司希望在不同的云基础架构上运行各种工作负载，从裸机到公共云。公司将如何在不同界面的存在下实现这一目标？</p><p>解：该公司可以将其基础设施分解为微服务，然后采用 Kubernetes。这将使公司在不同的云基础架构上运行各种工作负载。</p><h2 id="多项选择面试问题">多项选择面试问题</h2><p>这部分问题将包括多项选择面试问题，这些问题在面试中经常被问到。</p><p><strong>Q1、什么是 Kubernetes 集群中的 minions？</strong></p><ol><li>它们是主节点的组件。</li><li>它们是集群的工作节点。[答案]</li><li>他们正在监控 Kubernetes 中广泛使用的引擎。</li><li>他们是 Docker 容器服务。</li></ol><p><strong>Q2、Kubernetes 集群数据存储在以下哪个位置？</strong></p><ol><li>KUBE-API服务器</li><li>Kubelet</li><li>ETCD [答案]</li><li>以上都不是</li></ol><p><strong>Q3、哪个是 Kubernetes 控制器？</strong></p><ol><li>ReplicaSet</li><li>Deployment</li><li>Rolling Updates</li><li>ReplicaSet和Deployment [答案]</li></ol><p><strong>Q4、以下哪个是核心 Kubernetes 对象？</strong></p><ol><li>Pods</li><li>Services</li><li>Volumes</li><li>以上所有[答案]</li></ol><p><strong>Q5、Kubernetes Network 代理在哪个节点上运行？</strong></p><ol><li>Master Node</li><li>Worker Node</li><li>所有节点[答案]</li><li>以上都不是</li></ol><p><strong>Q6、节点控制器的职责是什么？</strong></p><ol><li>将 CIDR 块分配给节点</li><li>维护节点列表</li><li>监视节点的运行状况</li><li>以上所有[答案]</li></ol><p><strong>Q7、Replication Controller 的职责是什么？</strong></p><ol><li>使用单个命令更新或删除多个 Pod</li><li>有助于达到理想状态</li><li>如果现有 Pod 崩溃，则创建新 Pod</li><li>以上所有[答案]</li></ol><p><strong>Q8、如何在没有选择器的情况下定义服务？</strong></p><ol><li>指定外部名称[答案]</li><li>指定具有 IP 地址和端口的端点</li><li>只需指定 IP 地址即可</li><li>指定标签和 API 版本</li></ol><p><strong>Q9、1.8 版本的 Kubernetes 引入了什么？</strong></p><ol><li>Taints and Tolerations [答案]</li><li>Cluster level Logging</li><li>Secrets</li><li>Federated Clusters</li></ol><p><strong>Q10、Kubelet 调用的处理检查容器的 IP 地址是否打开的程序是？</strong></p><ol><li>HTTPGetAction</li><li>ExecAction</li><li>TCPSocketAction [答案]</li><li>以上都不是</li></ol><p><strong>译者注</strong></p><p>这篇文章不仅仅适合相关的面试者，也非常推荐 Kubernetes 的初学者或者想要了解 Kubernetes 技术的产品或管理者阅读。但是这里面还存在几点不足，例如覆盖的内容较浅显，没有非常具体的技术点，缺少大规模的经验和技术点考察等，有机会后面的文章会补充下！</p><blockquote><p>来源：知乎</p><p>原文：<a href="http://t.cn/Ailr1R3L" target="_blank" rel="noopener">http://t.cn/Ailr1R3L</a></p><p>译文：<a href="http://t.cn/Ailr1BxT" target="_blank" rel="noopener">http://t.cn/Ailr1BxT</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 一直是当今业界的流行语，也是最好的编排工具。它吸引了许多想要提升自己职业生涯的经验丰富的专业人士。&lt;/p&gt;
&lt;p&gt;Huwaei、Pokemon、Box、eBay、Ing、Yahoo Japan、SAP、纽约时报、Open AI、Sound Cloud 等跨国公司也使用 Kubernetes。我相信你已经知道这些事实，这也是促使你打开这个 Kubernetes 面试问题文章原因。&lt;/p&gt;
&lt;p&gt;在这篇关于 Kubernetes 面试问题的文章中，我将讨论在面试中提出的与 Kubernetes 相关的最重要问题。因此，为了您的理解，我将此文内容分为以下 4 个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 基本面试问题&lt;/li&gt;
&lt;li&gt;基于架构的面试问题&lt;/li&gt;
&lt;li&gt;基于场景的面试问题&lt;/li&gt;
&lt;li&gt;多项选择题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，让我们开始吧!&lt;/p&gt;
&lt;h2 id=&quot;基本的-Kubernetes-面试问题&quot;&gt;基本的 Kubernetes 面试问题&lt;/h2&gt;
&lt;p&gt;这部分问题将包含您需要了解的与 Kubernetes 工作相关的所有基本问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q1、Kubernetes 与 Docker Swarm 的区别如何？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/700/1*xzLZVPBlFvLsVPaqtracvw.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2、什么是 Kubernetes？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/321/1*jhzU7LO0pvfMJzrViu6tiA.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 是一个开源容器管理工具，负责容器部署，容器扩缩容以及负载平衡。作为 Google 的创意之作，它提供了出色的社区，并与所有云提供商合作。因此，我们可以说 Kubernetes 不是一个容器化平台，而是一个多容器管理解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q3、Kubernetes 与 Docker 有什么关系？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，Docker 提供容器的生命周期管理和 Docker 镜像构建运行时容器。但是，由于这些单独的容器有时必须跨主机通信，这时我们需要使用 Kubernetes 来解决这个问题。&lt;/p&gt;
&lt;p&gt;因此，我们说 Docker 构建容器，但这些容器通过 Kubernetes 来进行跨主机相互通信。我们还可以使用 Kubernetes 手动关联和编排在多个主机上运行的容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q4、在主机和容器上部署应用程序有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/700/1*R_5hio_I-hK4f-bOfTHstA.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;请参考上图。左侧架构表示在主机上部署应用程序。因此，这种架构将具有操作系统，然后操作系统将具有内核，该内核将在应用程序所需的操作系统上安装各种库。因此，在这种框架中，您可以拥有 N 个应用程序，并且所有应用程序将共享该操作系统中存在的库，而在容器中部署应用程序时，体系结构则略有不同。&lt;/p&gt;
&lt;p&gt;这种架构将有一个内核，这是唯一一个在所有应用程序之间唯一共同的东西。因此，如果有一个需要 Java 的特定应用程序，那么我们将获得访问 Java 的特定应用程序，如果有另一个需要 Python 的应用程序，则只有该特定应用程序才能访问 Python。&lt;/p&gt;
&lt;p&gt;您可以在图表右侧看到的各个块基本上是容器化的，并且这些块与其他应用程序隔离。因此，应用程序具有与系统其余部分隔离的必要库和二进制文件，并且不能被任何其他应用程序侵占。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款无需安装，仅需 1 条指令，秒实现内网穿透的神器 Serveo</title>
    <link href="https://www.hi-linux.com/posts/56863.html"/>
    <id>https://www.hi-linux.com/posts/56863.html</id>
    <published>2020-05-15T01:00:00.000Z</published>
    <updated>2020-05-15T04:58:10.461Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-serveo">什么是 Serveo</h2><p><code>Serveo</code> 是一个免费的内网穿透服务，<code>Serveo</code> 可以将本地计算机暴露在互联网上，官方声称其为 <code>Ngrok</code> 的绝佳替代品。</p><p><code>Serveo</code> 其最大优点是使用现有的 <code>SSH</code> 客户端，无需安装任何客户端软件，即可完成端口转发。</p><p><img src="https://www.hi-linux.com/img/linux/serveo.png" alt=""></p><p><code>Serveo</code> 工作原理很简单：当用户通过 <code>SSH</code> 连接到 <code>Serveo</code> 时会与该网站建立一个远程代理，<code>Serveo</code> 随后会生成一个 公共 <code>URL</code>，任何人都可以通过这个 <code>URL</code> 访问你的本地计算机。</p><blockquote><p>项目地址: <a href="https://serveo.net" target="_blank" rel="noopener">https://serveo.net</a></p></blockquote><a id="more"></a><h2 id="使用-serveo">使用 Serveo</h2><p><code>Serveo</code> 的使用非常简单，只需要可以使用 <code>SSH</code> 客户端并且能连接到互联网的任意系统都行。比如：<code>Linux</code>、<code>Windows</code>、<code>MacOS</code> 等系统，就算是 <code>Android</code>、<code>iOS</code> 也同样没问题。下面我们来看几个最常用的使用实例：</p><ol><li>开放本地服务到公网</li></ol><p>将一个本地应用的 8080 端口映射到公网中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果要转发其它端口，只需替换端口为其它就可以了</span><br><span class="line">$ ssh -R 80:localhost:8080 serveo.net</span><br><span class="line">Hi there</span><br><span class="line">Forwarding HTTP traffic from https:&#x2F;&#x2F;heryum.serveo.net</span><br><span class="line">Press g to start a GUI session and ctrl-c to quit.</span><br></pre></td></tr></table></figure><p><code>SSH</code> 连接成功后，会随机生成一个 <code>serveo.net</code> 二级域名。随后你就可以使用浏览器访问这个随机生成的二级域名 <code>heryum.serveo.net</code> 间接访问到本地计算机 8080 端口上的服务了。</p><blockquote><p><code>SSH</code> 初次和一个新服务器建立连接时会有提示，直接选择 yes 即可。</p></blockquote><p>如果你不想使用随机域名，想指定一个固定的二级域名也是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 这里指定为 ywzm.serveo.net，可以根据自身情况进行替换</span><br><span class="line">$ ssh -R ywzm:80:localhost:8080 serveo.net</span><br><span class="line">Hi there</span><br><span class="line">Forwarding HTTP traffic from https:&#x2F;&#x2F;ywzm.serveo.net</span><br><span class="line">Press g to start a GUI session and ctrl-c to quit.</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 上面的域名是简写的，你也可以写出完整的域名。</span><br><span class="line">$ ssh -R ywzm.serveo.net:80:localhost:8080 serveo.net</span><br></pre></td></tr></table></figure><p><code>SSH</code> 连接成功后，此时就可以在公网上使用 <code>ywzm.serveo.net</code> 访问到你本地计算机 8080 端口的服务了。</p><p>上面的例子中，我们转发的是 <code>HTTP</code> 服务。如果你需要转发的是 <code>TCP</code> 服务，又应该怎么做呢？其实方法也很简单，同样只需设置公网的转发端口和本地端口就可以了。例如：我们需要将本地 3306 端口转发到公网中，使用下面命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 可以自行设置公网端口，这里设置为 1492</span><br><span class="line">$ ssh -R 1492:localhost:3306 serveo.net</span><br><span class="line"></span><br><span class="line"># 如果公网端口设置为 0，就会采用一个随机端口进行转发</span><br><span class="line">$ ssh -R 0:localhost:3306 serveo.net</span><br></pre></td></tr></table></figure><ol start="2"><li>将本地 SSH 重定向到公网</li></ol><p>在很多场景下，我们需要远程访问到本地计算机的 <code>SSH</code> 服务。要实现这样的需求也很简单，只需要使用下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 名称为自定义的，这里设置为 myhost</span><br><span class="line">$ ssh -R myhost:22:localhost:22 serveo.net</span><br><span class="line">Hi there</span><br><span class="line">Forwarding SSH traffic from alias &quot;myhost&quot;</span><br><span class="line">Press g to start a GUI session and ctrl-c to quit.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>连接成功后，接下来你就可以从公网上对这个内网计算机的 <code>SSH</code> 进行访问了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -J serveo.net myuser@myhost</span><br><span class="line">Hi there</span><br><span class="line">myuser@myhost&#39;s password:</span><br><span class="line">Last login: Mon Dec 24 21:00:32 2019 from 127.0.0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>-J</code> 选项是在 <code>OpenSSH 7.3</code> 版本才引入的，如果你使用的 <code>SSH</code> 客户端版本较旧，则可以使用 <code>ProxyCommand</code> 选项来替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -o ProxyCommand&#x3D;&quot;ssh -W myhost:22 serveo.net&quot; user@myhost</span><br></pre></td></tr></table></figure><h2 id="一些其它技巧">一些其它技巧</h2><ol><li>保持 SSH 连接不超时</li></ol><p>众所周知，<code>SSH</code> 连接一旦超时就会自动断开，这样就很容易造成服务中断。这里我们只需给 <code>SSH</code> 连接增加一个保活参数 <code>-o ServerAliveInterval=60</code> 就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每隔 60 秒做一次连接保活</span><br><span class="line">$ ssh -o ServerAliveInterval&#x3D;60 -R 80:localhost:8080 serveo.net</span><br></pre></td></tr></table></figure><ol start="2"><li>对 SSH 连接进行守护</li></ol><p>上面的方法虽然可以解决超时的问题，但进程始终是在前台运行的。为了彻底解决这个问题，官方推荐使用 <code>AutoSSH</code> 来进行进程守护。</p><blockquote><p><code>AutoSSH</code> 是一个用来对 <code>SSH</code> 连接进行监控的程序，可在遇到程序问题或者是网络问题时自动进行重连，以达到长期保持 <code>SSH</code> 稳定连接的目的 。</p></blockquote><ul><li>安装 AutoSSH</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Debian &#x2F; Ubuntu 系统</span><br><span class="line">$ apt install autossh -y</span><br><span class="line"></span><br><span class="line"># CentOS &#x2F; RHEL 系统</span><br><span class="line">$ yum install autossh -y</span><br></pre></td></tr></table></figure><ul><li>将 AutoSSH 加入到系统服务</li></ul><p>这里以加入到 <code>Systemd</code> 系统服务为例，此方法适用于 <code>CentOS 7</code>、<code>Debian 8</code>、<code>Ubuntu 16</code> 及以上系统版本。首先，我们创建一个 AutoSSH 的 Systemd 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;autossh.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;autossh</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">Environment&#x3D;&quot;AUTOSSH_GATETIME&#x3D;0&quot;</span><br><span class="line">ExecStart&#x3D;$(command -v autossh) -M 0 -o &quot;ServerAliveInterval 60&quot; -o &quot;ServerAliveCountMax 3&quot; -R 80:localhost:8080 serveo.net</span><br><span class="line">Restart&#x3D;on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p><code>AutoSSH</code> 的 <code>-M</code> 参数主要用于指定一个监听端口来监视 <code>SSH</code> 连接状态，这里指定为 0 的主要目的是禁用 <code>AutoSSH</code> 的监控端口。保活依然使用 <code>SSH</code> 自己的 <code>ServerAliveInterval</code> 和 <code>ServerAliveCountMax</code> 选项来完成。</p></blockquote><p>其次，<code>Systemd</code> 系统服务创建完成后，我们启动这个 <code>AutoSSH</code> 的服务并设置为开机自启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start autossh</span><br><span class="line">$ systemctl enable autossh</span><br></pre></td></tr></table></figure><ol start="3"><li>如果你无法通过 22 端口连接到 Serveo，官方还预留了 443 端口给你使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 443 -R 80:localhost:8080 serveo.net</span><br></pre></td></tr></table></figure><ol start="4"><li>使用自定义的域名 / 子域名</li></ol><p>默认情况下，我们都是使用的 <code>Serveo</code> 生成的二级域名进行连接的。如果你想使用自己的域名也是可以的，方法非常简单。只需要在你的域名所在 DNS 中添加一条 A 记录和一条 TXT 记录就可实现。</p><p>4.1 添加一条 A 记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A | serveo | 159.89.214.31</span><br></pre></td></tr></table></figure><p>4.2 添加一条 TXT 记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TXT | serveo | authkeyfp&#x3D;SHA256:pmc7ZRv7ymCmghUwHoJWEm5ToSTd33ryeDeps5RnfRY</span><br></pre></td></tr></table></figure><blockquote><p><code>authkeyfp</code> 后面跟的那一串字符是 <code>RSA</code> 密钥指纹，你可以使用 <code>ssh-keygen -l</code> 命令进行查看。</p></blockquote><p>DNS 解析记录增加好后，你就可以使用自定义域名进行连接了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -R serveo.ywzm.org:80:localhost:3000 serveo.net</span><br></pre></td></tr></table></figure><p>至此，<code>Serveo</code> 的基本用法就介绍完了。如果你对它有更多的兴趣，欢迎去官网进行探索。</p><h2 id="参考文档">参考文档</h2><ol><li><p>https:/www.google.com</p></li><li><p><a href="https://www.moerats.com/archives/990/" target="_blank" rel="noopener">https://www.moerats.com/archives/990/</a></p></li><li><p><a href="https://blog.rxliuli.com/p/5ad7fa84/" target="_blank" rel="noopener">https://blog.rxliuli.com/p/5ad7fa84/</a></p></li><li><p><a href="https://www.jianshu.com/p/d0b3991a9ce1" target="_blank" rel="noopener">https://www.jianshu.com/p/d0b3991a9ce1</a></p></li><li><p><a href="https://blog.csdn.net/kongxx/article/details/86178364" target="_blank" rel="noopener">https://blog.csdn.net/kongxx/article/details/86178364</a></p></li><li><p><a href="https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-autossh/" target="_blank" rel="noopener">https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-autossh/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Serveo&quot;&gt;什么是 Serveo&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Serveo&lt;/code&gt; 是一个免费的内网穿透服务，&lt;code&gt;Serveo&lt;/code&gt; 可以将本地计算机暴露在互联网上，官方声称其为 &lt;code&gt;Ngrok&lt;/code&gt; 的绝佳替代品。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Serveo&lt;/code&gt; 其最大优点是使用现有的 &lt;code&gt;SSH&lt;/code&gt; 客户端，无需安装任何客户端软件，即可完成端口转发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/serveo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Serveo&lt;/code&gt; 工作原理很简单：当用户通过 &lt;code&gt;SSH&lt;/code&gt; 连接到 &lt;code&gt;Serveo&lt;/code&gt; 时会与该网站建立一个远程代理，&lt;code&gt;Serveo&lt;/code&gt; 随后会生成一个 公共 &lt;code&gt;URL&lt;/code&gt;，任何人都可以通过这个 &lt;code&gt;URL&lt;/code&gt; 访问你的本地计算机。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址: &lt;a href=&quot;https://serveo.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://serveo.net&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="内网穿透" scheme="https://www.hi-linux.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>25 个 Linux 下的炫酷又强大的命令行神器，你用过其中哪几个呢？</title>
    <link href="https://www.hi-linux.com/posts/28627.html"/>
    <id>https://www.hi-linux.com/posts/28627.html</id>
    <published>2020-05-15T01:00:00.000Z</published>
    <updated>2020-05-15T08:15:43.267Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，我们在 Linux 下大多数时候是使用命令行来处理任务的。这样不但操作起来效率比较高，而且界面也比较炫酷。下面，我们就给大家推荐一些不但炫酷又好用的 Linux 命令行神器。</p><h2 id="1-exa">1. exa</h2><p><img src="https://www.hi-linux.com/img/linux/exa.png" alt=""></p><p>exa 是一个用来替代 ls 的工具， exa 相比于 ls 增加了很多新的特性，比如：支持不同文件类型可以用不同颜色来展示、exa 比 ls 速度更快一些等。</p><blockquote><p>项目地址：<a href="https://github.com/ogham/exa" target="_blank" rel="noopener">https://github.com/ogham/exa</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247488536&amp;idx=1&amp;sn=05896e203e9c78740243ab552f59f535&amp;chksm=eac53531ddb2bc27629978c121bfa53f9d3c540dce134d8267259fa7c96e19e1ab07448b4e50&amp;token=1606750990&amp;lang=zh_CN#rd" target="_blank" rel="noopener">推荐一个比 ls 命令速度快 100 倍的文件目录浏览神器</a>」 一文。</p><h2 id="2-fd">2. FD</h2><p><img src="https://www.hi-linux.com/img/linux/fd.jpeg" alt=""></p><p>fd 是基于 Rust 开发的一个速度超快的命令行搜索工具，fd 旨在成为 Linux / Unix 下 find 命令的替代品。</p><p>fd 虽然不能提供现在 find 命令所有的强大功能，但它也提供了足够强大的功能来满足你日常需要。比如：简洁的语法、彩色的终端输出、超快的查询速度、智能大小写、支持正则表达式以及可并行执行命令等特性。</p><blockquote><p>项目地址：<a href="https://github.com/sharkdp/fd" target="_blank" rel="noopener">https://github.com/sharkdp/fd</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486196&amp;idx=1&amp;sn=6141148903295af608e64aecf192c33a&amp;chksm=eac52bddddb2a2cbe4c7a3252c933cb76835bb5bf94b4b3c592d28b7a3b24ce56ddc05641870&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">推荐一款比 Find 快 10 倍的搜索工具 FD</a>」 一文。</p><a id="more"></a><h2 id="3-ripgrep">3. RipGrep</h2><p><img src="https://www.hi-linux.com/img/linux/rg.jpeg" alt=""></p><p>Ripgrep 是命令行下一个基于行的命令行搜索工具，比 ag、grep、ack 速度更快。RipGrep 使用 Rust 开发，可以在多平台下运行，支持 Mac、Linux 和 Windows 等平台。</p><blockquote><p>项目地址：<a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">https://github.com/BurntSushi/ripgrep</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486258&amp;idx=1&amp;sn=8ff0fafd8ae2b261bd17985d3079acd6&amp;chksm=eac52a1bddb2a30d88dc449cdcf84d66801a84e85454d0335843f6e44cec9ec14398b818b6de&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">推荐一款命令行下最快的文本搜索神器 RipGrep</a>」 一文。</p><h2 id="4-tig">4. Tig</h2><p><img src="https://darrenburns.net/tig-cb475140e22bbb7f227d7e03f9050556.gif" alt=""></p><p>Tig 是一款命令行下 Git 的可视化工具，可以很方便地在命令行下以交互的方式完成 Git 的各种操作。</p><blockquote><p>项目地址：<a href="https://github.com/jonas/tig" target="_blank" rel="noopener">https://github.com/jonas/tig</a></p></blockquote><h2 id="5-fzf">5. FZF</h2><p><img src="https://raw.githubusercontent.com/junegunn/i/master/fzf-preview.png" alt=""></p><p>FZF 是使用 GO 语言开发的一款命令行下支持模糊搜索的交互式工具。FZF 可以用来查找任何列表内容，包括文件、Git 分支、进程等。所有的命令行工具都可以生成列表后再通过管道将结果输入到 FZF 上进行模糊搜索。FZF 还可以结合其它工具(比如：rg、bat 和 Fasd )来完成更多的工作。</p><blockquote><p>项目地址：<a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">https://github.com/junegunn/fzf</a></p></blockquote><h2 id="6-fpp">6. FPP</h2><p><img src="https://darrenburns.net/fpp-217fdcd6bcffaa605df85f31e8d84d79.gif" alt=""></p><p>FPP (Facebook Path Picker ) 是由 Fackbook 开源一款终端多文件路径选择工具，它可以用于完善优化终端中的操作, 比如：Git、Grep 等的输出结果。</p><blockquote><p>项目地址：<a href="https://github.com/facebook/PathPicker" target="_blank" rel="noopener">https://github.com/facebook/PathPicker</a></p></blockquote><h2 id="7-bat">7. BAT</h2><p><img src="https://www.hi-linux.com/img/linux/bat.jpeg" alt=""></p><p>BAT 是命令行下一款用来显示文件内容的工具，bat 命令功能跟常用命令 cat 类似。只是 bat 功能上更加强大一些，bat 在 cat 命令的基础上加入了行号显示、代码高亮和 Git 集成。</p><blockquote><p>项目地址： <a href="https://github.com/sharkdp/bat" target="_blank" rel="noopener">https://github.com/sharkdp/bat</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247485893&amp;idx=1&amp;sn=c6ff22b7f4afa84446e595bb5b14e7a0&amp;chksm=eac528ecddb2a1fa36861c98d10889d374bf9c1dbdb57c27914a96656a6d6556ae5ff0acffd4&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">推荐一款命令行下支持语法高亮和Git集成的文件查看工具 bat</a>」 一文。</p><h2 id="8-mycli">8. MyCli</h2><p><img src="https://www.hi-linux.com/img/linux/mycli.gif" alt=""></p><p>MyCli 是一个 MySQL 的命令行客户端，可以实现自动补全和语法高亮。MyCli 也可用于 MariaDB 和Percona。</p><blockquote><p>项目地址：<a href="http://mycli.net/" target="_blank" rel="noopener">http://mycli.net/</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483873&amp;idx=1&amp;sn=3e1e178510a33239cf4551f6377b8faf&amp;chksm=eac520c8ddb2a9de407d309303d9d7a5a51336efc8390d4e02f07b7791a96f159e53d3a65c0e&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL的增强型语法高亮终端-MyCli</a>」 一文。</p><h2 id="9-htop">9. HTop</h2><p><img src="https://hisham.hm/htop/htop_graph.gif" alt=""></p><p>HTop 称之为 Top 的增强版，是一个相对于 Top 命令提供更美观、更方便的进程监控工具。</p><blockquote><p>项目地址: <a href="https://hisham.hm/htop/" target="_blank" rel="noopener">https://hisham.hm/htop/</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247484585&amp;idx=1&amp;sn=6f49154c7f53025a616953803d5cd403&amp;chksm=eac52580ddb2ac96d2446a3cfe3d121720e9e103224b85bb377cf277f7714e4d324d1dc2281e&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">一款比 top 强悍好用的进程管理监控工具</a>」 一文。</p><h2 id="10-glances">10. Glances</h2><p><img src="https://raw.githubusercontent.com/nicolargo/glances/develop/docs/_static/glances-summary.png" alt=""></p><p>Glances 是一个用于监控系统的跨平台、基于文本模式的命令行工具。它是用 Python 编写的，使用 psutil 库从系统获取信息。你可以用它来监控 CPU、平均负载、内存、网络接口、磁盘 I/O，文件系统空间利用率、挂载的设备、所有活动进程以及消耗资源最多的进程。信息比 htop 更加丰富，除了命令行，Glances 还提供页面服务，可以让你从页面上随时查看某服务器的状态。</p><blockquote><p>项目地址: <a href="https://github.com/nicolargo/glances" target="_blank" rel="noopener">https://github.com/nicolargo/glances</a></p></blockquote><h2 id="11-lrzsz">11. lrzsz</h2><p>lrzsz 软件包是一个支持 Zmodem 协议的工具包。 其中包含的 rz、sz 命令是通过 ZModem 协议在远程服务器和终端机器间上传下载文件的利器。</p><p>lrzsz 支持交互式文件传输，在多重跳板机下传输文件非常好用，不用一级一级传输。</p><blockquote><p>项目地址: <a href="https://www.ohse.de/uwe/software/lrzsz.html" target="_blank" rel="noopener">https://www.ohse.de/uwe/software/lrzsz.html</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247485436&amp;idx=1&amp;sn=871a661688d6a2894f7d200709bf54bf&amp;chksm=eac526d5ddb2afc3e465faba25294e7361746d3ff821aa9c6df78f66ca6d202fc4b0312c1072&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">在 iTerm2 中使用 Zmodem 实现快速传输文件</a>」 一文。</p><h2 id="12-ncdu">12. Ncdu</h2><p><img src="https://dev.yorhel.nl/img/ncduinfo-2.png" alt=""></p><p>Ncdu (NCurses Disk Usage) 是一个基于 Ncurses 库的 du 命令的界面。它通过大家熟知的 du 命令，为用户提供一个快速且容易被使用的界面。它可以显示磁盘使用的百分比，且允许你使用 ncurses 库的方式在目录之间导航。</p><blockquote><p>项目地址: <a href="https://dev.yorhel.nl/ncdu" target="_blank" rel="noopener">https://dev.yorhel.nl/ncdu</a></p></blockquote><h2 id="13-tmux">13. Tmux</h2><p><img src="http://dotshare.it/public/images/uploads/29.png" alt=""></p><p>Tmux 是一个优秀的终端复用工具，功能类似 GNU Screen，但使用 BSD 许可发布。用户可以通过 Tmux 在一个终端内管理多个分离的会话、窗口及面板，对于同时使用多个命令行，或多个任务时非常方便。</p><blockquote><p>项目地址: <a href="https://github.com/tmux/tmux" target="_blank" rel="noopener">https://github.com/tmux/tmux</a></p></blockquote><h2 id="14-multitail">14. MultiTail</h2><p><img src="https://www.debuntu.org/wp-content/uploads/2013/04/multitail-splitoutput.png" alt=""></p><p>MultiTail 是一个开源的 Ncurses 实用程序，可用于在单个窗口或单个 Shell 中将多个日志文件同时显示到标准输出。</p><blockquote><p>项目地址: <a href="https://www.vanheusden.com/multitail" target="_blank" rel="noopener">https://www.vanheusden.com/multitail</a></p></blockquote><h2 id="15-shellcheck">15. ShellCheck</h2><p><img src="https://github.com/koalaman/shellcheck/raw/master/doc/terminal.png" alt=""></p><p>ShellCheck 是一款实用的 Shell 脚本静态检查工具，可以帮助你提前发现并修复语法错误以及不规范的写法。</p><blockquote><p>项目地址：<a href="https://github.com/koalaman/shellcheck" target="_blank" rel="noopener">https://github.com/koalaman/shellcheck</a></p></blockquote><h2 id="16-explainshell">16. Explainshell</h2><p><img src="https://darrenburns.net/static/explain_shell-0edc1706c18af98816645e6b2db89607-c83f1.png" alt=""></p><p>Explainshell 是一个帮助你解释命令行的网站，它会分析命令的帮助文档，然后根据你想查询的命令参数来抽取对应的解释，然后简洁易懂地显示出来。</p><blockquote><p>项目地址: <a href="https://github.com/idank/explainshell" target="_blank" rel="noopener">https://github.com/idank/explainshell</a></p></blockquote><h2 id="17-asciinema">17. Asciinema</h2><p><img src="https://www.hi-linux.com/img/linux/asciinema.jpeg" alt=""></p><p>Asciinema 是一个终端下非常棒的录屏和回放软件。Asciinema 对终端输入输出进行捕捉，然后以文本的形式来记录和回放。</p><p>基于 Asciinema 用文本来记录的特性，使其拥有了非常炫酷的特性。你可以在播放过程中随时暂停，然后对播放器中的文本进行复制或者其它操作。</p><blockquote><p>项目地址：<a href="https://github.com/asciinema/asciinema" target="_blank" rel="noopener">https://github.com/asciinema/asciinema</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486341&amp;idx=1&amp;sn=7996231ebcec64780b28ea90adfdc024&amp;chksm=eac52aacddb2a3ba63dd50bc9e40f6f0e292a1622353a04fd5a86d9f191bb96b1bcb8f174c1b&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">手把手教你使用终端录屏神器 Asciinema</a>」 一文。</p><h2 id="18-svg-term">18. Svg-term</h2><p><img src="https://i.gyazo.com/thumb/1000/fc8e8d6942c4b4792e05ce2c25a0ac10-png.png" alt=""></p><p>一个可以根据 Asciinema 录制文件生成 SVG 动画的小工具。</p><blockquote><p>项目地址： <a href="https://github.com/marionebl/svg-term-cli" target="_blank" rel="noopener">https://github.com/marionebl/svg-term-cli</a></p></blockquote><p>来看一个实例：将通过 Asciinema 在终端录制的视频转换为 SVG 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 安装 svg-term </span><br><span class="line">$ npm install -g svg-term-cli</span><br><span class="line"></span><br><span class="line"># 直接转换发布在 Asciinema 网站上的视频，需要先确认视频所在链接中的录制 ID，例如: https:&#x2F;&#x2F;asciinema.org&#x2F;a&#x2F;219486 的 ID 就是 219486</span><br><span class="line">$ svg-term --cast&#x3D;219486 --out ~&#x2F;home&#x2F;mike&#x2F;out.svg --padding 18 --height 8 --width 80</span><br><span class="line"></span><br><span class="line"># 如果你不想把录制文件上传到 Asciinema 网站上，你也可以直接使用 svg-term 转换本地录制文件</span><br><span class="line"></span><br><span class="line">$ asciinema rec cast.json</span><br><span class="line">$ cat cast.json | svg-term-cli</span><br></pre></td></tr></table></figure><h2 id="19-wrk">19. Wrk</h2><p><img src="https://pbs.twimg.com/media/DrPwgeOUwAAeqrR.jpg" alt=""></p><p>Wrk 是轻量级的 HTTP 性能测试工具。相比于 Apache ab 功能更强大，支持 HTTP 1.1，而且可以用 Lua 写脚本支持更复杂的测试场景。</p><blockquote><p>项目地址：<a href="https://github.com/wg/wrk" target="_blank" rel="noopener">https://github.com/wg/wrk</a></p></blockquote><h2 id="20-httpie">20. HTTPie</h2><p><img src="https://www.hi-linux.com/img/linux/httpie.jpeg" alt=""></p><p>HTTPie (读aych-tee-tee-pie) 是一款开源的命令行 HTTP 工具。HTTPie 采用 Python 开发，底层用到了 Requests 和 Pygments 库。</p><p>HTTPie 设计用来增强 wget 和 curl 的可用性。它的主要目标是使通过命令行与网络服务器进行交互的过程变得尽可能的人性化。其提供了一个简单的 HTTP 环境来让我们通过简单而自然的语法发送任意 HTTP 请求，并显示彩色输出。HTTPie 可用于测试，调试和与 HTTP 服务器进行普通的交互。</p><blockquote><p>项目地址: <a href="http://httpie.org/" target="_blank" rel="noopener">http://httpie.org/</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483830&amp;idx=1&amp;sn=dec71acedef41690ba000b05ab2da039&amp;chksm=eac5209fddb2a9896d7d665bcdf3a0476a2bdf1c3d1e0ed3e5ba8bb9c964b480eb9cc6aba3de&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">如何用 HTTPie 更高效的调试接口</a>」 一文。</p><h2 id="21-http-prompt">21. HTTP Prompt</h2><p><img src="https://www.hi-linux.com/img/linux/http-prompt.gif" alt=""></p><p>HTTP Prompt 是一个交互式的命令行 HTTP 客户端，支持自动完成、语法高亮，基于 HTTPie 和 prompt_toolkit 构建。HTTP Prompt 相对于其它命令行的 HTTP 客户端 (如：HTTPie、Curl 等)使用上更加直观方便。</p><blockquote><p>项目地址: <a href="https://github.com/eliangcs/http-prompt" target="_blank" rel="noopener">https://github.com/eliangcs/http-prompt</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483962&amp;idx=1&amp;sn=45e50270c32fde2d06ce59e274d31cc5&amp;chksm=eac52313ddb2aa0571a01088983bb061be36cf0a35bf235d32637ddc3490968890ae36f7f230&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Linux 命令行下交互式 HTTP 客户端–HTTP Prompt</a>」 一文。</p><h2 id="22-tldr">22. TLDR</h2><p><img src="https://tldr.sh/assets/img/screenshot.png" alt=""></p><p>TLDR 全称Too long, Don’t read，翻译成中文就是太长不读。它可以帮助你快速查看命令行工具的使用实例。简而言之，就是 Man 页面的精简版本。</p><blockquote><p>项目地址: <a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">https://github.com/tldr-pages/tldr</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483858&amp;idx=1&amp;sn=960f18327f4936bcf1e8f5d12eff8721&amp;chksm=eac520fbddb2a9edab7bc68ac91106ced74391886a631dd632c2ef9d0c90a1a736887117e2ce&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Linux命令行学习神器tldr</a>」 一文。</p><h2 id="23-ranger">23. Ranger</h2><p><img src="https://raw.githubusercontent.com/ranger/ranger-assets/master/screenshots/screenshot.png" alt=""></p><p>Ranger 是一个命令行下的文件管理器。Ranger 使用 Python 编写，默认为使用 Vim 风格的按键绑定。</p><blockquote><p>项目地址: <a href="https://github.com/ranger/ranger" target="_blank" rel="noopener">https://github.com/ranger/ranger</a></p></blockquote><h2 id="24-axel">24. Axel</h2><p><img src="https://i.loli.net/2019/08/30/I3m5peN7hMlvHJn.jpg" alt=""></p><p>Axel 是 Linux 下一个不错的高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。非常适合网速不给力时多线程下载，以提高下载速度。</p><blockquote><p>项目地址: <a href="https://github.com/axel-download-accelerator/axel" target="_blank" rel="noopener">https://github.com/axel-download-accelerator/axel</a></p></blockquote><h2 id="25-cloc">25. Cloc</h2><p><img src="https://www.hi-linux.com/img/linux/cloc.png" alt=""></p><p>Cloc 是一款使用 Perl 语言开发的开源代码统计工具，支持多平台使用、多语言识别，能够计算指定目标文件或文件夹中的文件数(files)、空白行数(blank)、注释行数(comment)和代码行数(code)。</p><blockquote><p>项目地址: <a href="http://cloc.sourceforge.net/" target="_blank" rel="noopener">http://cloc.sourceforge.net/</a></p></blockquote><p>更多详细介绍可参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483854&amp;idx=1&amp;sn=0c8a52b8504264b2e9bbe2699574c69a&amp;chksm=eac520e7ddb2a9f126be81ad83ff3221aa350d91b50a584f8d1a98942d019735143970099f59&amp;token=98555220&amp;lang=zh_CN#rd" target="_blank" rel="noopener">代码统计利器 CLOC</a>」 一文。</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a></p></li><li><p><a href="https://darrenburns.net/posts/tools/" target="_blank" rel="noopener">https://darrenburns.net/posts/tools/</a></p></li><li><p><a href="https://darrenburns.net/posts/more-tools" target="_blank" rel="noopener">https://darrenburns.net/posts/more-tools</a></p></li><li><p><a href="https://darrenburns.net/posts/even-more-tools" target="_blank" rel="noopener">https://darrenburns.net/posts/even-more-tools</a></p></li><li><p><a href="https://darrenburns.net/posts/command-line-tools-iv" target="_blank" rel="noopener">https://darrenburns.net/posts/command-line-tools-iv</a></p></li><li><p><a href="https://juejin.im/post/5afabcb1f265da0b886d92b6" target="_blank" rel="noopener">https://juejin.im/post/5afabcb1f265da0b886d92b6</a></p></li><li><p><a href="https://www.cnblogs.com/zqb-all/p/10054594.html" target="_blank" rel="noopener">https://www.cnblogs.com/zqb-all/p/10054594.html</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，我们在 Linux 下大多数时候是使用命令行来处理任务的。这样不但操作起来效率比较高，而且界面也比较炫酷。下面，我们就给大家推荐一些不但炫酷又好用的 Linux 命令行神器。&lt;/p&gt;
&lt;h2 id=&quot;1-exa&quot;&gt;1. exa&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/exa.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;exa 是一个用来替代 ls 的工具， exa 相比于 ls 增加了很多新的特性，比如：支持不同文件类型可以用不同颜色来展示、exa 比 ls 速度更快一些等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/ogham/exa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ogham/exa&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多详细介绍可参考：「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247488536&amp;amp;idx=1&amp;amp;sn=05896e203e9c78740243ab552f59f535&amp;amp;chksm=eac53531ddb2bc27629978c121bfa53f9d3c540dce134d8267259fa7c96e19e1ab07448b4e50&amp;amp;token=1606750990&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;推荐一个比 ls 命令速度快 100 倍的文件目录浏览神器&lt;/a&gt;」 一文。&lt;/p&gt;
&lt;h2 id=&quot;2-FD&quot;&gt;2. FD&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/fd.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;fd 是基于 Rust 开发的一个速度超快的命令行搜索工具，fd 旨在成为 Linux / Unix 下 find 命令的替代品。&lt;/p&gt;
&lt;p&gt;fd 虽然不能提供现在 find 命令所有的强大功能，但它也提供了足够强大的功能来满足你日常需要。比如：简洁的语法、彩色的终端输出、超快的查询速度、智能大小写、支持正则表达式以及可并行执行命令等特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/sharkdp/fd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sharkdp/fd&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多详细介绍可参考：「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247486196&amp;amp;idx=1&amp;amp;sn=6141148903295af608e64aecf192c33a&amp;amp;chksm=eac52bddddb2a2cbe4c7a3252c933cb76835bb5bf94b4b3c592d28b7a3b24ce56ddc05641870&amp;amp;token=98555220&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;推荐一款比 Find 快 10 倍的搜索工具 FD&lt;/a&gt;」 一文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>推荐一个比 ls 命令速度快 100 倍的文件目录浏览神器 exa</title>
    <link href="https://www.hi-linux.com/posts/11552.html"/>
    <id>https://www.hi-linux.com/posts/11552.html</id>
    <published>2020-05-15T01:00:00.000Z</published>
    <updated>2020-05-16T07:51:58.401Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>相信每个使用 <code>Linux</code> 的用户都使用过 <code>ls</code> 命令，其主要作用就是用于展示当前目录或者文件列表。但 <code>ls</code> 这个古老的高频使用命令存在一些使用上的问题，比如：1. 输出界面不是很友好。2. 目录下文件过多的情况下，输出结果会比较慢。</p><p>今天我们将给大家介绍一个更好用的文件目录列表工具 <code>exa</code>，<code>exa</code> 官方是这样介绍的:</p><blockquote><p>exa is a modern replacement for ls.</p></blockquote><p>顾名思义 <code>exa</code> 是一个用来替代 <code>ls</code> 的工具， <code>exa</code> 相比于 <code>ls</code> 增加了很多新的特性，比如：支持不同文件类型可以用不同颜色来展示、<code>exa</code> 比 <code>ls</code> 速度更快一些等。</p><p>项目地址：<a href="https://github.com/ogham/exa" target="_blank" rel="noopener">https://github.com/ogham/exa</a></p><p><img src="https://github.com/ogham/exa/raw/master/screenshots.png" alt=""></p><a id="more"></a><h2 id="安装-exa">安装 exa</h2><p><code>exa</code> 是用 <code>Rust</code> 语言实现的，安装前你的系统必须支持 <code>Rust</code> 1.17.0 或更高的版本。<code>exa</code> 目前已经支持了一些常用发行版本通过软件包安装，比如：</p><ul><li>Fedora</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dnf install exa</span><br></pre></td></tr></table></figure><ul><li>Arch</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S exa</span><br></pre></td></tr></table></figure><ul><li>openSUSE</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo zypper install exa</span><br></pre></td></tr></table></figure><ul><li>macOS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install exa</span><br></pre></td></tr></table></figure><p>如是你使用的发行版暂时不支持通过软件包进行安装，你还可以直接在官方仓库 <a href="https://github.com/ogham/exa/releases/" target="_blank" rel="noopener">Releases</a> 页面下载编译好的二进制版本使用。这里以 <code>Linux</code> 系统为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 下载对应二进制版本并解压安装到指定目录</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;ogham&#x2F;exa&#x2F;releases&#x2F;download&#x2F;v0.9.0&#x2F;exa-linux-x86_64-0.9.0.zip</span><br><span class="line">$ unzip exa-linux-x86_64-0.9.0.zip</span><br><span class="line">$ mv exa-linux-x86_64 &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line"></span><br><span class="line"># 下载并安装对应的 MAN 手册</span><br><span class="line">$ wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ogham&#x2F;exa&#x2F;master&#x2F;contrib&#x2F;man&#x2F;exa.1</span><br><span class="line">$ mv exa.1 &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1</span><br></pre></td></tr></table></figure><h2 id="使用-exa">使用 exa</h2><p><code>exa</code> 使用非常简单，其语法格式为 <code>exa [OPTIONS] [FILES]</code>，基本上和 <code>ls</code> 一样。</p><p>下面我们来看几个常用的例子：</p><ol><li>一行只输出一个结果</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ exa -1</span><br></pre></td></tr></table></figure><ol start="2"><li>输出结果并显示详细信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ exa -l</span><br></pre></td></tr></table></figure><ol start="3"><li>递归显示当然目录的所有文件</li></ol><p>输出结果的顺序为：先显示当前文件夹的，再递归显示每个子文件夹中的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ exa -R</span><br></pre></td></tr></table></figure><ol start="4"><li>以目录树结构显示目录下所有文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ exa -T</span><br></pre></td></tr></table></figure><ol start="5"><li>以网格方式排序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ exa -x</span><br></pre></td></tr></table></figure><p>当然 <code>exa</code> 的功能远不止这些，如果你对它有兴趣可以去官网探索更多用法哟。</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="https://the.exa.website/docs" target="_blank" rel="noopener">https://the.exa.website/docs</a></li><li><a href="https://www.jianshu.com/p/bd1e411a2e8d" target="_blank" rel="noopener">https://www.jianshu.com/p/bd1e411a2e8d</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信每个使用 &lt;code&gt;Linux&lt;/code&gt; 的用户都使用过 &lt;code&gt;ls&lt;/code&gt; 命令，其主要作用就是用于展示当前目录或者文件列表。但 &lt;code&gt;ls&lt;/code&gt; 这个古老的高频使用命令存在一些使用上的问题，比如：1. 输出界面不是很友好。2. 目录下文件过多的情况下，输出结果会比较慢。&lt;/p&gt;
&lt;p&gt;今天我们将给大家介绍一个更好用的文件目录列表工具 &lt;code&gt;exa&lt;/code&gt;，&lt;code&gt;exa&lt;/code&gt; 官方是这样介绍的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;exa is a modern replacement for ls.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;顾名思义 &lt;code&gt;exa&lt;/code&gt; 是一个用来替代 &lt;code&gt;ls&lt;/code&gt; 的工具， &lt;code&gt;exa&lt;/code&gt; 相比于 &lt;code&gt;ls&lt;/code&gt; 增加了很多新的特性，比如：支持不同文件类型可以用不同颜色来展示、&lt;code&gt;exa&lt;/code&gt; 比 &lt;code&gt;ls&lt;/code&gt; 速度更快一些等。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/ogham/exa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ogham/exa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/ogham/exa/raw/master/screenshots.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用 Kind 在 5 分钟内快速部署一个 Kubernetes 高可用集群</title>
    <link href="https://www.hi-linux.com/posts/42332.html"/>
    <id>https://www.hi-linux.com/posts/42332.html</id>
    <published>2020-05-14T01:00:00.000Z</published>
    <updated>2020-05-14T05:17:15.652Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是-kind">什么是 Kind</h2><p><code>Kind</code>（Kubernetes in Docker） 是一个 <code>Kubernetes</code> 孵化项目，<code>Kind</code> 是一套开箱即用的 <code>Kubernetes</code> 环境搭建方案。顾名思义，就是将 <code>Kubernetes</code> 所需要的所有组件，全部部署在一个 <code>Docker</code> 容器中，可以很方便的搭建 <code>Kubernetes</code> 集群。</p><p><code>Kind</code> 已经广泛的应用于 <code>Kubernetes</code> 上游及相关项目的 <code>CI</code> 环境中，官方文档中也把 <code>Kind</code> 作为一种本地集群搭建的工具推荐给大家。</p><blockquote><p>项目地址：<a href="https://github.com/kubernetes-sigs/kind" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kind</a></p></blockquote><p><strong>Kind 可以做什么？</strong></p><ol><li><p>快速创建一个或多个 <code>Kubernetes</code> 集群</p></li><li><p>支持部署高可用的 <code>Kubernetes</code> 集群</p></li><li><p>支持从源码构建并部署一个 <code>Kubernetes</code> 集群</p></li><li><p>可以快速低成本体验一个最新的 <code>Kubernetes</code> 集群，并支持 <code>Kubernetes</code> 的绝大部分功能</p></li><li><p>支持本地离线运行一个多节点集群</p></li></ol><p><strong>Kind 有哪些优势？</strong></p><ol><li><p>最小的安装依赖，仅需要安装 <code>Docker</code> 即可</p></li><li><p>使用方法简单，只需 <code>Kind Cli</code> 工具即可快速创建集群</p></li><li><p>使用容器来模似 <code>Kubernetes</code> 节点</p></li><li><p>内部使用 <code>Kubeadm</code> 的官方主流部署工具</p></li><li><p>通过了 <code>CNCF</code> 官方的 <code>K8S Conformance</code> 测试</p></li></ol><a id="more"></a><p><strong>Kind 是如何工作的？</strong></p><p><img src="https://www.hi-linux.com/img/linux/kind-demo.gif" alt=""></p><p><code>Kind</code> 使用容器来模拟每一个 <code>Kubernetes</code> 节点，并在容器里面运行 <code>Systemd</code>。 容器里的 <code>Systemd</code> 托管了 <code>Kubelet</code> 和 <code>Containerd</code>，然后容器内部的 <code>Kubelet</code> 把其它 <code>Kubernetes</code> 组件：<code>Kube-Apiserver</code>、<code>Etcd</code>、<code>CNI</code> 等等组件运行起来。</p><p><code>Kind</code> 内部使用了 <code>Kubeadm</code> 这个工具来做集群的部署，包括高可用集群也是借助 <code>Kubeadm</code> 提供的特性来完成的。在高用集群下还会额外部署了一个 <code>Nginx</code> 来提供负载均衡 <code>VIP</code>。</p><h2 id="安装-kind">安装 Kind</h2><h3 id="安装-kind-依赖组件">安装 Kind 依赖组件</h3><p><code>Kind</code> 把部署 <code>Kubernetes</code> 环境的依赖降低到了最小，仅需要机器安装 <code>Docker</code> 即可。</p><ol><li>安装 Docker</li></ol><p>这里以 <code>Linux</code> 系统为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh</span><br></pre></td></tr></table></figure><p>更多平台的安装方法可参考官方文档：<a href="https://docs.docker.com/install/" target="_blank" rel="noopener">https://docs.docker.com/install/</a></p><ol start="2"><li>安装 Kubectl</li></ol><p>如果你需要通过命令行管理集群，则需要安装 <code>Kubectl</code>。</p><p>这里以 <code>Linux</code> 系统为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -LO https:&#x2F;&#x2F;storage.googleapis.com&#x2F;kubernetes-release&#x2F;release&#x2F;v1.15.0&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl</span><br><span class="line">$ chmod +x .&#x2F;kubectl</span><br><span class="line">$ sudo mv .&#x2F;kubectl &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kubectl</span><br></pre></td></tr></table></figure><p>更多平台的安装方法可参考官方文档：<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl</a></p><h3 id="安装-kind">安装 Kind</h3><p><code>Kind</code> 使用 <code>Golang</code> 进行开发，原生支持良好的跨平台特性，通常只需要直接下载构建好的二进制文件就可使用。</p><ol><li>通过二进制安装</li></ol><ul><li>Linux</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -Lo .&#x2F;kind https:&#x2F;&#x2F;github.com&#x2F;kubernetes-sigs&#x2F;kind&#x2F;releases&#x2F;download&#x2F;v0.5.1&#x2F;kind-linux-amd64</span><br><span class="line">$ chmod +x .&#x2F;kind</span><br><span class="line">$ mv .&#x2F;kind &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kind</span><br></pre></td></tr></table></figure><ul><li>Windows</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl.exe -Lo kind-windows-amd64.exe https:&#x2F;&#x2F;github.com&#x2F;kubernetes-sigs&#x2F;kind&#x2F;releases&#x2F;download&#x2F;v0.5.1&#x2F;kind-windows-amd64</span><br><span class="line">$ mv .\kind-windows-amd64.exe c:\kind.exe</span><br></pre></td></tr></table></figure><p>更多平台的安装方法可参考官方文档：<a href="https://kind.sigs.k8s.io/docs/user/quick-start/" target="_blank" rel="noopener">https://kind.sigs.k8s.io/docs/user/quick-start/</a></p><ol start="2"><li>通过源码安装</li></ol><p>如果本地环境已经配置好 Golang (1.11+)  的开发环境，你也可以直接通过源码进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get sigs.k8s.io&#x2F;kind@v0.5.1</span><br></pre></td></tr></table></figure><p>运行完上述命令后，会将 <code>Kind</code> 的可执行文件放到 <code>$GOPATH/bin</code> 目录内。为了方便使用，你需要将此目录加入到 <code>$PATH</code> 中。</p><h2 id="使用-kind">使用 Kind</h2><p>安装完成之后，我们可以来看看 <code>Kind</code> 支持哪些命令行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ kind</span><br><span class="line">kind creates and manages local Kubernetes clusters using Docker container &#39;nodes&#39;</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  kind [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  build       Build one of [base-image, node-image]</span><br><span class="line">  create      Creates one of [cluster]</span><br><span class="line">  delete      Deletes one of [cluster]</span><br><span class="line">  export      exports one of [logs]</span><br><span class="line">  get         Gets one of [clusters, nodes, kubeconfig-path]</span><br><span class="line">  help        Help about any command</span><br><span class="line">  load        Loads images into nodes</span><br><span class="line">  version     prints the kind CLI version</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help              help for kind</span><br><span class="line">      --loglevel string   logrus log level [panic, fatal, error, warning, info, debug] (default &quot;warning&quot;)</span><br><span class="line">      --version           version for kind</span><br><span class="line"></span><br><span class="line">Use &quot;kind [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><p>简单说下几个比较常用选项的含义：</p><ul><li><p><code>build</code>：用来从 <code>Kubernetes</code> 源代码构建一个新的镜像。</p></li><li><p><code>create</code>：创建一个 <code>Kubernetes</code> 集群。</p></li><li><p><code>delete</code>：删除一个 <code>Kubernetes</code> 集群。</p></li><li><p><code>get</code>： 可用来查看当前集群、节点信息以及 <code>Kubectl</code> 配置文件的地址。</p></li><li><p><code>load</code>：从宿主机向 <code>Kubernetes</code> 节点内导入镜像。</p></li></ul><h2 id="使用-kind-创建-kubernetes-集群">使用 Kind 创建 Kubernetes 集群</h2><h3 id="搭建一个单节点集群">搭建一个单节点集群</h3><p>搭建单节点集群是 <code>Kind</code> 最基础的功能，当然使用起来也很简单，仅需一条指令即可完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kind create cluster --name my-cluster</span><br><span class="line">Creating cluster &quot;my-cluster&quot; ...</span><br><span class="line"> ✓ Ensuring node image (kindest&#x2F;node:v1.15.3) 🖼</span><br><span class="line"> ✓ Preparing nodes 📦</span><br><span class="line"> ✓ Creating kubeadm config 📜</span><br><span class="line"> ✓ Starting control-plane 🕹️</span><br><span class="line">Cluster creation complete. You can now use the cluster with:</span><br><span class="line"></span><br><span class="line">export KUBECONFIG&#x3D;&quot;$(kind get kubeconfig-path --name&#x3D;&quot;my-cluster&quot;)&quot;</span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><blockquote><p>以上命令中 <code>--name</code> 是可选参数。如果不指定，默认创建出来的集群名字为 <code>kind</code>。</p></blockquote><p>使用默认安装的方式时，我们没有指定任何配置文件。从安装过程的输出来看，一共分为 4 步：</p><ul><li><p>检查本地环境是否存在一个基础的安装镜像，默认是 <code>kindest/node:v1.15.3</code>，该镜像里面包含了所有需要安装的东西，包括：<code>kubectl</code>、<code>kubeadm</code>、<code>kubelet</code> 的二进制文件，以及安装对应版本 <code>Kubernetes</code> 所需要的镜像。</p></li><li><p>准备 <code>Kubernetes</code> 节点，主要就是启动容器、解压镜像这类的操作。</p></li><li><p>建立对应的 <code>kubeadm</code> 的配置，完成之后就通过 <code>kubeadm</code> 进行安装。安装完成后还会做一些清理操作，比如：删掉主节点上的污点，否则对于没有容忍的 <code>Pod</code> 无法完成部署。</p></li><li><p>上面所有操作都完成后，就成功启动了一个 <code>Kubernetes</code> 集群并输出一些操作集群的提示信息。</p></li></ul><blockquote><ol><li><p>默认情况下，<code>Kind</code> 会先下载 <code>kindest/node:v1.15.3</code> 镜像。如果你想指定不同版本，可以使用 <code>--image</code> 参数，类似这样：<code>kind create cluster --image kindest/node:v1.15.3</code></p></li><li><p><code>kindest/node</code> 这个镜像目前托管于 Docker Hub 上，下载时可能会较慢。同样的问题 <code>Kind</code> 进行集群的创建也是存在的，<code>Kind</code> 实际使用 <code>Kubeadm</code> 进行集群的创建。对 <code>Kubeadm</code> 有所了解的同学都知道它默认使用的镜像在国内是不能访问的，所以一样需要自行解决网络问题。</p></li><li><p>如果你存在上面说的网络问题，最好配置一个国内的加速器或者镜像源。如果你还不知道如何配置加速器和镜像源可以参考：「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247488553&amp;idx=1&amp;sn=14cbe47bc50df50f536345efb4d10b5e&amp;chksm=eac53500ddb2bc16be6bbfe69917895d0feed7c4e85d40450a5adb931ff01257d9f546c58538&amp;token=687022088&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Docker / Kubernetes 镜像源不可用，教你几招搞定它！</a>」和 「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483698&amp;idx=1&amp;sn=dfb6edca74539a9a4d8228495d1c17a0&amp;chksm=eac5201bddb2a90d5f8e6d4733ed2d0ff9466474471933e4ea5d5fc1ef6be15b86470f50eccb&amp;token=21948731&amp;lang=zh_CN#rd" target="_blank" rel="noopener"> Docker 下使用 DaoCloud / 阿里云镜像加速</a>」两篇文章。</p></li></ol></blockquote><p>接下来，我们根据上面命令执行完后，输出的提示信息进行操作来验证一下集群是否部署成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 获取指定集群的配置文件所在的路径</span><br><span class="line">$ export KUBECONFIG&#x3D;&quot;$(kind get kubeconfig-path --name&#x3D;&quot;my-cluster&quot;)&quot;</span><br><span class="line">$ kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https:&#x2F;&#x2F;localhost:34458</span><br><span class="line">KubeDNS is running at https:&#x2F;&#x2F;localhost:34458&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;services&#x2F;kube-dns:dns&#x2F;proxy</span><br><span class="line">To further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.</span><br><span class="line"></span><br><span class="line">$ kubectl get nodes</span><br><span class="line">NAME                       STATUS    ROLES     AGE       VERSION</span><br><span class="line">my-cluster-control-plane   Ready     master    2m        v1.15.3</span><br><span class="line"></span><br><span class="line">$ kubectl get po -n kube-system</span><br><span class="line">NAME                                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-86c58d9df4-6g66f                              1&#x2F;1     Running   0          21m</span><br><span class="line">coredns-86c58d9df4-pqcc4                              1&#x2F;1     Running   0          21m</span><br><span class="line">etcd-my-cluster-control-plane                         1&#x2F;1     Running   0          20m</span><br><span class="line">kube-apiserver-my-cluster-control-plane               1&#x2F;1     Running   0          20m</span><br><span class="line">kube-controller-manager-my-cluster-control-plane      1&#x2F;1     Running   0          20m</span><br><span class="line">kube-proxy-cjgnt                                      1&#x2F;1     Running   0          21m</span><br><span class="line">kube-scheduler-my-cluster-control-plane               1&#x2F;1     Running   0          21m</span><br><span class="line">weave-net-ls2v8                                       2&#x2F;2     Running   1          21m</span><br></pre></td></tr></table></figure><p>从上面的输出结果，可以看到单节点的 <code>Kubernetes</code> 已经搭建成功。单节点集群默认方式启动的节点类型是 <code>control-plane</code>，该节点包含了所有的组件。这些组件分别是：<code>2*Coredns</code>、<code>Etcd</code>、<code>Api-Server</code>、<code>Controller-Manager</code>、<code>Kube-Proxy</code>、<code>Sheduler</code> 和网络插件 <code>Weave</code>，目前默认使用的网络插件也是 <code>Weave</code>。</p><h3 id="创建多节点的集群">创建多节点的集群</h3><p>默认安装的集群只部署了一个控制节点，如果需要部署多节点集群，我们可以通过配置文件的方式来创建多个容器。这样就可以达到模拟多个节点目的，并以这些节点来构建一个多节点的 <code>Kubernetes</code> 集群。</p><ol><li>创建多节点 Kubernetes 集群配置文件</li></ol><p><code>Kind</code> 在创建集群的时候，支持通过 <code>--config</code> 参数传递配置文件给 <code>Kind</code>，配置文件可修改的内容主要有 role 和 节点使用的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vim my-cluster-multi-node.yaml</span><br><span class="line"># 一共两个节点，一个主节点，一个从节点。</span><br><span class="line">kind: Cluster</span><br><span class="line">apiVersion: kind.sigs.k8s.io&#x2F;v1alpha3</span><br><span class="line">nodes:</span><br><span class="line">- role: control-plane</span><br><span class="line">- role: worker</span><br></pre></td></tr></table></figure><ol start="2"><li>创建多节点 Kubernetes 集群</li></ol><p>配置文件创建完成后，就可以使用下面的命令来完成多节点 <code>Kubernetes</code> 集群搭建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kind create cluster --config my-cluster-multi-node.yaml --name my-cluster-multi-node</span><br><span class="line">Creating cluster &quot;my-cluster-multi-node&quot; ...</span><br><span class="line"> ✓ Ensuring node image (kindest&#x2F;node:v1.15.3) 🖼</span><br><span class="line"> ✓ Preparing nodes 📦📦 </span><br><span class="line"> ✓ Creating kubeadm config 📜 </span><br><span class="line"> ✓ Starting control-plane 🕹️ </span><br><span class="line"> ✓ Joining worker nodes 🚜 </span><br><span class="line">Cluster creation complete. You can now use the cluster with:</span><br><span class="line"></span><br><span class="line">export KUBECONFIG&#x3D;&quot;$(kind get kubeconfig-path --name&#x3D;&quot;my-cluster-multi-node&quot;)&quot;</span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><p>和上面创建的单节点集群一样，我们同样根据上面命令执行完后，输出的提示信息进行操作来验证一下集群是否部署成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME                                  STATUS   ROLES    AGE     VERSION</span><br><span class="line">my-cluster-multi-node-control-plane   Ready    master   3m20s   v1.15.3</span><br><span class="line">my-cluster-multi-node-worker          Ready    &lt;none&gt;   3m8s    v1.15.3</span><br><span class="line"></span><br><span class="line">$ kubectl get po -n kube-system</span><br><span class="line">NAME                                                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-86c58d9df4-cnqhc                                      1&#x2F;1     Running   0          5m29s</span><br><span class="line">coredns-86c58d9df4-hn9mv                                      1&#x2F;1     Running   0          5m29s</span><br><span class="line">etcd-my-cluster-multi-node-control-plane                      1&#x2F;1     Running   0          4m24s</span><br><span class="line">kube-apiserver-my-cluster-multi-node-control-plane            1&#x2F;1     Running   0          4m17s</span><br><span class="line">kube-controller-manager-my-cluster-multi-node-control-plane   1&#x2F;1     Running   0          4m21s</span><br><span class="line">kube-proxy-8t4xt                                              1&#x2F;1     Running   0          5m27s</span><br><span class="line">kube-proxy-skd5v                                              1&#x2F;1     Running   0          5m29s</span><br><span class="line">kube-scheduler-my-cluster-multi-node-control-plane            1&#x2F;1     Running   0          4m18s</span><br><span class="line">weave-net-nmfq2                                               2&#x2F;2     Running   1          5m27s</span><br><span class="line">weave-net-srdfw                                               2&#x2F;2     Running   0          5m29s</span><br></pre></td></tr></table></figure><h3 id="创建高可用-kubernetes-集群">创建高可用 Kubernetes 集群</h3><p><code>Kind</code> 也支持搭建高可用的 <code>Kubernetes</code> 集群，创建方式和多节点集群类似，也是通过配置文件来实现。</p><ol><li>创建高可用 Kubernetes 集群配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ vim my-cluster-ha.yaml</span><br><span class="line"></span><br><span class="line"># 一共六个节点，三个 control-plane 节点，三个 workers 节点</span><br><span class="line">kind: Cluster</span><br><span class="line">apiVersion: kind.sigs.k8s.io&#x2F;v1alpha3</span><br><span class="line">kubeadmConfigPatches:</span><br><span class="line">- |</span><br><span class="line">  apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">  kind: ClusterConfiguration</span><br><span class="line">  metadata:</span><br><span class="line">    name: config</span><br><span class="line">  networking:</span><br><span class="line">    serviceSubnet: 10.0.0.0&#x2F;16</span><br><span class="line">  imageRepository: registry.aliyuncs.com&#x2F;google_containers</span><br><span class="line">  nodeRegistration:</span><br><span class="line">    kubeletExtraArgs:</span><br><span class="line">      pod-infra-container-image: registry.aliyuncs.com&#x2F;google_containers&#x2F;pause:3.1</span><br><span class="line">- |</span><br><span class="line">  apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">  kind: InitConfiguration</span><br><span class="line">  metadata:</span><br><span class="line">    name: config</span><br><span class="line">  networking:</span><br><span class="line">    serviceSubnet: 10.0.0.0&#x2F;16</span><br><span class="line">  imageRepository: registry.aliyuncs.com&#x2F;google_containers</span><br><span class="line">nodes:</span><br><span class="line">- role: control-plane</span><br><span class="line">- role: control-plane</span><br><span class="line">- role: control-plane</span><br><span class="line">- role: worker</span><br><span class="line">- role: worker</span><br><span class="line">- role: worker</span><br></pre></td></tr></table></figure><blockquote><p>这里，我们通过直接在配置文件里使用国内容器镜像源的方式解决了官方容器镜像源不可用的问题，同时也达到了加速集群创建的目的。</p></blockquote><ol start="2"><li>创建高可用 Kubernetes 集群</li></ol><p>配置文件创建完成后，就可以使用下面的命令来完成高可用 <code>Kubernetes</code> 集群搭建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ kind create cluster --name my-cluster-ha --config my-cluster-ha.yaml</span><br><span class="line">Creating cluster &quot;my-cluster-ha&quot; ...</span><br><span class="line"> ✓ Ensuring node image (kindest&#x2F;node:v1.15.3) 🖼</span><br><span class="line"> ✓ Preparing nodes 📦📦📦📦📦📦📦</span><br><span class="line"> ✓ Starting the external load balancer ⚖️</span><br><span class="line"> ✓ Creating kubeadm config 📜</span><br><span class="line"> ✓ Starting control-plane 🕹️</span><br><span class="line"> ✓ Joining more control-plane nodes 🎮</span><br><span class="line"> ✓ Joining worker nodes 🚜</span><br><span class="line">Cluster creation complete. You can now use the cluster with:</span><br><span class="line"></span><br><span class="line">export KUBECONFIG&#x3D;&quot;$(kind get kubeconfig-path --name&#x3D;&quot;my-cluster-ha&quot;)&quot;</span><br><span class="line">kubectl cluster-info</span><br><span class="line">master $ export KUBECONFIG&#x3D;&quot;$(kind get kubeconfig-path --name&#x3D;&quot;my-cluster-ha&quot;)&quot;</span><br><span class="line">master $ kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https:&#x2F;&#x2F;localhost:44019</span><br><span class="line">KubeDNS is running at https:&#x2F;&#x2F;localhost:44019&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;services&#x2F;kube-dns:dns&#x2F;proxy</span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.</span><br></pre></td></tr></table></figure><p>同样，我们根据上面命令执行完后，输出的提示信息进行操作来验证一下集群是否部署成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME                           STATUS   ROLES    AGE     VERSION</span><br><span class="line">my-cluster-ha-control-plane    Ready    master   3m42s   v1.15.3</span><br><span class="line">my-cluster-ha-control-plane2   Ready    master   3m24s   v1.15.3</span><br><span class="line">my-cluster-ha-control-plane3   Ready    master   2m13s   v1.15.3</span><br><span class="line">my-cluster-ha-worker           Ready    &lt;none&gt;   96s     v1.15.3</span><br><span class="line">my-cluster-ha-worker2          Ready    &lt;none&gt;   98s     v1.15.3</span><br><span class="line">my-cluster-ha-worker3          Ready    &lt;none&gt;   95s     v1.15.3</span><br></pre></td></tr></table></figure><p>从上面的输出结果，可以看到包含了多个 master 节点，说明高可用的 <code>Kubernetes</code> 集群已经搭建成功。</p><h2 id="其它相关知识">其它相关知识</h2><h3 id="kind-的镜像里的秘密">Kind 的镜像里的秘密</h3><p><code>Kind</code> 镜像一共分为两类，一类是 <code>Base</code> 镜像，另一类是 <code>Node</code> 镜像。</p><ol><li>Base 镜像</li></ol><p>Base 镜像目前使用了 <code>ubuntu:19.04</code> 作为基础镜像，并做了下面的调整：</p><ul><li><p>安装 <code>Systemd</code> 相关的包，并调整一些配置以适应在容器内运行。</p></li><li><p>安装 <code>Kubernetes</code> 运行时的依赖包，比如: <code>Conntrack</code>、<code>Socat</code>、<code>CNI</code> 等。</p></li><li><p>安装容器运行环境，比如: <code>Containerd</code>、<code>Crictl</code> 等。</p></li><li><p>配置自己的 <code>ENTRYPOINT</code> 脚本，以适应和调整容器内运行的问题。</p></li></ul><p>更多具体的构建逻辑可以参考：<a href="https://github.com/kubernetes-sigs/kind/blob/master/images/base/Dockerfile" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kind/blob/master/images/base/Dockerfile</a></p><ol start="2"><li>Node 镜像</li></ol><p><code>Node</code> 镜像的构建比较复杂，目前是通过运行 <code>Base</code> 镜像并在 <code>Base</code> 镜像内执行操作，再保存此容器内容为镜像的方式来构建的，包含的操作有：</p><ul><li><p>构建 <code>Kubernetes</code> 相关资源，比如：二进制文件和镜像。</p></li><li><p>运行一个用于构建的容器</p></li><li><p>把构建的 <code>Kubernetes</code> 相关资源复制到容器里</p></li><li><p>调整部分组件配置参数，以支持在容器内运行</p></li><li><p>预先拉去运行环境需要的镜像</p></li><li><p>通过 <code>docker commit</code> 方式保存当前的构建容器为 <code>Node</code> 镜像</p></li></ul><h3 id="如何快速删除一个集群">如何快速删除一个集群</h3><p>如果你不需要本地的集群环境，通过以下命令进行删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kind delete  cluster --name my-cluster</span><br><span class="line">Deleting cluster &quot;my-cluster&quot; ...</span><br><span class="line">$KUBECONFIG is still set to use &#x2F;root&#x2F;.kube&#x2F;kind-config-my-cluster even though that file has been deleted, remember to unset it</span><br></pre></td></tr></table></figure><p>至此，我们就演示完了如何使用 <code>Kind</code> 快速搭建一个 <code>Kubernetes</code> 集群。 不过有一个你需要注意的地方，<code>Kind</code> 搭建的集群不适用于生产环境中使用。但是如果你想在本地快速构建一个 <code>Kubernetes</code> 集群环境，并且不想占用太多的硬件资源，那么 <code>Kind</code> 会是你不错的选择。</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="http://t.cn/AiRVBwDS" target="_blank" rel="noopener">http://t.cn/AiRVBwDS</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/60464867" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60464867</a></p></li><li><p><a href="https://yeya24.github.io/post/kind/" target="_blank" rel="noopener">https://yeya24.github.io/post/kind/</a></p></li><li><p><a href="http://dockerone.com/article/8974" target="_blank" rel="noopener">http://dockerone.com/article/8974</a></p></li><li><p><a href="https://kind.sigs.k8s.io/docs/user/quick-start/" target="_blank" rel="noopener">https://kind.sigs.k8s.io/docs/user/quick-start/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Kind&quot;&gt;什么是 Kind&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Kind&lt;/code&gt;（Kubernetes in Docker） 是一个 &lt;code&gt;Kubernetes&lt;/code&gt; 孵化项目，&lt;code&gt;Kind&lt;/code&gt; 是一套开箱即用的 &lt;code&gt;Kubernetes&lt;/code&gt; 环境搭建方案。顾名思义，就是将 &lt;code&gt;Kubernetes&lt;/code&gt; 所需要的所有组件，全部部署在一个 &lt;code&gt;Docker&lt;/code&gt; 容器中，可以很方便的搭建 &lt;code&gt;Kubernetes&lt;/code&gt; 集群。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Kind&lt;/code&gt; 已经广泛的应用于 &lt;code&gt;Kubernetes&lt;/code&gt; 上游及相关项目的 &lt;code&gt;CI&lt;/code&gt; 环境中，官方文档中也把 &lt;code&gt;Kind&lt;/code&gt; 作为一种本地集群搭建的工具推荐给大家。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/kubernetes-sigs/kind&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes-sigs/kind&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Kind 可以做什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;快速创建一个或多个 &lt;code&gt;Kubernetes&lt;/code&gt; 集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持部署高可用的 &lt;code&gt;Kubernetes&lt;/code&gt; 集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持从源码构建并部署一个 &lt;code&gt;Kubernetes&lt;/code&gt; 集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以快速低成本体验一个最新的 &lt;code&gt;Kubernetes&lt;/code&gt; 集群，并支持 &lt;code&gt;Kubernetes&lt;/code&gt; 的绝大部分功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持本地离线运行一个多节点集群&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Kind 有哪些优势？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;最小的安装依赖，仅需要安装 &lt;code&gt;Docker&lt;/code&gt; 即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用方法简单，只需 &lt;code&gt;Kind Cli&lt;/code&gt; 工具即可快速创建集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用容器来模似 &lt;code&gt;Kubernetes&lt;/code&gt; 节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部使用 &lt;code&gt;Kubeadm&lt;/code&gt; 的官方主流部署工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过了 &lt;code&gt;CNCF&lt;/code&gt; 官方的 &lt;code&gt;K8S Conformance&lt;/code&gt; 测试&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>分享几个让 Linux 非 Root 用户运行的程序使用特权端口的技巧</title>
    <link href="https://www.hi-linux.com/posts/26613.html"/>
    <id>https://www.hi-linux.com/posts/26613.html</id>
    <published>2020-05-13T01:00:00.000Z</published>
    <updated>2020-05-13T04:59:42.628Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，在 <code>Linux</code> 系统下，只允许 <code>Root</code> 用户运行的程序才可以使用特权端口 ( <code>1024</code> 以下的端口 )。如果在普通用户下使用特权端口将会报错。</p><p>在一些特定的环境下，我们可能考虑到程序运行在 <code>Root</code> 帐户下，可能会给 <code>Linux</code> 系统带来安全风险。希望能让普通用户启动的程序运行在特权端口上，比如：Web 服务器。</p><p>那如何能够让普通用户启动的程序运行在特权端口呢？本文将介绍一些方法，让你能够解决这个问题。</p><h2 id="通过设置-cap_net_bind_service-实现">通过设置 CAP_NET_BIND_SERVICE 实现</h2><p><code>Linux</code> 内核从 2.6.24 版本开始就有了能力的概念，这使得普通用户也能够做只有超级用户才能完成的工作。</p><p>使用 <code>setcap</code> 命令让指定程序拥有绑定端口的能力，这样即使程序运行在普通用户下，也能够绑定到 1024 以下的特权端口上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 给指定程序设置 CAP_NET_BIND_SERVICE 能力</span><br><span class="line">$ setcap cap_net_bind_service&#x3D;+eip &#x2F;path&#x2F;to&#x2F;application</span><br></pre></td></tr></table></figure><p>下面我们来看一个实例，以 <code>Nginx</code> 为例：</p><p><img src="https://www.hi-linux.com/img/linux/setcap.jpg" alt=""></p><p>如果你的程序不再需要使用这个能力，你可以使用以下命令来清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setcap -r &#x2F;path&#x2F;to&#x2F;application</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>这个方法并不是所有 <code>Linux</code> 系统通用，<code>Linux</code> 内核在 2.6.24 之前的并没有提供此项能力，因此你需要检查要使用此方法所在系统是否支持。</p></li><li><p>另外需要注意的是，如果要运行的程序是一个脚本，这个方法是没有办法正常工作的。</p></li></ol></blockquote><a id="more"></a><h2 id="通过端口转发实现">通过端口转发实现</h2><p>如果要运行的程序有权限监听其他端口，那么这个方法是可以使用的。首先让程序运行在普通用户下，并绑定高于 1024 的端口。在确保能正常工作的时候，我们将通过端口转发将低端口的请求转到应用所在的高端口，从而实现普通用户启动的程序绑定到低端口。要使用此方法可以使用下面的方式。</p><ol><li>配置内核参数以启用转发功能</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Enable the IP FORWARD kernel parameter.</span><br><span class="line">$ sysctl -w net.ipv4.ip_forward&#x3D;1</span><br></pre></td></tr></table></figure><p>以上方法是临时性设置，重启之后将会被重置。如果你想长期保存，需要在 <code>/etc/sysctl.conf</code> 文件内修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim  &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line"># Default value is 0, need change to 1.</span><br><span class="line"># net.ipv4.ip_forward &#x3D; 0</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br></pre></td></tr></table></figure><p>然后，使用 <code>sysctl</code> 命令从文件中加载新的配置，并使其生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># load new sysctl.conf</span><br><span class="line">$ sysctl -p &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"> </span><br><span class="line"># or sysctl -p</span><br><span class="line"># default filename is &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>配置转发规则</li></ol><p>这里我们使用 <code>Iptables</code> 来配置的转发规则，以实现端口转发到程序所在的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将 80 端口转发到 8088</span><br><span class="line">$ iptables -F -t nat</span><br><span class="line">$ iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to:8088</span><br></pre></td></tr></table></figure><p>此种方法能够比较好的达到我们的目的，我们的程序可以通过普通用户来运行，并能够对外提供低端口号的服务。</p><h2 id="通过-authbind-实现">通过 authbind 实现</h2><p><code>authbind</code> 是一个支持普通用户就能绑定系统特权端口的程序，你只需要使用 <code>authbind</code> 程序来调用需要使用特权端口的程序就可以了。</p><ol><li>安装 authbind</li></ol><ul><li>Debian / Ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install authbind</span><br></pre></td></tr></table></figure><ul><li>CentOS / RHEL</li></ul><p>CentOS 系列的系统安装起来相对就要麻烦一些，因为官方仓库并没有提供编译好的软件包。不过幸运的是，已经有人编译好了对应的软件包，我们只需要直接安装就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -ivh https:&#x2F;&#x2F;s3.amazonaws.com&#x2F;aaronsilber&#x2F;public&#x2F;authbind-2.1.1-0.1.x86_64.rpm</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 authbind</li></ol><p><code>authbind</code> 默认的配置文件在 <code>/etc/authbind</code> 目录下，里面有三个目录：<code>byport</code>、<code>byaddr</code>、<code>byuid</code>。</p><p>假如我们有一个 test 的普通账号，想运行一个程序并绑定在 80 端口上。我们需要配置以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在 byport 目录下建立 80 文件</span><br><span class="line">$ sudo touch &#x2F;etc&#x2F;authbind&#x2F;byport&#x2F;80</span><br><span class="line"># 设置 test 账户有 80 文件的使用权限</span><br><span class="line">$ sudo chmod 755 &#x2F;etc&#x2F;authbind&#x2F;byport&#x2F;80</span><br><span class="line">$ sudo chown test.test &#x2F;etc&#x2F;authbind&#x2F;byport&#x2F;80</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 authbind 运行指定程序</li></ol><p>在你要启动的命令前加上 <code>authbind --deep</code> 命令即可。例如：要用 test 这个普通用户启动 <code>Nginx</code> 并绑定在 80 端口，只需执行以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ authbind --deep &quot;&#x2F;usr&#x2F;bin&#x2F;nginx&quot; -c &quot;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&quot;</span><br></pre></td></tr></table></figure><p>我们也可以直接在 IP 地址上直接绑定端口，只需在 <code>byaddr</code> 目录下建立 <code>ip:port</code> 文件就可以了。</p><h2 id="通过-setuid-实现">通过 SetUID 实现</h2><p><code>SetUID</code> 这一特性可以让只有普通用户权限的应用程序用 Root 权限来运行，我们可以看到系统下 <code>/usr/bin/passwd</code> 这个文件，就使用了 <code>SetUID</code>。这样就使得系统的每个普通用户都能用 <code>passwd</code> 来修改密码，因为修改密码需要更改 <code>/etc/passwd</code> 文件，而默认这个文件只有 Root 用户才有权限访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将程序的所有者更改为 root</span><br><span class="line">$ chown root.root &#x2F;path&#x2F;to&#x2F;application</span><br><span class="line"></span><br><span class="line"># 给程序设置 SetUID</span><br><span class="line">$ chmod u+s &#x2F;path&#x2F;to&#x2F;application</span><br></pre></td></tr></table></figure><p>既然要使用普通用户运行程序，目的就是要降低程序本身给系统带来的安全风险。因此，本方法使用的时候需要特别谨慎，特别是当要执行的程序本身存在安全风险。</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://www.cnblogs.com/chenjunjie12321/p/9226279.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenjunjie12321/p/9226279.html</a></li><li><a href="https://blog.csdn.net/Becivells/article/details/52842019" target="_blank" rel="noopener">https://blog.csdn.net/Becivells/article/details/52842019</a></li><li><a href="https://my.oschina.net/guol/blog/186430" target="_blank" rel="noopener">https://my.oschina.net/guol/blog/186430</a></li><li><a href="https://github.com/tootedom/authbind-centos-rpm" target="_blank" rel="noopener">https://github.com/tootedom/authbind-centos-rpm</a></li><li><a href="https://dzone.com/articles/running-tomcat-port-80-user" target="_blank" rel="noopener">https://dzone.com/articles/running-tomcat-port-80-user</a></li><li><a href="http://blog.useasp.net/archive/2015/07/09/non-root-user-application-bind-to-ports-less-than-1024-without-root-access.aspx" target="_blank" rel="noopener">http://blog.useasp.net/archive/2015/07/09/non-root-user-application-bind-to-ports-less-than-1024-without-root-access.aspx</a></li><li><a href="https://stackoverflow.com/questions/413807/is-there-a-way-for-non-root-processes-to-bind-to-privileged-ports-on-linux" target="_blank" rel="noopener">https://stackoverflow.com/questions/413807/is-there-a-way-for-non-root-processes-to-bind-to-privileged-ports-on-linux</a></li><li><a href="https://aaronsilber.me/2016/04/24/install-authbind-on-centos-7-x86_64-download-the-rpm/" target="_blank" rel="noopener">https://aaronsilber.me/2016/04/24/install-authbind-on-centos-7-x86_64-download-the-rpm/</a></li><li><a href="https://blog.webhosting.net/how-to-get-tomcat-running-on-centos-7-2-using-privileged-ports-1024/" target="_blank" rel="noopener">https://blog.webhosting.net/how-to-get-tomcat-running-on-centos-7-2-using-privileged-ports-1024/</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，在 &lt;code&gt;Linux&lt;/code&gt; 系统下，只允许 &lt;code&gt;Root&lt;/code&gt; 用户运行的程序才可以使用特权端口 ( &lt;code&gt;1024&lt;/code&gt; 以下的端口 )。如果在普通用户下使用特权端口将会报错。&lt;/p&gt;
&lt;p&gt;在一些特定的环境下，我们可能考虑到程序运行在 &lt;code&gt;Root&lt;/code&gt; 帐户下，可能会给 &lt;code&gt;Linux&lt;/code&gt; 系统带来安全风险。希望能让普通用户启动的程序运行在特权端口上，比如：Web 服务器。&lt;/p&gt;
&lt;p&gt;那如何能够让普通用户启动的程序运行在特权端口呢？本文将介绍一些方法，让你能够解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;通过设置-CAP-NET-BIND-SERVICE-实现&quot;&gt;通过设置 CAP_NET_BIND_SERVICE 实现&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 内核从 2.6.24 版本开始就有了能力的概念，这使得普通用户也能够做只有超级用户才能完成的工作。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;setcap&lt;/code&gt; 命令让指定程序拥有绑定端口的能力，这样即使程序运行在普通用户下，也能够绑定到 1024 以下的特权端口上。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 给指定程序设置 CAP_NET_BIND_SERVICE 能力&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ setcap cap_net_bind_service&amp;#x3D;+eip &amp;#x2F;path&amp;#x2F;to&amp;#x2F;application&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面我们来看一个实例，以 &lt;code&gt;Nginx&lt;/code&gt; 为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/setcap.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你的程序不再需要使用这个能力，你可以使用以下命令来清除。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ setcap -r &amp;#x2F;path&amp;#x2F;to&amp;#x2F;application&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这个方法并不是所有 &lt;code&gt;Linux&lt;/code&gt; 系统通用，&lt;code&gt;Linux&lt;/code&gt; 内核在 2.6.24 之前的并没有提供此项能力，因此你需要检查要使用此方法所在系统是否支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外需要注意的是，如果要运行的程序是一个脚本，这个方法是没有办法正常工作的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>巧用 GoTTY 优雅的管理 Docker 容器权限</title>
    <link href="https://www.hi-linux.com/posts/33412.html"/>
    <id>https://www.hi-linux.com/posts/33412.html</id>
    <published>2020-05-13T01:00:00.000Z</published>
    <updated>2020-05-13T05:23:34.054Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>GoTTY</code> 是一个简单的基于 <code>Go</code> 语言的命令行工具，它可以将你的终端（TTY）作为 <code>Web</code> 程序共享。<code>GoTTY</code> 的架构是基于 <code>Hterm</code> + <code>Web Socket</code> 的，它能在 <code>Web</code> 浏览器上运行一个基于 <code>JavaScript</code> 的终端，并支持通过 <code>HTTP</code> 和 <code>HTTPS</code> 访问。</p><blockquote><p>项目地址：<a href="https://github.com/yudai/gotty" target="_blank" rel="noopener">https://github.com/yudai/gotty</a></p></blockquote><p><img src="https://raw.githubusercontent.com/yudai/gotty/master/screenshot.gif" alt=""></p><h2 id="安装-gotty">安装 GoTTY</h2><p><code>GoTTY</code> 原生支持良好的跨平台性，开箱即用。只需下载对应平台的二进制包就行了，这里以 <code>Linux</code> 平台为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 下载并解压 GoTTY 安装包</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;yudai&#x2F;gotty&#x2F;releases&#x2F;download&#x2F;v1.0.1&#x2F;gotty_linux_amd64.tar.gz</span><br><span class="line">$ tar -xzvf gotty_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 复制可执行文件到指定目录并赋予执行权限</span><br><span class="line">$ sudo cp gotty &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">$ chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;gotty</span><br></pre></td></tr></table></figure><p>更多平台的二进制安装包，可自行在官方项目地址的 <a href="https://github.com/yudai/gotty/releases" target="_blank" rel="noopener">Releases</a> 页面进行下载。</p><p>如果你使用的是 Mac，也可以通过 <code>Homebrew</code> 来实现一键安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install yudai&#x2F;gotty&#x2F;gotty</span><br></pre></td></tr></table></figure><p>安装完成后，检查一下 <code>Gotty</code> 的版本，以验证是否安装正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gotty -version</span><br><span class="line">gotty version 1.0.1</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="使用-gotty">使用 GoTTY</h2><p>你可以使用任何命令来作为 <code>GoTTY</code> 的参数运行，例如：<code>gotty top</code>。</p><h3 id="gotty-语法">GoTTY 语法</h3><ol><li>GoTTY 命令的常规语法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: gotty [options] &lt;command&gt; [&lt;arguments...&gt;]</span><br></pre></td></tr></table></figure><ol start="2"><li>GoTTY 命令的常用参数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--address value, -a value     IP address to listen (default: &quot;0.0.0.0&quot;) [$GOTTY_ADDRESS]</span><br><span class="line">--port value, -p value        Port number to liten (default: &quot;8080&quot;) [$GOTTY_PORT]</span><br><span class="line">--permit-write, -w            Permit clients to write to the TTY (BE CAREFUL) [$GOTTY_PERMIT_WRITE]</span><br><span class="line">--credential value, -c value  Credential for Basic Authentication (ex: user:pass, default disabled) [$GOTTY_CREDENTIAL]</span><br><span class="line">--random-url, -r              Add a random string to the URL [$GOTTY_RANDOM_URL]</span><br><span class="line">--random-url-length value     Random URL length (default: 8) [$GOTTY_RANDOM_URL_LENGTH]</span><br><span class="line">--tls, -t                     Enable TLS&#x2F;SSL [$GOTTY_TLS]</span><br><span class="line">--tls-crt value               TLS&#x2F;SSL certificate file path (default: &quot;~&#x2F;.gotty.crt&quot;) [$GOTTY_TLS_CRT]</span><br><span class="line">--tls-key value               TLS&#x2F;SSL key file path (default: &quot;~&#x2F;.gotty.key&quot;) [$GOTTY_TLS_KEY]</span><br><span class="line">--tls-ca-crt value            TLS&#x2F;SSL CA certificate file for client certifications (default: &quot;~&#x2F;.gotty.ca.crt&quot;) [$GOTTY_TLS_CA_CRT]</span><br><span class="line">--index value                 Custom index.html file [$GOTTY_INDEX]</span><br><span class="line">--title-format value          Title format of browser window (default: &quot;&#123;&#123; .command &#125;&#125;@&#123;&#123; .hostname &#125;&#125;&quot;) [$GOTTY_TITLE_FORMAT]</span><br><span class="line">--reconnect                   Enable reconnection [$GOTTY_RECONNECT]</span><br><span class="line">--reconnect-time value        Time to reconnect (default: 10) [$GOTTY_RECONNECT_TIME]</span><br><span class="line">--max-connection value        Maximum connection to gotty (default: 0) [$GOTTY_MAX_CONNECTION]</span><br><span class="line">--once                        Accept only one client and exit on disconnection [$GOTTY_ONCE]</span><br><span class="line">--timeout value               Timeout seconds for waiting a client(0 to disable) (default: 0) [$GOTTY_TIMEOUT]</span><br><span class="line">--permit-arguments            Permit clients to send command line arguments in URL (e.g. http:&#x2F;&#x2F;example.com:8080&#x2F;?arg&#x3D;AAA&amp;arg&#x3D;BBB) [$GOTTY_PERMIT_ARGUMENTS]</span><br><span class="line">--width value                 Static width of the screen, 0(default) means dynamically resize (default: 0) [$GOTTY_WIDTH]</span><br><span class="line">--height value                Static height of the screen, 0(default) means dynamically resize (default: 0) [$GOTTY_HEIGHT]</span><br><span class="line">--ws-origin value             A regular expression that matches origin URLs to be accepted by WebSocket. No cross origin requests are acceptable by default [$GOTTY_WS_ORIGIN]</span><br><span class="line">--term value                  Terminal name to use on the browser, one of xterm or hterm. (default: &quot;xterm&quot;) [$GOTTY_TERM]</span><br><span class="line">--close-signal value          Signal sent to the command process when gotty close it (default: SIGHUP) (default: 1) [$GOTTY_CLOSE_SIGNAL]</span><br><span class="line">--close-timeout value         Time in seconds to force kill process after client is disconnected (default: -1) (default: -1) [$GOTTY_CLOSE_TIMEOUT]</span><br><span class="line">--config value                Config file path (default: &quot;~&#x2F;.gotty&quot;) [$GOTTY_CONFIG]</span><br><span class="line">--version, -v                 print the version</span><br></pre></td></tr></table></figure><ol start="3"><li>GoTTY 的配置文件</li></ol><p>除了通过命令行直接给 <code>GoTTY</code> 指定参数外，你还可以通过向 <code>GoTTY</code> 命令提供配置文件来自定义默认参数和终端的样式。默认情况下，<code>GoTTY</code> 会加载用户目录下的 <code>.gotty</code> 文件 (<code>~/.gotty</code>) 为配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~&#x2F;.gotty</span><br><span class="line">&#x2F;&#x2F; Listen at port 9000 by default</span><br><span class="line">port &#x3D; &quot;9000&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Enable TSL&#x2F;SSL by default</span><br><span class="line">enable_tls &#x3D; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; hterm preferences</span><br><span class="line">&#x2F;&#x2F; Smaller font and a little bit bluer background color</span><br><span class="line">preferences &#123;</span><br><span class="line">    font_size &#x3D; 5</span><br><span class="line">    background_color &#x3D; &quot;rgb(16, 16, 32)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用实例">使用实例</h3><p><code>GoTTY</code> 命令运行完成后，默认会在 8080 启动一个 <code>Web</code> 服务器。你只需在浏览器中打开 <code>http://127.0.0.1:8080/</code>，就会看到运行的命令，仿佛和运行在终端中一样。<code>GoTTY</code> 支持的功能相当丰富，下面我就来看几个比较常用的使用实例。</p><ol><li>通过 GoTTY 直接在 Web 端查看系统分区空间及使用率</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty df -h</span><br></pre></td></tr></table></figure><p><img src="https://www.tecmint.com/wp-content/uploads/2017/03/Gotty-Linux-Disk-Usage.png" alt=""></p><ol start="2"><li>允许在 Web 终端中运行命令</li></ol><p>默认情况下，<code>GoTTY</code> 不允许在 <code>Web</code> 终端中进行输入。但是，你可以使用 <code>-w</code> 或 <code>--permit-write</code> 选项来启用 <code>Web</code> 终端可写入 <code>TTY</code> 的特性。</p><p>下面我们演示一个用 <code>vi</code> 命令在浏览器中编辑 <code>fossmint.txt</code> 文件的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty -w vi fossmint.txt</span><br></pre></td></tr></table></figure><p>我们可以从浏览器中看到打开的 <code>vi</code> 界面和在终端打开的一模一样。</p><p><img src="https://www.tecmint.com/wp-content/uploads/2017/03/Gotty-Web-Vi-Editor.png" alt=""></p><ol start="3"><li>使用 GoTTY 对容器内部进行管理</li></ol><p>众所周知，在 <code>Kubernetes</code> / <code>Docker</code> 环境下，我们需要提供一种能力让研发或者其它相关技术人员可以在不登陆宿主机的情况下直接访问容器或者是查看容器中应用程序的当前状态。基于上面介绍的允许 <code>Web</code> 终端写入 <code>TTY</code> 的特性，我们可以灵活的将这一特性运用到容器管理中来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 Docker 命令进入容器内部</span><br><span class="line">$ gotty -w --permit-arguments docker exec -ti</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 Kubectl 命令进入容器内部</span><br><span class="line">$ gotty -w --permit-arguments kubectl exec -ti</span><br></pre></td></tr></table></figure><p>执行上面命令后，你就可以直接通过浏览器传入容器的 ID 和进入容器需要执行的命令。这里传入的命令是 <code>/bin/bash</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;172.172.241.180:8080&#x2F;?arg&#x3D;6f&amp;arg&#x3D;%2fbin%2fbash</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用浏览器频繁进入容器之后，容器内部会产生大量 <code>/bin/bash</code> 进程 ，一般不推荐直接进入容器。</p></blockquote><ol start="4"><li>给 GoTTY 加上基本的身份验证</li></ol><p>默认情况下通过浏览器访问 <code>GoTTY</code> 是不需要验证的，任何人都可以访问。为了更加的安全，我们可以给 <code>GoTTY</code> 加上基本身份验证机制。这样在通过浏览器访问时，就需要输入指定的用户名和密码才能访问到 <code>GoTTY</code> 所在的服务器。</p><p>要给 <code>GoTTY</code> 加上基本的验证，用到的是 <code>-c</code> 选项，该选项主要用来指定访问 <code>GoTTY</code> 时所需的用户名和密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用户名是：test 密码是：@67890</span><br><span class="line">$ gotty -w -p &quot;9000&quot; -c &quot;test:@67890&quot; glances</span><br></pre></td></tr></table></figure><p><img src="https://www.tecmint.com/wp-content/uploads/2017/03/Gotty-use-basic-authentication.png" alt=""></p><ol start="5"><li>给 Gotty 生成随机 URL</li></ol><p>除了身份验证外，限制访问服务器的另一种方法是使用随机 <code>URL</code>。通过 <code>GoTTY</code> 的 <code>-r</code> 选项，我们就能生成一个随机 <code>URL</code>，这样就只有知道该 <code>URL</code> 的用户才可以访问该服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty -r glances</span><br></pre></td></tr></table></figure><p>你还可以使用下面的选项来定义浏览器标题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty -r --title-format <span class="string">"GoTTY - &#123;&#123; .Command &#125;&#125; (&#123;&#123; .Hostname &#125;&#125;)"</span> glances</span><br></pre></td></tr></table></figure><p><img src="https://www.tecmint.com/wp-content/uploads/2017/03/Gotty-Random-URL-for-Glances-Linux-Monitoring.png" alt=""></p><ol start="6"><li>给 GoTTY 启用 SSL/TLS 认证</li></ol><p>默认情况下服务器和客户端之间的所有连接都不加密，当你通过 <code>GoTTY</code> 发送敏感数据时，为保证数据完全建议你启用 <code>SSL/TLS</code>。</p><p><code>GoTTY</code> 启用 <code>SSL/TLS</code> 的支持需要使用 <code>-t</code> 或 <code>--tls</code> 选项。默认情况下，<code>GoTTY</code> 会读取用户主目录下的证书文件和密钥文件 ( <code>~/.gotty.crt</code> 和 <code>~/.gotty.key</code>)。</p><p>首先，我们先创建一个自签名的证书文件以及密钥文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ~&#x2F;.gotty.key -out ~&#x2F;.gotty.crt</span><br></pre></td></tr></table></figure><p>然后，通过下面的命令启用 <code>GoTTY</code> 的 <code>SSL/TLS</code> 特性后，以达到安全访问 <code>GoTTY</code> 的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty -tr --title-format &quot;GoTTY - &#123;&#123; .Command &#125;&#125; (&#123;&#123; .Hostname &#125;&#125;)&quot; glances</span><br></pre></td></tr></table></figure><ol start="7"><li>与多个客户端同时共享终端</li></ol><p>如果你需要和多个客户端同时共享一个终端，这里你需要使用一个终端多路复用器与多个客户端共享单个进程，以下命令以 <code>tmux</code> 为例。</p><p>首先，我们先启动一个名为 <code>gotty</code> 的新 <code>tmux</code> 会话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gotty tmux new -A -s gotty</span><br></pre></td></tr></table></figure><p>其次，在另外一个终端上 <code>attach</code> 上这个 <code>tmux</code> 会话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tmux attach -t gotty</span><br><span class="line">$ vim test.php</span><br></pre></td></tr></table></figure><p>最后，我们通过浏览器可以实时看到在终端中所有的输入，这种场景特别适用于教学和演示。</p><h2 id="参考文档">参考文档</h2><ol><li><p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a></p></li><li><p><a href="https://ywnz.com/linuxrj/4060.html" target="_blank" rel="noopener">https://ywnz.com/linuxrj/4060.html</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/26590894" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26590894</a></p></li><li><p><a href="https://blog.csdn.net/cj2580/article/details/79318726" target="_blank" rel="noopener">https://blog.csdn.net/cj2580/article/details/79318726</a></p></li><li><p><a href="https://www.tecmint.com/gotty-share-linux-terminal-in-web-browser/" target="_blank" rel="noopener">https://www.tecmint.com/gotty-share-linux-terminal-in-web-browser/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;GoTTY&lt;/code&gt; 是一个简单的基于 &lt;code&gt;Go&lt;/code&gt; 语言的命令行工具，它可以将你的终端（TTY）作为 &lt;code&gt;Web&lt;/code&gt; 程序共享。&lt;code&gt;GoTTY&lt;/code&gt; 的架构是基于 &lt;code&gt;Hterm&lt;/code&gt; + &lt;code&gt;Web Socket&lt;/code&gt; 的，它能在 &lt;code&gt;Web&lt;/code&gt; 浏览器上运行一个基于 &lt;code&gt;JavaScript&lt;/code&gt; 的终端，并支持通过 &lt;code&gt;HTTP&lt;/code&gt; 和 &lt;code&gt;HTTPS&lt;/code&gt; 访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/yudai/gotty&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yudai/gotty&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yudai/gotty/master/screenshot.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装-GoTTY&quot;&gt;安装 GoTTY&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GoTTY&lt;/code&gt; 原生支持良好的跨平台性，开箱即用。只需下载对应平台的二进制包就行了，这里以 &lt;code&gt;Linux&lt;/code&gt; 平台为例。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 下载并解压 GoTTY 安装包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ wget https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;yudai&amp;#x2F;gotty&amp;#x2F;releases&amp;#x2F;download&amp;#x2F;v1.0.1&amp;#x2F;gotty_linux_amd64.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ tar -xzvf gotty_linux_amd64.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 复制可执行文件到指定目录并赋予执行权限&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo cp gotty &amp;#x2F;usr&amp;#x2F;local&amp;#x2F;bin&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ chmod +x &amp;#x2F;usr&amp;#x2F;local&amp;#x2F;bin&amp;#x2F;gotty&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更多平台的二进制安装包，可自行在官方项目地址的 &lt;a href=&quot;https://github.com/yudai/gotty/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Releases&lt;/a&gt; 页面进行下载。&lt;/p&gt;
&lt;p&gt;如果你使用的是 Mac，也可以通过 &lt;code&gt;Homebrew&lt;/code&gt; 来实现一键安装。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew install yudai&amp;#x2F;gotty&amp;#x2F;gotty&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装完成后，检查一下 &lt;code&gt;Gotty&lt;/code&gt; 的版本，以验证是否安装正确。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ gotty -version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gotty version 1.0.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>
