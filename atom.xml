<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇妙的 Linux 世界</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2021-06-17T01:23:31.834Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>巧用 Docker Buildx 构建多种系统架构镜像</title>
    <link href="https://www.hi-linux.com/posts/58027.html"/>
    <id>https://www.hi-linux.com/posts/58027.html</id>
    <published>2021-06-17T01:00:00.000Z</published>
    <updated>2021-06-17T01:23:31.834Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Docker Buildx 是一个 Docker CLI 插件，其扩展了 Docker 命令，支持 Moby BuildKit 提供的功能。提供了与 Docker Build 相同的用户体验，并增加了许多新功能。</p><p>BuildKit 是下一代的镜像构建组件，主要特点有很多，本文主要使用其可以编译多种系统架构的特性。</p><blockquote><p>网址：<a href="https://github.com/moby/buildkit" target="_blank" rel="noopener">https://github.com/moby/buildkit</a></p></blockquote><p>需要注意的是，该功能仅适用于 Docker v19.03+ 版本。</p><p>本文将讲解如何使用 Buildx 构建多种系统架构的镜像。</p><a id="more"></a><p>在开始之前，已经默认你在 Linux 系统（各大发行版）下安装好了 64 位的 Docker。</p><p>在写本文时，Docker 最新版本号是 19.03.13。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           19.03.13</span><br><span class="line"> API version:       1.40</span><br><span class="line"> Go version:        go1.13.15</span><br><span class="line"> Git commit:        4484c46d9d</span><br><span class="line"> Built:             Wed Sep 16 17:03:45 2020</span><br><span class="line"> OS&#x2F;Arch:           linux&#x2F;amd64</span><br><span class="line"> Experimental:      true</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          19.03.13</span><br><span class="line">  API version:      1.40 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.13.15</span><br><span class="line">  Git commit:       4484c46d9d</span><br><span class="line">  Built:            Wed Sep 16 17:02:21 2020</span><br><span class="line">  OS&#x2F;Arch:          linux&#x2F;amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.3.7</span><br><span class="line">  GitCommit:        8fba4e9a7d01810a393d5d25a3621dc101981175</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.0-rc10</span><br><span class="line">  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.18.0</span><br><span class="line">  GitCommit:        fec3683</span><br></pre></td></tr></table></figure><h2><span id="1-启用-buildx">1. 启用 Buildx</span></h2><p>buildx 命令属于实验特性，因此首先需要开启该特性。</p><p>上面的查看 Docker 版本返回的内容中，如果出现 <code>Experimental: true</code> 字样就代表已经开启该特性了。下面的这一步骤就可以省略。</p><p>编辑 <code>~/.docker/config.json</code> 文件，新增如下内容（以下的演示适用于事先不存在 .docker 目录的情况下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~&#x2F;.docker</span><br><span class="line">$ cat &gt; ~&#x2F;.docker&#x2F;config.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">&quot;experimental&quot;: &quot;enabled&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>Linux/macOS 下可以通过设置环境变量的方式启用（不推荐）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export DOCKER_CLI_EXPERIMENTAL&#x3D;enabled</span><br></pre></td></tr></table></figure><h2><span id="2-新建-builder-实例">2. 新建 Builder 实例</span></h2><p>在 Docker 19.03+ 版本中可以使用 <code>docker buildx build</code> 命令使用 BuildKit 构建镜像。该命令支持 <code>--platform</code> 参数可以同时构建支持多种系统架构的 Docker 镜像，大大简化了构建步骤。</p><p>由于 Docker 默认的 builder 实例不支持同时指定多个 <code>--platform</code> ，我们必须首先创建一个新的 Builder 实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx create --name mybuilder --driver docker-container</span><br></pre></td></tr></table></figure><p>返回新的 Builder 实例名，为「mybuilder」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybuilder</span><br></pre></td></tr></table></figure><p>使用新创建好的 Builder 实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx use mybuilder</span><br></pre></td></tr></table></figure><p>查看已有的 Builder 实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx ls</span><br><span class="line">NAME&#x2F;NODE    DRIVER&#x2F;ENDPOINT             STATUS   PLATFORMS</span><br><span class="line">mybuilder *  docker-container</span><br><span class="line">  mybuilder0 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock inactive </span><br><span class="line">default      docker</span><br><span class="line">  default    default                     running  linux&#x2F;amd64, linux&#x2F;386</span><br></pre></td></tr></table></figure><p>Docker 在 Linux/AMD64 系统架构下是不支持 ARM 架构镜像，因此我们可以运行一个新的容器（Emulator）让其支持该特性，Docker 桌面版则无需进行此项设置。</p><ul><li>方法一：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --privileged docker&#x2F;binfmt:a7996909642ee92942dcd6cff44b9b95f08dad64</span><br></pre></td></tr></table></figure><blockquote><p>注：docker/binfmt 可以参考网址：<a href="https://hub.docker.com/r/docker/binfmt/tags" target="_blank" rel="noopener">https://hub.docker.com/r/docker/binfmt/tags</a> 获取最新镜像</p></blockquote><ul><li>方法二（推荐）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --privileged tonistiigi&#x2F;binfmt --install all</span><br></pre></td></tr></table></figure><blockquote><p>可参考网址：<a href="https://hub.docker.com/r/tonistiigi/binfmt" target="_blank" rel="noopener">https://hub.docker.com/r/tonistiigi/binfmt</a> 获取最新镜像。目前（2021/04/20 更新）的 <code>Qemu version: 5.0.0</code></p></blockquote><h2><span id="3-新建-dockerfile-文件">3. 新建 Dockerfile 文件</span></h2><p>要想构建多种系统架构的镜像，还需要一个支持的 Dockerfile 文件。</p><p>以下是一个示例的 Dockerfile 文件。</p><blockquote><p>参考链接：<a href="https://github.com/teddysun/across/blob/master/docker/kms/Dockerfile.architecture" target="_blank" rel="noopener">https://github.com/teddysun/across/blob/master/docker/kms/Dockerfile.architecture</a></p></blockquote><p>该 Dockerfile 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM --platform&#x3D;$TARGETPLATFORM alpine:latest AS builder</span><br><span class="line">WORKDIR &#x2F;root</span><br><span class="line">RUN apk add --no-cache git make build-base &amp;&amp; \</span><br><span class="line">    git clone --branch master --single-branch https:&#x2F;&#x2F;github.com&#x2F;Wind4&#x2F;vlmcsd.git &amp;&amp; \</span><br><span class="line">    cd vlmcsd&#x2F; &amp;&amp; \</span><br><span class="line">    make</span><br><span class="line"></span><br><span class="line">FROM --platform&#x3D;$TARGETPLATFORM alpine:latest</span><br><span class="line">LABEL maintainer&#x3D;&quot;Teddysun &lt;i@teddysun.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">COPY --from&#x3D;builder &#x2F;root&#x2F;vlmcsd&#x2F;bin&#x2F;vlmcsd &#x2F;usr&#x2F;bin&#x2F;vlmcsd</span><br><span class="line">EXPOSE 1688</span><br><span class="line">CMD [ &quot;vlmcsd&quot;, &quot;-D&quot;, &quot;-e&quot; ]</span><br></pre></td></tr></table></figure><p><code>$TARGETPLATFORM</code> 是内置变量，由 <code>--platform</code> 参数来指定其值。</p><p>由于是基于 <a href="https://hub.docker.com/_/alpine" target="_blank" rel="noopener">alpine 的镜像</a>来制作的，而 <a href="https://hub.docker.com/_/alpine?tab=tags" target="_blank" rel="noopener">alpine</a> 是支持以下 7 种系统架构的，因此我们制作的镜像也就跟着支持这 7 种系统架构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&#x2F;amd64, linux&#x2F;arm&#x2F;v6, linux&#x2F;arm&#x2F;v7, linux&#x2F;arm64, linux&#x2F;386, linux&#x2F;ppc64le, linux&#x2F;s390x</span><br></pre></td></tr></table></figure><p>更友好一点的架构名称如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amd64, arm32v6, arm32v7, arm64v8, i386, ppc64le, s390x</span><br></pre></td></tr></table></figure><p>这里穿插一句吐槽。简单统计了一下，ARM 的系统架构有如下各种简称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arm64, armv8l, arm64v8, aarch64</span><br><span class="line">arm, arm32, arm32v7, armv7, armv7l, armhf</span><br><span class="line">arm32v6, armv6, armv6l, arm32v5, armv5,  armv5l, armel, aarch32</span><br></pre></td></tr></table></figure><p>看完了是不是很想打人？</p><p>而对比 Intel 和 AMD 的就简单多了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x86, 386, i386, i686</span><br><span class="line">x86_64, x64, amd64</span><br></pre></td></tr></table></figure><h2><span id="4-构建镜像">4. 构建镜像</span></h2><p>先来本地构建一个。</p><p><code>git clone</code> 刚才的示例 Dockerfile 文件，并进入其目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~ &amp;&amp; git clone https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across.git &amp;&amp; cd across&#x2F;docker&#x2F;kms&#x2F;</span><br></pre></td></tr></table></figure><p>在本地构建支持 7 种 Platform 的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx build --platform linux&#x2F;amd64,linux&#x2F;arm&#x2F;v6,linux&#x2F;arm&#x2F;v7,linux&#x2F;arm64,linux&#x2F;ppc64le,linux&#x2F;s390x,linux&#x2F;386 -t teddysun&#x2F;kms -o type&#x3D;local,dest&#x3D;.docker -f .&#x2F;Dockerfile.architecture .</span><br></pre></td></tr></table></figure><p>docker buildx build 的具体参数含义，参考下面的官方文档:</p><blockquote><p><a href="https://docs.docker.com/engine/reference/commandline/buildx_build/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/buildx_build/</a></p></blockquote><p>做完上面的那一步，实际上是把构建好的镜像放在了本地路径下。</p><p>此时我们再来查看一下已有的 builder 实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx ls</span><br><span class="line">NAME&#x2F;NODE    DRIVER&#x2F;ENDPOINT             STATUS  PLATFORMS</span><br><span class="line">mybuilder *  docker-container                    </span><br><span class="line">  mybuilder0 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock running linux&#x2F;amd64, linux&#x2F;arm64, linux&#x2F;riscv64, linux&#x2F;ppc64le, linux&#x2F;s390x, linux&#x2F;386, linux&#x2F;arm&#x2F;v7, linux&#x2F;arm&#x2F;v6</span><br><span class="line">default      docker                              </span><br><span class="line">  default    default                     running linux&#x2F;amd64, linux&#x2F;386</span><br></pre></td></tr></table></figure><p>你会发现 mybuilder 下存在 8 种支持的架构（riscv64 目前还用不上，但是已经支持）。</p><p>此时查看一下 docker image 的运行情况，会发现存在一个名为 <code>buildx_buildkit_mybuilder0</code> 的容器在运行。</p><p>这是刚才在本地构建时，自动创建的，切记不要将其停止，也不要删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -as</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND           CREATED             STATUS              PORTS             NAMES                        SIZE</span><br><span class="line">be753fa16090        moby&#x2F;buildkit:buildx-stable-1   &quot;buildkitd&quot;       15 minutes ago      Up 15 minutes                         buildx_buildkit_mybuilder0   0B (virtual 78.6MB)</span><br></pre></td></tr></table></figure><p>再来构建一个多系统架构镜像，并将构建好的镜像推送到 Docker 仓库（也就是 <a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a>）。</p><p>在此操作之前，你需要事先注册一个账号（演示过程省略），并登录。登录命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure><p>输入你的用户名和密码即可登录。</p><blockquote><p>注意，以下演示的命令中 tag 的前面是我的用户名 <code>teddysun</code>，如果你想制作自己的镜像，请自行替换为你自己的用户名。</p></blockquote><p>使用 <code>--push</code> 参数构建好的镜像推送到 Docker 仓库。</p><p>此时仍然是在刚才的 <code>~/across/docker/kms</code> 目录下，文件 <code>Dockerfile.architecture</code> 是为多系统架构构建准备的。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx build --platform linux&#x2F;386,linux&#x2F;amd64,linux&#x2F;arm&#x2F;v6,linux&#x2F;arm&#x2F;v7,linux&#x2F;arm64,linux&#x2F;ppc64le,linux&#x2F;s390x -t teddysun&#x2F;kms --push -f .&#x2F;Dockerfile.architecture .</span><br></pre></td></tr></table></figure><p>命令执行成功后，你就会在 Docker Hub 看到你上传的镜像啦。示例图如下：</p><p><img src="https://img.hi-linux.com/staticfile/kms_docker_hub-20210429161527270-2021-04-29-vT9VO3.png" alt></p><h2><span id="5-写在最后">5. 写在最后</span></h2><p>在制作多系统架构的 Docker 镜像时，建议使用 CPU 比较强或者多核心的 VPS 来构建，否则会非常耗时。</p><blockquote><p>本文转载自：「秋水逸冰」，原文：<a href="https://teddysun.com/581.html" target="_blank" rel="noopener">https://teddysun.com/581.html</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker Buildx 是一个 Docker CLI 插件，其扩展了 Docker 命令，支持 Moby BuildKit 提供的功能。提供了与 Docker Build 相同的用户体验，并增加了许多新功能。&lt;/p&gt;
&lt;p&gt;BuildKit 是下一代的镜像构建组件，主要特点有很多，本文主要使用其可以编译多种系统架构的特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网址：&lt;a href=&quot;https://github.com/moby/buildkit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/moby/buildkit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的是，该功能仅适用于 Docker v19.03+ 版本。&lt;/p&gt;
&lt;p&gt;本文将讲解如何使用 Buildx 构建多种系统架构的镜像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="教程" scheme="https://www.hi-linux.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>4 种优雅的在 Kubernetes 中调试网络流量的方式</title>
    <link href="https://www.hi-linux.com/posts/22651.html"/>
    <id>https://www.hi-linux.com/posts/22651.html</id>
    <published>2021-06-17T01:00:00.000Z</published>
    <updated>2021-06-17T01:29:36.606Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="前言">前言</span></h2><p>在当今世界, 分布式系统, 微服务/SOA架构遍地, 服务之间的许多交互和通信都不再是同一主机的不同线程或进程, 而是跨主机, 甚至跨网络区域. 那么一旦相关服务出现问题, 我们就会需要调试服务间的通讯, 主机间的网络…</p><p><img src="https://img.hi-linux.com/staticfile/smartscape-complex-environment-572-9c4b25ca16-2021-04-08-u3bMoJ.png" alt="复杂的网络架构"></p><p>Kubernetes 中的应用出了问题, 往往需要进行网络抓包分析. 本文介绍了在 Kubernetes 中网络调试分析的4种方法.</p><ol><li>使用 sidecar</li><li>使用 <a href="https://github.com/nicolaka/netshoot" target="_blank" rel="noopener">netshoot</a> - 一个 Docker + Kubernetes网络故障排除的瑞士军刀容器</li><li>利用Network Namespace</li><li>使用 kubectl 插件 - <code>ksniff</code></li></ol><a id="more"></a><h2><span id="方法一-使用-sidecar">方法一 使用 Sidecar</span></h2><p>在分布式计算、容器和微服务的世界中，服务之间的许多交互和通信都是通过 RESTful Api 完成的。在开发这些 Api 和服务之间的交互时，我经常需要调试服务之间的通信，特别是当事情看起来不像预期的那样工作时。</p><p>在容器出现之前，我只需将服务部署到本地机器上，启动 Wireshark，执行测试，并分析服务之间的HTTP通信。对我来说，这是一种快速分析软件中通信问题的简单而有效的方法。然而，这种调试方法在一个容器化的世界中并不适用。</p><p>首先，容器很可能在您的机器无法直接访问的内部容器平台网络上运行。第二个问题是，按照容器设计最佳实践，容器只包含执行其任务所需的最小应用程序和库集。这意味着像 Tcpdump 这样的工具通常在容器中不可用。这使得调试和分析容器之间的网络通信变得更加困难，从而使得调试微服务间的通信比在非容器环境中更加困难。本文展示了一种解决方案。</p><h3><span id="sidecar-前来救援">Sidecar 前来救援</span></h3><p><img src="https://img.hi-linux.com/staticfile/sidecar-20210408104152197-2021-04-08-aw0bbq.jpg" alt="Sidecar"></p><p>在过去的几个月里，我尝试了各种方法来克服这个问题，最终形成了我将在本文中概述的方法。它是捕获Kubernetes/OpenShift Pods 之间的网络流量数据的简单方法，允许开发人员更好地分析和调试容器化应用程序中的通信问题，并更快、更有效地解决问题。</p><p>我们将使用 Tcpdump 捕获一个所谓的 PCAP(packet capture)文件，该文件将包含 Pod 的网络流量。然后可以将这个 PCAP 文件加载到 Wireshark 之类的工具中来分析流量，在本例中，分析在 Pod 中运行的服务的 RESTful 通信。在本文中，我将使用 Red Hat Process Automation Manager 产品的 KIE 服务器(执行服务器)作为示例，但是这种方法应该适用于任何类型的容器化应用程序。</p><p>要克服的第一个问题是 Kubernetes Pod 中 Tcpdump 命令的可用性。KIE 服务器容器映像没有安装Tcpdump。其次，容器不提供从 Red Hat 存储库安装 Tcpdump 的实用程序。为了克服这个问题，我们使用了 “Sidecar 容器” 的概念。</p><h4><span id="sidecar-概念">Sidecar 概念</span></h4><p>Sidecar 容器是与实际服务/应用程序运行在相同 Pod 中的容器，能够为服务/应用程序提供附加功能。<strong>Sidecar 容器的一个例子是 Istio 的 Envoy sidecar，它使pod成为服务网格的一部分</strong> 。在本例中，我们将部署一个 Sidecar 容器，该容器提供 Tcpdump 实用程序。由于 <strong>pod中的多个容器共享相同的网络层</strong> ，所以我们可以使用 Sidecar 来捕获进出 KIE 服务器的网络流量。</p><h3><span id="部署-sidecar">部署 Sidecar</span></h3><p>在这个例子中，我部署了<a href="https://github.com/jbossdemocentral/rhpam7-mortgage-demo" target="_blank" rel="noopener">Red Hat Process Automation Manager 7 Mortgage Demo</a>，它将在我的 OpenShift namespace 中创建两个 Pod。一个 Pod 运行 Business Central workbench，另一个 Pod 是执行服务器的 Pod。这两个组件之间的通信是通过 REST 完成的，这是我们将要捕获的流量。</p><p><img src="https://img.hi-linux.com/staticfile/Screenshot-2019-02-20-at-09.04.48-20210408103149938-2021-04-08-ZXh8d2.png" alt="OpenShift Namespace Overview"></p><p>我们的目标是捕获 KIE 服务器 Pod 上的网络流量，以便分析 Business Central Workbench 发送给 KIE 服务器的 RESTful 命令。要做到这一点，我们首先需要附加 (attach)一个 Sidecar 到 KIE 服务器的 Pod.</p><ol><li><p>在 Overview 页面中，单击要分析的 Pod 的名称。这将打开 <em>部署配置(Deployment Config, 简称DC)</em> 页面。</p></li><li><p>在 <em>部署配置</em> 屏幕的右上角，单击 Actions -&gt; Edit YAML。这将打开 DC 的 YAML配置。</p></li></ol><p><img src="https://img.hi-linux.com/staticfile/Screenshot-2019-02-20-at-09.08.55-2021-04-08-XCDrsY.png" alt></p><ol start="3"><li>向下滚动，直到看到单词 <code>containers</code>。我们将添加一个额外的容器，安装了 Tcpdump 的Sidecar 到 Pod 中。直接在 <code>containers</code> 定义下添加以下 YAML 片段:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- name: tcpdump</span><br><span class="line">   image: corfr&#x2F;tcpdump</span><br><span class="line">   command:</span><br><span class="line">     - &#x2F;bin&#x2F;sleep</span><br><span class="line">     - infinity</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/Screenshot-2019-02-20-at-09.17.56-2021-04-08-ci10cL.png" alt></p><ol start="4"><li>保存配置。这将部署一个新的 Pod，它现在由两个容器组成: 一个容器包含 KIE 服务器，另一个容器包含我们的 Tcpdump 工具，它将无限期地持续运行。</li></ol><h3><span id="捕获和分析流量">捕获和分析流量</span></h3><p>随着 Sidecar 的部署和运行，我们现在可以开始捕获数据了。我尝试的方法之一是使用 <code>oc rsh</code> 命令远程执行 Sidecar 中的 <code>tcpdump</code> 命令，将网络数据流输出到 FIFO 文件，并将数据直接导入 Wireshark。由于各种原因，这种方法失败了。其中一个问题是，<code>tcpdump</code> 向 <code>stderr</code> 发送信息消息，但是这些消息与 <code>stdout</code> 在相同的流中, 并且是通过 SSH 接收，从而破坏了进入 Wireshark 的数据。</p><p>我最后使用的方法是登录到 Sidecar 容器，并在 Sidecar 中运行 <code>tcpdump</code> 命令来创建 PCAP 文件。当您捕获了足够的数据后，就可以停止捕获过程并将 PCAP 文件复制到您希望使用 Wireshark 进行网络流量分析的机器上。具体步骤如下:</p><ol><li>在您的开发机器上，用 <code>oc</code> 客户端连接到 OpenShift 实例，并激活正确的项目( project, 即namespace)，运行 <code>oc get pods</code> 命令来列出您的 Pods:</li></ol><p><img src="https://img.hi-linux.com/staticfile/Screenshot-2019-02-20-at-09.26.30-2021-04-08-Xyw4s5.png" alt></p><ol start="2"><li><p>使用以下命令登录到我们的 KIE 服务器 Pod 的 tcpdump 容器中: <code>oc rsh -c tcpdump rhpam7-mortgage-kieserver-2-zcpsn</code></p></li><li><p>在 <code>tcpdump</code> 容器中，运行此命令以启动网络流量捕获过程: <code>tcpdump -s 0 -n -w /tmp/kieserver.pcap</code></p></li><li><p>运行要分析的网络流量的测试。在本例中，我将从 Business Central workbench 中启动一个业务流程，它将向 KIE 服务器发送一个 RESTful 请求。</p></li><li><p>捕获足够的数据后，在 <code>tcpdump</code> 容器中使用 <code>Ctrl+C</code> 完成捕获过程。</p></li><li><p>回到本地机器。将 PCAP 文件从 Pod 复制到本地机器: <code>oc cp -c tcpdump rhpam7-mortgage-kieserver-2-zcpsn:tmp/kieserver.pcap kieserver.pcap</code></p></li><li><p>用 Wireshark 打开 PCAP 文件并分析网络流量。在这个例子中，我正在分析我的 HTTP POST 方法，它创建了 Mortgage 进程的一个新实例:</p></li></ol><p><img src="https://img.hi-linux.com/staticfile/Screenshot-2019-02-20-at-09.45.47-2021-04-08-FBOqZz.png" alt="Wireshark 分析"></p><h3><span id="总结">总结</span></h3><p>在容器环境(如 Kubernetes 和/或 OpenShift )中分析 Pod 之间的网络通信可能比在非容器环境中更困难一些。然而，Sidecar 容器的概念为开发人员提供了一种简单的工具，可以将容器连同所需的开发工具和实用程序附加到微服务pod上。<strong>这避免了开发人员必须在应用程序容器映像本身中安装这些调试工具，从而保持容器的轻便和干净。</strong> 使用像 <code>oc rsh</code> 和 <code>oc cp</code> 这样的 OpenShift 工具，我展示了如何轻松地从 Pod 捕获网络流量数据并将数据带到开发机器进行分析。</p><h2><span id="方法二-使用-netshoot">方法二 使用 netshoot</span></h2><p><a href="https://github.com/nicolaka/netshoot" target="_blank" rel="noopener">Netshoot</a> - Docker + Kubernetes网络故障排除的瑞士军刀容器</p><p><img src="https://img.hi-linux.com/staticfile/403141-2021-04-08-17rDoq.jpg" alt="瑞士军刀"></p><h3><span id="用途">用途</span></h3><p>Docker 和 Kubernetes 网络故障排除变得复杂。通过正确理解 Docker 和 Kubernetes 网络的工作方式和正确的工具集，您可以排除故障并解决这些网络问题。netshoot 容器有一组强大的网络troubleshoot 工具，可以用来排除 Docker 网络问题。与这些工具一起出现的还有一组用例，展示了如何在真实场景中使用这个容器。</p><h3><span id="network-namespaces-网络名称空间">Network Namespaces - 网络名称空间</span></h3><p>在开始使用这个工具之前，有一点很重要:网络名称空间。网络名称空间提供与网络相关的系统资源的隔离。Docker使用网络和其他类型的名称空间(<code>pid</code>、<code>mount</code>、<code>user</code>…)为每个容器创建一个隔离的环境。从接口、路由到 ip 的所有内容都完全隔离在容器的网络名称空间中。</p><p>Kubernetes 也使用网络名称空间。<strong>Kubelets为每个pod创建一个网络名称空间，其中该 Pod 中的所有容器共享相同的网络名称空间(eths、IP、tcp套接字……)。这是 Docker 容器和Kubernetes pod之间的关键区别。</strong></p><p>名称空间很酷的一点是您可以在它们之间进行切换。您可以输入不同容器的网络名称空间，使用甚至没有安装在该容器上的工具在其网络堆栈上执行一些故障排除。此外，netshoot 可以通过使用主机的网络名称空间来对主机本身进行故障排除。这允许您在不直接在主机或应用程序包上安装任何新包的情况下执行任何故障排除。</p><h3><span id="针对容器的用法">针对容器的用法</span></h3><ul><li><strong>容器的网络名称空间</strong> :如果您的应用程序的容器存在网络问题，您可以像这样使用容器的网络名称空间启动 netshoot: <code>$ docker run -it --net container:&lt;container_name&gt; nicolaka/netshoot</code></li><li><strong>主机的网络名称空间</strong> :如果您认为网络问题在于主机本身，那么可以使用该主机的网络名称空间启动 netshoot。命令: <code>$ docker run -it --net host nicolaka/netshoot</code></li><li><strong>网络的网络名称空间</strong> :如果要对Docker网络进行故障排除，可以使用 <code>nsenter</code> 输入网络的名称空间。这将在下面的 <code>nsenter</code> 部分进行解释。</li></ul><h3><span id="针对-kubernetes-的用法">针对 Kubernetes 的用法</span></h3><p><strong>Kubernetes</strong>: 如果你想打开一个临时的容器来调试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run --generator&#x3D;run-pod&#x2F;v1 tmp-shell --rm -i --tty --image nicolaka&#x2F;netshoot -- &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>如果您想在主机的网络名称空间上 spin up 一个容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run tmp-shell --generator&#x3D;run-pod&#x2F;v1 --rm -i --tty --overrides&#x3D;&#39;&#123;&quot;spec&quot;: &#123;&quot;hostNetwork&quot;: true&#125;&#125;&#39; --image nicolaka&#x2F;netshoot -- &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><blockquote><p>同样的原理, <code>netshoot</code> 也可以通过 Sidecar 的方式进行使用.</p></blockquote><h3><span id="网络问题">网络问题</span></h3><p>许多网络问题可能导致应用程序性能下降。其中一些问题可能与底层网络基础设施有关。其他问题可能与主机或 Docker 级别的配置错误有关。让我们来看看常见的网络问题</p><ul><li>延迟(latency)</li><li>路由(routing)</li><li>DNS解析(DNS resolution)</li><li>防火墙(firewall)</li><li>不完整的 ARP(incomplete ARPs)</li></ul><p>为了解决这些问题，<code>netshoot</code> 包含了一组强大的工具，如图所示。</p><p><img src="https://img.hi-linux.com/staticfile/netshoot-all-tools-2021-04-08-oPnkeD.png" alt="netshoot 工具集"></p><h3><span id="被包含的包">被包含的包</span></h3><p>以下包被包含在 <code>netshoot</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">apache2-utils</span><br><span class="line">bash</span><br><span class="line">bind-tools</span><br><span class="line">bird</span><br><span class="line">bridge-utils</span><br><span class="line">busybox-extras</span><br><span class="line">calicoctl</span><br><span class="line">conntrack-tools</span><br><span class="line">ctop</span><br><span class="line">curl</span><br><span class="line">dhcping</span><br><span class="line">drill</span><br><span class="line">ethtool</span><br><span class="line">file</span><br><span class="line">fping</span><br><span class="line">iftop</span><br><span class="line">iperf</span><br><span class="line">iproute2</span><br><span class="line">ipset</span><br><span class="line">iptables</span><br><span class="line">iptraf-ng</span><br><span class="line">iputils</span><br><span class="line">ipvsadm</span><br><span class="line">libc6-compat</span><br><span class="line">liboping</span><br><span class="line">mtr</span><br><span class="line">net-snmp-tools</span><br><span class="line">netcat-openbsd</span><br><span class="line">netgen</span><br><span class="line">nftables</span><br><span class="line">ngrep</span><br><span class="line">nmap</span><br><span class="line">nmap-nping</span><br><span class="line">openssl</span><br><span class="line">py-crypto</span><br><span class="line">py2-virtualenv</span><br><span class="line">python2</span><br><span class="line">scapy</span><br><span class="line">socat</span><br><span class="line">strace</span><br><span class="line">tcpdump</span><br><span class="line">tcptraceroute</span><br><span class="line">util-linux</span><br><span class="line">vim</span><br></pre></td></tr></table></figure><h2><span id="方法三-利用network-namespace">方法三 利用Network Namespace</span></h2><p>正如方法二中提到的 Network Namespace 概念, 实际上, 不同的容器, <strong>只是在宿主机上不同 namespace 运行的进程而已</strong> . 因此要在不同的容器抓包可以简单地使用命令切换 Network Namespace 即可，可以使用在宿主机上的 <code>tcpdump</code> 等应用进行抓包。</p><blockquote><p>前提条件: 宿主机上已安装<code>tcpdump</code></p><p>参考链接: <a href="https://ruofeng.me/2018/09/19/capture-packets-in-kubernetes/" target="_blank" rel="noopener">在 k8s 中对指定 Pod 进行抓包</a></p></blockquote><p>具体操作步骤如下:</p><ol><li>查看指定 Pod 运行在哪个宿主机上:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubctl describe pod &lt;pod&gt; -n mservice</span><br></pre></td></tr></table></figure><ol start="2"><li>获得容器的 Pid:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;.State.Pid&#125;&#125; &lt;container&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>进入该容器的 network namespace:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsenter --target &lt;PID&gt; -n</span><br></pre></td></tr></table></figure><ol start="4"><li>使用宿主机的 <code>tcpdump</code> 抓包, 指定 eth0 网卡:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 tcp and port 80 -vvv</span><br></pre></td></tr></table></figure><ol start="5"><li>或者直接抓包并导出到文件:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -w &#x2F;tmp&#x2F;out.cap</span><br></pre></td></tr></table></figure><ol start="6"><li>从远程 <code>scp</code> 到本地:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ipaddr:&#x2F;tmp&#x2F;out.cap .&#x2F;</span><br></pre></td></tr></table></figure><ol start="7"><li>之后在 Wireshark 中可以打开文件非常直观得查看过滤抓到的数据。</li></ol><h2><span id="方法四-使用-kubectl-插件-ksniff">方法四 使用 kubectl 插件 ksniff</span></h2><p>ksniff 项目地址：<a href="https://github.com/eldadru/ksniff" target="_blank" rel="noopener">https://github.com/eldadru/ksniff</a></p><h3><span id="题外话-krew-kubectl-插件包管理器">题外话: krew - kubectl 插件包管理器</span></h3><blockquote><p>前提条件: kubectl v1.12 或更高.</p><p>项目地址：<a href="https://github.com/kubernetes-sigs/krew/" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/krew/</a></p></blockquote><p>Krew 是 kubectl 插件的包管理器。</p><h4><span id="什么是-krew">什么是 <code>krew</code></span></h4><p>krew 是一个使 <a href="https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/" target="_blank" rel="noopener">kubectl插件</a> 易于使用的工具。krew 帮助您发现插件，并在您的机器上安装和管理它们。它类似于 apt、dnf 或 brew 等工具。</p><ul><li><strong>对于 kubectl 用户</strong> : krew 帮助您以一致的方式查找、安装和管理 kubectl插件。</li></ul><p>krew 易于使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl krew search                 # show all plugins</span><br><span class="line">kubectl krew install view-secret    # install a plugin named &quot;view-secret&quot;</span><br><span class="line">kubectl view-secret                 # use the plugin</span><br><span class="line">kubectl krew upgrade                # upgrade installed plugins</span><br><span class="line">kubectl krew uninstall view-secret  # uninstall a plugin</span><br></pre></td></tr></table></figure><p>详细文档请参阅<a href="https://krew.sigs.k8s.io/docs/user-guide/" target="_blank" rel="noopener">用户指南</a>。</p><p>查看在 krew 上<a href="http://sigs.k8s.io/krew-index/plugins.md" target="_blank" rel="noopener">可用的 kubectl 插件列表</a>，或者运行 <code>kubectl krew search</code> 来发现可用的插件。</p><h4><span id="安装-krew">安装 krew</span></h4><p><strong>Bash 和 ZSH</strong>:</p><ol><li>确保 <code>git</code> 已安装;</li><li>运行如下命令, 下载并安装 <code>krew</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">  set -x; cd &quot;$(mktemp -d)&quot; &amp;&amp;</span><br><span class="line">  curl -fsSLO &quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes-sigs&#x2F;krew&#x2F;releases&#x2F;download&#x2F;v0.3.1&#x2F;krew.&#123;tar.gz,yaml&#125;&quot; &amp;&amp;</span><br><span class="line">  tar zxvf krew.tar.gz &amp;&amp;</span><br><span class="line">  .&#x2F;krew-&quot;$(uname | tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;)_amd64&quot; install \</span><br><span class="line">    --manifest&#x3D;krew.yaml --archive&#x3D;krew.tar.gz</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>添加 <code>$HOME/.krew/bin</code> 目录到 <code>PATH</code> 环境变量. 如下: <code>export PATH=&quot;${KREW_ROOT:-$HOME/.krew}/bin:$PATH&quot;</code> 并重启下 Shell 生效.</li></ol><h3><span id="安装-ksniff">安装 ksniff</span></h3><p>通过 <code>krew</code>: <code>kubectl krew install sniff</code></p><h3><span id="使用方法">使用方法</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># kubectl &lt; 1.12:</span><br><span class="line">$ kubectl plugin sniff &lt;POD_NAME&gt; [-n &lt;NAMESPACE_NAME&gt;] [-c &lt;CONTAINER_NAME&gt;] [-i &lt;INTERFACE_NAME&gt;] [-f &lt;CAPTURE_FILTER&gt;] [-o OUTPUT_FILE] [-l LOCAL_TCPDUMP_FILE] [-r REMOTE_TCPDUMP_FILE]</span><br><span class="line"></span><br><span class="line"># kubectl &gt;&#x3D; 1.12:</span><br><span class="line">$ kubectl sniff &lt;POD_NAME&gt; [-n &lt;NAMESPACE_NAME&gt;] [-c &lt;CONTAINER_NAME&gt;] [-i &lt;INTERFACE_NAME&gt;] [-f &lt;CAPTURE_FILTER&gt;] [-o OUTPUT_FILE] [-l LOCAL_TCPDUMP_FILE] [-r REMOTE_TCPDUMP_FILE]</span><br><span class="line"></span><br><span class="line">POD_NAME: Required. the name of the kubernetes pod to start capture it&#39;s traffic.</span><br><span class="line">NAMESPACE_NAME: Optional. Namespace name. used to specify the target namespace to operate on.</span><br><span class="line">CONTAINER_NAME: Optional. If omitted, the first container in the pod will be chosen.</span><br><span class="line">INTERFACE_NAME: Optional. Pod Interface to capture from. If omited, all Pod interfaces will be captured.</span><br><span class="line">CAPTURE_FILTER: Optional. specify a specific tcpdump capture filter. If omitted no filter will be used.</span><br><span class="line">OUTPUT_FILE: Optional. if specified, ksniff will redirect tcpdump output to local file instead of wireshark.</span><br><span class="line">LOCAL_TCPDUMP_FILE: Optional. if specified, ksniff will use this path as the local path of the static tcpdump binary.</span><br><span class="line">REMOTE_TCPDUMP_FILE: Optional. if specified, ksniff will use the specified path as the remote path to upload static tcpdump to.</span><br></pre></td></tr></table></figure><p>举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl sniff mypod -n myproject -o &#x2F;tmp&#x2F;mypod.pcap</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>为了在容器或 K8S 中进行网络调试和分析, 本文列举了 4 种方法, 现在进行总结归纳:</p><ol><li><p>使用 Sidecar - Sidecar 容器所在的 <strong>Pod 中的多个容器共享相同的网络层</strong>, 且Sidecar 容器可以包含 <code>tcpdump</code> 等工具;</p></li><li><p>利用 Network Namespace - 不同的容器, <strong>只是在宿主机上不同 namespace 运行的进程而已</strong>. 容器的网络也是如此.</p></li><li><p>使用 <code>netshoot</code> - <code>netshoot</code> 其实是包含一系列的常用网络分析调试工具集的容器, 真正的使用方法其实还是以上 2 种:</p><ol><li>通过 sidecar 挂载</li><li>利用 Network Namespace 分析调试</li></ol></li><li><p>使用 kubectl 插件 - <code>ksniff</code>.</p></li></ol><p>以上这些方法, 有不同的前提条件和使用场景, 希望本文读完会让你的 K8S 调试技能有所提升.</p><blockquote><p>本文转载自：「 个人技术分享 」，原文：<a href="http://t.cn/AimWk1Wl%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">http://t.cn/AimWk1Wl，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在当今世界, 分布式系统, 微服务/SOA架构遍地, 服务之间的许多交互和通信都不再是同一主机的不同线程或进程, 而是跨主机, 甚至跨网络区域. 那么一旦相关服务出现问题, 我们就会需要调试服务间的通讯, 主机间的网络…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/smartscape-complex-environment-572-9c4b25ca16-2021-04-08-u3bMoJ.png&quot; alt=&quot;复杂的网络架构&quot;&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 中的应用出了问题, 往往需要进行网络抓包分析. 本文介绍了在 Kubernetes 中网络调试分析的4种方法.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 sidecar&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://github.com/nicolaka/netshoot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;netshoot&lt;/a&gt; - 一个 Docker + Kubernetes网络故障排除的瑞士军刀容器&lt;/li&gt;
&lt;li&gt;利用Network Namespace&lt;/li&gt;
&lt;li&gt;使用 kubectl 插件 - &lt;code&gt;ksniff&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>弹指一挥间，揭秘诞生 30 周年 Linux 成功的真正原因</title>
    <link href="https://www.hi-linux.com/posts/43403.html"/>
    <id>https://www.hi-linux.com/posts/43403.html</id>
    <published>2021-06-11T01:00:00.000Z</published>
    <updated>2021-06-11T03:46:46.656Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><ul><li>作者丨 Jeremy Andrews</li><li>译者丨屠灵</li><li>策划丨蔡芳芳</li></ul><blockquote><p>Linux 诞生于 1991 年，距今已经 30 年了。虽然它一开始只是 Linus 的一个个人项目，而非出于要开发一个新操作系统的伟大梦想，但如今的 Linux 早已无处不在。</p></blockquote><p>30 年前，当 Linus Torvalds 第一次发布 Linux 内核时，他还是赫尔辛基大学的一名 21 岁的学生。他宣布说：“我正在开发一个（免费的）操作系统（这只是个爱好，不会做得很大，也不会很专业……）”。30 年后，500 强超级计算机和 70% 以上的智能手机都在运行 Linux。很显然，Linux 不仅大，而且很专业。</p><p>30 年来，Linus Torvalds 一直在领导着 Linux 内核的开发，启发了无数开发者和开源项目。2005 年，Linus 开发了 Git，用来管理内核开发过程。Git 现在已经成为最流行的版本控制系统，受到无数开源和私有项目的信任。</p><p>正值 Linux 诞生 30 周年之际，Linus Torvalds 通过电子邮件回复了 Tag 1 咨询公司的创始合伙人 / 首席执行官 Jeremy Andrews 的访谈问题（《An Interview With Linus Torvalds: Linux and Git - Part 1》），回顾并总结了过去这些年他在领导大型开源项目过程中得到的真知灼见。本文着重介绍 Linux 内核开发和 Git。InfoQ 对访谈内容进行了翻译，以飨读者。</p><a id="more"></a><h2><span id="linux-内核开发">Linux 内核开发</span></h2><h3><span id="linux-发展的关键我不认识的人都在使用-linux">Linux 发展的关键：“我不认识的人都在使用 Linux”</span></h3><p><strong>Jeremy Andrews：Linux 无处不在，它是整个开源世界的灵感源泉。当然，事情并不是从一开始就这样的。1991 年，你在 comp.os.minix Usenet 新闻组中发布了一个 Linux 内核。十年后，你写了一本书，叫作“Just for Fun: The Story of an Accidental Revolutionary”（中译名：《只是为了好玩：Linux 之父林纳斯自传》），对那段历史进行了深度回顾。今年 8 月，Linux 将迎来它的 30 周年纪念日！在这个过程中，你是在什么时候开始意识到 Linux 并不仅仅是一个“爱好”的？</strong></p><p><strong>Linus Torvalds</strong>：这听起来可能有点荒谬，实际上我很早就开始意识到了。在 1991 年末（以及 1992 年初），Linux 已经比我预想的要大得多。</p><p>那时候可能只有几百个用户（确切地说不是“用户”，因为人们还要不断地对它进行修修补补），从没想过 Linux 后来能够发展壮大。在我看来，<strong>最大的转折点是当我意识到其他人正在使用它，并对它感兴趣，它开始有了自己的生命</strong>。人们开始发送补丁，这个系统能做的事情比我最初预想的要多得多。</p><p>1992 年 4 月的某个时候，X11 被移植到 Linux 上（其实我也记不太清具体时间了，毕竟那是很久以前的事了），这是一个重大进步，Linux 系统突然间有了 GUI 和一系列全新的功能。</p><p>我一开始并没有什么大计划。这只是一个个人项目，并不是出于要开发一个新操作系统的伟大梦想。我当时只是想了解我的新 PC 硬件的来龙去脉。</p><p>所以，在发布第一个版本时，实际上更多的是想“看看自己都做了些什么”。当然，我希望其他人会觉得它有趣，但它并不是一个真正可用的操作系统。它更多的是一种概念验证，而且只是一个我在当时做了几个月的个人项目。</p><p>从“个人项目”到其他人开始使用它、给我反馈（和 bug 报告）和发送补丁，对我来说是一个巨大的转变。</p><p>举个最基本的例子：最初的版权许可是“你可以以源代码的形式发布它，但不能用它赚钱”。</p><p>对于当时的我来说，商业版 Unix 太贵了（作为穷学生，我已经为了买新 PC 花光了所有钱），所以我希望这个操作系统的源代码是公开可用的（这样人们就可以提供补丁），<strong>我希望将它开放给像我这样负担不起昂贵电脑和操作系统的人</strong>。</p><p>1991 年末（或是 1992 年初），我把许可改为 GPLv2，因为有人想把它以软盘的形式分发给本地 Unix 用户组，但又想收回软盘的成本，并补偿他们拷贝软盘所花费的时间。我觉得这很合理，因为“免费”与否并不是最重要的，最重要的是要“公开源码”。</p><p>最终的结果是：人们不仅在 Unix 用户组中发布它，在几个月之内还出现了 SLS 和 Slackware 的软盘发行版。</p><p>与最初的那些根本性的变化相比，后来的一切都是“增量式”的。当然，有些增量式的变化也是大跨步（IBM 的加入、Oracle 数据库的移植、Red Hat 的首次公开募股，Android 在手机上的应用，等等），但在我看来，它们仍然不如最初的“我不认识的人都在使用 Linux”那样具有革命性。</p><h3><span id="linux-成功的重要原因修改开源许可协议采用-gplv2">Linux 成功的重要原因：修改开源许可协议，采用 GPLv2</span></h3><p>Jeremy Andrews：你是否曾经后悔修改了许可协议？或者说，其他人或公司用你开发的系统赚了很多钱，你因此感到后悔吗？</p><p><strong>Linus Torvalds</strong>：我从来没有后悔过。</p><p>首先，我过得还不错。我不是特别富有，但我是一个薪水很高的软件工程师，可以按照自己的节奏做我喜欢做的事情。</p><p>关键是我百分之百认为这个许可是 Linux（以及 Git）取得成功的重要原因。我认为，当所有人都认为他们有平等的权利，没有人在这方面有特权的时候，他们才会变得更快乐。</p><p>有很多项目采用了“双重许可”，一方面，原作者保留了商业许可（“只要你支付了许可费用，就可以使用它”），另一方面，项目也可以在 GPL 许可下开源。</p><p>我认为要在这种情况下建立好的社区是非常困难的，因为开源那一方知道自己是“二等公民”。另外，为了让享有特权的那一方一直享有特殊的权利，需要做很多许可文书工作，这给项目带来了额外的阻力。</p><p>另一方面，我见过很多基于 BSD（或 MIT 等类似的许可）许可的开源项目，当它们变得足够强大，大到具备商业价值时，它们就开始分裂，相关的公司不可避免地会将自己的那部分变成专有的。</p><p>我认为 <strong>GPLv2 能够在“每个人都处于相同的规则之下”和“要求人们回馈社区”之间取得完美的平衡</strong>。每个人都知道，所有参与者都受到相同的规则的约束，所以这是非常公平的。</p><p>当然，你的投入总会得到回报。如果你只是想轻度参与项目，或者只是想作为一名用户，那也是可以的。如果你真的只是这样，就也无法控制这个项目。如果你真的只需要一个基本的操作系统，而 Linux 已经具备你想要的所有功能，那也完全没有问题。但如果你有特殊的需求，想要为这个项目做一点事情，那么唯一的方法就是参与其中。</p><p>这让每个人都秉持诚实的态度，包括我在内。任何人都可以 fork 这个项目，用他们自己的方式，然后说“再见了，Linus，我要维护自己的 Linux 版本”。我之所以“特别”，仅仅是因为人们相信我能把工作做好。</p><p>“任何人都可以维护自己的 Linux 版本”，这让一些人对 GPLv2 产生了怀疑，但我认为这是一种优势，而不是劣势。我认为，这实际上是避免 Linux 出现分裂的原因：每个人都可以创建自己的项目分支。事实上，这也是“Git”的核心设计原则之一——代码库的每一个克隆都是一个分支，人们（和公司）再 fork 出自己的版本，完成开发工作。</p><p>所以，分支不是问题，只要你能把好的部分合并回来。这就是 GPLv2 发挥作用的地方。能够拉取分支，并按照自己的方式修改代码，拥有这些权利很重要，但另一方面也同样重要——当一个分支被证明取得了成功，有权利把它合并回去。</p><p>另一个问题是，除了要有支持这种工作流的工具，也要有可以支持它的心态。合并分支的一大障碍不仅是许可问题，还有“嫌隙”问题。如果分支是源于对立，那么要合并两个分支就非常困难——不是因为许可或技术方面的原因，而是因为分支之间太过对立。我认为 Linux 避免了这种情况的发生，主要是因为我们一直认为分支是一件很自然的事情。而且，当一些开发工作被证明取得了成功，尝试将其合并回来也是很自然的。</p><p>虽然这个答案有点偏离正题，但我认为它很重要——我不后悔修改了许可，因为我真的认为 GPLv2 是 Linux 取得成功的一个重要原因。</p><p>金钱不是一种很好的激励方式，它无法让人们团结在一起。我认为，参与一个共同的项目，并感觉到自己可以成为这个项目的合作伙伴，这样才能激励人们。</p><p><strong>Jeremy Andrews：现在，人们基于 GPLv2 发布源代码通常是因为 Linux。你当时是怎么找到这个许可的？你在调研其他许可方面又投入了多少时间和精力呢？</strong></p><p><strong>Linus Torvalds</strong>：那个时候，有关 BSD 和 GPL 的争论非常激烈。我在阅读各种新闻组（比如 comp.arch、comp.os.minix 等）时看到了一些有关许可的讨论。</p><p>其中两个最主要的原因可能是 gcc 和 Lars Wirzenius。gcc 对 Linux 的发展起到了很大作用，因为我肯定需要一个 C 语言编译器。Lars Wirzenius 是我在念大学时另一个说瑞典语（瑞典语在芬兰是小语种）的计算机系学生。</p><p>Lasu 比我更喜欢讨论与许可相关的事情。</p><p>在我看来，选择 GPLv2 并不算是什么重大的政治问题，主要是因为我最初在选择许可时太过仓促，后来需要做出修改。况且，我很感恩有 gcc，并且 GPLv2 更符合我对“你必须把源代码合并回来”这种想法的期望。</p><p>因此，与其另起炉灶新建一个许可，不如选择一个人们已经知道并且有一些律师参与其中的许可。</p><h3><span id="linux-之父的一天">Linux 之父的一天</span></h3><p><strong>Jeremy Andrews：通常情况下，你的一天是怎么过的？其中有多少时间花在写代码上，多少花在评审代码上，多少花在电子邮件上？你如何平衡个人生活和 Linux 内核开发工作？</strong></p><p><strong>Linus Torvalds</strong>：我现在写的代码很少，而且已经很久没写了。再要写代码，通常是因为人们对某些特定的问题存在争议。我修改代码，并将其作为补丁发布出去，作为对解决方案的解释说明。</p><p>换句话说，我写的大部分代码更多的是作为解决方案的示例，而补丁是一种非常具体的例子。人们很容易陷入理论讨论的陷阱，而我发现描述解决方案最好的方式是写代码片段，不一定要完整的程序，只要让解决方案具体化一些即可。</p><p>我的工作时间都花在电子邮件上了。主要是沟通，而不是写代码。事实上，我认为这种与记者和技术博主之间的交流就是我工作的一部分——它可能比技术讨论优先级低一些，但我也花了相当多的时间在这类事情上。</p><p>当然，我也会花一些时间在代码评审上。但老实说，当我收到一个 PR 时，有问题的代码通常已经被其他人评审过了。所以，虽然我仍然会看一下补丁，但实际上会更多地去关注注解，以及补丁的演化过程。但对于那些与我共事很久的人，我不会这么做：他们是自己子系统的维护者，我不需要对他们的工作指手画脚。</p><p>所以，很多时候，我的主要工作就是“待在那里”，执行管理和发布任务。换句话说，我的工作通常更多地是关于维护过程，而不是底层代码。</p><h3><span id="linux-之父的工作环境">Linux 之父的工作环境</span></h3><p>Jeremy Andrews：你的工作环境是怎样的？比如，你是喜欢黑暗、不会受人打扰的房间，还是喜欢能看到风景的房间？你喜欢在安静的环境下工作，还是喜欢一边听音乐一边工作？你通常使用哪种硬件？你是在终端上使用 vi 来评审代码，还是使用某种奇特的 IDE？你是否有偏爱的 Linux 发行版作为开发环境？</p><p><strong>Linus Torvalds</strong>：我的房间并不“暗”，但我确实把桌子旁边窗户上的百叶窗关上了，因为我不想要强烈的阳光。所以，我的房间没有什么风景视野，<strong>只有一张（凌乱的）桌子，配了两个 4k 显示器，桌子下面有一台强劲的电脑主机</strong>。还有几台笔记本电脑供我测试和在路上用。</p><p>我喜欢安静地工作。我很讨厌机械硬盘的滴答声，所以我把它们扔进了垃圾桶，现在只使用 SSD。这样已经 10 多年了。嘈杂的 CPU 风扇声也是不可接受的。</p><p>代码评审都是在传统的终端上完成的，不过我没有使用 vi。我使用的是“<strong>micro-emacs</strong>”这个令人讨厌的东西。它与 GNU emacs 完全没有关系，只是有些键绑定与它相似。我在赫尔辛基大学时就习惯用它了，到现在还没改掉这个习惯。几年前，我给它增加了（非常有限的）utf-8 支持，但它确实很老旧了，所有的迹象都表明它是在 80 年代开发的，我使用的版本是一个自 90 年代中期以来就没有更新过的分支。</p><p>赫尔辛基大学选择了这个工具，因为它可以在 DOS、VAX/VMS 和 Unix 上运行，这也是为什么我也会用它。到现在，我的手指已经对它形成肌肉记忆了。我真的需要换个有人维护并支持 utf-8 的工具，只是我增强的那部分功能用起来还好，所以一直没有强迫我的手指去接受新的工具。</p><p>我的工作桌面相当简单：几个文本终端，一个打开了电子邮箱的浏览器（还打开了其他几个标签，主要是新闻和科技网站）。我喜欢大的桌面空间，因为我习惯使用大终端窗口（100x40 是我的默认初始大小），并且并排打开好几个。我使用了两个 4k 显示器。</p><p>我在所有的机器上都安装了 Fedora 发行版，并不是因为我偏爱它，而是因为我习惯了。我并不太关心使用哪个发行版——对于我来说，选择发行版只是在机器上安装 Linux 和开发工具的一种方式。</p><h3><span id="如何处理大量电子邮件">如何处理大量电子邮件？</span></h3><p><strong>Jeremy Andrews：Linux 内核邮件组（<a href="https://lore.kernel.org/lkml/%EF%BC%89" target="_blank" rel="noopener">https://lore.kernel.org/lkml/）</a> 是人们公开交流内核开发的地方，流量非常高。你是怎么处理这么多电子邮件的？你尝试过邮件组之外的其他协作和沟通解决方案吗？或者说，这种简单的邮件组对你的工作来说足够好吗？</strong></p><p><strong>Linus Torvalds</strong>：我没有直接阅读内核邮件组里的邮件，而且好几年都没有。邮件太多了。</p><p>内核邮件组里的邮件会被抄送到所有的讨论当中。当新人加入讨论时，他们可以通过查看内核邮件组来了解相关的历史和背景。</p><p>过去我会订阅邮件组，让所有没有抄送给我的电子邮件自动归档，默认不看它们。当一些问题需要我介入时，我可以找到所有相关的讨论，因为它们都在我的电子邮件里，只是在需要时才会出现在我的收件箱里。</p><p>现在，我使用的是 <a href="http://lore.kernel.org" target="_blank" rel="noopener">lore.kernel.org</a> 提供的功能，因为它很好用，而且我们还基于它开发了一些工具。这样就不需要让邮件自动归档了，我们换了一种讨论方式，但基本的工作流程是一样的。</p><p>但很显然，我仍然会收到很多邮件——但从很多方面来看，这些年来情况变得越来越好，而不是越来越糟。其中很大一部分原因是 Git 和内核发布流程的改进：我们过去在代码流程和工具方面存在很多问题。在本世纪初是最为糟糕的，当时我们仍然在处理巨大的补丁炸弹，我们的开发流程存在严重的可伸缩性问题。</p><p>邮件组模式确实运作得很好，但并不是说人们就不使用除电子邮件之外的其他沟通方式了：有些人喜欢各种实时聊天工具（比如传统的 IRC）。虽然我不是很喜欢这样，但很显然有些人喜欢用它们来进行头脑风暴。但这种“邮件组存档”模式运作得非常好，并且能够无缝地与“开发者之间以邮件的形式发送补丁”和“以邮件的形式发送问题报告”相结合。</p><p>所以电子邮件仍然是主要的沟通渠道，并且因为邮件中可以包含补丁，我们可以更容易地讨论技术问题。而且邮件可以跨越时区，当参与者分布在不同地区时，这一点非常重要。</p><h3><span id="linux-30-以来内核开发的有趣事情">Linux 3.0 以来，内核开发的有趣事情</span></h3><p><strong>Jeremy Andrews：我密切关注内核开发大约有 10 年了，并在 KernelTrap 上写与内核有关的博文，大概是在 3.0 内核发布时停止更新博客。3.0 内核的发布与 2.6.x 内核的发布相隔了 8 年。请总结一下自 3.0 版本以来内核开发中发生的一些有趣的事情。</strong></p><p><strong>Linus Torvalds</strong>：那是很久以前的事了，我不知道该从哪里开始总结。从 3.0 版本到现在已经 10 年了，在这 10 年中发生了很多技术上的变化。ARM 已经发展成熟，ARM64 已经成为我们的主要架构之一，并出现了大量新的驱动程序和核心功能。</p><p>如果说过去 10 年有什么有趣的事情，那一定是我们努力保持开发模式的稳定，以及那些没有发生改变的东西。</p><p>在过去的几十年里，我们经历了多种不同的版本号方案和不同的开发模式，3.0 版本最终确定了后来一直使用的模式。它让“基于时间发布，版本号只是数字，与特性无关”这一说法落地了。</p><p>在 2.6.x 版本中，我们就有了基于时间的发布模式，所以它并不是什么新东西，但 3.0 版本确实是让这种模式板上钉钉的至关重要的一步。</p><p>我们以前使用随机编号方案（主要是在 1.0 版本之前），然后用“奇数表示开发版内核，偶数表示稳定的生产就绪版内核”，然后在 2.6.x 版本中，我们开始进入基于时间的发布模式。但人们仍然对“什么时候需要增加主版本号”存在疑问。3.0 版本正式发布后，宣告了主版本号没有任何意义，我们尽量简化数字，不要让它们变得太大。</p><p>因此，在过去的 10 年里，我们做了巨大的改变（有了 Git，就可以很容易地得到一些数字统计数据：超过 1.7 万人提交了大约 75 万次代码），但开发模式仍然相当稳定。</p><p>但并非一直都是这样的，内核开发的前 20 年经历了相当痛苦的开发模式变更，只是在过去 10 年中，发布可预测性才得到大幅提升。</p><h3><span id="linux-发布流程">Linux 发布流程</span></h3><p><strong>Jeremy Andrews：目前，最新的版本是 5.12-rc5。现在的发布流程标准是怎样的？例如，-rc1 和 -rc2 有什么不同？你会在什么情况下决定正式发布其中一个给定的版本？如果在正式发布之后出现了大量的回归会怎样？这种情况发生的频率是怎样的？这些年来，这个过程是如何演变的？</strong></p><p><strong>Linus Torvalds</strong>：我之前提到过，这个过程本身是很标准的，并且在过去十年里一直如此。在此之前，它经历了几次演变，但实际上从 3.0 开始它就像时钟一样走得很稳定。</p><p>到现在为止，我们的发布节奏是这样的：先是两周的合并时间窗口，然后是大约 6 到 8 周的候选版本，然后是最终版本。这样子差不多 15 年了。</p><p>规则一直都是一样的，尽管它们并不总是被完全严格执行：合并时间窗口是针对那些被认为已经“经过测试和准备就绪”的新代码，然后在接下来的大约两个月里进行修复，以确保所有的问题都得到解决。有时候，那些所谓的“就绪”代码会在发布之前会被禁用或完全推翻。</p><p>这个过程会重复，所以我们大约每 10 周发布一次。</p><p>达到可以发布的标准是我对候选版本有足够的信心，而这是以各种问题报告为基础的。如果某些方面在 rc 后期仍然会出问题，我就极力推翻这些内容，并建议将其放在后续的版本中。但总体而言，很少会出现这种情况。</p><p>这样就完全没有问题了吗？不是的。一旦内核发布了，就会有新用户，他们会发现一些在 rc 版本中没有被发现的问题。这几乎是不可避免的。这也是为什么我们需要“稳定内核”树。在发布之后，我们可以继续修复代码。一些稳定内核比其他版本内核维护的时间更长，被称为 LTS（“Long Term Support”）版本。</p><p>所有这些在过去十年里都没有什么变化，尽管后来有了更多的自动化流程。一般来说，内核测试自动化是很困难的——因为很多内核是驱动程序，十分依赖硬件的可用性。不过，我们有几个测试场同时进行引导和性能测试，以及各种随机负载测试。这些在这几年有了很大的改善。</p><h3><span id="一直等待可用的-arm-机器">一直等待可用的 ARM 机器</span></h3><p><strong>Jeremy Andrews：去年 11 月，有人说你对苹果公司在部分新款电脑中使用的 ARM64 芯片十分感兴趣。Linux 会支持它们吗？我看到一些代码被合并到 for-next。即将到来的 5.13 内核有可能在苹果 MacBook 上启动吗？你有可能是它的早期采用者吗？ARM64 有什么重大的意义？</strong></p><p><strong>Linus Torvalds</strong>：我偶尔会跟进一下，但现在说这些还为时过早。正如你所说的，早期支持可能会被合并到 5.13 中，但这只是一个开始，并不能说明 Linux 和苹果电脑将来会怎样。</p><p>主要问题不是 arm64 架构，而是与之相关的所有硬件驱动程序（特别是 SSD 和 GPU）。到目前为止，一些底层的东西得到了支持，但除了可以启用硬件之外，没有任何有用的结果。要想达到可以被人们使用的程度，还需要一些时间。</p><p>不仅仅是苹果的硬件得到了改进——arm64 架构总体上也已经成长了很多，内核在服务器领域也更具竞争力了。不久前，arm64 在服务器领域的竞争力还很弱，但亚马逊的 Graviton2 和安培的 Altra 处理器——都是基于改进后的 ARM Neoverse IP——比几年前的产品要好很多。</p><p>我已经等了十多年都没能等到一个可用的 ARM 机器，可能还要继续等下去，但情况明显比以前好了一些。</p><p>事实上，我很早之前就想要一台 ARM 机器。当我还是个少年，我真正想要的是一台 Acorn Archimedes，但可用性和价格让我最终选择了 Sinclair QL（M68008 处理器），然后几年后换成了 i386。</p><p>所以，这个想法已经酝酿了几十年。但到现在它们还没有被广泛使用，而且对于我来说，它们在价格和性能方面都不具竞争力。希望在不久的将来，这个想法能够变成现实。</p><h3><span id="重写内核会做出的改变">重写内核会做出的改变</span></h3><p><strong>Jeremy Andrews：内核中有什么东西需要进行完全的重写才能达到最优的吗？或者说，内核已经有 30 年的历史了，知识、编程语言和硬件在这 30 年里发生了很大的变化：如果现在让你从头开始重写，你会做出哪些改变？</strong></p><p><strong>Linus Torvalds</strong>：如果有必要的话我们会这么做的。我们真的很擅长重写，那些本来会造成灾难的东西很久以前就被我们重写了。</p><p>我们有很多“兼容”层，不过它们一般不会造成太大问题。如果从头开始重写，这些兼容层是否要去掉，我们还不清楚——它们存在的目的是为了与旧二进制文件向后兼容（通常是与旧架构向后兼容，例如在 x86-64 上运行 32 位的 x86 应用程序）。因为我认为向后兼容是非常重要的，所以即使重写，我也希望保留这些兼容层。</p><p>所以很明显，有很多东西并不是最优的，毕竟任何东西都有改进的空间。但就你提的这个问题，我不得不说，我不鄙视任何东西。有一些遗留驱动程序，可能没有人关心，也没有人去清理，会做一些丑陋的事情，但这主要是因为“没有人关心”。这些在过去不是问题，而一旦成为问题，我们就会积极把这些没人关心的东西移除掉。多年来，我们已经移除了很多驱动程序，当维护不再有任何意义时，我们会放弃整个架构支持。</p><p>“重写”的主要原因是：整个架构不再有意义，但仍然存在一些应用场景。最有可能的情况是，一些小型嵌入式系统并不需要 Linux 提供的所有东西，它们的硬件很小，需要的是更简单、更少的系统功能。</p><p>Linux 已经有了长足的发展。现在，即使是小硬件（比如手机等）也比当初开发 Linux 所使用的机器强大得多。</p><h3><span id="不会用-rust-取代-c-语言来开发内核">不会用 Rust 取代 C 语言来开发内核</span></h3><p><strong>Jeremy Andrews：如果用 Rust 来重写一部分系统会怎样？在这方面还有改进的余地吗？在内核开发方面，你觉得是否有可能用另一种语言（比如 Rust）来取代 C 语言？</strong></p><p><strong>Linus Torvalds</strong>：我不认为我们会用 Rust 取代 C 语言来开发内核，但可能会用来开发一些驱动程序，也许是整个驱动子系统，也许是文件系统。所以不是“取代 C 语言”，而是“在一些有意义的地方扩展我们的 C 代码”。</p><p>当然，驱动程序几乎占了内核的一半代码，有非常大的重写空间，但我不认为所有人都会很期待使用 Rust 全盘重写现有的驱动程序。可能“有些人会用 Rust 开发新驱动程序，或者适当地重写一部分旧驱动程序”。</p><p>现在更多的是“人们在尝试和体验”Rust，仅此而已。Rust 优势的背后肯定存在复杂性，所以我会采取观望的态度，看看这些优势是否真的奏效。</p><h3><span id="内核中最令-linux-之父自豪的部分">内核中最令 Linux 之父自豪的部分</span></h3><p><strong>Jeremy Andrews：内核中是否有你个人感到最自豪的部分？</strong></p><p><strong>Linus Torvalds</strong>：我最想说的是 VFS 层（虚拟文件系统，特别是路径名查找）和 VM。前者是因为 Linux 在做一些基础任务（在操作系统中查找文件名确实是一个核心的操作）时比其他系统都要好得多，后者主要是因为我们支持 20 多种架构，但仍然在使用一个基本统一的 VM 层，我认为这一点很了不起。</p><p>但与此同时，这很大程度上取决于“你最关注内核的哪一部分”。内核很大，不同的开发者（和不同的用户）会关注不同的方面。有些人认为调度是内核中最令人感到兴奋的部分，有些人则关注设备驱动程序的细节（我们有很多这样的驱动程序）。我个人在 VM 和 VFS 这两个方面参与得更多，所以自然会提到它们。</p><h3><span id="linux-在这个方面比其他操作系统做得更好">Linux 在这个方面比其他操作系统做得更好</span></h3><p><strong>Jeremy Andrews：我看了这个关于路径名查找的描述（<a href="https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html%EF%BC%89%EF%BC%8C%E5%AE%83%E6%AF%94%E6%88%91%E9%A2%84%E6%83%B3%E7%9A%84%E8%A6%81%E5%A4%8D%E6%9D%82%E3%80%82%E6%98%AF%E4%BB%80%E4%B9%88%E8%AE%A9" target="_blank" rel="noopener">https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html），它比我预想的要复杂。是什么让</a> Linux 在这方面比其他操作系统做得更好？你说的“更好”是什么意思？</strong></p><p><strong>Linus Torvalds</strong>：路径名查找是一个非常常见和基础的任务，以至于大多数非内核开发者不认为它会是一个问题：他们只知道打开文件，并认为这是理所当然的。</p><p>但要做好其实是相当复杂的。确切地说，因为几乎所有地方都在用路径名查找，所以对性能要求很高，而且大家都希望它在 SMP 环境中具有良好的伸缩性，而在锁定方面又很复杂。你不想发生 IO，那么缓存就非常重要。路径名查找是如此的重要，以至于你不能把它留给底层的文件系统，因为我们有 20 多种不同的文件系统，让它们各自拥有自己的缓存和锁定机制将是一场彻头彻尾的灾难。</p><p>所以，VFS 层的一个主要任务是处理所有路径名组件的锁定和缓存问题，以及所有的序列化和挂载点遍历问题，这些都是通过无锁算法（RCU）来完成的，但也会有一些非常智能的锁（Linux 内核的“lockref”锁是一种非常特殊的“带有引用计数的自旋锁”，表面上看是为 dcache 缓存而设计的，但本质上是一个专门的锁感知引用计数，可以在某些常见情况下消除锁）。</p><p>最终结果是：底层文件系统仍然需要对未缓存的内容进行查找，但它们不需要关心缓存和一致性规则以及与路径名查找相关的原子性规则。VFS 会为它们处理好所有这些问题。</p><p>而且它的性能比任何其他操作系统都要好，基本上可以在拥有数千个 CPU 的机器上完美运行。</p><p>所以不仅仅是“更好”，而是“大写”的更好。没有什么能与之相提并论的了。Linux dcache 是独一无二的。</p><h3><span id="新冠疫情对内核开发的影响">新冠疫情对内核开发的影响</span></h3><p><strong>Jeremy Andrews：过去的一年对全世界来说是艰难的一年。新冠疫情对内核开发进程带来了哪些影响？</strong></p><p><strong>Linus Torvalds</strong>：实际上，得益于我们一直以来的工作方式，它的影响非常小。电子邮件真的是一个很好的工具，我们并不依赖面对面的会议。</p><p>是的，它确实影响了去年的年度内核峰会（今年的峰会仍悬而未决），大多数会议被取消或转为线上进行。以前在办公室工作的人大都开始在家里工作（但很多核心内核维护者在之前已经这么做了）。所以，周围的很多东西都发生了改变，但内核开发还是像以前一样。</p><p>很显然，新冠疫情在其他方面影响了我们所有人的生活，但总的来说，作为几乎完全通过电子邮件进行交流的内核开发人员，我们可能是受影响最小的。</p><h2><span id="版本控制系统-git">版本控制系统 Git</span></h2><h3><span id="对-git-项目领导权主动放手">对 Git 项目领导权主动放手</span></h3><p><strong>Jeremy Andrews：Linux 只是你对开源做出的众多贡献中的一个。在 2005 年，你还创建了 Git，一个非常流行的分布式源代码控制系统。你快速地将 Linux 内核源代码树从专有的 Bitkeeper 迁移到开源的 Git 系统中，并在同年将维护工作移交给了 Junio Hamano。这里有很多有趣的故事，是什么原因促使你这么快就将项目的领导权移交了出来，你是如何找到并选择了 Junio 的？</strong></p><p><strong>Linus Torvalds</strong>：答案可以分为两个部分。</p><p>首先，我并不想创建一个新的源代码控制系统。开发 Linux 是因为硬件和软件之间的底层接口很吸引我——基本上是出于个人的热爱和兴趣。相反，开发 Git 是因为确实有这个需要：不是因为我觉得源代码控制很有趣，而是因为我十分鄙视市面上的大多数源代码控制系统。而我觉得最合适的、在 Linux 开发当中很好用的 BitKeeper 已经无法维持下去了。</p><p>我开发 Linux 已经超过 30 年了（距离第一个版本的周年纪念还有几个月，但在 30 年前我就开始研究 Linux 的“前身”了），并且一直在维护它。但 Git 呢？我从来没有想过我真的想要长期维护它。我喜欢用它，而且在某种程度上，我认为它是最好的 SCM，但它并不是我的兴趣所在。</p><p>所以我总是希望别人来为我维护 SCM——事实上，如果当初我不用自己开发这个 SCM，我会很开心。</p><p>以上就是故事的背景。</p><p>至于 Junio，他实际上是最早加入 Git 开发队伍的人员之一。他在我将 Git 的第一个非常粗糙的版本公开后的几天内提交了第一次变更代码，所以 Junio 在 Git 一开始就参与其中了。</p><p>但我之所以把项目交给 Junio，并不是因为他是第一批参与项目的人。在维护了 Git 几个月之后，让我决定将项目交给 Junio 维护者的真正原因是“好品味”——一个很难描述的概念。我真的想不到还有什么更好的描述：编程主要是为了解决技术问题，但如何解决这些问题以及如何思考也很重要。随着时间的推移，你开始意识到：有些人就有这种“好品味”，他总能选择正确的解决方案。</p><p>我不想将编程说成是一门艺术，因为它实际上主要是关于“好的工程”。我很喜欢托马斯·爱迪生的那句“天才是百分之一的灵感加上百分之九十九的汗水”：编程涉及的几乎都是细枝末节的东西和日常繁重的工作。但是，那百分之一的“灵感”，也就是“好品味”，不仅要解决问题，而且要干净、漂亮地解决。</p><p>Junio 就有那种“好品味”。</p><p>每次提到 Git，我都想试着讲清楚：我在一开始提出了 Git 的核心思想，并经常因为这部分工作而获得太多荣誉。Git 的这 15 年，我也只是在第一年真正参与了项目。Junio 是一个优秀的维护者，是他让 Git 变成现在的样子。</p><p>顺便说一下，关于“好品味”，以及找到拥有好品味的人，并信任他们——不仅仅 Git 是这样，Linux 也是这样。与 Git 不一样的是，Linux 这个项目我仍然在积极维护，但与 Git 一样的是，Linux 也是一个有很多人共同参与的项目。我认为，Linux 的一大成功是它拥有数百名维护者，他们都具备了“好品味”，并维护着内核的不同部分。</p><h3><span id="项目维护并非非黑即白">项目维护并非“非黑即白”</span></h3><p><strong>Jeremy Andrews：你有没有过这样的经历：把控制权交给维护者，然后发现这是一个错误的决定？</strong></p><p><strong>Linus Torvalds</strong>：我们的维护体系从来就不是非黑即白的，所以不会出现这种情况。事实上，我们甚至没有将维护权正式记录下来：我们确实有一个 MAINTAINERS 文件，但那只是为了让你在遇到问题时能够找到对的人，并不是某种排他所有权的标志。</p><p>所以，“谁负责什么东西”更像是一种流动的指南，以及“这个人很活跃，工作做得很好”，而不是“我们把所有权给了那个人，然后他搞砸了”。</p><p>从某种意义上说，我们的维护体系也是流动的。假设你是某个子系统的维护者，如果你需要另一个子系统的东西，是可以跨界的。通常人们在这样做之前都会进行广泛的沟通，而且这种事情确实发生了。这并不是“你只能动这个文件”之类的硬性规定。</p><p>实际上，这与前面讨论的有关许可的事情有些联系。“Git”的另一个设计原则是“每个人都有自己的代码树，但没有哪一个代码树是特殊的”。</p><p>因为很多其他项目都使用了工具——比如 CVS 或 SVN——这些工具会让一些人变得“特殊”，赋予了他们某种“所有权”。在 BSD 世界里，他们称之为“commit bit”：给一个维护者“commit bit”意味着他可以将代码提交到中央代码库。</p><p>我一直很讨厌这种模式，因为它会不可避免地导致政治“小团体”的出现。在这种模式下，总有一些人是特殊、隐性受信任的。问题的关键甚至不在于“隐性受信任”，而在于硬币的另一面——其他人不被信任，他们被定义成局外人，必须受制于监护者。</p><p>同样，在 Git 开发中也不存在这种情况。每个人都是平等的，任何人都可以克隆代码，做自己的开发，做好了，就可以合并回来。</p><p>所以，没有必要给人们特权，也不需要“commit bit”。这样就可以避免出现政治“小团体”，也不需要“隐性信任”。如果他们做得不好——或者更常见的是，最终消失了，并转向了另一个兴趣——他们的代码就不会被合并回来，也不会阻碍其他有新想法的人。</p><h3><span id="对-git-特性的看法">对 Git 特性的看法</span></h3><p><strong>Jeremy Andrews：Git 有没有哪些新特性让你印象深刻，并成为你工作流的一部分？还有哪些特性是你想要增加的？</strong></p><p><strong>Linus Torvalds</strong>：我对 Git 的需求总是最早得到满足的，所以，对于我来说，Git 没有“新”特性。</p><p>这些年来，Git 确实有很大的改进，有一些在我的工作流中已经体现出来了。例如，Git 的速度一直都很快——毕竟这是我的设计目标之一——但它的大部分特性最初是围绕 shell 脚本而构建的。多年来，大多数 shell 脚本都已经消失了，这意味着我可以比原来更快地应用 Andrew Morton 的补丁。这一点令人感到欣慰，因为这实际上是我早期用于性能测试的基准之一。</p><p>所以，Git 对我来说一直都很好，而且变得越来越好。</p><p>Git 最大的改进在于“普通用户”的使用体验变得更好了。一部分原因是人们在学习 Git 工作流的过程中逐渐习惯了它，但更多的是因为 Git 本身变得更易于使用。</p><blockquote><p>本文转载自：「 架构头条 」，原文：<a href="https://tinyurl.com/wxejbh4w" target="_blank" rel="noopener">https://tinyurl.com/wxejbh4w</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;作者丨 Jeremy Andrews&lt;/li&gt;
&lt;li&gt;译者丨屠灵&lt;/li&gt;
&lt;li&gt;策划丨蔡芳芳&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux 诞生于 1991 年，距今已经 30 年了。虽然它一开始只是 Linus 的一个个人项目，而非出于要开发一个新操作系统的伟大梦想，但如今的 Linux 早已无处不在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;30 年前，当 Linus Torvalds 第一次发布 Linux 内核时，他还是赫尔辛基大学的一名 21 岁的学生。他宣布说：“我正在开发一个（免费的）操作系统（这只是个爱好，不会做得很大，也不会很专业……）”。30 年后，500 强超级计算机和 70% 以上的智能手机都在运行 Linux。很显然，Linux 不仅大，而且很专业。&lt;/p&gt;
&lt;p&gt;30 年来，Linus Torvalds 一直在领导着 Linux 内核的开发，启发了无数开发者和开源项目。2005 年，Linus 开发了 Git，用来管理内核开发过程。Git 现在已经成为最流行的版本控制系统，受到无数开源和私有项目的信任。&lt;/p&gt;
&lt;p&gt;正值 Linux 诞生 30 周年之际，Linus Torvalds 通过电子邮件回复了 Tag 1 咨询公司的创始合伙人 / 首席执行官 Jeremy Andrews 的访谈问题（《An Interview With Linus Torvalds: Linux and Git - Part 1》），回顾并总结了过去这些年他在领导大型开源项目过程中得到的真知灼见。本文着重介绍 Linux 内核开发和 Git。InfoQ 对访谈内容进行了翻译，以飨读者。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="杂谈" scheme="https://www.hi-linux.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>6 张图带你搞懂微服务</title>
    <link href="https://www.hi-linux.com/posts/39095.html"/>
    <id>https://www.hi-linux.com/posts/39095.html</id>
    <published>2021-06-10T01:00:00.000Z</published>
    <updated>2021-06-10T09:50:38.832Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>虽说<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">微服务</a>早已是一个老生常谈的话题了，在 <a href="https://www.infoq.cn/topic/microservice" target="_blank" rel="noopener">infoq</a> 或者 <a href="https://insights.thoughtworks.cn/tag/microservices/" target="_blank" rel="noopener">thoughtworks</a> 上可以找到很多案例，不过可惜的是其中相当比例的案例是失败的案例，究其原因，除了<a href="https://microservices.io/index.html" target="_blank" rel="noopener">技术门槛</a>之外，主要是因为很多人脱离了实际情况，只是为了微服务而微服务。本文通过一个例子带领大家从头到尾体验一下微服务的演化过程，不仅要做到知其然，更要做到知其所以然。</p><a id="more"></a><p>假设我们正在开发一个在线购物项目，其主要功能包括商城、推荐、评论、用户等，它是一个典型的<a href="https://microservices.io/patterns/monolithic.html" target="_blank" rel="noopener">单体架构</a>：不同团队的技术人员工作在同一个版本库上，系统功能按模块划分，不同模块之间通过本地函数调用，通常操作同一个数据库。</p><p><img src="https://img.hi-linux.com/staticfile/ms01-20210514145248915-2021-05-14-k5YOD0.png" alt></p><p>在项目早期，单体架构往往能很好的适应快速迭代的需求，不过随着项目的发展，项目本身会变得复杂，其弊端不可避免的出现，比如下面列举的一些情况：</p><ul><li>因为大家都工作在同一个版本库上，所以可能会遇到：商城模块完成了新功能，准备上线，结果推荐模块刚提交了还没来得及测试的代码，于是不得不推迟上线。</li><li>不同的需求采用不同的技术栈：负责评论模块的同事想用 PHP + MySQL 来构建系统，负责用户模块的同事却想用 Golang + PostgreSQL 来构建系统。</li><li>有的模块需要高性能 CPU，有的模块需要大内存，因为不同的模块是耦合在一起的，所以我们的服务器不得不同时具备高性能 CPU，大内存，从而增加了成本。</li></ul><p>如何解决此类问题？<a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">康威定律</a>给出了很好的建议：「设计系统的架构受制于产生这些设计的组织的沟通结构」，通俗点说就是：「有什么样的组织架构就会设计出什么样的系统架构」。在本例中，因为不同的团队负责不同的模块，所以很自然的可以通过模块来把系统切分成商城、推荐、评论、用户等几个独立的服务：每个服务有自己独立的版本库和数据库，服务之间通过 RPC 来通信。不同的服务拥有自己的版本库，可以使用适合自己的技术栈和硬件，独立开发独立部署。</p><p>一个需要注意的问题是如何确定服务粒度的大小，虽然按照康威定律的描述只要按照组织架构的大小来确定服务的大小即可，但是如何规划一个合理的团队规模呢？实际上并没有一个精确的答案，我们需要按照客观情况来确定一个适合自己的大小适中的服务粒度，过小的粒度会导致服务之间强耦合，过大的粒度则背离了微服务的初衷，Uber 甚至还针对服务粒度大小问题发明了一个<a href="https://mp.weixin.qq.com/s/1P_5mMeZQ8YQzybLmjENLg" target="_blank" rel="noopener">宏服务</a>的概念，有兴趣的读者不妨看看。</p><p><img src="https://img.hi-linux.com/staticfile/ms02-20210514145255339-2021-05-14-mujm29.png" alt></p><p>当我们把单体架构切分成独立的服务之后，原本模块间本地的函数调用变成了服务间远程的 RPC 调用，我们不得不处理服务治理之类的问题，随着微服务数量的增加，问题会变得越来越棘手，好在随着云原生的发展，特别是 <a href="https://kubernetes.io/" target="_blank" rel="noopener">K8S</a> 和 <a href="https://istio.io/" target="_blank" rel="noopener">istio</a> 等技术的成熟，我们的架构可以演化到 <a href="https://www.servicemesher.com/" target="_blank" rel="noopener">service mesh</a> 阶段，通过 sidecar 透明实现服务治理。</p><p><img src="https://img.hi-linux.com/staticfile/ms03-2021-05-14-7Q6UhO.png" alt></p><p>如果仅仅是把原本模块间本地的函数调用变成了服务间远程的 RPC 调用的话，那么我们的微服务很可能会沦为「<a href="https://skyao.io/talk/202007-microservice-avoiding-distributed-monoliths/" target="_blank" rel="noopener">分布式单体</a>」。问题的症结在于过度使用 RPC，导致服务与服务之间强耦合，解决方法是引入 Event，通过 Event 实现服务与服务的解耦。</p><p>看看如何实现下面的业务逻辑：当一个用户注册后，要在商城里给用户一张优惠券。</p><ul><li>使用 RPC（强调做什么）：当用户模块创建了一个新用户的时候，通过 RPC 调用商城模块给用户一张优惠券，过程中用户模块和商城模块是强耦合的。</li><li>使用 Event（强调发生了什么）：当用户模块创建了一个新用户的时候，它发出一个 UserCreated 事件，商城模块观察到对应的事件后，给用户一张优惠券，过程中用户模块和商城模块是弱耦合的。</li></ul><p>实际情况中应该按需求来选择使用 RPC 或者 Event：如果是业务逻辑的实现部分，倾向于选择使用 RPC；如果是业务逻辑完成之后的后续通知部分，强烈建议选择使用 Event。</p><p><img src="https://img.hi-linux.com/staticfile/ms04-2021-05-14-mw4b0B.png" alt></p><p>服务部署好了之后，接下来我们还需要考虑如何暴露服务以供前端调用，比如用户浏览某个商品的详情页，内容包括商品数据、以及对应的推荐数据和评论数据，如果直接操作服务的话，那么需要多次查询商品服务、推荐服务、评论服务，并不可取，此时可以加入 <a href="https://microservices.io/patterns/apigateway.html" target="_blank" rel="noopener">API Gateway</a> 充当代理，前端只要请求 API Gateway 一次就可以拿到数据。</p><p><img src="https://img.hi-linux.com/staticfile/ms05-2021-05-14-oA6Kbk.png" alt></p><p>有了 API Gateway 之后，它可以帮我们完成聚合之类的逻辑。不过有一个问题是前端可能有多种不同的类型，比如 PC 前端，Mobile 前端，它们的业务逻辑不可避免的会有各种各样的差异，如果在 API Gateway 中处理这些差异的话，那么会出现坏味道，为了解决此类问题，我们引入 <a href="https://microservices.io/patterns/apigateway.html" target="_blank" rel="noopener">BFF</a>（Backend For Frontend），每一种前端都有属于自己的 BFF，用来处理专属于自己的业务逻辑，至于 API Gateway，则只处理鉴权，日志等公共业务逻辑。</p><p><img src="https://img.hi-linux.com/staticfile/ms06-2021-05-14-teyyms.png" alt></p><p>微服务是个极其复杂的概念，本文仅就一些表面问题浅谈一二，其他诸如 <a href="https://microservices.io/patterns/data/saga.html" target="_blank" rel="noopener">SAGA</a> 之类的复杂问题，由于篇幅所限，并未涉猎，大家如果有兴趣的话请自行查阅。</p><p>最后把 <a href="https://martinfowler.com/" target="_blank" rel="noopener">Martin Fowler</a> 在 <a href="https://www.martinfowler.com/books/eaa.html" target="_blank" rel="noopener">PoEAA</a> 中提出的<a href="https://martinfowler.com/bliki/FirstLaw.html" target="_blank" rel="noopener">分布式对象第一定律</a>送给大家：不要分布你的对象！套用这个说法的话，不难引申出微服务第一定律：不要使用微服务！虽然话里有一些戏虐的成份，但是它至少告诫我们在面对微服务的时候要怀揣着一颗敬畏的心。</p><blockquote><p>本文转载自：「 火丁笔记 」，原文：<a href="http://t.cn/A6VzZPdg" target="_blank" rel="noopener">http://t.cn/A6VzZPdg</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽说&lt;a href=&quot;https://martinfowler.com/articles/microservices.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微服务&lt;/a&gt;早已是一个老生常谈的话题了，在 &lt;a href=&quot;https://www.infoq.cn/topic/microservice&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;infoq&lt;/a&gt; 或者 &lt;a href=&quot;https://insights.thoughtworks.cn/tag/microservices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;thoughtworks&lt;/a&gt; 上可以找到很多案例，不过可惜的是其中相当比例的案例是失败的案例，究其原因，除了&lt;a href=&quot;https://microservices.io/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;技术门槛&lt;/a&gt;之外，主要是因为很多人脱离了实际情况，只是为了微服务而微服务。本文通过一个例子带领大家从头到尾体验一下微服务的演化过程，不仅要做到知其然，更要做到知其所以然。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="https://www.hi-linux.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="微服务" scheme="https://www.hi-linux.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linux下优雅的进行大文件切割与合并</title>
    <link href="https://www.hi-linux.com/posts/15581.html"/>
    <id>https://www.hi-linux.com/posts/15581.html</id>
    <published>2021-06-10T01:00:00.000Z</published>
    <updated>2021-06-10T09:50:38.834Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>往往是因为网络传输的限制，导致很多时候，我们需要在 Linux 系统下进行大文件的切割。这样将一个大文件切割成为多个小文件，进行传输，传输完毕之后进行合并即可。</strong></p></blockquote><h2><span id="1-文件切割-split">1. 文件切割 - split</span></h2><blockquote><p><strong>在 Linux 系统下使用 split 命令进行大文件切割很方便</strong></p></blockquote><ul><li><strong>[1] 命令语法</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a: 指定输出文件名的后缀长度(默认为2个:aa,ab...)</span></span><br><span class="line"><span class="comment"># -d: 指定输出文件名的后缀用数字代替</span></span><br><span class="line"><span class="comment"># -l: 行数分割模式(指定每多少行切成一个小文件;默认行数是1000行)</span></span><br><span class="line"><span class="comment"># -b: 二进制分割模式(支持单位:k/m)</span></span><br><span class="line"><span class="comment"># -C: 文件大小分割模式(切割时尽量维持每行的完整性)</span></span><br><span class="line">split [-a] [-d] [-l &lt;行数&gt;] [-b &lt;字节&gt;] [-C &lt;字节&gt;] [要切割的文件] [输出文件名]</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><strong>[2] 使用实例</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行切割文件</span></span><br><span class="line">$ split -l 300000 users.sql /data/users_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用数字后缀</span></span><br><span class="line">$ split -d -l 300000 users.sql /data/users_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字节大小分割</span></span><br><span class="line">$ split -d -b 100m users.sql /data/users_</span><br></pre></td></tr></table></figure><ul><li><strong>[3] 帮助信息</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 帮助信息</span></span><br><span class="line">$ split --<span class="built_in">help</span></span><br><span class="line">Usage: split [OPTION]... [FILE [PREFIX]]</span><br><span class="line">Output pieces of FILE to PREFIXaa, PREFIXab, ...;</span><br><span class="line">default size is 1000 lines, and default PREFIX is <span class="string">'x'</span>.</span><br><span class="line"></span><br><span class="line">With no FILE, or when FILE is -, <span class="built_in">read</span> standard input.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory <span class="keyword">for</span> short options too.</span><br><span class="line">  -a, --suffix-length=N   generate suffixes of length N (default 2)            后缀名称的长度(默认为2)</span><br><span class="line">      --additional-suffix=SUFFIX  append an additional SUFFIX to file names</span><br><span class="line">  -b, --bytes=SIZE        put SIZE bytes per output file                       每个输出文件的字节大小</span><br><span class="line">  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file    每个输出文件的最大字节大小</span><br><span class="line">  -d                      use numeric suffixes starting at 0, not alphabetic   使用数字后缀代替字母后缀</span><br><span class="line">      --numeric-suffixes[=FROM]  same as -d, but allow setting the start value</span><br><span class="line">  -e, --elide-empty-files  <span class="keyword">do</span> not generate empty output files with <span class="string">'-n'</span>        不产生空的输出文件</span><br><span class="line">      --filter=COMMAND    write to shell COMMAND; file name is <span class="variable">$FILE</span>           写入到shell命令行</span><br><span class="line">  -l, --lines=NUMBER      put NUMBER lines/records per output file             设定每个输出文件的行数</span><br><span class="line">  -n, --number=CHUNKS     generate CHUNKS output files; see explanation below  产生chunks文件</span><br><span class="line">  -t, --separator=SEP     use SEP instead of newline as the record separator;  使用新字符分割</span><br><span class="line">                            <span class="string">'\0'</span> (zero) specifies the NUL character</span><br><span class="line">  -u, --unbuffered        immediately copy input to output with <span class="string">'-n r/...'</span>     无需缓存</span><br><span class="line">      --verbose           <span class="built_in">print</span> a diagnostic just before each                  显示分割进度</span><br><span class="line">                            output file is opened</span><br><span class="line">      --<span class="built_in">help</span>     display this <span class="built_in">help</span> and <span class="built_in">exit</span>                                    显示帮助信息</span><br><span class="line">      --version  output version information and <span class="built_in">exit</span>                           显示版本信息</span><br><span class="line"></span><br><span class="line">The SIZE argument is an <span class="built_in">integer</span> and optional unit (example: 10K is 10*1024).</span><br><span class="line">Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).</span><br><span class="line"></span><br><span class="line">CHUNKS may be:</span><br><span class="line">  N       split into N files based on size of input</span><br><span class="line">  K/N     output Kth of N to stdout</span><br><span class="line">  l/N     split into N files without splitting lines/records</span><br><span class="line">  l/K/N   output Kth of N to stdout without splitting lines/records</span><br><span class="line">  r/N     like <span class="string">'l'</span> but use round robin distribution</span><br><span class="line">  r/K/N   likewise but only output Kth of N to stdout</span><br><span class="line"></span><br><span class="line">GNU coreutils online <span class="built_in">help</span>: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">Full documentation at: &lt;http://www.gnu.org/software/coreutils/split&gt;</span><br><span class="line">or available locally via: info <span class="string">'(coreutils) split invocation'</span></span><br></pre></td></tr></table></figure><h2><span id="2-文件合并-cat">2. 文件合并 - cat</span></h2><blockquote><p><strong>在 Linux 系统下使用 cat 命令进行多个小文件的合并也很方便</strong></p></blockquote><ul><li><strong>[1] 命令语法</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -n: 显示行号</span></span><br><span class="line"><span class="comment"># -e: 以$字符作为每行的结尾</span></span><br><span class="line"><span class="comment"># -t: 显示TAB字符(^I)</span></span><br><span class="line">cat [-n] [-e] [-t] [输出文件名]</span><br></pre></td></tr></table></figure><ul><li><strong>[2] 使用实例</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并文件</span></span><br><span class="line">$ cat /data/users_* &gt; users.sql</span><br></pre></td></tr></table></figure><ul><li><strong>[3] 帮助信息</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 帮助信息</span></span><br><span class="line">$ cat --h</span><br><span class="line">Usage: cat [OPTION]... [FILE]...</span><br><span class="line">Concatenate FILE(s) to standard output.</span><br><span class="line"></span><br><span class="line">With no FILE, or when FILE is -, <span class="built_in">read</span> standard input.</span><br><span class="line"></span><br><span class="line">  -A, --show-all           equivalent to -vET</span><br><span class="line">  -b, --number-nonblank    number nonempty output lines, overrides -n</span><br><span class="line">  -e                       equivalent to -vE</span><br><span class="line">  -E, --show-ends          display $ at end of each line</span><br><span class="line">  -n, --number             number all output lines</span><br><span class="line">  -s, --squeeze-blank      suppress repeated empty output lines</span><br><span class="line">  -t                       equivalent to -vT</span><br><span class="line">  -T, --show-tabs          display TAB characters as ^I</span><br><span class="line">  -u                       (ignored)</span><br><span class="line">  -v, --show-nonprinting   use ^ and M- notation, except <span class="keyword">for</span> LFD and TAB</span><br><span class="line">      --<span class="built_in">help</span>     display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">      --version  output version information and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  cat f - g  Output f<span class="string">'s contents, then standard input, then g'</span>s contents.</span><br><span class="line">  cat        Copy standard input to standard output.</span><br><span class="line"></span><br><span class="line">GNU coreutils online <span class="built_in">help</span>: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">Full documentation at: &lt;http://www.gnu.org/software/coreutils/cat&gt;</span><br><span class="line">or available locally via: info <span class="string">'(coreutils) cat invocation'</span></span><br></pre></td></tr></table></figure><h2><span id="3-参考文档">3. 参考文档</span></h2><ul><li><a href="https://www.cnblogs.com/bymo/p/7571320.html" target="_blank" rel="noopener">Linux 大文件的分割与合并</a></li><li><a href="https://www.jianshu.com/p/014ec71b0215" target="_blank" rel="noopener">Linux 学习–文件分割与合并</a></li></ul><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/y3zhsyyw%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://tinyurl.com/y3zhsyyw，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;往往是因为网络传输的限制，导致很多时候，我们需要在 Linux 系统下进行大文件的切割。这样将一个大文件切割成为多个小文件，进行传输，传输完毕之后进行合并即可。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-文件切割-split&quot;&gt;1. 文件切割 - split&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在 Linux 系统下使用 split 命令进行大文件切割很方便&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[1] 命令语法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -a: 指定输出文件名的后缀长度(默认为2个:aa,ab...)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -d: 指定输出文件名的后缀用数字代替&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -l: 行数分割模式(指定每多少行切成一个小文件;默认行数是1000行)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -b: 二进制分割模式(支持单位:k/m)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -C: 文件大小分割模式(切割时尽量维持每行的完整性)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;split [-a] [-d] [-l &amp;lt;行数&amp;gt;] [-b &amp;lt;字节&amp;gt;] [-C &amp;lt;字节&amp;gt;] [要切割的文件] [输出文件名]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Shell" scheme="https://www.hi-linux.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款开源即时性能分析工具 Pyroscope</title>
    <link href="https://www.hi-linux.com/posts/52545.html"/>
    <id>https://www.hi-linux.com/posts/52545.html</id>
    <published>2021-06-09T01:00:00.000Z</published>
    <updated>2021-06-09T01:24:04.959Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>当网站上线后，流量增加或短暂功能故障，都会造成使用者体验相当不好，而这时该怎么快速找到性能的瓶颈呢？通常 CPU 达到 100% 时，有时候也很难复制及找出关键问题点。</p><p>本篇文章，我们会介绍一套工具叫 Pyroscope，让开发者可以快速找到性能瓶颈的代码。Pyroscope 目前可以支持 Python, Ruby 或 Go 的环境。本文笔者会针对 Go 环境做介绍。</p><h2><span id="什么是-pyroscope">什么是 Pyroscope？</span></h2><p>Pyroscope 是一套开源的性能即时监控平台，简单的 Server 及 Agent 架构，让开发者可以轻松监控代码性能，不管你要找 10 秒或几分钟内的性能数据，都可以快速的即时呈现，开发者也不用在意装了此监控会造成任何性能上的负担。Pyroscope 背后的储存采用 Badger 这套 Key-Value 数据库，性能上是非常好的。目前只支持 3 种语言 (Python, Ruby 及 Go) 未来会预计支持 NodeJS。假设您还没引入任何性能分析工具或平台，那 Pyroscope 会是您最好的选择。</p><a id="more"></a><h2><span id="pyroscope-架构">Pyroscope 架构</span></h2><p>如果你有打算找性能分析工具平台，Pyroscope 提供了三大优势，让开发者可以放心使用</p><ul><li>低 CPU 使用率，不会影响既有平台</li><li>可储存好几年的资料，并且可用 10 秒细颗粒度查看资料</li><li>压缩储存资料，减少浪费硬盘空间</li><li>架构只有分 Server 和 Agent，除了 Go 语言之外，Python 跟 Ruby App 都是透过 pyroscope 指令启动相关 app 来监控系统效能。</li></ul><p><img src="https://img.hi-linux.com/staticfile/36tdD2-2021-04-22-Im2TSi.jpg" alt="Pyroscope 架构图"></p><h2><span id="启动-pyroscope-服务">启动 Pyroscope 服务</span></h2><p>启动方式有两种，第一是直接用 docker 指令启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -p 4040:4040 pyroscope&#x2F;pyroscope:latest server</span><br></pre></td></tr></table></figure><p>另一种可以用 docker-compose 启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">services:</span><br><span class="line">  pyroscope:</span><br><span class="line">    image: &quot;pyroscope&#x2F;pyroscope:latest&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;4040:4040&quot;</span><br><span class="line">    command:</span><br><span class="line">      - &quot;server&quot;</span><br></pre></td></tr></table></figure><h2><span id="安装-agent">安装 Agent</span></h2><h3><span id="在-go-语言中使用">在 Go 语言中使用</span></h3><p>本篇用 Go 语言当作示例，先 import package</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;github.com&#x2F;pyroscope-io&#x2F;pyroscope&#x2F;pkg&#x2F;agent&#x2F;profiler&quot;</span><br></pre></td></tr></table></figure><p>接著在 main.go 写入底下代码即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">profiler.Start(profiler.Config&#123;</span><br><span class="line">    ApplicationName: &quot;simple.golang.app&quot;,</span><br><span class="line">    ServerAddress:   &quot;http:&#x2F;&#x2F;pyroscope:4040&quot;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中 <code>http://pyroscope</code> 可以换成自定义的 hostname 即可，接着打开上述网址就可以看到性能监控的画面了</p><p><img src="https://img.hi-linux.com/staticfile/7hYcxe-2021-04-22-v59IxB.jpg" alt></p><p>通过画面，我们可以快速找到是 SQL 或哪个函式执行时间长。</p><p><img src="https://img.hi-linux.com/staticfile/ChNi8m-2021-04-22-YkkYNt.jpg" alt></p><h3><span id="在-python-和-ruby-语言中使用">在 Python 和 Ruby 语言中使用</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># If using Python</span><br><span class="line">$ pyroscope exec python manage.py runserver </span><br><span class="line"></span><br><span class="line"># If using Ruby</span><br><span class="line">$ pyroscope exec rails server</span><br></pre></td></tr></table></figure><h2><span id="心得">心得</span></h2><p>这套工具相当方便，在 Go 语言虽然可以用 pprof 快速找到问题，但是难免还是需要手动的一些地方才可以查出性能瓶颈，有了这套平台，就可以将全部 App 都进行监控，当使用者有任何问题，就可以快速透过 Pyroscope 查看哪些代码出了问题。</p><blockquote><p>本文转载自：「 小恶魔 」，原文：<a href="http://t.cn/A6c0G3dm%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">http://t.cn/A6c0G3dm，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当网站上线后，流量增加或短暂功能故障，都会造成使用者体验相当不好，而这时该怎么快速找到性能的瓶颈呢？通常 CPU 达到 100% 时，有时候也很难复制及找出关键问题点。&lt;/p&gt;
&lt;p&gt;本篇文章，我们会介绍一套工具叫 Pyroscope，让开发者可以快速找到性能瓶颈的代码。Pyroscope 目前可以支持 Python, Ruby 或 Go 的环境。本文笔者会针对 Go 环境做介绍。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Pyroscope？&quot;&gt;什么是 Pyroscope？&lt;/h2&gt;
&lt;p&gt;Pyroscope 是一套开源的性能即时监控平台，简单的 Server 及 Agent 架构，让开发者可以轻松监控代码性能，不管你要找 10 秒或几分钟内的性能数据，都可以快速的即时呈现，开发者也不用在意装了此监控会造成任何性能上的负担。Pyroscope 背后的储存采用 Badger 这套 Key-Value 数据库，性能上是非常好的。目前只支持 3 种语言 (Python, Ruby 及 Go) 未来会预计支持 NodeJS。假设您还没引入任何性能分析工具或平台，那 Pyroscope 会是您最好的选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Pyroscope" scheme="https://www.hi-linux.com/tags/Pyroscope/"/>
    
  </entry>
  
  <entry>
    <title>推荐两款助你效率提高 10 倍的 Kubernetes 容器日志查看神器</title>
    <link href="https://www.hi-linux.com/posts/43085.html"/>
    <id>https://www.hi-linux.com/posts/43085.html</id>
    <published>2021-06-07T01:00:00.000Z</published>
    <updated>2021-06-07T02:17:23.004Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>通常情况下，在部署了 <code>K8S</code> 服务之后，为了更好地监控服务的运行情况，都会接入对应的日志系统来进行检测和分析，比如常见的 <code>Filebeat + ElasticSearch + Kibana</code> 这一套组合来完成。虽然该组合可以满足我们对于服务监控的要求，但是如果只是部署一个内部单服务用的话，未免显得大材小用，而且部署服务还会带来大量的资源消耗。那么有没有简单查看 <code>K8S</code> 中多个 <code>Pod</code> 中的日志工具呢？咳咳咳，那么今天就介绍两款超好用的多容器实时日志查看工具 <code>Kubetail</code> 和 <code>Stern</code>。</p><a id="more"></a><h2><span id="1-kubetail-工具">1. Kubetail 工具</span></h2><blockquote><p><strong>Bash script to tail Kubernetes logs from multiple pods at the same time</strong></p></blockquote><p><a href="https://github.com/johanhaleby/kubetail" target="_blank" rel="noopener">Kubetail</a> 项目其实是一个简单 <code>Shell</code> 脚本，它可以将多个 <code>Pod</code> 中的日志信息聚合到一起进行展示，并支持彩色输出和条件过滤。</p><p><img src="https://img.hi-linux.com/staticfile/watch-k8s-logs-tools-01-2021-05-29-2NQPv6.png" alt="查看K8S容器日志内容 - Kubetail"></p><h3><span id="11-工具安装">1.1 工具安装</span></h3><blockquote><p><strong>安装非常简单，而且针对不同平台适配不同类型的工具。</strong></p></blockquote><ul><li><strong>Homebrew</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install kubetail using brew</span></span><br><span class="line">$ brew tap johanhaleby/kubetail &amp;&amp; brew install kubetail</span><br></pre></td></tr></table></figure><ul><li><strong>Linux</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># download and to go</span></span><br><span class="line"><span class="comment"># https://github.com/johanhaleby/kubetail/releases</span></span><br><span class="line">$ wget https://raw.githubusercontent.com/johanhaleby/kubetail/master/kubetail</span><br><span class="line">$ chmod +x kubetail</span><br><span class="line">$ cp kubetail /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><ul><li><strong>zsh plugin</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># oh-my-zsh</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/johanhaleby/kubetail.git kubetail</span><br><span class="line"></span><br><span class="line">$ vim ~/.zshrc</span><br><span class="line">plugins=( ... kubetail )</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><h3><span id="12-工具使用">1.2 工具使用</span></h3><blockquote><p><strong>使用起来也非常的简单，短短 2 分钟就可以上手！</strong></p></blockquote><ul><li><strong>示例说明前数据信息准备</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show all your pods</span></span><br><span class="line">$ kubectl get pods -n <span class="built_in">test</span></span><br><span class="line">NAME                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">app1-v1-aba8y          1/1       Running   0          1d</span><br><span class="line">app1-v1-gc4st          1/1       Running   0          1d</span><br><span class="line">app1-v1-m8acl          1/1       Running   0          6d</span><br><span class="line">app1-v1-s20d0          1/1       Running   0          1d</span><br><span class="line">app2-v31-9pbpn         1/1       Running   0          1d</span><br><span class="line">app2-v31-q74wg         1/1       Running   0          1d</span><br><span class="line">my-demo-v5-0fa8o       1/1       Running   0          3h</span><br><span class="line">my-demo-v5-yhren       1/1       Running   0          2h</span><br></pre></td></tr></table></figure><ul><li><strong>介绍了工具的使用方式</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时跟踪两个"app2"的Pod的日志</span></span><br><span class="line">$ kubetail app2</span><br><span class="line">$ kubetail app1,app2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定"app2"的Pod里面的容器名称</span></span><br><span class="line">$ kubetail app2 -c container1</span><br><span class="line">$ kubetail app2 -c container1 -c container2</span><br><span class="line">$ kubetail app2 -c container1 -n namespace1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式</span></span><br><span class="line">$ kubetail <span class="string">"^app1|.*my-demo.*"</span> --regex</span><br></pre></td></tr></table></figure><ul><li><strong>通过使用 <code>-k</code> 参数，您可以指定 <code>kubetail</code> 如何使用颜色</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pod:   只有Pod名称着色且其他输出均使用终端默认颜色</span></span><br><span class="line"><span class="comment"># line:  整行是彩色的(默认)</span></span><br><span class="line"><span class="comment"># false: 所有输出都不着色</span></span><br><span class="line">$ kubetail app2 -k pod</span><br><span class="line">$ kubetail app2 -k line</span><br><span class="line">$ kubetail app2 -k <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><strong>常见命令行参数说明</strong></li></ul><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">命令行参数</th><th style="text-align:left">对应含义解析</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong><code>-n</code></strong></td><td style="text-align:left">指定命名空间的名称</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong><code>-c</code></strong></td><td style="text-align:left">指定多容器 <code>Pod</code> 中的容器具体名称</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong><code>-k</code></strong></td><td style="text-align:left">将输出的日志内容进行着色显示</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong><code>-b</code></strong></td><td style="text-align:left">是否使用 <code>line-buffered</code> 特性，默认为 <code>false</code> 状态</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong><code>-l</code></strong></td><td style="text-align:left">标签过滤器，用于忽略 <code>Pod</code> 名称</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong><code>-t</code></strong></td><td style="text-align:left">指定 <code>Kubeconfig</code> 文件中的 <code>Context</code> 内容</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong><code>-s</code></strong></td><td style="text-align:left">指定返回一个相对时间之后的日志；例如 <code>5s</code>/<code>2m</code>/<code>3h</code>，默认是 <code>10s</code></td></tr></tbody></table><h2><span id="2-stern-工具">2. Stern 工具</span></h2><blockquote><p><strong>Multi pod and container log tailing for Kubernetes</strong></p></blockquote><p><a href="https://github.com/wercker/stern" target="_blank" rel="noopener">Stern</a> 是使用 <code>Go</code> 语言开发的一款开箱即用的简单工具，它可以将多个 <code>Pod</code> 中的日志信息聚合到一起进行展示，并支持彩色输出和条件过滤。需要说的是，改工具已经很久都没有更新过了，所有不建议使用了。</p><p><img src="https://img.hi-linux.com/staticfile/watch-k8s-logs-tools-02-2021-05-29-TeVzd6.png" alt></p><h3><span id="21-工具安装">2.1 工具安装</span></h3><blockquote><p><strong>安装非常简单，而且针对不同平台适配不同类型的工具。</strong></p></blockquote><ul><li><strong>Homebrew</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install kubetail using brew</span></span><br><span class="line">$ brew install stern</span><br></pre></td></tr></table></figure><ul><li><strong>Linux</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># download and to go</span></span><br><span class="line"><span class="comment"># https://github.com/wercker/stern/tags</span></span><br><span class="line">$ wget https://github.com/wercker/stern/releases/download/1.11.0/stern_linux_amd64</span><br><span class="line">$ chmod +x stern_linux_amd64</span><br><span class="line">$ mv stern_linux_amd64 /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><ul><li><strong>zsh plugin</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bash-completion</span></span><br><span class="line">$ brew install bash-completion</span><br><span class="line">$ <span class="built_in">source</span> &lt;(brew --prefix)/etc/bash-completion</span><br><span class="line">$ <span class="built_in">source</span> &lt;(stern --completion=bash)</span><br><span class="line"></span><br><span class="line"><span class="comment"># .zshrc</span></span><br><span class="line">$ <span class="built_in">source</span> &lt;(stern --completion=zsh)</span><br></pre></td></tr></table></figure><h3><span id="22-工具使用">2.2 工具使用</span></h3><blockquote><p><strong>使用起来也非常的简单，短短 2 分钟就可以上手！</strong></p></blockquote><ul><li><strong>示例说明前数据信息准备</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show all your pods</span></span><br><span class="line">$ kubectl get pods -n <span class="built_in">test</span></span><br><span class="line">NAME                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">app1-v1-aba8y          1/1       Running   0          1d</span><br><span class="line">app1-v1-gc4st          1/1       Running   0          1d</span><br><span class="line">app1-v1-m8acl          1/1       Running   0          6d</span><br><span class="line">app1-v1-s20d0          1/1       Running   0          1d</span><br><span class="line">app2-v31-9pbpn         1/1       Running   0          1d</span><br><span class="line">app2-v31-q74wg         1/1       Running   0          1d</span><br><span class="line">my-demo-v5-0fa8o       1/1       Running   0          3h</span><br><span class="line">my-demo-v5-yhren       1/1       Running   0          2h</span><br></pre></td></tr></table></figure><ul><li><strong>介绍了工具的使用方式</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看默认名称空间下的所有Pod日志</span></span><br><span class="line">$ stern  .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod 中指定容器的日志</span></span><br><span class="line">$ stern app2 --container container1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定命名空间中容器的日志</span></span><br><span class="line">$ stern app2 --namespace namespace1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定命名空间中除指定容器外的所有容器的日志</span></span><br><span class="line">$ stern --namespace namespace1 --exclude-container container1 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间范围内容器的日志(15分钟内)</span></span><br><span class="line">$ stern app2 -t --since 15m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有命名空间中符合指定标签容器的日志</span></span><br><span class="line">$ stern --all-namespaces -l run=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找前端Pod中版本为canary的日志</span></span><br><span class="line">$ stern frontend --selector release=canary</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将日志消息通过管道传输到jq命令</span></span><br><span class="line">$ stern backend -o json | jq .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅输出日志消息本身</span></span><br><span class="line">$ stern backend -o raw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义模板输出</span></span><br><span class="line">$ stern --template <span class="string">'&#123;&#123;.Message&#125;&#125; (&#123;&#123;.Namespace&#125;&#125;/&#123;&#123;.PodName&#125;&#125;/&#123;&#123;.ContainerName&#125;&#125;)'</span> backend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用stern提供的颜色的自定义模板输出</span></span><br><span class="line">$ stern --template <span class="string">'&#123;&#123;.Message&#125;&#125; (&#123;&#123;.Namespace&#125;&#125;/&#123;&#123;color .PodColor .PodName&#125;&#125;/&#123;&#123;color .ContainerColor .ContainerName&#125;&#125;)'</span> backend</span><br></pre></td></tr></table></figure><ul><li><strong>常见命令行参数说明</strong></li></ul><table><thead><tr><th style="text-align:left">flag</th><th style="text-align:left">default</th><th style="text-align:left">purpose</th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>--container</code></strong></td><td style="text-align:left"><code>.*</code></td><td style="text-align:left">Container name when multiple containers in pod (regular expression)</td></tr><tr><td style="text-align:left"><strong><code>--exclude-container</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Container name to exclude when multiple containers in pod (regular expression)</td></tr><tr><td style="text-align:left"><strong><code>--container-state</code></strong></td><td style="text-align:left"><code>running</code></td><td style="text-align:left">Tail containers with status in running, waiting or terminated. Default to running.</td></tr><tr><td style="text-align:left"><strong><code>--timestamps</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Print timestamps</td></tr><tr><td style="text-align:left"><strong><code>--since</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Return logs newer than a relative duration like 52, 2m, or 3h. Displays all if omitted</td></tr><tr><td style="text-align:left"><strong><code>--context</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Kubernetes context to use. Default to <code>kubectl config current-context</code></td></tr><tr><td style="text-align:left"><strong><code>--exclude</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Log lines to exclude; specify multiple with additional <code>--exclude</code>; (regular expression)</td></tr><tr><td style="text-align:left"><strong><code>--namespace</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Kubernetes namespace to use. Default to namespace configured in Kubernetes context</td></tr><tr><td style="text-align:left"><strong><code>--kubeconfig</code></strong></td><td style="text-align:left"><code>~/.kube/config</code></td><td style="text-align:left">Path to kubeconfig file to use</td></tr><tr><td style="text-align:left"><strong><code>--all-namespaces</code></strong></td><td style="text-align:left"></td><td style="text-align:left">If present, tail across all namespaces. A specific namespace is ignored even if specified with –namespace.</td></tr><tr><td style="text-align:left"><strong><code>--selector</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Selector (label query) to filter on. If present, default to <code>.*</code> for the pod-query.</td></tr><tr><td style="text-align:left"><strong><code>--tail</code></strong></td><td style="text-align:left"><code>-1</code></td><td style="text-align:left">The number of lines from the end of the logs to show. Defaults to -1, showing all logs.</td></tr><tr><td style="text-align:left"><strong><code>--color</code></strong></td><td style="text-align:left"><code>auto</code></td><td style="text-align:left">Force set color output. <code>auto</code>: colorize if tty attached, <code>always</code>: always colorize, <code>never</code>: never colorize</td></tr><tr><td style="text-align:left"><strong><code>--output</code></strong></td><td style="text-align:left"><code>default</code></td><td style="text-align:left">Specify predefined template. Currently support: [default, raw, json] See templates section</td></tr><tr><td style="text-align:left"><strong><code>template</code></strong></td><td style="text-align:left"></td><td style="text-align:left">Template to use for log lines, leave empty to use –output flag</td></tr></tbody></table><h2><span id="3-参考链接地址">3. 参考链接地址</span></h2><ul><li><a href="https://github.com/johanhaleby/kubetail" target="_blank" rel="noopener">johanhaleby/kubetail</a></li><li><a href="https://github.com/wercker/stern" target="_blank" rel="noopener">wercker/stern</a></li><li><a href="https://www.hi-linux.com/posts/14566.html">两款超好用的 Kubernetes 实时日志查看工具</a></li></ul><blockquote><p>本文转载自：「  Ecsape 的博客 」，原文：<a href="https://tinyurl.com/euu7396c" target="_blank" rel="noopener">https://tinyurl.com/euu7396c</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常情况下，在部署了 &lt;code&gt;K8S&lt;/code&gt; 服务之后，为了更好地监控服务的运行情况，都会接入对应的日志系统来进行检测和分析，比如常见的 &lt;code&gt;Filebeat + ElasticSearch + Kibana&lt;/code&gt; 这一套组合来完成。虽然该组合可以满足我们对于服务监控的要求，但是如果只是部署一个内部单服务用的话，未免显得大材小用，而且部署服务还会带来大量的资源消耗。那么有没有简单查看 &lt;code&gt;K8S&lt;/code&gt; 中多个 &lt;code&gt;Pod&lt;/code&gt; 中的日志工具呢？咳咳咳，那么今天就介绍两款超好用的多容器实时日志查看工具 &lt;code&gt;Kubetail&lt;/code&gt; 和 &lt;code&gt;Stern&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂 DevOps 和 SRE 的区别</title>
    <link href="https://www.hi-linux.com/posts/38404.html"/>
    <id>https://www.hi-linux.com/posts/38404.html</id>
    <published>2021-06-04T01:00:00.000Z</published>
    <updated>2021-06-04T06:15:16.306Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="devops-和-sre">DevOps 和 SRE</span></h2><p>最近有一位朋友和我聊职业发展方向问题，聊了不少 DevOps 和 SRE 话题。 我几年前刚接触这两个概念时也常常将之混淆，可惜当时没有人来解答我困惑。 现在这虽然已经极为流行，但是我发现我这位朋友对这两个职位还存在一些误区。 于是我给了一些见解并整理成文章以饕大众。</p><p>最常见的误区：</p><ul><li>DevOps 新概念，好高级哦</li><li>SRE 是高级版 DevOps</li><li>运维可以轻松转身 DevOps 工程师</li></ul><h2><span id="devops-和-sre-定义">DevOps 和 SRE 定义</span></h2><p>DevOps 是字面上 Dev 开发 / Ops 运维两者组合， 严格意义上 DevOps 如下（via DevOps - Wikipedia）：</p><blockquote><p>DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev） ”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。</p></blockquote><p>SRE 全称是 Site Reliability Engineering，最早是由 Google 提出，并且在其工程实践中发扬光大。 他们还出了一本同名书籍「Site Reliability Engineering」， 让这个理念在互联网工程师圈子里广泛传播。</p><p>Google 对 SRE 解释是（via Site Reliability Engineering - Wikipedia）：</p><blockquote><p>Site reliability engineering (SRE) is a discipline that incorporates aspects of software engineering and applies that to operations whose goals are to create ultra-scalable and highly reliable software systems.</p></blockquote><p>我将其翻译翻译为中文：</p><blockquote><p>网站稳定性工程师是致力于打造「高扩展、高可用系统」，并将其贯彻为原则的软件工程师。</p></blockquote><p>从定义来看，DevOps 是文化、运动和惯例，而 SRE 是有严格任职要求的职位。 文化是软性定义，文化有更多概念可以捏造，而 SRE 定义精准，就少了想象空间（也可能 SRE 门槛高 ）。 按 Google 给出的说法是，SRE 工程师实践了 DevOps 文化。这个观点没错，但是国内的 DevOps 逐步独立出 DevOps 工程师， 所以在本文，我着重讨论的是 DevOps 工程师和 SRE 工程师两种职位对比。</p><a id="more"></a><h2><span id="两者产生背景和历史">两者产生背景和历史</span></h2><p>互联网需求催生了 DevOps 。在最传统软件企业中，是只有 Dev 没有 Ops， 那时 Ops 可能还是只是技术支持人员。开发按照瀑布流：需求分析、系统设计、开发、测试、交付、运行， 传统软件发布是一个重量级操作。一旦发布，Dev 几乎不再直接操作。 80 后可能会记得 QQ 每年都会有一个大版本发布吧，QQ 2000 / 2003 / 2004 等等。 此时 Ops 不用和 Dev 直接高频接触，甚至针对一些纯离线业务，压根没有设立 Ops 这个岗位。</p><p>互联网浪潮之后，软件由传统意义上桌面软件演变为面向网站、手机应用。 这时候业务核心逻辑，比如交易，社交行为都不在用户桌面完成，而是在服务器后端完成。 这给互联网企业给予了极大操作空间：随时可以改变业务逻辑，这促进了业务快速迭代变更。 但即便这样，Dev 和 Ops 是极其分裂的两个环节。Ops 不关心代码是如何运作的，Dev 不知道代码如何运行在服务器上。</p><p>当业界还沉浸在可以每周发布版本喜悦中时，2009 年，Flicker 提出了每天发布 10+ 次概念，大大震撼了业界。 Flicker 提出了几个核心理念：</p><ul><li>业务快速发展，需要拥抱变更，小步快跑</li><li>Ops 目标不是为了网站稳定和快速，而是推动业务快速发展</li><li>基于自动化工具提高 Dev / Ops 联接：代码版本管理、监控</li><li>高效沟通：IRC / IM Robot（现在那些 ChatBot 套路，10 年前就被 Flicker 玩过了）</li><li>信任、透明、高效、互助的沟通文化</li></ul><p>真是让人难以想象，今天各种培训公司和一些知名大 V 在呼唤这些 DevOps 理念， 竟然在 2009 年一份幻灯片中就展现淋漓尽致。经典总是不过时，在尘封下闪耀着智慧光芒。 有些人将 DevOps 和运维自动化等同，这是只看到表象。 DevOps 目标是提高业务系统交付速度，并为之提供相关工具、制度和服务。 一些个人或培训机构添油加醋和衍生含义，都是围绕这 DevOps 本质而发散。</p><p>接下来聊聊 SRE 历史， SRE 出现要晚一些。在 2003 年时候 Google 的 Ben Treynor 招募了几个软件工程师，这个团队设立目的是帮助 Google 生产环境服务运行更稳定、健壮、可靠。 不同于中小型规模公司，Google 服务于十几亿用户服务，短暂服务不可用会带来致命后果。 因此 Google 走在了时代最前面，SRE 产生了。 这个职位为大规模集群服务，小型团队不需要这样职位设定（可能也招不起真正 SRE ）。 Google 在探索若干年之后，SRE 团队开始将自己心得体会写在线上，并在 2016 年将此书出版。</p><h2><span id="两者的职能不同">两者的职能不同</span></h2><p>现在不少公司将 DevOps 职能单独抽取出来，称之为 DevOps 工程师。 那让我们看看 DevOps 工程师关心什么：DevOps 文化目的是提交交付速度， DevOps 工程师就自然会关心软件 / 服务的整个生命周期。 一个简单的公式：速度 = 总量 / 时间，添上工程行业术语，即 交付速度 = （（功能特性 * 工程质量） / 交付时间） * 交付风险。</p><p>功能特性交给产品经理和项目经理管理，DevOps 工程师需要关心剩下几个因素：工程质量 / 交付时间 / 交付风险。 DevOps 工程师职能如下：</p><ul><li>管理应用全生命周期（需求、设计、开发、QA、发布、运行）</li><li>关注全流程效率提升，挖掘瓶颈点并将其解决</li><li>自动化运维平台设计和研发工作（标准化、自动化、平台化）</li><li>支持运维系统，包括 虚拟化技术、资源管理技术、监控技术、网络技术</li></ul><p>SRE 关键词是「高扩展性」「高可用性」。高扩展性是指当服务用户数量暴增时， 应用系统以及支撑其服务（服务器资源、网络系统、数据库资源）可以在不调整系统结构，不强化机器本身性能 ，仅仅增加实例数量方式进行扩容。高可用性是指，应用架构中任何环节出现不可用时，比如应用服务、网关、数据库 等系统挂掉，整个系统可以在可预见时间内恢复并重新提供服务。当然，既然是「高」可用， 那么这个时间一般期望在分钟级别。SRE 职能可以概括为以下：</p><ul><li>为 应用、中间件、基础设施等提供 选型、设计、开发、容量规划、调优、故障处理</li><li>为业务系统提供基于可用性、可扩展性考虑决策，参与业务系统设计和实施</li><li>定位、处理、管理故障，优化导致故障发生相关部件</li><li>提高各部件资源利用率</li></ul><h2><span id="工作内容不同">工作内容不同</span></h2><p>职责不同导致两个职位工作内容也不尽相同，我将 DevOps 工程师和 SRE 工程师职能列举如下：</p><ul><li><p>DevOps</p><ul><li>设定应用生命管理周期制度，扭转流程</li><li>开发、管理 开发工程师 /QA 工程师使用 开发平台系统</li><li>开发、管理 发布系统</li><li>开发、选型、管理 监控、报警系统</li><li>开发、管理 权限系统</li><li>开发、选型、管理 CMBD</li><li>管理变更</li><li>管理故障</li></ul></li><li><p>SRE</p><ul><li>管理变更</li><li>管理故障</li><li>制定 SLA 服务标准</li><li>开发、选型、管理 各类中间件</li><li>开发、管理 分布式监控系统</li><li>开发、管理 分布式追踪系统</li><li>开发、管理 性能监控、探测系统（dtrace、火焰图）</li><li>开发、选型、培训 性能调优工具</li></ul></li></ul><p>很有趣的对比，DevOps 和 SRE 都会关心应用生命周期，特别是生命周期里面的变更和故障。 但是 DevOps 工作内容是主要为开发链路服务，一个 DevOps Team 通常会提供一串工具链， 这其中会包括：开发工具、版本管理工具、CI 持续交付工具、CD 持续发布工具、报警工具、故障处理。 而 SRE Team 则关注更为关注变更、故障、性能、容量相关问题，会涉及具体业务，产出工具链会有： 容量测量工具、Logging 日志工具、Tracing 调用链路跟踪工具、Metrics 性能度量工具、监控报警工具等。</p><h2><span id="devops-和-sre-关系">DevOps 和 SRE 关系</span></h2><p>DevOps 首先是一种文化，后期逐渐独立成一个职位；SRE 一开始就明确是一个职位； 不少同学把 DevOps 和 SRE 搞混，是被两者表象锁迷惑，看上去这两者都有的工具属性、自动化要求也相似。 甚至有一些开发同学把这类运维工作都统一理解为：服务器 + 工具 + 自动化。这是盲人摸象，管中窥豹。</p><p>从技能上来说，两者都需要较强的运维技能。 在职业发展天花板上，DevOps 可能缺乏 SRE 在一些专业领域的技能： 计算机体系结构能力；高吞吐高并发优化能力；可扩展系统设计能力；复杂系统设计能力；业务系统排查能力。 两者都需要软实力，但是 SRE 面临复杂度更高，挑战更大，要求也更高：</p><p>DevOps 具有普遍意义，现代互联网公司都需要 DevOps，但是并非所有团队对高可用性、高扩展性存在需求，它们不需要 SRE。 DevOps 工程师掌握相关技能之后，也有机会可以发展为 SRE 工程师。 而一位合格 SRE 工程师，在有选择情况下面，我相信不会去转型为 DevOps 工程师。</p><p>从专业背景来看，无论是 DevOps 还是 SRE 工程师，都需要研发背景，前者需要开发工具链，后者需要有较强架构设计经验。 如果有运维工程师想转型成为 DevOps 或者 SRE，那么需要补上相关技术知识。 毕竟，不是会搭建一套 Jenkins + Kubernetes 就可以自称为 DevOps / SRE 工程师。</p><p>怎么样，有没有解开这几个常见误区呢？希望你看到这里可以豁然开朗，最后附上两个工程师的技能点， 期望有志成为这两种工程师的同学，加油努力。</p><h2><span id="附录技能点">附录：技能点</span></h2><p>DevOps：</p><ul><li><p>Operator 技能</p><ul><li><p>Linux Basis</p><ul><li>基本命令操作</li><li>Linux FHS（Filesystem Hierarchy Standard 文件系统层次结构标准）</li><li>Linux 系统（差异、历史、标准、发展）</li></ul></li><li><p>脚本</p><ul><li>Bash / Python</li></ul></li><li><p>基础服务</p><ul><li>DHCP / NTP / DNS / SSH / iptables / LDAP / CMDB</li></ul></li><li><p>自动化工具</p><ul><li>Fabric / Saltstack / Chef / Ansible</li></ul></li><li><p>基础监控工具</p><ul><li>Zabbix / Nagios / Cacti</li></ul></li><li><p>虚拟化</p><ul><li>KVM 管理 / XEN 管理 / vSphere 管理 / Docker</li><li>容器编排 / Mesos / Kubernetes</li></ul></li><li><p>服务</p><ul><li>Nginx / F5 / HAProxy / LVS 负载均衡</li><li>常见中间件 Operate（启动、关闭、重启、扩容）</li></ul></li></ul></li><li><p>Dev</p><ul><li><p>语言</p><ul><li>Python</li><li>Go（可选）</li><li>Java（了解部署）</li></ul></li><li><p>流程和理论</p><ul><li>Application Life Cycle</li><li>12 Factor</li><li>微服务概念、部署、生命周期</li><li>CI 持续集成 / Jenkins / Pipeline / Git Repo Web Hook</li><li>CD 持续发布系统</li></ul></li><li><p>基础设施</p><ul><li>Git Repo / Gitlab / Github</li><li>Logstash / Flume 日志收集</li><li>配置文件管理（应用、中间件等）</li><li>Nexus / JFrog / Pypi 包依赖管理</li><li>面向 开发 / QA 开发环境管理系统</li><li>线上权限分配系统</li><li>监控报警系统</li><li>基于 Fabric / Saltstack / Chef / Ansible 自动化工具开发</li></ul></li></ul></li></ul><p>SRE：</p><ul><li><p>语言和工程实现</p><ul><li><p>深入理解开发语言（假设是 Java）</p><ul><li>业务部门使用开发框架</li><li>并发、多线程和锁</li><li>资源模型理解：网络、内存、CPU</li><li>故障处理能力（分析瓶颈、熟悉相关工具、还原现场、提供方案）</li></ul></li><li><p>常见业务设计方案和陷阱（比如 Business Modeling，N+1、远程调用、不合理 DB 结构）</p></li><li><p>MySQL / Mongo OLTP 类型查询优化</p></li><li><p>多种并发模型，以及相关 Scalable 设计</p></li></ul></li><li><p>问题定位工具</p><ul><li>容量管理</li><li>Tracing 链路追踪</li><li>Metrics 度量工具</li><li>Logging 日志系统</li></ul></li><li><p>运维架构能力</p><ul><li>Linux 精通，理解 Linux 负载模型，资源模型</li><li>熟悉常规中间件（MySQL Nginx Redis Mongo ZooKeeper 等），能够调优</li><li>Linux 网络调优，网络 IO 模型以及在语言里面实现</li><li>资源编排系统（Mesos / Kubernetes）</li></ul></li><li><p>理论</p><ul><li>容量规划方案</li><li>熟悉分布式理论（Paxos / Raft / BigTable / MapReduce / Spanner 等），能够为场景决策合适方案</li><li>性能模型（比如 Pxx 理解、Metrics、Dapper）</li><li>资源模型（比如 Queuing Theory、负载方案、雪崩问题）</li><li>资源编排系统（Mesos / Kurbernetes）</li></ul></li></ul><blockquote><p>本文转载自：「 知乎 」，原文：<a href="https://tinyurl.com/fbjbzcn4" target="_blank" rel="noopener">https://tinyurl.com/fbjbzcn4</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DevOps-和-SRE&quot;&gt;DevOps 和 SRE&lt;/h2&gt;
&lt;p&gt;最近有一位朋友和我聊职业发展方向问题，聊了不少 DevOps 和 SRE 话题。 我几年前刚接触这两个概念时也常常将之混淆，可惜当时没有人来解答我困惑。 现在这虽然已经极为流行，但是我发现我这位朋友对这两个职位还存在一些误区。 于是我给了一些见解并整理成文章以饕大众。&lt;/p&gt;
&lt;p&gt;最常见的误区：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DevOps 新概念，好高级哦&lt;/li&gt;
&lt;li&gt;SRE 是高级版 DevOps&lt;/li&gt;
&lt;li&gt;运维可以轻松转身 DevOps 工程师&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;DevOps-和-SRE-定义&quot;&gt;DevOps 和 SRE 定义&lt;/h2&gt;
&lt;p&gt;DevOps 是字面上 Dev 开发 / Ops 运维两者组合， 严格意义上 DevOps 如下（via DevOps - Wikipedia）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev） ”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SRE 全称是 Site Reliability Engineering，最早是由 Google 提出，并且在其工程实践中发扬光大。 他们还出了一本同名书籍「Site Reliability Engineering」， 让这个理念在互联网工程师圈子里广泛传播。&lt;/p&gt;
&lt;p&gt;Google 对 SRE 解释是（via Site Reliability Engineering - Wikipedia）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Site reliability engineering (SRE) is a discipline that incorporates aspects of software engineering and applies that to operations whose goals are to create ultra-scalable and highly reliable software systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我将其翻译翻译为中文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网站稳定性工程师是致力于打造「高扩展、高可用系统」，并将其贯彻为原则的软件工程师。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从定义来看，DevOps 是文化、运动和惯例，而 SRE 是有严格任职要求的职位。 文化是软性定义，文化有更多概念可以捏造，而 SRE 定义精准，就少了想象空间（也可能 SRE 门槛高 ）。 按 Google 给出的说法是，SRE 工程师实践了 DevOps 文化。这个观点没错，但是国内的 DevOps 逐步独立出 DevOps 工程师， 所以在本文，我着重讨论的是 DevOps 工程师和 SRE 工程师两种职位对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DevOps" scheme="https://www.hi-linux.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>最 COOL 的 Kubernetes 网络方案 CILIUM 入门教程</title>
    <link href="https://www.hi-linux.com/posts/60044.html"/>
    <id>https://www.hi-linux.com/posts/60044.html</id>
    <published>2021-06-03T01:00:00.000Z</published>
    <updated>2021-06-04T06:19:36.391Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>最近业界使用范围最广的K8S CNI网络方案<a href="https://www.projectcalico.org/introducing-the-calico-ebpf-dataplane/" target="_blank" rel="noopener">Calico宣布支持eBPF</a>，而作为第一个通过 eBPF 实现了 kube-proxy 所有功能的 K8S 网络方案——Cilium，它的先见之名是否能转成优势，继而成为 CNI 新的头牌呢？今天我们一起来入门最 Cool Kubernetes 网络方案 Cilium。</p></blockquote><h2><span id="cilium介绍">Cilium介绍</span></h2><blockquote><p>以下基于<a href="https://cilium.readthedocs.io/en/stable/" target="_blank" rel="noopener">Cilium官网文档</a>翻译整理。</p></blockquote><h3><span id="当前趋势">当前趋势</span></h3><p>现代数据中心的应用系统已经逐渐转向基于微服务架构的开发体系，一个微服务架构的应用系统是由多个小的独立的服务组成，它们之间通过轻量通信协议如 HTTP、gRPC、Kafka 等进行通信。微服务架构下的服务天然具有动态变化的特点，结合容器化部署，时常会引起大规模的容器实例启动或重启。要确保这种向高度动态化的微服务应用之间的安全可达，既是挑战，也是机遇。</p><h3><span id="现有问题">现有问题</span></h3><p>传统的 Linux 网络访问安全控制机制（如 iptables）是基于静态环境的IP地址和端口配置网络转发、过滤等规则，但是 IP 地址在微服务架构下是不断变化的，非固定的；出于安全目的，协议端口(例如 HTTP 传输的 TCP 端口 80)也不再固定用来区分应用系统。为了匹配大规模容器实例快速变化的生命周期，传统网络技术需要维护成千上万的负载均衡规则和访问控制规则，并且需要以不断增长的频率更新这些规则，而如果没有准确的可视化功能，要维护这些规则也是十分困难，这些对传统网络技术的可用性和性能都是极大的挑战。比如经常会有人对 kube-proxy 基于 iptables 的服务负载均衡功能在大规模容器场景下具有严重的性能瓶颈，同时由于容器的创建和销毁非常频繁，基于 IP 做身份关联的故障排除和安全审计等也很难实现。</p><a id="more"></a><h3><span id="解决方案">解决方案</span></h3><p>Cilium 作为一款 Kubernetes CNI 插件，从一开始就是为大规模和高度动态的容器环境而设计，并且带来了 API 级别感知的网络安全管理功能，通过使用基于 Linux 内核特性的新技术——<a href="https://docs.cilium.io/en/stable/bpf/" target="_blank" rel="noopener">BPF</a>，提供了基于 service/pod/container 作为标识，而非传统的 IP 地址，来定义和加强容器和 Pod 之间网络层、应用层的安全策略。因此，Cilium 不仅将安全控制与寻址解耦来简化在高度动态环境中应用安全性策略，而且提供传统网络第 3 层、4 层隔离功能，以及基于 http 层上隔离控制，来提供更强的安全性隔离。</p><p>另外，由于 BPF 可以动态地插入控制 Linux 系统的程序，实现了强大的安全可视化功能，而且这些变化是不需要更新应用代码或重启应用服务本身就可以生效，因为 BPF 是运行在系统内核中的。</p><p>以上这些特性，使 Cilium 能够在大规模容器环境中也具有高度可伸缩性、可视化以及安全性。</p><p><img src="https://img.hi-linux.com/staticfile/cilium-arch2020-1024x584-2021-05-29-H9lm7N.png" alt></p><h2><span id="部署-cilium">部署 Cilium</span></h2><p>部署 Cilium 非常简单，可以通过单独的 yaml 文件部署全部组件（目前我使用了这个方式部署了1.7.1 版本），也可以通过 helm chart 一键完成。重要的是部署环境和时机：</p><ol><li><p>官方建议所有部署节点都使用 Linux 最新稳定内核版本，这样所有的功能都能启用，具体部署环境建议可以参照<a href="https://cilium.readthedocs.io/en/stable/install/system_requirements/" target="_blank" rel="noopener">这里</a>。</p></li><li><p>作为一个 Kubernetes 网络组件，它应该在部署 Kubernetes 其他基础组件之后，才进行部署。这里，我自己遇到的问题是，因为还没有 CNI 插件，coredns 组件的状态一直是 pending的，直到部署完 Cilium 后，coredns 完成了重置变成running状态。</p></li></ol><p>下图是 Cilium 的整体部署组件图：</p><p><img src="https://img.hi-linux.com/staticfile/cilium-provision-2021-05-29-mP4svg.png" alt></p><h2><span id="测试安装效果">测试安装效果</span></h2><p>官方提供了一个<a href="https://github.com/cilium/cilium/blob/master/examples/kubernetes/connectivity-check/connectivity-check.yaml" target="_blank" rel="noopener">connectivity检查工具</a>，以检测部署好的 Cilium 是否工作正常。如果你的网络环境有些限制，我作了一些简单修改，可以参照<a href="https://github.com/nevermosby/K8S-CNI-Cilium-Tutorial/blob/master/cilium/connectivity-check.yaml" target="_blank" rel="noopener">这里</a>。部署起来很简单，请确保至少有两个可用的节点，否则有几个 deployment 会无法成功运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl apply -f connectivity-check.yaml</span><br><span class="line"></span><br><span class="line">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">echo-a                                  1&#x2F;1     1            1           16d</span><br><span class="line">echo-b                                  1&#x2F;1     1            1           16d</span><br><span class="line">host-to-b-multi-node-clusterip          1&#x2F;1     1            1           16d</span><br><span class="line">host-to-b-multi-node-headless           1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a                                1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a-allowed-cnp                    1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a-external-1111                  1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a-l3-denied-cnp                  1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-b-intra-node                     1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-b-multi-node-clusterip           1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-b-multi-node-headless            1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-external-fqdn-allow-google-cnp   1&#x2F;1     1            1           16d</span><br></pre></td></tr></table></figure><p>如果所有的 deployment 都能成功运行起来，说明 Cilium 已经成功部署并工作正常。</p><p><img src="https://img.hi-linux.com/staticfile/draggedimage-13-2021-05-29-wnSUP8.png" alt></p><h2><span id="网络可视化神器-hubble">网络可视化神器 Hubble</span></h2><p>上文提到了 Cilium 强大之处就是提供了简单高效的网络可视化功能，它是通过<a href="https://github.com/cilium/hubble" target="_blank" rel="noopener">Hubble</a>组件完成的。<a href="https://cilium.io/blog/2019/11/19/announcing-hubble" target="_blank" rel="noopener">Cilium在1.7版本后推出并开源了Hubble</a>，它是专门为网络可视化设计，能够利用 Cilium 提供的 eBPF 数据路径，获得对 Kubernetes 应用和服务的网络流量的深度可见性。这些网络流量信息可以对接 Hubble CLI、UI 工具，可以通过交互式的方式快速诊断如与 DNS 相关的问题。除了 Hubble 自身的监控工具，还可以对接主流的云原生监控体系—— Prometheus 和  Grafana，实现可扩展的监控策略。</p><p><img src="https://img.hi-linux.com/staticfile/hubble_arch-2021-05-29-Z4N8xr.png" alt></p><p><img src="https://cilium.io/static/hubble-arch-aa2f9af8628edc26f6c8473854d97a8a-50393.png" alt></p><h3><span id="部署-hubble-和-hubble-ui">部署 Hubble 和 Hubble UI</span></h3><p>官方提供了基于 Helm Chart 部署方式，这样可以灵活控制部署变量，实现不同监控策略。出于想要试用 hubble UI 和对接 Grafana，我是这样的部署的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; helm template hubble \</span><br><span class="line">    --namespace kube-system \</span><br><span class="line">    --set metrics.enabled&#x3D;&quot;&#123;dns:query;ignoreAAAA;destinationContext&#x3D;pod-short,drop:sourceContext&#x3D;pod;destinationContext&#x3D;pod,tcp,flow,port-distribution,icmp,http&#125;&quot; \</span><br><span class="line">    --set ui.enabled&#x3D;true \</span><br><span class="line">    &gt; hubble.yaml</span><br><span class="line">&gt; kubectl apply -f hubble.yaml</span><br><span class="line"># 包含两个组件</span><br><span class="line"># - daemonset hubble</span><br><span class="line"># - deployment hubble UI</span><br><span class="line">&gt; kubectl get pod -n kube-system |grep hubble</span><br><span class="line">hubble-67ldp                       1&#x2F;1     Running   0          21h</span><br><span class="line">hubble-f287p                       1&#x2F;1     Running   0          21h</span><br><span class="line">hubble-fxzms                       1&#x2F;1     Running   0          21h</span><br><span class="line">hubble-tlq64                       1&#x2F;1     Running   1          21h</span><br><span class="line">hubble-ui-5f9fc85849-hkzkr         1&#x2F;1     Running   0          15h</span><br><span class="line">hubble-vpxcb                       1&#x2F;1     Running   0          21h</span><br></pre></td></tr></table></figure><h3><span id="运行效果">运行效果</span></h3><p>由于默认的 Hubble UI 只提供了 ClusterIP 类似的 service，无法通过外部访问。因此需要创建一个 NodePort 类型的 service，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># hubble-ui-nodeport-svc.yaml</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  name: hubble-ui-np</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: hubble-ui</span><br><span class="line">  ports:</span><br><span class="line">    - name: http</span><br><span class="line">      port: 12000</span><br><span class="line">      nodePort: 32321</span><br><span class="line">  type: NodePort</span><br></pre></td></tr></table></figure><p>执行 <code>kubectl apply -f hubble-ui-nodeport-svc.yaml</code>，就可以通过任意集群节点 IP 地址加上 32321 端口访问 Hubble UI 的 web 服务了。打开效果如下所示：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-000-2021-05-29-tnYtAT.png" alt></p><ul><li>页面上半部分是之前部署的一整套 conectivity-check 组件的数据流向图，官方叫做 <code>Service Map</code>，默认情况下可以自动发现基于网络 3 层和 4 层的访问依赖路径，看上去非常 cool，也有点分布式链路追踪图的感觉。点击某个服务，还能看到更为详细的关系图：</li></ul><p><img src="https://img.hi-linux.com/staticfile/service-map-ex001-2021-05-29-fFJ0Ts.png" alt></p><ul><li>下图是 kube-system 命名空间下的数据流图，能看到 Hubble-UI 组件和 Hubble 组件是通过gRPC 进行通信的，非常有趣。但令人感到的好奇的是，为何没有显示 Kubernetes 核心组件之间的调用关系图:</li></ul><p><img src="https://img.hi-linux.com/staticfile/draggedimage-1-1-2021-05-29-za8OnA.png" alt></p><p>页面的下半部分默认显示的是对于每条数据流路径的详细描述，包括发起请求的 pod 名称、发起请求的 service 名称、请求目标的 pod 名称、请求目标的 service 名称、目标 IP、目标端口、目标 7 层信息、请求状态、最后一次查看时间等，如下图所示：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-flow-000-2021-05-29-HqW2Pi.png" alt></p><p>点击任意一条 flow，可以查看到更多详细信息：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-flow-001-2021-05-29-11nSZ4.png" alt></p><p>页面的下半部分可以通过点击切换成显示 network policy 模式，列出了当前命名空间下所有的网络策略：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-policy-000-2021-05-29-HRJMNo.png" alt></p><p>如果想开启网络 7 层的可视化观察，就需要对目标 pod 进行 annotations ，感兴趣可以看<a href="http://docs.cilium.io/en/stable/policy/visibility/" target="_blank" rel="noopener">这里</a>，就不在入门篇详述了。</p><p>这样的网络可视化是不是你梦寐以求的，绝对能在排查请求调用问题的时候帮上大忙。</p><h3><span id="对接-grafana-prometheus">对接 Grafana + Prometheus</span></h3><p>如果你跟一样是 Grafana+ Prometheus 的忠实粉丝，那么使 Hubble 对接它们就是必然操作了。仔细的同学已经发现之前 helm template 的玄机了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--set metrics.enabled&#x3D;&quot;&#123;dns:query;ignoreAAAA;destinationContext&#x3D;pod-short,drop:sourceContext&#x3D;pod;destinationContext&#x3D;pod,tcp,flow,port-distribution,icmp,http&#125;&quot;</span><br><span class="line"># 上面的设置，表示开启了 hubble 的 metrics 输出模式，并输出以上这些信息。</span><br><span class="line"># 默认情况下，Hubble daemonset 会自动暴露 metrics API 给 Prometheus。</span><br></pre></td></tr></table></figure><p>你可以对接现有的 Grafana+Prometheus 服务，也可以部署一个简单的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下面的命令会在命名空间 cilium-monitoring 下部署一个 Grafana 服务和 Prometheus 服务</span><br><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;cilium&#x2F;cilium&#x2F;v1.6&#x2F;examples&#x2F;kubernetes&#x2F;addons&#x2F;prometheus&#x2F;monitoring-example.yaml</span><br><span class="line"># 创建对应 NodePort Service，方便外部访问 web 服务</span><br><span class="line">$ kubectl expose deployment&#x2F;grafana --type&#x3D;NodePort --port&#x3D;3000 --name&#x3D;gnp -n cilium-monitoring </span><br><span class="line">$ kubectl expose deployment&#x2F;prometheus --type&#x3D;NodePort --port&#x3D;9090 --name&#x3D;pnp -n cilium-monitoring</span><br></pre></td></tr></table></figure><p>完成部署后，打开 Grafana 网页，导入官方制作的<a href="https://github.com/cilium/hubble/blob/master/tutorials/deploy-hubble-and-grafana/grafana.json" target="_blank" rel="noopener">dashboard</a>，可以快速创建基于 Hubble 的 metrics 监控。等待一段时间，就能在 Grafana 上看到数据了：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-grafana-000-2021-05-29-trvJCq.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/hubble-grafana-001-2021-05-29-sF10Ae.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/hubble-grafana-002-2021-05-29-a0lhJn.png" alt></p><p>Cilium 配合 Hubble，的确非常好用！</p><h2><span id="取代-kube-proxy-组件">取代 kube-proxy 组件</span></h2><p>Cilium 另外一个很大的宣传点是宣称已经全面实现kube-proxy的功能，包括 <code>ClusterIP</code>, <code>NodePort</code>, <code>ExternalIPs</code> 和 <code>LoadBalancer</code>，可以完全取代它的位置，同时提供更好的性能、可靠性以及可调试性。当然，这些都要归功于 eBPF 的能力。</p><p>官方文档中提到，如果你是在先有 kube-proxy 后部署的 Cilium，那么他们是一个 “共存” 状态，Cilium 会根据节点操作系统的内核版本来决定是否还需要依赖 kube-proxy 实现某些功能，可以通过以下手段验证是否能停止 kube-proxy 组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 检查 Cilium 对于取代 kube-proxy 的状态</span><br><span class="line">&gt; kubectl exec -it -n kube-system [Cilium-agent-pod] -- cilium status | grep KubeProxyReplacement</span><br><span class="line"># 默认是 Probe 状态</span><br><span class="line"># 当 Cilium agent 启动并运行，它将探测节点内核版本，判断 BPF 内核特性的可用性，</span><br><span class="line"># 如果不满足，则通过依赖 kube-proxy 来补充剩余的 Kubernetess，</span><br><span class="line"># 并禁用 BPF 中的一部分功能</span><br><span class="line">KubeProxyReplacement:   Probe   [NodePort (SNAT, 30000-32767), ExternalIPs, HostReachableServices (TCP, UDP)]</span><br><span class="line"># 查看 Cilium 保存的应用服务访问列表</span><br><span class="line"># 有了这些信息，就不需要 kube-proxy 进行中转了</span><br><span class="line">&gt; kubectl exec -it -n kube-system [Cilium-agent-pod] -- cilium service list</span><br><span class="line">ID   Frontend              Service Type   Backend</span><br><span class="line">1    10.96.0.10:53         ClusterIP      1 &#x3D;&gt; 100.64.0.98:53</span><br><span class="line">                                          2 &#x3D;&gt; 100.64.3.65:53</span><br><span class="line">2    10.96.0.10:9153       ClusterIP      1 &#x3D;&gt; 100.64.0.98:9153</span><br><span class="line">                                          2 &#x3D;&gt; 100.64.3.65:9153</span><br><span class="line">3    10.96.143.131:9090    ClusterIP      1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">4    10.96.90.39:9090      ClusterIP      1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">5    0.0.0.0:32447         NodePort       1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">6    10.1.1.179:32447      NodePort       1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">7    100.64.0.74:32447     NodePort       1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">8    10.96.190.1:80        ClusterIP</span><br><span class="line">9    10.96.201.51:80       ClusterIP</span><br><span class="line">10   10.96.0.1:443         ClusterIP      1 &#x3D;&gt; 10.1.1.171:6443</span><br><span class="line">                                          2 &#x3D;&gt; 10.1.1.179:6443</span><br><span class="line">                                          3 &#x3D;&gt; 10.1.1.188:6443</span><br><span class="line">11   10.96.129.193:12000   ClusterIP      1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">12   0.0.0.0:32321         NodePort       1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">13   10.1.1.179:32321      NodePort       1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">14   100.64.0.74:32321     NodePort       1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">15   10.96.0.30:3000       ClusterIP</span><br><span class="line">16   10.96.156.253:3000    ClusterIP</span><br><span class="line">17   100.64.0.74:31332     NodePort</span><br><span class="line">18   0.0.0.0:31332         NodePort</span><br><span class="line">19   10.1.1.179:31332      NodePort</span><br><span class="line">20   10.96.131.215:12000   ClusterIP      1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line"># 查看 iptables 是否有 kube-proxy 维护的规则</span><br><span class="line">&gt; iptables-save | grep KUBE-SVC</span><br><span class="line">&lt;Empty&gt; # 说明 kube-proxy 没有维护任何应用服务跳转，即可以停止它了。</span><br></pre></td></tr></table></figure><h2><span id="小结">小结</span></h2><p>Cilium 作为当下最 Cool 的 Kubernetes CNI 网络插件，还有很多特性，如高阶 network policy、7 层流量控制等，这款基于 BPF/eBPF 打造出的简单、高效、易用的网络管理体验，有机会大家都来试用吧。</p><blockquote><p>本文转载自：「  MY X FILES 」，原文：<a href="https://tinyurl.com/54h8zzvd" target="_blank" rel="noopener">https://tinyurl.com/54h8zzvd</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近业界使用范围最广的K8S CNI网络方案&lt;a href=&quot;https://www.projectcalico.org/introducing-the-calico-ebpf-dataplane/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Calico宣布支持eBPF&lt;/a&gt;，而作为第一个通过 eBPF 实现了 kube-proxy 所有功能的 K8S 网络方案——Cilium，它的先见之名是否能转成优势，继而成为 CNI 新的头牌呢？今天我们一起来入门最 Cool Kubernetes 网络方案 Cilium。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Cilium介绍&quot;&gt;Cilium介绍&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;以下基于&lt;a href=&quot;https://cilium.readthedocs.io/en/stable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cilium官网文档&lt;/a&gt;翻译整理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;当前趋势&quot;&gt;当前趋势&lt;/h3&gt;
&lt;p&gt;现代数据中心的应用系统已经逐渐转向基于微服务架构的开发体系，一个微服务架构的应用系统是由多个小的独立的服务组成，它们之间通过轻量通信协议如 HTTP、gRPC、Kafka 等进行通信。微服务架构下的服务天然具有动态变化的特点，结合容器化部署，时常会引起大规模的容器实例启动或重启。要确保这种向高度动态化的微服务应用之间的安全可达，既是挑战，也是机遇。&lt;/p&gt;
&lt;h3 id=&quot;现有问题&quot;&gt;现有问题&lt;/h3&gt;
&lt;p&gt;传统的 Linux 网络访问安全控制机制（如 iptables）是基于静态环境的IP地址和端口配置网络转发、过滤等规则，但是 IP 地址在微服务架构下是不断变化的，非固定的；出于安全目的，协议端口(例如 HTTP 传输的 TCP 端口 80)也不再固定用来区分应用系统。为了匹配大规模容器实例快速变化的生命周期，传统网络技术需要维护成千上万的负载均衡规则和访问控制规则，并且需要以不断增长的频率更新这些规则，而如果没有准确的可视化功能，要维护这些规则也是十分困难，这些对传统网络技术的可用性和性能都是极大的挑战。比如经常会有人对 kube-proxy 基于 iptables 的服务负载均衡功能在大规模容器场景下具有严重的性能瓶颈，同时由于容器的创建和销毁非常频繁，基于 IP 做身份关联的故障排除和安全审计等也很难实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="微服务" scheme="https://www.hi-linux.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款可快速全量交付 Kubernetes 集群分布式应用的神器 Sealer</title>
    <link href="https://www.hi-linux.com/posts/29602.html"/>
    <id>https://www.hi-linux.com/posts/29602.html</id>
    <published>2021-06-02T01:00:00.000Z</published>
    <updated>2021-06-04T06:20:55.416Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="什么是集群镜像">什么是集群镜像</span></h2><p>顾名思义，和操作系统 .iso 镜像或 Docker 镜像类似，集群镜像是<strong>用一定的技术手段把整个集群的所有文件以一定格式打成的一个资源包</strong>。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210601143614113-2021-06-01-u9cFX4.jpg" alt></p><p>对比单机和集群会发现一些的有趣现象：</p><ul><li>单机有计算、存储、网络等驱动；集群有 CNI/CSI/CRI 实现像是集群的驱动。</li><li>单机有 Ubuntu、Centos 操作系统；集群中可以把 Kubernetes 看成云操作系统。</li><li>单机上可以运行 Docker 容器或虚拟机；相当于一个运行的实例，集群上也有运行着 K8s 的实例。</li><li>单机上有虚拟机镜像，Docker 镜像；随着云计算技术的发展，集群上也会抽象出类似的镜像技术。</li></ul><p>以基于 Kubernetes 的集群镜像为例，里面包含了除操作系统以外的所有文件：</p><ul><li>docker 依赖的二进制与 Systemd 配置、Dockerd 配置，以及一个私有的容器镜像仓库。</li><li>Kubernetes 核心组件二进制、容器镜像、kubelet system 配置等。</li><li>应用需要用到的 yaml 配置或 helm chart，以及应用的容器镜像。</li><li>其它脚本、配置与二进制工具等应用运行需要的所有依赖。</li></ul><p>同样，集群镜像运行时肯定不是起一个容器或者装在一台机器上，而是这个镜像可以直接安装到多台服务器上或者直接对接到公有云的基础设施上。</p><a id="more"></a><h2><span id="什么是-sealer">什么是 sealer</span></h2><p>sealer[ˈsiːlər]是一款分布式应用打包交付运行的解决方案，通过把分布式应用及其数据库中间件等依赖一起打包以解决复杂应用的交付问题。</p><p>sealer 构建出来的产物我们称之为集群镜像, 集群镜像里内嵌了一个 kubernetes, 解决了分布式应用的交付一致性问题。集群镜像可以 push 到 registry 中共享给其他用户使用，也可以在官方仓库中找到非常通用的分布式软件直接使用。</p><p>Docker 解决了单个容器的镜像化问题，而 sealer 把 kubernetes 看成操作系统，在这个更高的抽象纬度上做出来的镜像就是集群镜像。sealer 通过把整个集群打包，实现了分布式软件的 Build Share Run!!!</p><h3><span id="特性">特性</span></h3><ul><li>[x] 极其简单的方式在生产环境中或者离线环境中安装 kubernetes、以及 kubernetes 生态中其它软件</li><li>[x] 通过 Kubefile 可以非常简单的自定义 kubernetes 集群镜像对集群和应用进行打包，并可以提交到仓库中进行分享</li><li>[x] 强大的生命周期管理能力，以难以想象的简单的方式去做如集群升级，集群备份恢复，节点阔缩等操作</li><li>[x] 速度极快 3min 以内完成集群安装</li><li>[x] 支持 ARM x86, v1.20 以上版本支持 containerd，几乎兼容所有支持 systemd 的 linux 操作系统</li><li>[x] 不依赖 ansible haproxy keepalived, 高可用通过 ipvs 实现，占用资源少，稳定可靠</li><li>[x] 官方仓库中有非常多的生态软件镜像可以直接使用，包含所有依赖，一键安装</li></ul><h3><span id="使用场景">使用场景</span></h3><p>试想我们要去交付一个 SaaS 应用，它依赖了 MySQL/ES/Redis 这些数据库和中间件，所有东西都在 Kubernetes 上进行编排，如果没有集群镜像时，要做如下操作：</p><ol><li>找个工具去安装 K8s 集群</li><li><code>helm install mysql es redis...</code> ，如果是离线环境可能还需要导入容器镜像</li><li><code>kubectl apply yoursaas</code></li></ol><p>看似好像也没那么复杂，但其实从整个项目交付的角度来说，以上操作是面向过程极易出错的。</p><p>现在如果提供另外一个方式，只需一条命令就可解决上面的问题，你会不会用？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sealer run your-saas-application-with-mysql-redis-es:latest</span><br></pre></td></tr></table></figure><p>可以看到，只需要 run 一个集群镜像，整个集群就被交付了，细节复杂的操作都被屏蔽掉了，而且任何应用都可以使用相同的方式运行。这个集群镜像是怎么来的呢？</p><p><img src="https://img.hi-linux.com/staticfile/640-20210601154712544-2021-06-01-qHQrjk.jpg" alt></p><p>如上图所示：我们只需要定义一个类似 Dockerfile 的文件，将其称之为 Kubefile, 然后执行 build 命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sealer build -t your-saas-application-with-mysql-redis-es:latest .</span><br></pre></td></tr></table></figure><p>从单机和集群两个纬度进行对比，就可以一目了然：</p><p><img src="https://img.hi-linux.com/staticfile/640-20210601154902708-2021-06-01-w4g4WG.jpg" alt></p><ul><li>docker 通过 Dockerfile 构建一个 docker 镜像，使用 compose 就可以运行容器。</li><li>sealer 通过 Kubefile 构建一个 CloudImage，使用 Clusterfile 启动整个集群。</li></ul><h3><span id="技术原理">技术原理</span></h3><h4><span id="1-写时复制">1. 写时复制</span></h4><p>集群镜像的存储也是通过写时复制的方式实现的。这样做有两个好处：我们可以把同一集群中不同的分布式软件打在不同层，以实现复用；还可以实现直接把集群镜像 push 到 docker 镜像仓库中。</p><h4><span id="2-容器镜像缓存">2. 容器镜像缓存</span></h4><p>build 的过程中 sealer 是如何知道待构建的集群镜像里有哪些容器镜像，以及怎么把容器镜像存储下来呢？其中有一些难点问题:</p><ol><li><p>如何知道分布式软件中有哪些容器镜像？因为我们需要把这些镜像缓存下来，不管是扫描用户的 yaml 文件还是用 helm template 之后扫描都是不完美的。首先不能确定用户的编排方式是什么，其次有些软件不把镜像地址写在编排文件中，而是通过自己的程序去拉起，无法保证 build 成功运行就一定没问题。</p></li><li><p>容器镜像是需要被存储到私有仓库中打包在集群镜像里，那容器镜像仓库地址势必和编排文件中写的不一样，特别是怎么保证用户 alwayPull 的时候还是能够在私有仓库中下载到镜像？</p></li></ol><p>对待第一个问题，sealer 解决方式是：sealer build 的过程中和 Docker build 一样，会拉起一个临时的 Kubernetes 集群，并执行用户在 Kubefile 中定义的 apply 指令。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210601154910492-2021-06-01-GYb2Gl.jpg" alt></p><p>如上图所示，这样就可以保证用户依赖的所有镜像都被打包进去，无论用户使用什么样的编排方式。</p><p>第二个问题，我们打包容器镜像到私有镜像仓库中，怎样使用这个私有镜像也是个难题，假设私有镜像仓库名为 localhost:5000，肯定会和编排文件中写的不一致，对此我们有两种方式解决：</p><ul><li><p>第一种是 hack 和 docker，做了一个只要私有镜像仓库中有就直接从私有镜像中拉取，没有才去公网拉取镜像的能力。</p></li><li><p>第二种方案是无侵入 docke r的 proxy，把 docker 请求全部打给代理，让代理去决定如果私有仓库有就从私有仓库拉取。同时我们还增强了 registry 的能力让 registry 可以 cache 多个远程仓库的能力。</p></li></ul><p><img src="https://img.hi-linux.com/staticfile/640-20210601150651235-2021-06-01-veScxz.jpg" alt></p><p>sealer 的这种方案完美解决了离线场景镜像打包的问题。</p><h4><span id="3-负载均衡">3. 负载均衡</span></h4><p>sealer 的集群高可用使用了轻量级的负载均衡 lvscare。相比其它负载均衡，lvscare 非常小仅有几百行代码，而且 lvscare 只做 ipvs 规则的守护，本身不做负载非常稳定，直接在 node 上监听 apiserver，如果跪了就移除对应的规则，重新起来之后会自动加回，相当于是一个专用的负载均衡器，在 sealos 项目中也用了两年多，有广泛的实践。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210601150651248-2021-06-01-SCS83B.jpg" alt></p><h4><span id="4-运行时">4. 运行时</span></h4><p>运行时就是支撑应用运行的环境，像 base on Kuberentes 的运行时 sealer 就可以透明地支持非常简单，以 istio 为例，用户只需要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM kubernetes:v1.18.3</span><br><span class="line">RUN  curl -L https:&#x2F;&#x2F;istio.io&#x2F;downloadIstio | sh -</span><br></pre></td></tr></table></figure><p>就可以 build 出一个 istio 的运行时供自己应用使用。</p><p>对于不是 base on Kuberentes 的运行时，如 k0s k3s，可以扩展 sealer.Runtime 中的接口，这样以后就可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM k3s:v1.18.3</span><br><span class="line">RUN curl -L https:&#x2F;&#x2F;istio.io&#x2F;downloadIstio | sh -</span><br></pre></td></tr></table></figure><p>更牛的扩展比如扩展 ACK 的 runtime：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM aliyum.com&#x2F;ACK:v1.16.9RUN </span><br><span class="line">curl -L https:&#x2F;&#x2F;istio.io&#x2F;downloadIstio | sh -</span><br></pre></td></tr></table></figure><p>这种镜像会直接帮助用户应用运行到 ACK 上。以上有些能力在 roadmap 中。</p><h4><span id="5-基础设施">5. 基础设施</span></h4><p>现在很多用户都希望在云端运行自己的集群镜像，sealer 自带对接公有云能力，sealer 自己实现的基础设施管理器，得益于我们更精细的退避重试机制，30s 即可完成基础设施构建（阿里云 6 节点）性能是同类工具中的佼佼者，且 API 调用次数大大降低，配置兼容 Clusterfile。</p><h2><span id="快速体验">快速体验</span></h2><h3><span id="安装一个-kubernetes-集群">安装一个 kubernetes 集群</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sealer run kubernetes:v1.19.9 --masters 192.168.0.2 --passwd xxx</span><br></pre></td></tr></table></figure><p>如果是在云上安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ export ACCESSKEYID&#x3D;xxx</span><br><span class="line">$ export ACCESSKEYSECRET&#x3D;xxx</span><br><span class="line">$ sealer run registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;dashboard:latest</span><br><span class="line"># 或者指定节点数量运行集群</span><br><span class="line">$ sealer run registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;dashboard:latest \</span><br><span class="line">  --masters 3 --nodes 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get node</span><br><span class="line">NAME                      STATUS   ROLES    AGE   VERSION</span><br><span class="line">izm5e42unzb79kod55hehvz   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r7z   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r8z   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r9z   Ready    &lt;none&gt;   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7raz   Ready    &lt;none&gt;   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7rbz   Ready    &lt;none&gt;   18h   v1.16.9</span><br></pre></td></tr></table></figure><p>查看镜像默认启动配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sealer inspect -c registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;dashboard:latest</span><br></pre></td></tr></table></figure><h3><span id="使用-clusterfile-拉起一个-k8s-集群">使用 Clusterfile 拉起一个 K8s 集群</span></h3><p>使用已经提供好的官方基础镜像(sealer-io/kubernetes:v1.19.9)就可以快速拉起一个 k8s 集群。</p><ol><li>场景 1：在已存在的服务器上去安装，provider 类型为：BAREMETAL</li></ol><p>Clusterfile 内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: sealer.aliyun.com&#x2F;v1alpha1</span><br><span class="line">kind: Cluster</span><br><span class="line">metadata:</span><br><span class="line">  name: my-cluster</span><br><span class="line">spec:</span><br><span class="line">  image: registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;kubernetes:v1.19.9</span><br><span class="line">  provider: BAREMETAL</span><br><span class="line">  ssh:</span><br><span class="line">    passwd:</span><br><span class="line">    pk: xxx</span><br><span class="line">    pkPasswd: xxx</span><br><span class="line">    user: root</span><br><span class="line">  network:</span><br><span class="line">    interface: eth0</span><br><span class="line">    cniName: calico</span><br><span class="line">    podCIDR: 100.64.0.0&#x2F;10</span><br><span class="line">    svcCIDR: 10.96.0.0&#x2F;22</span><br><span class="line">    withoutCNI: false</span><br><span class="line">  certSANS:</span><br><span class="line">    - aliyun-inc.com</span><br><span class="line">    - 10.0.0.2</span><br><span class="line"></span><br><span class="line">  masters:</span><br><span class="line">    ipList:</span><br><span class="line">     - 172.20.125.234</span><br><span class="line">     - 172.20.126.5</span><br><span class="line">     - 172.20.126.6</span><br><span class="line">  nodes:</span><br><span class="line">    ipList:</span><br><span class="line">     - 172.20.126.8</span><br><span class="line">     - 172.20.126.9</span><br><span class="line">     - 172.20.126.10</span><br></pre></td></tr></table></figure><p>执行如下所示命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sealer apply -f Clusterfile</span><br><span class="line">$ kubectl get node</span><br><span class="line">NAME                      STATUS   ROLES    AGE   VERSION</span><br><span class="line">izm5e42unzb79kod55hehvz   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r7z   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r8z   Ready    master   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7r9z   Ready    &lt;none&gt;   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7raz   Ready    &lt;none&gt;   18h   v1.16.9</span><br><span class="line">izm5ehdjw3kru84f0kq7rbz   Ready    &lt;none&gt;   18h   v1.16.9</span><br></pre></td></tr></table></figure><ol start="2"><li>场景 2：自动申请阿里云服务器进行安装, provider 类型为：ALI_CLOUD</li></ol><p>Clusterfile 内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: sealer.aliyun.com&#x2F;v1alpha1</span><br><span class="line">kind: Cluster</span><br><span class="line">metadata:</span><br><span class="line">  name: my-cluster</span><br><span class="line">spec:</span><br><span class="line">  image: registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;kubernetes:v1.19.9</span><br><span class="line">  provider: ALI_CLOUD</span><br><span class="line">  ssh:</span><br><span class="line">    passwd:</span><br><span class="line">    pk: xxx</span><br><span class="line">    pkPasswd: xxx</span><br><span class="line">    user: root</span><br><span class="line">  network:</span><br><span class="line">    interface: eth0</span><br><span class="line">    cniName: calico</span><br><span class="line">    podCIDR: 100.64.0.0&#x2F;10</span><br><span class="line">    svcCIDR: 10.96.0.0&#x2F;22</span><br><span class="line">    withoutCNI: false</span><br><span class="line">  certSANS:</span><br><span class="line">    - aliyun-inc.com</span><br><span class="line">    - 10.0.0.2</span><br><span class="line"></span><br><span class="line">  masters:</span><br><span class="line">    cpu: 4</span><br><span class="line">    memory: 4</span><br><span class="line">    count: 3</span><br><span class="line">    systemDisk: 100</span><br><span class="line">    dataDisks:</span><br><span class="line">    - 100</span><br><span class="line">  nodes:</span><br><span class="line">    cpu: 4</span><br><span class="line">    memory: 4</span><br><span class="line">    count: 3</span><br><span class="line">    systemDisk: 100</span><br><span class="line">    dataDisks:</span><br><span class="line">    - 100</span><br></pre></td></tr></table></figure><p>准备好阿里云的 AK 和 SK，并执行如下所示命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ACCESSKEYID&#x3D;xxxxxxx ACCESSKEYSECRET&#x3D;xxxxxxx sealer apply -f Clusterfile</span><br></pre></td></tr></table></figure><p>部署完成后，基础设置的一些源信息会被写入到 Clusterfile 中，存储在 <code>/root/.sealer/[cluster-name]/Clusterfile</code> 中。如果你需要释放集群，可以执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;sealer delete -f &#x2F;root&#x2F;.sealer&#x2F;my-cluster&#x2F;Clusterfile</span><br></pre></td></tr></table></figure><h3><span id="制作一个自定义的集群镜像-这里以制作一个-kubernetes-dashboard-镜像为例">制作一个自定义的集群镜像, 这里以制作一个 Kubernetes Dashboard 镜像为例</span></h3><p>新建一个 dashboard 目录，并创建一个文件 Kubefile 内容为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;kubernetes:v1.19.9</span><br><span class="line">RUN wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.2.0&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml</span><br><span class="line">CMD kubectl apply -f recommended.yaml</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ export ACCESSKEYID&#x3D;xxxxxxx</span><br><span class="line">$ export ACCESSKEYSECRET&#x3D;xxxxxxx</span><br><span class="line">$ sealer build -f Kubefile -t my-kuberentes-cluster-with-dashboard:latest .</span><br></pre></td></tr></table></figure><p>创建一个带有 Kubernetes Dashboard 的自定义集群, 操作同上，替换掉 Clusterfile 中的 image 字段即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: sealer.aliyun.com&#x2F;v1alpha1</span><br><span class="line">kind: Cluster</span><br><span class="line">metadata:</span><br><span class="line">  name: my-cluster</span><br><span class="line">spec:</span><br><span class="line">  image: my-kuberentes-cluster-with-dashboard:latest</span><br><span class="line">  provider: ALI_CLOUD</span><br><span class="line">  ssh:</span><br><span class="line">    passwd:</span><br><span class="line">    pk: xxx</span><br><span class="line">    pkPasswd: xxx</span><br><span class="line">    user: root</span><br><span class="line">  network:</span><br><span class="line">    interface: eth0</span><br><span class="line">    cniName: calico</span><br><span class="line">    podCIDR: 100.64.0.0&#x2F;10</span><br><span class="line">    svcCIDR: 10.96.0.0&#x2F;22</span><br><span class="line">    withoutCNI: false</span><br><span class="line">  certSANS:</span><br><span class="line">    - aliyun-inc.com</span><br><span class="line">    - 10.0.0.2</span><br><span class="line"></span><br><span class="line">  masters:</span><br><span class="line">    cpu: 4</span><br><span class="line">    memory: 4</span><br><span class="line">    count: 3</span><br><span class="line">    systemDisk: 100</span><br><span class="line">    dataDisks:</span><br><span class="line">    - 100</span><br><span class="line">  nodes:</span><br><span class="line">    cpu: 4</span><br><span class="line">    memory: 4</span><br><span class="line">    count: 3</span><br><span class="line">    systemDisk: 100</span><br><span class="line">    dataDisks:</span><br><span class="line">    - 100</span><br></pre></td></tr></table></figure><p>和上面的操作类似，先准备好阿里云的 AK 和 SK，并执行如下所示命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ACCESSKEYID&#x3D;xxxxxxx ACCESSKEYSECRET&#x3D;xxxxxxx sealer apply -f Clusterfile</span><br></pre></td></tr></table></figure><p>到这里，你就部署好一个自带 Kubernetes Dashboard 的集群。</p><p>你还可以把制作好的集群镜像推送到镜像仓库，供其它人进行使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sealer tag my-kuberentes-cluster-with-dashboard:latest registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;my-kuberentes-cluster-with-dashboard:latest</span><br><span class="line">$ sealer push registry.cn-qingdao.aliyuncs.com&#x2F;sealer-io&#x2F;my-kuberentes-cluster-with-dashboard:latest</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>sealer 未来的一些愿景与价值体现：</p><ul><li>sealer 可以以极其简单的方式让用户自定义集群，解决分布式软件制作者与使用者的协作问题。</li><li>极其简单友好的 User Interface，能屏蔽和兼容各种底层技术细节，到处运行。</li><li>生态建设，官方仓库里将会涵盖常用的分布式软件。</li></ul><p>最后我们总结下：</p><ul><li>如果你要整体交付你的分布式 SaaS，请用 sealer。</li><li>如果你要集成多个分布式服务在一起，如数据库消息队列或者微服务运行时，请用 sealer。</li><li>如果你要安装一个分布式应用如 mysql 主备集群，请用 sealer。</li><li>如果你需要安装/管理一个 Kubernetes 高可用集群，请用 sealer。</li><li>如果你要初始化多个数据中心，保持多个数据中心状态强一致，请用 sealer。</li><li>如果你需要在公有云上实现上述场景，请用 sealer。</li></ul><blockquote><p>sealer 项目地址：<a href="https://github.com/alibaba/sealer" target="_blank" rel="noopener">https://github.com/alibaba/sealer</a></p></blockquote><h2><span id="参考文档">参考文档</span></h2><ol><li><a href="https://github.com/alibaba/sealer/blob/main/docs/README_zh.md" target="_blank" rel="noopener">https://github.com/alibaba/sealer/blob/main/docs/README_zh.md</a></li><li><a href="https://mp.weixin.qq.com/s/0SBslzaMWtqn9H8Q57urNA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0SBslzaMWtqn9H8Q57urNA</a></li><li><a href="https://mp.weixin.qq.com/s/0jVykl3DAYp9cQpAi13G-A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0jVykl3DAYp9cQpAi13G-A</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是集群镜像&quot;&gt;什么是集群镜像&lt;/h2&gt;
&lt;p&gt;顾名思义，和操作系统 .iso 镜像或 Docker 镜像类似，集群镜像是&lt;strong&gt;用一定的技术手段把整个集群的所有文件以一定格式打成的一个资源包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/640-20210601143614113-2021-06-01-u9cFX4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对比单机和集群会发现一些的有趣现象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单机有计算、存储、网络等驱动；集群有 CNI/CSI/CRI 实现像是集群的驱动。&lt;/li&gt;
&lt;li&gt;单机有 Ubuntu、Centos 操作系统；集群中可以把 Kubernetes 看成云操作系统。&lt;/li&gt;
&lt;li&gt;单机上可以运行 Docker 容器或虚拟机；相当于一个运行的实例，集群上也有运行着 K8s 的实例。&lt;/li&gt;
&lt;li&gt;单机上有虚拟机镜像，Docker 镜像；随着云计算技术的发展，集群上也会抽象出类似的镜像技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以基于 Kubernetes 的集群镜像为例，里面包含了除操作系统以外的所有文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docker 依赖的二进制与 Systemd 配置、Dockerd 配置，以及一个私有的容器镜像仓库。&lt;/li&gt;
&lt;li&gt;Kubernetes 核心组件二进制、容器镜像、kubelet system 配置等。&lt;/li&gt;
&lt;li&gt;应用需要用到的 yaml 配置或 helm chart，以及应用的容器镜像。&lt;/li&gt;
&lt;li&gt;其它脚本、配置与二进制工具等应用运行需要的所有依赖。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样，集群镜像运行时肯定不是起一个容器或者装在一台机器上，而是这个镜像可以直接安装到多台服务器上或者直接对接到公有云的基础设施上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linux 下优雅的查看系统 CPU 信息</title>
    <link href="https://www.hi-linux.com/posts/13355.html"/>
    <id>https://www.hi-linux.com/posts/13355.html</id>
    <published>2021-05-28T01:00:00.000Z</published>
    <updated>2021-05-28T08:44:37.102Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>我们在进行机器学习的时候，肯定需要使用一个比较好的 <code>GPU</code> 显卡，其次就是一个性能强劲的 <code>CPU</code> 了。主频高的 <code>CPU</code> 在跑程序的时候，真的有时候比使用 <code>GPU</code> 都跑的块，所以如何查看自己机器的 <code>CPU</code> 就是必不可少的步骤了。我们常常选购笔记本或者服务器的时候，总是会看到 <strong>X 核 XG</strong> 这样的表示，今天我们就一起来了解下其中的一些常见术语吧！</p><ul><li><strong>[1] 查看 CPU 型号和频率 - model</strong></li></ul><p>通过 <code>CPU</code> 的型号，我们可以直观的分辨其好坏和优劣，而频率则反馈的是其性能如何。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CPU型号</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"model name"</span> | uniq</span><br><span class="line">model name      : Intel(R) Xeon(R) CPU E5-2640 v4 @ 2.40GHz</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU频率</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"cpu MHz"</span> | uniq</span><br><span class="line">cpu MHz         : 1547.537</span><br><span class="line">cpu MHz         : 1250.590</span><br><span class="line">cpu MHz         : 2183.637</span><br></pre></td></tr></table></figure><ul><li><strong>[2] 查看物理 CPU 个数 - chip</strong></li></ul><p>主板上实际插入的 <code>CPU</code> 数量，可以数不重复的 <code>physical id</code> 字段有几个，即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 物理CPU数量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | sort | uniq | wc -l</span><br><span class="line">2</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><strong>[3] 查看每个物理 CPU 中 core 的个数 - core - 核数</strong></li></ul><p>单块 <code>CPU</code> 上面能处理数据的芯片组的数量，如双核、四核等，成为 <code>cpu cores</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CPU核数</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"cpu cores"</span> | uniq</span><br><span class="line">cpu cores       : 10</span><br></pre></td></tr></table></figure><ul><li><strong>[4] 查看逻辑 CPU 的个数 - processor</strong></li></ul><p>一般情况下，<strong>逻辑 CPU = 物理 CPU 个数 × 每颗核数</strong>，如果不相等的话，则表示服务器的 <code>CPU</code> 支持超线程技术。<strong>超线程技术(HTT)</strong>：简单来说，它可使处理器中的 <code>1</code> 颗内核如 <code>2</code> 颗内核那样在操作系统中发挥作用。这样一来，操作系统可使用的执行资源扩大了一倍，大幅提高了系统的整体性能，此时<strong>逻辑 CPU = 物理 CPU 个数 × 每颗核数 × 2</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逻辑CPU数</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"processor"</span> | wc -l</span><br><span class="line">40</span><br></pre></td></tr></table></figure><ul><li><strong>[5] 查询系统 CPU 是否启用超线程 - HTT</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询方式</span></span><br><span class="line">$ cat /proc/cpuinfo | grep -e <span class="string">"cpu cores"</span>  -e <span class="string">"siblings"</span> | sort | uniq</span><br><span class="line">cpu cores       : 10</span><br><span class="line">siblings        : 20</span><br></pre></td></tr></table></figure><ul><li><p>参考链接地址</p><ol><li><a href="https://wiki.mbalib.com/wiki/%E8%B6%85%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF" target="_blank" rel="noopener">超线程技术</a></li><li><a href="https://blog.csdn.net/ztguang/article/details/83089905" target="_blank" rel="noopener">CPU：chip、core 和 processor 的关系</a></li></ol></li></ul><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/yy2m9ayn" target="_blank" rel="noopener">https://tinyurl.com/yy2m9ayn</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在进行机器学习的时候，肯定需要使用一个比较好的 &lt;code&gt;GPU&lt;/code&gt; 显卡，其次就是一个性能强劲的 &lt;code&gt;CPU&lt;/code&gt; 了。主频高的 &lt;code&gt;CPU&lt;/code&gt; 在跑程序的时候，真的有时候比使用 &lt;code&gt;GPU&lt;/code&gt; 都跑的块，所以如何查看自己机器的 &lt;code&gt;CPU&lt;/code&gt; 就是必不可少的步骤了。我们常常选购笔记本或者服务器的时候，总是会看到 &lt;strong&gt;X 核 XG&lt;/strong&gt; 这样的表示，今天我们就一起来了解下其中的一些常见术语吧！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[1] 查看 CPU 型号和频率 - model&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 &lt;code&gt;CPU&lt;/code&gt; 的型号，我们可以直观的分辨其好坏和优劣，而频率则反馈的是其性能如何。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# CPU型号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat /proc/cpuinfo | grep &lt;span class=&quot;string&quot;&gt;&quot;model name&quot;&lt;/span&gt; | uniq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model name      : Intel(R) Xeon(R) CPU E5-2640 v4 @ 2.40GHz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# CPU频率&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat /proc/cpuinfo | grep &lt;span class=&quot;string&quot;&gt;&quot;cpu MHz&quot;&lt;/span&gt; | uniq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cpu MHz         : 1547.537&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cpu MHz         : 1250.590&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cpu MHz         : 2183.637&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[2] 查看物理 CPU 个数 - chip&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主板上实际插入的 &lt;code&gt;CPU&lt;/code&gt; 数量，可以数不重复的 &lt;code&gt;physical id&lt;/code&gt; 字段有几个，即可。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 物理CPU数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat /proc/cpuinfo | grep &lt;span class=&quot;string&quot;&gt;&quot;physical id&quot;&lt;/span&gt; | sort | uniq | wc -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Shell" scheme="https://www.hi-linux.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>万字总结，体系化带你全面认识 Linux 系统安全强化</title>
    <link href="https://www.hi-linux.com/posts/38523.html"/>
    <id>https://www.hi-linux.com/posts/38523.html</id>
    <published>2021-05-24T01:00:00.000Z</published>
    <updated>2021-05-26T06:08:29.931Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本指南旨在说明如何尽可能地加强 Linux 的安全性和隐私性，并且不限于任何特定的指南。</p><p>免责声明：如果您不确定自己在做什么，请不要尝试在本文中使用任何内容。</p><p>本指南仅关注安全性和隐私性，而不关注性能，可用性或其他内容。</p><p>列出的所有命令都将需要 root 特权。以 <code>$</code> 符号开头的单词表示一个变量，不同终端之间可能会有所不同。</p><h2><span id="选择正确的linux发行版">选择正确的Linux发行版</span></h2><p>选择一个好的 Linux 发行版有很多因素。</p><ul><li><p>避免分发冻结程序包，因为它们在安全更新中通常很落后</p></li><li><p>不使用与 Systemd 机制的发行版。 Systemd 包含许多不必要的攻击面；它尝试做的事情远远超出了必要，并且超出了初始化系统应做的事情。</p></li><li><p>使用 musl 作为默认的 C 库。 Musl 专注于最小化，这会导致很小的攻击面，而其他 C 库（例如 glibc）过于复杂，容易产生漏洞。例如，与 musl 中的极少数漏洞相比，glibc 中的一百多个漏洞已被公开披露。尽管仅靠披露的 CVE 本身通常是不准确的统计信息，但有时这种情况有时可以用来表示过分的问题。 Musl还具有不错的漏洞利用缓解措施，尤其是其新的强化内存分配器。</p></li><li><p>最好默认情况下使用 LibreSSL 而不是 OpenSSL 的发行版。OpenSSL 包含大量完全不必要的攻击面，并且遵循不良的安全做法。例如，它仍然保持 OS / 2和 VMS 支持这些已有数十年历史的古老操作系统。这些令人讨厌的安全做法导致了可怕的 Heartbleed 漏洞。LibreSSL 是 OpenBSD 团队的 OpenSSL 分支，它采用了出色的编程实践并消除了很多攻击面。在 LibreSSL 成立的第一年内，它缓解了许多漏洞，其中包括一些高严重性的漏洞。</p></li></ul><p>用作强化操作系统基础的最佳发行版是 Gentoo Linux，因为它可以让您精确地配置系统，以达到理想的效果，这将非常有用，尤其是参考我们在后面的章节中使用更安全的编译标志。</p><p>但是，由于 Gentoo 的巨大可用性缺陷，它对于许多人来说可能并不顺手。在这种情况下，Void Linux的 Musl 构建是一个很好的折衷方案。</p><a id="more"></a><h2><span id="内核">内核</span></h2><p>内核是操作系统的核心，不幸的是很容易受到攻击。正如Brad Spengler曾经说过的那样，可以将其视为系统上最大，最易受攻击的setuid根二进制文件。因此，对内核进行尽可能多的强化非常重要。</p><h3><span id="stable-vs-lts-内核">Stable vs LTS 内核</span></h3><p>Linux 内核以两种主要形式发布：稳定和长期支持（LTS）。稳定版本是较新的版本，而 LTS 发行版本是较老的稳定版本，长期以来一直受支持。选择上述任何一个发行版本都有许多后果。</p><p>Linux 内核未使用 CVE 标识安全漏洞。这意味着大多数安全漏洞的修复程序不能向后移植到 LTS 内核。但是稳定版本包含到目前为止进行的所有安全修复。</p><p>但是，有了这些修复程序，稳定的内核将包含更多新功能，因此大大增加了内核的攻击面，并引入了大量新错误。相反，LTS 内核的受攻击面较小，因为这些功能没有被不断添加。</p><p>此外，稳定的内核还包括更新的强化功能，以减轻 LTS 内核没有的某些利用。此类功能的一些示例是Lockdown LSM 和 STACKLEAK GCC 插件。</p><p>总而言之，在选择稳定或 LTS 内核时需要权衡取舍。LTS 内核具有较少的强化功能，并且并非当时所有的公共错误修复都已向后移植，但是通常它的攻击面更少，并且引入未知错误的可能性也较小。稳定的内核具有更多的强化功能，并且包括所有已知的错误修复，但它也具有更多的攻击面以及引入更多未知错误的机会更大。最后，最好使用较新的 LTS 分支（如4.19内核）。</p><h3><span id="sysctl">Sysctl</span></h3><p>Sysctl 是允许用户配置某些内核设置并启用各种安全功能或禁用危险功能以减少攻击面的工具。要临时更改设置，您可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w $tunable &#x3D; $value</span><br></pre></td></tr></table></figure><p>要永久更改 sysctls，您可以将要更改的 sysctls 添加到 /etc/sysctl.conf 或 /etc/sysctl.d 中的相应文件，具体取决于您的Linux发行版。</p><p>以下是您应更改的建议 sysctl 设置。</p><h3><span id="kernel-self-protection">Kernel self-protection</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.kptr_restrict&#x3D;2</span><br></pre></td></tr></table></figure><p>内核指针指向内核内存中的特定位置。这些在利用内核方面可能非常有用，但是默认情况下不会隐藏内核指针，例如，通过读取 /proc/kallsyms 的内容即可轻松发现它们。此设置旨在减轻内核指针泄漏。另外，您可以设置 <code>kernel.kptr_restrict = 1</code> 以仅从没有 CAP_SYSLOG 功能的进程中隐藏内核指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.dmesg_restrict&#x3D;1</span><br></pre></td></tr></table></figure><p>dmesg 是内核日志，它公开了大量有用的内核调试信息，但这通常会泄漏敏感信息，例如内核指针。更改上述 sysctl 设置会将内核日志限制为 CAP_SYSLOG 功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.printk&#x3D;3 3 3 3</span><br></pre></td></tr></table></figure><p>尽管 dmesg_restrict 的值，启动过程中内核日志仍将显示在控制台中。能够在引导过程中记录屏幕的恶意软件可能会滥用此恶意软件以获得更高的特权。此选项可防止这些信息泄漏。必须将其与下面描述的某些引导参数结合使用才能完全有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel.unprivileged_bpf_disabled&#x3D;1</span><br><span class="line">net.core.bpf_jit_harden&#x3D;2</span><br></pre></td></tr></table></figure><p>eBPF 暴露了很大的攻击面，因此需加以限制。这些系统将 eBPF 限制为 CAP_BPF 功能（在 5.8 之前的内核版本上为 CAP_SYS_ADMIN ），并启用 JIT 强化技术，例如常量绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev.tty.ldisc_autoload&#x3D;0</span><br></pre></td></tr></table></figure><p>这将加载 TTY 行规则限制为 CAP_SYS_MODULE 功能，以防止非特权的攻击者使用 TIOCSETD ioctl加载易受攻击的线路规则，而该 TIOCSETD ioctl 之前已在许多漏洞利用中被滥用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.unprivileged_userfaultfd&#x3D;0</span><br></pre></td></tr></table></figure><p>userfaultfd() 系统调用经常被滥用以利用“事后使用(use-after-free)”缺陷。因此，该 sysctl 用于将此 syscall 限制为 CAP_SYS_PTRACE 功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.kexec_load_disabled&#x3D;1</span><br></pre></td></tr></table></figure><p>kexec 是一个系统调用，用于在运行时引导另一个内核。可以滥用此功能来加载恶意内核并在内核模式下获得任意代码执行能力，因此该 sysctl 设置将被禁用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.sysrq&#x3D;4</span><br></pre></td></tr></table></figure><p>SysRq 密钥向非特权用户公开了许多潜在的危险调试功能。与通常的假设相反，SysRq 不仅是物理攻击的问题，而且还可以远程触发。该 sysctl 的值使其可以使用户只能使用SAK密钥，这对于安全地访问 root 是必不可少的。或者，您可以简单地将值设置为 0 以完全禁用 SysRq。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.unprivileged_userns_clone&#x3D;0</span><br></pre></td></tr></table></figure><p>用户名称空间是内核中的一项功能，旨在改善沙箱并使非特权用户易于访问它，但是，此功能公开了重要的内核攻击面，以进行特权升级，因此该 sysctl 将用户名称空间的使用限制为 CAP_SYS_ADMIN 功能。对于无特权的沙箱，建议使用具有很少攻击面的 setuid 二进制文件，以最大程度地减少特权升级的可能性。沙箱章节部分将进一步讨论此主题。</p><p>请注意，尽管该 sysctl 仅在某些Linux发行版中存在，因为它需要内核补丁。如果您的内核不包含此补丁，则可以通过设置 user.max_user_namespaces = 0 来完全禁用用户名称空间（包括 root 用户）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.perf_event_paranoid&#x3D;3</span><br></pre></td></tr></table></figure><p>性能事件会增加大量内核攻击面，并导致大量漏洞。此 sysctl 设置将性能事件的所有使用限制为 CAP_PERFMON 功能（5.8 之前的内核版本为 CAP_SYS_ADMIN）。</p><p>请注意，此 sysctl 设置需要在某些发行版中具备相关的内核补丁。否则，此设置等效于<code>kernel.perf_event_paranoid = 2</code>，它仅限制此功能的子集。</p><h3><span id="网络">网络</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies&#x3D;1</span><br></pre></td></tr></table></figure><p>这有助于防止 SYN 泛洪攻击，这种攻击是拒绝服务攻击的一种形式，在这种攻击中，攻击者发送大量虚假的 SYN 请求，以尝试消耗足够的资源以使系统对合法流量不响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_rfc1337&#x3D;1</span><br></pre></td></tr></table></figure><p>这通过丢弃处于时间等待状态的套接字的RST数据包来防止 time-wait 状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.rp_filter&#x3D;1</span><br><span class="line">net.ipv4.conf.default.rp_filter&#x3D;1</span><br></pre></td></tr></table></figure><p>这些启用了源验证，以验证从计算机所有网络接口接收到的数据包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.all.secure_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.secure_redirects&#x3D;0</span><br><span class="line">net.ipv6.conf.all.accept_redirects&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.all.send_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.send_redirects&#x3D;0</span><br></pre></td></tr></table></figure><p>这些设置禁用了 ICMP 重定向，以防止中间人攻击并最大程度地减少信息泄露。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.icmp_echo_ignore_all&#x3D;1</span><br></pre></td></tr></table></figure><p>此设置使您的系统忽略所有 ICMP 请求，以避免 Smurf 攻击，使设备更难以在网络上枚举，并防止通过 ICMP 时间戳识别时钟指纹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.accept_source_route&#x3D;0</span><br><span class="line">net.ipv4.conf.default.accept_source_route&#x3D;0</span><br><span class="line">net.ipv6.conf.all.accept_source_route&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_source_route&#x3D;0</span><br></pre></td></tr></table></figure><p>源路由是一种允许用户重定向网络流量的机制。由于这可用于执行中间人攻击，在中间人攻击中，出于恶意目的将流量重定向，因此上述设置将会禁用此功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.accept_ra&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_ra&#x3D;0</span><br></pre></td></tr></table></figure><p>恶意的 IPv6 路由广告可能会导致中间人攻击，因此应将其禁用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_sack&#x3D;0</span><br><span class="line">net.ipv4.tcp_dsack&#x3D;0</span><br><span class="line">net.ipv4.tcp_fack&#x3D;0</span><br></pre></td></tr></table></figure><p>禁用 TCP SACK。ACK 通常被利用，并且在许多情况下是不必要的，因此如果您不需要它，则应将其禁用。</p><h3><span id="用户空间">用户空间</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.yama.ptrace_scope&#x3D;2</span><br></pre></td></tr></table></figure><p>ptrace 是一个系统调用，它允许程序调试、修改和检查另一个正在运行的进程，从而使攻击者可以轻易修改其他正在运行的程序的内存。设置将 ptrace 的使用限制为仅具有 CAP_SYS_PTRACE 功能的进程。或者，将 sysctl 设置为 3 以完全禁用 ptrace。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.mmap_rnd_bits&#x3D;32</span><br><span class="line">vm.mmap_rnd_compat_bits&#x3D;16</span><br></pre></td></tr></table></figure><p>ASLR 是一种常见的漏洞利用缓解措施，它可以使进程的关键部分在内存中的位置随机化。这可能会使各种各样的漏洞利用更困难，因为它们首先需要信息泄漏。上述设置增加了用于 mmap ASLR 的熵的位数，从而提高了其有效性。</p><p><strong>这些sysctls的值必须根据CPU体系结构进行设置。以上值与x86兼容，但其他体系结构可能有所不同。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.protected_symlinks&#x3D;1</span><br><span class="line">fs.protected_hardlinks&#x3D;1</span><br></pre></td></tr></table></figure><p>仅当在可全局写入的粘性目录之外，当符号链接和关注者的所有者匹配或目录所有者与符号链接的所有者匹配时，才允许遵循符号链接。这还可以防止没有对源文件的读/写访问权限的用户创建硬链接。这两者都阻止了许多常见的 TOCTOU 漏洞（time-of-check-to-time-of-use）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.protected_fifos&#x3D;2</span><br><span class="line">fs.protected_regular&#x3D;2</span><br></pre></td></tr></table></figure><p>这些阻止了在可能由攻击者控制的环境（例如，全局可写目录）中创建文件，从而使数据欺骗攻击更加困难。</p><h3><span id="引导参数">引导参数</span></h3><p>引导参数在引导时使用引导加载程序（bootloader）将设置传递给内核。类似于sysctl，可以使用某些设置来提高安全性。引导加载程序通常在引导参数设置方式上有所不同。下面列出了一些示例，但是您应该研究特定 bootloader 的修改参数的必要步骤。</p><p>如果使用 GRUB 作为引导程序，请编辑 <code>/etc/default/grub</code> 并将参数添加到<code>GRUB_CMDLINE_LINUX_DEFAULT=line</code>。</p><p>如果使用 Syslinux，请编辑 /boot/syslinux/syslinux.cfg 并将它们添加到 APPEND 行中。</p><p>如果使用 systemd-boot，请编辑您的加载程序条目，并将其附加到 linux 行的末尾。</p><p>建议使用以下设置以提高安全性。</p><h3><span id="kernel-self-protection">Kernel self-protection</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slab_nomerge</span><br></pre></td></tr></table></figure><p>这将禁用 slab 合并，这将通过防止覆盖合并的缓存中的对象并使其更难以影响 slab 缓存的布局，从而大大增加了堆利用的难度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slub_debug&#x3D;FZ</span><br></pre></td></tr></table></figure><p>这些启用健全性检查（F）和重新分区（Z）。健全性检查会添加各种检查，以防止某些slab操作中的损坏。重新分区会在 slab 周围添加额外的区域，以检测 slab 何时被覆盖超过其实际大小，从而有助于检测溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_on_alloc&#x3D;1 init_on_free&#x3D;1</span><br></pre></td></tr></table></figure><p>这样可以在分配和空闲时间期间将内存清零，这可以帮助减轻使用后使用的漏洞并清除内存中的敏感信息。如果您的内核版本低于 5.3，则这些选项不存在。而是在上述 slub_debug 选项后面附加 “P”，以获得 slub_debug=FZP 并添加 page_poison=1。由于它们实际上是一种调试功能，刚好具有一些安全性，因此它们在释放时提供的内存擦除形式较弱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page_alloc.shuffle&#x3D;1</span><br></pre></td></tr></table></figure><p>此选项使页分配器空闲列表随机化，从而通过降低页分配的可预测性来提高安全性，同时这也提高了性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pti&#x3D;on</span><br></pre></td></tr></table></figure><p>这将启用内核页表隔离，从而减轻崩溃并防止某些 KASLR 绕过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsyscall&#x3D;none</span><br></pre></td></tr></table></figure><p>这将禁用 vsyscall，因为它们已过时且已被 vDSO 取代。 vsyscall 也在内存中的固定地址上，使其成为 ROP 攻击的潜在目标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugfs&#x3D;off</span><br></pre></td></tr></table></figure><p>这将禁用 debugfs，它会公开许多有关内核的敏感信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oops&#x3D;panic</span><br></pre></td></tr></table></figure><p>有时某些内核漏洞利用会导致所谓的 “oops”。此参数将引发内核对此类事件 panic，从而防止这些攻击。但是，有时错误的驱动程序会导致无害的操作，这会导致系统崩溃，这意味着此引导参数只能在某些硬件上使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.sig_enforce&#x3D;1</span><br></pre></td></tr></table></figure><p>这仅允许加载已使用有效密钥签名的内核模块，使加载恶意内核模块更加困难。</p><p>这可以防止加载所有树外内核模块（包括 DKMS 模块），除非您已对其进行签名，这意味着诸如 VirtualBox 或 Nvidia 驱动程序之类的模块可能不可用，但根据您的设置可能并不重要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lockdown&#x3D;confidentiality</span><br></pre></td></tr></table></figure><p>内核锁定 LSM 可以消除用户空间代码滥用以升级为内核特权并提取敏感信息的许多方法。为了在用户空间和内核之间实现清晰的安全边界，此LSM是必需的。上面的选项在 confidentiality 模式（最严格的选项）中启用此功能。这意味着 <code>module.sig_enforce=1</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mce&#x3D;0</span><br></pre></td></tr></table></figure><p>这将导致内核对 ECC 内存中无法利用的错误 panic，而这些错误可能会被利用。对于没有 ECC 内存的系统，这是不必要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quiet loglevel&#x3D;0</span><br></pre></td></tr></table></figure><p>这些参数可防止引导期间信息泄漏，并且必须与上面的 kernel.printk sysctl 结合使用。</p><h3><span id="cpu缓解">CPU缓解</span></h3><p>最好启用适用于您的CPU的所有CPU缓解措施，以确保您不受已知漏洞的影响。这是启用所有内置缓解措施的列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spectre_v2&#x3D;on spec_store_bypass_disable&#x3D;on tsx&#x3D;off tsx_async_abort&#x3D;full,nosmt mds&#x3D;full,nosmt l1tf&#x3D;full,force nosmt&#x3D;force kvm.nx_huge_pages&#x3D;force</span><br></pre></td></tr></table></figure><p>您必须研究系统受其影响的 CPU 漏洞，并相应地选择上述缓解措施。请记住，您将需要安装微代码更新，以完全免受这些漏洞的影响。但所有这些操作都可能导致性能显着下降。</p><h3><span id="结果">结果</span></h3><p>如果遵循了以上所有建议（不包括特定的 CPU 缓解措施），则将具有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slab_nomerge slub_debug&#x3D;FZ init_on_alloc&#x3D;1 init_on_free&#x3D;1 page_alloc.shuffle&#x3D;1 pti&#x3D;on vsyscall&#x3D;none debugfs&#x3D;off oops&#x3D;panic module.sig_enforce&#x3D;1 lockdown&#x3D;confidentiality mce&#x3D;0 quiet loglevel&#x3D;0</span><br></pre></td></tr></table></figure><p>如果将 GRUB 用作引导加载程序，则可能需要重新生成 GRUB 配置文件才能应用这些文件。</p><h3><span id="hidepid">hidepid</span></h3><p>proc 是一个伪文件系统，其中包含有关系统上当前正在运行的所有进程的信息。默认情况下，所有用户都可以访问此程序，这可能使攻击者可以窥探其他进程。要只允许用户看到自己的进程，而不能看到其他用户的进程，则必须使用 hidepid=2，gid=proc 挂载选项来挂载 /proc。gid=proc 将 proc 组从此功能中排除，因此您可以将特定的用户或进程列入白名单。添加这些选项的一种方法是编辑 /etc/fstab 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc &#x2F;proc proc nosuid,nodev,noexec,hidepid&#x3D;2,gid&#x3D;proc 0 0</span><br></pre></td></tr></table></figure><p>systemd-logind 仍然需要查看其他用户的进程，因此，要使用户会话在 systemd 系统上正常工作，必须创建 <code>/etc/systemd/system/systemd-logind.service.d/hidepid.conf</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">SupplementaryGroups&#x3D;proc</span><br></pre></td></tr></table></figure><h3><span id="减少内核攻击面">减少内核攻击面</span></h3><p>最好禁用不是绝对必要的任何功能，以最大程度地减少潜在的内核攻击面。这些功能不必一定很危险，它们可以只是被删除以减少攻击面的良性代码。切勿禁用您不了解的随机事物。以下是一些可能有用的示例，具体取决于您的设置。</p><h3><span id="引导参数">引导参数</span></h3><p>引导参数通常可以用来减少攻击面，这样的例子之一是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipv6.disable&#x3D;1</span><br></pre></td></tr></table></figure><p>这将禁用整个IPv6堆栈，如果您尚未迁移到该堆栈，则可能不需要该堆栈。如果正在使用的IPv6，请不要使用此引导参数。</p><h3><span id="将内核模块列入黑名单">将内核模块列入黑名单</span></h3><p>内核允许非特权的用户通过模块自动加载来间接导致某些模块被加载。这使攻击者可以自动加载易受攻击的模块，然后加以利用。一个这样的示例是 CVE-2017-6074，其中攻击者可以通过启动DCCP连接来触发DCCP内核模块的加载，然后利用该内核模块中的漏洞。</p><p>可以通过将文件插入 <code>/etc/modprobe.d</code> 并将指定的内核模块列入黑名单的方法，将特定的内核模块列入黑名单。</p><p>Install 参数告诉 modprobe 运行特定命令，而不是像往常一样加载模块。 /bin/false 是仅返回 1 的命令，该命令实际上不会执行任何操作。两者都告诉内核运行 /bin/false 而不是加载模块，这将防止攻击者利用该模块。以下是最有可能不需要的内核模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">install dccp &#x2F;bin&#x2F;false</span><br><span class="line">install sctp &#x2F;bin&#x2F;false</span><br><span class="line">install rds &#x2F;bin&#x2F;false</span><br><span class="line">install tipc &#x2F;bin&#x2F;false</span><br><span class="line">install n-hdlc &#x2F;bin&#x2F;false</span><br><span class="line">install ax25 &#x2F;bin&#x2F;false</span><br><span class="line">install netrom &#x2F;bin&#x2F;false</span><br><span class="line">install x25 &#x2F;bin&#x2F;false</span><br><span class="line">install rose &#x2F;bin&#x2F;false</span><br><span class="line">install decnet &#x2F;bin&#x2F;false</span><br><span class="line">install econet &#x2F;bin&#x2F;false</span><br><span class="line">install af_802154 &#x2F;bin&#x2F;false</span><br><span class="line">install ipx &#x2F;bin&#x2F;false</span><br><span class="line">install appletalk &#x2F;bin&#x2F;false</span><br><span class="line">install psnap &#x2F;bin&#x2F;false</span><br><span class="line">install p8023 &#x2F;bin&#x2F;false</span><br><span class="line">install p8022 &#x2F;bin&#x2F;false</span><br><span class="line">install can &#x2F;bin&#x2F;false</span><br><span class="line">install atm &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>特别是模糊的网络协议会增加大量的远程攻击面。此黑名单：</p><ul><li>DCCP — Datagram Congestion Control Protocol</li><li>SCTP — Stream Control Transmission Protocol</li><li>RDS — Reliable Datagram Sockets</li><li>TIPC — Transparent Inter-process Communication</li><li>HDLC — High-Level Data Link Control</li><li>AX25 — Amateur X.25</li><li>NetRom</li><li>X25</li><li>ROSE</li><li>DECnet</li><li>Econet</li><li>af_802154 — IEEE 802.15.4</li><li>IPX — Internetwork Packet Exchange</li><li>AppleTalk</li><li>PSNAP — Subnetwork Access Protocol</li><li>p8023 — Novell raw IEEE 802.3</li><li>p8022 — IEEE 802.2</li><li>CAN — Controller Area Network</li><li>ATM</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">install cramfs &#x2F;bin&#x2F;false</span><br><span class="line">install freevxfs &#x2F;bin&#x2F;false</span><br><span class="line">install jffs2 &#x2F;bin&#x2F;false</span><br><span class="line">install hfs &#x2F;bin&#x2F;false</span><br><span class="line">install hfsplus &#x2F;bin&#x2F;false</span><br><span class="line">install squashfs &#x2F;bin&#x2F;false</span><br><span class="line">install udf &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>将各种稀有文件系统列入黑名单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">install cifs &#x2F;bin&#x2F;true</span><br><span class="line">install nfs &#x2F;bin&#x2F;true</span><br><span class="line">install nfsv3 &#x2F;bin&#x2F;true</span><br><span class="line">install nfsv4 &#x2F;bin&#x2F;true</span><br><span class="line">install gfs2 &#x2F;bin&#x2F;true</span><br></pre></td></tr></table></figure><p>如果不使用网络文件系统，也可以将其列入黑名单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install vivid &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p><a href="https://href.li/?https://www.kernel.org/doc/html/v4.12/media/v4l-drivers/vivid.html" target="_blank" rel="noopener">vivid driver</a>驱动程序仅用于测试目的，并且是特权提升漏洞的原因，因此应禁用它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install bluetooth &#x2F;bin&#x2F;false</span><br><span class="line">install btusb &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>禁用具有安全问题历史记录的蓝牙。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install uvcvideo &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>这会禁用网络摄像头，以防止其被用来监视您。</p><p>您也可以将麦克风模块列入黑名单，但这在系统之间可能会有所不同。要查找模块的名称，请在 /proc/asound/modules 中查找并将其列入黑名单。例如，一个这样的模块是 snd_hda_intel。</p><p>请注意，尽管有时麦克风的内核模块与扬声器的模块相同。这意味着像这样禁用麦克风也可能会无意中禁用任何扬声器，虽然扬声器也有可能变成麦克风，所以这不一定是消极的结果。</p><p>最好从物理上删除这些设备，或者至少在 BIOS/UEFI 中禁用它们。禁用内核模块并不总是那么有效。</p><h3><span id="rfkill">rfkill</span></h3><p>可以通过rfkill将无线设备列入黑名单，以进一步减少远程攻击面。要将所有无线设备列入黑名单，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill block all</span><br></pre></td></tr></table></figure><p>WiFi可以通过以下方式解锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill unblock wifi</span><br></pre></td></tr></table></figure><p>在使用systemd的系统上，rfkill在所有会话中均保持不变，但是，在使用其他init系统的系统上，您可能必须创建一个init脚本以在引导时执行这些命令。</p><h3><span id="其他内核指针泄漏">其他内核指针泄漏</span></h3><p>前面的部分已经防止了一些内核指针泄漏，但是还有更多泄漏。</p><p>在文件系统上，/boot 中存在内核映像和 System.map 文件。/usr/src和/{,usr/} lib/modules目录中还有其他敏感的内核信息。您应该限制这些目录的文件权限，以使它们只能由root用户读取。您还应该删除 System.map 文件，因为除高级调试外，它们都不需要。</p><p>此外，某些日志记录守护程序（例如 systemd 的 journalctl ）包括内核日志，可用于绕过上述 dmesg_restrict 保护。从 adm 组中删除用户通常足以撤销对以下日志的访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -d $user adm</span><br></pre></td></tr></table></figure><h3><span id="限制对-sysfs-的访问">限制对 sysfs 的访问</span></h3><p>sysfs 是伪文件系统，可提供大量的内核和硬件信息。它通常安装在/sys上。 sysfs 导致大量信息泄漏，尤其是内核指针泄漏。Whonix 的 security-misc 软件包包括 hide-hardware-info 脚本，该脚本限制访问此目录以及 /proc 中的一些脚本，以试图隐藏潜在的硬件标识符并防止内核指针泄漏。该脚本是可配置的，并允许基于组将特定的应用程序列入白名单。建议应用此方法，并使其在启动时使用 init 脚本执行。或者这样<a href="https://href.li/?https://github.com/Whonix/security-misc/blob/master/lib/systemd/system/hide-hardware-info.service" target="_blank" rel="noopener">做成systemd服务</a>。</p><p>为了使基本功能在使用 systemd 的系统上运行，必须将一些系统服务列入白名单。这可以通过创建 <code>/etc/systemd/system/user@.service.d/sysfs.conf</code> 并添加以下内容来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">SupplementaryGroups&#x3D;sysfs</span><br></pre></td></tr></table></figure><p>但是，这不能解决所有问题。许多应用程序可能仍会中断，您需要将它们正确列入白名单。</p><h3><span id="linux强化">Linux强化</span></h3><p>某些发行版（例如 Arch Linux ）包括强化的内核程序包。它包含许多强化补丁程序和更注重安全性的内核配置。如果可能的话，建议安装它。</p><h3><span id="grsecurity">Grsecurity</span></h3><p>Grsecurity 是一组内核修补程序，可以大大提高内核安全性。这些补丁曾经可以免费获得，但是现在<a href="https://href.li/?https://grsecurity.net/passing_the_baton" target="_blank" rel="noopener">需要购买</a>了。如果可用，则强烈建议您获取它。Grsecurity 提供了最新的内核和用户空间保护。</p><h3><span id="内核运行时防护">内核运行时防护</span></h3><p>Linux Kernel Runtime Guard（LKRG）是一个内核模块，可确保运行时内核的完整性并检测漏洞。它可以杀死整个类别的内核漏洞。但这并不是一个完美的缓解方法，因为LKRG在设计上可以绕开。它仅适用于现成的恶意软件。但是，尽管可能性不大，但LKRG本身可能会像其他任何内核模块一样公开新的漏洞。</p><h3><span id="自编译内核">自编译内核</span></h3><p>建议编译您自己的内核，同时启用尽可能少的内核模块和尽可能多的安全性功能，以将内核的受攻击面保持在绝对最低限度。</p><p>另外，应用内核强化补丁，例如如上所述的 linux-hardened 或 grsecurity。</p><p>发行版编译的内核还具有公共内核指针/符号，这对于漏洞利用非常有用。编译自己的内核将为您提供独特的内核符号，连同 kptr_restrict，dmesg_restrict 和其他针对内核指针泄漏的强化措施，将使攻击者更加难以创建依赖于内核指针知识的漏洞利用程序。</p><p>您就可以从<a href="https://href.li/?https://www.whonix.org/wiki/Hardened-kernel" target="_blank" rel="noopener">Whonix的强化内核</a>中汲取灵感或使用它。</p><h2><span id="强制访问措施">强制访问措施</span></h2><p>强制访问控制（MAC）系统对程序可以访问的内容进行细粒度的控制。这意味着您的浏览器将无权访问您的整个主目录或类似目录。</p><p>最常用的 MAC 措施是 SELinux 和 AppArmor。SELinux比AppArmor 更安全，因为它的粒度更细。例如，它是基于inode而不是基于路径的，允许强制执行明显更严格的限制，可以过滤内核 ioctl 等。不幸的是，这是以难以使用和难以学习为代价的，因此某些人可能会首选 AppArmor。</p><p>要在内核中启用 AppArmor，必须设置以下引导参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apparmor&#x3D;1 security&#x3D;apparmor</span><br></pre></td></tr></table></figure><p>要启用 SELinux，请设置以下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selinux&#x3D;1 security&#x3D;selinux</span><br></pre></td></tr></table></figure><p>请记住，仅启用 MAC 措施本身并不能神奇地提高安全性。您必须制定严格的政策才能充分利用它。例如，要创建 AppArmor 配置文件，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa-genprof $path_to_program</span><br></pre></td></tr></table></figure><p>打开程序，然后像往常一样开始使用它。AppArmor 将检测需要访问哪些文件，并将它们添加到配置文件中（如果您选择的话）。但是，仅凭这一点不足以提供高质量的配置文件。请参阅<a href="https://href.li/?https://gitlab.com/apparmor/apparmor/-/wikis/Documentation" target="_blank" rel="noopener">AppArmor文档</a>以获取更多详细信息。</p><p>如果您想更进一步，则可以通过实施 initramfs 勾子来设置一个完整的系统MAC策略，该策略限制每个单个用户空间进程，该挂钩对 init 系统强制实施MAC策略。这就是 Android 使用 SELinux 的方式，以及 Whonix 未来将如何使用 AppArmor 的方式。对于加强实施最小特权原则的强大安全模型是必要的。</p><h2><span id="沙箱">沙箱</span></h2><h3><span id="应用沙箱">应用沙箱</span></h3><p>沙箱可让您在隔离的环境中运行程序，该环境对系统的其余部分具有有限的访问权限或完全没有访问权限。您可以使用它们来保护应用程序安全或运行不受信任的程序。</p><p>建议与 AppArmor 或 SELinux 一起在单独的用户帐户中使用<a href="https://href.li/?https://github.com/containers/bubblewrap" target="_blank" rel="noopener">Bubblewrap</a>到沙箱程序。您也可以考虑改用 gVisor，它的优点是为每个来宾提供了自己的内核。</p><p>这些方法中的任何一个都可以用来创建一个功能强大的沙箱，并且暴露的攻击面最小。如果您不想自己创建沙箱，请在完成后考虑使用 Whonix 的 sandbox-app-launcher。<a href="https://href.li/?https://madaidans-insecurities.github.io/linux.html#firejail" target="_blank" rel="noopener">您不应该使用Firejail</a>。</p><p>诸如 Docker 和 LXC 之类的容器解决方案经常被误导为沙盒形式。它们太宽松了，无法广泛支持各种应用程序，因此不能认为它们是强大的应用程序沙箱。</p><h3><span id="常见沙箱逃逸">常见沙箱逃逸</span></h3><h4><span id="pulseaudio">PulseAudio</span></h4><p>PulseAudio 是一种常见的声音服务器，但在编写时并未考虑隔离或沙盒的问题，这使其成为重复出现的沙盒逃逸漏洞。为了防止这种情况，建议您从沙箱中阻止对 PulseAudio 的访问，或者从系统中完全卸载它。</p><h4><span id="d-bus">D-Bus</span></h4><p>D-Bus 是台式机 Linux 上最流行的进程间通信形式，但它也是沙箱逃逸的另一种常见途径，因为它允许与服务自由交互。这些漏洞的一个例子就是 Firejail。您应该从沙箱中阻止对 D-Bus 的访问，或者通过 MAC 以细粒度的规则进行调解。</p><h4><span id="gui隔离">GUI隔离</span></h4><p>任何 Xorg 窗口都可以访问另一个窗口。这允许琐碎的键盘记录或屏幕截图程序，甚至可以记录诸如 root 密码之类的内容。您可以使用嵌套的 X11 服务器（例如 Xpra 或 Xephyr 和 bubblewrap）将 Xorg 窗口沙箱化。默认情况下，Wayland 将窗口彼此隔离，这将是一个比 Xorg 更好的选择，尽管 Wayland 可能不如 Xorg 普遍可用，因为它在开发中较早。</p><h4><span id="ptrace">ptrace</span></h4><p>如前所述，ptrace 是一个系统调用，可能会被滥用破坏在沙箱外部运行的进程。为避免这种情况，您可以通过 sysctl 启用内核 YAMA ptrace 限制，也可以在 seccomp 过滤器中将 ptrace syscall 列入黑名单。</p><h4><span id="tiocsti">TIOCSTI</span></h4><p>TIOCSTI 是一个 ioctl，它允许注入终端命令，并为攻击者提供了一种简单的机制，可以在同一用户会话内的其他进程之间横向移动。可以通过将 seccomp 过滤器中的 ioctl 列入黑名单或使用 bubblewrap 的 <code>–new-session</code> 参数来缓解这种攻击。</p><h4><span id="systemd-沙箱">Systemd 沙箱</span></h4><p>虽然不建议使用 systemd，但有些系统可能无法切换。这些人至少可以使用沙盒服务，因此他们只能访问所需的内容。这是一个沙箱化 systemd 服务的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">CapabilityBoundingSet&#x3D;CAP_NET_BIND_SERVICE</span><br><span class="line">ProtectSystem&#x3D;strict</span><br><span class="line">ProtectHome&#x3D;true</span><br><span class="line">ProtectKernelTunables&#x3D;true</span><br><span class="line">ProtectKernelModules&#x3D;true</span><br><span class="line">ProtectControlGroups&#x3D;true</span><br><span class="line">ProtectKernelLogs&#x3D;true</span><br><span class="line">ProtectHostname&#x3D;true</span><br><span class="line">ProtectClock&#x3D;true</span><br><span class="line">ProtectProc&#x3D;invisible</span><br><span class="line">ProcSubset&#x3D;pid</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line">PrivateUsers&#x3D;yes</span><br><span class="line">PrivateDevices&#x3D;true</span><br><span class="line">MemoryDenyWriteExecute&#x3D;true</span><br><span class="line">NoNewPrivileges&#x3D;true</span><br><span class="line">LockPersonality&#x3D;true</span><br><span class="line">RestrictRealtime&#x3D;true</span><br><span class="line">RestrictSUIDSGID&#x3D;true</span><br><span class="line">RestrictAddressFamilies&#x3D;AF_INET</span><br><span class="line">RestrictNamespaces&#x3D;yes</span><br><span class="line">SystemCallFilter&#x3D;write read openat close brk fstat lseek mmap mprotect munmap rt_sigaction rt_sigprocmask ioctl nanosleep select access execve getuid arch_prctl set_tid_address set_robust_list prlimit64 pread64 getrandom</span><br><span class="line">SystemCallArchitectures&#x3D;native</span><br><span class="line">UMask&#x3D;0077</span><br><span class="line">IPAddressDeny&#x3D;any</span><br><span class="line">AppArmorProfile&#x3D;&#x2F;etc&#x2F;apparmor.d&#x2F;usr.bin.example</span><br></pre></td></tr></table></figure><p>所有选项的说明：</p><ul><li><code>CapabilityBoundingSet=</code> — Specifies the <a href="https://href.li/?https://madaidans-insecurities.github.io/guides/linux-hardening.html#capabilities" target="_blank" rel="noopener">capabilities</a> the process is given.</li><li><code>ProtectHome=true</code> — Makes all home directories inaccessible.</li><li><code>ProtectKernelTunables=true</code> — Mounts kernel tunables such as those modified through <code>sysctl</code> as read-only.</li><li><code>ProtectKernelModules=true</code> — Denies module loading and unloading.</li><li><code>ProtectControlGroups=true</code> — Mounts all control group hierarchies as read-only.</li><li><code>ProtectKernelLogs=true</code> — Prevents accessing the kernel logs.</li><li><code>ProtectHostname=true</code> — Prevents changes to the system hostname.</li><li><code>ProtectClock</code> — Prevents changes to the system clock.</li><li><code>ProtectProc=invisible</code> — Hides all outside processes.</li><li><code>ProcSubset=pid</code> — Permits access to only the pid subset of <code>/proc</code>.</li><li><code>PrivateTmp=true</code> — Mounts an empty tmpfs over <code>/tmp</code> and <code>/var/tmp</code>, therefore hiding their previous contents.</li><li><code>PrivateUsers=true</code> — Sets up an empty user namespace to hide other user accounts on the system.</li><li><code>PrivateDevices=true</code> — Creates a new <code>/dev</code> mount with minimal devices present.</li><li><code>MemoryDenyWriteExecute=true</code> — Enforces a memory W^X policy.</li><li><code>NoNewPrivileges=true</code> — Prevents escalating privileges.</li><li><code>LockPersonality=true</code> — Locks down the <code>personality()</code> syscall to prevent switching execution domains.</li><li><code>RestrictRealtime=true</code> — Prevents attempts to enable realtime scheduling.</li><li><code>RestrictSUIDSGID=true</code> — Prevents executing setuid or setgid binaries.</li><li><code>RestrictAddressFamilies=AF_INET</code> — Restricts the usable socket address families to IPv4 only (<code>AF_INET</code>).</li><li><code>RestrictNamespaces=true</code> — Prevents creating any new namespaces.</li><li><code>SystemCallFilter=...</code> — Restricts the allowed syscalls to the absolute minimum. If you aren’t willing to maintain your own custom seccomp filter, then systemd provides many [predefined system call sets](<a href="https://href.li/?https://www.freedesktop.org/software/systemd/man/systemd.exec.html#System" target="_blank" rel="noopener">https://www.freedesktop.org/software/systemd/man/systemd.exec.html#System</a> Call Filtering) that you can use. <code>@system-service</code> will be suitable for many use cases.</li><li><code>SystemCallArchitectures=native</code> — Prevents executing syscalls from other CPU architectures.</li><li><code>UMask=0077</code> — Sets the <a href="https://href.li/?https://madaidans-insecurities.github.io/guides/linux-hardening.html#umask" target="_blank" rel="noopener">umask</a> to a more restrictive value.</li><li><code>IPAddressDeny=any</code> — Blocks all incoming and outgoing traffic to/from any IP address. Set <code>IPAddressAllow=</code> to configure a whitelist. Alternatively, setup a network namespace with <code>PrivateNetwork=true</code>.</li><li><code>AppArmorProfile=...</code> — Runs the process under the specified AppArmor profile.</li></ul><p>您不能仅将此示例配置复制到您的配置中，每种服务的要求各不相同，并且必须针对每种服务微调沙箱。要了解有关您可以设置的所有选项的更多信息，请阅读<a href="https://href.li/?https://www.freedesktop.org/software/systemd/man/systemd.exec.html" target="_blank" rel="noopener">systemd.exec手册页</a>。</p><p>如果您使用的系统不是 systemd 而是 init，那么可以使用 bubblewrap 轻松复制所有这些选项。</p><h3><span id="gvisor">gVisor</span></h3><p>普通沙箱固有地与主机共享同一内核。您信任我们已经评估为不安全的内核，可以正确限制这些程序。由于主机内核的整个攻击面已完全暴露，因此沙盒中的内核利用程序可以绕过任何限制。已经进行了一些努力来限制使用 seccomp 的攻击面，但不足以完全解决此问题。</p><p>GVisor 是解决此问题的方法。它为每个应用程序提供了自己的内核，该内核以内存安全的语言重新实现了 Linux 内核的大部分系统调用，从而提供了明显更强的隔离性。</p><h3><span id="虚拟机">虚拟机</span></h3><p>虽然不是传统的 “沙盒”，但虚拟机通过虚拟化全新系统来分离进程，从而提供了非常强大的隔离性。KVM是内核模块，它允许内核充当管理程序，而QEMU是利用KVM的仿真器。Virt-manager 和 GNOME Boxs都是良好且易于使用的 GUI，用于管理 KVM / QEMU 虚拟机。不建议使用 Virtualbox 的<a href="https://href.li/?https://www.whonix.org/wiki/KVM#Why_Use_KVM_Over_VirtualBox.3F" target="_blank" rel="noopener">原因</a>有很多。</p><h2><span id="强化内存分配器">强化内存分配器</span></h2><p>hardened_malloc 是一种硬化的内存分配器，可为堆内存损坏漏洞提供实质性的保护。它很大程度上基于 OpenBSD 的 malloc 设计，但具有许多改进。</p><p>可以通过 LD_PRELOAD 环境变量针对每个应用程序使用 hardened_malloc。例如，假设您编译的库位于 <code>/usr/lib/libhardened_malloc.so</code>，则可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD&#x3D;&quot;&#x2F;usr&#x2F;lib&#x2F;libhardened_malloc.so&quot; $program</span><br></pre></td></tr></table></figure><p>通过全局预加载该库，也可以在系统范围内使用它，这是使用它的推荐方法。为此，请编辑 /etc/ld.so.preload 并插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;lib&#x2F;libhardened_malloc.so</span><br></pre></td></tr></table></figure><p>尽管大多数应用程序都可以正常工作，但 hardened_malloc 可能会破坏某些应用程序。建议使用以下选项编译 hardened_malloc 以最大程度地减少损坏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SLAB_QUARANTINE_RANDOM_LENGTH&#x3D;0 </span><br><span class="line">CONFIG_SLAB_QUARANTINE_QUEUE_LENGTH&#x3D;0 </span><br><span class="line">CONFIG_GUARD_SLABS_INTERVAL&#x3D;8</span><br></pre></td></tr></table></figure><p>您还应该使用sysctl设置以下内容，以适应hardened_malloc创建的大量保护页：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count&#x3D;524240</span><br></pre></td></tr></table></figure><p><a href="https://href.li/?https://www.whonix.org/wiki/Hardened_Malloc" target="_blank" rel="noopener">Whonix项目</a>为基于Debian的发行版提供了hardened_malloc软件包。</p><h2><span id="强化编译标志">强化编译标志</span></h2><p>编译自己的程序可以带来很多好处，因为它使您能够优化程序的安全性。但是，执行完全相反的操作并降低安全性很容易，如果您不确定自己在做什么，请跳过本节。在基于源的发行版（例如Gentoo）上，这将是最简单的，但也可以在其他发行版上这样做。</p><p>某些编译选项可用于添加其他漏洞利用缓解措施，从而消除整个类别的常见漏洞。您可能听说过常规保护，例如位置独立可执行文件，堆栈粉碎保护程序，立即绑定，只读重定位和 FORTIFY_SOURCE，但是本节将不做介绍，因为它们已被广泛采用。相反，它将讨论诸如控制流完整性和影子堆栈之类的现代漏洞利用缓解措施。</p><p>本节涉及主要用 C 或 C ++ 编写的本机程序。您必须使用 Clang 编译器，因为这些功能在 GCC 上不可用。请记住，由于未广泛采用这些缓解措施，因此某些应用程序在启用它们后可能无法运行。</p><ul><li>控制流完整性（CFI）是一种缓解漏洞利用的方法，旨在防止诸如 ROP 或 JOP 之类的代码重用攻击。由于更广泛采用的缓解措施（例如 NX）使过时的利用技术过时了，因此使用这些技术利用了很大一部分漏洞。Clang 支持细粒度的前沿 CFI，这意味着它可以有效缓解JOP攻击。Clang 的 CFI 本身并不能减轻ROP；您还必须使用下面记录的单独机制。要启用此功能，必须应用以下编译标志： <code>-flto -fvisibility=hidden -fsanitize=cfi</code></li><li>影子堆栈通过将程序复制到其他隐藏堆栈中来保护程序的返回地址。然后比较主堆栈和影子堆栈中的返回地址，看两者是否不同。如果是这样，则表明存在攻击，程序将中止，从而减轻了 ROP 攻击。Clang 具有称为 ShadowCallStack 的功能，可以完成此操作，但是，仅在 ARM64 上可用。要启用此功能，必须应用以下编译标志： <code>-fsanitize=shadow-call-stack</code></li><li>如果上述 ShadowCallStack 不是一个选项，则可以选择使用具有相似目标的 SafeStack。但是，不幸的是，此功能有许多漏洞，因此效果不甚理想。如果仍然希望启用此功能，则必须应用以下编译标志： <code>-fsanitize=safe-stack</code></li><li>最常见的内存损坏漏洞之一是未初始化的内存。Clang 有一个选项可以使用零或特定模式自动初始化变量。建议将变量初始化为零，因为使用其他模式比利用漏洞缓解功能更适合发现错误。要启用此功能，必须应用以下编译标志： -ftrivial-auto-var-init=zero -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang 但该选项的存在目前正在<a href="https://href.li/?https://lists.llvm.org/pipermail/cfe-dev/2020-April/065221.html" target="_blank" rel="noopener">辩论</a>中。</li></ul><h2><span id="内存安全语言">内存安全语言</span></h2><p>用内存安全语言编写的程序会自动受到保护，免受各种安全漏洞的影响，这些安全漏洞包括缓冲区溢出，未初始化的变量，售后使用等。</p><p>Microsoft 和 Google 的安全研究人员进行的研究证明，已发现的大多数漏洞都是内存安全问题。这样的内存安全语言的示例包括 Rust，Swift 和 Java，而内存不安全语言的示例包括 C 和 C ++。如果可行，应使用内存安全替代品替换尽可能多的程序。</p><h2><span id="root-账户">Root 账户</span></h2><p>root 可以执行任何操作，并且可以访问您的整个系统。因此，应尽可能将其锁定，以使攻击者无法轻松获得 root 用户访问权限。</p><h3><span id="etcsecuretty">/etc/securetty</span></h3><p>/etc/securetty 文件指定允许您以 root 用户身份登录的位置。该文件应保留为空，以便任何人都不能从终端上这样做。</p><h3><span id="限制-su">限制 su</span></h3><p>su 可让您从终端切换用户。默认情况下，它尝试以 root 用户身份登录。要将 su 的使用限制在 wheel 组中，请编辑 <code>/etc/pam.d/su</code> 和 <code>/etc/pam.d/su-l</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth required pam_wheel.so use_uid</span><br></pre></td></tr></table></figure><p>您应该在 wheel 组中拥有尽可能少的用户。</p><h3><span id="锁定-root-账户">锁定 root 账户</span></h3><p>要锁定 root 帐户以防止任何人以 root 身份登录，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -l root</span><br></pre></td></tr></table></figure><p>在执行此操作之前，请确保您具有获取根的替代方法（例如，从活动 USB 引导并更改为文件系统的chroot ），以免您无意中将自己锁定在系统之外。</p><h3><span id="拒绝通过-ssh-的远程-root-登陆">拒绝通过 SSH 的远程 root 登陆</span></h3><p>为了防止某人通过 SSH 以 root 身份登录，请编辑 <code>/etc/ssh/sshd_config</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br></pre></td></tr></table></figure><h3><span id="增加散列回合数">增加散列回合数</span></h3><p>您可以增加 shadow 使用的哈希回合数，从而通过迫使攻击者计算更多的哈希值来破解您的密码，从而提高哈希密码的安全性。默认情况下，shadow 使用 5000 次回合，但是您可以将其增加到任意数量。尽管配置的回合越多，登录速度就越慢。编辑 /etc/pam.d/passwd 并添加回合选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password required pam_unix.so sha512 shadow nullok rounds&#x3D;65536</span><br></pre></td></tr></table></figure><p>这使 shadow 执行 65536 次散列回合。</p><p>应用此设置后，密码不会自动重新加密，因此您需要使用以下方法重置密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd $username</span><br></pre></td></tr></table></figure><h3><span id="限制-xorg-root-访问">限制 Xorg root 访问</span></h3><p>默认情况下，某些发行版以 root 用户身份运行 Xorg，这是一个问题，因为 Xorg 包含大量古老而又复杂的代码，这增加了巨大的攻击面，并使其更有可能拥有可以获取 root 特权的漏洞利用程序。要阻止它作为 root 用户执行，请编辑 <code>/etc/X11/Xwrapper.config</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">needs_root_rights &#x3D; no</span><br></pre></td></tr></table></figure><h3><span id="安全访问root">安全访问root</span></h3><p>恶意软件可以使用多种方法来嗅探 root 帐户的密码。因此，访问根帐户的传统方式是不安全的，最好根本不访问根，但这实际上是不可行的。本节详细介绍了访问根帐户的最安全方法。在安装操作系统后，应立即应用这些说明，以确保该软件不含恶意软件。</p><p>您绝对不能使用普通用户帐户访问 root，因为 root 可能已被盗用。您也不能直接登录到根帐户。通过执行以下操作，创建一个单独的“管理员”用户帐户，该帐户仅用于访问 root 用户，而不能用于访问其他用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd admin</span><br></pre></td></tr></table></figure><p>执行并来设置一个非常强的密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd admin</span><br></pre></td></tr></table></figure><p>仅允许该帐户使用您首选的权限提升机制。例如，如果使用 sudo，则通过执行以下命令来添加 sudoers异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo -f &#x2F;etc&#x2F;sudoers.d&#x2F;admin-account</span><br></pre></td></tr></table></figure><p>然后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>确保没有其他帐户可以访问 sudo（或您的首选机制）</p><p>现在，要实际登录到该帐户，请先重新启动-例如，这可以防止受损的窗口管理器执行登录欺骗。当提供登录提示时，请通过按键盘上的以下组合键来激活安全注意键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alt + SysRq + k</span><br></pre></td></tr></table></figure><p>这将杀死当前虚拟控制台上的所有应用程序，从而克服登录欺骗攻击。现在，您可以安全地登录到您的管理员帐户，并使用 root 用户执行任务。完成后，注销管理员帐户，然后重新登录到非特权用户帐户。</p><h2><span id="防火墙">防火墙</span></h2><p>防火墙可以控制传入和传出的网络流量，并且可以用来阻止或允许某些类型的流量。除非有特殊原因，否则应始终阻止所有传入流量。建议设置严格的 iptables 或 nftables 防火墙。火墙必须针对您的系统进行微调，并且没有一个适合所有防火墙的规则集。建议您熟悉创建防火墙规则。<a href="https://href.li/?https://wiki.archlinux.org/index.php/Iptables" target="_blank" rel="noopener">Arch Wiki</a>和<a href="https://href.li/?https://linux.die.net/man/8/iptables" target="_blank" rel="noopener">手册页</a>都是很好的资源。</p><p>这是基本 iptables 配置的示例，该配置禁止所有传入的网络流量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD DROP [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">:TCP - [0:0]</span><br><span class="line">:UDP - [0:0]</span><br><span class="line">-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -m conntrack --ctstate INVALID -j DROP</span><br><span class="line">-A INPUT -p udp -m conntrack --ctstate NEW -j UDP</span><br><span class="line">-A INPUT -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP</span><br><span class="line">-A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">-A INPUT -p tcp -j REJECT --reject-with tcp-reset</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-proto-unreachable</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p>但是，您不应尝试在实际系统上使用此示例。它仅适用于某些台式机系统。</p><h2><span id="身份标识">身份标识</span></h2><p>为了保护隐私，最好最大程度地减少可追溯到您的信息量。</p><h3><span id="主机名和用户名">主机名和用户名</span></h3><p>请勿在主机名或用户名中添加唯一标识的内容。将它们保留为通用名称，例如 “host” 和 “user”，以便它们无法识别您。</p><h3><span id="timezones-locales-keymaps">Timezones / Locales / Keymaps</span></h3><p>如果可能，应将您的时区设置为 “UTC”，将区域设置和键盘映射设置为 “US”。</p><h3><span id="机器id">机器ID</span></h3><p>一个独一无二的机器ID被存储在 <code>/var/lib/dbus/machine-id</code> （ systemd 系统是保存在 <code>/etc/machine-id</code> ）这些应编辑为通用名称，例如<a href="https://href.li/?https://github.com/Whonix/dist-base-files/blob/master/etc/machine-id" target="_blank" rel="noopener">Whonix ID</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b08dfa6083e7567a1921a715000001fb</span><br></pre></td></tr></table></figure><h3><span id="mac地址欺骗">MAC地址欺骗</span></h3><p>MAC 地址是分配给网络接口控制器（NIC）的唯一标识符。每次您连接到网络时（ WIFI 或以太网）则您的 MAC 地址已暴露。这使人们可以使用它来跟踪您并在本地网络上唯一地标识您。</p><p>但您不应该完全随机化 MAC 地址。拥有完全随机的 MAC 地址是显而易见的，并且会对您脱颖而出的行为产生不利影响。</p><p>MAC 地址的 OUI（组织唯一标识符）部分标识芯片组的制造商。对 MAC 地址的这一部分进行随机化处理可能会为您提供以前从未使用过的OUI，数十年来从未使用过的 OUI 或在您所在的地区极为罕见的 OUI，因此使您脱颖而出，很明显地表明您在欺骗 MAC 地址。</p><p>MAC 地址的末尾标识您的特定设备，并且可以用来跟踪您的设备。仅对 MAC 地址的这一部分进行随机化可防止您被跟踪，同时仍使MAC地址看起来可信。</p><p>要欺骗这些地址，请首先执行以下命令找出您的网络接口名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure><p>接下来，安装 macchanger 并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">macchanger -e $network_interface</span><br></pre></td></tr></table></figure><p>要在每次引导时随机分配 MAC 地址，您应该为您的特定初始化系统创建一个初始化脚本。这是 systemd的一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;macchanger on eth0</span><br><span class="line">Wants&#x3D;network-pre.target</span><br><span class="line">Before&#x3D;network-pre.target</span><br><span class="line">BindsTo&#x3D;sys-subsystem-net-devices-eth0.device</span><br><span class="line">After&#x3D;sys-subsystem-net-devices-eth0.device</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;macchanger -e eth0</span><br><span class="line">Type&#x3D;oneshot</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>上面的示例在启动时欺骗了 eth0 接口的 MAC 地址。将 eth0 替换为您的网络接口。</p><h3><span id="时间攻击">时间攻击</span></h3><p>几乎每个系统都有不同的时间。这可用于时钟偏斜指纹攻击，几毫秒的差异足以使用户被暴露识别。</p><h4><span id="icmp时间戳">ICMP时间戳</span></h4><p>ICMP 时间戳会在查询答复中泄漏系统时间。阻止这些攻击的最简单方法是利用防火墙阻止传入连接，或者使内核忽略 ICMP 请求。</p><h4><span id="tcp-时间戳">TCP 时间戳</span></h4><p>TCP 时间戳也会泄漏系统时间。内核尝试通过对每个连接使用随机偏移量来解决此问题，但<a href="https://href.li/?https://forums.whonix.org/t/do-ntp-and-tcp-timestamps-really-leak-your-local-time/7824/10" target="_blank" rel="noopener">这不足以解决问题</a>。因此应该禁用 TCP 时间戳，可以通过使用 sysctl 设置以下内容来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps&#x3D;0</span><br></pre></td></tr></table></figure><h4><span id="tcp-初始化序号">TCP 初始化序号</span></h4><p>TCP 初始序列号（ISN）是泄漏系统时间的另一种方法。为了减轻这种情况，您必须<a href="https://href.li/?https://github.com/0xsirus/tirdad" target="_blank" rel="noopener">安装tirdad内核模块</a>，该模块会生成用于连接的随机ISN。</p><h4><span id="时间同步">时间同步</span></h4><p>时间同步对于匿名性和安全性至关重要。错误的系统时钟可能使您遭受时钟偏斜指纹攻击，或者可以用来为您提供过时的 HTTPS 证书，从而绕过证书到期或吊销。</p><p>最流行的时间同步方法 NTP 是不安全的，因为它未经加密和未经身份验证，因此攻击者可以轻易地拦截和修改请求。NTP 还会以 NTP 时间戳格式泄漏本地系统时间，该格式可用于时钟偏斜指纹识别，如前所述。</p><p>因此，您应该卸载所有 NTP 客户端并禁用 systemd-timesyncd（如果正在使用）。您可以通过安全连接（HTTPS或最好是Torion服务）连接到受信任的网站，而不是 NTP，并从 HTTP 标头中提取当前时间。达到此目的的工具是 sdwdate 或我自己的<a href="https://href.li/?https://gitlab.com/madaidan/secure-time-sync" target="_blank" rel="noopener">安全时间同步工具</a>。</p><h3><span id="按键指纹">按键指纹</span></h3><p>可以通过他们在键盘上输入键的方式来对人进行指纹识别。您可以通过键入速度，在两次按键之间的暂停，每次按键被按下和释放的确切时间等方式来唯一地进行指纹识别。可以使用<a href="https://href.li/?https://www.keytrac.net/en/tryout" target="_blank" rel="noopener">KeyTrac</a>在线进行测试。</p><p><a href="https://href.li/?https://github.com/vmonaco/kloak" target="_blank" rel="noopener">Kloak</a>是一种工具，旨在通过混淆按键和释放事件之间的时间间隔来克服这种跟踪方法。当按键被按下时，它会引入随机延迟，然后由应用程序选择。</p><h2><span id="文件权限">文件权限</span></h2><p>默认情况下，文件的权限是非常宽松的。您应该在整个系统中搜索权限不当的文件和目录，并对其进行限制。例如，在诸如 Debian 之类的某些发行版中，用户的 Home 目录是全局可读的。</p><p>这可以通过执行以下操作来限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 &#x2F;home&#x2F;$user</span><br></pre></td></tr></table></figure><p>另外一些示例是/boot，/usr /src和/ {,usr /} lib/modules 它们包含内核映像，System.map和其他各种文件，所有这些文件都可能泄漏有关内核的敏感信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 &#x2F;boot &#x2F;usr&#x2F;src &#x2F;lib&#x2F;modules &#x2F;usr&#x2F;lib&#x2F;modules</span><br></pre></td></tr></table></figure><p>在基于 Debian 的发行版中，必须使用 dpkg-statoverride 保留文件许可权。否则，它们将在更新期间被覆盖。</p><p>Whonix的<a href="https://href.li/?https://www.whonix.org/wiki/SUID_Disabler_and_Permission_Hardener" target="_blank" rel="noopener">SUID Disabler和Permission Hardener</a>会自动应用本节中详细介绍的步骤。</p><h3><span id="setuid-setgid">setuid / setgid</span></h3><p>Setuid / SUID 允许用户使用二进制文件所有者的特权执行二进制文件。这通常用于允许非特权用户使用通常仅为 root 用户保留的某些功能。因此，许多 SUID 二进制文件都有特权升级安全漏洞的历史记录。 Setgid / SGID 类似，但适用于组而不是用户。要使用 setuid 或 setgid 位查找系统上的所有二进制文件，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -type f \( -perm -4000 -o -perm -2000 \)</span><br></pre></td></tr></table></figure><p>然后，您应该删除不使用的程序上的所有不必要的 setuid / setgid 位，或将其替换为功能。要删除 setuid 位，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-s $path_to_program</span><br></pre></td></tr></table></figure><p>要删除 setgid 位，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod g-s $path_to_program</span><br></pre></td></tr></table></figure><p>要向文件添加功能，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcap $capability+ep $path_to_program</span><br></pre></td></tr></table></figure><p>或者，要删除不必要的功能，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcap -r $path_to_program</span><br></pre></td></tr></table></figure><h3><span id="umask">umask</span></h3><p>umask 设置新创建文件的默认文件权限。默认的 umask 是0022，它不是很安全，因为它为系统上的每个用户提供了对新创建文件的读取访问权限。要使所有者以外的任何人都不可读新文件，请编辑 /etc/profile 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask 0077</span><br></pre></td></tr></table></figure><h2><span id="核心转储">核心转储</span></h2><p>核心转储包含特定时间（通常是该程序崩溃时）该程序的已记录内存。它们可能包含敏感信息，例如密码和加密密钥，因此必须将其禁用。</p><p>禁用它们的方法主要有三种：sysctl，systemd 和 ulimit</p><h3><span id="sysctl">sysctl</span></h3><p>通过 sysctl 设置以下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.core_pattern&#x3D;|&#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><h3><span id="systemd">systemd</span></h3><p>创建 <code>/etc/systemd/coredump.conf.d/disable.conf</code> 并添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Coredump]</span><br><span class="line">Storage&#x3D;none</span><br></pre></td></tr></table></figure><h3><span id="ulimit">ulimit</span></h3><p>编辑/etc/security/limits.conf并添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* hard core 0</span><br></pre></td></tr></table></figure><h3><span id="setuid进程">setuid进程</span></h3><p>即使在进行了这些设置之后，以提升的特权运行的进程仍可能会转储其内存。</p><p>为了防止他们这样做，请通过 sysctl 设置以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.suid_dumpable&#x3D;0</span><br></pre></td></tr></table></figure><h2><span id="swap">Swap</span></h2><p>与核心转储类似，交换或分页将部分内存复制到磁盘，其中可能包含敏感信息。应该将内核配置为仅在绝对必要时进行交换，相应的 sysctl 设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness&#x3D;1</span><br></pre></td></tr></table></figure><h2><span id="pam">PAM</span></h2><p>PAM 是用于用户身份验证的框架。这就是您登录时使用的机制。您可以通过要求使用强密码或在失败的登录尝试后强制执行延迟验证来使其更加安全。</p><p>要强制使用强密码，可以使用 pam_pwquality。它强制执行密码的可配置策略。例如，如果您希望密码至少包含 16 个字符（最小），与旧密码（difok）至少 6 个不同的字符，至少 3 个数字（dcredit），至少 2 个大写字母（ucredit），至少 2 个字符小写字母（lcredit）和至少 3 个其他字符（ocredit），然后编辑 /etc/pam.d/passwd 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password required pam_pwquality.so retry&#x3D;2 minlen&#x3D;16 difok&#x3D;6 dcredit&#x3D;-3 ucredit&#x3D;-2 lcredit&#x3D;-2 ocredit&#x3D;-3 enforce_for_root</span><br><span class="line">password required pam_unix.so use_authtok sha512 shadow</span><br></pre></td></tr></table></figure><p>要强制执行延迟验证，可以使用 pam_faildelay。要在两次失败的登录尝试之间添加至少4秒的延迟以阻止暴力破解尝试，请编辑 /etc/pam.d/system-login 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth optional pam_faildelay.so delay&#x3D;4000000</span><br></pre></td></tr></table></figure><p>4000000 是 4 秒（以微秒为单位）。</p><h2><span id="microcode更新">Microcode更新</span></h2><p>Microcode 更新对于修复关键的 CPU 漏洞（如 Meltdown 和 Spectre 等）至关重要。大多数发行版都将这些发行版包含在其软件仓库中，例如<a href="https://href.li/?https://wiki.archlinux.org/index.php/Microcode" target="_blank" rel="noopener">Arch Linux</a>和<a href="https://href.li/?https://wiki.debian.org/Microcode" target="_blank" rel="noopener">Debian</a>。</p><h2><span id="ipv6-隐私扩展">IPv6 隐私扩展</span></h2><p>IPv6 地址是从计算机的 MAC 地址生成的，从而使您的 IPv6 地址是唯一的，并直接绑定到计算机。隐私扩展会生成一个随机的 IPv6 地址，以减轻这种形式的跟踪。请注意，如果您开启了 MAC 地址欺骗机制或禁用了 IPv6，则无需执行这些步骤。</p><p>要启用这些功能，请通过sysctl设置以下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.use_tempaddr&#x3D;2</span><br><span class="line">net.ipv6.conf.default.use_tempaddr&#x3D;2</span><br></pre></td></tr></table></figure><h3><span id="networkmanager">NetworkManager</span></h3><p>要为NetworkManager启用隐私扩展，请编辑 <code>/etc/NetworkManager/NetworkManager.conf</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[connection]</span><br><span class="line">ipv6.ip6-privacy&#x3D;2</span><br></pre></td></tr></table></figure><h3><span id="systemd-networkd">systemd-networkd</span></h3><p>要为 systemd-networkd 启用隐私扩展，请创建 <code>/etc/systemd/network/ipv6-privacy.conf</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Network]</span><br><span class="line">IPv6PrivacyExtensions&#x3D;kernel</span><br></pre></td></tr></table></figure><h3><span id="分区和挂载选项">分区和挂载选项</span></h3><p>文件系统应分为多个分区，以对其权限进行细粒度控制。可以添加不同的安装选项以限制可以执行的操作：</p><ul><li>nodev - 禁止使用设备</li><li>nosuid - 禁止setuid或setgid位</li><li>noexec - 禁止执行任何二进制文件</li></ul><p>这些安装选项应在 /etc/fstab 中尽可能设置。如果您不能使用单独的分区，请创建绑定挂载。一个更安全的 /etc/fstab 的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;        &#x2F;          ext4    defaults                              1 1</span><br><span class="line">&#x2F;home    &#x2F;home      ext4    defaults,nosuid,noexec,nodev          1 2</span><br><span class="line">&#x2F;tmp     &#x2F;tmp       ext4    defaults,bind,nosuid,noexec,nodev     1 2</span><br><span class="line">&#x2F;var     &#x2F;var       ext4    defaults,bind,nosuid                  1 2</span><br><span class="line">&#x2F;boot    &#x2F;boot      ext4    defaults,nosuid,noexec,nodev          1 2</span><br></pre></td></tr></table></figure><p>请注意，可以<a href="https://href.li/?https://chromium.googlesource.com/chromiumos/docs/+/master/security/noexec_shell_scripts.md" target="_blank" rel="noopener">通过shell脚本绕过noexec</a>。</p><h2><span id="熵">熵</span></h2><p>熵基本上反应操作系统信息收集的随机程度，对于诸如加密之类的事情至关重要。因此，最好通过安装其他随机数生成器（如<a href="https://href.li/?http://www.issihosts.com/haveged/" target="_blank" rel="noopener">haveged</a>和<a href="https://href.li/?https://github.com/smuellerDD/jitterentropy-rngd" target="_blank" rel="noopener">jitterentropy</a>）从各种来源收集尽可能多的熵。</p><p>为了使jitterentropy正确运行，必须通过创建 <code>/usr/lib/modules-load.d/jitterentropy.conf</code> 并添加以下内容尽早加载内核模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jitterentropy_rng</span><br></pre></td></tr></table></figure><h3><span id="rdrand">RDRAND</span></h3><p>RDRAN 是提供随机数的 CPU 指令。如果可用，内核会自动将其用作熵源。但是由于它是专有的并且是 CPU 身的一部分，因此无法审核和验证其安全性。您甚至无法对代码进行反向工程。该RNG以前曾遭受过漏洞的攻击，其中有些可能是后门攻击。通过设置以下引导参数可以不信任此功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random.trust_cpu&#x3D;off</span><br></pre></td></tr></table></figure><h2><span id="以-root-身份编辑文件">以 root 身份编辑文件</span></h2><p>建议不要以 root 用户身份运行普通的文本编辑器。大多数文本编辑器可以做的不仅仅是简单地编辑文本文件，而且还可以被利用。例如，以 root 身份打开 vi 并输入：sh。现在，您具有一个可以访问整个系统的 root shell，攻击者可以轻松利用该 shell。</p><p>解决方案是使用 sudoedit。这会将文件复制到一个临时位置，以普通用户身份打开文本编辑器，编辑该临时文件并以root用户身份覆盖原始文件。这样，实际的编辑器就不会以 root 身份运行。要使用 sudoedit，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudoedit $path_to_file</span><br></pre></td></tr></table></figure><p>默认情况下，它使用 vi，但是可以通过 EDITOR 或 SUDO_EDITOR 环境变量来切换默认编辑器。例如，要使用 nano，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR&#x3D;nano sudoedit $path_to_file</span><br></pre></td></tr></table></figure><p>可以在 /etc/environment 中全局设置此环境变量。</p><h2><span id="特定发行版的安全强化">特定发行版的安全强化</span></h2><h3><span id="http包管理器镜像">HTTP包管理器镜像</span></h3><p>默认情况下，Linux发行版通常使用 HTTP 或 HTTP 和 HTTPS 镜像的混合来从其软件存储库下载软件包。人们认为这很好，因为程序包管理器会在安装前验证程序包的签名。但是，从历史上看，已经有很多绕过此方法的地方。您应将软件包管理器配置为从 HTTPS 镜像专门下载以进行深度防御。</p><h3><span id="apt-seccomp-bpf">APT seccomp-bpf</span></h3><p>自软件包管理器 Debian Buster 以来，APT 已支持可选的 seccomp-bpf 过滤。这限制了允许执行APT的系统调用，这可能严重限制攻击者尝试利用APT中的漏洞时对系统造成危害的能力。要启用此功能，请创建 <code>/etc/apt/apt.conf.d/40sandbox</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APT::Sandbox::Seccomp &quot;true&quot;;</span><br></pre></td></tr></table></figure><h2><span id="物理安全">物理安全</span></h2><p>全盘加密可确保对驱动器上的所有数据进行加密，并且不会被物理攻击者读取。大多数发行版都支持在安装过程中启用加密，请确保设置了强密码。您也可以使用<a href="https://href.li/?https://wiki.archlinux.org/index.php/Dm-crypt" target="_blank" rel="noopener">dm-crypt</a>手动加密驱动器。</p><p>请注意，全盘加密不包括 /boot，这样仍然可以修改内核、引导加载程序和其他关键文件。为了完全防止篡改，您还必须实施经过验证的引导。</p><h3><span id="bios-uefi强化">BIOS / UEFI强化</span></h3><p>如果您仍在使用旧版 BIOS，则应迁移到 UEFI，以利用较新的安全功能。大多数 BIOS 或 UEFI 实现都支持设置密码。最好启用它并设置一个非常强壮的密码。虽然这是很弱的保护，因为重置密码很简单。它通常存储在易失性内存中，因此攻击者只需要能够卸下 CMOS 电池几秒钟，或者他们就可以使用某些主板上的跳线将其重置。</p><p>您还应该禁用所有未使用的设备和引导选项，例如USB引导，以减少攻击面。</p><p>别忽略 BIOS 或 UEFI 的更新，确保将其更新。将其与常规操作系统更新一样重要。</p><p>此外，请参阅<a href="https://href.li/?https://github.com/nsacyber/Hardware-and-Firmware-Security-Guidance" target="_blank" rel="noopener">《NSA的硬件和固件安全指南》</a></p><h3><span id="bootloader-密码">Bootloader 密码</span></h3><p>引导加载程序会在引导过程的早期执行，并负责加载操作系统。保护它非常重要，否则，它可能会被篡改。例如，本地攻击者可以通过在启动时使用 <code>init=/bin/bash</code> 作为内核参数来轻松获得 root shell，该命令告诉内核执行 /bin/bash 而不是常规的 init 系统。您可以通过为引导加载程序设置密码来防止这种情况。仅设置引导程序密码不足以完全保护它。还必须按照以下说明设置经过验证的启动。</p><h4><span id="grub">Grub</span></h4><p>要为 GRUB 设置密码，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkpasswd-pbkdf2</span><br></pre></td></tr></table></figure><p>输入您的密码，该密码将生成一个字符串。它将类似于 &quot;grub.pbkdf2.sha512.10000.C4009… &quot; 。创建 <code>/etc/grub.d/40_password</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set superusers&#x3D;&quot;$username&quot;</span><br><span class="line">password_pbkdf2 $username $password</span><br></pre></td></tr></table></figure><p>用 grub-mkpasswd-pbkdf2 生成的字符串替换 “$password”。 “$username” 将用于被允许使用GRUB命令行，编辑菜单项和执行任何菜单项的超级用户。对于大多数人来说，这只是 &quot;root”。</p><p>重新生成您的配置文件，GRUB 现在将受到密码保护。</p><p>要仅限制编辑引导参数并访问 GRUB 控制台，同时仍然允许您引导，请编辑 <code>/boot/grub/grub.cfg</code> 并在 &quot;menuentry $OSName &quot; 旁边添加 <code>-–unrestricted</code> 参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menuentry &#39;Arch Linux&#39; --unrestricted</span><br></pre></td></tr></table></figure><p>您将需要再次重新生成配置文件以应用此更改。</p><h3><span id="syslinux">Syslinux</span></h3><p>Syslinux 可以设置主密码或菜单密码。引导任何条目都需要主密码，而引导特定条目仅需要菜单密码。</p><p>要为 Syslinux 设置主密码，请编辑 <code>/boot/syslinux/syslinux.cfg</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MENU MASTER PASSWD $password</span><br></pre></td></tr></table></figure><p>要设置菜单密码，请编辑 <code>/boot/syslinux/syslinux.cfg</code> ，并在带有您要密码保护的项目的标签内，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MENU PASSWD $password</span><br></pre></td></tr></table></figure><p>将 “$password” 替换为您要设置的密码。</p><p>这些密码可以是纯文本，也可以使用MD5，SHA-1，SHA-256 或 SHA-512 进行散列。建议先使用强哈希算法（例如SHA-256或SHA-512）对密码进行哈希处理，以避免将其存储为明文形式。</p><h3><span id="systemd-boot">systemd-boot</span></h3><p>systemd-boot 具有防止在引导时编辑内核参数的选项。在 loader.conf文件中，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editor no</span><br></pre></td></tr></table></figure><p>systemd-boot 并不正式支持保护内核参数编辑器的密码，但是您可以<a href="https://href.li/?https://github.com/kitsunyan/systemd-boot-password" target="_blank" rel="noopener">使用systemd-boot-password来实现</a>。</p><h3><span id="验证引导">验证引导</span></h3><p>经过验证的引导通过密码验证来确保引导链和基本系统的完整性。这可用于确保物理攻击者无法修改设备上的软件。</p><p>如果没有经过验证的引导，则一旦获得物理访问权限，就可以轻松绕过上述所有预防措施。经过验证的引导不仅像许多人认为的那样是为了物理安全。它还可以用于防止远程恶意软件持久化——如果攻击者设法破坏了整个系统并获得了很高的特权，则经过验证的引导将在重新引导后还原其更改，并确保它们无法持久化。</p><p>经过验证的最常见的引导实现是UEFI安全引导，但是它本身并不是一个完整的实现，因为它仅会验证引导加载程序和内核，这意味着可以通过以下方法：</p><ul><li>仅UEFI安全启动就没有一成不变的信任根，因此物理攻击者仍然可以刷新设备的固件。为了减轻这种情况，请结合使用UEFI安全启动和 Intel Boot Guard 或 AMD Secure Boot。</li><li>远程攻击者（或不使用加密的物理攻击者）可以简单地修改操作系统的任何其他特权部分。例如，如果他们有修改内核的特权，那么他们也可以修改 /sbin/init 来有效地获得相同的结果。因此，仅验证内核和引导加载程序不会对远程攻击者产生任何影响。为了减轻这种情况，您必须使用<a href="https://href.li/?https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/verity.html" target="_blank" rel="noopener">dm-verity</a>验证基本操作系统，尽管由于传统Linux发行版的布局，这非常困难且笨拙。</li></ul><p>通常，很难在传统Linux上实现可靠的经过验证的引导实现。</p><h3><span id="usbs">USBs</span></h3><p>USB设备为物理攻击提供了重要的攻击面。例如<a href="https://href.li/?https://srlabs.de/bites/badusb/" target="_blank" rel="noopener">BadUSB</a>和<a href="https://href.li/?https://en.wikipedia.org/wiki/Stuxnet" target="_blank" rel="noopener">Stuxnet</a>是此类攻击的范例。最佳实践是禁止所有新连接的USB且仅将受信任设备列入白名单，<a href="https://href.li/?https://usbguard.github.io/" target="_blank" rel="noopener">USBGuard</a>对此非常有用。</p><p>您也可以将nousb用作内核引导参数，以禁用内核中的所有USB支持。可以 sysctl 设置kernel.deny_new_usb=1</p><h3><span id="dma攻击">DMA攻击</span></h3><p>直接内存访问（DMA）攻击涉及通过插入某些物理设备来完全访问所有系统内存。这可以通过控制设备可访问的内存区域的<a href="https://href.li/?https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit" target="_blank" rel="noopener">IOMMU</a>或将特别易受攻击的内核模块列入黑名单来缓解。</p><p>要启用 IOMMU，请设置以下内核引导参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intel_iommu&#x3D;on amd_iommu&#x3D;on</span><br></pre></td></tr></table></figure><p>您只需要为特定的 CPU 制造商启用该选项，但同时启用这两个选项就没有问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efi&#x3D;disable_early_pci_dma</span><br></pre></td></tr></table></figure><p>通过在非常早的启动过程中禁用所有 PCI 桥接器上的 busmaster 位，此选项可<a href="https://href.li/?https://mjg59.dreamwidth.org/54433.html" target="_blank" rel="noopener">修复上述IOMMU中的漏洞</a>。</p><p>此外，Thunderbolt 和 FireWire 通常容易受到 DMA 攻击。要禁用它们，请将这些内核模块列入黑名单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install firewire-core &#x2F;bin&#x2F;false</span><br><span class="line">install thunderbolt &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><h3><span id="冷启动攻击">冷启动攻击</span></h3><p>当攻击者在擦除 RAM 中的数据之前对其进行分析时，就会发生<a href="https://href.li/?https://en.wikipedia.org/wiki/Cold_boot_attack" target="_blank" rel="noopener">冷启动攻击</a>。使用现代 RAM 时，冷启动攻击不太实用，因为 RAM 通常会在几秒钟或几分钟内清除，除非将其放入冷却液（如液氮或冷冻机）中。攻击者必须在几秒钟内将设备中的RAM棒拔出并将其暴露于液氮中，而且确保用户不会注意到。</p><p>如果冷启动攻击是威胁模型的一部分，请在关机后保护计算机几分钟，以确保没有人可以访问您的 RAM 记忆棒。您也可以将 RAM 棒焊接到主板上，以使其更难以卡住。如果使用笔记本电脑，请取出电池，然后直接用充电电缆供电。关机后请拔出电缆，以确保RAM彻底断电无法访问。</p><p>在内核自我保护启动参数部分中，空闲时内存清零选项将用零覆盖内存中的敏感数据。此外，强化的内存分配器可以通过 <code>CONFIG_ZERO_ON_FREE</code> 配置选项清除用户空间堆内存中的敏感数据。尽管如此，某些数据仍可能保留在内存中。</p><p>此外，现代内核还包括<a href="https://href.li/?https://lwn.net/Articles/730006/" target="_blank" rel="noopener">复位攻击缓解</a>措施，该命令可命令固件在关机时擦除数据，尽管这需要<a href="https://href.li/?https://www.trustedcomputinggroup.org/wp-content/uploads/Platform-Reset-Attack-Mitigation-Specification.pdf" target="_blank" rel="noopener">固件支持</a>。</p><p>确保正常关闭计算机，以使上述缓解措施可以开始。</p><p>如果以上都不适用您的威胁模型，则可以实施<a href="https://href.li/?https://tails.boum.org/contribute/design/memory_erasure/" target="_blank" rel="noopener">Tails的内存擦除过程</a>，该过程将擦除大部分内存（视频内存除外），并且已被证明是有效的。</p><h2><span id="最佳实践">最佳实践</span></h2><p>一旦对系统进行了尽可能多的加固，就应该遵循良好的隐私和安全性惯例：</p><ul><li>禁用或删除不需要的东西以最小化攻击面。</li><li>保持更新。配置 cron 任务或 init 脚本以每天更新系统。</li><li>不要泄漏有关您或您的系统的任何信息，无论它看起来多么渺小。</li><li>遵循<a href="https://href.li/?https://madaidans-insecurities.github.io/security-privacy-advice.html" target="_blank" rel="noopener">常规的安全和隐私建议</a></li></ul><p>尽管已经进行了强化，但您必须记住 Linux 仍然是一个有缺陷的操作系统，没有任何强化可以完全修复它。</p><h2><span id="其他指南">其他指南</span></h2><p>您应该进行尽可能多的研究，而不要依赖单一的信息来源。最大的安全问题之一就是用户。这些是我认为有价值的其他指南的链接：</p><ul><li><p><a href="https://href.li/?https://wiki.archlinux.org/index.php/Security" target="_blank" rel="noopener">Arch Linux Security wiki page</a></p></li><li><p><a href="https://href.li/?https://www.whonix.org/wiki/Documentation" target="_blank" rel="noopener">Whonix Documentation</a></p></li><li><p><a href="https://href.li/?https://apps.nsa.gov/iaarchive/library/ia-guidance/security-configuration/operating-systems/guide-to-the-secure-configuration-of-red-hat-enterprise.cfm" target="_blank" rel="noopener">NSA RHEL 5 Hardening Guide</a> (稍有过时，但仍包含有用的信息）</p></li><li><p><a href="https://href.li/?https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings" target="_blank" rel="noopener">KSPP recommended kernel settings</a></p></li><li><p><a href="https://href.li/?https://github.com/a13xp0p0v/kconfig-hardened-check/" target="_blank" rel="noopener">kconfig-hardened-check</a></p></li></ul><h2><span id="术语">术语</span></h2><p>您可能需要重新生成 GRUB 配置，以应用对引导加载程序所做的某些更改。在不同的发行版之间，执行此操作的步骤有时可能会有所不同。例如，在诸如 Arch Linux 之类的发行版上，应通过执行以下命令来重新生成配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o $path_to_grub_config</span><br></pre></td></tr></table></figure><p>“$path_to_grub_config” 取决于您如何设置系统。它通常是 <code>/boot/grub/grub.cfg</code>或 <code>/boot/EFI/grub/grub.cfg</code>，但是在执行此命令之前，请务必确保正确。</p><p>另外，在 Debian 或 Ubuntu 等发行版上，您应该执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure><h2><span id="能力">能力</span></h2><p>在 Linux 内核中，“root 特权” 分为各种不同的能力（<a href="https://href.li/?https://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">capabilities</a>）。这在应用最小特权原则时很有帮助——可以给它们仅授予特定的子集，而不是授予进程总的 root 特权。例如，如果程序只需要设置系统时间，则只需要 CAP_SYS_TIME 而不是 root 所有能力。这会限制可能造成的损害，但是，您仍必须谨慎授予能力，因为无论如何，其中许多能力<a href="https://href.li/?https://forums.grsecurity.net/viewtopic.php?t=2522" target="_blank" rel="noopener">可能会被滥用以获取完整的root特权</a>。</p><p>本文翻译自：<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html" target="_blank" rel="noopener">https://madaidans-insecurities.github.io/guides/linux-hardening.html</a></p><p><strong>如需『 Linux 系统安全强化指南 』PDF 高清版，可在公众号对话框回复关键字：「<code>LinuxSecurity</code>」获取。</strong></p><blockquote><p>本文转载自：「 GAO CHAO’S NEW BLOG 」，原文：<a href="http://t.cn/A6VwHzjQ" target="_blank" rel="noopener">http://t.cn/A6VwHzjQ</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本指南旨在说明如何尽可能地加强 Linux 的安全性和隐私性，并且不限于任何特定的指南。&lt;/p&gt;
&lt;p&gt;免责声明：如果您不确定自己在做什么，请不要尝试在本文中使用任何内容。&lt;/p&gt;
&lt;p&gt;本指南仅关注安全性和隐私性，而不关注性能，可用性或其他内容。&lt;/p&gt;
&lt;p&gt;列出的所有命令都将需要 root 特权。以 &lt;code&gt;$&lt;/code&gt; 符号开头的单词表示一个变量，不同终端之间可能会有所不同。&lt;/p&gt;
&lt;h2 id=&quot;选择正确的Linux发行版&quot;&gt;选择正确的Linux发行版&lt;/h2&gt;
&lt;p&gt;选择一个好的 Linux 发行版有很多因素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;避免分发冻结程序包，因为它们在安全更新中通常很落后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用与 Systemd 机制的发行版。 Systemd 包含许多不必要的攻击面；它尝试做的事情远远超出了必要，并且超出了初始化系统应做的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 musl 作为默认的 C 库。 Musl 专注于最小化，这会导致很小的攻击面，而其他 C 库（例如 glibc）过于复杂，容易产生漏洞。例如，与 musl 中的极少数漏洞相比，glibc 中的一百多个漏洞已被公开披露。尽管仅靠披露的 CVE 本身通常是不准确的统计信息，但有时这种情况有时可以用来表示过分的问题。 Musl还具有不错的漏洞利用缓解措施，尤其是其新的强化内存分配器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最好默认情况下使用 LibreSSL 而不是 OpenSSL 的发行版。OpenSSL 包含大量完全不必要的攻击面，并且遵循不良的安全做法。例如，它仍然保持 OS / 2和 VMS 支持这些已有数十年历史的古老操作系统。这些令人讨厌的安全做法导致了可怕的 Heartbleed 漏洞。LibreSSL 是 OpenBSD 团队的 OpenSSL 分支，它采用了出色的编程实践并消除了很多攻击面。在 LibreSSL 成立的第一年内，它缓解了许多漏洞，其中包括一些高严重性的漏洞。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用作强化操作系统基础的最佳发行版是 Gentoo Linux，因为它可以让您精确地配置系统，以达到理想的效果，这将非常有用，尤其是参考我们在后面的章节中使用更安全的编译标志。&lt;/p&gt;
&lt;p&gt;但是，由于 Gentoo 的巨大可用性缺陷，它对于许多人来说可能并不顺手。在这种情况下，Void Linux的 Musl 构建是一个很好的折衷方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="安全" scheme="https://www.hi-linux.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>小白也能看懂的网络基础 | 02 连接设备？</title>
    <link href="https://www.hi-linux.com/posts/50201.html"/>
    <id>https://www.hi-linux.com/posts/50201.html</id>
    <published>2021-05-21T01:00:00.000Z</published>
    <updated>2021-05-21T10:02:25.206Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言">引言</span></h2><p>欢迎来到网络世界，《小白也能看懂的网络基础》系列文章会从零开始帮助你构建网络的基础知识。如果你完全没有接触过网络相关的内容，那我们是一样的，在学习过程中我们肯定遇到了相同的问题！写下这些文章一方面要记录自己的学习历程，另一方面也希望帮到同样想要学习网络基础的小伙伴。</p><p>文章的部分内容与素材是我从【Youtube平台】的【<a href="https://www.youtube.com/channel/UCtuXekfqj-paqsxtqVNCC2A" target="_blank" rel="noopener">Network Direction</a>】发布的系列视频学习和搜集过来的，翻译不易，部分内容可能无法做到尽善尽美，甚至可能会有部分瑕疵，我会尽力让文章内容通俗易懂，覆盖全面。若各位小伙伴发现任何问题，希望能够留言或私信告诉我，在下不胜感激！当然，我也会在第一时间进行更正。</p><p>在往后的每一篇文章中，我都会把看到文章的小伙伴当成是完全没有网络经验的小白，我的目标是和零基础小白一起建立坚实的网络基础，网络大神请略过此系列文章。</p><p>让我们开始网络之旅吧！</p><a id="more"></a><h2><span id="线缆和-wi-fi">线缆和 Wi-Fi</span></h2><h3><span id="1连接设备">1.连接设备</span></h3><p>首先我们需要知道，想要将设备连接到网络，有两种方式可供选择，那就是「<strong>有线和无线</strong>」。</p><p>相信大家对这两兄弟都不陌生了，有线连接从很早以前就出现了，最早可追溯到1960年代，有线网络使用电缆进行连接。</p><p>而无线技术的发展，也已经有相当长的一段历史了，最早可追溯到1990年代。说到无线，我们最先想到的就是与它相关的移动设备，例如：收音机、手机、便携式笔记本电脑等。对于无线技术，我们经常称它为「Wi-Fi」。</p><p><img src="https://img.hi-linux.com/staticfile/a4eb6a3ea8ddc076a20906b97cd2cfa1-2021-03-17-ssNJJ7.gif" alt="有线和无线"></p><h4><span id="1-有线设备">1. 有线设备</span></h4><p>电缆通常使用铜线制成，铜缆更便宜，常用于短距离传输，同时因为它是使用电信号进行信息传播，这就意味着它可能会受到外界电磁干扰的影响，所以，我们常见的网线多由多股线栏缠绕制成，后面的小节会讲到原因。</p><p>光纤通常使用玻璃作为传输介质，可用于较长距离信号传输，因其使用光信号，所以不易受外界信号干扰，但因为其材质的特殊，导致光纤的价格通常都比较昂贵。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140149102-2021-03-16-BzMdPa.png" alt></p><table><thead><tr><th><strong>铜缆</strong></th><th><strong>光纤</strong></th></tr></thead><tbody><tr><td>铜丝制作</td><td>玻璃制作</td></tr><tr><td>更便宜</td><td>更昂贵</td></tr><tr><td>短距离传输</td><td>较长距离传输</td></tr><tr><td>使用电信号</td><td>使用光信号</td></tr><tr><td>容易受到外界干扰</td><td>不受外界干扰</td></tr></tbody></table><h4><span id="2-无线设备">2. 无线设备</span></h4><p>无论是台式机，还是移动笔记本，或者是手机平板电脑，如果想要实现无线连接，就必须配备无线网卡，大部分情况下，台式机是没有无线网卡的，因此需要单独购买无线网卡，可以直接通过USB连接以实现无线上网。</p><h2><span id="以太网协议">以太网协议</span></h2><p>由于 <strong>「以太网」</strong> 构建简单、成本低、可扩展性强、与IP网能够很好地结合等特点，使它成为局域网网络构建中最常用的一种技术。对于 <strong>「以太网协议」</strong>，则代表了接入以太网的节点设备都达成一致的一组规则。想要接入以太网，就必须按 <strong>「合同」</strong> 办事儿。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-4rjH9z.gif" alt="以太网"></p><p><strong>「以太网」</strong> 由许多不同的部分组成，其中一部分描述了 <strong>线缆的类型</strong> 以及 <strong>不同线缆的传输速度</strong>；另一部分则描述了数据应该 <strong>如何进行格式化</strong> 和 <strong>发送</strong> 的操作，这部分被称为 <strong>「媒体访问控制」</strong>。</p><p><strong>「以太网」</strong> 这样来分层的主要原因，是为了兼容不同线缆以不同速度访问不同的设备，却依然能够保证设备间的正常通信，毕竟我们无法保证每台设备、线缆及其传输速度都相同，差异性是不可避免的问题！</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-bpNhFR.gif" alt="本地主机访问服务器"></p><p>举个例子：一个具有 1G b网络带宽的本地主机，想要将数据发送到具有10Gb带宽的服务器上，这中间经历了哪些操作？</p><p>首先，本地主机根据「媒体访问控制」规则准备一条信息，接下来，再根据它必须遵循的物理规则来发送信息；然后，信息通过物理线缆发送到了服务器这边，当服务器收到消息，它会对这段消息进行解码，并通过「媒体访问控制」，传递到服务器主机。</p><p>正是因为本地主机与服务器主机都遵循了以太网的协议规则，才能保证彼此间的通信不会出现问题，并最终将信息传递到目的地。即使双方使用不同的线缆、带宽与设备， 该分层系统仍然畅通无阻 ！</p><h3><span id="1-以太网协议标准">1. 以太网协议标准</span></h3><p>以太网技术诞生以后，IEEE 组织制定了众多以太网不同的技术标准，每一个标准都会用一段代号来命名（就像007和9527一样）。以 802 开头的标准用于局域网技术。而以太网技术的代号是 <strong>802.3</strong> ，再配合一到两个字母就组成了以太网不同的类型。</p><table><thead><tr><th>速度</th><th>常用名称</th><th>非正式名称</th><th>正式名称</th><th>线缆类型</th><th>最大传输距离</th></tr></thead><tbody><tr><td>10Mbps</td><td>以太网</td><td>10BASE-T</td><td>802.3</td><td>双绞线</td><td>100m</td></tr><tr><td>100Mbps</td><td>快速以太网</td><td>100BASE-T</td><td>802.3u</td><td>双绞线</td><td>100m</td></tr><tr><td>1Gbps</td><td>1吉比特以太网</td><td>1000BASE-LX</td><td>802.3z</td><td>光纤</td><td>5000m</td></tr><tr><td>1Gbps</td><td>1吉比特以太网</td><td>1000BASE-T</td><td>802.3ab</td><td>双绞线</td><td>100m</td></tr><tr><td>10Gbpx</td><td>10吉比特以太网</td><td>10GBASE-T</td><td>802.3an</td><td>双绞线</td><td>100m</td></tr></tbody></table><p>单独通过正式名称来记忆这些类型实属不易，因此 IEEE 组织还给我们准备了便于记忆的非正式名称。拿 <strong>10GBASE-T</strong> 来举例，里面的 <strong>10G</strong> 代表了其传输速度为 <strong>「10G比特每秒」</strong>，<strong>「比特」</strong> 是传输速率的单位，比特值越高，其传输速度也越快；<strong>BASE = Baseband</strong>(cables) 是 <strong>基带</strong> 的意思，代表它使用数字信号进行传输（另一种是模拟信号）；而后面的 <strong>T</strong> ，则代表了所使用的线缆类型，T=UTP 也就是双绞线（另一种是LX光纤）。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-gleloB.gif" alt="以太网标准"></p><p>我们已经知道了，电缆使用电信号来传输数据；而光纤使用光信号来传输数据；无论使用哪种信号，这里的数据指的都是我们熟知的 <strong>「01代码」</strong>，接收器会对接收到的 <strong>「01代码」</strong> 进行相应解码，这就是所谓的 <strong>「编码方案」。</strong></p><h3><span id="2-电信号">2. 电信号</span></h3><p>首先我们来看一下电信号，想要发送电信号，就需要拥有电路，这意味着我们需要准备多根电线以传输数据，而我们最常见的线缆称为 <strong>「非屏蔽双绞线」</strong>（UTP，也就是常见的网线），每对电线构成一个电路。</p><p><img src="https://img.hi-linux.com/staticfile/d669b71f87224584ff5ffcc4719382f4-2021-03-16-c7n3d4.gif" alt="非屏蔽双绞线（UTP）"></p><p>听名字我们也知道了，它是非屏蔽的线缆，也就意味着如果外界有电磁干扰，它就会受影响，在初中的时候我们就学习过了，电和磁铁是有一定关系的。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-bzNOtC.gif" alt="电磁干扰"></p><p>电流通过铜缆会产生磁场，同时也生成了电力。问题就出在这里，一对平行运行的电线会产生小的电磁场，如果一对铜线有电流经过，则必定会对其旁边的另一对电线的信号产生电磁干扰，我们称其为 <strong>「串扰」</strong>。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-SvuLn5.gif" alt="串扰"></p><p>为了解决 <strong>「串扰」</strong> 的问题，非屏蔽双绞线则将平行的两根铜缆绞在一起，这样一来，就有效的避免了电磁干扰，而这也是它名字的由来。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-EHSYQH.gif" alt="双绞线"></p><p>如果条件允许的话，你可以找到一条废弃的双绞线，将水晶头去掉，观察一下内部的线缆，就可以清晰的看到，线缆确实是绞在一起的。</p><p><img src="https://img.hi-linux.com/staticfile/1da9a14e0901077a05fd8f67703af114-2021-03-16-7LbeG3.gif" alt="真实的双绞线"></p><h3><span id="3-双绞线">3. 双绞线</span></h3><p>我们可以看到多种不同类型的双绞线，有的中间有塑料芯，有的则是一根细线。通常，我们使用颜色对其进行编码，每对电线都是由<strong>纯色</strong>和<strong>条纹色</strong>组成的，观察图片就不难看出。例如蓝色和蓝白线缆绞在一起，而棕色和棕白线缆绞在一起。</p><p>通常，我们常见的网线都是由四对电线组成的，而在早期的标准中，其线缆并不一定是由四对组成的（例如：10BASE-T 和 100BASE-T 都是由两对绞线组成），但是如果想要让传输速度达到1Gbps或10Gbps，就必须使用全部四对电线才可以。</p><p>不同的以太网标准，需要使用不同的线缆，我们应该都听说过 「5类线」 或 「6类线」 这样的名称，其实这就是不同网线的专用术语，不同的类别对应了不同线缆的标准（例如：线缆的对数、线缆的粗细以及线缆的交合程度）。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140149821-2021-03-16-iD7GHf.png" alt="线缆的不同标准"></p><p>例如：Cat2 仅具有两对线缆，而Cat5具有四对线缆，Cat6 具有比 Cat5 更粗的四对线缆等等</p><p>不同类别的线缆会定义不同的名称，除了数字的不同，后面的英文字母也不同，比如：Cat5e，Cat6，Cat6a，数字越大，标准越新，意味着传输距离越远，速度越高！！</p><p>举一个现实一些的案例，我们可以在 100Mbps 的网络上使用5类线；但如果你想让网速达到千兆，就至少需要使用 Cat5e 这样标准的线缆；而如果你想让网速达到万兆，那就需要使用 Cat6 也就是6类网线才能达到理论速度。</p><p>如果你的带宽达到了万兆，但你的线缆跟不上，仅仅使用5类线 Cat5，那你的实际使用网速肯定达不到万兆，其原因是线缆没法支持那么快的速度！</p><p>所以，回家赶紧看看你家网络的带宽是多少，为什么理论速度达到了，可实际使用却达不到那么快的网速，原因可能就是因为你的线缆太老旧了，扔了换新的吧。</p><table><thead><tr><th>线缆名称</th><th>线缆介绍</th><th>线缆速率</th></tr></thead><tbody><tr><td>CAT-1</td><td>以往用在传统电话的网络线路</td><td>无</td></tr><tr><td>CAT-2</td><td>以往用在令牌环网络</td><td>4 Mbit/s</td></tr><tr><td>CAT-3</td><td>提供16MHz的带宽，曾经常用在 10 Mbit/s 以太网络</td><td>10 Mbit/s</td></tr><tr><td>CAT-4</td><td>提供20MHz的带宽，曾经常用在 16 Mbit/s 的令牌环网</td><td>16 Mbit/s</td></tr><tr><td>CAT-5</td><td>提供100MHz的带宽，目前常用在快速以太网（100 Mbit/s）中</td><td>100 Mbit/s</td></tr><tr><td>CAT-5e</td><td>提供125MHz的带宽，目前常用在快速以太网及千兆以太网（1000Mbit/s）中</td><td>1000 Mbit/s</td></tr><tr><td>CAT-6</td><td>提供250MHz的带宽，比CAT-5与CAT-5e高出一倍半</td><td>2500 Mbit/s</td></tr><tr><td>CAT-6A</td><td>提供500MHz的带宽，使用在万兆以太网（10 Gbit/s）中</td><td>10 Gbit/s</td></tr><tr><td>CAT-7</td><td>设计供以600MHz频率传输信号</td><td>未定</td></tr></tbody></table><h3><span id="4-电缆的连接器">4. 电缆的连接器</span></h3><p>我们的线缆两端都会安装一个连接器，这个连接器的名字叫做 <strong>「rj45连接器」</strong>，其实就是我们所说的水晶头，它们是接入到网卡与交换机端口的部分，该连接器有八个引脚，它们与电缆内部的八根铜线对齐，必须按正确的顺序与引脚对齐才能保证通信。</p><p><img src="https://img.hi-linux.com/staticfile/cf3d4d7d0e9a0c5bf3215eb87e13aff8-2021-03-16-57dxiR.gif" alt="线缆与引脚对齐方式"></p><p>大家应该听到过连接线缆的口诀，那就是「橙白橙，绿白蓝，蓝白绿，棕白棕」，这种连接方式称为「568b」，其实就是图示中的这种顺序，确保顺序正确，再将其与水晶头的8个引脚对齐，这样就大功告成了！</p><p><img src="https://img.hi-linux.com/staticfile/127e61edc2578c46acf2e72bea56647e-2021-03-16-hjQZXx.gif" alt="引脚连接"></p><p>在网络通信中，其实就是将一端的 <strong>引脚1对接另一端的引脚1</strong> ，<strong>引脚2对接另一端的引脚2</strong> ，以此类推，因其线缆直通另一端线缆的特性，我们称这种连接方式为 「 <strong>直通电缆(Straight Through)</strong> 」。</p><p><img src="https://img.hi-linux.com/staticfile/31c4a596fa089776220b84cd1e4b140f-2021-03-16-ReBzhU.gif" alt="数据传输与接收"></p><p>这些线缆中的一部分用于<strong>传输数据</strong>，另一部分则用于<strong>接收数据</strong>，在这里，我们使用TX表示传输，TR表示接收，如图所示，第一对引脚就用来传输数据，而第二对引脚则用来接收数据。</p><p><img src="https://img.hi-linux.com/staticfile/056930b3f4c75795fa01bc7e29f135b9-2021-03-16-xRL1sZ.gif" alt="主机直连到交换机"></p><p>当我们将一台主机通过网线接入到交换机上，交换机非常聪明，在它这一端的水晶头接口处，它知道用第一对引脚来接收数据，用第二对引脚来传输数据。也正因为此，它的名字叫做交换机，交换的就是这个位置的信息。</p><p><img src="https://img.hi-linux.com/staticfile/6d389681f72bb6edfdefba7ac1ad9bff-2021-03-16-glvHXk.gif" alt="主机直连到主机（或交换器）"></p><p>但是，如果我们将这台主机的网线接入到另一台主机或路由器，而不是交换机呢？这会遇到什么情况？引脚的排列顺序不对了，它们使用相同的引脚来收发数据，这就导致数据传不出去了呀！所以，我们这里就不能使用「直通电缆」，而需要使用 <strong>「交叉电缆(Crossover)」</strong>，那就是将用于传输数据一端的引脚对应接收数据的引脚，即可解决问题（将一台交换机接入到另一台交换机，也是同样的道理）。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-5SjT3C.gif" alt="Auto MDI-X 自动引脚逻辑切换功能"></p><p>我能理解你此刻的心情，你肯定会说，这太痛苦了吧？不但要使用不同的以太网线缆或接头，还要保证线序完全对应，我只想说「恕臣无能！」。为了避免我们陷入此困境，我们拥有一项成为「 <strong>Auto MDI-X</strong> 」 的技术，尽管 「 <strong>Auto MDI-X</strong> 」 可以支持的设备可以检测是否使用了错误的线缆，然后，可以再逻辑上切换引脚的功能，使其与电缆相匹配，但是需要注意的是在以太网为 100BASE-T 及以上的标准才可以支持这项技术。</p><p>因为现在我们现在应用的以太网标准基本都处于 100BASE-T 之上，所以我们可以不必担心直通电缆与交叉电缆的问题，不过我们还是应该记住它们两个之间的区别。</p><p>当我们的以太网标准达到 1000BASE-TX 时，情况发生了一些变化，此时，我们会利用所有的四对电线进行数据传输（较旧的标准只需要使用两对），这里有两种工作方式，分别是 1000BASE-T 和 1000BASE-TX。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-Hc2lb6.gif" alt="1000BASE-TX标准"></p><p>1000BASE-TX 的标准是使用两对电线用于传输，另外两对电线用于接收，如果想要使用这种标准的话，我们需要将网线升级到 cat6 或更高级别。</p><p><img src="https://img.hi-linux.com/staticfile/a883ca8bbb5e809ba5f846ebf7beae1b-2021-03-16-fJhz8M.gif" alt="1000BASE-T标准"></p><p>1000BASE-T 的标准是使用所有的四对电线同时进行发送和接受，这是非常特别的一种方式，它只需要使用 cat5e 标准的线缆即可。</p><h3><span id="5-光纤">5. 光纤</span></h3><p><img src="https://img.hi-linux.com/staticfile/Z75exR-2021-03-17-6BfdtD.jpg" alt="光纤"></p><p>铜缆的替代品就是光纤，光纤使用的材质是「玻璃束」，使用这种材质，脉冲信号会从「玻璃束」的一端通过「玻璃束体」向另一端传递。回顾一下我们初中时做的物理实验，将一束光打到流动的弯曲水柱上，光会跟随水柱的方向进行传递，这里用的就是「光的全反射」原理。</p><p><img src="https://img.hi-linux.com/staticfile/4683047a308f46d8d149111d18bbba8a-2021-03-16-T8boZ1.gif" alt="光的全反射"></p><p>光纤通常用在路由器和交换机之类的网络设备之间，也可能用在我们从未见过的服务器中。</p><h3><span id="6-全双工与半双工">6. 全双工与半双工</span></h3><p>我们回过头来看一下全双工和半双工，看看它们是如何工作的。</p><h4><span id="61-全双工full-duplex">6.1 全双工（Full Duplex）</span></h4><p><strong>全双工</strong> 的意思就是，UTP非屏蔽双绞线的线缆需要同时发送和接受信息，如图所示，这需要两端的设备都支持同时发送和接受。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-9j6gVj.gif" alt="全双工"></p><h4><span id="62-半双工half-duplex">6.2 半双工（Half Duplex）</span></h4><p>有时候，两端设备中的某一端可能并不支持同时发送和接受信息，因此，信息发送完毕后，需要等待一会，待收到对方回复信息后，才能再次发送信息，这种方式就是 <strong>「半双工」</strong>。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-6Qy6Kp.gif" alt="半双工"></p><p>根据 <strong>全双工</strong>与<strong>半双工</strong> 的特性，光纤就有两种不同的使用方式：</p><h3><span id="7-单芯光纤与双芯光纤">7. 单芯光纤与双芯光纤</span></h3><h4><span id="71-单芯光纤single-core">7.1 单芯光纤（Single Core）</span></h4><p>由于无法同时发送和接受，因此单芯光纤只能使用半双工模式运行。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-BoiZZt.gif" alt="单芯光纤"></p><h4><span id="72-双芯光纤dual-core">7.2 双芯光纤（Dual Core）</span></h4><p>因其双芯的特性，其中一个芯专用于发送，而另一个芯则用于接收，因此双芯光纤支持全双工模式的运行。</p><p><img src="https://img.hi-linux.com/staticfile/bc47f38f17cebd00f367a8a06a73c8fb-2021-03-16-rwcK3K.gif" alt="双芯光纤"></p><p>如果我们自行连接光纤，却不能正常使用时，可以尝试交换光纤方向，问题也许就可以解决。</p><p><img src="https://img.hi-linux.com/staticfile/x2EUqr-2021-03-17-c7IHR0.jpg" alt="双芯光纤与单芯光纤"></p><p>企业网络通常使用双芯光纤，通常是使用在交换机、路由器和服务器之间。对于家庭中使用的光纤，网络服务提供商通常只会提供单核光纤。</p><h3><span id="8-单模与多模光纤">8. 单模与多模光纤</span></h3><p>接下来，我们来聊一下单模光纤与多模光纤，它们可能看起来很相似，但因为使用光的类型不同而产生了很大的差别。</p><h4><span id="81-单模光纤smfsingle-mode-fibre">8.1 单模光纤（SMF：Single Mode Fibre）</span></h4><p>单模光纤使用激光作为光源，这是其价格更高，但这中广可以传输更远的距离，很容易就可以达到2公里或更长的距离，服务提供商通常会在不同的建筑中使用单模光纤，以方便每栋用户流畅的访问Internet。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140150598-2021-03-16-Nun3KQ.png" alt="单模光纤"></p><h4><span id="82-多模光纤mmfmulti-mode-fibre">8.2 多模光纤（MMF：Multi Mode Fibre）</span></h4><p>多模光纤使用LED作为光源，它并不是特别强的光， 所以只能在较短的距离（500m或更短）传输，通常用于同一栋建筑中的网络连接，效果非常好。同时因为LED的生产成本比较低，因此如果你很在乎价格，可以选择这种类型的光纤。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140150629-2021-03-16-vWgjl5.png" alt="多模光纤"></p><h3><span id="9-光纤弯曲程度">9. 光纤弯曲程度</span></h3><p>尽管光纤是由玻璃制成的，但它具有很强的柔韧性，即便对它进行一定程度的弯曲也不会造成它的损坏。光纤都具有最大弯曲半径（根据光纤的不同而不同），光纤缠绕的程度会导致不同程度的信号衰减（信号衰减或丢失的地方），如果你想知道你家的光纤最大的弯曲程度是多少，可以联系网络服务提供商。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-6c20sX.gif" alt="光纤的弯曲程度"></p><h3><span id="10-光纤的连接器">10. 光纤的连接器</span></h3><p>光纤有非常多不同类型的连接器（接头），这里大家要知道，光纤不仅仅用于网络连接，它可能还会有一些其他用途。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140150728-2021-03-16-NY1h3U.png" alt="光纤连接器"></p><p>例如：LC类型的接头就通常用与与交换机和路由器的连接，我们通常会在双核配置中看到它们；而SC类型的接头属于比较老旧的类型，它看起来更大，通常我们会在配线柜中看到它。</p><p><img src="https://img.hi-linux.com/staticfile/222-2021-03-17-6C0lhd.png" alt="配线柜"></p><p>一些交换机会有一些看起来很空的特殊的接口，而一些交换机则完全由这些接口组成，这些接口都是用于安装收发器模块的，这些接口都可以用于不同目的，但通常情况下，他们都是用于很合匹配不同线缆的接头的，这些收发器接口支持不同的电缆类型，包括了单模和多模光纤。同时它们还支持不同的速度，例如1G或10G的速度；它们也支持不同的电缆长度，例如长40公里电缆的收发器比1公里的收法器要贵得多。</p><p><img src="https://img.hi-linux.com/staticfile/618afb36222910564c757147daa9da90-2021-03-16-gAEahw.gif" alt="交换机上的特殊接口"></p><p>这些交换机准备这么多端口最终原因是为了方便我们搭配不同的收发器，以完成不同的业务场景。我们甚至可以为其安装上「rj45收发器」，以满足我想要安装双绞线的需求。</p><p><img src="https://img.hi-linux.com/staticfile/996b1c608e3680334b1b919f839449ac-2021-03-17-bA5vdN.gif" alt="RJ45收发器"></p><h3><span id="11-wi-fi-连接">11. Wi-Fi 连接</span></h3><p>我们的另一种通信方法就是无线Wi-Fi通信，它不需要使用电缆连接，无线网络就像一个无线的交换机，可以让手机、笔记本之类的无线设备链接到接入点，但这个接入点是需要链接到有线网络的，此时，有线和无线设备可以在同一个网络当中使用。当然，并不是所有的设备都会连接到无线接入点的，例如我们不能把路由器或服务器连接到无线接入点。</p><p><img src="https://img.hi-linux.com/staticfile/2622f77fdd2700d1ee34df375fac4d23-2021-03-16-lOiRLs.gif" alt="无线网络"></p><p>Wi-Fi网络不适用 802.3 的以太网标准，它使用的是 802.11 的标准（802.11 标准描述了信息是如何使用无线电波来格式化和编码信息），虽然它们不是同一个以太网，但它们都是由 IEEE 制定，因此在数据格式化方面有很多相似之处。</p><h3><span id="总结">总结</span></h3><ol><li>网络可以是有线或无线的，网络连接可以使用铜缆或光缆</li><li>以太网标准用于描述了物理连接线缆的类型以及如何格式化数据</li><li>UTP有四对双绞线，其中一些用于数据发送，另一些用于数据接收</li><li>线缆可以以直通方式或交叉方式连接到交换机</li><li>现如今的大部分平台都支持 Auto MDI-X，可自动对线缆进行检测并做出调整</li><li>双工设备可以同时发送和接受数据，半双工则需要收到响应后再发送数据</li><li>双芯光纤支持全双工，单芯光纤支持半双工</li><li>若想要短距离连接，并节省更多成本，可以选择多模光纤</li><li>若想要远距离连接，则需要支付更高的价格，选择单模光纤，同时需采用正确收发器</li><li>如果有线连接无法满足你的需求，可以采用无线网络连接</li></ol><h3><span id="问题">问题</span></h3><ol><li>1000BASE-T以什么速度运行？需要使用什么类型的电缆？</li><li>使用哪种类型的UTP电缆将主机连接到交换机？那种类型的电缆可以将一个交换机连接到另一个交换机？</li><li>哪种情况下我们需要使用 Auto MDI-X 技术？</li><li>那种情况下需要使用光纤代替UTP？什么时候需要单模式光纤而不是多模光纤？</li><li>什么是弯曲半径？使用哪种类型的电缆，需要特别注意弯曲半径？</li><li>请简单阐述全双工工作模式的特点</li></ol><h2><span id="网络寻址">网络寻址</span></h2><p><img src="https://img.hi-linux.com/staticfile/aa699b8601737a0d0ef782babcb58570-2021-03-16-SXOTWq.gif" alt="模拟 soho 网络"></p><p>让我们回到  <strong>「soho网络」</strong> ，一起来看一个比较特殊的案例，我们用下图作为一个模拟的 <strong>「soho网络」</strong> 。假如，我们想通过网络中的一台主机，将需要打印的文件信息传递给打印机，因为打印机已入网，所以我们可以实现这一功能，在这个网络中有多个节点存在，试问一下，我们的电脑主机如何才能知道将信息发送到什么位置呢？</p><p><img src="https://img.hi-linux.com/staticfile/92ed8da29ce74e745fbad62319ea2b55-2021-03-16-pxwChj.gif" alt="soho 网络中的节点同时发送信息"></p><p>虽然，我们可以将打印信息发送给网络中的所有节点，然后让节点去判断这个信息是否是发给自己的，但这样一来信息的安全性且不说，效率低下才是最致命的；试想一下，如果所有的设备同时发送信息，该怎么办？如果网络环境下有多台打印机，该怎么办？会出现什么状况？网络将变得一团糟！所以呢，我们需要一个解决方法。</p><p><img src="https://img.hi-linux.com/staticfile/bef18e90b170848a5d55c0019ccc1290-2021-03-16-ys8kRE.gif" alt="网络设备地址"></p><p>其实，网络上的每台设备都有一个地址，这就类似于我们公司的、家庭的或亲朋好友的家庭住址，这个地址一定是唯一的，因此，我们邮寄包裹或网络购物可以找到准确的位置。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140151841-2021-03-16-LerkaC.png" alt="MAC 地址与 IP 地址"></p><p>在同一个域中，每台设备都会有两个地址，分别是 MAC 地址和 IP 地址，这两个地址的使用方式不同，目前，我们先大概了解它们的特点与基本使用，后面的章节会做展开讲解。</p><h3><span id="1mac地址">1.MAC地址</span></h3><p><img src="https://img.hi-linux.com/staticfile/84fb3871865da2ed8b3a89d1c1ceebcd-2021-03-16-BQaks6.gif" alt="MAC 地址"></p><p>首先来看一下 <strong>「MAC地址」</strong>，每台设备都至少拥有一个 <strong>「MAC地址」</strong>，确切地说，应该是每一块网卡都拥有一个 <strong>「MAC地址」</strong>，如果你的机器有多块网卡，那就会拥有多个 <strong>「MAC地址」</strong>。网卡从被生产出来就会被烧录一个永久的 <strong>「MAC地址」。</strong></p><p>这非常类似于烙印在动物身上的标记，主要是为了方便我们快速寻找并确认这头羊是不是我的，是我的第几头羊……扯远了，回过头来，<strong>「MAC地址」</strong> 就是烙印在网卡上的标记，且可以保证的是，每个 <strong>「MAC地址」</strong> 都是唯一的。</p><p><img src="https://img.hi-linux.com/staticfile/f5b3b6c3bd562a28f1af5d696f9bdc0b-2021-03-16-wGJjBj.gif" alt="MAC 寻址并发送信息"></p><p>在同一网络中，当一台设备想要快速找到另一台设备，可以通过该地址来寻找，因为 <strong>「MAC地址」</strong> 的唯一性，我们可以轻松的找到目标设备，并将信息精确的发送给它。</p><h3><span id="2ip地址">2.IP地址</span></h3><p><img src="https://img.hi-linux.com/staticfile/129b8d43e31e323d1482fc6f377f151f-2021-03-16-kRNHUE.gif" alt="IP 地址"></p><p>除了 <strong>「MAC地址」</strong>，每台设备同时拥有另一个地址，那就是 <strong>「IP地址」</strong>，改地址并不是烙印在设备上的，而是需要网络管理员来给我们分配。相比较 <strong>「MAC地址」</strong> 又长又无规律的特点，<strong>「IP地址」</strong> 显得相对容易记忆，大家可能会问，都已经有一个「MAC 地址 」了，为什么还要用「IP 地址」呢？</p><p>这里我们要考虑一个问题，目前全球有 60 多亿人，如果每个人都拥有一台设备，那就意味着我们拥有 60亿个 <strong>「MAC地址」</strong>，这是一个庞大的 <strong>「MAC地址库」</strong>，在这样庞大的库中查找具体的某一个设备无异于大海捞针。</p><p><img src="https://img.hi-linux.com/staticfile/0ad479635eb0798b0b2dfb7853255fca-2021-03-16-yLWu1i.gif" alt="IP 寻址并发送信息"></p><p>所以 <strong>「MAC地址」</strong> 通常都用于局部网络中的设备查找，而 <strong>「IP地址」</strong> 因为由管理员分配，这意味着每个国家，每个地区，每个城市的「IP地址」都有具体分配的 <strong>「IP地址段」</strong>，这就很方便我们查找了，当我们想要给一个异国他乡的亲友发送信息时，只需要先来确定它的 <strong>「IP地址」</strong> 所在地区，然后再具体查找它的设备，这将变得非常容易。</p><h3><span id="3网络寻址">3.网络寻址</span></h3><p><img src="https://img.hi-linux.com/staticfile/927e9f7bb99a48428d1b5803b3068fdc-2021-03-16-wam8yc.gif" alt="两个局域网连接"></p><p>举个例子，当一个公司的规模越来越大，分公司必然会出现，这种情况下会出现多个网络区域，此时我们需要将两个网络通过路由器连接在一起，这个路由器同时属于两个局域网LAN的一部分，它的工作就是将一个网段的信息传递到另一个网段。</p><p>通过刚才的学习，我们都知道了，MAC地址是用于本地局域网中的地址，因此，当我们想要把一段打印信息发送给另一个网段的打印机时，仅仅使用MAC地址就不够用了，此时我们就可以通过IP地址来定位打印机所处的位置。</p><p><img src="https://img.hi-linux.com/staticfile/1b93b0d809a4a4c659e60ec9d9bcc3e3-2021-03-16-QHiFsP.gif" alt="IP 地址的工作流程"></p><p>我们看一下具体的工作流程，当一个网段中的电脑准备好了要传递给打印机打印信息，我们的电脑会在这段消息上追加一个 <strong>「IP地址」</strong>，这个 <strong>「IP地址」</strong> 就是打印机的 <strong>「IP地址」</strong>。同时，因为该打印机在另一段网络，所以，电脑又在该信息上追加了路由器的 <strong>「MAC地址」</strong>，先找到路由器，路由器接到信息后把这个 <strong>「MAC地址」</strong> 更改成打印机的 <strong>「MAC地址」</strong>，接着，就可以精确的将该信息传递给打印机。</p><h3><span id="总结">总结</span></h3><ol><li>主机都同时拥有一个MAC地址和一个IP地址</li><li>MAC地址常用于一个局域网络</li><li>IP地址可以可以在本地的网段使用，同样可以再其他网段使用</li></ol><h3><span id="问题">问题</span></h3><ol><li>谁把Mac地址分配给计算机？一台计算机有多少个Mac地址？</li><li>要在本地网段中发送消息，是否需要IP地址？</li></ol><h3><span id="结语">结语</span></h3><p>如果你觉得文章很棒，可以转发，评论该文章；如果文章有问题，请留言或私信告诉我，我会在第一时间对内容进行调整，这将会帮助每一位想要学习网络基础的小伙伴，感谢！抱拳！</p><h4><span id="原作者">原作者：</span></h4><ul><li>原文作者：Network Direction</li><li>链接地址：<a href="https://www.youtube.com/watch?v=v8aYhOxZuNg&amp;list=PLDQaRcbiSnqF5U8ffMgZzS7fq1rHUI3Q8&amp;index=16&amp;t=28s" target="_blank" rel="noopener">点击查看</a></li></ul><blockquote><p>本文转载自：「 少数派 」，原文：<a href="https://sspai.com/post/64640" target="_blank" rel="noopener">https://sspai.com/post/64640</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;欢迎来到网络世界，《小白也能看懂的网络基础》系列文章会从零开始帮助你构建网络的基础知识。如果你完全没有接触过网络相关的内容，那我们是一样的，在学习过程中我们肯定遇到了相同的问题！写下这些文章一方面要记录自己的学习历程，另一方面也希望帮到同样想要学习网络基础的小伙伴。&lt;/p&gt;
&lt;p&gt;文章的部分内容与素材是我从【Youtube平台】的【&lt;a href=&quot;https://www.youtube.com/channel/UCtuXekfqj-paqsxtqVNCC2A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Network Direction&lt;/a&gt;】发布的系列视频学习和搜集过来的，翻译不易，部分内容可能无法做到尽善尽美，甚至可能会有部分瑕疵，我会尽力让文章内容通俗易懂，覆盖全面。若各位小伙伴发现任何问题，希望能够留言或私信告诉我，在下不胜感激！当然，我也会在第一时间进行更正。&lt;/p&gt;
&lt;p&gt;在往后的每一篇文章中，我都会把看到文章的小伙伴当成是完全没有网络经验的小白，我的目标是和零基础小白一起建立坚实的网络基础，网络大神请略过此系列文章。&lt;/p&gt;
&lt;p&gt;让我们开始网络之旅吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="https://www.hi-linux.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="网络" scheme="https://www.hi-linux.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你给 Kubernetes Dashboard 增加用户名密码认证功能</title>
    <link href="https://www.hi-linux.com/posts/7928.html"/>
    <id>https://www.hi-linux.com/posts/7928.html</id>
    <published>2021-05-20T01:00:00.000Z</published>
    <updated>2021-05-20T01:22:08.887Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>仪表板是基于 <code>Web</code> 的 <code>Kubernetes</code> 用户界面。您可以使用仪表板将容器化应用程序部署到 <code>Kubernetes</code> 集群，对容器化应用程序进行故障排除，并管理集群本身及其伴随资源。您可以使用仪表板来概述群集上运行的应用程序，以及创建或修改单个 <code>Kubernetes</code> 资源。</p><p><img src="https://img.hi-linux.com/staticfile/use-name-passwd-login-dashborad-2021-04-15-evt2DM.png" alt="Dashboard开启用户名密码登录"></p><p>通过 <code>yaml</code> 文件默认安装完 <code>k8s</code> 集群和 <code>Dashboard</code> 服务之后，都是使用 <strong><code>token</code></strong> 或者 <strong><code>Kubeconfig</code> 文件</strong> 来登录的，这样使用起来比较安全。但是如果我们部署的是测试或者实验环境的话，每次都要输入一长串的 <code>token</code> 还是很方便的。所以，这里我们介绍如何使用 <strong>用户名和密码</strong> 的方式来登录 <code>Dashboard</code> 服务。</p><table><thead><tr><th style="text-align:left">集群环境</th><th style="text-align:left">集群版本</th><th style="text-align:left">搭建方式</th><th style="text-align:left">dashboard 的版本</th></tr></thead><tbody><tr><td style="text-align:left">master</td><td style="text-align:left">v1.20.4</td><td style="text-align:left">kubeadm</td><td style="text-align:left">dashboard:v2.0.4</td></tr><tr><td style="text-align:left">node01</td><td style="text-align:left">v1.20.4</td><td style="text-align:left">kubeadm</td><td style="text-align:left">dashboard:v2.0.4</td></tr><tr><td style="text-align:left">node02</td><td style="text-align:left">v1.20.4</td><td style="text-align:left">kubeadm</td><td style="text-align:left">dashboard:v2.0.4</td></tr></tbody></table><ul><li>创建用户文件<ul><li>格式：<code>user</code>、<code>password</code>、<code>userID</code>、<code>&quot;group1,group2&quot;</code></li><li>注意：<code>userID</code> 不可重复</li></ul></li></ul><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户名密码配置文件</span></span><br><span class="line"><span class="comment"># 在所有的master节点配置用户名密码</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'admin,admin,1'</span> | sudo tee /etc/kubernetes/pki/basic_auth_file</span><br></pre></td></tr></table></figure><ul><li>修改配置文件<ul><li>将上述创建好的用户名密码文件添加到下述文件中</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置修改</span></span><br><span class="line">$ sudo vim /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - <span class="built_in">command</span>:</span><br><span class="line">    - kube-apiserver</span><br><span class="line">    - --advertise-address=192.168.30.30</span><br><span class="line">    - --basic-auth-file=/etc/kubernetes/pki/basic_auth_file</span><br><span class="line">    ......</span><br><span class="line">  volumeMounts:</span><br><span class="line">  – mountPath: /etc/kubernetes/basic_auth_file</span><br><span class="line">    name: basic-auth-file</span><br><span class="line">    readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">  – hostPath:</span><br><span class="line">    name: basic-auth-file</span><br><span class="line">      path: /etc/kubernetes/basic_auth_file</span><br></pre></td></tr></table></figure><ul><li>重启 apiserver 服务<ul><li>使刚才的修改生效</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启</span></span><br><span class="line">$ kubectl apply -f /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">$ kubectl get pod -n kube-system | grep apiserver</span><br><span class="line">kube-apiserver-k8s-01            1/1     Running   0          24s</span><br><span class="line">kube-apiserver-k8s-02            1/1     Running   0          44s</span><br><span class="line">kube-apiserver-k8s-03            1/1     Running   0          50s</span><br></pre></td></tr></table></figure><ul><li>将用户与权限绑定<ul><li>创建集群 <code>admin</code> 角色绑定</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 权限绑定</span></span><br><span class="line">$ kubectl create clusterrolebinding \</span><br><span class="line">    login-on-dashboard-with-cluster-admin \</span><br><span class="line">    --clusterrole=cluster-admin --user=admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看绑定</span></span><br><span class="line">$ kubectl get clusterrolebinding login-on-dashboard-with-cluster-admin</span><br><span class="line">NAME                                    ROLE                        AGE</span><br><span class="line">login-on-dashboard-with-cluster-admin   ClusterRole/cluster-admin   2m23s</span><br></pre></td></tr></table></figure><ul><li>开启 basic 配置<ul><li>修改 <code>kubernetes-dashboard.yaml</code> 配置文件</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim kubernetes-dashboard.yaml</span><br><span class="line">args:</span><br><span class="line">  - --auto-generate-certificates</span><br><span class="line">  - --namespace=kubernetes-dashboard</span><br><span class="line">  - --token-ttl=43200 <span class="comment"># 过期秒数</span></span><br><span class="line">  - --authentication-mode=basic <span class="comment"># 启用basic登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">$ kubectl apply -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><ul><li>登录验证<ul><li>使用用户名和密码登录 <code>Dashboard</code> 服务</li></ul></li></ul><p><img src="https://www.escapelife.site/images/use-name-passwd-login-dashborad-01.png" alt="Dashboard开启用户名密码登录"></p><blockquote><p>本文转载自：「 Ecsape 的博客 」，原文：<a href="http://t.cn/A6c6nQfG" target="_blank" rel="noopener">http://t.cn/A6c6nQfG</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;仪表板是基于 &lt;code&gt;Web&lt;/code&gt; 的 &lt;code&gt;Kubernetes&lt;/code&gt; 用户界面。您可以使用仪表板将容器化应用程序部署到 &lt;code&gt;Kubernetes&lt;/code&gt; 集群，对容器化应用程序进行故障排除，并管理集群本身及其伴随资源。您可以使用仪表板来概述群集上运行的应用程序，以及创建或修改单个 &lt;code&gt;Kubernetes&lt;/code&gt; 资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/use-name-passwd-login-dashborad-2021-04-15-evt2DM.png&quot; alt=&quot;Dashboard开启用户名密码登录&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;yaml&lt;/code&gt; 文件默认安装完 &lt;code&gt;k8s&lt;/code&gt; 集群和 &lt;code&gt;Dashboard&lt;/code&gt; 服务之后，都是使用 &lt;strong&gt;&lt;code&gt;token&lt;/code&gt;&lt;/strong&gt; 或者 &lt;strong&gt;&lt;code&gt;Kubeconfig&lt;/code&gt; 文件&lt;/strong&gt; 来登录的，这样使用起来比较安全。但是如果我们部署的是测试或者实验环境的话，每次都要输入一长串的 &lt;code&gt;token&lt;/code&gt; 还是很方便的。所以，这里我们介绍如何使用 &lt;strong&gt;用户名和密码&lt;/strong&gt; 的方式来登录 &lt;code&gt;Dashboard&lt;/code&gt; 服务。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;集群环境&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;集群版本&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;搭建方式&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;dashboard 的版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;master&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;v1.20.4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;kubeadm&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;dashboard:v2.0.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;node01&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;v1.20.4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;kubeadm&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;dashboard:v2.0.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;node02&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;v1.20.4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;kubeadm&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;dashboard:v2.0.4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;创建用户文件
&lt;ul&gt;
&lt;li&gt;格式：&lt;code&gt;user&lt;/code&gt;、&lt;code&gt;password&lt;/code&gt;、&lt;code&gt;userID&lt;/code&gt;、&lt;code&gt;&amp;quot;group1,group2&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意：&lt;code&gt;userID&lt;/code&gt; 不可重复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>万字总结，Redis 性能问题排查解决手册（强烈建议收藏）</title>
    <link href="https://www.hi-linux.com/posts/54695.html"/>
    <id>https://www.hi-linux.com/posts/54695.html</id>
    <published>2021-05-18T01:00:00.000Z</published>
    <updated>2021-05-18T06:15:32.878Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="阅读目录">阅读目录</span></h2><ol><li>性能相关的数据指标</li><li>内存使用率used_memory</li><li>命令处理总数total_commands_processed</li><li>延迟时间</li><li>内存碎片率</li><li>回收key</li><li>总结</li></ol><h2><span id="性能相关的数据指标">性能相关的数据指标</span></h2><p>通过Redis-cli命令行界面访问到Redis服务器，然后使用info命令获取所有与Redis服务相关的信息。通过这些信息来分析文章后面提到的一些性能指标。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134751769-2021-05-18-Y5iyDV.png" alt></p><p>info命令输出的数据可分为10个类别，分别是：</p><ul><li>server</li><li>clients</li><li>memory</li><li>persistence</li><li>stats</li><li>replication</li><li>cpu</li><li>commandstats</li><li>cluster</li><li>keyspace</li></ul><p>这篇主要介绍比较重要的2部分性能指标memory和stats。</p><p>需要注意的是info命令返回的信息，并没有命令响应延迟相关的数据信息，所以后面会详细介绍怎么获取与延迟相关的数据指标。</p><a id="more"></a><p>倘若你觉得info输出的信息太多并且杂乱无章，可以指定info命令的参数来获取单个分类下的数据。比如输入info memory命令，会只返回与内存相关的数据。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134817564-2021-05-18-EtD7Ca.png" alt></p><p>为了快速定位并解决性能问题，这里选择5个关键性的数据指标，它包含了大多数人在使用Redis上会经常碰到的性能问题。</p><h2><span id="内存使用率used_memory">内存使用率used_memory</span></h2><p>上图中used_memory 字段数据表示的是：由Redis分配器分配的内存总量，以字节（byte）为单位。其中used_memory_human上的数据和used_memory是一样的值，它以M为单位显示，仅为了方便阅读。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134824172-2021-05-18-6SNalM.png" alt></p><p>used_memory是Redis使用的内存总量，它包含了实际缓存占用的内存和Redis自身运行所占用的内存(如元数据、lua)。它是由Redis使用内存分配器分配的内存，所以这个数据并没有把内存碎片浪费掉的内存给统计进去。</p><p>其他字段代表的含义，都以字节为单位：</p><ul><li>used_memory_rss：从操作系统上显示已经分配的内存总量。</li><li>mem_fragmentation_ratio：内存碎片率。</li><li>used_memory_lua：Lua脚本引擎所使用的内存大小。</li><li>mem_allocator：在编译时指定的Redis使用的内存分配器，可以是libc、jemalloc、tcmalloc。</li></ul><h3><span id="因内存交换引起的性能问题">因内存交换引起的性能问题</span></h3><p>内存使用率是Redis服务最关键的一部分。如果一个Redis实例的内存使用率超过可用最大内存 (used_memory &gt; 可用最大内存)，那么操作系统开始进行内存与swap空间交换，把内存中旧的或不再使用的内容写入硬盘上（硬盘上的这块空间叫Swap分区），以便腾出新的物理内存给新页或活动页(page)使用。</p><p>在硬盘上进行读写操作要比在内存上进行读写操作，时间上慢了近5个数量级，内存是0.1μs单位、而硬盘是10ms。如果Redis进程上发生内存交换，那么Redis和依赖Redis上数据的应用会受到严重的性能影响。</p><p>通过查看used_memory指标可知道Redis正在使用的内存情况，如果used_memory&gt;可用最大内存，那就说明Redis实例正在进行内存交换或者已经内存交换完毕。管理员根据这个情况，执行相对应的应急措施。</p><h3><span id="跟踪内存使用率">跟踪内存使用率</span></h3><p>若是在使用Redis期间没有开启rdb快照或aof持久化策略，那么缓存数据在Redis崩溃时就有丢失的危险。因为当Redis内存使用率超过可用内存的95%时，部分数据开始在内存与swap空间来回交换，这时就可能有丢失数据的危险。</p><p>当开启并触发快照功能时，Redis会fork一个子进程把当前内存中的数据完全复制一份写入到硬盘上。因此若是当前使用内存超过可用内存的45%时触发快照功能，那么此时进行的内存交换会变的非常危险(可能会丢失数据)。倘若在这个时候实例上有大量频繁的更新操作，问题会变得更加严重。</p><p>通过减少Redis的内存占用率，来避免这样的问题，或者使用下面的技巧来避免内存交换发生：</p><ol><li>假如缓存数据小于4GB，就使用32位的Redis实例</li></ol><p>因为32位实例上的指针大小只有64位的一半，它的内存空间占用空间会更少些。这有一个坏处就是，假设物理内存超过4GB，那么32位实例能使用的内存仍然会被限制在4GB以下。</p><p>要是实例同时也共享给其他一些应用使用的话，那可能需要更高效的64位Redis实例，这种情况下切换到32位是不可取的。不管使用哪种方式，Redis的dump文件在32位和64位之间是互相兼容的， 因此倘若有减少占用内存空间的需求，可以尝试先使用32位，后面再切换到64位上。</p><ol start="2"><li>尽可能的使用Hash数据结构</li></ol><p>因为Redis在储存小于100个字段的Hash结构上，其存储效率是非常高的。所以在不需要集合(set)操作或list的push/pop操作的时候，尽可能的使用Hash结构。比如，在一个web应用程序中，需要存储一个对象表示用户信息，使用单个key表示一个用户，其每个属性存储在Hash的字段里，这样要比给每个属性单独设置一个key-value要高效的多。</p><p>通常情况下倘若有数据使用string结构，用多个key存储时，那么应该转换成单key多字段的Hash结构。如上述例子中介绍的Hash结构应包含，单个对象的属性或者单个用户各种各样的资料。Hash结构的操作命令是HSET(key, fields, value)和HGET(key, field)，使用它可以存储或从Hash中取出指定的字段。</p><ol start="3"><li>设置key的过期时间</li></ol><p>一个减少内存使用率的简单方法就是，每当存储对象时确保设置key的过期时间。倘若key在明确的时间周期内使用或者旧key不大可能被使用时，就可以用Redis过期时间命令(expire,expireat, pexpire, pexpireat)去设置过期时间，这样Redis会在key过期时自动删除key。</p><p>假如你知道每秒钟有多少个新key-value被创建，那可以调整key的存活时间，并指定阀值去限制Redis使用的最大内存。</p><ol start="4"><li>回收key</li></ol><p>在Redis配置文件中(一般叫Redis.conf)，通过设置“maxmemory”属性的值可以限制Redis最大使用的内存，修改后重启实例生效。</p><p>也可以使用客户端命令config set maxmemory 去修改值，这个命令是立即生效的，但会在重启后会失效，需要使用config rewrite命令去刷新配置文件。</p><p>若是启用了Redis快照功能，应该设置“maxmemory”值为系统可使用内存的45%，因为快照时需要一倍的内存来复制整个数据集，也就是说如果当前已使用45%，在快照期间会变成95%(45%+45%+5%)，其中5%是预留给其他的开销。如果没开启快照功能，maxmemory最高能设置为系统可用内存的95%。</p><p>当内存使用达到设置的最大阀值时，需要选择一种key的回收策略，可在Redis.conf配置文件中修改“maxmemory-policy”属性值。若是Redis数据集中的key都设置了过期时间，那么“volatile-ttl”策略是比较好的选择。</p><p>但如果key在达到最大内存限制时没能够迅速过期，或者根本没有设置过期时间。那么设置为“allkeys-lru”值比较合适，它允许Redis从整个数据集中挑选最近最少使用的key进行删除(LRU淘汰算法)。Redis还提供了一些其他淘汰策略，如下：</p><ul><li>volatile-lru：使用LRU算法从已设置过期时间的数据集合中淘汰数据。</li><li>volatile-ttl：从已设置过期时间的数据集合中挑选即将过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集合中随机挑选数据淘汰。</li><li>allkeys-lru：使用LRU算法从所有数据集合中淘汰数据。</li><li>allkeys-random：从数据集合中任意选择数据淘汰</li><li>no-enviction：禁止淘汰数据。</li></ul><p>通过设置maxmemory为系统可用内存的45%或95%(取决于持久化策略)和设置“maxmemory-policy”为“volatile-ttl”或“allkeys-lru”(取决于过期设置)，可以比较准确的限制Redis最大内存使用率，在绝大多数场景下使用这2种方式可确保Redis不会进行内存交换。倘若你担心由于限制了内存使用率导致丢失数据的话，可以设置noneviction值禁止淘汰数据。</p><h2><span id="命令处理数-total_commands_processed">命令处理数 total_commands_processed</span></h2><p>在info信息里的total_commands_processed字段显示了Redis服务处理命令的总数，其命令都是从一个或多个Redis客户端请求过来的。Redis每时每刻都在处理从客户端请求过来的命令，它可以是Redis提供的140种命令的任意一个。</p><p>total_commands_processed字段的值是递增的，比如Redis服务分别处理了client_x请求过来的2个命令和client_y请求过来的3个命令，那么命令处理总数(total_commands_processed)就会加上5。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518133455574-2021-05-18-VcSVHk.png" alt></p><h3><span id="分析命令处理总数诊断响应延迟">分析命令处理总数，诊断响应延迟</span></h3><p>在Redis实例中，跟踪命令处理总数是解决响应延迟问题最关键的部分，因为Redis是个单线程模型，客户端过来的命令是按照顺序执行的。比较常见的延迟是带宽，通过千兆网卡的延迟大约有200μs。倘若明显看到命令的响应时间变慢，延迟高于200μs，那可能是Redis命令队列里等待处理的命令数量比较多。</p><p>如上所述，延迟时间增加导致响应时间变慢可能是由于一个或多个慢命令引起的，这时可以看到每秒命令处理数在明显下降，甚至于后面的命令完全被阻塞，导致Redis性能降低。要分析解决这个性能问题，需要跟踪命令处理数的数量和延迟时间。</p><p>比如可以写个脚本，定期记录 total_commands_processed 的值。当客户端明显发现响应时间过慢时，可以通过记录的 total_commands_processed 历史数据值来判断命理处理总数是上升趋势还是下降趋势，以便排查问题。</p><h3><span id="使用命令处理总数解决延迟时间增加">使用命令处理总数解决延迟时间增加</span></h3><p>通过与记录的历史数据比较得知，命令处理总数确实是处于上升或下降状态，那么可能是有2个原因引起的:</p><ul><li>命令队列里的命令数量过多，后面命令一直在等待中。</li><li>几个慢命令阻塞Redis。</li></ul><p>下面有三个办法可以解决，因上面2条原因引起的响应延迟问题。</p><ol><li>使用多参数命令</li></ol><p>若是客户端在很短的时间内发送大量的命令过来，会发现响应时间明显变慢，这由于后面命令一直在等待队列中前面大量命令执行完毕。有个方法可以改善延迟问题，就是通过单命令多参数的形式取代多命令单参数的形式。</p><p>举例来说，循环使用LSET命令去添加1000个元素到list结构中，是性能比较差的一种方式，更好的做法是在客户端创建一个1000元素的列表，用单个命令LPUSH或RPUSH，通过多参数构造形式一次性把1000个元素发送的Redis服务上。下面的表格是Redis的一些操作命令，有单个参数命令和支持多个参数的命令，通过这些命令可尽量减少使用多命令的次数。                                             <img src="https://img.hi-linux.com/staticfile/640-20210518134848518-2021-05-18-4aq6rE.png" alt></p><ol start="2"><li>管道命令</li></ol><p>另一个减少多命令的方法是使用管道(pipeline)，把几个命令合并一起执行，从而减少因网络开销引起的延迟问题。因为10个命令单独发送到服务端会引起10次网络延迟开销，使用管道会一次性把执行结果返回，仅需要一次网络延迟开销。Redis本身支持管道命令，大多数客户端也支持，倘若当前实例延迟很明显，那么使用管道去降低延迟是非常有效的。</p><ol start="3"><li>避免操作大集合的慢命令</li></ol><p>如果命令处理频率过低导致延迟时间增加，这可能是因为使用了高时间复杂度的命令操作导致，这意味着每个命令从集合中获取数据的时间增大。</p><p>所以减少使用高时间复杂的命令，能显著的提高的Redis的性能。下面的表格是高时间复杂度命令的列表，其详细描述了命令的属性，有这助于高效合理的、最优化的使用这些命令(如果不得不使用的话)，以提高Redis性能。</p><p><img src="https://img.hi-linux.com/staticfile/640-2021-05-18-U0h99k.jpg" alt></p><h2><span id="延迟时间">延迟时间</span></h2><p>Redis的延迟数据是无法从info信息中获取的。倘若想要查看延迟时间，可以用 Redis-cli工具加–latency参数运行，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis-cli --latency -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure><p>其host和port是Redis实例的ip及端口。由于当前服务器不同的运行情况，延迟时间可能有所误差，通常1G网卡的延迟时间是200μs。</p><p>以毫秒为单位测量Redis的响应延迟时间，楼主本机的延迟是300μs：</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518133700583-2021-05-18-xKRykn.png" alt></p><h3><span id="跟踪redis延迟性能">跟踪Redis延迟性能</span></h3><p>Redis之所以这么流行的主要原因之一就是低延迟特性带来的高性能，所以说解决延迟问题是提高Redis性能最直接的办法。拿1G带宽来说，若是延迟时间远高于200μs，那明显是出现了性能问题。</p><p>虽然在服务器上会有一些慢的IO操作，但Redis是单核接受所有客户端的请求，所有请求是按良好的顺序排队执行。因此若是一个客户端发过来的命令是个慢操作，那么其他所有请求必须等待它完成后才能继续执行。</p><h3><span id="使用延迟命令提高性能">使用延迟命令提高性能</span></h3><p>一旦确定延迟时间是个性能问题后，这里有几个办法可以用来分析解决性能问题。</p><ol><li>使用 slowlog 查出引发延迟的慢命令</li></ol><p>Redis中的slowlog命令可以让我们快速定位到那些超出指定执行时间的慢命令，默认情况下命令若是执行时间超过10ms就会被记录到日志。slowlog只会记录其命令执行的时间，不包含io往返操作，也不记录单由网络延迟引起的响应慢。</p><p>通常1gb带宽的网络延迟，预期在200μs左右，倘若一个命令仅执行时间就超过10ms，那比网络延迟慢了近50倍。想要查看所有执行时间比较慢的命令，可以通过使用Redis-cli工具，输入slowlog get命令查看，返回结果的第三个字段以微妙位单位显示命令的执行时间。</p><p>假如只需要查看最后10个慢命令，输入slowlog get 10即可。关于怎么定位到是由慢命令引起的延迟问题，可查看total_commands_processed介绍章节。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134858745-2021-05-18-EHBvbl.png" alt></p><p>图中字段分别意思是：</p><ul><li>1=日志的唯一标识符</li><li>2=被记录命令的执行时间点，以 UNIX 时间戳格式表示</li><li>3=查询执行时间，以微秒为单位。例子中命令使用54毫秒。</li><li>4= 执行的命令，以数组的形式排列。完整命令是config get *。</li></ul><p>倘若你想自定义慢命令的标准，可以调整触发日志记录慢命令的阀值。若是很少或没有命令超过10ms，想降低记录的阀值，比如5毫秒，可在Redis-cli工具中输入下面的命令配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set slowlog-log-slower-than 5000</span><br></pre></td></tr></table></figure><p>也可以在Redis.config配置文件中设置，以微妙位单位。</p><ol start="2"><li>监控客户端的连接</li></ol><p>因为Redis是单线程模型(只能使用单核)，来处理所有客户端的请求， 但由于客户端连接数的增长，处理请求的线程资源开始降低分配给单个客户端连接的处理时间，这时每个客户端需要花费更多的时间去等待Redis共享服务的响应。</p><p>这种情况下监控客户端连接数是非常重要的，因为客户端创建连接数的数量可能超出预期的数量，也可能是客户端端没有有效的释放连接。在Redis-cli工具中输入info clients可以查看到当前实例的所有客户端连接信息。</p><p>如下图，第一个字段(connected_clients)显示当前实例客户端连接的总数：</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518133148021-2021-05-18-kgCwYv.png" alt></p><p>Redis默认允许客户端连接的最大数量是10000。若是看到连接数超过5000以上，那可能会影响Redis的性能。倘若一些或大部分客户端发送大量的命令过来，这个数字会低的多。</p><ol start="3"><li>限制客户端连接数</li></ol><p>自 Redis 2.6 以后，允许使用者在配置文件(Redis.conf)maxclients属性上修改客户端连接的最大数，也可以通过在 Redis-cli 工具上输入 config set maxclients 去设置最大连接数。</p><p>根据连接数负载的情况，这个数字应该设置为预期连接数峰值的110%到150之间，若是连接数超出这个数字后，Redis会拒绝并立刻关闭新来的连接。通过设置最大连接数来限制非预期数量的连接数增长，是非常重要的。</p><p>另外，新连接尝试失败会返回一个错误消息，这可以让客户端知道，Redis此时有非预期数量的连接数，以便执行对应的处理措施。上述二种做法对控制连接数的数量和持续保持Redis的性能最优是非常重要的，</p><ol start="4"><li>加强内存管理</li></ol><p>较少的内存会引起Redis延迟时间增加。如果Redis占用内存超出系统可用内存，操作系统会把Redis进程的一部分数据，从物理内存交换到硬盘上，内存交换会明显的增加延迟时间。关于怎么监控和减少内存使用，可查看used_memory介绍章节。</p><ol start="5"><li>性能数据指标</li></ol><p>分析解决Redis性能问题，通常需要把延迟时间的数据变化与其他性能指标的变化相关联起来。命令处理总数下降的发生可能是由慢命令阻塞了整个系统，但如果命令处理总数的增加，同时内存使用率也增加，那么就可能是由于内存交换引起的性能问题。</p><p>对于这种性能指标相关联的分析，需要从历史数据上来观察到数据指标的重要变化，此外还可以观察到单个性能指标相关联的所有其他性能指标信息。这些数据可以在Redis上收集，周期性的调用内容为Redis info的脚本，然后分析输出的信息，记录到日志文件中。当延迟发生变化时，用日志文件配合其他数据指标，把数据串联起来排查定位问题。</p><h2><span id="内存碎片率">内存碎片率</span></h2><p>info信息中的 mem_fragmentation_ratio 给出了内存碎片率的数据指标，它是由操系统分配的内存除以Redis分配的内存得出：</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134928605-2021-05-18-wiJNx3.png" alt></p><p>used_memory和used_memory_rss数字都包含的内存分配有：</p><ul><li>用户定义的数据：内存被用来存储key-value值。</li><li>内部开销：存储内部Redis信息用来表示不同的数据类型。</li></ul><p>used_memory_rss的rss是Resident Set Size的缩写，表示该进程所占物理内存的大小，是操作系统分配给Redis实例的内存大小。除了用户定义的数据和内部开销以外，used_memory_rss指标还包含了内存碎片的开销，内存碎片是由操作系统低效的分配/回收物理内存导致的。</p><p>操作系统负责分配物理内存给各个应用进程，Redis使用的内存与物理内存的映射是由操作系统上虚拟内存管理分配器完成的。</p><p>举个例子来说，Redis需要分配连续内存块来存储1G的数据集，这样的话更有利，但可能物理内存上没有超过1G的连续内存块，那操作系统就不得不使用多个不连续的小内存块来分配并存储这1G数据，也就导致内存碎片的产生。</p><p>内存分配器另一个复杂的层面是，它经常会预先分配一些内存块给引用，这样做会使加快应用程序的运行。</p><h3><span id="理解资源性能">理解资源性能</span></h3><p>跟踪内存碎片率对理解Redis实例的资源性能是非常重要的。内存碎片率稍大于1是合理的，这个值表示内存碎片率比较低，也说明redis没有发生内存交换。但如果内存碎片率超过1.5，那就说明Redis消耗了实际需要物理内存的150%，其中50%是内存碎片率。</p><p>若是内存碎片率低于1的话，说明Redis内存分配超出了物理内存，操作系统正在进行内存交换。内存交换会引起非常明显的响应延迟，可查看 used_memory 介绍章节。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518133905109-2021-05-18-aBjwpT.png" alt></p><p>上图中的 0.99 即 99%。</p><h3><span id="用内存碎片率预测性能问题">用内存碎片率预测性能问题</span></h3><p>倘若内存碎片率超过了1.5，那可能是操作系统或Redis实例中内存管理变差的表现。下面有3种方法解决内存管理变差的问题，并提高Redis性能：</p><ol><li>重启Redis服务器</li></ol><p>如果内存碎片率超过1.5，重启Redis服务器可以让额外产生的内存碎片失效并重新作为新内存来使用，使操作系统恢复高效的内存管理。额外碎片的产生是由于Redis释放了内存块，但内存分配器并没有返回内存给操作系统，这个内存分配器是在编译时指定的，可以是libc、jemalloc或者tcmalloc。</p><p>通过比较used_memory_peak, used_memory_rss和used_memory_metrics的数据指标值可以检查额外内存碎片的占用。从名字上可以看出，used_memory_peak是过去Redis内存使用的峰值，而不是当前使用内存的值。</p><p>如果used_memory_peak和used_memory_rss的值大致上相等，而且二者明显超过了used_memory值，这说明额外的内存碎片正在产生。</p><p>在Redis-cli工具上输入info memory可以查看上面三个指标的信息：</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134944908-2021-05-18-tk0wzc.png" alt></p><p>在重启服务器之前，需要在Redis-cli工具上输入shutdown save命令，意思是强制让Redis数据库执行保存操作并关闭Redis服务，这样做能保证在执行Redis关闭时不丢失任何数据。在重启后，Redis会从硬盘上加载持久化的文件，以确保数据集持续可用。</p><ol start="2"><li>限制内存交换</li></ol><p>如果内存碎片率低于1，Redis实例可能会把部分数据交换到硬盘上。内存交换会严重影响Redis的性能，所以应该增加可用物理内存或减少实Redis内存占用。可查看used_memory章节的优化建议。</p><ol start="3"><li>修改内存分配器</li></ol><p>Redis支持glibc’s malloc、jemalloc11、tcmalloc几种不同的内存分配器，每个分配器在内存分配和碎片上都有不同的实现。</p><p>不建议普通管理员修改Redis默认内存分配器，因为这需要完全理解这几种内存分配器的差异，也要重新编译Redis。这个方法更多的是让其了解Redis内存分配器所做的工作，当然也是改善内存碎片问题的一种办法。</p><h2><span id="回收key">回收key</span></h2><p>info信息中的evicted_keys字段显示的是，因为maxmemory限制导致key被回收删除的数量。关于maxmemory的介绍见前面章节，回收key的情况只会发生在设置maxmemory值后，不设置会发生内存交换。当Redis由于内存压力需要回收一个key时，Redis首先考虑的不是回收最旧的数据，而是在最近最少使用的key或即将过期的key中随机选择一个key，从数据集中删除。</p><p>这可以在配置文件中设置maxmemory-policy值为“volatile-lru”或“volatile-ttl”，来确定Redis是使用lru策略还是过期时间策略。倘若所有的key都有明确的过期时间，那过期时间回收策略是比较合适的。若是没有设置key的过期时间或者说没有足够的过期key，那设置lru策略是比较合理的，这可以回收key而不用考虑其过期状态。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134952294-2021-05-18-gSRj4a.png" alt></p><h3><span id="根据key回收定位性能问题">根据key回收定位性能问题</span></h3><p>跟踪key回收是非常重要的，因为通过回收key，可以保证合理分配Redis有限的内存资源。如果evicted_keys值经常超过0，那应该会看到客户端命令响应延迟时间增加，因为Redis不但要处理客户端过来的命令请求，还要频繁的回收满足条件的key。</p><p>需要注意的是，回收key对性能的影响远没有内存交换严重，若是在强制内存交换和设置回收策略做一个选择的话，选择设置回收策略是比较合理的，因为把内存数据交换到硬盘上对性能影响非常大(见前面章节)。</p><h3><span id="减少回收key以提升性能">减少回收key以提升性能</span></h3><p>减少回收key的数量是提升Redis性能的直接办法，下面有2种方法可以减少回收key的数量：</p><ol><li>增加内存限制</li></ol><p>倘若开启快照功能，maxmemory 需要设置成物理内存的45%，这几乎不会有引发内存交换的危险。若是没有开启快照功能，设置系统可用内存的95%是比较合理的，具体参考前面的快照和maxmemory限制章节。如果maxmemory的设置是低于45%或95%(视持久化策略)，通过增加maxmemory的值能让Redis在内存中存储更多的key，这能显著减少回收key的数量。</p><p>若是maxmemory已经设置为推荐的阀值后，增加maxmemory限制不但无法提升性能，反而会引发内存交换，导致延迟增加、性能降低。maxmemory的值可以在Redis-cli工具上输入config set maxmemory命令来设置。</p><p>需要注意的是，这个设置是立即生效的，但重启后丢失，需要永久化保存的话，再输入config rewrite命令会把内存中的新配置刷新到配置文件中。</p><ol start="2"><li>对实例进行分片</li></ol><p>分片是把数据分割成合适大小，分别存放在不同的Redis实例上，每一个实例都包含整个数据集的一部分。通过分片可以把很多服务器联合起来存储数据，相当于增加总的物理内存，使其在没有内存交换和回收key的策略下也能存储更多的key。</p><p>假如有一个非常大的数据集，maxmemory已经设置，实际内存使用也已经超过了推荐设置的阀值，那通过数据分片能明显减少key的回收，从而提高Redis的性能。分片的实现有很多种方法，下面是Redis实现分片的几种常见方式：</p><p>a. Hash分片：一个比较简单的方法实现，通过Hash函数计算出key的Hash值，然后值所在范围对应特定的Redis实例。</p><p>b. 代理分片：客户端把请求发送到代理上，代理通过分片配置表选择对应的Redis实例。如Twitter的Twemproxy，豌豆荚的codis。</p><p>c. 一致性Hash分片：参见前面博客</p><blockquote><p><a href="http://www.cnblogs.com/mushroom/p/4472369.html" target="_blank" rel="noopener">http://www.cnblogs.com/mushroom/p/4472369.html</a></p></blockquote><p>d. 虚拟桶分片：</p><blockquote><p><a href="http://www.cnblogs.com/mushroom/p/4542772.html" target="_blank" rel="noopener">http://www.cnblogs.com/mushroom/p/4542772.html</a></p></blockquote><h2><span id="总结">总结</span></h2><p>对于开发者来说，Redis 是个速度非常快的 key-value 内存数据库，并提供了方便的API接口。为了最好最优的使用 Redis，需要理解哪些因素能影响到 Redis 性能，哪些数据指标能帮助我们避免性能陷阱。通过本篇，能理解Redis中的重要性能指标，怎么查看，更重要的是怎么利用这些数据排查解决Redis性能问题。</p><p>本篇博客主要翻译了一电子书的中间15页，电子书地址是</p><blockquote><p><a href="https://www.datadoghq.com/wp-content/uploads/2013/09/Understanding-the-Top-5-Redis-Performance-Metrics.pdf" target="_blank" rel="noopener">https://www.datadoghq.com/wp-content/uploads/2013/09/Understanding-the-Top-5-Redis-Performance-Metrics.pdf</a></p></blockquote><p>楼主翻译水平有限，如有错误之处请多多包涵，也欢迎指出交流，希望本文对大家有所帮助。</p><blockquote><p>本文转载自：「 博客园 」，原文：<a href="http://t.cn/A6Vb0mIY" target="_blank" rel="noopener">http://t.cn/A6Vb0mIY</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;阅读目录&quot;&gt;阅读目录&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;性能相关的数据指标&lt;/li&gt;
&lt;li&gt;内存使用率used_memory&lt;/li&gt;
&lt;li&gt;命令处理总数total_commands_processed&lt;/li&gt;
&lt;li&gt;延迟时间&lt;/li&gt;
&lt;li&gt;内存碎片率&lt;/li&gt;
&lt;li&gt;回收key&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;性能相关的数据指标&quot;&gt;性能相关的数据指标&lt;/h2&gt;
&lt;p&gt;通过Redis-cli命令行界面访问到Redis服务器，然后使用info命令获取所有与Redis服务相关的信息。通过这些信息来分析文章后面提到的一些性能指标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/640-20210518134751769-2021-05-18-Y5iyDV.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;info命令输出的数据可分为10个类别，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;server&lt;/li&gt;
&lt;li&gt;clients&lt;/li&gt;
&lt;li&gt;memory&lt;/li&gt;
&lt;li&gt;persistence&lt;/li&gt;
&lt;li&gt;stats&lt;/li&gt;
&lt;li&gt;replication&lt;/li&gt;
&lt;li&gt;cpu&lt;/li&gt;
&lt;li&gt;commandstats&lt;/li&gt;
&lt;li&gt;cluster&lt;/li&gt;
&lt;li&gt;keyspace&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇主要介绍比较重要的2部分性能指标memory和stats。&lt;/p&gt;
&lt;p&gt;需要注意的是info命令返回的信息，并没有命令响应延迟相关的数据信息，所以后面会详细介绍怎么获取与延迟相关的数据指标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://www.hi-linux.com/categories/Redis/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Redis" scheme="https://www.hi-linux.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现一个支持无限层级泛域名解析的 DNS 服务器 Xip</title>
    <link href="https://www.hi-linux.com/posts/12599.html"/>
    <id>https://www.hi-linux.com/posts/12599.html</id>
    <published>2021-05-17T01:00:00.000Z</published>
    <updated>2021-05-17T02:18:52.381Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="什么是-xipio">什么是 </span></h2><p><code>xip.io</code> 是一个提供通配符 <code>DNS</code> 解析的魔法域名。你可以无需配置，将自定义的任何域名解析到指定的 <code>IP</code> 地址。假设你的 <code>IP</code> 地址是 <code>10.0.0.1</code>，你只需使用 <code>前缀域名+IP地址+xip.io</code> 即可完成相应自定义域名解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.1.xip.io         # 解析到 10.0.0.1</span><br><span class="line">www.10.0.0.2.xip.io     # www 子域解析到 10.0.0.2</span><br><span class="line">mysite.10.0.0.3.xip.io  # mysite 子域解析到 10.0.0.3</span><br><span class="line">foo.bar.10.0.0.4.xip.io # foo.bar 子域解析到 10.0.0.4</span><br></pre></td></tr></table></figure><p><code>xip.io</code> 使用上已经很简单了，如果你想使用自己的域名来实现一个类似 <code>xip.io</code> 同样功能也是很容易的。你只需部署一个 <code>xip.name</code> 的开源软件就可以简单实现了!</p><h2><span id="什么是-xipname">什么是 </span></h2><p><code>xip.name</code> 是受 <code>xip.io</code> 启发，使用 <code>Golang</code> 开发的一个支持通配符的 <code>DNS</code> 服务器。</p><blockquote><p>项目地址：<a href="https://github.com/peterhellberg/xip.name" target="_blank" rel="noopener">https://github.com/peterhellberg/xip.name</a></p></blockquote><p><a href="http://xip.name" target="_blank" rel="noopener">xip.name</a> 也同样提供了一个和 <a href="http://xip.io" target="_blank" rel="noopener">xip.io</a> 类似的公共 DNS 服务，它的使用上和 <code>xip.io</code> 无异。你同样可以直接使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.1.xip.name         # 解析到 10.0.0.1</span><br><span class="line">www.10.0.0.2.xip.name     # www 子域解析到 10.0.0.2</span><br><span class="line">mysite.10.0.0.3.xip.name  # mysite 子域解析到 10.0.0.3</span><br><span class="line">foo.bar.10.0.0.4.xip.name # foo.bar 子域解析到 10.0.0.4</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="xipname-部署教程"> 部署教程</span></h2><p><strong>前置条件：</strong></p><ul><li>一台有公网 <code>IP</code> 并开放 <code>53</code> 端口的服务器</li><li>一个有管理权限的域名</li><li>一个提供支持通配 <code>NS</code> 记录的 <code>DNS</code> 解析服务的帐号</li></ul><h3><span id="安装-xipname">安装 </span></h3><p><code>xip.name</code> 使用 <code>Go</code> 语言开发，通常情况下，安装是很容易的，你只需直接下载并放到相应路径即可使用它。</p><p>由于 <code>xip.name</code> 项目没有直接提供二进制包下载，所以这里我们使用 <code>go</code> 命令进行源码下载后，进行编译安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装 GO 环境</span><br><span class="line">$ yum install -y golang</span><br><span class="line"># 获取、编译代码</span><br><span class="line">$ go get github.com&#x2F;peterhellberg&#x2F;xip.name</span><br><span class="line"># 将编译好的二进制文件放到系统 PATH 路径下</span><br><span class="line">$ cp go&#x2F;bin&#x2F;xip.name &#x2F;usr&#x2F;local&#x2F;bin&#x2F;xip</span><br></pre></td></tr></table></figure><p>安装完成后，我们给 <code>xip.name</code> 增加一个 <code>Systemd</code> 配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt; EOF &gt; &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;xip.service</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;xip</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;xip -ip 0.0.0.0 -fqdn ywzm.org.</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p>注： ExecStart 配置的启动命令的 -fqdn 是用来定义 DNS 服务器要支持的域名，这里设置的是 <a href="http://ywzm.org" target="_blank" rel="noopener">ywzm.org</a>.。你可以根据实际情况进行调整。</p></blockquote><p>一些常规的 <code>xip</code> 服务管理操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 启动 xip</span><br><span class="line">$ systemctl start xip</span><br><span class="line"># 关闭 xip</span><br><span class="line">$ systemctl stop xip</span><br><span class="line"># 重启 xip</span><br><span class="line">$ systemctl restart xip</span><br><span class="line"># 配置开机自启 xip</span><br><span class="line">$ systemctl enable xip</span><br></pre></td></tr></table></figure><h3><span id="配置-dns">配置 DNS</span></h3><p>要成功实现 <code>xip.name</code> 提供的服务，只部署相关程序是不够的。还需要配置你自定义域名的 <code>NS</code> 解析记录，目前国内支持通配 <code>NS</code> 记录的免费 <code>DNS</code> 服务商不多，这里我使用的是阿里云 <code>DNS</code> 解析。</p><p>配置其实也很简单，主要需要配置一个通配的 <code>NS</code> 记录和一个指向 <code>DNS</code> 服务器的 A 记录。</p><p>以我的域名 <a href="http://ywzm.org" target="_blank" rel="noopener">ywzm.org</a> 为例，假设部署 <a href="http://xip.name" target="_blank" rel="noopener">xip.name</a> 服务器的公网 IP 是 <code>11.22.33.44</code>。DNS 就应该增加以下两条解析记录：</p><ul><li>增加一条通配 NS 记录解析到 <a href="http://ns1.ywzm.org" target="_blank" rel="noopener">ns1.ywzm.org</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  ns ns1.ywzm.org</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/image-20210425142336948-2021-04-25-u6uGGL.png" alt></p><ul><li>增加一条 A 记录解析到 11.22.33.44</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ns1.ywzm.org  A  11.22.33.44</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/image-20210425142441740-2021-04-25-6911Td.png" alt></p><p>以上配置好就完成了，看下最终效果吧！</p><p><img src="https://img.hi-linux.com/staticfile/image-20210425142632078-2021-04-25-jrYChV.png" alt></p><p>最后，我们来验证一下吧：</p><p><img src="https://img.hi-linux.com/staticfile/image-20210425145305223-2021-04-25-bk0Kaq.png" alt></p><p>从上面的结果可以看到，我们并未对域名进行任何配置就自动实现了相应解析，是不是很给力呢？有兴趣的同学赶紧用起来吧！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-xip-io&quot;&gt;什么是 &lt;a href=&quot;http://xip.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xip.io&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;xip.io&lt;/code&gt; 是一个提供通配符 &lt;code&gt;DNS&lt;/code&gt; 解析的魔法域名。你可以无需配置，将自定义的任何域名解析到指定的 &lt;code&gt;IP&lt;/code&gt; 地址。假设你的 &lt;code&gt;IP&lt;/code&gt; 地址是 &lt;code&gt;10.0.0.1&lt;/code&gt;，你只需使用 &lt;code&gt;前缀域名+IP地址+xip.io&lt;/code&gt; 即可完成相应自定义域名解析。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10.0.0.1.xip.io         # 解析到 10.0.0.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;www.10.0.0.2.xip.io     # www 子域解析到 10.0.0.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysite.10.0.0.3.xip.io  # mysite 子域解析到 10.0.0.3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo.bar.10.0.0.4.xip.io # foo.bar 子域解析到 10.0.0.4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;xip.io&lt;/code&gt; 使用上已经很简单了，如果你想使用自己的域名来实现一个类似 &lt;code&gt;xip.io&lt;/code&gt; 同样功能也是很容易的。你只需部署一个 &lt;code&gt;xip.name&lt;/code&gt; 的开源软件就可以简单实现了!&lt;/p&gt;
&lt;h2 id=&quot;什么是-xip-name&quot;&gt;什么是 &lt;a href=&quot;http://xip.name&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xip.name&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;xip.name&lt;/code&gt; 是受 &lt;code&gt;xip.io&lt;/code&gt; 启发，使用 &lt;code&gt;Golang&lt;/code&gt; 开发的一个支持通配符的 &lt;code&gt;DNS&lt;/code&gt; 服务器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/peterhellberg/xip.name&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/peterhellberg/xip.name&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://xip.name&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xip.name&lt;/a&gt; 也同样提供了一个和 &lt;a href=&quot;http://xip.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xip.io&lt;/a&gt; 类似的公共 DNS 服务，它的使用上和 &lt;code&gt;xip.io&lt;/code&gt; 无异。你同样可以直接使用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10.0.0.1.xip.name         # 解析到 10.0.0.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;www.10.0.0.2.xip.name     # www 子域解析到 10.0.0.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysite.10.0.0.3.xip.name  # mysite 子域解析到 10.0.0.3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo.bar.10.0.0.4.xip.name # foo.bar 子域解析到 10.0.0.4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="DNS" scheme="https://www.hi-linux.com/categories/DNS/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>你在拥有「加密货币」前，必须要搞清楚的事</title>
    <link href="https://www.hi-linux.com/posts/6273.html"/>
    <id>https://www.hi-linux.com/posts/6273.html</id>
    <published>2021-05-13T01:00:00.000Z</published>
    <updated>2021-05-13T07:46:27.256Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>相对于通过数字货币的获利、区块链的技术原理，如果你更想了解如何拥有自己的加密货币、不同的<strong>加密货币有何区别</strong>、加密货币的<strong>应用场景</strong>，或是<strong>参与到加密货币</strong>的洪流里来，希望本文能够给到一定帮助。文中个别链接需要在特殊网络环境下访问。需要注意，<strong>本文不具有任何投资建议</strong>。</p><p>和历年来科技上大部分的新技术不同，区块链技术在给大众生活带来显著正面影响之前，就已经带来了显著又负面的大范围影响——显卡涨价。而在本文编辑的这段时间里，热度旺盛的 Chia 币因为其需要通过硬盘参与挖矿，导致了大容量硬盘继显卡后成为了下一个「受害者」。</p><a id="more"></a><p>由此很多人莫名其妙进入了这挖矿狂潮的辐射范围内，一些人开始通过抢购、倒卖显卡、组装矿机挖矿、囤积硬盘等等形式从中获利，甚至有网吧老板关门挖矿。区块链技术和比特币就以这样的方式「火」了起来。</p><p><img src="https://img.hi-linux.com/staticfile/1-2021-05-13-njL8AJ.png" alt="官网标注售价 3899 元起的显卡 RTX 3070 如今在京东随手一搜就是 11000+ 元的售价"></p><h2><span id="那些陌生的名词">那些陌生的名词</span></h2><p>以下挑选下文中出现的几个相对陌生的名词，仅以不影响阅读体验的最低程度展开介绍。想要更精准全面地了解相关名词需要另外查阅。</p><h3><span id="公有链"><strong>公有链</strong></span></h3><blockquote><p>公有链是指全世界任何人都可读取、发送交易且交易能获得有效确认的、也可以参与其中共识过程的区块链。</p></blockquote><p><a href="https://baike.baidu.com/item/%E5%85%AC%E6%9C%89%E9%93%BE/22447233?fr=aladdin" target="_blank" rel="noopener">公有链</a>（公共区块链）一般被称为公链，一般理解为记录信息的公共「账本」或是构建应用的「操作系统」，最为人熟知的账本有比特币、以太坊、EOS 等，不同的公链上的交易手续费（Gas Fee）与并发量（每秒处理的交易量）都可能不同，导致了不同程度的网络拥堵，也会影响到交易中的到账时间。</p><h3><span id="同质化代币ft">同质化代币（FT）</span></h3><p>大多数人了解的 BTC、ETH 等加密货币多数是同质化代币。像💴人民币、💵美元也是广义上的同质化代币，两张不同的一元人民币在价值上是不会有任何区别的（不考虑错版、靓号等特殊情况），同质化代币互相能够替换，具有统一性、可接近无穷拆分的特性。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043141-2021-05-13-3NUd5Z.png" alt></p><h3><span id="非同质化代币nft">非同质化代币（NFT）</span></h3><p>NFT 即非同质化代币（Non-Fungible Token），具有不可分割、不可替代、独一无二等特点。在现实生活中具有实际价值的事物是不可替代的，如一份📜合同、🏠房屋产权、🎨艺术作品、出生证明等，为了能数字化这些资产，就诞生了 NFT 这一概念。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043168-2021-05-13-0Y3U96.png" alt></p><p>NFT 这一概念最早产生于「<a href="https://cryptokitties.co/" target="_blank" rel="noopener">加密猫</a>」——全球首款区块链游戏，这么简单的一张图能卖上千元，离不开这张图在区块链上这一特性，保证了这猫咪在数字世界中的独一无二，即便这张图谁都可以保存数字版或打印出来一万份，也只有掌握「密码」的人能拥有这猫咪的价值或售卖交易。</p><blockquote><p>加密猫是一群讨人喜欢的数字喵咪，每一只猫咪都拥有独一无二的基因组，这决定它的外观和特征。玩家可以收集和繁殖喵咪，创造出全新的喵星人并解锁珍稀属性。</p></blockquote><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043181-2021-05-13-FKF8dG.png" alt="基于不同毛色、稀有度的价格不一的加密猫"></p><p>「加密猫」只是 NFT 中的开始，极具知名度的奢侈品品牌「GUCCI」「DC 漫画」「NBA」「波多野结衣」等等，都有宣布关于 NFT 的计划或已卖起了各自的 NFT 。</p><p><img src="https://cdn.sspai.com/2021/05/07/cbc3221dae42b4a0ec73e4b5fc32959e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><h3><span id="dapp">DApp</span></h3><p>DApp 即去中心化应用（Decentralization Application），实际上还是 app，只是有着去中心化的属性，不部署在中心化的服务器当中。也因为这个特性，影响到普通用户的地方主要在于 DApp 中的交易行为都需要连接到去中心化钱包，一般 PC 在浏览器中打开 DApp，然后连接到钱包插件；；手机端则是在钱包 app 内嵌的浏览器中打开 DApp 然后再连接到当前的钱包。</p><p><img src="https://cdn.sspai.com/2021/05/08/e5ef651a0c8f22046623f1d651016ce4.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><h3><span id="去中心化钱包">去中心化钱包</span></h3><p>去中心化钱包的奇怪名称起源于区块链技术的应用，可以简单理解为可以存放各种加密货币的钱包，是数字货币界中的「支付宝钱包」「微信钱包」。</p><p>PC 端操作可以在 Edge 或 Chrome 浏览器中下载一个去中心化钱包插件，在这里推荐「<a href="https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn" target="_blank" rel="noopener">MetaMask</a>」。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043299-2021-05-13-oyiUOa.png" alt="MetaMask"></p><p>而手机应用中常用的也有 「<a href="https://tokenpocket.pro/" target="_blank" rel="noopener">TokenPocket</a>」「<a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>」「<a href="https://trustwallet.com/" target="_blank" rel="noopener">Trust Wallet</a>」等。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043321-2021-05-13-059jzA.png" alt></p><p>另外一点需要注意的区别在于钱包不再以你身份信息、手机号码、认证邮箱作为被盗后找回密码的依据，取而代之的是「助记词」，需要谨慎保存。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043365-2021-05-13-jvb5fO.png" alt></p><p><img src="https://cdn.sspai.com/2021/04/29/f05fb693e509674858e0c4760d1e32e8.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><p>关于助记词，要是钱包没钱，也大可不必把这助记词的安全当回事🙄。但如果数字惊人，可以抄写到自己墙上，万一有好学的侄子侄女问起来怎么解释？当然是告诉他/她这是中考重点单词建议抄写背诵。</p><h2><span id="从哪里获取加密货币">从哪里获取加密货币</span></h2><h3><span id="参加空投">参加空投</span></h3><p>许多尚未发行或廉价的币为了提高知名度、宣传项目，会提供空投活动，免费发放各式各样的加密货币，除了部分含金量较高的加密货币为了防止不可控的白嫖，会要求钱包里预存一定等值金额的币种才能收到空投。</p><p>而大部分空投活动中要求的是只需动动手指就能完成的任务，像关注推特账号、转发推特、加入 「Discord」「Telegram」 频道、登记钱包地址、每日签到、邀请好友、位于积分排行榜前列等等。比起拼多多的无底线拉新活动，这些项目团队设置的规则要老实得多，自行配置好网络条件以及注册一个去中心化钱包后，可以通过空投导航网站 <a href="https://tokenairdrop.org/" target="_blank" rel="noopener">币空投</a> 体验白嫖空投的快感。</p><p><img src="https://cdn.sspai.com/2021/04/21/720e6044479bf8024797bed089f902df.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><h3><span id="交易所获取">交易所获取</span></h3><p>由于 2017 年 9 月 4 日开始国内禁止交易所运营，内地环境中的手机应用商店也没有任何交易所 app 可供下载，身处港澳台以及国外的读者可以自行了解主流交易所。</p><h3><span id="家用机挖矿">家用机挖矿</span></h3><p>如果你家里恰好有一台性能不错的机器，那么仅需要电费和时间，就能获得不同种类的加密货币，这类软件有很多，以 <a href="http://www.qskg.top/welcome.html" target="_blank" rel="noopener">轻松矿工</a> 为例，支持多个币种，操作傻瓜化，相对适合我们这种尝尝鲜并不打算以此盈利的小白用户。但不是所有币种都能通过硬件挖矿的方式获取，能选择的币种相当有限。</p><h3><span id="朋友转账">朋友转账</span></h3><p>注册好去中心化钱包后，1️⃣选择好一条公链2️⃣复制你的钱包地址3️⃣找到一个有加密货币的朋友（重点🐢）。然后就可以告诉你的朋友让他给你转账啦！</p><p>数字货币钱包之间的转账行为区别于并没有我们常用的如支付宝、银行转账的体验如此之好，除了需要提供钱包地址，还需要确定公链的选择，不同公链上的交易手续费用（Gas Fee，即矿工费）、网络拥堵程度（影响到账时间）都不同。要是两个信息（钱包地址、公链）选错了一个，就只能做好准备接受数字货币消失带来的悲痛了💔。</p><h2><span id="加密货币不止比特币">加密货币不止比特币</span></h2><p>就我身边群体而言，大部分人只知道比特币，而实际上加密货币种类可谓是百花齐放，其中也包括一些相当<strong>有趣</strong>（但不具有投资价值）的币种。</p><p><img src="https://cdn.sspai.com/2021/04/27/8a185f6beb16b5d5bdf8f66ecf76778f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt>加密货币市值分布</p><h3><span id="doge狗狗币">Doge（狗狗币）</span></h3><p><img src="https://cdn.sspai.com/2021/04/27/ad4a2ab01d2a1ea19aadbde7ed39869d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt>Dogecoin</p><p>Doge（狗狗币）可谓是加密货币中的「潮牌」。Adobe 任职的 Jackson Palmer 觉得好玩把Doge Meme 加入到加密货币后便一发不可收拾，狗狗币诞生后便在国外论坛 Reddit 上一直保持着惊人的热度。而后被作为各种社交平台的打赏道具，赞助了各种慈善活动和赛事，特斯拉 CEO 马斯克对其“可能是我最喜欢的数字货币”的评价，陆续被作为各个平台的支付手段，因此用户量和市值也在不停增长，这个相当不正经的数字货币目前已经成为了有着市值前十的货币之一。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043526-2021-05-13-DADPFm.png" alt="马斯克日常推特 cue 狗狗币"></p><h3><span id="mona萌奈币">Mona（萌奈币）</span></h3><p><img src="https://cdn.sspai.com/2021/05/08/8729ad399a2c1e3e223239ebee45d8a2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt>Monacoin</p><p><a href="https://monacoin.org/" target="_blank" rel="noopener">Mona</a>（萌奈币）是日本本土的首个加密货币，在（也仅仅在）日本拥有庞大的支持社区（<a href="https://monappy.jp/" target="_blank" rel="noopener">Monappy</a>），在社区中的各种交易行为都可以通过 Mona 来支付。包括游戏充值、文章打赏、图片打赏、自由买卖、购买礼品卡赠送等等。</p><p><img src="https://cdn.sspai.com/2021/05/08/b7b4bbb66e486c9d7fb5e14bb861c7c6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><h3><span id="flow">Flow</span></h3><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043605-2021-05-13-gEQuMt.png" alt></p><p><a href="https://www.onflow.org/" target="_blank" rel="noopener">Flow</a> 是 NFT 的公链代币，由前文提及到的「加密猫」团队打造，而 NBA 也基于 Flow 公链开发了「<a href="https://nbatopshot.com/" target="_blank" rel="noopener">NBA TOP SHOT</a>」  这一火爆的 DApp。购买 NFT 并非必须使用 Flow 付款，所以对于仅仅想要购买 NFT 的人而言可以选择忽略 Flow。</p><blockquote><p>Open Worlds</p><p>Flow is a new blockchain built for the next generation of apps, games, and the digital assets that power them.（Flow 定义为“开放世界的区块链”，旨在成为下一代游戏、应用程序及数字资产的基础。）</p></blockquote><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043646-2021-05-13-dbMc3A.png" alt="Flow 社区中还有 UFC、育碧、三星等知名赛事/企业"></p><h3><span id="shib柴犬币">SHIB（柴犬币）</span></h3><p><img src="https://cdn.sspai.com/2021/05/09/bec63295e1299fed885e07a3306040b2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt>SHIB</p><blockquote><p>What would happen if a crypto currency project was 100% run by its community?（如果一个加密货币项目 100% 由其社区管理会发生什么？）</p></blockquote><p><a href="https://www.shibatoken.com/" target="_blank" rel="noopener">SHIB（柴犬币）</a>来自于一个去中心化自发社区「Shiba Inu」的实验，团队在白皮书中如此描述去中心化社区：建立在社区参与基础上的项目是我们未来里待征服的荒漠。当我们离僵化的金融结构和传统思维方式越来越远，我们发现了解决问题与相互产生联系的新方式。当成功仅取决于组织创建团队的力量时，我们为了和其他人保持一致而改变了自己的观点。通过研究社区成员后发现力量并非来源与个体而是和谐的团体合作。而其创造的社区的代币「SHIB」也被称为「狗狗币杀手」,同时又是一个被马斯克「带货」而爆红的加密货币。</p><h3><span id="其他山寨币">其他山寨币</span></h3><p>「山寨币」并没有明确的定义和覆盖范围，用来统称一些没有明显创新和实用价值，市价极其不稳定，崩盘风险极高，常被用来投机交易的币种，而被称为山寨币中的莱特币和狗狗币甚至有着前十的市值。但有许多山寨币仅凭借着吸引眼球的名字便吸引了不少的持币者。</p><p><img src="https://cdn.sspai.com/2021/05/09/689eca4fc75ecae8e67de0a6b7c82e97.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt>LOWB</p><p>「<a href="https://losercoin.org/" target="_blank" rel="noopener">LOWB</a>」又称为 Loser Coin，这一符合当代青年自嘲特性的名字完全不输狗狗币。而其创立背景也名副其实：</p><blockquote><p>中国一个四线城市的贫困青年，邀请另一位贫困程序员，一同发起了Loser Coin项目，代币 LOWB。两人于 17 年接触 BTC，进入币圈，陆续炒币亏了许多钱，本次抱着归零的心态，成立此项目，在项目上线当天拿出全部积蓄添加流动性池子。本项目承诺不护盘（主要没实力），不跑路（无私募公募）。</p></blockquote><p>官网中的介绍有着相当贴地气的颓废和鸡血，👻看起来压根不打算找得到投资的样子。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043738-2021-05-13-D6rHua.png" alt></p><h2><span id="多多少少有点用处">多多少少有点用处</span></h2><p>世界上第一个加密货币比特币的白皮书上第一段话如此写道：</p><blockquote><p>本文提出了一种完全通过点对点技术实现的电子现金系统，它使得在线支付能够直接由一方发起并支付给另外一方，中间不需要通过任何的金融机构。</p></blockquote><p>可以知道的是创造者中本聪的初衷与目前大家感知到的炒币、挖矿、炒显卡、屯硬盘大相径庭，也是因为这些加密货币直接给人们带来的负面影响，很多人对加密货币嗤之以鼻，诸如「污染环境」「浪费资源」「影响显卡价格」「傻子才买」「割韭菜」等评价，但除了这些缺点，目前加密货币也已经有许多较为实用的应用场景。</p><h3><span id="藏品">藏品</span></h3><p><a href="https://opensea.io/" target="_blank" rel="noopener">OpenSea</a> 是全球第一个也是目前最大规模的 NFT 市场，可以购买「艺术品」「域名」「虚拟世界（Virtual Worlds）」「交易卡（Trading Cards）」「收藏品（Collectibles）」等各种分类的 NFT。</p><blockquote><p>Discover, collect, and sell extraordinary NFTs</p><p>on the world’s first &amp; largest NFT marketplace</p></blockquote><p><img src="https://cdn.sspai.com/2021/05/08/8674ee3052051d85f8c450b641b72480.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="马斯克再次客串"></p><p>近期在 OpenSea 上拍卖最引人注目的 NFT 之一，是街头艺术家 Banksy 的画作《Morons》（《白痴》），有趣的是这张画作本身是实体艺术品，被区块链公司 Injective Protocol 买下来后便在网络直播中销毁了实体，利用区块链技术做数位化处理后作为 NFT 拍卖，价格也从买入价 9.5 万美元翻了四倍以 38 万美元成交。更有趣的是 Banksy 这张画意在讽刺 1987 年梵高作品《Sunflowers》拍卖会现场，作品上写下「I can’t believe you morons actually buy this shit.」</p><p><img src="https://cdn.sspai.com/2021/05/08/a6b168df40d166716b7cc7a30a7de846.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="《Morons》"></p><p>而另一张著名的纯 NFT 画作《EVERYDAYS: THE FIRST 5000 DAYS》，诞生于数码艺术家 Beeple（Mike Winkleman）之手，是历史上第一次在大型拍卖行以 NFT 形式进行拍卖的纯数码拍品，最终在佳士得拍卖行以 6900 万美元成交。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043898-2021-05-13-JV5B1t.jpeg" alt="《EVERYDAYS: THE FIRST 5000 DAYS》"></p><p>如果对艺术品没有兴趣，NBA 爱好者还能通过「<a href="https://www.nbatopshot.com/" target="_blank" rel="noopener">NBA TOP SHOT</a>」中购买各种 NFT 卡包，解锁不同稀有度的球星卡片，不同球星的拉杆、隔扣、绝杀、退役录像/图片，作为你偶像名场面在区块链上的拥有者，这独特的 NFT 相信比保存在相册里的视频更加珍贵（价钱也确实很珍贵）。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043936-2021-05-13-7qHfuN.png" alt></p><p>颇有知名度日本女演员波多野结衣、上原亚衣等，也推出了自己的 NFT 形式的写真集，相比纸质版的写真集，也多出了游戏上常用的盲盒玩法以及稀有度机制，区分了普通、高级、稀有、珍奇、史诗、传说多个档次，除了二次市场的价格以外，实际上不同稀有度的写真也确实有所不同（就是你想象的那样）。</p><p><img src="https://cdn.sspai.com/2021/05/08/1994dffdb2dafa4ba4aab9d7a1829974.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><h3><span id="游戏">游戏</span></h3><p>依赖区块链技术上的三个特性：公开性、安全性和唯一性，区块链游戏也找到了一席之地，去中心化的游戏保证了以前从来没有的公平，因为数据上链，游戏里的资产都只属于玩家，由玩家进行自由交易，游戏厂商不能做出诸如收回、销毁等操作的干预，而老网游玩家必定经历过的数据泄露或资产被盗成为了不再需要担心的问题等等优势。</p><p><img src="https://cdn.sspai.com/2021/05/08/5ff1462e82e82857e68f13900f0567e2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="基本区块链游戏都会在首页中宣传基于区块链所获得的游戏特性；来源：「加密三国」"></p><p>除了以上提到的改变，即便区块链游戏的前期玩家通常都能有机会通过质押挖矿等形式获得游戏的分红，游戏本身的乐趣并没有因为区块链的技术带来显著的体验加强，目前游戏的玩法也是早已普遍的卡牌、养成、创造类游戏，还有许多可玩性一眼望穿且极具 4399 既视感的游戏，作为一名游戏玩家，区块链游戏的特点中我只对「资产自由交易」这一点比较感兴趣，在「地下城与勇士」「梦幻西游」等游戏中混迹大小街头摆摊，刷出深渊史诗转手拍卖的体验在如今的游戏中已几乎绝迹。</p><p>「<a href="https://www.sandbox.game/en/" target="_blank" rel="noopener">The Sandbox</a>」是区块链游戏中关注度较高的代表之一，游戏类型为沙盒游戏，允许玩家买卖土地、个人创作的模型资产。虽然目前还在预注册阶段，但精美的 UI、已公布的丰富的游戏元素也能让玩家们以小见大了。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133044086-2021-05-13-dpKZ20.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133044148-2021-05-13-mRL7Vq.png" alt></p><h3><span id="购物">购物</span></h3><p>除了像 OpenSea 的各个 NFT 交易平台提供了使用加密货币进行支付以外，目前也有越来越多的品牌、电商平台提供了使用加密货币付款的支付方式。而像苹果礼品卡兑换、亚马逊购物、微软积分兑换、网络域名购买、订阅 Twitch 流媒体付费服务、连锁餐饮店支付、航空公司服务支付等等，加密货币的用途也在不断地扩大范围，覆盖人们的购物行为。</p><h2><span id="结语">结语</span></h2><p>体验了各种加密货币的应用后，能感受到这些应用场景中的各种不完善。</p><ul><li>区块链游戏中总是强调着并不能带来乐趣的去中心化特性，和堆砌在显眼的位置上的一堆陌生术语，让只想玩游戏的我兴致全无。</li><li>各种去中心化钱包的交互体验堪比 2010 年的各大银行 app 般难用。</li><li>各个平台使用加密货币作为支付手段的流程相当复杂，主流币种每次交易需扣除的手续费（Gas Fee）也并不低廉，让这种概念先进的支付手段成了麻烦又昂贵的选择。</li></ul><p>总得来说这种种糟糕的体验就像是一台 Microsoft HoloLens ，除了让我这普通互联网用户感觉到「牛」之外，并没有带来实用价值。</p><p>这种情况也是部分互联网用户对于加密货币的应用还比较陌生的原因，但不能否认加密货币在全球范围内正蓬勃发展，即便带来了许多让人懊恼的负面影响，也或多或少正面影响甚至改变了如购物、社区、艺术品、音乐、游戏等多个领域的发展方向。</p><p>感谢你看到这里，本文仅从自身兴趣角度片面地泛泛而谈，如有错误欢迎指出。</p><blockquote><p>本文转载自：「 少数派 」，原文：<a href="https://sspai.com/post/65694" target="_blank" rel="noopener">https://sspai.com/post/65694</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相对于通过数字货币的获利、区块链的技术原理，如果你更想了解如何拥有自己的加密货币、不同的&lt;strong&gt;加密货币有何区别&lt;/strong&gt;、加密货币的&lt;strong&gt;应用场景&lt;/strong&gt;，或是&lt;strong&gt;参与到加密货币&lt;/strong&gt;的洪流里来，希望本文能够给到一定帮助。文中个别链接需要在特殊网络环境下访问。需要注意，&lt;strong&gt;本文不具有任何投资建议&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;和历年来科技上大部分的新技术不同，区块链技术在给大众生活带来显著正面影响之前，就已经带来了显著又负面的大范围影响——显卡涨价。而在本文编辑的这段时间里，热度旺盛的 Chia 币因为其需要通过硬盘参与挖矿，导致了大容量硬盘继显卡后成为了下一个「受害者」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链" scheme="https://www.hi-linux.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="区块链" scheme="https://www.hi-linux.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Docker 兴衰记 | 十年弹指一挥间，看容器霸业谁主沉浮！</title>
    <link href="https://www.hi-linux.com/posts/176.html"/>
    <id>https://www.hi-linux.com/posts/176.html</id>
    <published>2021-05-08T01:00:00.000Z</published>
    <updated>2021-05-08T01:34:39.445Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>Docker support in the kubelet is now deprecated and will be removed in a future release. The kubelet uses a module called “dockershim” which implements CRI support for Docker and it has seen maintenance issues in the Kubernetes community. We encourage you to evaluate moving to a container runtime that is a full-fledged implementation of CRI (v1alpha1 or v1 compliant) as they become available. (#94624, @dims) [SIG Node]</p></blockquote><p>上述引言来自 Kubernetes 1.120 的 Release Note，标志着 Docker 的丧钟进入尾声。事实上，当 2018 年 Docker 创始人 CTO Solomon Hykes 宣布离职时，Docker 和公司的命运已是江河日下。在复杂商业利益的驱使和一意孤行的错误决策下，从 2016 年至今诞生了 CRI、OCI 等标准和 Containerd、Runc、Docker-shim、CRI-O 等眼花缭乱却、功能盘龙交错重叠的项目，Kubelet 和容器运行时的调用链路复杂冗长且多次变化，整个生态为此苦不堪言。</p><p>回想 1981 年 IBM 推出 PC 时，采用了非常开放的标准，凝聚了硬件和软件的生态，迅速占据市场第一把交椅。开放也导致了广大廉价而有竞争力的兼容机出现，渐渐蚕食 IBM 的市场份额。于是 1987 年 IBM 从开放走向封闭，推出一款不再兼容外部硬件的机器 IBM PS/2，彻底走上了一条不归路，失去市场的同时失去了 PC 产业话语权。让我们再次回顾 Docker 从一鸣惊人再到由盛而衰的历史，并思考开源商业、技术和文化和内在逻辑和一些教训。</p><a id="more"></a><h2><span id="小船出海">小船出海</span></h2><p>PaaS 历来是兵家必争之地，通过类似 Container 技术将应用封装并交由编排系统管理，将给 DevOps 带来巨大的效率和成本优化。2002 年诞生的 linux namespace 和 2006 年诞生的 cgroup 为此奠定基本技术基础，此后 Google 和百度依次建设了 Borg 和 Matrix 平台，并取得巨大的成功；与此同时开源界也诞生了 Cloud Foundry 等项目。但在外人看来，Borg 和 Matrix 只闻其名，未见其实；而 Cloud Foundry 一直不愠不火，未得到广泛的普及。</p><p>究其根本原因乃是对应用(交付)的标准抽象的不过友好。以 Cloud Foundry 为例，它针对每种语言指定了一系列的标准，比如目录、可执行文件、二进制等等。这用在内部场景用无可厚非，绝大部分上规模的公司都会为应用设定一系列的规则，比如编码、配置、打包、运行环境和依赖，并形成各自的特色的标准；但是放眼整个生态，这种要求过于苛刻而缺乏普及性。Docker 真正革命之处在于开创了基于镜像交付应用的先河，它把应用的代码、配置和所有用户态层次依赖的整合成一个镜像，保证了运行环境的高度闭环和统一，对宿主机的依赖仅限于内核，而内核的 posix 接口非常稳定和兼容，所以保证了 Docker 镜像具有一次制作，四处运行的强大兼容强大威力。</p><p>2013 年，成立三年的 dotCloud(Docker 公司前身) 在 PaaS 平台产品商业化走到穷途末路时选择了开源核心引擎 Docker，换来的是柳暗花明又一村。这种轻量级虚拟化、语音无关、可移植性强的技术给出完美的应用交付标准，直击用户痛点，立马一石激起千层浪。这一年，Docker 迅速成长为云计算领域最受欢迎的项目，诸多巨头逐步增加了对 Docker 的支持，很多应用软件的交付也提供了 Docker 镜像；这一年，dotCloud 更名为 Docker，注册了 Docker 商标，出售了 PaaS 平台产品，全力转向 Docker 技术研发和生态建设。</p><p>此后的两年里，Docker 的发展可谓顺风顺水，生态版图持续扩大，从 linux 到 windows，从云计算到广义的应用市场，已俨然成为容器的标准。即使 Google 和 CoreOS 强势推出竞品 lmctfy 和 rkt，面对已成气候的 Docker 毫无招架之力。伴随生态的成功，Docker 前后拿下 4000万刀和 9500万刀的两轮重要融资补充粮草。当 2016 年夏天 DockerCon 举办时，Docker Hub 镜像总下载数量高达 40 多亿次，甚至一度传出微软欲以 40 亿美金收购这家只有数百人的公司！</p><h2><span id="群雄逐鹿">群雄逐鹿</span></h2><p>技术的持续发展离不开商业化的支持，Docker 作为一家创业公司从出身就背负着商业化的根本任务。尽管取得生态和技术上的巨大成功，带来了普世的巨大价值，却面临着商业化的巨大挑战。和其它通用而基础的开源技术一样，比如操作系统 linux、编译工具 GCC、虚拟化技术 Qemu-KVM，开源决定了 Liscense 之路不通，而单一的技术无法带来服务的溢价。打造 PaaS 平台层次的产品便成最具备可行性之路，和 2013 年卖掉 PaaS 平台相反，2014 年 Docker 收购 Fig 项目，以此推出编排产品 Docker Swarm，拉开了编排领域群雄逐鹿的帷幕。</p><p>开源的长河充满了合作和竞争，推动着生态不断发展和演进。这一年，Mesos 背后的公司 Mesospheres 推出 Marathon 项目；Google 基于 Borg 推出开源版本的编排项目 Kubernetes。和 Google、Redhat 等深谙道理的老玩家相比，年少气盛的 Docker 公司显得不易相处，2014 年 Docker 项目最早积极贡献者 CoreOS 不久后分道扬镳，和 Google、Redhat 创建了 OCI 规范，定义了容器运行时标准，妥协之下 Docker 公司从 libcontainer 捐献出 RunC 项目作为符合 OCI 标准的容器运行时。2015 年 Google、Redhat 等共同发起了 CNFC 基金会，并迅速增加了 Prometheus、Etcd、Helm、CNI 等众多知名项目，生态发展的风向标逐步由 Docker 转向 Kubernetes，开始建造了坚固的护城河。</p><p>当时间来到 2016 年时，一切尘埃落定，远去了鼓角争鸣，Kubernetes 已成了容器编排领域的绝对标准。和暴发户 Docker 如日中天变得专横独断相比，K8S 民主化的风格和 Plugin 的架构迅速的吸引了周边的生态伙伴；其次 K8S 源自于 Google 基础设施领域多年的宝贵实践和升华，其设计的理念和抽象形态更贴近本质的需求。</p><p>即使 K8S 赢得编排的标准，由于 Docker 已成容器的标准，所以早期的 Kubelet 内嵌 Docker 客户端，默认其为容器的运行时，因而从 Kubelet 到容器运行时的代码整体比较路径简短优雅 —— 容器的归容器、编排的归编排。但之后 Docker 公司祭出以自杀八百、损敌一千的姿态做出损人不利己的骚招。在面对 Swarm 的失败后，由于 Docker 名声和美誉广为人知，于是公司将 PaaS 平台的能力沉淀到名为 Docker 产品(甚至集成了 K8S)，并将 Docker 项目改名为 moby，压上名气这张最后的筹码孤注一掷。</p><p>群雄逐鹿过程中，Docker 和 K8S 之间的纠葛埋下广大同行深受其苦的坑，从 Kubelet 到运行时主要经历了如下调用链路的变更，诞生了一堆临时和更多凑热闹的项目，给广大的开发者带来沉重的心智负担，留下一地鸡毛。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+    +---------+    +-----------+</span><br><span class="line">| Kubelet(Dockerclient) | -&gt; | Dockerd | -&gt; | Container |</span><br><span class="line">+-----------------------+    +---------+    +-----------+</span><br><span class="line"></span><br><span class="line">+--------------+    +-------------+    +---------+    +------------+    +------+    +------------+</span><br><span class="line">| Kubelet(CRI) | -&gt; | Docker-shim | -&gt; | Dockerd | -&gt; | Containerd | -&gt; | Runc | -&gt; | Containers |</span><br><span class="line">+--------------+    +-------------+    +---------+.   +------------+    +------+    +------------+</span><br><span class="line"></span><br><span class="line">+--------------+    +----------------+    +------------+    +------+    +-----------+</span><br><span class="line">| Kubelet(CRI) | -&gt; | CRI-Containerd | -&gt; | Containerd | -&gt; | RunC | -&gt; | Container | </span><br><span class="line">+--------------+    +----------------+    +------------+    +------+    +-----------+</span><br><span class="line"></span><br><span class="line">+--------------+    +------------+    +------+    +-----------+</span><br><span class="line">| Kubelet(CRI) | -&gt; | Containerd | -&gt; | RunC | -&gt; | Container | </span><br><span class="line">+--------------+    +------------+    +------+    +-----------+</span><br></pre></td></tr></table></figure><h2><span id="最佳选择">最佳选择</span></h2><p>有些历史被成为绝唱，那是因为没如果和重来。但是似曾相识的故事总是在不断的轮回，上世纪八十年代，蓝色巨人坐拥拥无人可撼动的市场霸主地位，当它试图以一己之力关闭兼容机的大门时，换来了作茧自缚。巅峰时期的 Docker 在生态上虽然取得了巨大的成功，但它的地位和当年的 IBM 丝毫不能相提并论，当然，这也是马后炮式的分析。</p><p>让我们站在 Docker 的曾经的巅峰上，俯瞰整个应用的交付标准唯我独尊，Docker hub 囊括了海量应用镜像，和下一个 “vmware” 相比，微软抛出区区 40 亿美金收购的橄榄枝又是多么的微不足道，我想换成任何人都愿意跃跃欲试，放手一搏向 PaaS 平台进军。当错失闪烁瞬间的机会后，便是土崩瓦解般的故事，2018 年创始人兼 CTO 离职，2019 年裁员，2020 年 Dockerhub 离奇的推出限速下载。</p><p>从商业的视角来看，基础而通用的开源技术项目本身价值和需求重大，但是成功的商业故事却寥寥无几。开源注定卖 License 之路不通，单一的基础技术很难带来服务的溢价，技术培训、二次开发的收益则是杯水车薪，而捐助等对于一家数百人的公司更天方夜谭，所以特别对于基础通用的技术来说，开源几乎不可能成为商业模式。但是从另外一个角度来说，开源更是一种市场策略，它可以快速试错，推广产品和思路，获得用户粘性，构建生态的护城河。如果顺着这个思路，从短期盈利的价值来看，Docker 公司卖给微软和 AWS 是中策，背靠着金主爸爸和强大的云计算服务；从长远的生态和普世价值角度来看，我认为 Redhat 收购 Docker 应该是最佳的选择，以 Redhat 的智慧，或将带来全方位的共赢和持久的繁荣。可以说，对于绝大部分做基础通用的开源技术产品的创业公司来说，被巨头收购已是最好的结局。</p><p>正如《大教堂和集市》所言：“开放式的文化会最终胜利，这或许不是因为”开放”在道德上正确，或者”封闭”在道德上错误，而只是因为开放式合作可以在一个问题上投入多几个数量级的技术工时，封闭的世界无法赢得这样的竞争。”当 Docker 开源时，它以新颖的理念解决应用交付的巨大痛点，描绘了 PaaS 的新蓝图，吸引了广泛的合作者。但是 Docker 的管理者既没有充分的识别和吸收他人优秀的想法，更没有良好的人际关系、交流技能和人格魅力。先后和 CoreOS、Redhat、Google 等开源巨头分道扬镳，最后又为一己之利和生态背离。开源生态的发展如一股大洪流滚滚向前，只能顺势和引领，不可阻挡，妄图借垄断之势损坏普遍大众的利益的行为只会被这股洪流冲垮和抛弃。</p><p>回首这八年，Docker 已到棺盖定论之时，它掀起了一场轰轰烈烈的 PaaS 革命，给 DevOps、云原生等带来了巨大的理念突破和奠定技术基础；而管理者的战略和战术的种种失误措施良机，接连败北，丢失了商业市场，失去了生态和名声，拉下一地鸡毛。数年以后，容器一词依旧盛行，而 Docker 或将无人提及，唯有一声叹息。</p><blockquote><p>本文转载自：「 Koala Bear 」，原文：<a href="http://t.cn/A6tYaES0" target="_blank" rel="noopener">http://t.cn/A6tYaES0</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Docker support in the kubelet is now deprecated and will be removed in a future release. The kubelet uses a module called “dockershim” which implements CRI support for Docker and it has seen maintenance issues in the Kubernetes community. We encourage you to evaluate moving to a container runtime that is a full-fledged implementation of CRI (v1alpha1 or v1 compliant) as they become available. (#94624, @dims) [SIG Node]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述引言来自 Kubernetes 1.120 的 Release Note，标志着 Docker 的丧钟进入尾声。事实上，当 2018 年 Docker 创始人 CTO Solomon Hykes 宣布离职时，Docker 和公司的命运已是江河日下。在复杂商业利益的驱使和一意孤行的错误决策下，从 2016 年至今诞生了 CRI、OCI 等标准和 Containerd、Runc、Docker-shim、CRI-O 等眼花缭乱却、功能盘龙交错重叠的项目，Kubelet 和容器运行时的调用链路复杂冗长且多次变化，整个生态为此苦不堪言。&lt;/p&gt;
&lt;p&gt;回想 1981 年 IBM 推出 PC 时，采用了非常开放的标准，凝聚了硬件和软件的生态，迅速占据市场第一把交椅。开放也导致了广大廉价而有竞争力的兼容机出现，渐渐蚕食 IBM 的市场份额。于是 1987 年 IBM 从开放走向封闭，推出一款不再兼容外部硬件的机器 IBM PS/2，彻底走上了一条不归路，失去市场的同时失去了 PC 产业话语权。让我们再次回顾 Docker 从一鸣惊人再到由盛而衰的历史，并思考开源商业、技术和文化和内在逻辑和一些教训。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Tmuxp 来优雅的管理多个 Tmux 会话</title>
    <link href="https://www.hi-linux.com/posts/253.html"/>
    <id>https://www.hi-linux.com/posts/253.html</id>
    <published>2021-05-06T01:00:00.000Z</published>
    <updated>2021-05-06T04:35:34.700Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>使用 <a href="https://github.com/tmux-python/tmuxp" target="_blank" rel="noopener">tmuxp</a> 可以很好的帮助我们来管理 tmux 的会话(session)，解决了平时在使用 tmux 工具时候的痛点。</strong></p></blockquote><h2><span id="1-工具介绍">1. 工具介绍</span></h2><blockquote><p><strong>安装和使用都非常简单</strong></p></blockquote><p>事实上，<code>tmuxp</code> 也是一个构建于 <code>tmux</code> 之上的对象关系映射的 <code>ORM</code> 的 <code>API</code> 工具，就是利用 <code>tmux</code> 工具定义的窗格(pane)、窗口(windows)和会话(session)，以创建关联视图的 <code>Server</code>, <code>Session</code>, <code>Window</code>, <code>Pane</code> 对象。我们在使用的时候，可以使用 <code>YAML</code>, <code>JSON</code> 以及 <code>dict</code> 字配置项来启动我们配置好的窗口和面板。使用时候需要注意的是，只支持 <code>tmux&gt;=1.8</code> 的版本。</p><ul><li>简洁的语法<ul><li>都支持在单独的命令中使用简短标记</li></ul></li><li>加载会话<ul><li>都是根据配置文件中加载 <code>tmux</code> 会话(<code>session</code>)</li></ul></li><li>多种格式支持<ul><li>可以使用 <code>YAML</code>, <code>JSON</code> 以及 <code>dict</code> 字配置项</li></ul></li></ul><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有这一种安装方式</span></span><br><span class="line">$ pip install tmuxp</span><br><span class="line">$ pip install --user tmuxp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置zsh补全(.zshrc)</span></span><br><span class="line">$ <span class="built_in">eval</span> <span class="string">"<span class="variable">$(_TMUXP_COMPLETE=source_zsh tmuxp)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置bash补全(.bashrc)</span></span><br><span class="line">$ <span class="built_in">eval</span> <span class="string">"<span class="variable">$(_TMUXP_COMPLETE=source tmuxp)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果运行命令提示报错则执行如下命令即可</span></span><br><span class="line">$ tmux <span class="built_in">kill</span>-server</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简洁的语法配置</span></span><br><span class="line"><span class="attr">session_name:</span> <span class="string">shorthands</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">long</span> <span class="string">form</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'did you know'</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'you can inline'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span> <span class="string">echo</span> <span class="string">'single commands'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'for panes'</span></span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/learn-tmuxp-tools-1-2021-01-27-aJHxhm.gif" alt></p><h2><span id="2-使用方式">2. 使用方式</span></h2><blockquote><p><strong>只需要记住 load 这个一个命令其实就够了</strong></p></blockquote><p><strong><code>tmuxp</code></strong> 工具将配置文件保存在 <code>~/.tmuxp</code> 中或在项目目录下作为 <code>~/.tmuxp.{yaml，json}</code> 独立出现。当然我们也可以使用其提供的命令，进行会话的相关操作和使用。下来就让我们一起去看看，如何使用吧！</p><ul><li>[1] 加载会话(Load session)<ul><li>Load a tmux workspace from each CONFIG.</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方式</span></span><br><span class="line"><span class="comment"># session_name: 会话(Session)名称</span></span><br><span class="line"><span class="comment"># -h: tmux服务器的地址</span></span><br><span class="line"><span class="comment"># -L: tmux服务器的socket名，与tmux相同</span></span><br><span class="line"><span class="comment"># -S: tmux服务器的socket路径，与tmux相同</span></span><br><span class="line"><span class="comment"># -2: 强迫tmux的终端支持256色</span></span><br><span class="line"><span class="comment"># -8: 与-2类似，但是只支持88色</span></span><br><span class="line"><span class="comment"># --list=False: 列出可用的配置文件</span></span><br><span class="line">$ tmuxp load [-h] [-L socket-name] [-S socket-path] [-2 | -8] [--list] [config]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过配置文件路径加载</span></span><br><span class="line">$ tmuxp load .</span><br><span class="line">$ tmuxp load ./mysession.yaml</span><br><span class="line">$ tmuxp load ~/workspaces/myproject.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过自定义会话名称加载</span></span><br><span class="line">$ tmuxp load mysession</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次加载多个会话</span></span><br><span class="line">$ tmuxp load mysession ./another/project/</span><br></pre></td></tr></table></figure><ul><li>[2] 冻结会话(Freeze sessions)<ul><li>Snapshot a session into a config.</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方式</span></span><br><span class="line"><span class="comment"># session_name: 会话(Session)名称</span></span><br><span class="line"><span class="comment"># -h: tmux服务器的地址</span></span><br><span class="line"><span class="comment"># -L: tmux服务器的socket名，与tmux相同</span></span><br><span class="line"><span class="comment"># -S: tmux服务器的socket路径，与tmux相同</span></span><br><span class="line">$ tmuxp freeze [-h] [-L socket-name] [-S socket-path] session_name [session_name ...]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为tmux布局、窗格路径和窗口/会话名称创建快照</span></span><br><span class="line">$ tmuxp freeze session-name</span><br></pre></td></tr></table></figure><ul><li>[3] 配置转换<ul><li>Convert a tmuxp config between JSON and YAML.</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方式</span></span><br><span class="line"><span class="comment"># config: 配置文件的绝对/相对路径</span></span><br><span class="line">tmuxp convert [-h] config</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以互相转换JSON/YAML格式</span></span><br><span class="line">$ tmuxp convert &lt;filename&gt;</span><br></pre></td></tr></table></figure><ul><li>[4] 配置导入<ul><li>Import a teamocil/tmuxinator config.</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方式</span></span><br><span class="line"><span class="comment"># config: 在 ~/.teamocil 和当前目录下查找yaml文件</span></span><br><span class="line"><span class="comment"># --list=False: 列出 ~/.teamocil 和当前工作目录下的配置文件</span></span><br><span class="line">$ tmuxp import teamocil [-h] (--list | config)</span><br><span class="line">$ tmuxp import tmuxinator [-h] (--list | config)</span><br></pre></td></tr></table></figure><h2><span id="3-面板窗口配置">3. 面板窗口配置</span></h2><blockquote><p><strong>主要介绍 tmux 面板的切分、启动目录、索引设定等操作</strong></p></blockquote><ul><li>[1] 两个窗格(2 split panes)<ul><li>分割出两个窗格</li></ul></li></ul><p><img src="https://img.hi-linux.com/staticfile/learn-tmuxp-tools-2-2021-01-27-c3IkeK.gif" alt></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="number">2</span><span class="string">-pane-vertical</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">my</span> <span class="string">test</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="number">2</span><span class="string">-pane-vertical-long</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cd</span> <span class="string">~</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pwd</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">top</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cd</span> <span class="string">/var/www</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pwd</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">second</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">shell_command_before:</span> <span class="string">cd</span> <span class="string">/var/www</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span> <span class="string">pwd</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pwd</span></span><br></pre></td></tr></table></figure><ul><li><strong>[2] 三个窗格(3 panes)</strong></li></ul><p><img src="https://img.hi-linux.com/staticfile/RA1Cc4-2021-01-27-a7MTrq.jpg" alt></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="number">3</span><span class="string">-panes</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">dev</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-vertical</span></span><br><span class="line">    <span class="attr">shell_command_before:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cd</span> <span class="string">~/</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cd</span> <span class="string">/var/log</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ls</span> <span class="string">-al</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">\.log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hellotmu</span></span><br></pre></td></tr></table></figure><ul><li><strong>[3] 四个窗格(4 panes)</strong></li></ul><p><img src="https://img.hi-linux.com/staticfile/learn-tmuxp-tools-4-2021-01-27-NB729J.gif" alt></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="number">4</span><span class="string">-pane-split</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">dev</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">tiled</span></span><br><span class="line">    <span class="attr">shell_command_before:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cd</span> <span class="string">~/</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cd</span> <span class="string">/var/log</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ls</span> <span class="string">-al</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">\.log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure><ul><li>[4] 空白窗格(Blank panes)<ul><li>直接可以使用 ‘null, ‘blank’, ‘pane’ 中任何一个，即可创建空白窗格</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">Blank</span> <span class="string">pane</span> <span class="string">test</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="comment"># 如果之前没有shell命令将打开一个空白窗格</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">Blank</span> <span class="string">pane</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blank</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">More</span> <span class="string">blank</span> <span class="string">panes</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="literal">null</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span></span><br><span class="line">  <span class="comment"># 空字符串将被视为回车</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">Empty</span> <span class="string">string</span> <span class="string">(return)</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span> <span class="string">""</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">  <span class="comment"># 窗格可以有其他选项但仍然是空的</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">Blank</span> <span class="string">with</span> <span class="string">options</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">start_directory:</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure><ul><li>[5] 启动目录(Start Directory)<ul><li>设置起始目录</li><li>等价于<code>tmux new-window -c &lt;start-directory&gt;</code>命令</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">start</span> <span class="string">directory</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">/var/</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">should</span> <span class="string">be</span> <span class="string">/var/</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"\033c</span></span><br><span class="line"><span class="string">          - it trickles down from session-level"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">should</span> <span class="string">be</span> <span class="string">/var/log</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'\033c</span></span><br><span class="line"><span class="string">          - window start_directory concatenates to session start_directory</span></span><br><span class="line"><span class="string">          - if it is not absolute'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">should</span> <span class="string">be</span> <span class="string">~</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">'echo \\033c ~ has precedence. note: remember to quote ~ in YAML'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">should</span> <span class="string">be</span> <span class="string">/bin</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/bin</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'\033c absolute paths also have precedence.'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">should</span> <span class="string">be</span> <span class="string">config's</span> <span class="string">dir</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'\033c</span></span><br><span class="line"><span class="string">          - ./ is relative to config file location</span></span><br><span class="line"><span class="string">          - ../ will be parent of config file</span></span><br><span class="line"><span class="string">          - ./test will be \"test\" dir inside dir of config file'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'\033c</span></span><br><span class="line"><span class="string">          - This way you can load up workspaces from projects and maintain</span></span><br><span class="line"><span class="string">          - relative paths.'</span></span><br></pre></td></tr></table></figure><ul><li>[6] 窗口索引<ul><li>定义窗口索引，就是我们在使用时候用来切换窗口时使用</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">Window</span> <span class="string">index</span> <span class="string">example</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">zero</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"this window's index will be zero"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">five</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"this window's index will be five"</span></span><br><span class="line">    <span class="attr">window_index:</span> <span class="number">5</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">one</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"this window's index will be one"</span></span><br></pre></td></tr></table></figure><h2><span id="4-面板窗口设置">4. 面板窗口设置</span></h2><blockquote><p><strong>工具系统方法的一些配置</strong></p></blockquote><ul><li>[1] 环境变量<ul><li>在<code>tmuxp</code>中设置会话环境变量</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">Environment</span> <span class="string">variables</span> <span class="string">test</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">EDITOR:</span> <span class="string">/usr/bin/vim</span></span><br><span class="line">  <span class="attr">HOME:</span> <span class="string">/tmp/hm</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="comment"># 如果之前没有shell命令将打开一个空白窗格。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">Blank</span> <span class="string">pane</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span></span><br></pre></td></tr></table></figure><ul><li>[2] 定制主面板高度(Main pane height)<ul><li>根据实际使用情况，设置主面板的高度</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">main-pane-height</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">top</span></span><br><span class="line">        <span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"hey"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"moo"</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">my</span> <span class="string">window</span> <span class="string">name</span></span><br></pre></td></tr></table></figure><ul><li>[3] 终端历史<ul><li>用于配置是否需要记录终端命令历史</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">suppress</span></span><br><span class="line"><span class="attr">suppress_history:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">appended</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">suppress_history:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"window in the history!"</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">suppressed</span></span><br><span class="line">    <span class="attr">suppress_history:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"window not in the history!"</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"session in the history!"</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">mixed</span></span><br><span class="line">    <span class="attr">suppress_history:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"command in the history!"</span></span><br><span class="line">        <span class="attr">suppress_history:</span> <span class="literal">false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"command not in the history!"</span></span><br><span class="line">        <span class="attr">suppress_history:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"window in the history!"</span></span><br></pre></td></tr></table></figure><ul><li>[4] 窗口选项<ul><li>创建窗格后设置窗口选项</li><li>在创建过程中在每个窗格中执行单个命令后，对于“同步窗格”选项很有用</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="number">2</span><span class="string">-pane-synchronized</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">Two</span> <span class="string">synchronized</span> <span class="string">panes</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ssh</span> <span class="string">server1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ssh</span> <span class="string">server2</span></span><br><span class="line">    <span class="attr">options_after:</span></span><br><span class="line">      <span class="attr">synchronize-panes:</span> <span class="string">on</span></span><br></pre></td></tr></table></figure><ul><li>[5] 设置选项<ul><li>设置<code>tmux</code>工具相关的选项，例如全局(服务器范围)选项、会话选项和窗口选项</li><li>包括<code>automatic-rename</code>,<code>default-shell</code>,<code>default-command</code>等相关命令</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">test</span> <span class="string">window</span> <span class="string">options</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line"><span class="attr">global_options:</span></span><br><span class="line">  <span class="attr">default-shell:</span> <span class="string">/bin/sh</span></span><br><span class="line">  <span class="attr">default-command:</span> <span class="string">/bin/sh</span></span><br><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">main-pane-height:</span> <span class="string">$&#123;MAIN_PANE_HEIGHT&#125;</span> <span class="comment"># works with env variables</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">on</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">man</span> <span class="string">echo</span></span><br><span class="line">        <span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"hey"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"moo"</span></span><br></pre></td></tr></table></figure><ul><li>[6] 自动重命名(Automatic Rename)<ul><li>即可以自动命令创建的面板名称</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">test</span> <span class="string">window</span> <span class="string">options</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">on</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">man</span> <span class="string">echo</span></span><br><span class="line">        <span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"hey"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"moo"</span></span><br></pre></td></tr></table></figure><ul><li>[7] 专注模式<ul><li>在专注模式中，可以确保在加载时附加和选择窗口和窗格</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">focus</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">attached</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'this pane should be selected on load'</span></span><br><span class="line">        <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cd</span> <span class="string">/var/log</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">second</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">shell_command_before:</span> <span class="string">cd</span> <span class="string">/var/log</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'this pane should be focused, when window switched to first time'</span></span><br><span class="line">        <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br></pre></td></tr></table></figure><h2><span id="5-测试开发配置">5. 测试开发配置</span></h2><blockquote><p><strong>主要介绍在我们实际开发和测试当中应该如何使用该工具</strong></p></blockquote><ul><li>[1] 定制高级开发环境<ul><li>作为开发环境时候的相关配置</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">tmuxp</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span> <span class="comment"># 加载相对于配置位置(项目根目录)的会话</span></span><br><span class="line"><span class="attr">before_script:</span> <span class="string">pipenv</span> <span class="string">install</span> <span class="string">--dev</span> <span class="string">--skip-lock</span></span><br><span class="line"><span class="attr">shell_command_before:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"[ -d `pipenv --venv` ] &amp;&amp; source `pipenv --venv`/bin/activate &amp;&amp; reset"</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">tmuxp</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">True</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">watch_test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">docs</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">doc/</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">serve</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">watch</span></span><br></pre></td></tr></table></figure><ul><li>[2] 自动引导<ul><li>新版本<code>1.3.4</code>:在脚本 CWD 进入根(会话)级启动目录之前</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设您的.tmuxp.yaml位于项目的根目录中</span></span><br><span class="line"><span class="comment"># 如果使用pipenv的话，则可以使用如下脚本来确保已安装软件包</span></span><br><span class="line"><span class="attr">session_name:</span> <span class="string">my</span> <span class="string">pipenv</span> <span class="string">project</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">before_script:</span> <span class="string">pipenv</span> <span class="string">install</span> <span class="string">--dev</span> <span class="string">--skip-lock</span> <span class="comment"># 开发环境</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">django</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blank</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pipenv</span> <span class="string">run</span> <span class="string">./manage.py</span> <span class="string">runserver</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设您的.tmuxp.yaml位于项目的根目录中</span></span><br><span class="line"><span class="comment"># 可以使用shell_command_before将自己置身于虚拟环境中</span></span><br><span class="line"><span class="attr">session_name:</span> <span class="string">my</span> <span class="string">pipenv</span> <span class="string">project</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">before_script:</span> <span class="string">pipenv</span> <span class="string">install</span> <span class="string">--dev</span> <span class="string">--skip-lock</span> <span class="comment"># 开发环境</span></span><br><span class="line"><span class="attr">shell_command_before:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"[ -d `pipenv --venv` ] &amp;&amp; source `pipenv --venv`/bin/activate &amp;&amp; reset"</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">django</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blank</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./manage.py</span> <span class="string">runserver</span></span><br></pre></td></tr></table></figure><h2><span id="6-配置示例文件">6. 配置示例文件</span></h2><blockquote><p><strong>这里就是其他人使用该工具的配置文件，可以借鉴和引用</strong></p></blockquote><ul><li><strong>laixintao</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">workspace</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="number">66e3</span><span class="string">,238x57,0,0,14</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/Users/laixintao/Program</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">vim</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="string">a5de,238x57,0,0&#123;119x57,0,0,15,118x57,120,0[118x28,120,0,19,118x28,120,29,20]&#125;</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="attr">shell_command:</span> <span class="string">zsh</span></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/Users/laixintao</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">operation</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="number">66e5</span><span class="string">,238x57,0,0,16</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="attr">shell_command:</span> <span class="string">zsh</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/Users/laixintao</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">shell</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="number">66e6</span><span class="string">,238x57,0,0,17</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="attr">shell_command:</span> <span class="string">zsh</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/Users/laixintao</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">shell</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="number">66e7</span><span class="string">,238x57,0,0,18</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="attr">shell_command:</span> <span class="string">zsh</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/Users/laixintao</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">shell</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="string">main-vertical</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="attr">shell_command:</span> <span class="string">clash</span> <span class="string">&gt;</span> <span class="string">/tmp/clash.log</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">&lt;clash&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>vcspull</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">vcspull</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">before_script:</span> <span class="string">pipenv</span> <span class="string">install</span> <span class="string">--dev</span> <span class="string">--skip-lock</span></span><br><span class="line"><span class="attr">shell_command_before:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"[ -d `pipenv --venv` ] &amp;&amp; source `pipenv --venv`/bin/activate &amp;&amp; reset"</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">vcspull</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">True</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">watch_test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">docs</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">doc/</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">serve</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">watch</span></span><br></pre></td></tr></table></figure><ul><li><strong>dockerfiles</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">dockerfiles</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">6da5,239x56,0,0[239x34,0,0,65,239x21,0,35&#123;119x21,0,35,66,119x21,120,35,67&#125;]</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">vim</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">:e</span> <span class="string">README.rst</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">docs</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">    <span class="attr">shell_command_before:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">virtualenv</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">virtualenv;</span> <span class="string">&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"[ -d .env -a -f .env/bin/activate ] &amp;&amp; source .env/bin/activate || virtualenv .env"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"[ ! -d .env/build ] || rm -rf .env/build"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./doc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">.env/bin/tmuxp</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">requirements.pip;</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">reset</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">vim</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">:Ex</span></span><br><span class="line">        <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pwd</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'docs built to &lt;http://0.0.0.0:8007/_build/html&gt;'</span><span class="string">;</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">SimpleHTTPServer</span> <span class="number">8007</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">watching_testrunner</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">watching_testrunner;</span> <span class="string">&#125;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">watching_testrunner</span> <span class="string">--basepath</span> <span class="string">./</span> <span class="string">--pattern="*.rst"</span> <span class="string">'make html'</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">postgresql</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">6da5,239x56,0,0[239x34,0,0,65,239x21,0,35&#123;119x21,0,35,66,119x21,120,35,67&#125;]</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">postgresql</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">vim</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">:e</span> <span class="string">Dockerfile</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br></pre></td></tr></table></figure><ul><li><strong>sphinxcontrib</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">sphinxcontrib-github</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">options:</span></span><br><span class="line">    <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">  <span class="attr">panes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">vim</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">  <span class="attr">window_name:</span> <span class="string">sphinxcontrib-github</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">docs</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">  <span class="attr">shell_command_before:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">virtualenv</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">virtualenv;</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'[ -d .env -a -f .env/bin/activate ] &amp;&amp; source .env/bin/activate || virtualenv .env'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'[ ! -d .env/build ] || rm -rf .env/build'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">.env/bin/tmuxp</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-e</span> <span class="string">.;</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./doc</span></span><br><span class="line">  <span class="attr">panes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">reset</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">vim</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">:Ex</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'docs built to &lt;http://0.0.0.0:8005/_build/html&gt;'</span><span class="string">;</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">SimpleHTTPServer</span> <span class="number">8005</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">sphinx-quickstart</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">requirements.pip;</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">watching_testrunner</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">watching_testrunner;</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">watching_testrunner</span> <span class="string">--basepath</span> <span class="string">./</span> <span class="string">--pattern="*.rst"</span> <span class="string">'make html'</span></span><br><span class="line"><span class="string">Terms</span></span><br></pre></td></tr></table></figure><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/y5zsckzv%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://tinyurl.com/y5zsckzv，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用 &lt;a href=&quot;https://github.com/tmux-python/tmuxp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tmuxp&lt;/a&gt; 可以很好的帮助我们来管理 tmux 的会话(session)，解决了平时在使用 tmux 工具时候的痛点。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-工具介绍&quot;&gt;1. 工具介绍&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;安装和使用都非常简单&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事实上，&lt;code&gt;tmuxp&lt;/code&gt; 也是一个构建于 &lt;code&gt;tmux&lt;/code&gt; 之上的对象关系映射的 &lt;code&gt;ORM&lt;/code&gt; 的 &lt;code&gt;API&lt;/code&gt; 工具，就是利用 &lt;code&gt;tmux&lt;/code&gt; 工具定义的窗格(pane)、窗口(windows)和会话(session)，以创建关联视图的 &lt;code&gt;Server&lt;/code&gt;, &lt;code&gt;Session&lt;/code&gt;, &lt;code&gt;Window&lt;/code&gt;, &lt;code&gt;Pane&lt;/code&gt; 对象。我们在使用的时候，可以使用 &lt;code&gt;YAML&lt;/code&gt;, &lt;code&gt;JSON&lt;/code&gt; 以及 &lt;code&gt;dict&lt;/code&gt; 字配置项来启动我们配置好的窗口和面板。使用时候需要注意的是，只支持 &lt;code&gt;tmux&amp;gt;=1.8&lt;/code&gt; 的版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁的语法
&lt;ul&gt;
&lt;li&gt;都支持在单独的命令中使用简短标记&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加载会话
&lt;ul&gt;
&lt;li&gt;都是根据配置文件中加载 &lt;code&gt;tmux&lt;/code&gt; 会话(&lt;code&gt;session&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多种格式支持
&lt;ul&gt;
&lt;li&gt;可以使用 &lt;code&gt;YAML&lt;/code&gt;, &lt;code&gt;JSON&lt;/code&gt; 以及 &lt;code&gt;dict&lt;/code&gt; 字配置项&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Tmux" scheme="https://www.hi-linux.com/categories/Tmux/"/>
    
    
      <category term="Tmux" scheme="https://www.hi-linux.com/tags/Tmux/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Tmuxp" scheme="https://www.hi-linux.com/tags/Tmuxp/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 之父创造的 Rocky Linux 8.3 发布了！(内附镜像下载地址）</title>
    <link href="https://www.hi-linux.com/posts/16230.html"/>
    <id>https://www.hi-linux.com/posts/16230.html</id>
    <published>2021-05-02T01:00:00.000Z</published>
    <updated>2021-05-03T15:16:25.163Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>去年 12 月份，<code>CentOS</code> 官网正式宣布，将停止维护 <code>CentOS Linux</code>，并将更多资金和人力投入到 <code>CentOS Stream</code> 中。而 <code>Rocky Linux</code> 是红帽宣布放弃 <code>CentOS Linux</code> 后，由 <code>CentOS</code> 联合创始人 <code>Gregory Kurtzer</code> 创建的 <code>CentOS</code> 发行版，旨在继承 <code>CentOS</code> 的社区属性。</p><p><img src="https://img.hi-linux.com/staticfile/sPPw5k-2021-05-03-lHmSRy.jpg" alt></p><p>自去年年底创立该项目以来，<code>Rocky</code> 企业软件基金会一直致力于在今年 3 月和 5 月之间推出一个版本。现在随着五月的到来，Rocky Linux 8.3 的首个候选发行版发布，下载镜像已放出。</p><blockquote><p>Gregory Kurtzer 述：今年最受期待的开源项目发布就在这里！这是 Rocky Linux 8.3 的第一个候选发行版的首次发布！Rocky 是社区企业操作系统，现在 CentOS 已成为 RHEL 的协作开发测试基地。特别感谢所有实现此版本的朋友。言出必行，Rocky Linux 已经准备就绪！</p></blockquote><p>关于 <code>Rocky Linux 8.3 RC1</code> 首发版本的下载和更多细节可以通过 <a href="http://RockyLinux.org" target="_blank" rel="noopener">RockyLinux.org</a> 找到：</p><blockquote><p>链接：<a href="https://forums.rockylinux.org/t/rocky-linux-8-3-rc1-available-now/2393" target="_blank" rel="noopener">https://forums.rockylinux.org/t/rocky-linux-8-3-rc1-available-now/2393</a></p></blockquote><a id="more"></a><p><img src="https://img.hi-linux.com/staticfile/7kEryp-2021-05-03-ViaDUt.jpg" alt></p><p><strong>Rocky Linux 8.3 官方下载地址：</strong></p><ul><li><a href="https://rockylinux.org/download/" target="_blank" rel="noopener">https://rockylinux.org/download/</a></li></ul><p>为方便国内 Rocky Linux 爱好者下载试用，Rocky Linux 中文社区已经提供了多种下载方式，包括：<code>迅雷VIP</code>、<code>BT下载</code>、<code>百度网盘</code>、<code>天翼云盘</code>等（在此感谢社区爱好者），欢迎大家下载试用。</p><p><strong>Rocky Linux 中文社区下载链接：</strong></p><ul><li><a href="https://rockylinux.cn/rocky-linux-mirror-download.html" target="_blank" rel="noopener">https://rockylinux.cn/rocky-linux-mirror-download.html</a></li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年 12 月份，&lt;code&gt;CentOS&lt;/code&gt; 官网正式宣布，将停止维护 &lt;code&gt;CentOS Linux&lt;/code&gt;，并将更多资金和人力投入到 &lt;code&gt;CentOS Stream&lt;/code&gt; 中。而 &lt;code&gt;Rocky Linux&lt;/code&gt; 是红帽宣布放弃 &lt;code&gt;CentOS Linux&lt;/code&gt; 后，由 &lt;code&gt;CentOS&lt;/code&gt; 联合创始人 &lt;code&gt;Gregory Kurtzer&lt;/code&gt; 创建的 &lt;code&gt;CentOS&lt;/code&gt; 发行版，旨在继承 &lt;code&gt;CentOS&lt;/code&gt; 的社区属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/sPPw5k-2021-05-03-lHmSRy.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;自去年年底创立该项目以来，&lt;code&gt;Rocky&lt;/code&gt; 企业软件基金会一直致力于在今年 3 月和 5 月之间推出一个版本。现在随着五月的到来，Rocky Linux 8.3 的首个候选发行版发布，下载镜像已放出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gregory Kurtzer 述：今年最受期待的开源项目发布就在这里！这是 Rocky Linux 8.3 的第一个候选发行版的首次发布！Rocky 是社区企业操作系统，现在 CentOS 已成为 RHEL 的协作开发测试基地。特别感谢所有实现此版本的朋友。言出必行，Rocky Linux 已经准备就绪！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于 &lt;code&gt;Rocky Linux 8.3 RC1&lt;/code&gt; 首发版本的下载和更多细节可以通过 &lt;a href=&quot;http://RockyLinux.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RockyLinux.org&lt;/a&gt; 找到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://forums.rockylinux.org/t/rocky-linux-8-3-rc1-available-now/2393&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://forums.rockylinux.org/t/rocky-linux-8-3-rc1-available-now/2393&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="教程" scheme="https://www.hi-linux.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
