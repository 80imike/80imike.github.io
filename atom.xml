<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>运维之美</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2020-05-24T08:33:04.677Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手把手教你用 Tiny Tiny RSS 部署一个私有 RSS 服务器</title>
    <link href="https://www.hi-linux.com/posts/47278.html"/>
    <id>https://www.hi-linux.com/posts/47278.html</id>
    <published>2020-05-24T01:14:00.000Z</published>
    <updated>2020-05-24T08:33:04.677Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>9012 年了，别的小朋友们服务器上面跑着各式各样的东西：博客、云盘、监控脚本……再看看我们那台闲（bai）置（piao）很久的阿里云 Server，里面的 Git 竟然还是 1.8 的上古版本。🤦‍♂️ 不如把那台服务器拿出来，部署一个属于自己的 RSS 服务器，甚至可以跟同学们一起用呢～</p><h2 id="rss">RSS</h2><p>首先我们来说一说 RSS。RSS 的全称是 Really Simple Syndication（简易信息聚合），它是一种消息来源的格式规范，网站可以按照这种格式规范提供文章的标题、摘要、全文等信息给订阅用户，用户可以通过订阅不同网站 RSS 链接的方式将不同的信息源进行聚合，在一个工具里阅读这些内容。</p><p>对于第一次接触 RSS 的同学，推荐大家阅读：<a href="https://sspai.com/post/56391" target="_blank" rel="noopener">高效获取信息，你需要这份 RSS 入门指南</a>，进行扫盲。</p><p>市面上有非常多的 RSS 聚合服务，来帮助我们统一管理、订阅、更新、筛选 RSS 源推送给我们的更新信息，避免我们被海量的文章淹没，也能保证我们多个设备上 RSS 的阅读进度一致。Feedly、Inoreader 等等都是非常不错的 RSS 服务，但是它们的免费版本都有着一定的限制，有时候无法满足我们的全部功能需求，而动辄一个月数十刀的订阅费用又让人望而却步。不慌，开源的 RSS 服务：Tiny Tiny RSS 可以满足我们 RSS 订阅的全部需求！</p><h2 id="tiny-tiny-rss-的搭建">Tiny Tiny RSS 的搭建</h2><p><img src="https://i.loli.net/2019/11/19/aCty2KspU5f1gHr.jpg" alt="使用 Feedly 主题的 Tiny Tiny RSS 服务端"></p><p>Tiny Tiny RSS 是一个非常优秀的开源免费 RSS 服务引擎，可以直接部署在我们自己的服务器上面，借助于 Docker 优秀方便的容器技术和 Let’s Encrypt 异常简单的 SSL 证书签署机器人 <code>certbot</code>，我们几分钟之内就可以部署上线属于我们自己的 RSS 服务，运行在我们可控的服务器上，环境稳定，刷新及时，并且完全免费。👍（当然，除了服务器需要一定的费用。）</p><p>在容器、HTTPS 证书自动签署和虚拟化技术极度发达的今天，整个部署过程非常方便简单。我接下来只利用 iPad 进行讲解演示我们的部署过程。请大家坐好，我们立刻开始。</p><a id="more"></a><h2 id="准备工作">准备工作</h2><p>在开始之前，首先我们需要准备一个位于公网的服务器，以及一个可以通过 SSH 连接到服务器上的本地设备。这里我使用我同（bai）学（piao）的已经备案的阿里云服务器作为运行 Tiny Tiny RSS 的服务器，并使用 iPad 和 Blink Shell（一个支持 SSH 协议的 iOS 终端 App）作为我的操作设备。Blink Shell 是 iPad 上面最好用的 SSH/Mosh 工具，推荐大家使用。我们在 Blink Shell 中配置好服务器私钥，通过 SSH 登录服务器。</p><p><img src="https://i.loli.net/2019/11/19/iyk8KrUBYzodPqS.jpg" alt="利用 Blink Shell 登录至服务器"></p><h2 id="利用-docker-部署-tiny-tiny-rss">利用 Docker 部署 Tiny Tiny RSS</h2><h3 id="安装-docker">安装 Docker</h3><p>Docker 是非常优秀的虚拟化容器，借助于 Docker 我们可以方便的部署 Tiny Tiny RSS，首先我们在服务器上安装 Docker 本体。在服务器上面执行下面命令来安装 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>然后启动 Docker 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>然后，我们检查一下 Docker 是否启动成功。我们执行命令：<code>sudo systemctl status docker</code>：</p><p><img src="https://i.loli.net/2019/11/20/L6VicoJy8OCBpxq.jpg" alt="检查 Docker 服务状态"></p><p>看到如上的输出，说明我们 Docker 服务启动成功。</p><p><em>参考资料：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">Get Docker Engine - Community for CentOS | Docker Documentation</a></em></p><h3 id="安装-docker-compose">安装 docker-compose</h3><p>接下来我们安装 <code>docker-compose</code>：一个管理和启动多个 Docker 容器的工具。由于 Tiny Tiny RSS 依赖有 PostgreSQL 的数据库服务以及 <a href="https://github.com/HenryQW/mercury_fulltext" target="_blank" rel="noopener">mercury_fulltext</a> 的全文抓取服务等等，这些服务我们都借助于 Docker 部署，因此利用 <code>docker-compose</code> 就会大大降低我们的部署难度。</p><p>我们继续，在服务器上面执行下面的命令来安装 <code>docker-compose</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p>之后给予安装好的 <code>docker-compose</code> 可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p><em>参考资料：<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">Install Docker Compose | Docker Documentation</a></em></p><p>最后我们运行 <code>docker-compose --version</code> 来检查安装是否成功。如果有如下输出，说明我们的 <code>docker-compose</code> 安装成功：</p><p><img src="https://i.loli.net/2019/11/20/6j3QgG1FszTPp5Y.jpg" alt="检查 docker-compose 安装情况"></p><h3 id="安装-tiny-tiny-rss-及其周边服务">安装 Tiny Tiny RSS 及其周边服务</h3><p>准备工作已经全部完成，接下来我们下载由 Awesome-TTRSS 配置的 Tiny Tiny RSS 服务的 docker-compose 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 ttrss 目录并进入</span></span><br><span class="line">mkdir ttrss &amp;&amp; <span class="built_in">cd</span> ttrss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 curl 下载 ttrss 的 docker-compose 配置文件至服务器</span></span><br><span class="line">curl -fLo docker-compose.yml https://github.com/HenryQW/Awesome-TTRSS/raw/master/docker-compose.yml</span><br></pre></td></tr></table></figure><p>修改 docker-compose.yml 里面的内容：</p><p><img src="https://i.loli.net/2019/11/20/sn4MP8uvb3WIzDt.png" alt="修改 docker-compose 配置文件"></p><ul><li>在配置文件的第 7 行和第 23 行，将 PostgreSQL 数据库的默认密码进行修改。暴露在公网的数据库使用默认密码非常危险。</li><li>在配置文件的第 18 行，将 Tiny Tiny RSS 服务的部署网址修改。比如我的部署网址是 <code>https://ttrss.tenkeyseven.com/</code><ul><li>注意，如果你的部署 URL 包含端口（比如默认部署端口为 181 端口），那么这里的 URL 也需要加上端口号，格式为 <code>{网址}:{端口}</code></li><li>不过不必担心，如果你这里的 URL 配置不正确，那么访问 Tiny Tiny RSS 的时候，Tiny Tiny RSS 会提醒你修改这里的值为正确的 URL，按照提醒进行配置即可</li></ul></li></ul><p>之后，我们保存配置文件，启动 Tiny Tiny RSS 服务。在刚刚的 <code>ttrss</code> 目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>等待脚本执行完成，如果一切没有问题，那么接下来输入 <code>docker ps</code>，我们应该看到类似下面的结果：</p><p><img src="https://i.loli.net/2019/11/20/AxTdoa7YJCgI5i4.jpg" alt="查看正在运行的 Docker 容器"></p><p>上面内容表示我们开启了四个 Docker 容器，分别是：</p><ul><li>Tiny Tiny RSS 本身，监听端口为 <code>0.0.0.0:181 -&gt; 80</code>，同时暴露给外网</li><li>PostgreSQL 数据库，仅供内部使用</li><li>Mercury 全文抓取服务，仅供内部使用</li><li>OpenCC 简体、繁体中文转换服务，仅供内部使用</li></ul><p>如果发现问题，修改 docker-compose 配置文件后，需要执行下面的命令重启 Docker 容器们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭 Docker 容器们</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除已停止的 Docker 容器</span></span><br><span class="line">docker-compose rm</span><br><span class="line"></span><br><span class="line"><span class="comment"># ……</span></span><br><span class="line"><span class="comment"># 修改 docker-compose 配置文件</span></span><br><span class="line"><span class="comment"># ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次开启 Docker 服务</span></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="安装-nginx-作为-docker-容器的反向代理">安装 Nginx 作为 Docker 容器的反向代理</h2><p>事实上，到上一步，如果我们访问 <code>{服务器 IP}:181</code>，应该可以直接看到 Tiny Tiny RSS 的 Web 前端，但是 Tiny Tiny RSS 并不能直接配置 SSL 证书，也就没法添加 HTTPS 支持。我们利用 Nginx 作为反向代理服务器，即可方便的给 Tiny Tiny RSS 单独绑定一个我们希望的域名，并利用 Let’s Encrypt 来部署 HTTPS。</p><h3 id="安装-nginx">安装 Nginx</h3><p>首先我们来安装 Nginx，以 CentOS 为例，我们直接执行下面命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nginx</span><br></pre></td></tr></table></figure><p>之后开启 Nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx</span><br></pre></td></tr></table></figure><p>检查 Nginx 是否启动成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/20/gakiyznx5NhXT16.jpg" alt="检查 Nginx 运行状态"></p><h3 id="签署-ssl-证书部署-https">签署 SSL 证书，部署 HTTPS</h3><p>之后，我们利用 Let’s Encrypt 提供的 <code>certbot</code> 直接为 Nginx 配置 SSL 证书。首先，我们执行下面的命令安装 <code>certbot</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install certbot python2-certbot-nginx</span><br></pre></td></tr></table></figure><p>然后运行 <code>certbot</code> 来签署 SSL 证书并自动配置 Nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot --nginx</span><br></pre></td></tr></table></figure><p><em>参考资料：<a href="https://certbot.eff.org/lets-encrypt/centosrhel7-nginx" target="_blank" rel="noopener">Certbot | Nginx on CentOS/RHEL 7</a></em></p><p>在这里，certbot 会要求我们输入我们希望签署 SSL 证书的域名，我们选择为 Tiny Tiny RSS 分配的域名（比如我的就是 <code>ttrss.tenkeyseven.com</code>）即可。另外，如果 certbot 询问是否需要将访问该网址的全部流量重定向至 HTTPS，那么选择「是」即可。我们等待脚本执行签署任务完毕，然后重启 Nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><p>此时我们如果直接访问这一域名，应该就可以看到带有 HTTPS 的 Nginx 默认网站：</p><p><img src="https://i.loli.net/2019/11/20/jWwRplvBD8oOczJ.jpg" alt="HTTPS 配置成功的 Nginx 默认网站"></p><p>接下来，我们修改 Nginx 的配置文件，配置 Nginx 反向代理，将访问 <code>https://ttrss.tenkeyseven.com</code> 的请求指向我们刚刚部署好的 Tiny Tiny RSS 服务，对服务器来说，也就是 <code>127.0.0.1:181</code> 这一地址。（如果你没有更改 Tiny Tiny RSS 的端口号的话。）</p><p>Nginx 的配置文件位于 <code>/etc/nginx/nginx.conf</code>，我们打开这一文件：</p><p><img src="https://i.loli.net/2019/11/20/J9yaSejPN1iLnkO.png" alt="Nginx 配置文件"></p><ul><li><p>在 <code>http</code> 项下，<code>server</code> 项前定义 <code>upstream</code> 服务：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream ttrssdev &#123;</span><br><span class="line">server 127.0.0.1:181;</span><br><span class="line">keepalive 64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/20/XLAlTsegadr5cPE.jpg" alt="Nginx upstream 服务声明"></p></li><li><p>在刚刚 <code>certbot</code> 为我们生成好的响应域名 <code>server</code> 项下，注释掉第一行定义 <code>root</code> 的内容，并将 <code>location /</code> 项修改为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_redirect off;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;ttrssdev;</span><br><span class="line"></span><br><span class="line">proxy_set_header  Host                $http_host;</span><br><span class="line">proxy_set_header  X-Real-IP           $remote_addr;</span><br><span class="line">proxy_set_header  X-Forwarded-Ssl     on;</span><br><span class="line">proxy_set_header  X-Forwarded-For     $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_set_header  X-Forwarded-Proto   $scheme;</span><br><span class="line">proxy_set_header  X-Frame-Options     SAMEORIGIN;</span><br><span class="line"></span><br><span class="line">client_max_body_size        100m;</span><br><span class="line">client_body_buffer_size     128k;</span><br><span class="line"></span><br><span class="line">proxy_buffer_size           4k;</span><br><span class="line">proxy_buffers               4 32k;</span><br><span class="line">proxy_busy_buffers_size     64k;</span><br><span class="line">proxy_temp_file_write_size  64k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/20/LVXAFOfywRB2inr.jpg" alt="Nginx 配置文件：反向代理配置"></p></li></ul><p>这样，我们再次执行 <code>sudo systemctl restart nginx</code> 重启 Nginx 服务，一切顺利的话，我们就可以通过我们刚刚签署 SSL 证书的域名访问我们部署好的 Tiny Tiny RSS 服务了！鼓掌 👏</p><p>Tiny Tiny RSS 的默认管理员账户密码是 admin 和 password，请在第一时间进行修改。</p><h2 id="配置-tiny-tiny-rss">配置 Tiny Tiny RSS</h2><p><img src="https://i.loli.net/2019/11/20/cis6yUboY2KStEn.jpg" alt="Tiny Tiny RSS 配置、主题"></p><p>如果上面步骤没有问题的话，我们在服务器上面所部署的 Tiny Tiny RSS 本身就已经包含了：</p><ul><li>Mercury 全文提取服务（默认未开启）</li><li>OpenCC 繁简自动转换服务（默认未开启）</li><li>Fever 格式输出插件（默认已开启，用来和 Reeder 等客户端进行连接）</li><li>包括 Feedly、RSSHub 在内的多款主题</li><li>等等……</li></ul><p>我们不需要多余的配置，开箱即可使用上面的主题和插件，根本不需要操心其他服务的部署和安装。我们登录自己的 Tiny Tiny RSS，在右上角「设置→ 插件」中即可启用上述插件，在「设置 → 主题」处就可以更改我们部署的 Tiny Tiny RSS 所用的主题。这些插件和主题在 <a href="https://sspai.com/post/41302" target="_blank" rel="noopener">如何搭建属于自己的 RSS 服务，高效精准获取信息</a> 中已经介绍了使用方法，这里我就不再赘述了。</p><p>如果有同学对上面的配置还有问题，请直接参考 <a href="https://ttrss.henry.wang/zh/#%E6%8F%92%E4%BB%B6" target="_blank" rel="noopener">Awesome TTRSS 的官方文档：🐋 Awesome TTRSS | 插件</a></p><h2 id="小结">小结</h2><p>Tiny Tiny RSS 的配置到这里就基本结束了，我相信你通过上面的配置一定已经在自己的服务器上部署成功了 Tiny Tiny RSS 服务，并为它添加了域名和 HTTPS 的支持。另外，Tiny Tiny RSS 还自带了账号系统，可以邀请其他志同道合的朋友们一起使用我们自己部署的 Tiny Tiny RSS。感谢阅读。</p><p>📖 关联阅读：</p><ul><li><a href="https://ttrss.henry.wang/zh/#%E5%85%B3%E4%BA%8E" target="_blank" rel="noopener">🐋 Awesome TTRSS</a></li><li><a href="https://sspai.com/post/56893" target="_blank" rel="noopener">Docker 的入门「指北」</a></li><li><a href="https://sspai.com/post/41302" target="_blank" rel="noopener">如何搭建属于自己的 RSS 服务，高效精准获取信息</a></li></ul><blockquote><p>本文转载自：「Spencer’s Blog」，原文：<a href="https://url.cn/5oFe33h%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5oFe33h，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;9012 年了，别的小朋友们服务器上面跑着各式各样的东西：博客、云盘、监控脚本……再看看我们那台闲（bai）置（piao）很久的阿里云 Server，里面的 Git 竟然还是 1.8 的上古版本。🤦‍♂️ 不如把那台服务器拿出来，部署一个属于自己的 RSS 服务器，甚至可以跟同学们一起用呢～&lt;/p&gt;
&lt;h2 id=&quot;RSS&quot;&gt;RSS&lt;/h2&gt;
&lt;p&gt;首先我们来说一说 RSS。RSS 的全称是 Really Simple Syndication（简易信息聚合），它是一种消息来源的格式规范，网站可以按照这种格式规范提供文章的标题、摘要、全文等信息给订阅用户，用户可以通过订阅不同网站 RSS 链接的方式将不同的信息源进行聚合，在一个工具里阅读这些内容。&lt;/p&gt;
&lt;p&gt;对于第一次接触 RSS 的同学，推荐大家阅读：&lt;a href=&quot;https://sspai.com/post/56391&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;高效获取信息，你需要这份 RSS 入门指南&lt;/a&gt;，进行扫盲。&lt;/p&gt;
&lt;p&gt;市面上有非常多的 RSS 聚合服务，来帮助我们统一管理、订阅、更新、筛选 RSS 源推送给我们的更新信息，避免我们被海量的文章淹没，也能保证我们多个设备上 RSS 的阅读进度一致。Feedly、Inoreader 等等都是非常不错的 RSS 服务，但是它们的免费版本都有着一定的限制，有时候无法满足我们的全部功能需求，而动辄一个月数十刀的订阅费用又让人望而却步。不慌，开源的 RSS 服务：Tiny Tiny RSS 可以满足我们 RSS 订阅的全部需求！&lt;/p&gt;
&lt;h2 id=&quot;Tiny-Tiny-RSS-的搭建&quot;&gt;Tiny Tiny RSS 的搭建&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/19/aCty2KspU5f1gHr.jpg&quot; alt=&quot;使用 Feedly 主题的 Tiny Tiny RSS 服务端&quot;&gt;&lt;/p&gt;
&lt;p&gt;Tiny Tiny RSS 是一个非常优秀的开源免费 RSS 服务引擎，可以直接部署在我们自己的服务器上面，借助于 Docker 优秀方便的容器技术和 Let’s Encrypt 异常简单的 SSL 证书签署机器人 &lt;code&gt;certbot&lt;/code&gt;，我们几分钟之内就可以部署上线属于我们自己的 RSS 服务，运行在我们可控的服务器上，环境稳定，刷新及时，并且完全免费。👍（当然，除了服务器需要一定的费用。）&lt;/p&gt;
&lt;p&gt;在容器、HTTPS 证书自动签署和虚拟化技术极度发达的今天，整个部署过程非常方便简单。我接下来只利用 iPad 进行讲解演示我们的部署过程。请大家坐好，我们立刻开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="RSS" scheme="https://www.hi-linux.com/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款英语学习神器 Rosetta Stone</title>
    <link href="https://www.hi-linux.com/posts/32690.html"/>
    <id>https://www.hi-linux.com/posts/32690.html</id>
    <published>2020-05-24T01:11:00.000Z</published>
    <updated>2020-05-24T08:27:00.137Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>这是一篇旧文重发，近日又见不少同学在讨论英语学习的方法和重要性。或许本文涉及相关内容就是你的最好选择，本文涉及的相关软件已更新到最新版本。</p></blockquote><p>在这个技术高速发展的时代，新技术日新月异、层出不穷。而这些新技术基本上都是外国人开发的，并且提供的文档通常只有英文的。</p><p>如果想在第一时间掌握到最新的资讯或是解决遇到的问题，满屏的英文认识的单词没几个，这个时候会不会有种书到用时方恨少的感觉。</p><p>今天给你推荐一款学习外语的神器「Rosetta Stone」，这个软件是我从一篇「告诉你外语学习的真实方法及误区分析」文章中得知的。此文是一篇对外语学习非常有用的文章，里面谈到了学外语的四个阶段。该文章电子版本已经放到文末下载地址里了，有兴趣的同学可以读一读。</p><p>「Rosetta Stone」强调的是一个沉浸式的语言环境，学习新语言的方法与您学习母语的方法相同。教您用新的语言说话和思考。自然地发展基本的语言技能，无需依赖翻译和死记硬背。</p><p><img src="https://www.hi-linux.com/img/linux/Rosetta-Stone.jpeg" alt=""></p><a id="more"></a><p>「Rosetta Stone」课程主要分为以下几部分：</p><ol><li><p>核心课程 (包含本节主要内容, 形式：用鼠标选择即可，没有发声、拼写。)</p></li><li><p>发音 (以鼠标选择的形式)</p></li><li><p>词汇 (以鼠标选择的形式)</p></li><li><p>语法 (以鼠标选择的形式)</p></li><li><p>阅读 (用 Mic 读)</p></li><li><p>写作 (用鼠标点击屏幕上的软键盘，来拼写单词。)</p></li><li><p>听力 (以鼠标选择的形式)</p></li><li><p>听力与阅读 (以鼠标选择的形式)</p></li><li><p>口语 (以鼠标选择的形式)</p></li><li><p>复习 (以鼠标选择的形式)</p></li><li><p>重点 (四节课一次， 以鼠标选择的形式)</p></li></ol><p>看上去是不是很不错？零基础，不需要背语法，不需要背单词。还不快快安装学起来吧！</p><p>如果你的英语已经非常的厉害了，你还可以用来学习其它外语呢！「Rosetta Stone」不仅可以学习英语，还可以学习西班牙语、汉语、日语、德语、法语和意大利语等 24 种语言。</p><p>说了这么多「Rosetta Stone」的好处，现在告诉你个坏消息，「Rosetta Stone」其实是一个收费软件，而且还很贵。有没有世界都要崩塌了的感觉，呵呵！</p><p>好了，说了这么多废话。现在重点来了，直接在公众号回复关键词:「<strong>外语</strong>」，可获取「Rosetta Stone」最新特别版 (已解锁所有课程) 下载地址哟 。还在等什么呢，赶快去下载吧！</p><blockquote><p>「Rosetta Stone」目前有 Windows、Macos、IOS 版本。这里暂时只提供 Android 版本，其它版本可以自己搜一搜。</p></blockquote><p>最后，软件再好也只是辅助，坚持和反复练习才是最终获胜的大杀器！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是一篇旧文重发，近日又见不少同学在讨论英语学习的方法和重要性。或许本文涉及相关内容就是你的最好选择，本文涉及的相关软件已更新到最新版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个技术高速发展的时代，新技术日新月异、层出不穷。而这些新技术基本上都是外国人开发的，并且提供的文档通常只有英文的。&lt;/p&gt;
&lt;p&gt;如果想在第一时间掌握到最新的资讯或是解决遇到的问题，满屏的英文认识的单词没几个，这个时候会不会有种书到用时方恨少的感觉。&lt;/p&gt;
&lt;p&gt;今天给你推荐一款学习外语的神器「Rosetta Stone」，这个软件是我从一篇「告诉你外语学习的真实方法及误区分析」文章中得知的。此文是一篇对外语学习非常有用的文章，里面谈到了学外语的四个阶段。该文章电子版本已经放到文末下载地址里了，有兴趣的同学可以读一读。&lt;/p&gt;
&lt;p&gt;「Rosetta Stone」强调的是一个沉浸式的语言环境，学习新语言的方法与您学习母语的方法相同。教您用新的语言说话和思考。自然地发展基本的语言技能，无需依赖翻译和死记硬背。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/Rosetta-Stone.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://www.hi-linux.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>TTY 的前世今生</title>
    <link href="https://www.hi-linux.com/posts/2960.html"/>
    <id>https://www.hi-linux.com/posts/2960.html</id>
    <published>2020-05-24T01:10:00.000Z</published>
    <updated>2020-05-24T08:22:27.746Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="译者序">译者序</h2><p>本文翻译自 2008 年的一篇帖子 The TTY demystified.</p><p>由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。</p><p>以下是译文。</p><h2 id="目录">目录</h2><ol><li><p>历史</p></li><li><p>使用场景</p></li><li><p>进程</p></li><li><p>作业（Jobs）和会话</p></li><li><p>简单粗暴的信号机制</p></li><li><p>一个例子</p></li><li><p>流控和阻塞式 I/O</p></li><li><p>配置 TTY 设备</p></li><li><p>结束语</p></li></ol><p>TTY 子系统是 Linux 乃至 Unix 家族中最核心的设计之一。</p><p>但不幸的是，TTY 的重要性经常被低估，而且网上也很难找到不错的介绍性文章。而我认为，对 Linux 中的 TTY 有一些基本了解对于开发者和高级用户来说是非常有帮助的。</p><p>但要注意：接下来你将看到的东西并不是非常优雅。事实上，TTY 子系统 —— 虽然从用户的角度来非常好用 —— 是很多特殊场景杂糅在一起的结果。而要理解为什么会变成这样， 我们需要从历史说起。</p><h2 id="1-历史">1. 历史</h2><p>1869，人类发明了股票自动报价机（stock ticker）。它是一个用于跨长距离实时传 递股票价格的电子-机械设备，由一个打字机（typewriter）、一对很长的电缆（a long pair of wires）和一个报价用的磁带打印机（tape printer）组成。后来，这个概念逐渐 进化成速度更快的、基于 ASCII 码的电传打印机（teletype）。电传打印机曾通过一个称 为 Telex 的网络实现全球互联，用于传递商业电报，但它们并没有连接到任何计算机（ computers）。</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/oldschool.jpg" alt=""></p><p>20 世纪 40 年代的真实电传打印机（teletypes）</p><p>在同一时期，计算机 —— 虽然仍是很大很原始的机器，但能处理多任务（multitask）—— 开始变得越来越强大，足以实现与用户的实时交互。当命令行（command line）最终取代 了老式的批处理模型（batch processing model）后，人们直接将电传打印机用作了计算 机的输入和输出设备（input and output devices），因为这些设备在市场上很容易买到。</p><p>但此时面临的一个问题是：市场上有大量的电传打印机模型，所有模型之间都有一些细 微差别，因此就需要某种层面的软件中间层来屏蔽这些差异。Unix 世界中的方式是** 让操作系统内核来处理所有的低层（low-level）细节，例如 word 长度、波特率（baud rate）、流控（flow control）、奇偶校验（parity）、基本的行编辑（line editing）功 能所用的控制码等等。而 20 世纪 70 年代随着例如 VT-100 这样的固态视频终端（solid state video terminals）的出现而变成为现实的光标炫酷移动、彩色输入和其他高级特 性，则交给应用（application）来控制**。</p><p>如今在我们的世界中，物理电传打印机和视频终端事实上已经绝迹了。除非你去参观某个博 物馆或者硬件爱好者的私藏，否则你能看到的所有 TTY 很可能都是仿真（模拟）的视频 终端（emulated video terminals）——用软件去模拟真实硬件。但我们将会看到，这些传 统的钢铁浇筑的怪兽仍然潜伏在表面的平静之下。</p><a id="more"></a><h2 id="2-使用场景">2. 使用场景</h2><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/case1.png" alt=""></p><p>用户（通过一个物理电传打印机）在一个终端上输入（打字）。这个终端通过一对电缆连接 到计算机上的一个 UART（Universal Asynchronous Receiver and Transmitter，通用异步收发器）。操作系统中安装了 UART 驱动，能够处理字节的物理传输，包括奇偶校验和流控。在一个简陋的系统中，UART 驱动会将收到的字节直接发送给某个应用进程 。但是，以上方式缺少下列必备特性：</p><h3 id="21-行编辑line-editing">2.1 行编辑（Line editing）</h3><p>大部分用户都难免在打字时犯错，因此退格键（backspace key）是很有必要的。 这个功能当然可以由应用自己实现，但按照 Unix 的设计哲学，应用应该越简单越好。因此 ，为了方便，操作系统提供了一个编辑缓冲区（editing buffer）以及一些基本 的编辑命令（退格、擦除单词、清除行、重新打印），这些功能在 line discipline（行 规程）中是默认开启的。</p><p><strong>Line discipline</strong></p><p>高级应用可以选择关闭这些特性，只要将 line discipline 从默认（或 canonical） 模式改为 raw 模式就行了。大部分交互式应用（编辑器、邮件用户 agent、shell，以及 所有依赖 curses 或 readline 的程序）都运行在 raw 模式，自己来处理所有的行编辑 命令。line discipline 还包含了字符回显（character echoing）和回车/换行（ carriage returns and linefeeds）自动转换的功能。如果你愿意，可以将其想象成内核 中的 sed(1)。</p><p>出于某些偶然的原因，内核提供了多种 line discipline。但在任何时刻，对于某个给 定的串行设备，内核只会 attach 其中的一种到这个设备。默认的 discipline 叫 N_TTY（位于 drivers/char/n_tty.c，如果你喜欢刨根究底）。其他几种 disciplines 用于不同目的，例如管理包交换数据（packet switched data，例如 ppp, IrDA, serial mice 等等），但这些超出了本文的范围。</p><h3 id="22-会话管理session-management">2.2 会话管理（Session management）</h3><p>用户可能希望同时运行多个程序，在不同时刻 和不同的程序交互。如果一个程序进入无限循环，用户可能会杀掉或挂起这个程序。 后台（background）启动的程序如果执行到需要向终端写数据的地方，需要被挂起。与此类似，用户输入只应当被重定向到前台程序（foreground program）。操作系统在 TTY 驱动（drivers/char/tty_io.c）中实现了这些特性。</p><p>我们说一个操作系统进程“活着”（alive）时（有执行上下文），意味着这个进程能够执行 动作（perform actions）。TTY 驱动并没有活着；用面向对象的术语来说，TTY 驱动是一 个被动对象（passive object）。它有一些数据字段和方法，但只有当 它在某个进程或某个内核中断处理函数的上下文中被调用时，它才能够执行。同样的，line discipline 也是一个被动实体（passive entity）。</p><p>UART 驱动、line discipline 实例和 TTY 驱动三者组成一个 TTY 设备， 有时简称为 TTY。用户进程能够通过操作 /dev 目录下的相应设备文件来改变 TTY 设备的行为。进程需要对设备文件有写权限，因此当一个用户登陆到某个特定的 TTY 时 ，该用户必须成为相应设备文件的 owner。传统上这是通过 login(1) 程序实现的 ，该程序需要以 root 特权执行。</p><p>前面图中的物理线路当然也可以是一个长距离电话线路：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/case2.png" alt=""></p><p>在这张图中，除了系统此时也需要处理调制解调器（modem）的 hangup 情况之外，其他方 面跟前一张没有太大区别。</p><p>接下来我们来看一个典型的桌面系统。下图展示的是 Linux console 是如何工作的：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/case3.png" alt=""></p><p>TTY 驱动和 line discipline 的行为和前面例子中的一样，但其中不再涉及 UART 或物理 终端。与前面不同的地方在于，现在多了一个软件仿真的视频终端（一个复杂的状态机，包 括一个字符帧缓冲区和一些图形字符属性），渲染到一个 VGA 显示器。</p><p>控制台（console）子系统某种程度上比较刻板。如果我们将终端仿真放到用户空间（ userland），事情就会变得更加灵活（和抽象）。下面是 xterm(1) 及其衍生版本如何工作的：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/case4.png" alt=""></p><p>为了方便将终端模拟移到用户空间且同时保持 TTY 子系统（会话管理和 line discipline）的完整性，人们引入了伪终端（pseudo terminal）或称 pty。 你也许已经猜到了，当在伪终端内运行伪终端时（running pseudo terminals inside pseudo terminals），事情会变得更加复杂，例如 screen(1) 或 ssh(1)。</p><p>现在让我们退后一步，来看一看这些东西是如何适配到进程模型的。</p><h2 id="3-进程">3. 进程</h2><p>一个 Linux 进程可以处于以下几种状态之一：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/linuxprocess.png" alt=""></p><ul><li><p>R: 运行中或可运行（Running or runnable (on run queue)）</p></li><li><p>D: 不可中断睡眠（Uninterruptible sleep (waiting for some event)）</p></li><li><p>S: 可中断睡眠（Interruptible sleep (waiting for some event or signal)）</p></li><li><p>T: 停止（Stopped, either by a job control signal or because it is being traced by a debugger.）</p></li><li><p>Z: 僵尸进程（Zombie process, terminated but not yet reaped by its parent.）</p></li></ul><p>运行 ps l 可以看到各进程的状态。例如，如果是 sleeping 状态，WCHAN 列（”wait channel”，等待队列的名字）会显示这个进程正在等待的内核事件（kernel event）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ps l</span><br><span class="line">F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND</span><br><span class="line">0   500  5942  5928  15   0  12916  1460 wait   Ss   pts&#x2F;14     0:00 -&#x2F;bin&#x2F;bash</span><br><span class="line">0   500 12235  5942  15   0  21004  3572 wait   S+   pts&#x2F;14     0:01 vim index.php</span><br><span class="line">0   500 12580 12235  15   0   8080  1440 wait   S+   pts&#x2F;14     0:00 &#x2F;bin&#x2F;bash -c (ps l) &gt;&#x2F;tmp&#x2F;v727757&#x2F;1 2&gt;&amp;1</span><br><span class="line">0   500 12581 12580  15   0   4412   824 -      R+   pts&#x2F;14     0:00 ps l</span><br></pre></td></tr></table></figure><p>“wait” 等待队列（wait queue）和 wait(2) 系统调用相关，因此当这些进程的 任何一个子进程有任何状态变化时，这些进程就会被移动到 running 状态。</p><p>sleeping 状态有两种：可中断 sleep 和不可中断 sleep。可中断 sleep 最常见，它表示 虽然该进程当前在 wait 队列中，但只要它收到信号，就可以被移动到 running 状态。如 果查看内核源码，你会发现任何正在等待事件的内核代码都必须在 schedule() 返回 之后检查是否有信号 pending，如果有就 abort。</p><p>在上面 ps 命令的输出结果中，STAT 列显式了每个进程的当前状态。除此之外，这一 列还可能包含额外的属性或标记：</p><ul><li><p>s：表示这个进程是 session leader</p></li><li><p>+：表示这个进程是一个前台进程组的一部分（part of a foreground process group）</p></li></ul><p>这些属性用于作业控制（job control）。</p><h2 id="4-作业jobs和会话">4. 作业（Jobs）和会话</h2><p>当你按下 ^Z 键，或使用 &amp; 在后台启动一个程序时，就是在进行作业控制。</p><p>作业和进程组的概念是一样的（A job is the same as a process group）。shell 内 置的命令，例如 jobs、fg、bg 等等可以用于管理一个会话内已有的作业。每个 session 都是由一个 session leader 管理的，这个 session leader 就是 shell —— 通过一个复杂的信号协议和系统调用来和内核紧密协作。</p><p>下面的例子展示了进程、作业和会话之间的关系：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/exampleterm.png" alt=""></p><p>上图中的 shell 交互对应下面的这些进程：</p><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/examplediagram.png" alt=""></p><p>以及下面这些内核结构：</p><ul><li>TTY Driver (/dev/pts/0)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Size: 45x13                                           # 尺寸：45x13</span><br><span class="line">Controlling process group: (101)                      # 控制进程组：101</span><br><span class="line">Foreground process group: (103)                       # 前台进程组：103</span><br><span class="line">UART configuration (ignored, since this is an xterm): # UART 配置（忽略，因为这是虚拟终端 xterm）</span><br><span class="line">  Baud rate, parity, word length and much more.</span><br><span class="line">Line discipline configuration:                        # Line discipline 配置：</span><br><span class="line">  cooked&#x2F;raw mode, linefeed correction,               #   cooked&#x2F;raw 模式</span><br><span class="line">  meaning of interrupt characters etc.</span><br><span class="line">Line discipline state:                                # Line discipline 状态：</span><br><span class="line">  edit buffer (currently empty),                      #   编辑缓冲区（当前为空）</span><br><span class="line">  cursor position within buffer etc.</span><br></pre></td></tr></table></figure><ul><li>pipe0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Readable end (connected to PID 104 as file descriptor 0) # 可读端（作为文件描述符 0 连接到 PID 104）</span><br><span class="line">Writable end (connected to PID 103 as file descriptor 1) # 可写端（作为文件描述符 1 连接到 PID 103）</span><br><span class="line">Buffer</span><br></pre></td></tr></table></figure><pre><code>                                               # 缓冲区</code></pre><p>这里的基本思想是：every pipeline is a job（每条流水线都是一个作业），因为每个 pipeline 内的进程都需要被同时操控（stopped, resumed, killed）。这也是为什么能够 用 kill(2) 向一整个进程组发送信号的原因。默认情况下，fork(2) 会将新创建出来 的子进程放到与其父进程相同的进程组，因此，例如一个 ^C 键就会同时影响到父子进程 。但 shell 有些不同，作为其 session leader 职责的一部分，它每次创建一个 pipeline 的时候都会创建一个新的进程组。</p><p>TTY 驱动跟踪记录前台进程组 ID（foreground process group id），但只会以被动的方 式跟踪。当有必要时，session leader 必须显式更新这项信息。类似地，TTY 驱动 也会以被动的方式跟踪所连接的终端的尺寸大小（size），但这个信息必须由终端模拟器甚 至用户来显式更新。</p><p>前面的图中可以看到，几个不同进程都将 /dev/pts/0 attach 到了它们的标准输入。但 只有前台任务（ls | sort pipeline）会从 TTY 接收输入。类似地，只有前台作业是允 许写到 TTY 设备的（在默认配置下）。如果图中的 cat 进程试图写到该 TTY，内核会通过一个信号挂起它。</p><h2 id="5-简单粗暴的信号机制">5. 简单粗暴的信号机制</h2><p>现在让我们来更加近距离地看看内核中的 TTY 驱动、line discipline 和 UART 驱动 是如何与用户空间进程通信的。</p><p>UNIX 文件，包括 TTY 设备文件，都可以被读取或写入，以及通过神奇的 ioctl(2)（ UNIX 中的瑞士军刀）系统调用进一步操作，内核中已经为 TTY 设备实现了很多相关的 ioctl 操作。但是，ioctl 请求必须从进程（向内核）发起，因此当内核（主动）希望异步地与应用进行通信时，ioctl 就不适用了。</p><p>在《银河系漫游指南》中， Douglas Adams 描述了一个极其迟钝的星球，上面居住了一群 意志消沉的人以及一种带有锋利牙齿的动物，后者与前者交谈的方式就是用力撕咬他们的大 腿。这与 UNIX 非常相似，因为内核与进程通信的方式就是向进程发送能使之瘫痪或致命的信号。进程可能会捕获其中某些信号，然后尝试解决遇到的问题，但大部分信号都是没 有被捕获的。</p><p>因此，信号是一种粗暴的内核与应用进程异步通信的机制。UNIX 中信号的设计并不整洁或通用；每个信号都是唯一的，因此必须逐个研究。</p><p><code>kill -l</code> 命令可以查看当前系统已经实现了哪些信号。这个命令的输出可能与下面的类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL</span><br><span class="line"> 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE</span><br><span class="line"> 9) SIGKILL      10) SIGUSR1     11) SIGSEGV     12) SIGUSR2</span><br><span class="line">13) SIGPIPE      14) SIGALRM     15) SIGTERM     16) SIGSTKFLT</span><br><span class="line">17) SIGCHLD      18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN      22) SIGTTOU     23) SIGURG      24) SIGXCPU</span><br><span class="line">25) SIGXFSZ      26) SIGVTALRM   27) SIGPROF     28) SIGWINCH</span><br><span class="line">29) SIGIO        30) SIGPWR      31) SIGSYS      34) SIGRTMIN</span><br><span class="line">35) SIGRTMIN+1   36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4</span><br><span class="line">39) SIGRTMIN+5   40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9   44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12</span><br><span class="line">47) SIGRTMIN+13  48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14</span><br><span class="line">51) SIGRTMAX-13  52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10</span><br><span class="line">55) SIGRTMAX-9   56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6</span><br><span class="line">59) SIGRTMAX-5   60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1   64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>如上所示，信号是从 1 开始编码的。但如果是掩码（bitmask）形式表示（例如 ps s 的 输出中），最不重要比特（least significant bit）表示的是 1。</p><p>本文将关下面几信号：SIHUP、SIGIT、SIGQUI、SIGPIPE、 SIGCHLD、SIGSTOP 、 SIGCONT、 SIGTSTP、 SIGTTIN、SIGTTOU 和 SIGWINCH。</p><ul><li><p>SIGHUP</p><ul><li><p>默认动作：Terminate</p></li><li><p>可能动作：Terminate, Ignore, Function call</p></li></ul></li></ul><p>当检测到 hangup 时，UART 驱动会向整个 session 发送 SIGHUP 信号。 正常情况下，这会 kill 掉所有进程。某些程序，例如 nohup(1) 和 screen(1)，会从他们的 session（和 TTY）中 detach 出来， 因此这些程序的子进程无法关注到 hangup 事件。</p><ul><li><p>SIGINT</p><ul><li><p>默认动作：Terminate</p></li><li><p>可能动作：Terminate, Ignore, Function call</p></li></ul></li></ul><p>当输入流中出现interactive attention character（交互式注意字符，通常是 ^C，ASCII 码是 3）时，TTY 驱动会向当前的前台作业发送 SIGINT 信号，除非这个特性被关闭了。任何对 TTY 设备有权限的人都可以修改 the interactive attention character 或打开/关闭这个特性；另外，会话管理器（session manager） 跟踪记录每个作业的 TTY 配置，当发生作业切换时会更新 TTY。</p><ul><li><p>SIGQUIT</p><ul><li><p>默认动作：Core dump</p></li><li><p>可能动作：Core dump, Ignore, Function call</p></li></ul></li></ul><p>SIGQUIT 和 SIGINT 类似，但 quit 字符通常是 ^\，而且默认动作不同。</p><ul><li><p>SIGPIPE</p><ul><li><p>默认动作：Terminate</p></li><li><p>可能动作：Terminate, Ignore, Function call</p></li></ul></li></ul><p>对于每个尝试向没有 reader 的 piepe 写数据的进程，内核会向其发送 SIGPIPE 信号。这很有用，因为如果没有这个信号，某些作业就无法终止。</p><ul><li><p>SIGCHLD</p><ul><li><p>默认动作：Ignore</p></li><li><p>可能动作：Ignore, Function call</p></li></ul></li></ul><p>当一个进程死掉或状态发生改变时（stop/continue），内核会向其父进程发送此信号 。该信号还附带了其他信息，即该进程的进程 ID、用户 ID、退出状态码（或终止信号） 以及其他一些执行时统计信息（execution time statistics）。session leader 使用 这个信号跟踪它的作业。</p><ul><li><p>SIGSTOP</p><ul><li><p>默认动作：Suspend</p></li><li><p>可能动作：Suspend</p></li></ul></li></ul><p>该信号会无条件地挂起信号接受者，例如，该信号的动作是不能被重新配置的（ reconfigure）。但要注意，该信号并不是在作业控制（job control）期间被内核发送 的。^Z 通常情况下触发的是 SIGTSTP 信号，这个信号是可以被应用捕获的。例如 ，应用可以将光标移动到屏幕底部，或者将终端置于某个已知状态，随后通过 SIGSTOP 将自己置于 sleep 状态。</p><ul><li><p>SIGCONT</p><ul><li><p>默认动作：Wake up</p></li><li><p>可能动作：Wake up, Wake up + Function call</p></li></ul></li></ul><p>该信号会唤醒（un-suspend）一个已经 stop 的进程。用户执行 fg 命令时， shell 会显式地发送这个信号。由于应用无法捕获该信号，因此如果出现未预期的 SIGCONT 信号，可能就表示某些进程在一段时间之前被挂起了，现在挂起被解除了。</p><ul><li><p>SIGTSTP</p><ul><li><p>默认动作：Suspend</p></li><li><p>可能动作：Suspend, Ignore, Function call</p></li></ul></li></ul><p>该信号与 SIGINT 和 SIGQUIT 类似，但对应的魔法字符通常是 ^Z，默认动作是挂起进程。</p><ul><li><p>SIGTTIN</p><ul><li><p>默认动作：Suspend</p></li><li><p>可能动作：Suspend, Ignore, Function call</p></li></ul></li></ul><p>如果一个后台作业中的进程尝试读取一个 TTY 设备，TTY 会发送该信号给整个作业。 正常情况下这会挂起作业。</p><ul><li><p>SIGTTOU</p><ul><li><p>默认动作：Suspend</p></li><li><p>可能动作：Suspend, Ignore, Function call</p></li></ul></li></ul><p>如果一个后台作业中的进程尝试写一个 TTY 设备，TTY 会发送该信号给整个作业。 正常情况下这会挂起作业。可以在 per-TTY 级别打开或关闭这个特性。</p><ul><li><p>SIGWINCH</p><ul><li><p>默认动作：Ignore</p></li><li><p>可能动作：Ignore, Function call</p></li></ul></li></ul><p>前面提到，TTY 设备会跟踪记录终端的尺寸（size），但这个信息需要手动更新。 当终端尺寸发送变化时，TTY 设备会向前台作业发送该信号。行为良好的交互式应用， 例如编辑器，会对此作出响应：从 TTY 设备获取新的终端尺寸，然后根据该信息重绘自己。</p><h2 id="6-一个例子">6. 一个例子</h2><p>设想你在用自己的（基于终端的）编辑器编辑某个文件。光标当前位于屏幕中央，编辑器正 忙于执行某些 CPU 密集型任务，例如在一个大文件中执行搜索或替换操作。现在假设你按 下了^Z 键。因为 line discipline 已经配置了捕获此字符（^Z 是单个字节，ASCII 码 为 26），因此你无需等待编辑器完成它正在执行的任务然后开始从 TTY 设备读取数据。</p><p>此时的情况是，line discipline 子系统会立即向前台进程组发送 SIGTSTP 信号。 这个进程组中包括编辑器进程，以及它创建出来的任何子进程。</p><p>编辑器为 SIGTSTP 进程注册了信号处理函数，因此内核此时开始执行该信号处理函数 的代码。该代码通过向 TTY 设备写入相应的控制序列（control sequences），将 光标移动到屏幕最后一行。由于编辑器仍然在前台，这个控制序列能够正常发送出去（给 TTY）。但之后，编辑器会给自己所在的进程组发送一个 SIGSTOP 信号。</p><p>编辑器此时就被挂起（stop）了。这个事件会通过一个 SIGCHLD 信号发送给 session leader， 其中包括了被挂起进程的进程 ID。当前台作业中的所有进程都被挂起后，session leader 从 TTY 设备中读取当前配置，保存以备后面恢复时用。session leader 使用 ioctl 系 统调用，继续将自己注册（install itself）为该 TTY 的当前前台进程组。然后，它打印 出类似 “[1]+ Stopped” 之类的信息，告知用户有一个作业刚被挂起了。</p><p>此时，ps(1) 会告诉你编辑器进程当前处于 stopped state (“T”)。如果我们试图唤醒它 ，不管是通过 shell 内置的 bg 命令，还是使用 kill(1) 发送 SIGCONT 信号给进程 ，都会触发编辑器执行它的 SIGCONT 信号处理函数。该信号处理函数可能会尝试通过写 TTY 设备来重绘编辑器 GUI。但由于此时编辑器是后台作业，TTY 设备是不允许其写入的。 这种情况下 TTY 会给编辑器发送 SIGTTOU 信号，再次将其 stop。这个事件会通过 SIGCHLD 信号通知到 session leader，然后 shell 会再次将 “[1]+ Stopped” 之类的 消息写到终端。</p><p>但当我们输入 fg 命令时，shell 首先会恢复此前保存的 line discipline 配置。 然后，它通知 TTY 驱动从现在开始编辑器作业应当被作为前台作业对待了。最后，它发送一个 SIGCONT 信号给进程组。编辑器进程尝试重绘 GUI，而这一次它不会被 SIGTTOU 中断了，因为它现在是前台作业的一部分了。</p><blockquote><p>（译者）总结：</p><ol><li><p>使用编辑器编辑文件。</p></li><li><p>按 ^Z 键 -&gt; 唤醒 line discipline。</p></li><li><p>line discipline -&gt; 前台进程组：SIGTSTP。</p></li><li><p>编辑器 SIGTSTP 信号处理函数 -&gt; TTY：写入控制序列，将光标移动到最后屏幕一行</p></li><li><p>编辑器 SIGTSTP 信号处理函数 -&gt; 自己所在的进程组：SIGSTOP。</p></li><li><p>编辑器被挂起（stop）。这个事件会通过一个 SIGCHLD 信号发送给 session leader，其中包括了被挂起进程的进程 ID。</p></li><li><p>前台进程组中的所有进程都被挂起，session leader 从 TTY 中读取当前配置并保存</p></li></ol><p>8.session leader 使用 ioctl 系统调用，继续将自己注册（install itself）为该 TTY 的当前前台进程组。然后，它打印出类似 “[1]+ Stopped” 之类的信息，告知 用户有一个作业刚被挂起了。</p><ol start="9"><li><p>bg 或 kill -SIGCONT 给编辑器发信号：编辑器会尝试写 TTY 来重绘窗口，但此 时编辑器进程是后台进程，不允许写 TTY，因此 TTY 会给其发送 SIGTTOU 信号， 再次将其 stop；这个事件会通过 SIGCHLD 信号告知 session leader，后者再次将 [1]+ Stopped 信息写到终端。</p></li><li><p>但当我们输入 fg 命令时，shell 会恢复此前保存的 line discipline 配置。然 后通知 TTY 驱动编辑器进程现在是前台进程了。最后，它发送一个 SIGCONT 信号 给进程组恢复编辑器的执行。</p></li></ol></blockquote><h2 id="7-流控和阻塞式-io">7. 流控和阻塞式 I/O</h2><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/dsc00043.jpg" alt=""></p><p>在 xterm 中执行 yes 命令，你会看到大量的 “yes” 一行一行地快速闪过。正常情况 下条，yes 进程产生 “yes” 输出的速度要远快于 xterm 应用解析这些行、更新帧缓冲 区、与 X server 通信来滚动窗口等等的速度。那么，这些进程之间是如何协作的呢？</p><p>答案就是 blocking I/O（阻塞式输入/输出）。伪终端只能在其内核缓冲区中保存一定量 的数据，当缓冲区已经填满而 yes 程序仍然调用 write(2) 写入时，write(2) 会阻 塞，yes 进程会被移入可中断 sleep 状态，直到 xterm 进程读走了一部分缓存的数据。</p><p>当 TTY 连接到的是串口（serial port）时，过程与此类似。yes 能够以很快的速度 发送数据，例如 9600 波特，但如果串口速度比这个低，内核缓冲区很快就会塞满，随后的 任何 write(2) 调用都会阻塞写进程（或者返回 EAGAIN 错误码 —— 如果进程请求的是非 阻塞 I/O）。</p><p>如果我告诉你，我们能够显式地将 TTY 置于阻塞状态，即使内核缓冲区中仍然有可用 空间呢？这样设置之后，每个进程调用 write(2) 进行写入时，TTY 都会自动阻塞。但 什么情况下回用到这个特性呢？</p><p>设想我们正在以 9600 波特和某个陈旧的 VT-100 硬件通信。我们刚发送了一个复杂的控制 序列要求终端滚动显示页面。此时，终端忙于执行滚动操作，无法以全速 9600 波特接收新 的数据。这种情况下，在物理上，终端 UART 仍然运行在 9600 波特，但缓冲区中没有足够 的空间来给终端存储接收到的数据。这就是一个将 TTY 置于阻塞状态的好时机。那么要实 现这个效果，我们该怎么做呢？</p><p>前面已经看到，可以配置 TTY 设备对某些特定的数据给予特殊对待。例如，在默认配 置中，TTY 收到的 ^C 字符并不会通过 read(2) 直接交给应用，而是会触发发送一个 SIGINT 信号给前台作业。类似地，可以配置 TTY 对 stop flow byte（停止流字节） 和start flow byte（开始流字节）做出响应。通常情况下，这分别是^S (ASCII code 19) 和 ^Q (ASCII code 17)。老式硬件终端能自动发送这些字节，然后期待操作系统能够按照约定对它的数据流进行管控。这个过程称为流控（flow control），这也是 为什么有时你误按了 ^S 时，你的 xterm 会锁定的原因。</p><p>这里要区分两种情况：</p><ul><li><p>向一个由于流控或内核缓冲空间不足而 stop 的 TTY 写入：写入进程会被阻塞（block）</p></li><li><p>从后台作业向一个 TTY 写入：会导致 TTY 发送一个 SIGTTOU 给整个进程组将其挂起（suspend）<br>我不清楚 UNIX 的设计者为何发明 SIGTTOU 和 SIGTTIN 而不是依靠 blocking I/O， 我尽己所能猜到的原因是：负责着作业控制（job control）的 TTY 驱动，设计用于监控和 操作全部作业，而不是作业内的单个进程。</p></li></ul><h2 id="8-配置-tty-设备">8. 配置 TTY 设备</h2><p><img src="https://arthurchiao.github.io/assets/img/tty-demystified/cockpit.jpg" alt=""></p><p>要确定当前 shell 的 TTY，可以通过我们前面介绍的 ps l 命令，或者直接运行 tty(1) 命令。</p><p>一个进程可能会通过 ioctl(2) 读取或修改一个已经打开的 TTY 设备。相应的 API 在 tty_ioctl(4) 中作了描述。由于这是 Linux 应用和内核之间的二进制接口的一部分， 因此它在不同的 Linux 版本之间是保持稳定的。但是，这个接口是不可移植的，若想编 写可移植的程序，应用应当使用 termios(3) man page 中提供的 POSIX wrapper。</p><p>这里我不会深入介绍 termios(3) 接口，但如果你正在编写 C 程序，涉及到捕获 ^C、 关闭行编辑或字符回显、修改串口的波特率、关闭流控等等工作，那你就需要去阅读前面提到的 man page。</p><p>另外还有一个命令行工具 stty(1)，用于操纵 TTY 设备。它使用了 termios(3) API。</p><p>我们来试试！</p><h3 id="tty-配置选项">TTY 配置选项</h3><p><code>stty -a</code> 打印所有配置项。默认打印的是当前 shell 所 attach 的 TTY 设备配置项，但 可以通过 -F 指定其他设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ stty -a</span><br><span class="line">speed 38400 baud; rows 73; columns 238; line &#x3D; 0;</span><br><span class="line">intr &#x3D; ^C; quit &#x3D; ^\; erase &#x3D; ^?; kill &#x3D; ^U; eof &#x3D; ^D; eol &#x3D; &lt;undef&gt;; eol2 &#x3D; &lt;undef&gt;; swtch &#x3D; &lt;undef&gt;; start &#x3D; ^Q; stop &#x3D; ^S; susp &#x3D; ^Z; rprnt &#x3D; ^R; werase &#x3D; ^W; lnext &#x3D; ^V; flush &#x3D; ^O; min &#x3D; 1; time &#x3D; 0;</span><br><span class="line">-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts</span><br><span class="line">-ignbrk brkint ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany imaxbel -iutf8</span><br><span class="line">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><br><span class="line">isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke</span><br></pre></td></tr></table></figure><p>以上选项中，某些是 UART 参数；某些影响 line discipline，某些用于作业控制。我们先 来看第一行：</p><ul><li><p>speed</p><ul><li><p>UART 参数</p></li><li><p>波特率。伪终端忽略此选项。</p></li></ul></li><li><p>rows 和 columns</p><ul><li><p>TTY 驱动参数</p></li><li><p>attach 到这个 TTY 设备的终端大小（size），单位是字符数。本质上这只是内核空 间中的一对变量，可以随意修改和读取。修改这两个参数会触发 TTY 驱动发送 SIGWINCH 信号给前台作业。</p></li></ul></li><li><p>line</p><ul><li><p>Line discipline 参数</p></li><li><p>表示 attach 到这个 TTY 的 line discipline。0 代表 N_TTY。所有的合法值列在 /proc/tty/ldiscs 下面。未列出的值似乎是 N_TTY 的 alias，但不依赖前者。</p></li></ul></li></ul><h3 id="修改窗口尺寸">修改窗口尺寸</h3><p>尝试下面的例子：开启一个 xterm。记录下它的 TTY 设备（执行 tty 命令查看）以及尺 寸（执行 stty -a 命令查看）。在 xterm 中启动 vim（或其他全屏终端应用）。编辑器会询问 TTY 设 备当前的终端尺寸，以填充整个窗口。</p><p>现在，在另一个 shell 窗口中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stty -F X rows Y</span><br></pre></td></tr></table></figure><p>其中 X 是 TTY 设备，Y 是终端高度的一半。这条命令会更新内核内存中的 TTY 配置数据 ，并触发向编辑器发送一个 SIGWINCH 信号；vim 收到信号会立即重绘自身，结果是编辑 器的高度减半。</p><h3 id="修改-sigint-对应的控制字符">修改 SIGINT 对应的控制字符</h3><p>stty -a 命令的输出中，第二行列出了所有的特殊字符。</p><p>打开一个新 xterm 然后尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stty intr o</span><br></pre></td></tr></table></figure><p>现在输入字符 o —— 而不是原来默认的 ^C —— 会触发发送 SIGINT 信号给前台作业。</p><p>你可以运行着某个命令，例如 cat，然后验证此时 ^C 是不能终止其执行的。然后，再试试输入 hello 给 cat。</p><h3 id="退格键无法使用">退格键无法使用</h3><p>某些场合下，你可能会在某个 UNIX 系统上遇到退格键无法使用的情况。</p><p>发生这种情况是因为终端模拟器发送的退格码（不管是 ASCII 8 还是 127）与 TTY 设备中的擦除设置（erase setting）不匹配。要解决这个问题，通常需要输入 stty 擦除 ^H（ASCII 8）或 stty erase ^?（ASCII 127）。但请记住，某些终端应用使 用 readline，它们会将 line discipline 置于 raw 模式，这些应用不会受此影响。</p><h3 id="tty-开关项">TTY 开关项</h3><p>最后，stty -a 列出了一系列的开关。这些开关并没有先后顺序。某些与 UART 相关，某 些影响 line discipline 行为，某些用于流控，某些用于作业控制。有减号（-）表示该 开关当前是关闭的；否则就是打开的。所有开关都在 stty(1) man page 中有解释，因此 这里只是简要介绍几个：</p><p>icanon 打开/关闭 canonical (line-based) 模式。尝试在一个新 xterm 内运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stty -icanon; cat</span><br></pre></td></tr></table></figure><p>执行这条命令后，所有的行编辑字符，例如退格和 ^U 将无法使用。你会注意到 cat 此 时开始按字符接收（以及打印）内容，而不是像之前一样按行。</p><p>echo 打开字符回显（character echoing），这个选项默认是打开的。重新启用 canonical mode（stty icanon），然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stty -echo; cat</span><br></pre></td></tr></table></figure><p>输入命令时，终端模拟器会将命令信息发送给内核。通常情况下，内核会将相同的信息回显给 终端模拟器，这样我们就可以看到自己输入的内容了。没有字符回显的话，我们无法看到自己输 入的内容，但由于我们在 cooked 模式，因此行编辑设施还是仍然工作的。当按下回车键 时，line discipline 会将编辑缓冲区发送给 cat，后者就会显示输入的内容。</p><p>tostop 控制是否允许后台作业写终端。首先尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stty tostop; (sleep 5; echo hello, world) &amp;</span><br></pre></td></tr></table></figure><p>&amp; 使得前面的进程以后台作业的方式执行。5 秒之后，该作业会尝试写 TTY。TTY 驱动会 使用 SIGTTOU 来挂起该进程，shell 可能会报告这个结果，可能是立即，也可能是某个时 候弹出一个提醒框。现在 kill 掉后台作业，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stty -tostop; (sleep 5; echo hello, world) &amp;</span><br></pre></td></tr></table></figure><p>以上命令会重新打开输入回显功能；5 秒之后，后台作业发送 hello, world 给终端，此 时不管你正在输入什么，这句话都会打印出来。</p><p>最后，stty sane 会将 TTY 设备恢复到某个合理的配置。</p><h2 id="9-结束语">9. 结束语</h2><p>本文提供了 TTY 驱动和 line discipline 相关的知识，以及它们和终端、行编辑及作业控 制的联系，希望这些内容足够读者对它们有一个了解。更多信息请参考前面提到的几个 man page，以及 glibc 手册（info libc，”Job Control”）。</p><p>最后，感谢阅读！</p><blockquote><p>本文转载自：「ARTHURCHIAO’S BLOG」，原文：<a href="https://url.cn/5Q53HEg%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5Q53HEg，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;译者序&quot;&gt;译者序&lt;/h2&gt;
&lt;p&gt;本文翻译自 2008 年的一篇帖子 The TTY demystified.&lt;/p&gt;
&lt;p&gt;由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。&lt;/p&gt;
&lt;p&gt;以下是译文。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;历史&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用场景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作业（Jobs）和会话&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单粗暴的信号机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个例子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流控和阻塞式 I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 TTY 设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结束语&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TTY 子系统是 Linux 乃至 Unix 家族中最核心的设计之一。&lt;/p&gt;
&lt;p&gt;但不幸的是，TTY 的重要性经常被低估，而且网上也很难找到不错的介绍性文章。而我认为，对 Linux 中的 TTY 有一些基本了解对于开发者和高级用户来说是非常有帮助的。&lt;/p&gt;
&lt;p&gt;但要注意：接下来你将看到的东西并不是非常优雅。事实上，TTY 子系统 —— 虽然从用户的角度来非常好用 —— 是很多特殊场景杂糅在一起的结果。而要理解为什么会变成这样， 我们需要从历史说起。&lt;/p&gt;
&lt;h2 id=&quot;1-历史&quot;&gt;1. 历史&lt;/h2&gt;
&lt;p&gt;1869，人类发明了股票自动报价机（stock ticker）。它是一个用于跨长距离实时传 递股票价格的电子-机械设备，由一个打字机（typewriter）、一对很长的电缆（a long pair of wires）和一个报价用的磁带打印机（tape printer）组成。后来，这个概念逐渐 进化成速度更快的、基于 ASCII 码的电传打印机（teletype）。电传打印机曾通过一个称 为 Telex 的网络实现全球互联，用于传递商业电报，但它们并没有连接到任何计算机（ computers）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://arthurchiao.github.io/assets/img/tty-demystified/oldschool.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;20 世纪 40 年代的真实电传打印机（teletypes）&lt;/p&gt;
&lt;p&gt;在同一时期，计算机 —— 虽然仍是很大很原始的机器，但能处理多任务（multitask）—— 开始变得越来越强大，足以实现与用户的实时交互。当命令行（command line）最终取代 了老式的批处理模型（batch processing model）后，人们直接将电传打印机用作了计算 机的输入和输出设备（input and output devices），因为这些设备在市场上很容易买到。&lt;/p&gt;
&lt;p&gt;但此时面临的一个问题是：市场上有大量的电传打印机模型，所有模型之间都有一些细 微差别，因此就需要某种层面的软件中间层来屏蔽这些差异。Unix 世界中的方式是** 让操作系统内核来处理所有的低层（low-level）细节，例如 word 长度、波特率（baud rate）、流控（flow control）、奇偶校验（parity）、基本的行编辑（line editing）功 能所用的控制码等等。而 20 世纪 70 年代随着例如 VT-100 这样的固态视频终端（solid state video terminals）的出现而变成为现实的光标炫酷移动、彩色输入和其他高级特 性，则交给应用（application）来控制**。&lt;/p&gt;
&lt;p&gt;如今在我们的世界中，物理电传打印机和视频终端事实上已经绝迹了。除非你去参观某个博 物馆或者硬件爱好者的私藏，否则你能看到的所有 TTY 很可能都是仿真（模拟）的视频 终端（emulated video terminals）——用软件去模拟真实硬件。但我们将会看到，这些传 统的钢铁浇筑的怪兽仍然潜伏在表面的平静之下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>一个优秀架构师必知的 30 条设计原则</title>
    <link href="https://www.hi-linux.com/posts/53772.html"/>
    <id>https://www.hi-linux.com/posts/53772.html</id>
    <published>2020-05-24T01:08:00.000Z</published>
    <updated>2020-05-24T08:15:49.419Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，架构师的角色，更偏向于策划、而非指挥，塑造、而非支配，其存在的意义，在于引导大家讨论、而非自己主宰一切。</p><p>但是，具体应该如何执行呢？本文作者整理了 30 个公认的架构原则，来帮助大家解决此问题。也许有的原则，你从未听说，但你看完就能快速学会。</p><p>相信你学会了，工作起来也会事半功倍，或许还可帮你避免很多无用的加班！</p><blockquote><p>本文作者叫 Srinath，是一位计算机科学家、软件架构师、作家。他是 Apache 的核心成员，拥有 15 年分布式系统编程经验，设计了 Apache Axis2 以及 WSO2 流处理器。</p></blockquote><p>在 WSO2，我参与架构评审的时间已长达八年之久。WSO2 的产品非常丰富，比如 WSO2 ESB 、WSO2 API Manager  以及 WSO2 SP 都人尽皆知。在过去八年中，我们对许多产品和功能进行了讨论、设计、改进和重新设计。</p><p>我们在设计软件的过程中，把握的一个关键点是：软件架构并非由架构师负责设计。我们的架构不是由架构师制定，然后交给其他人来实施。</p><p>相反，架构的设计任务由真正编写代码的团队负责。架构师负责对工程师设计的架构进行修复、完善和改进。我们的架构团队是指导员和把关人，而非独裁者。</p><p>在短期内，由一位架构师来制定架构的确既快捷又实惠。但是，从长远来看，我们会组建一个团队，让他们自己不断思考、改善架构，并从他们的错误中来提升自己。</p><p>当我们专注于团队时，他们自然会随着时间的推移而变得更好。架构团队的首要任务是：尽可能保证架构容易执行。此外，架构评审也存在缺陷。</p><p>就像 Paul （@pzfreo）描述的架构评审那样：架构师参与进来，听一会，发表一点评论然后就走了。作为一名架构师，你对架构发表自己的看法和意见无可厚非。但是，如果你不够投入和细心，你的意见可能会让团队感到困惑，团队就无法确定正确的做法到底是什么。</p><p>接下来我会将 30 个架构原则一一列出，其中一些原则是众所周知的，而有些则源于我的个人经验和心血。</p><p><img src="https://i.loli.net/2019/08/15/CVRuDeBOyvcJM9G.png" alt=""></p><a id="more"></a><h2 id="基本原则">基本原则</h2><ul><li><p>原则 1： KISS (Keep it simple,sutpid) 和保持每件事情都尽可能的简单，用最简单的解决方案来解决问题。</p></li><li><p>原则 2：YAGNI（你不需要它）原则 ，只在需要时构建。</p></li><li><p>原则 3：先学会爬，然后再学会走，最后学会跑。换句话说，先保证能够正常运行，然后优化它使其更好，最后逐渐让它变得完美。使用迭代开发，采用敏捷开发模式。为每个功能制定一个开发周期（最多 2 周），然后不断迭代。</p></li><li><p>原则 4：自动化测试是构建稳定、高质量产品的唯一方法。通过自动化测试提升创造力，所有一切都可以自动化！在设计时应当好好考虑自动化。</p></li><li><p>原则 5：注重投资回报率（ROI）并将最多的注意力放在最重要的地方。</p></li><li><p>原则 6：了解用户并相应地平衡资源。大多数产品都有数千个最终用户，大致需要 20 个开发人员和 100 个 DevOps 人员。不要花费数月的时间来构建一个不太可能使用 DevOps 的用户界面（他们更喜欢脚本）。这是原则 5 的特例。</p></li><li><p>原则 7：功能的设计和测试尽可能独立。如果在设计时考虑到这一点，长远来看，它将省去很多麻烦，否则只有一切构建完成时你才可以开始测试整个系统。此外，遵循这个原则，版本发布也会更加顺利。</p></li><li><p>原则 8：警惕搜索引擎中花里胡哨的架构方案。我们天生都喜欢令人夺目的设计。如果你按奈不住， 就可能把太多根本不需要的功能和解决方案引入到你的架构中。</p></li></ul><h2 id="功能选择">功能选择</h2><ul><li><p>原则 9：想要准确知道用户如何使用我们的产品是很难的。所以我们要推行 MVP（最小可行产品）。该理念的核心在于：先制定一些用例，完成用例所涉及的相关功能，立即发布产品，然后根据反馈和经验对产品进行优化。</p></li><li><p>原则 10：尽可能减少功能，如有疑问则将其删除。许多功能可能从未使用，你只需为其留一个扩展接口即可。</p></li><li><p>原则 11：听取客户的意见，看他们想要什么功能。</p></li><li><p>原则 12：当客户要求的功能影响到其他模块时，要勇于和客户辩论。从大局出发，尝试找到另一种方法来处理问题。就像 Fords 所说的那样“每当我问顾客需要什么的时候,他们总是会说需要跑得更快的马”。请记住，你才是专家。你应该主导一切，做出正确和专业的决定。虽然用户可能当时有些疑惑，但最终他们会感谢你的。</p></li></ul><h2 id="服务端设计和并发">服务端设计和并发</h2><ul><li><p>原则 13：要知道一个 Server 是如何运行的，从硬件到操作系统，直到编程语言。优化 IO 调用的数量是你通往最好架构的首选之路。</p></li><li><p>原则 14：遵循 Amdhal 的同步定律。线程之间共享的可变数据会降低程序速度。如果可以，请使用并发数据结构，并且仅在必要时使用同步。尽可能少地使用锁。如果你打算在线程锁期间阻塞，请确保自己足够了解具体细节，因为这里存在极大的隐患。</p></li><li><p>原则 15：如果你的设计是基于事件驱动的非阻塞架构，那就不要阻塞线程或者在线程中执行 IO 操作。一旦这样做，系统将慢如蜗牛。</p></li></ul><h2 id="分布式系统">分布式系统</h2><ul><li><p>原则 16：无状态系统具有良好的扩展性。我们要尽可能了解和使用无分享架构。</p></li><li><p>原则 17：除非你能够掌控客户端和服务器的所有代码，否则消息传递失败的情况在所难免。尽量减少你的系统依赖的因素（例如使用原则 18 ）。</p></li><li><p>原则 18：尽可能实施幂等操作。这样它就很容易恢复，你至少可以保证交付没问题。</p></li><li><p>原则 19：了解 CAP 定理。可扩展的事务（分布式事务）是很难的 。尽可能使用补偿，基于 RDBMS 的事务很难扩展。</p></li><li><p>原则 20：分布式系统共识不支持扩展，也无法进行组通信，不支持群集范围内的可靠消息传递。其最大节点限制大约是八个节点。</p></li><li><p>原则 21：在分布式系统中，你很难隐藏分布式系统中的延迟和故障。（参见分布式计算的谬误解释 ）。</p></li></ul><h2 id="用户体验">用户体验</h2><ul><li><p>原则 22：了解你的用户以及他们的目标：他是新手、专家还是临时用户？他对计算机科学了解多少？极客看重扩展功能，开发人员关注示例和脚本，普通人则更在乎界面。</p></li><li><p>原则 23：最好的产品应当不需要用户手册，用户应该一看就会用。</p></li><li><p>原则 24：当你无法在两个选项之间做出决定时，请不要通过配置选项的方式来呈现问题。这会给用户和架构师带来麻烦。对于系统如何运作的细节，他们没有你了解，他们怎么能做出决定呢？最好的方案是找到一个每次都有效的选择；其次是自动做出选择；第三个方案是添加配置参数并设置合理的默认值。</p></li><li><p>原则 25：始终具有合理的配置默认值。</p></li><li><p>原则 26：设计不良的配置会制造麻烦，始终配置几个示例值。</p></li><li><p>原则 27：询问用户配置值的时候，注意选择用户无需即可设置的值（例如，不要问用户需要的最大缓存条目数量，而是要问他想要用于缓存的内存数量）</p></li><li><p>原则 28：如果发现未知配置，则抛出错误。永远不要忽视它。在调试过程中，无提示的配置错误会浪费我们很多调式时间。</p></li></ul><h2 id="难点">难点</h2><p>原则 29：尝试新语言很容易，但要正确使用却很难。除非公司愿意组建一个十人团队并花一年的时间来学习，否则尽量不要这样做。如果你仍不死心，请阅读有关语言设计的五个问题后再做定夺。</p><p>原则 30：可组合的拖放 UI 很难实现，除非团队准备投入 10 人/年的资源，否则不要去做。</p><p>最后，谈一下我的感受。在理想情况下，一个平台应当由多个正交组件组成，每个组件负责一个方面（例如，安全性、消息传递、注册、调解、分析，等等）。使用这些功能构建的系统将是最佳的。</p><p>不幸的是，现实中我们很难达到这样的状态。因为在项目初始状态时，很多事情是不确定的，你无法做到这样的独立性，现在我认为在开始的时候适当的重复是必要的，当你尝试铲除他们的时候，你会发现引入了新的复杂性，分布本身就意味着复杂。有时候治愈的过程要比疾病本身更加的糟糕。</p><h2 id="总结">总结</h2><p>作为一个架构师，我们应该像园丁一样思考、塑造、策划和去除杂草而不是定义和构建。虽然在短期内，由一位架构师来制定架构的确既快捷又实惠。但是，从长远来看，团队的力量才是最强的。</p><p>如果你不够投入和细心，你只指出错误，但是不道明错误原因，那么你的意见可能会让团队感到困惑。避免这种情况的一种方法是拥有一套普遍接受的原则，这些原则是讨论架构时遵循的基本点，也是初学者学习架构的好资源。所以想成为一名优秀的架构师，还是需要长期的磨练以及时间的验证，当然随时保持学习的状态也是非常重要的。当你学会更多知识，你便会更清晰的解决各种复杂的架构问题。</p><blockquote><p>来源：HACKERNOON</p><p>原文：<a href="http://t.cn/AiHXMF44" target="_blank" rel="noopener">http://t.cn/AiHXMF44</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，架构师的角色，更偏向于策划、而非指挥，塑造、而非支配，其存在的意义，在于引导大家讨论、而非自己主宰一切。&lt;/p&gt;
&lt;p&gt;但是，具体应该如何执行呢？本文作者整理了 30 个公认的架构原则，来帮助大家解决此问题。也许有的原则，你从未听说，但你看完就能快速学会。&lt;/p&gt;
&lt;p&gt;相信你学会了，工作起来也会事半功倍，或许还可帮你避免很多无用的加班！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文作者叫 Srinath，是一位计算机科学家、软件架构师、作家。他是 Apache 的核心成员，拥有 15 年分布式系统编程经验，设计了 Apache Axis2 以及 WSO2 流处理器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 WSO2，我参与架构评审的时间已长达八年之久。WSO2 的产品非常丰富，比如 WSO2 ESB 、WSO2 API Manager  以及 WSO2 SP 都人尽皆知。在过去八年中，我们对许多产品和功能进行了讨论、设计、改进和重新设计。&lt;/p&gt;
&lt;p&gt;我们在设计软件的过程中，把握的一个关键点是：软件架构并非由架构师负责设计。我们的架构不是由架构师制定，然后交给其他人来实施。&lt;/p&gt;
&lt;p&gt;相反，架构的设计任务由真正编写代码的团队负责。架构师负责对工程师设计的架构进行修复、完善和改进。我们的架构团队是指导员和把关人，而非独裁者。&lt;/p&gt;
&lt;p&gt;在短期内，由一位架构师来制定架构的确既快捷又实惠。但是，从长远来看，我们会组建一个团队，让他们自己不断思考、改善架构，并从他们的错误中来提升自己。&lt;/p&gt;
&lt;p&gt;当我们专注于团队时，他们自然会随着时间的推移而变得更好。架构团队的首要任务是：尽可能保证架构容易执行。此外，架构评审也存在缺陷。&lt;/p&gt;
&lt;p&gt;就像 Paul （@pzfreo）描述的架构评审那样：架构师参与进来，听一会，发表一点评论然后就走了。作为一名架构师，你对架构发表自己的看法和意见无可厚非。但是，如果你不够投入和细心，你的意见可能会让团队感到困惑，团队就无法确定正确的做法到底是什么。&lt;/p&gt;
&lt;p&gt;接下来我会将 30 个架构原则一一列出，其中一些原则是众所周知的，而有些则源于我的个人经验和心血。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/15/CVRuDeBOyvcJM9G.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="分布式" scheme="https://www.hi-linux.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 反向代理使用教程</title>
    <link href="https://www.hi-linux.com/posts/5595.html"/>
    <id>https://www.hi-linux.com/posts/5595.html</id>
    <published>2020-05-24T01:07:00.000Z</published>
    <updated>2020-05-24T08:13:23.551Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>前段时间公司根据要求需要将聚石塔上服务器从杭州整体迁移到张家口，刚好趁这次机会将这些乱七八糟的服务器做一次梳理和整合。断断续续一个月迁移完成大概优化掉了 1/3 的机器，完成之后遇到了一些问题，比如：曾经零零散散部署在生产上一些可视化 UI：<code>Apollo</code>、<code>Kibana</code>、<code>Grafana</code>、<code>Jenkins</code> 等等服务，这些服务都采用了 <code>80</code> 或者其它公网端口进行对外暴露。为了安全，现在不再开放非 <code>80</code> 之外的公网端口。由于机器少了，<code>80</code> 端口不够，这些可视化 <code>UI</code> 不再能直接访问到了。所以需另寻其他出路。</p><h2 id="用-nginx-做反向代理">用 Nginx 做反向代理</h2><p>为了解决这两个问题，自然第一反应想到的就是使用反向代理，我的理想构思下应该是下图这样的。</p><p><img src="https://img2018.cnblogs.com/blog/214741/201911/214741-20191103230057336-52782006.jpg" alt=""></p><p>既用户所有的请求都经过 <code>Nginx</code>，让 <code>Nginx</code> 来判断当前 <code>URL</code> 需要跳转到哪一个后端代理上。比较好的策略应该是让 <code>Nginx</code> 来判断当前的 <code>Host</code> 是什么来决定跳转到哪一个后端的 <code>Webserver</code> 上，比如: <code>a.mip.com</code> 就跳转到 <code>Apollo</code>，<code>j.mip.com</code> 就跳转到 <code>Jenkins</code>。以此类推，这样就可以完美解决了。</p><a id="more"></a><h2 id="一个完整的演示实例">一个完整的演示实例</h2><p>为了实现上面的需求，在 <code>Nginx</code> 中你完全可以使用 <code>Rewrite</code> 模块下 <code>if</code> 指令来完成。由于 <code>Nginx</code> 默认带的模块比较少，如果需使用第三方模块，你可能还需要重新编译 <code>Nginx</code>。所以这里直接使用 <code>OpenResty</code>，它扩展了 <code>Nginx</code>，并且集成了很多成熟的 <code>LUA</code> 模块。可自行下载最新的 1.15.8 版本，其安装方式和 <code>Nginx</code> 一模一样。</p><blockquote><p>项目地址：<a href="https://openresty.org/en/download.html" target="_blank" rel="noopener">https://openresty.org/en/download.html</a></p></blockquote><p><img src="https://img2018.cnblogs.com/blog/214741/201911/214741-20191103230705182-358199087.jpg" alt=""></p><p><code>OpenResty</code> 默认是安装到 <code>/usr/local/</code> 目录下，当你看到有一个 <code>openresty</code> 目录就表示你安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># ls</span></span><br><span class="line">bin  etc  games  include  lib  lib64  libexec  openresty  sbin  share  src</span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>接下来你可以使用 <code>nginx  -v</code> 来验证下 <code>OpenResty</code> 版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/openresty/nginx/sbin</span><br><span class="line">[root@localhost sbin]<span class="comment"># </span></span><br><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -v</span></span><br><span class="line">nginx version: openresty/1.15.8.1</span><br></pre></td></tr></table></figure><p>为了演示方便，我就直接使用 <code>Nginx</code> 开启三个 Server。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.23.129:80    　 <span class="comment"># 在 80 端口上开启第一个网站，就是 Proxy 了。</span></span><br><span class="line">192.168.23.129:8001     <span class="comment"># 在 8001 端口上开启第二个网站，模拟 Apollo。</span></span><br><span class="line">192.168.23.129:8002     <span class="comment"># 在 8002 端口上开启第三个网站，模拟 Jenkins。</span></span><br></pre></td></tr></table></figure><p>首先，我们在 <code>Nginx</code> 中的配置好三个网站。</p><ol><li>Apollo 配置片断</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8001;</span><br><span class="line">        server_name  somename  alias  another.alias;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  apollo.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8001 端口网站的默认页是 <code>apollo.html</code>，这个 <code>apollo.html</code> 所在路径就是在 <code>Nginx</code> 目录下的 <code>html</code> 目录，如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost html]<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/openresty/nginx/html</span><br><span class="line">[root@localhost html]<span class="comment"># ls</span></span><br><span class="line">50x.html  apollo.html  index.html  jenkins.html</span><br></pre></td></tr></table></figure><ol start="2"><li>Jenkins 配置片断</li></ol><p><code>Jenkins.html</code> 的文件所在路径如下所示，不再赘述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8002;</span><br><span class="line">        server_name  somename  alias  another.alias;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  jenkins.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Proxy 配置片断</li></ol><p>我们可以看到，这里只需要使用 <code>Rewrite</code> 模块下的 <code>if</code> 条件语句。然后通过 <code>$host</code> 系统变量判断当前的 <code>URL</code> 中的 <code>host</code> 的值来实现跳转到相应的网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line"></span><br><span class="line">           if ($host &#x3D; &quot;a.mip.com&quot;) &#123;</span><br><span class="line">               proxy_pass http:&#x2F;&#x2F;localhost:8001;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if ($host &#x3D; &quot;j.mip.com&quot;) &#123;</span><br><span class="line">               proxy_pass http:&#x2F;&#x2F;localhost:8002;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们做好对应域名关系映射。这里为了演示方便，我们直接在 hosts 文件中进行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/hosts</span><br><span class="line">192.168.23.129 a.mip.com</span><br><span class="line">192.168.23.129 j.mip.com</span><br></pre></td></tr></table></figure><p>最后，启动 Nginx。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx </span></span><br><span class="line">[root@localhost sbin]<span class="comment"># </span></span><br><span class="line">[root@localhost sbin]<span class="comment"># </span></span><br><span class="line">[root@localhost sbin]<span class="comment"># netstat -tlnp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:8001            0.0.0.0:*               LISTEN      3802/nginx: master  </span><br><span class="line">tcp        0      0 0.0.0.0:8002            0.0.0.0:*               LISTEN      3802/nginx: master  </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      3802/nginx: master  </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1172/sshd           </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1724/master         </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1172/sshd           </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      1724/master</span><br></pre></td></tr></table></figure><p>通过上面输出看到，<code>80</code>、<code>8001</code>、<code>8002</code> 端口都已经开启了，接下来大家可以到浏览器去验证一下了。</p><p><img src="https://img2018.cnblogs.com/blog/214741/201911/214741-20191103232858709-1676878325.jpg" alt=""></p><p>从上图中，我们可以看到通过不同域名成功的访问到了不同的后端应用。以下是全部的 <code>Nginx</code> 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">$ cat nginx.conf</span><br><span class="line"></span><br><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$host ----&gt; $remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">    # location &#x3D; &#x2F;get &#123;</span><br><span class="line">        #     set_unescape_uri $key $arg_key;  # this requires ngx_set_misc</span><br><span class="line">        #     redis2_query get $key;</span><br><span class="line">        #     redis2_pass 10.105.13.174:6379;</span><br><span class="line">        # &#125;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">           </span><br><span class="line">           if ($host &#x3D; &quot;a.mip.com&quot;) &#123;</span><br><span class="line">               proxy_pass http:&#x2F;&#x2F;localhost:8001;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if ($host &#x3D; &quot;j.mip.com&quot;) &#123;</span><br><span class="line">               proxy_pass http:&#x2F;&#x2F;localhost:8002;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           root   html;</span><br><span class="line">           index  index.html index.htm;   </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8001;</span><br><span class="line">        server_name  somename  alias  another.alias;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  apollo.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8002;</span><br><span class="line">        server_name  somename  alias  another.alias;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  jenkins.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就演示完了一个反向代理实现多个不同类型的后端网站访问的场景，希望本篇文章对你有所帮助！</p><blockquote><p>来源：博客园</p><p>原文：<a href="https://url.cn/5iSfcUN" target="_blank" rel="noopener">https://url.cn/5iSfcUN</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间公司根据要求需要将聚石塔上服务器从杭州整体迁移到张家口，刚好趁这次机会将这些乱七八糟的服务器做一次梳理和整合。断断续续一个月迁移完成大概优化掉了 1/3 的机器，完成之后遇到了一些问题，比如：曾经零零散散部署在生产上一些可视化 UI：&lt;code&gt;Apollo&lt;/code&gt;、&lt;code&gt;Kibana&lt;/code&gt;、&lt;code&gt;Grafana&lt;/code&gt;、&lt;code&gt;Jenkins&lt;/code&gt; 等等服务，这些服务都采用了 &lt;code&gt;80&lt;/code&gt; 或者其它公网端口进行对外暴露。为了安全，现在不再开放非 &lt;code&gt;80&lt;/code&gt; 之外的公网端口。由于机器少了，&lt;code&gt;80&lt;/code&gt; 端口不够，这些可视化 &lt;code&gt;UI&lt;/code&gt; 不再能直接访问到了。所以需另寻其他出路。&lt;/p&gt;
&lt;h2 id=&quot;用-Nginx-做反向代理&quot;&gt;用 Nginx 做反向代理&lt;/h2&gt;
&lt;p&gt;为了解决这两个问题，自然第一反应想到的就是使用反向代理，我的理想构思下应该是下图这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/214741/201911/214741-20191103230057336-52782006.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;既用户所有的请求都经过 &lt;code&gt;Nginx&lt;/code&gt;，让 &lt;code&gt;Nginx&lt;/code&gt; 来判断当前 &lt;code&gt;URL&lt;/code&gt; 需要跳转到哪一个后端代理上。比较好的策略应该是让 &lt;code&gt;Nginx&lt;/code&gt; 来判断当前的 &lt;code&gt;Host&lt;/code&gt; 是什么来决定跳转到哪一个后端的 &lt;code&gt;Webserver&lt;/code&gt; 上，比如: &lt;code&gt;a.mip.com&lt;/code&gt; 就跳转到 &lt;code&gt;Apollo&lt;/code&gt;，&lt;code&gt;j.mip.com&lt;/code&gt; 就跳转到 &lt;code&gt;Jenkins&lt;/code&gt;。以此类推，这样就可以完美解决了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>别让自己的选择，限制了你的未来</title>
    <link href="https://www.hi-linux.com/posts/45902.html"/>
    <id>https://www.hi-linux.com/posts/45902.html</id>
    <published>2020-05-24T01:06:00.000Z</published>
    <updated>2020-05-24T08:13:23.549Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这一两周与几个朋友聊天，有年轻的90后，也有大叔级的70后，这些人在我看来都是很有能力的人，但是一些喜好过于强烈，让我不经意地回顾了我工作20年来身边的人，有发展得好的，也有发展的不好的，有些人是很可惜的，因为限制他们的不是其它人，也不是环境，而是自己，所以，很想写下这篇文章。（注：这篇文章可能会是一篇说教的文章，所以，可能会让你看着犯困，所以，我会尽量地短一些，而且尽可能多讲故事，少道理，这里的故事，全是真实发生的）</p><h2 id="几个故事">几个故事</h2><p>2019年年初，我面试了一个很年轻的小伙子（93/94年出生），这个小伙子特别有灵性，也很聪明，计算机专业出身，也很喜欢技术，基础和学习能力也很好。在我这20年来认识的人中，如果他能呆在北京、上海、深圳这样的城市，我保证不出三年，他会成为他们同龄人中非常出色的技术人员，如果有个好的舞台有一个好的团队带他，他的未来会非常成功。然而，这个小伙子有两大喜好：1）只愿（或是说被迫）呆在一个毫无IT的环境的三/四线城市，2）对技术有非常大的偏好，只喜欢Go语言，非常不喜欢其它的语言，比如：Java（离开Java的世界，基本上离开了做架构的世界）。</p><p>他的这两个喜好，足以让一个未来会很优秀的人毁掉，因为，这个时代没有限制他，他的能力也没有限制他，但是他的意识完完全全地限制了他。</p><ul><li><p>他把自己最宝贵的青春放在了很烂的项目上，就算能用一些新的技术，他也只能算是自娱自乐，在实验室中玩玩具罢了。</p></li><li><p>他把自己的技术栈封闭起来，而直接放弃了这个时代最具工业化的技术Java，对于一个好的程序员来说，同时掌握几门语言和技术完全是没什么问题，但是自己封闭了自己的视野。</p></li></ul><p>实在是非常可惜，我本来是可以为他介绍到一些很不错的公司的，但是他这样的习性，等于自己把自己未来的门给关上了，虽然我跟他长谈过，但是我也没有办法叫醒不想醒的人……</p><ul><li><p>视野、环境和舞台，对一个人的限制是非常大的。井蛙不知道大海，被空间维度所限制；夏虫不知道冬天，是被时间维度所限制；圈养的动物没有斗志，是被自己意识所限制。</p></li><li><p>偏见和不开放，对一个人的限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己的能力阉割掉，这是一件令人痛心的事。想想大清的闭关锁国是如何让亚洲第一的北洋水师给毁掉的……</p></li></ul><a id="more"></a><p>我还有个同学，他的技术并不差，就算呆在昆明这种很落后的地方，他也非常地好学，学习英文，学习各种新技术，对技术没有任何的偏好，喜欢C/C++/Java/Python/Shell，同样喜欢前端Javascript，对基础知识非常地踏实，他在技术上没有限制自己的潜力，有什么就学什么。后来，我带他玩Docker/Go/K8S……分布式架构，他也上手的很快……像他这样的人，技术能力完全没得说，比我还大一岁，44岁了，还是一样的天天追代码细节，看Youtube的各种大会，翻github里的各种issue和pull request……</p><p>我同学这人，拥有了成为一个技术牛人几乎所有的条件：基础知识过硬，细节扎得深，面很广，学习能力强，有英文能力，逻辑思维能力不错，非常的自律，执行力也很强，抓得住重点……然而，只有一个小问题，就是没有到大公司历练过，我三番五次叫他从昆明出来，但是最终他都呆在昆明这个城市没有出来，因为有所谓的家庭约束。然而，我身边还有好些人，把自己家从北京搬到上海，从上海搬到深圳，从厦门搬到深圳……这样的人大有人在……像他这样的能力，在哪个公司都会是主力和骨干，对于一个公司的主力和骨干来说，家庭上的这些问题都是小问题都是有很多解的……</p><p>另外，我这个同学还是一个比较悲观的人，任何事情都是先想到不好的事，他关注负面的东西会胜于正面的东西，而且他还有一定的社交恐惧，怕与人相处和交流，时间越长越害怕，甚至有时候直接跟我说，“我就是不想改变”这样的话……其实，我以前也是一个很害怕与人交流的人，面试的时候，我根本不敢正眼看面试官一眼，也不知道与人怎么交流。但是，我与他不一样，我努力克服，不断地面试，与人面对面的交流，到一线技术客服接用户的电话，在公司里做分享，慢慢地到外面分享……3-5年就完全克服掉了。</p><p>其实，很多事情，完全是有解的，也没有必要担心，自己的心理障碍也是可以克服的，重点就是自己愿不愿意，只要愿意完成了一半，接下来就是不断的摸爬滚打坚持了。</p><ul><li><p>不限制自己的人，会穷举各种方法来解决问题，限制自己的人，只会找各式各样的问题或借口。</p></li><li><p>不限制自己的人，会努力改变自己的问题和缺陷，限制自己的人，会放任自己。</p></li></ul><h2 id="另外几个故事">另外几个故事</h2><p>我还有另外几个故事（活到四十多，能看到好多人十几年的发展过程，感觉有点上帝视角了）</p><p>我还有一个以前团队里的一个小伙，人是很聪明，但就完全就是野路子，他对技术没有什么偏好，一个PHP程序员，做那个Discuz!论坛，公司被并购了，转成Java，开始研究Java的各种细节，对技术从来没有什么偏见，有什么就玩什么，每做一个项目，就算是一样的他都要用新的技术做一遍，然后跟着我做云计算，我教他TCP，教他C/C++，后来一起玩Docker/Go，等等，反正是一点就通，他是我见过学习能力最强的人。但是，有一个事他一直与我的想法不一样，就是我希望他先把软件设计好，再写代码，他非常不能理解，他习惯于直接动手开干，然后有什么问题就整什么问题，我也很难教育他。</p><p>有一天，他电话面了一下Facebook，电话面了15分钟后对方就放弃了，他受到了严重的打击。然后，他就开始找菲利宾人练英文口语了，我也让他做算法题，然后，他才发现，一道连算法都不是的纯编程题都提交几次都过不了，等他做完了Leetcode最初的那151道题后，整个人都改变了，写代码前认认真真地在纸上把程序的状态，处理时序以及可能遇到的一些条件先罗列出来，然后，进行逻辑设计后，再写，从此，他就开启他更大的天地了。我后来把他推荐给了微软，先在中国的Bing，在中国升好2-3级，然后去了美国的Azure，现在听说他准备要跟 k8s 的 co-founder Brendan Burns 混了（虽然，他现在还在印度人手下，但是，我真的不知道他未来能玩多大，因为今年他才33岁，而且非常聪明）</p><p>他以前是把自己封闭起来的，我叫他出来，他也不出来，后来因为一些办公室政治的原因不得不来找我，于是我就带着他玩了两年，跟他讲了很多外面的世界是怎么玩的，他这个人也是一个相当不善于社交的人，但是心是开放的，愿意接受新的东西，虽然对技术也有一定偏见，比如不喜欢Windows，但是也不会不喜欢到完全封闭。后来我跟他说，微软的技术相当的强的，你看到的技术只是表面，深层次的东西都是相通的，直到他到了微软后发现各种牛逼的东西，对微软系统的技术的态度也有了改变，而且我让他跟我说很多微软那边的事，我发现，他对技术了解的维度已经是越来越高级的了……</p><p>还是我以前团队的一个小伙，他是一个前端，他说前端的东西没什么意思，想来找我做后端，我也一点点带他……后来，我说，你如果想要玩得好，你必需来北京，无论现在你觉得过得有多好，你都要放弃掉，然后，尽最大可能出去经历一下世界最顶尖的公司，我甚至跟他说，如果他女朋友不跟来的话，就先分开一段时间，先自己立业，他来北京的时候，他之前的同事都等着看他的笑话，我说，那些人连想都不敢想，不必管他们。于是，他去了Amazon，再过了一年去了西雅图，我跟他说，接下来就是去AWS，然后，如果有足够的野心，用自己的年轻这个资本去硅谷创业公司赌一把……未来他怎么样我不知道，但至少他没有限制自己，他的未来不会有封顶……</p><p>也是我的同学，我跟他在大学是上下铺，后来他去了人民大学读计算机博士，大学的时候做国产数据库kingbase，然后去了一家外企，天天被派到用户那边做数据分析，后来，他想回科研单位做国产数据库，我说，别啊，你的技术比我好太多，还有博士理论加持，你不去国外顶尖公司玩玩，你不知道自己有多强的，于是他跟公司申请去了国外做核心，后来因为Hadoop的原因，公司的产品最终成为了历史，于是我说，你来了美国么，你一定要去AWS，于是他就去了AWS的Aurora团队，成为了AWS明星级产品的中坚力量，天天在改MySQL的核心源码，干了两年，被提升为Principal Software Engineer ……</p><p>这里我到不是说出国有多牛，也许你只关注能挣多少钱，但是我想说，他们之所以能有这样的际遇，除了他们本来就有实力，还更因为他们从来不给自己设制什么限制，就是那种“艺多不压身”，有什么就学什么，有更高的就去向更高的迈进，其它的像家庭什么的问题其实都是会有解的，真的不必担心太多……</p><h2 id="别限制了自己">别限制了自己</h2><p>上面的这些故事，也许你能看得懂，也许你看得不一定能懂，这里，让我来做个总结吧</p><ul><li><p>**做有价值的事。**这个世界对计算机人才的要求是供不应求的，所以，不要让自己为自己找各式各样的借口，让自己活在“玩玩具”、“搬砖”和“使蛮力加班”的境地。其实，我发现这世界上有能力的人并不少，但是有品味的人的确很少。<strong>所谓的有价值，就是，别人愿付高价的，高技术门槛的，有创造力的，有颠覆性的……</strong></p></li><li><p>**扩大自己的眼界，开放自己的内心。**人要变得开放，千万不要做一个狭隘的民族主义者，做一个开放的人，把目光放在全人类这个维度，不断地把自己融入到世界上，而不是把自己封闭起来，这里，<strong>你的英文语言能力对你能不能融入世界是起决定性的作用。</strong> 开放自己的心态，正视自己的缺点，你才可能往前迈进。<strong>你的视野决定了你的知不知道要去哪，你的开放决定了你想不想去。</strong></p></li><li><p><strong>站在更高的维度。</strong> 面的维度会超过点的维点，空间的维度会超过面的维度，在更高维度上思考和学习，你会获得更多。<strong>整天在焦虑那些低维度的事（比如自己的薪水、工作的地点、稳不稳定、有没有户口……），只会让你变得越来越平庸，只要你站在更高的维度（比如： 眼界有没有扩大、可能性是不是更多、竞争力是不是更强、能不能解决更大更难的问题、能创造多大的价值……），时间会让你明白那些低维度的东西全都不是事儿。</strong> 技术学习上也一样，站在学习编程语法特性的维度和站在学习编程范式、设计模式的维度是两种完全不一样的学习方式。</p></li><li><p><strong>精于计算得失。</strong> 很多人其实不是很懂计算。绝大多数人都是在算计自己会失去多少，而不会算会得到多少。而一般的人也总是在算短期内会失去什么，优秀则总是会算我投入后未来会有什么样的回报，前者在算计今天，目光短浅，而后者则是舍在今天，得在明天，计算的是未来。<strong>精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。</strong></p></li><li><p><strong>勇于跳出传统的束缚。</strong> 有时候，跳出传统并不是一件很容易的事，因为大多数人都会对未知有恐惧的心理。比如：我看到很多人才都被大公司垄断了，其实，有能力的人都不需要加入大公司，有能力的人是少数，这些少数的人应该是所有的公司share着用的，这样一来，对于所有的人都是利益最大化的。这样的事现在也有，比如：律师、设计师……。但是，绝大多数有能力的技术人员是不敢走出这步。我在2015年到2016年实践过一年半，有过这些实践，做“鸡”的比“二奶”好多了，收入也好很多很多（不好意思开车了）……</p></li></ul><p>庄子说过几句话——</p><blockquote><p>井蛙不可以语于海者，拘于虚也；//空间局限</p><p>夏虫不可以语于冰者，笃于时也；//时间局限</p><p>曲士不可以语于道者，束于教也。//认识局限</p></blockquote><p>别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想，共勉！</p><p><strong>注：这篇文章就是要劝大家更为开放，让自己有更多的可能性，能到更高的层次，做更有价值的事，成为更强更好的人……当然，如果你觉得你只想做一个平凡人，也和本文并不冲突……另外你也不要觉得这篇文章是让你要成为一个精英，但你一定要去摸高……这篇文章是告诉你一种面对人生的思考方式，在这种思考方式下，你会有更多的可能性，更大的场景……而不是直接把自己归到“平常人”，把自己“墙”了！</strong></p><blockquote><p>本文转载自：「酷壳」，原文：<a href="https://url.cn/5xBwefC%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5xBwefC，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一两周与几个朋友聊天，有年轻的90后，也有大叔级的70后，这些人在我看来都是很有能力的人，但是一些喜好过于强烈，让我不经意地回顾了我工作20年来身边的人，有发展得好的，也有发展的不好的，有些人是很可惜的，因为限制他们的不是其它人，也不是环境，而是自己，所以，很想写下这篇文章。（注：这篇文章可能会是一篇说教的文章，所以，可能会让你看着犯困，所以，我会尽量地短一些，而且尽可能多讲故事，少道理，这里的故事，全是真实发生的）&lt;/p&gt;
&lt;h2 id=&quot;几个故事&quot;&gt;几个故事&lt;/h2&gt;
&lt;p&gt;2019年年初，我面试了一个很年轻的小伙子（93/94年出生），这个小伙子特别有灵性，也很聪明，计算机专业出身，也很喜欢技术，基础和学习能力也很好。在我这20年来认识的人中，如果他能呆在北京、上海、深圳这样的城市，我保证不出三年，他会成为他们同龄人中非常出色的技术人员，如果有个好的舞台有一个好的团队带他，他的未来会非常成功。然而，这个小伙子有两大喜好：1）只愿（或是说被迫）呆在一个毫无IT的环境的三/四线城市，2）对技术有非常大的偏好，只喜欢Go语言，非常不喜欢其它的语言，比如：Java（离开Java的世界，基本上离开了做架构的世界）。&lt;/p&gt;
&lt;p&gt;他的这两个喜好，足以让一个未来会很优秀的人毁掉，因为，这个时代没有限制他，他的能力也没有限制他，但是他的意识完完全全地限制了他。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;他把自己最宝贵的青春放在了很烂的项目上，就算能用一些新的技术，他也只能算是自娱自乐，在实验室中玩玩具罢了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;他把自己的技术栈封闭起来，而直接放弃了这个时代最具工业化的技术Java，对于一个好的程序员来说，同时掌握几门语言和技术完全是没什么问题，但是自己封闭了自己的视野。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实在是非常可惜，我本来是可以为他介绍到一些很不错的公司的，但是他这样的习性，等于自己把自己未来的门给关上了，虽然我跟他长谈过，但是我也没有办法叫醒不想醒的人……&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;视野、环境和舞台，对一个人的限制是非常大的。井蛙不知道大海，被空间维度所限制；夏虫不知道冬天，是被时间维度所限制；圈养的动物没有斗志，是被自己意识所限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;偏见和不开放，对一个人的限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己的能力阉割掉，这是一件令人痛心的事。想想大清的闭关锁国是如何让亚洲第一的北洋水师给毁掉的……&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="思想" scheme="https://www.hi-linux.com/tags/%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Explain 使用指南</title>
    <link href="https://www.hi-linux.com/posts/5749.html"/>
    <id>https://www.hi-linux.com/posts/5749.html</id>
    <published>2020-05-24T01:05:00.000Z</published>
    <updated>2020-05-24T08:13:23.550Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>MySQL的 explain 命令语句提供了如何执行 SQL 语句的信息，解析 SQL 语句的执行计划并展示，explain 支持 select、delete、insert、replace 和 update 等语句，也支持对分区表的解析。通常 explain 用来获取 select 语句的执行计划，通过 explain 展示的信息我们可以了解到表查询的顺序，表连接的方式等，并根据这些信息判断 select 执行效率，决定是否添加索引或改写 SQL 语句优化表连接方式以提高执行效率。本文参考官方文档：EXPLAIN Output Format 对 explain 输出的内容进行说明，同时也对自己之前使用 explain 不清晰的方面进行总结。</p><p>本文使用的 MySQL 版本为官方社区版 5.7.24。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:(none)&gt; select version();</span><br><span class="line">+------------+</span><br><span class="line">| version()  |</span><br><span class="line">+------------+</span><br><span class="line">| 5.7.24-log |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.066s</span><br></pre></td></tr></table></figure><h2 id="主要用法">主要用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; EXPLAIN | DESCRIBE &#125; [EXTENDED | PARTITIONS | FORMAT&#x3D;[TRADITIONAL | JSON]] SQL_STATEMENT;</span><br></pre></td></tr></table></figure><ol><li><p>EXPLAIN 和 DESCRIBE(可以简写成 DESC)都可以用来查看语句的执行计划，但通常使用 EXPLAIN 较多；</p></li><li><p>FORMAT 选项可以指定执行计划输出信息为 JSON 格式，而且包含一些更详细的指标说明；</p></li><li><p>EXTENDED 和 PARTITIONS 选项可以输出更详细选项说明，语法上是为了兼容低版本 MySQL，未来会废弃，默认使用 EXPLAIN 命令即可。</p></li></ol><h2 id="测试数据">测试数据</h2><p>本文基于 MySQL 官方示例数据库 employee：Example Databases 进行解析说明，使用到的表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">-- employees：</span><br><span class="line">mysql root@localhost:employees&gt; show create table employees\G;</span><br><span class="line">***************************[ 1. row ]***************************</span><br><span class="line">Table        | employees</span><br><span class="line">Create Table | CREATE TABLE &#96;employees&#96; (</span><br><span class="line">  &#96;emp_no&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;birth_date&#96; date NOT NULL,</span><br><span class="line">  &#96;first_name&#96; varchar(14) NOT NULL,</span><br><span class="line">  &#96;last_name&#96; varchar(16) NOT NULL,</span><br><span class="line">  &#96;gender&#96; enum(&#39;M&#39;,&#39;F&#39;) NOT NULL,</span><br><span class="line">  &#96;hire_date&#96; date NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;emp_no&#96;),</span><br><span class="line">  KEY &#96;idx_first_last&#96; (&#96;first_name&#96;,&#96;last_name&#96;),</span><br><span class="line">  KEY &#96;idx_birth_hire&#96; (&#96;birth_date&#96;,&#96;hire_date&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.008s</span><br><span class="line"></span><br><span class="line">-- dept_emp：</span><br><span class="line">mysql root@localhost:employees&gt; show create table dept_emp\G;</span><br><span class="line">***************************[ 1. row ]***************************</span><br><span class="line">Table        | dept_emp</span><br><span class="line">Create Table | CREATE TABLE &#96;dept_emp&#96; (</span><br><span class="line">  &#96;emp_no&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;dept_no&#96; char(4) NOT NULL,</span><br><span class="line">  &#96;from_date&#96; date NOT NULL,</span><br><span class="line">  &#96;to_date&#96; date NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;emp_no&#96;,&#96;dept_no&#96;),</span><br><span class="line">  KEY &#96;dept_no&#96; (&#96;dept_no&#96;),</span><br><span class="line">  CONSTRAINT &#96;dept_emp_ibfk_1&#96; FOREIGN KEY (&#96;emp_no&#96;) REFERENCES &#96;employees&#96; (&#96;emp_no&#96;) ON DELETE CASCADE,</span><br><span class="line">  CONSTRAINT &#96;dept_emp_ibfk_2&#96; FOREIGN KEY (&#96;dept_no&#96;) REFERENCES &#96;departments&#96; (&#96;dept_no&#96;) ON DELETE CASCADE</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.010s</span><br><span class="line"></span><br><span class="line">-- departments：</span><br><span class="line">mysql root@localhost:employees&gt; show create table departments\G;</span><br><span class="line">***************************[ 1. row ]***************************</span><br><span class="line">Table        | departments</span><br><span class="line">Create Table | CREATE TABLE &#96;departments&#96; (</span><br><span class="line">  &#96;dept_no&#96; char(4) NOT NULL,</span><br><span class="line">  &#96;dept_name&#96; varchar(40) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;dept_no&#96;),</span><br><span class="line">  UNIQUE KEY &#96;dept_name&#96; (&#96;dept_name&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.012s</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="输出说明">输出说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select count(*) from employees;</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+--------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref    | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+--------+--------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | index | &lt;null&gt;        | PRIMARY | 4       | &lt;null&gt; | 299512 | 100.0    | Using index |</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+--------+--------+----------+-------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.026s</span><br></pre></td></tr></table></figure><p>通过以上示例语句得出 explain 输出有 12 个字段，主要说明如下表：</p><p><img src="https://i.loli.net/2019/09/25/Lp2vShJgtlMEqK6.png" alt=""></p><h3 id="id">id</h3><p>id 为 select 标识符，语句在执行计划当中的执行顺序。id 值的出现有如下几种情况：</p><ol><li><p>id 值全相同，则按由上到下顺序执行；</p></li><li><p>id 值全不相同，则按 id 值大小，由大到小顺序执行；</p></li><li><p>id 值部分相同，部分不相同，则同组 id 值大的优先执行(组内 id 值相同的顺序执行)。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">-- id 全相同</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from employees e,dept_emp d,departments de where e.emp_no &#x3D; d.emp_no and de.dept_name &#x3D; &#39;Human</span><br><span class="line">                                Resources&#39;;</span><br><span class="line"></span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+--------------------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref                | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+--------------------+--------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | de    | &lt;null&gt;     | const | dept_name     | dept_name | 122     | const              | 1      | 100.0    | Using index |</span><br><span class="line">| 1  | SIMPLE      | e     | &lt;null&gt;     | ALL   | PRIMARY       | &lt;null&gt;    | &lt;null&gt;  | &lt;null&gt;             | 299512 | 100.0    | &lt;null&gt;      |</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | ref   | PRIMARY       | PRIMARY   | 4       | employees.e.emp_no | 1      | 100.0    | &lt;null&gt;      |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+--------------------+--------+----------+-------------+</span><br><span class="line">3 rows in set</span><br><span class="line">Time: 0.018s</span><br><span class="line"></span><br><span class="line">-- id 全不相同</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from employees e where e.emp_no &#x3D; (select d.emp_no from dept_emp d where d.dept_no &#x3D; (select de.d</span><br><span class="line">                                ept_no from departments de where de.dept_name &#x3D; &#39;Development&#39;) and d.emp_no &#x3D; 10023);</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+-----------+---------+-------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys   | key       | key_len | ref         | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+-----------+---------+-------------+------+----------+-------------+</span><br><span class="line">| 1  | PRIMARY     | e     | &lt;null&gt;     | const | PRIMARY         | PRIMARY   | 4       | const       | 1    | 100.0    | &lt;null&gt;      |</span><br><span class="line">| 2  | SUBQUERY    | d     | &lt;null&gt;     | const | PRIMARY,dept_no | PRIMARY   | 16      | const,const | 1    | 100.0    | Using index |</span><br><span class="line">| 3  | SUBQUERY    | de    | &lt;null&gt;     | const | dept_name       | dept_name | 122     | const       | 1    | 100.0    | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+-----------+---------+-------------+------+----------+-------------+</span><br><span class="line">3 rows in set</span><br><span class="line">Time: 0.027s</span><br><span class="line"></span><br><span class="line">-- id 部分相同，部分不相同</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from^Iemployees e where^Ie.emp_no in (select d.emp_no from dept_emp d where d.dept_no &#x3D; (select d</span><br><span class="line">                                e.dept_no from departments de where de.dept_name &#x3D; &#39;Human Resources&#39;));</span><br><span class="line">+----+-------------+-------+------------+--------+-----------------+-----------+---------+--------------------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys   | key       | key_len | ref                | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+--------+-----------------+-----------+---------+--------------------+-------+----------+-------------+</span><br><span class="line">| 1  | PRIMARY     | d     | &lt;null&gt;     | ref    | PRIMARY,dept_no | dept_no   | 12      | const              | 33212 | 100.0    | Using index |</span><br><span class="line">| 1  | PRIMARY     | e     | &lt;null&gt;     | eq_ref | PRIMARY         | PRIMARY   | 4       | employees.d.emp_no | 1     | 100.0    | &lt;null&gt;      |</span><br><span class="line">| 3  | SUBQUERY    | de    | &lt;null&gt;     | const  | dept_name       | dept_name | 122     | const              | 1     | 100.0    | Using index |</span><br><span class="line">+----+-------------+-------+------------+--------+-----------------+-----------+---------+--------------------+-------+----------+-------------+</span><br><span class="line">3 rows in set</span><br><span class="line">Time: 0.020s</span><br></pre></td></tr></table></figure><h3 id="select_type">select_type</h3><p>select_type 为表查询的类型，根据官方文档总结几种常见类型如下表：</p><p><img src="https://i.loli.net/2019/09/25/zWs5YpGgiMQmtvB.png" alt=""></p><ol><li>SIMPLE：最常见的查询类型，通常情况下没有子查询、union 查询就是 SIMPLE 类型。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees where emp_no &#x3D; 10001;</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | const | PRIMARY       | PRIMARY | 4       | const | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.019s</span><br></pre></td></tr></table></figure><ol start="2"><li>PRIMARY 和 SUBQUERY：在含有子查询的语句中会出现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from dept_emp d where d.dept_no &#x3D; (select de.dept_no from departments de where de.dept_name &#x3D; &#39;De</span><br><span class="line">                                velopment&#39;);</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref   | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+--------+----------+-------------+</span><br><span class="line">| 1  | PRIMARY     | d     | &lt;null&gt;     | ref   | dept_no       | dept_no   | 12      | const | 148054 | 100.0    | Using where |</span><br><span class="line">| 2  | SUBQUERY    | de    | &lt;null&gt;     | const | dept_name     | dept_name | 122     | const | 1      | 100.0    | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+--------+----------+-------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.021s</span><br></pre></td></tr></table></figure><ol start="3"><li>UNION 和 UNION RESULT：在有 union 查询的语句中出现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from departments where dept_no &#x3D; &#39;d005&#39; union select * from departments where dept_no &#x3D; &#39;d004&#39;;</span><br><span class="line">+--------+--------------+-------------+------------+-------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">| id     | select_type  | table       | partitions | type  | possible_keys | key     | key_len | ref    | rows   | filtered | Extra           |</span><br><span class="line">+--------+--------------+-------------+------------+-------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">| 1      | PRIMARY      | departments | &lt;null&gt;     | const | PRIMARY       | PRIMARY | 12      | const  | 1      | 100.0    | &lt;null&gt;          |</span><br><span class="line">| 2      | UNION        | departments | &lt;null&gt;     | const | PRIMARY       | PRIMARY | 12      | const  | 1      | 100.0    | &lt;null&gt;          |</span><br><span class="line">| &lt;null&gt; | UNION RESULT | &lt;union1,2&gt;  | &lt;null&gt;     | ALL   | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt; | &lt;null&gt; | &lt;null&gt;   | Using temporary |</span><br><span class="line">+--------+--------------+-------------+------------+-------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">3 rows in set</span><br><span class="line">Time: 0.020s</span><br></pre></td></tr></table></figure><ol start="4"><li>DEPENDENT UNION 和 DEPENDENT SUBQUERY：当语句中子查询和 union 查询依赖外部查询会出现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees e where e.emp_no in (select d.emp_no from dept_emp d where d.from_date &#x3D; &#39;1986-06-</span><br><span class="line">                                26&#39; union select d.emp_no from dept_emp d where d.from_date &#x3D; &#39;1996-08-03&#39;);</span><br><span class="line">+--------+--------------------+------------+------------+------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">| id     | select_type        | table      | partitions | type | possible_keys | key     | key_len | ref    | rows   | filtered | Extra          |</span><br><span class="line">+--------+--------------------+------------+------------+------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">| 1      | PRIMARY            | e          | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt; | 299512 | 100.0    | Using where    |</span><br><span class="line">| 2      | DEPENDENT SUBQUERY | d          | &lt;null&gt;     | ref  | PRIMARY       | PRIMARY | 4       | func   | 1      |  10.0    | Using where    |</span><br><span class="line">| 3      | DEPENDENT UNION    | d          | &lt;null&gt;     | ref  | PRIMARY       | PRIMARY | 4       | func   | 1      |  10.0    | Using where    |</span><br><span class="line">| &lt;null&gt; | UNION RESULT       | &lt;union2,3&gt; | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt; | &lt;null&gt; | &lt;null&gt;   | Using temporary|</span><br><span class="line">+--------+--------------------+------------+------------+------+---------------+---------+---------+--------+--------+----------+-----------------+</span><br><span class="line">4 rows in set</span><br><span class="line">Time: 0.022s</span><br></pre></td></tr></table></figure><ol start="5"><li>DERIVED：当查询涉及生成临时表时出现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from (select * from departments limit 5) de;</span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+-----------+---------+--------+------+----------+-------------+</span><br><span class="line">| id | select_type | table       | partitions | type  | possible_keys | key       | key_len | ref    | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+-----------+---------+--------+------+----------+-------------+</span><br><span class="line">| 1  | PRIMARY     | &lt;derived2&gt;  | &lt;null&gt;     | ALL   | &lt;null&gt;        | &lt;null&gt;    | &lt;null&gt;  | &lt;null&gt; | 5    | 100.0    | &lt;null&gt;      |</span><br><span class="line">| 2  | DERIVED     | departments | &lt;null&gt;     | index | &lt;null&gt;        | dept_name | 122     | &lt;null&gt; | 9    | 100.0    | Using index |</span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+-----------+---------+--------+------+----------+-------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.012s</span><br></pre></td></tr></table></figure><ol start="6"><li>table</li></ol><p>指执行计划当中当前是从哪张表获取数据，如果为表指定了别名，则显示别名，如果没有涉及对表的数据读取，则显示 NULL，还有如下几种情形：</p><ul><li><p>&lt;unionM,N&gt;：数据来自union查询的id为M和N的结果集；</p></li><li><p>：数据来自派生表id为N的结果集；</p></li><li><p>：数据来自子查询id为N的结果集。</p></li></ul><ol start="7"><li>partitions</li></ol><p>指执行计划中当前从分区表哪个表分区获取数据，如果不是分区表，则显示为 NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-- 示例数据库 employees 的分区表 salaries</span><br><span class="line">mysql root@localhost:employees&gt; show create table salaries;</span><br><span class="line">+----------+-----------------------------------------------------------------+</span><br><span class="line">| Table    | Create Table                                                    |</span><br><span class="line">+----------+-----------------------------------------------------------------+</span><br><span class="line">| salaries | CREATE TABLE &#96;salaries&#96; (                                       |</span><br><span class="line">|          |   &#96;emp_no&#96; int(11) NOT NULL,                                    |</span><br><span class="line">|          |   &#96;salary&#96; int(11) NOT NULL,                                    |</span><br><span class="line">|          |   &#96;from_date&#96; date NOT NULL,                                    |</span><br><span class="line">|          |   &#96;to_date&#96; date NOT NULL,                                      |</span><br><span class="line">|          |   PRIMARY KEY (&#96;emp_no&#96;,&#96;from_date&#96;)                            |</span><br><span class="line">|          | ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8                            |</span><br><span class="line">|          | &#x2F;*!50500 PARTITION BY RANGE  COLUMNS(from_date)                 |</span><br><span class="line">|          | (PARTITION p01 VALUES LESS THAN (&#39;1985-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p02 VALUES LESS THAN (&#39;1986-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p03 VALUES LESS THAN (&#39;1987-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p04 VALUES LESS THAN (&#39;1988-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p05 VALUES LESS THAN (&#39;1989-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p06 VALUES LESS THAN (&#39;1990-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p07 VALUES LESS THAN (&#39;1991-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p08 VALUES LESS THAN (&#39;1992-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p09 VALUES LESS THAN (&#39;1993-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p10 VALUES LESS THAN (&#39;1994-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p11 VALUES LESS THAN (&#39;1995-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p12 VALUES LESS THAN (&#39;1996-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p13 VALUES LESS THAN (&#39;1997-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p14 VALUES LESS THAN (&#39;1998-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p15 VALUES LESS THAN (&#39;1999-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p16 VALUES LESS THAN (&#39;2000-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p17 VALUES LESS THAN (&#39;2001-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p18 VALUES LESS THAN (&#39;2002-12-31&#39;) ENGINE &#x3D; InnoDB, |</span><br><span class="line">|          |  PARTITION p19 VALUES LESS THAN (MAXVALUE) ENGINE &#x3D; InnoDB) *&#x2F;  |</span><br><span class="line">+----------+-----------------------------------------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.018s</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; explain select * from salaries where from_date &gt; &#39;1985-12-31&#39; and from_date &lt; &#39;1990-12-31&#39;;</span><br><span class="line">+----+-------------+----------+---------------------+------+---------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table    | partitions          | type | possible_keys | key    | key_len | ref    | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+----------+---------------------+------+---------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | salaries | p02,p03,p04,p05,p06 | ALL  | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 384341 | 11.11    | Using where |</span><br><span class="line">+----+-------------+----------+---------------------+------+---------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.023s</span><br></pre></td></tr></table></figure><h3 id="type">type</h3><p>type 应该被认为是解读执行计划当中最重要的部分，根据 type 显示的内容可以判断语句总体的查询效率。主要有以下几种类型：</p><ol><li>system：表只有一行(系统表)，是 const 的一种特殊情况。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">-- 测试表 departments_1 生成：</span><br><span class="line">mysql root@localhost:employees&gt; create table departments_1 as select * from departments where dept_no&#x3D;&#39;d005&#39;;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Time: 0.107s </span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; alter table departments_1 add primary key(dept_no);</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; create index idx_dept_name on departments_1(dept_name);</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; show create table departments_1\G;</span><br><span class="line">***************************[ 1. row ]***************************</span><br><span class="line">Table        | departments_1</span><br><span class="line">Create Table | CREATE TABLE &#96;departments_1&#96; (</span><br><span class="line">  &#96;dept_no&#96; char(4) NOT NULL,</span><br><span class="line">  &#96;dept_name&#96; varchar(40) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;dept_no&#96;),</span><br><span class="line">  KEY &#96;idx_dept_name&#96; (&#96;dept_name&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.010s</span><br><span class="line"></span><br><span class="line">-- 系统表：</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from mysql.proxies_priv;</span><br><span class="line">+----+-------------+--------------+------------+--------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">| id | select_type | table        | partitions | type   | possible_keys | key    | key_len | ref    | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+--------------+------------+--------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | proxies_priv | &lt;null&gt;     | system | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+--------------+------------+--------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.023s</span><br><span class="line"></span><br><span class="line">-- 普通表：</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from (select * from departments_1 where dept_no &#x3D; &#39;d005&#39; limit 1) de;</span><br><span class="line">+----+-------------+---------------+------------+--------+---------------+---------+---------+--------+------+----------+--------+</span><br><span class="line">| id | select_type | table         | partitions | type   | possible_keys | key     | key_len | ref    | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+---------------+------------+--------+---------------+---------+---------+--------+------+----------+--------+</span><br><span class="line">| 1  | PRIMARY     | &lt;derived2&gt;    | &lt;null&gt;     | system | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt; | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">| 2  | DERIVED     | departments_1 | &lt;null&gt;     | const  | PRIMARY       | PRIMARY | 12      | const  | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+---------------+------------+--------+---------------+---------+---------+--------+------+----------+--------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.015s</span><br></pre></td></tr></table></figure><ol start="2"><li>const：对于主键或者唯一索引键的等值查询，只返回一行数据。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from departments_1 where dept_no &#x3D; &#39;d005&#39;;</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | departments_1 | &lt;null&gt;     | const | PRIMARY       | PRIMARY | 12      | const | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+--------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.018s</span><br></pre></td></tr></table></figure><ol start="3"><li>eq_ref：对于前表的每一行数据，都只能匹配当前表唯一一行数据。除了 system 与 const 之外这是最好的一种连接查询类型，主键或者是非空唯一索引的所有部分都可以在连接时被使用，通常使用的是’='操作符，比较值可以是一个常量，也可以是一个在该表之前读取该表的字段表达式。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">explain select * from departments d,departments_1 d1 where d.dept_no &#x3D; d1.dept_no;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------------+---------+----------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key           | key_len | ref                  | rows | filtered | Extra      |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------------+---------+----------------------+------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | d1    | &lt;null&gt;     | index  | PRIMARY       | idx_dept_name | 123     | &lt;null&gt;               | 1    | 100.0    | Using index|</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | eq_ref | PRIMARY       | PRIMARY       | 12      | employees.d1.dept_no | 1    | 100.0    | &lt;null&gt;     |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------------+---------+----------------------+------+----------+-------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.037s</span><br></pre></td></tr></table></figure><ol start="4"><li>ref：对于前表的每一行数据，都从当前表读取所有匹配索引值的行。与 eq_ref 相比，连接查询字段不是主键或者唯一索引，又或者是复合索引的部分左前缀，如果连接查询匹配的是少量几行数据，ref 是个不同错的选择，通常使用的运算符是’=’、’&lt;=‘或者’&gt;='等。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from dept_emp where dept_no &#x3D;&#39;d005&#39;;</span><br><span class="line">+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+--------+</span><br><span class="line">| id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra  |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | dept_emp | &lt;null&gt;     | ref  | dept_no       | dept_no | 12      | const | 148054 | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+--------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.059s</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; explain select * from dept_emp d,departments_1 d1 where d.dept_no &#x3D; d1.dept_no;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+----------------------+-------+----------+--------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref                  | rows  | filtered | Extra  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+----------------------+-------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | d1    | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt;               | 1     | 100.0    | &lt;null&gt; |</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | ref  | dept_no       | dept_no | 12      | employees.d1.dept_no | 41392 | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+----------------------+-------+----------+--------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.012s</span><br></pre></td></tr></table></figure><ol start="5"><li>ref_or_null：同ref类型，但是包含了对NULL值的搜索。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select dept_name from departments_1 where dept_name &#x3D; &#39;d005&#39; or dept_name is null;</span><br><span class="line">+----+-------------+---------------+------------+-------------+---------------+---------------+---------+-------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table         | partitions | type        | possible_keys | key           | key_len | ref   | rows | filtered | Extra                   |</span><br><span class="line">+----+-------------+---------------+------------+-------------+---------------+---------------+---------+-------+------+----------+--------------------------+</span><br><span class="line">| 1  | SIMPLE      | departments_1 | &lt;null&gt;     | ref_or_null | idx_dept_name | idx_dept_name | 123     | const | 2    | 100.0    | Using where; Using index |</span><br><span class="line">+----+-------------+---------------+------------+-------------+---------------+---------------+---------+-------+------+----------+--------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.011s</span><br></pre></td></tr></table></figure><ol start="6"><li>index_merge：使用了索引合并优化进行查询。如果查询指定条件涉及对多个索引的使用时，会将多个索引合并操作。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from dept_emp where emp_no &#x3D; 10001 or dept_no &#x3D; (select dept_no from departments_1);</span><br><span class="line">+----+-------------+---------------+------------+-------------+-----------------+-----------------+---------+--------+--------+----------+-------------------------------------------+</span><br><span class="line">| id | select_type | table         | partitions | type        | possible_keys   | key             | key_len | ref    | rows   | filtered | Extra                                    |</span><br><span class="line">+----+-------------+---------------+------------+-------------+-----------------+-----------------+---------+--------+--------+----------+-------------------------------------------+</span><br><span class="line">| 1  | PRIMARY     | dept_emp      | &lt;null&gt;     | index_merge | PRIMARY,dept_no | PRIMARY,dept_no | 4,12    | &lt;null&gt; | 148055 | 100.0    | Using union(PRIMARY,dept_no); Using where |</span><br><span class="line">| 2  | SUBQUERY    | departments_1 | &lt;null&gt;     | index       | &lt;null&gt;          | idx_dept_name   | 123     | &lt;null&gt; | 1      | 100.0    | Using index                               |</span><br><span class="line">+----+-------------+---------------+------------+-------------+-----------------+-----------------+---------+--------+--------+----------+-------------------------------------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.014s</span><br></pre></td></tr></table></figure><ol start="7"><li>range：使用索引扫描条件指定范围内的数据。常用的操作符有 ‘&gt;’、’&lt;’、‘is null’、‘between’、‘in’ 和 ‘like’ 等。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select de.* from dept_emp de,departments_1 d where de.dept_no &#x3D; d.dept_no and de.emp_no &lt; 10010;</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+---------------+---------+--------+------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys   | key           | key_len | ref    | rows | filtered | Extra                                             |</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+---------------+---------+--------+------+----------+----------------------------------------------------+</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | index | PRIMARY         | idx_dept_name | 123     | &lt;null&gt; | 1    | 100.0    | Using index                                       |</span><br><span class="line">| 1  | SIMPLE      | de    | &lt;null&gt;     | range | PRIMARY,dept_no | PRIMARY       | 4       | &lt;null&gt; | 9    |  12.5    | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+-------+-----------------+---------------+---------+--------+------+----------+----------------------------------------------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.019s</span><br></pre></td></tr></table></figure><ol start="8"><li>index：使用索引全扫描。类似于全表扫描，只是扫描对象是索引，出现于以下两种情况：</li></ol><ul><li><p>如果索引是覆盖索引，即索引包含查询所需要的所有表数据，就只扫描索引，并且在 Extra 中出现 Using index。通常情况下扫描索引比打描表要更快，因为索引一般比表来的小；</p></li><li><p>全表扫描采用索引的顺序来读取数据，本质上还是全表扫描，并且在 Extra 中不会出现 Using index，避免再进行排序消耗性能，因为索引本身就是排序好的。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select dept_name from departments_1;</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">| id | select_type | table         | partitions | type  | possible_keys | key           | key_len | ref    | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | departments_1 | &lt;null&gt;     | index | &lt;null&gt;        | idx_dept_name | 123     | &lt;null&gt; | 1    | 100.0    | Using index |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.020s</span><br></pre></td></tr></table></figure><ol start="9"><li>all：使用全表扫描。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; drop index idx_dept_name on departments_1;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.052s</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; explain select * from departments_1;</span><br><span class="line">+----+-------------+---------------+------------+------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">| id | select_type | table         | partitions | type | possible_keys | key    | key_len | ref    | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+---------------+------------+------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | departments_1 | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+---------------+------------+------+---------------+--------+---------+--------+------+----------+--------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.018s</span><br></pre></td></tr></table></figure><p>通过以上各种主要类型的分析，可以总结出各个类型性能排序(从左到右性能从高到低)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</span><br></pre></td></tr></table></figure><h3 id="possible_keys">possible_keys</h3><p>显示了 MySQL 在查找当前表中数据的时候可能使用到的索引，如果该字段值为 NULL，则表明没有相关索引可用。</p><h3 id="key">key</h3><p>显示了 MySQL 在实际查找数据时决定使用的索引，如果该字段值为 NULL，则表明没有使用索引。</p><h3 id="key_len">key_len</h3><p>显示了 MySQL 实际使用索引的键大小，单位字节。可以通过 key_len 的大小判断评估复合索引使用了哪些部分，如果 key 字段值为 NULL，则 key_len 的值也为 NULL。</p><p>几种常见字段类型索引长度大小如下，假设字符编码为 UTF8：</p><ul><li><p>字段属性是否允许 NULL，如果允许 NULL，则需要额外增加一个字节；</p></li><li><p>字符型：</p><ul><li>char(n)：3n个字节</li><li>varchar(n)：3n+2个字节</li></ul></li><li><p>数值型：</p><ul><li>tinyint：1 个字节</li><li>int：4 个字节</li><li>bigint：8 个字节</li></ul></li><li><p>时间型：</p><ul><li>date：3 个字节</li><li>datetime：5 个字节+秒精度字节</li><li>timestamp：4 个字节+秒精度字节</li><li>秒精度字节(最大 6 位)：<ul><li>1~2位：1 个字节</li><li>3~4位：2 个字节</li><li>5~6位：3 个字节</li></ul></li></ul></li></ul><h3 id="ref">ref</h3><p>显示哪些常量或者字段被用于查询索引列键值，以获取表中数据行。</p><ol><li><p>如果是常量等值查询，则显示为 const；</p></li><li><p>如果是连接查询，则被驱动表的该字段会显示驱动表的所关联字段；</p></li><li><p>如果条件当中使用函数表达式，或者值导致条件字段发生隐式转换，这里显示为 func。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from departments d,departments_1 d1 where d.dept_no &#x3D; d1.dept_no;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+--------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                  | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+--------+</span><br><span class="line">| 1  | SIMPLE      | d1    | &lt;null&gt;     | ALL    | PRIMARY       | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt;               | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | eq_ref | PRIMARY       | PRIMARY | 12      | employees.d1.dept_no | 1    | 100.0    | &lt;null&gt; |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+--------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.038s</span><br></pre></td></tr></table></figure><h3 id="rows">rows</h3><p>显示预估需要查询的行数。对 InnoDB 表来说这是个预估值，并非是个准确值。</p><h3 id="filtered">filtered</h3><p>显示按表条件过滤的表行的估计百分比。</p><h3 id="extra">Extra</h3><p>显示查询时的额外信息。常见的有如下几种：</p><ol><li>Using index</li></ol><p>仅查询索引树就可以获取到所需要的数据行，而不需要读取表中实际的数据行。通常适用于 select 字段就是查询使用索引的一部分，即使用了覆盖索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select dept_name from departments_1;</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">| id | select_type | table         | partitions | type  | possible_keys | key           | key_len | ref    | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | departments_1 | &lt;null&gt;     | index | &lt;null&gt;        | idx_dept_name | 123     | &lt;null&gt; | 1    | 100.0    | Using index |</span><br><span class="line">+----+-------------+---------------+------------+-------+---------------+---------------+---------+--------+------+----------+-------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.015s</span><br></pre></td></tr></table></figure><ol start="2"><li>Using index condition</li></ol><p>显示采用了Index Condition Pushdown (ICP) 特性通过索引去表中获取数据。关于ICP特性可以参考官方文档：Index Condition Pushdown Optimization。简单说法如下：</p><ul><li><p>如果开启 ICP 特性，部分 where 条件部分可以下推到存储引擎通过索引进行过滤，ICP 可以减少存储引擎访问基表的次数；</p></li><li><p>如果没有开启 ICP 特性，则存储引擎根据索引需要直接访问基表获取数据并返回给 server 层进行 where 条件的过滤。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- employees表创建复合索引idx_birth_hire</span><br><span class="line">mysql root@localhost:employees&gt; create index idx_birth_hire on employees(birth_date,hire_date);</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.768s</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; explain select * from employees where birth_date &#x3D; &#39;1960-01-01&#39; and hire_date &gt; &#39;1980-01-01&#39;;</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table     | partitions | type  | possible_keys  | key            | key_len | ref    | rows | filtered | Extra                |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+-----------------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | range | idx_birth_hire | idx_birth_hire | 6       | &lt;null&gt; | 63   | 100.0    | Using index condition |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+-----------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.016s</span><br></pre></td></tr></table></figure><ol start="3"><li>Using index for group-by</li></ol><p>跟 Using index 访问表的方式类似，显示 MySQL 通过索引就可以完成对 GROUP BY 或 DISTINCT 字段的查询，而无需再访问表中的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select distinct dept_no from dept_emp;</span><br><span class="line">+----+-------------+----------+------------+-------+-----------------+---------+---------+--------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys   | key     | key_len | ref    | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+----------+------------+-------+-----------------+---------+---------+--------+------+----------+--------------------------+</span><br><span class="line">| 1  | SIMPLE      | dept_emp | &lt;null&gt;     | range | PRIMARY,dept_no | dept_no | 12      | &lt;null&gt; | 9    | 100.0    | Using index for group-by |</span><br><span class="line">+----+-------------+----------+------------+-------+-----------------+---------+---------+--------+------+----------+--------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.020s</span><br></pre></td></tr></table></figure><ol start="4"><li>Using where</li></ol><p>显示 MySQL 通过索引条件定位之后还需要返回表中获得所需要的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees where birth_date &lt; &#39;1970-01-01&#39;;</span><br><span class="line">+----+-------------+-----------+------------+------+----------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys  | key    | key_len | ref    | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+-----------+------------+------+----------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | ALL  | idx_birth_hire | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 299512 | 50.0     | Using where |</span><br><span class="line">+----+-------------+-----------+------------+------+----------------+--------+---------+--------+--------+----------+-------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.016s</span><br></pre></td></tr></table></figure><ol start="5"><li>Impossible WHERE</li></ol><p>where 子句的条件永远都不可能为真。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees where 1 &#x3D; 0;</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------+</span><br><span class="line">| id | select_type | table  | partitions | type   | possible_keys | key    | key_len | ref    | rows   | filtered | Extra            |</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------+</span><br><span class="line">| 1  | SIMPLE      | &lt;null&gt; | &lt;null&gt;     | &lt;null&gt; | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | &lt;null&gt; | &lt;null&gt;   | Impossible WHERE |</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.015s</span><br></pre></td></tr></table></figure><ol start="6"><li>Using join buffer (Block Nested Loop), Using join buffer (Batched Key Access)</li></ol><p>在表联接过程当中，将先前表的部分数据读取到 join buffer 缓冲区中，然后从缓冲区中读取数据与当前表进行连接。主要有两种算法：Block Nested Loop和Batched Key Access，关于这两种算法说明可以参考官方文档：Block Nested-Loop and Batched Key Access Joins，也可以参考另一篇博文说明：MySQL 查询优化之 Block Nested-Loop 与 Batched Key Access Joins。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- Block Nested Loop</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from employees e,dept_emp d where e.emp_no &gt; 10001 and e.emp_no &lt;&gt; d.emp_no;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+--------+--------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref    | rows   | filtered | Extra                                             |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+--------+--------+----------+----------------------------------------------------+</span><br><span class="line">| 1  | SIMPLE      | e     | &lt;null&gt;     | range | PRIMARY       | PRIMARY | 4       | &lt;null&gt; | 149756 | 100.0    | Using where                                       |</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | ALL   | &lt;null&gt;        | &lt;null&gt;  | &lt;null&gt;  | &lt;null&gt; | 331143 |  90.0    | Using where; Using join buffer(Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+--------+--------+----------+----------------------------------------------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.020s</span><br><span class="line"></span><br><span class="line">-- Batched Key Access</span><br><span class="line">mysql root@localhost:employees&gt; explain SELECT &#x2F;*+ bka(a)*&#x2F; a.gender, b.dept_no FROM employees a, dept_emp b WHERE a.birth_date &#x3D; b.from_date;</span><br><span class="line">+----+-------------+-------+------------+------+----------------+----------------+---------+-----------------------+--------+----------+----------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys  | key            | key_len | ref                   | rows   | filtered | Extra                                 |</span><br><span class="line">+----+-------------+-------+------------+------+----------------+----------------+---------+-----------------------+--------+----------+----------------------------------------+</span><br><span class="line">| 1  | SIMPLE      | b     | &lt;null&gt;     | ALL  | &lt;null&gt;         | &lt;null&gt;         | &lt;null&gt;  | &lt;null&gt;                | 331143 | 100.0    | &lt;null&gt;                                |</span><br><span class="line">| 1  | SIMPLE      | a     | &lt;null&gt;     | ref  | idx_birth_hire | idx_birth_hire | 3       | employees.b.from_date | 63     | 100.0    | Using join buffer (Batched Key Access) |</span><br><span class="line">+----+-------------+-------+------------+------+----------------+----------------+---------+-----------------------+--------+----------+----------------------------------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.014s</span><br></pre></td></tr></table></figure><ol start="7"><li>Using MRR</li></ol><p>读取数据采用多范围读 (Multi-Range Read) 的优化策略。关于MRR特性也可以参考官方文档：Multi-Range Read Optimization</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; set optimizer_switch&#x3D;&#39;mrr&#x3D;on,mrr_cost_based&#x3D;off&#39;;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.001s</span><br><span class="line">mysql root@localhost:employees&gt; explain select * from employees where birth_date &#x3D; &#39;1970-01-01&#39; and hire_date &gt; &#39;1990-01-01&#39;;</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+----------------------------------+</span><br><span class="line">| id | select_type | table     | partitions | type  | possible_keys  | key            | key_len | ref    | rows | filtered | Extra                           |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+----------------------------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | range | idx_birth_hire | idx_birth_hire | 6       | &lt;null&gt; | 1    | 100.0    | Using index condition; Using MRR |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+------+----------+----------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.014s</span><br></pre></td></tr></table></figure><ol start="8"><li>Range checked for each record (index map: N)</li></ol><p>MySQL 在获取数据时发现在没有索引可用，但当获取部分先前表字段值时发现可以采用当前表某些索引来获取数据。index map展示的是一个掩码值，如 index map:0x19，对应二进制值为 11001，表示当前表索引编号为 1、4 和 5 号索引可能被用来获取数据，索引编号通过 SHOW INDEX 语句获得。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees e,dept_emp d where e.emp_no &gt; d.emp_no;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+--------+--------+----------+------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key    | key_len | ref    | rows   | filtered | Extra                                         |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+--------+--------+----------+------------------------------------------------+</span><br><span class="line">| 1  | SIMPLE      | d     | &lt;null&gt;     | ALL  | PRIMARY       | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 331143 | 100.0    | &lt;null&gt;                                        |</span><br><span class="line">| 1  | SIMPLE      | e     | &lt;null&gt;     | ALL  | PRIMARY       | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 299512 |  33.33   | Range checked for each record (index map: 0x1) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+--------+--------+----------+------------------------------------------------+</span><br><span class="line">2 rows in set</span><br><span class="line">Time: 0.038s</span><br></pre></td></tr></table></figure><ol start="9"><li>Select tables optimized away</li></ol><p>MySQL 优化器能够确定以下两点：</p><ul><li><p>最多只有一行记录被返回；</p></li><li><p>为了获取这一行数据，有一定的结果集需要获取。</p></li></ul><p>当语句在优化器阶段过程中可以获取查询结果(如获取行数，只需要读取相应索引数据)，而无需再返回表中查询数据，可能会出现 Select tables optimized away。例如针对 MyISAM 引擎的表，使用 select count(*) 获取表的总行数，而且又没有 where 子句或者条件总是为真，也没有 GROUP BY 子句时，其实就包含了以上的条件且隐式含有 GROUP BY 分组的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 创建 MyISAM 引擎的 employees 表</span><br><span class="line">mysql root@localhost:employees&gt; create table employees_myisam like employees;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.040s</span><br><span class="line">mysql root@localhost:employees&gt; insert into employees_myisam select * from employees;</span><br><span class="line">Query OK, 300024 rows affected</span><br><span class="line">Time: 5.023s</span><br><span class="line">mysql root@localhost:employees&gt; alter table employees_myisam engine&#x3D;MyISAM;</span><br><span class="line">Query OK, 300024 rows affected</span><br><span class="line">Time: 1.515s</span><br><span class="line"></span><br><span class="line">-- 获取执行 count(*) 查询行数执行计划</span><br><span class="line">mysql root@localhost:employees&gt; explain select count(*) from employees_myisam;</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------------------+</span><br><span class="line">| id | select_type | table  | partitions | type   | possible_keys | key    | key_len | ref    | rows   | filtered | Extra                        |</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------------------+</span><br><span class="line">| 1  | SIMPLE      | &lt;null&gt; | &lt;null&gt;     | &lt;null&gt; | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | &lt;null&gt; | &lt;null&gt;   | Select tables optimized away |</span><br><span class="line">+----+-------------+--------+------------+--------+---------------+--------+---------+--------+--------+----------+------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.024s</span><br></pre></td></tr></table></figure><ol start="10"><li>Using temporary</li></ol><p>MySQL 需要创建临时表来存放查询结果集。通常发生在有 GROUP BY 或 ORDER BY 子句的语句当中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select hire_date from employees group by hire_date;</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+--------+----------+----------------------------------------------+</span><br><span class="line">| id | select_type | table     | partitions | type  | possible_keys  | key            | key_len | ref    | rows   | filtered | Extra</span><br><span class="line">                          |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+--------+----------+----------------------------------------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | index | idx_birth_hire | idx_birth_hire | 6       | &lt;null&gt; | 299512 | 100.0    | Using index; Using temporary; Using filesort |</span><br><span class="line">+----+-------------+-----------+------------+-------+----------------+----------------+---------+--------+--------+----------+----------------------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.018s</span><br></pre></td></tr></table></figure><ol start="11"><li>Using filesort</li></ol><p>MySQL 需要对获取的数据进行额外的一次排序操作，无法通过索引的排序完成。通常发生在有 ORDER BY 子句的语句当中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; explain select * from employees order by hire_date;</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+--------+---------+--------+--------+----------+----------------+</span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key    | key_len | ref    | rows   | filtered | Extra          |</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+--------+---------+--------+--------+----------+----------------+</span><br><span class="line">| 1  | SIMPLE      | employees | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 299512 | 100.0    | Using filesort |</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+--------+---------+--------+--------+----------+----------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.015s</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>以上内容总结了 MySQL 获取执行计划 explain 命令执行时输出的主要字段说明，还有许多未仔细说明的参数和选项，以后还需多多实践总结。可以看出 explain 命令输出内容当中比较重要的是：</p><ol><li><p>type：展示了表的查询/连接类型，体现查询效率；</p></li><li><p>key/key_len：实际使用了什么索引，使用了哪些部分索引；</p></li><li><p>Extra：对执行计划步骤额外的说明，采用了哪些查询特性。</p></li></ol><h2 id="参考">参考</h2><ol><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a></p></li><li><p><a href="https://dev.mysql.com/doc/index-other.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/index-other.html</a></p></li><li><p><a href="https://blog.csdn.net/u012410733/article/details/66472157" target="_blank" rel="noopener">https://blog.csdn.net/u012410733/article/details/66472157</a></p></li><li><p><a href="https://blog.csdn.net/wanbin6470398/article/details/82425620" target="_blank" rel="noopener">https://blog.csdn.net/wanbin6470398/article/details/82425620</a></p></li><li><p><a href="https://blog.csdn.net/tianya9704/article/details/80067860" target="_blank" rel="noopener">https://blog.csdn.net/tianya9704/article/details/80067860</a></p></li></ol><blockquote><p>来源：博客园</p><p>原文：<a href="https://tinyurl.com/y26xecs7" target="_blank" rel="noopener">https://tinyurl.com/y26xecs7</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL的 explain 命令语句提供了如何执行 SQL 语句的信息，解析 SQL 语句的执行计划并展示，explain 支持 select、delete、insert、replace 和 update 等语句，也支持对分区表的解析。通常 explain 用来获取 select 语句的执行计划，通过 explain 展示的信息我们可以了解到表查询的顺序，表连接的方式等，并根据这些信息判断 select 执行效率，决定是否添加索引或改写 SQL 语句优化表连接方式以提高执行效率。本文参考官方文档：EXPLAIN Output Format 对 explain 输出的内容进行说明，同时也对自己之前使用 explain 不清晰的方面进行总结。&lt;/p&gt;
&lt;p&gt;本文使用的 MySQL 版本为官方社区版 5.7.24。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql root@localhost:(none)&amp;gt; select version();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| version()  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 5.7.24-log |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 row in set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Time: 0.066s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;主要用法&quot;&gt;主要用法&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; EXPLAIN | DESCRIBE &amp;#125; [EXTENDED | PARTITIONS | FORMAT&amp;#x3D;[TRADITIONAL | JSON]] SQL_STATEMENT;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;EXPLAIN 和 DESCRIBE(可以简写成 DESC)都可以用来查看语句的执行计划，但通常使用 EXPLAIN 较多；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FORMAT 选项可以指定执行计划输出信息为 JSON 格式，而且包含一些更详细的指标说明；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EXTENDED 和 PARTITIONS 选项可以输出更详细选项说明，语法上是为了兼容低版本 MySQL，未来会废弃，默认使用 EXPLAIN 命令即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;测试数据&quot;&gt;测试数据&lt;/h2&gt;
&lt;p&gt;本文基于 MySQL 官方示例数据库 employee：Example Databases 进行解析说明，使用到的表如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- employees：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql root@localhost:employees&amp;gt; show create table employees\G;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************[ 1. row ]***************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Table        | employees&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Create Table | CREATE TABLE &amp;#96;employees&amp;#96; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;emp_no&amp;#96; int(11) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;birth_date&amp;#96; date NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;first_name&amp;#96; varchar(14) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;last_name&amp;#96; varchar(16) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;gender&amp;#96; enum(&amp;#39;M&amp;#39;,&amp;#39;F&amp;#39;) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;hire_date&amp;#96; date NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (&amp;#96;emp_no&amp;#96;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY &amp;#96;idx_first_last&amp;#96; (&amp;#96;first_name&amp;#96;,&amp;#96;last_name&amp;#96;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY &amp;#96;idx_birth_hire&amp;#96; (&amp;#96;birth_date&amp;#96;,&amp;#96;hire_date&amp;#96;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE&amp;#x3D;InnoDB DEFAULT CHARSET&amp;#x3D;utf8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 row in set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Time: 0.008s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-- dept_emp：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql root@localhost:employees&amp;gt; show create table dept_emp\G;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************[ 1. row ]***************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Table        | dept_emp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Create Table | CREATE TABLE &amp;#96;dept_emp&amp;#96; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;emp_no&amp;#96; int(11) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;dept_no&amp;#96; char(4) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;from_date&amp;#96; date NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;to_date&amp;#96; date NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (&amp;#96;emp_no&amp;#96;,&amp;#96;dept_no&amp;#96;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY &amp;#96;dept_no&amp;#96; (&amp;#96;dept_no&amp;#96;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CONSTRAINT &amp;#96;dept_emp_ibfk_1&amp;#96; FOREIGN KEY (&amp;#96;emp_no&amp;#96;) REFERENCES &amp;#96;employees&amp;#96; (&amp;#96;emp_no&amp;#96;) ON DELETE CASCADE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CONSTRAINT &amp;#96;dept_emp_ibfk_2&amp;#96; FOREIGN KEY (&amp;#96;dept_no&amp;#96;) REFERENCES &amp;#96;departments&amp;#96; (&amp;#96;dept_no&amp;#96;) ON DELETE CASCADE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE&amp;#x3D;InnoDB DEFAULT CHARSET&amp;#x3D;utf8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 row in set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Time: 0.010s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-- departments：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql root@localhost:employees&amp;gt; show create table departments\G;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************[ 1. row ]***************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Table        | departments&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Create Table | CREATE TABLE &amp;#96;departments&amp;#96; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;dept_no&amp;#96; char(4) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#96;dept_name&amp;#96; varchar(40) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (&amp;#96;dept_no&amp;#96;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UNIQUE KEY &amp;#96;dept_name&amp;#96; (&amp;#96;dept_name&amp;#96;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE&amp;#x3D;InnoDB DEFAULT CHARSET&amp;#x3D;utf8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 row in set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Time: 0.012s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://www.hi-linux.com/categories/MySQL/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="MySQL" scheme="https://www.hi-linux.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的回退 Git 误操作</title>
    <link href="https://www.hi-linux.com/posts/2831.html"/>
    <id>https://www.hi-linux.com/posts/2831.html</id>
    <published>2020-05-24T01:02:00.000Z</published>
    <updated>2020-05-24T07:59:40.841Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Git</code> 版本管理时，往往需要撤销某些操作。</p><p>本文介绍几种最主要的情况，给出详细的解释。更多的命令可以参考《<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247483821&amp;idx=1&amp;sn=37a2d147d25cea5efc424736bfb01dc8&amp;chksm=eac52084ddb2a9922e1962d30347f2593014dd45de91ba8464539b04a79906b28fa1c450336d&amp;token=630135187&amp;lang=zh_CN#rd" target="_blank" rel="noopener">常用 Git 命令清单</a>》一文。</p><h2 id="一-撤销提交">一、撤销提交</h2><p>一种常见的场景是，提交代码以后，你突然意识到这个提交有问题，应该撤销掉，这时执行下面的命令就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert HEAD</span><br></pre></td></tr></table></figure><p>上面命令的原理是，在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化。它不会改变过去的历史，所以是首选方式，没有任何丢失代码的风险。</p><p><code>git revert</code> 命令只能抵消上一个提交，如果想抵消多个提交，必须在命令行依次指定这些提交。比如，抵消前两个提交，要像下面这样写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert [倒数第一个提交] [倒数第二个提交]</span><br></pre></td></tr></table></figure><p><code>git revert</code> 命令还有两个参数。</p><ul><li><code>--no-edit</code>：执行时不打开默认编辑器，直接使用 <code>Git</code> 自动生成的提交信息。</li><li><code>--no-commit</code>：只抵消暂存区和工作区的文件变化，不产生新的提交。</li></ul><a id="more"></a><h2 id="二-丢弃提交">二、丢弃提交</h2><p>如果希望以前的提交在历史中彻底消失，而不是被抵消掉，可以使用 <code>git reset</code> 命令，丢弃掉某个提交之后的所有提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset [last good SHA]</span><br></pre></td></tr></table></figure><p><code>git reset</code> 的原理是，让最新提交的指针回到以前某个时点，该时点之后的提交都从历史中消失。</p><p>默认情况下，<code>git reset</code> 不改变工作区的文件（但会改变暂存区），<code>--hard</code> 参数可以让工作区里面的文件也回到以前的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard [last good SHA]</span><br></pre></td></tr></table></figure><p>执行 <code>git reset</code> 命令之后，如果想找回那些丢弃掉的提交，可以使用 <code>git reflog</code> 命令，具体做法参考这里。不过，这种做法有时效性，时间长了可能找不回来。</p><h2 id="三-替换上一次提交">三、替换上一次提交</h2><p>提交以后，发现提交信息写错了，这时可以使用 <code>git commit</code> 命令的 <code>--amend</code>  参数，可以修改上一次的提交信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend -m <span class="string">"Fixes bug #42"</span></span><br></pre></td></tr></table></figure><p>它的原理是产生一个新的提交对象，替换掉上一次提交产生的提交对象。</p><p>这时如果暂存区有发生变化的文件，会一起提交到仓库。所以，<code>--amend</code> 不仅可以修改提交信息，还可以整个把上一次提交替换掉。</p><h2 id="四-撤销工作区的文件修改">四、撤销工作区的文件修改</h2><p>如果工作区的某个文件被改乱了，但还没有提交，可以用 <code>git checkout</code> 命令找回本次修改之前的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- [filename]</span><br></pre></td></tr></table></figure><p>它的原理是先找暂存区，如果该文件有暂存的版本，则恢复该版本，否则恢复上一次提交的版本。</p><p>注意，工作区的文件变化一旦被撤销，就无法找回了。</p><h2 id="五-从暂存区撤销文件">五、从暂存区撤销文件</h2><p>如果不小心把一个文件添加到暂存区，可以用下面的命令撤销。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached [filename]</span><br></pre></td></tr></table></figure><p>上面的命令不影响已经提交的内容。</p><h2 id="六-撤销当前分支的变化">六、撤销当前分支的变化</h2><p>你在当前分支上做了几次提交，突然发现放错了分支，这几个提交本应该放到另一个分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个 feature 分支，指向当前最新的提交</span></span><br><span class="line"><span class="comment"># 注意，这时依然停留在当前分支</span></span><br><span class="line">$ git branch feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到这几次提交之前的状态</span></span><br><span class="line">$ git reset --hard [当前分支此前的最后一次提交]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 feature 分支</span></span><br><span class="line">$ git checkout feature</span><br></pre></td></tr></table></figure><p>上面的操作等于是撤销当前分支的变化，将这些变化放到一个新建的分支。</p><blockquote><p>本文转载自：「阮一峰的网络日志」，原文：<a href="https://url.cn/5NLK2pC%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5NLK2pC，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Git&lt;/code&gt; 版本管理时，往往需要撤销某些操作。&lt;/p&gt;
&lt;p&gt;本文介绍几种最主要的情况，给出详细的解释。更多的命令可以参考《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247483821&amp;amp;idx=1&amp;amp;sn=37a2d147d25cea5efc424736bfb01dc8&amp;amp;chksm=eac52084ddb2a9922e1962d30347f2593014dd45de91ba8464539b04a79906b28fa1c450336d&amp;amp;token=630135187&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;常用 Git 命令清单&lt;/a&gt;》一文。&lt;/p&gt;
&lt;h2 id=&quot;一、撤销提交&quot;&gt;一、撤销提交&lt;/h2&gt;
&lt;p&gt;一种常见的场景是，提交代码以后，你突然意识到这个提交有问题，应该撤销掉，这时执行下面的命令就可以了。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git revert HEAD&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令的原理是，在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化。它不会改变过去的历史，所以是首选方式，没有任何丢失代码的风险。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git revert&lt;/code&gt; 命令只能抵消上一个提交，如果想抵消多个提交，必须在命令行依次指定这些提交。比如，抵消前两个提交，要像下面这样写。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git revert [倒数第一个提交] [倒数第二个提交]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;git revert&lt;/code&gt; 命令还有两个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--no-edit&lt;/code&gt;：执行时不打开默认编辑器，直接使用 &lt;code&gt;Git&lt;/code&gt; 自动生成的提交信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-commit&lt;/code&gt;：只抵消暂存区和工作区的文件变化，不产生新的提交。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Git" scheme="https://www.hi-linux.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核故障调试利器 dmesg 使用指南</title>
    <link href="https://www.hi-linux.com/posts/5619.html"/>
    <id>https://www.hi-linux.com/posts/5619.html</id>
    <published>2020-05-24T01:01:00.000Z</published>
    <updated>2020-05-24T07:59:40.843Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Linux</code> 内核是操作系统的核心，它控制对系统资源（例如： <code>CPU</code>、<code>I/O</code>设备、物理内存和文件系统）的访问。在引导过程中以及系统运行时，内核会将各种消息写入内核环形缓冲区。这些消息包括有关系统操作的各种信息。</p><p>内核环形缓冲区是物理内存的一部分，用于保存内核的日志消息。它具有固定的大小，这意味着一旦缓冲区已满，较旧的日志记录将被覆盖。</p><p><code>dmesg</code> 命令行实用程序用于在 <code>Linux</code> 和其他类似 <code>Unix</code> 的操作系统中打印和控制内核环形缓冲区。对于检查内核启动消息和调试与硬件相关的问题很有用。</p><p>在本教程中，我们将介绍 <code>dmesg</code> 命令的基础。</p><h2 id="使用-dmesg-命令">使用 dmesg 命令</h2><p><code>dmesg</code> 命令的语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg [OPTIONS]</span><br></pre></td></tr></table></figure><p>在不带任何选项的情况下调用时，<code>dmesg</code> 将所有消息从内核环形缓冲区写入标准输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg</span><br></pre></td></tr></table></figure><p>默认情况下，所有用户都可以运行 <code>dmesg</code> 命令。但是，在某些系统上，非 root 用户可能会限制对 <code>dmesg</code>的访问。在这种情况下，调用 dmesg`时您将收到如下错误消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg: <span class="built_in">read</span> kernel buffer failed: Operation not permitted</span><br></pre></td></tr></table></figure><a id="more"></a><p>内核参数 <code>kernel.dmesg_restrict</code> 指定非特权用户是否可以使用 <code>dmesg</code> 查看来自内核日志缓冲区的消息。要删除限制，请将其设置为零：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -w kernel.dmesg_restrict=0</span><br></pre></td></tr></table></figure><p>通常，输出包含很多信息行，因此只能看到输出的最后一部分。要一次查看一页，请将输出通过管道传送到分页实用程序，例如 <code>less</code> 或 <code>more</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg --color=always | less</span><br></pre></td></tr></table></figure><p>其中的 <code>--color=always</code> 参数用于保留彩色输出。</p><p>如果要过滤缓冲区消息，可能使用 <code>grep</code> 。例如，要仅查看与 USB 相关的消息，请键入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg | grep -i usb</span><br></pre></td></tr></table></figure><p>dmesg 从 <code>/proc/kmsg</code> 虚拟文件中读取内核生成的消息。该文件提供了到内核环形缓冲区的接口，并且只能由一个进程打开。如果系统上正在运行 <code>syslog</code> 进程，并且你尝试使用 <code>cat</code> 或 <code>less</code> 命令读取文件，则命令将挂起。</p><p><code>syslog</code> 守护程序将内核消息转储到 <code>/var/log/dmesg</code>，因此你也可以使用该日志文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/<span class="built_in">log</span>/dmesg</span><br></pre></td></tr></table></figure><h2 id="格式化-dmesg-输出">格式化 dmesg 输出</h2><p><code>dmesg</code> 命令提供了许多选项，可帮助你格式化和过滤输出。</p><p><code>dmesg</code> 中最常用的选项之一是 <code>-H（--human）</code>，它将输出更容易读的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg -H</span><br></pre></td></tr></table></figure><p>要打印人类可读的时间戳，请使用 <code>-T（--ctime</code> 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg -T</span><br><span class="line"></span><br><span class="line">[Mon Oct 14 14:38:04 2019] IPv6: ADDRCONF(NETDEV_CHANGE): wlp1s0: link becomes ready</span><br></pre></td></tr></table></figure><p>时间戳格式也可以使用 <code>--time-format &lt;format&gt;</code> 选项设置，可以是 <code>ctime</code>，<code>reltime</code>，<code>delta</code>，<code>notime</code>或 <code>iso</code>。例如：要使用增量格式，你可以输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg --time-format=delta</span><br></pre></td></tr></table></figure><p>你也可以组合两个或多个选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg -H -T</span><br></pre></td></tr></table></figure><p>要实时观看 <code>dmesg</code> 命令的输出，请使用 <code>-w（--follow）</code>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg --follow</span><br></pre></td></tr></table></figure><h2 id="过滤-dmesg-输出">过滤 dmesg 输出</h2><p>你可以将 <code>dmesg</code> 输出限制为给定的设施和等级。<code>dmesg</code> 支持以下类型：</p><ul><li><p>kern-内核消息</p></li><li><p>user-用户级消息</p></li><li><p>mail-邮件系统</p></li><li><p>daemon-系统守护程序</p></li><li><p>auth-安全/授权消息</p></li><li><p>syslog-内部 syslogd 消息</p></li><li><p>lpr-行式打印机子系统</p></li><li><p>news-网络新闻子系统</p></li></ul><p><code>-f（--facility &lt;list&gt;）</code> 选项允许你将输出限制为特定的设备，该选项接受一个或多个逗号分隔的功能。</p><p>例如，要仅显示内核和系统守护程序消息，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg -f kern,daemon</span><br></pre></td></tr></table></figure><p>每条日志消息都与一个显示消息重要性的日志级别相关联，<code>dmesg</code> 支持以下日志级别：</p><ul><li><p>emerg-系统无法使用</p></li><li><p>alert-必须立即采取措施</p></li><li><p>crit-紧急情况</p></li><li><p>err-错误条件</p></li><li><p>warn-警告条件</p></li><li><p>notice-正常但重要的条件</p></li><li><p>info-信息性</p></li><li><p>debug-调试级消息</p></li></ul><p><code>-l（--level &lt;list&gt;）</code>选项允许你将输出限制为定义的级别，该选项接受一个或多个逗号分隔的级别。以下命令仅显示错误和严重消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg -l err,crit</span><br></pre></td></tr></table></figure><h2 id="清除环形缓冲区">清除环形缓冲区</h2><p><code>-C（--clear）</code> 选项可让您清除环形缓冲区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dmesg -C</span><br></pre></td></tr></table></figure><p>只有 <code>root</code> 或具有 <code>sudo</code> 特权的用户才能清除缓冲区。</p><p>要在清除之前打印缓冲区内容，请使用 <code>-c（--read-clear）</code>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dmesg -c</span><br></pre></td></tr></table></figure><p>如果要在清除文件之前将当前 <code>dmesg</code> 日志保存到文件中，你可以将输出重定向到文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg &gt; dmesg_messages</span><br></pre></td></tr></table></figure><h2 id="结论">结论</h2><p><code>dmesg</code> 命令允许你查看和控制内核环形缓冲区。对内核或硬件问题进行故障排除时，它非常有用。</p><p>在终端中输入 <code>man dmesg</code>，你可以获取有关所有可用 <code>dmesg</code> 选项的信息。</p><blockquote><p>来源：myfreax</p><p>原文：<a href="https://url.cn/5Fn5kFm" target="_blank" rel="noopener">https://url.cn/5Fn5kFm</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 内核是操作系统的核心，它控制对系统资源（例如： &lt;code&gt;CPU&lt;/code&gt;、&lt;code&gt;I/O&lt;/code&gt;设备、物理内存和文件系统）的访问。在引导过程中以及系统运行时，内核会将各种消息写入内核环形缓冲区。这些消息包括有关系统操作的各种信息。&lt;/p&gt;
&lt;p&gt;内核环形缓冲区是物理内存的一部分，用于保存内核的日志消息。它具有固定的大小，这意味着一旦缓冲区已满，较旧的日志记录将被覆盖。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dmesg&lt;/code&gt; 命令行实用程序用于在 &lt;code&gt;Linux&lt;/code&gt; 和其他类似 &lt;code&gt;Unix&lt;/code&gt; 的操作系统中打印和控制内核环形缓冲区。对于检查内核启动消息和调试与硬件相关的问题很有用。&lt;/p&gt;
&lt;p&gt;在本教程中，我们将介绍 &lt;code&gt;dmesg&lt;/code&gt; 命令的基础。&lt;/p&gt;
&lt;h2 id=&quot;使用-dmesg-命令&quot;&gt;使用 dmesg 命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dmesg&lt;/code&gt; 命令的语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dmesg [OPTIONS]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在不带任何选项的情况下调用时，&lt;code&gt;dmesg&lt;/code&gt; 将所有消息从内核环形缓冲区写入标准输出：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ dmesg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认情况下，所有用户都可以运行 &lt;code&gt;dmesg&lt;/code&gt; 命令。但是，在某些系统上，非 root 用户可能会限制对 &lt;code&gt;dmesg&lt;/code&gt;的访问。在这种情况下，调用 dmesg`时您将收到如下错误消息：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dmesg: &lt;span class=&quot;built_in&quot;&gt;read&lt;/span&gt; kernel buffer failed: Operation not permitted&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="dmesg" scheme="https://www.hi-linux.com/tags/dmesg/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款全平台目录结构分析神器 folder-explorer</title>
    <link href="https://www.hi-linux.com/posts/41860.html"/>
    <id>https://www.hi-linux.com/posts/41860.html</id>
    <published>2020-05-24T01:00:00.000Z</published>
    <updated>2020-05-24T07:59:40.846Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>对于一个比较复杂的项目来说，我们经常需要在项目文档中对其结构和重要的文件进行介绍。而要形像生动的介绍清楚项目中所有内容，无疑是用一张漂亮的目录结构图。</p><p><img src="https://qiniucdn.fairyever.com/20190926165513.png" alt=""></p><p>通常一个目录结构图的制作需要以下几个步骤：</p><ol><li><p>扫描目录</p></li><li><p>编辑注释</p></li><li><p>隐藏希望忽略的文件</p></li><li><p>生成美观的结构图</p></li></ol><p>今天我们就给大家介绍一款可以自动扫描目录、分析文件结构和生成统计信息的利器 Folder-Explorer。 Folder-Explorer 不仅能自动分析目录和文件，还能给任意文件添加备注和导出多种格式的树形目录结构图，大大方便了项目技术文档的编写。</p><blockquote><p>项目地址：<a href="https://github.com/d2-projects/folder-explorer" target="_blank" rel="noopener">https://github.com/d2-projects/folder-explorer</a></p></blockquote><a id="more"></a><h2 id="folder-explorer-功能介绍">Folder-Explorer 功能介绍</h2><p><img src="https://qiniucdn.fairyever.com/20190926165542.png" alt=""></p><ul><li><p>支持扫描指定的目录（支持拖拽）以及再次扫描当前结果中的指定目录</p></li><li><p>展示文件结构的树形统计，</p></li><li><p>支持给文件添加注释</p></li><li><p>支持隐藏单个文件或者文件夹内容</p></li><li><p>支持文件类型统计</p></li><li><p>支持文件体积分布统计</p></li><li><p>支持导出文字构成的树形结构图，支持注释和自动对齐，支持自定义内容格式</p></li><li><p>支持导出 JSON 文件和 XML 文件供其他软件或者程序使用</p></li><li><p>支持导出 Xmind 结构图，支持自定义节点、Label 和注释的内容格式化</p></li><li><p>支持自定义导出文件的名称预设</p></li><li><p>支持注释信息记忆功能</p></li><li><p>支持个性化设置的备份和导入</p></li><li><p>更多其它丰富的设置选项</p></li></ul><h2 id="folder-explorer-常见使用场景">Folder-Explorer 常见使用场景</h2><ul><li><p>项目文档书写，附上文件结构和注释可以更清晰地让别人上手项目</p></li><li><p>展示课程目录，如果你是讲师，可以一口气将你的课程所有章节生成树形结构展示</p></li><li><p>统计某个资源文件夹中的文件大小分布，例如分析你的照片文件夹，或者一目了然磁盘里每部电影占了多大空间</p></li></ul><h2 id="安装-folder-explorer">安装 Folder-Explorer</h2><p>Folder-Explorer 的安装非常简单，主流平台 (macOS、Windows、Linux) 都支持了，开箱即用。你只需到项目官方地址的 Releases 页面下载即可。</p><h2 id="folder-explorer-详细功能介绍">Folder-Explorer 详细功能介绍</h2><p>以下所有演示，都将基于下述的目录结构进行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">├─.DS_Store </span><br><span class="line">├─.browserslistrc </span><br><span class="line">├─.gitignore </span><br><span class="line">├─README.md </span><br><span class="line">├─babel.config.js </span><br><span class="line">├─package.json </span><br><span class="line">├─postcss.config.js </span><br><span class="line">├─public </span><br><span class="line">│ ├─favicon.ico </span><br><span class="line">│ └─index.html </span><br><span class="line">├─src </span><br><span class="line">│ ├─App.vue </span><br><span class="line">│ ├─assets </span><br><span class="line">│ │ └─sys </span><br><span class="line">│ │   └─logo </span><br><span class="line">│ │     └─w200.png </span><br><span class="line">│ ├─components </span><br><span class="line">│ │ └─HelloWorld.vue </span><br><span class="line">│ ├─layout </span><br><span class="line">│ │ └─headerAside </span><br><span class="line">│ │   ├─components </span><br><span class="line">│ │   │ ├─aside </span><br><span class="line">│ │   │ │ ├─index.vue </span><br><span class="line">│ │   │ │ └─style.scss </span><br><span class="line">│ │   │ └─header </span><br><span class="line">│ │   │   ├─index.vue </span><br><span class="line">│ │   │   └─style.scss </span><br><span class="line">│ │   └─index.vue </span><br><span class="line">│ └─main.js </span><br><span class="line">└─yarn.lock</span><br></pre></td></tr></table></figure><h3 id="folder-explorer-编辑器中的日常操作演示">Folder-Explorer 编辑器中的日常操作演示</h3><ol><li>展开和折叠节点</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926165558.gif" alt=""></p><ol start="2"><li>移除节点</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926165703.gif" alt=""></p><ol start="3"><li>给文件或者目录添加注释</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926165924.gif" alt=""></p><p>添加注释后的导出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">├─README.md --------------- // 介绍</span><br><span class="line">├─babel.config.js </span><br><span class="line">├─package.json </span><br><span class="line">├─postcss.config.js </span><br><span class="line">├─public ------------------ // 公共资源</span><br><span class="line">│ ├─favicon.ico </span><br><span class="line">│ └─index.html </span><br><span class="line">├─src </span><br><span class="line">│ ├─App.vue --------------- // 根组件</span><br><span class="line">│ ├─assets </span><br><span class="line">│ │ └─sys </span><br><span class="line">│ │   └─logo </span><br><span class="line">│ │     └─w200.png </span><br><span class="line">│ ├─components </span><br><span class="line">│ │ └─HelloWorld.vue </span><br><span class="line">│ ├─layout </span><br><span class="line">│ │ └─headerAside </span><br><span class="line">│ │   ├─components </span><br><span class="line">│ │   │ ├─aside </span><br><span class="line">│ │   │ │ ├─index.vue </span><br><span class="line">│ │   │ │ └─style.scss </span><br><span class="line">│ │   │ └─header </span><br><span class="line">│ │   │   ├─index.vue </span><br><span class="line">│ │   │   └─style.scss </span><br><span class="line">│ │   └─index.vue </span><br><span class="line">│ └─main.js </span><br><span class="line">└─yarn.lock</span><br></pre></td></tr></table></figure><blockquote><ol><li>从上面的导出结果我们可以看到，并不会导出被折叠和隐藏的文件或目录，并且会根据折叠之后的状态重新计算树形结构。</li></ol></blockquote><blockquote><ol start="2"><li>备注有记忆功能，例如扫描 <code>/a</code> 目录后添加了注释，之后扫描了 <code>/b</code> 目录，当再次扫描 <code>/a</code> 目录后第一次添加的注释会自动还原。</li></ol></blockquote><ol start="4"><li>直接在 Folder-Explorer 中打开文件</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926170049.gif" alt=""></p><ol start="5"><li>直接在 Folder-Explorer 中打开目录</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926170058.gif" alt=""></p><ol start="6"><li>扫描子文件夹</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926170246.gif" alt=""></p><h3 id="在-folder-explorer-中进行统计">在 Folder-Explorer 中进行统计</h3><ol><li>文件类型统计</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926170302.png" alt=""></p><ol start="2"><li>文件大小统计</li></ol><p><img src="https://qiniucdn.fairyever.com/20190926170319.png" alt=""></p><h3 id="将目录结果进行导出">将目录结果进行导出</h3><p><img src="https://qiniucdn.fairyever.com/20190926170332.png" alt=""></p><p>目前支持以下导出方式：</p><ol><li>文本</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113304.png" alt=""></p><ol start="2"><li>JSON</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113313.png" alt=""></p><ol start="3"><li>Xmind</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113337.png" alt=""></p><ol start="4"><li>XML</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113352.png" alt=""></p><ol start="5"><li>HTML</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113402.png" alt=""></p><h3 id="更多个性化设置">更多个性化设置</h3><ol><li>自定义扫描</li></ol><p>支持自定义扫描忽略的文件夹和文件，并可以指定忽略的文件类型。</p><p><img src="https://qiniucdn.fairyever.com/20190927113631.png" alt=""></p><p>为方便快速设置，选项会自动根据当前的扫描结果改变。</p><p><img src="https://qiniucdn.fairyever.com/20190927113643.png" alt=""></p><p><img src="https://qiniucdn.fairyever.com/20190927113653.png" alt=""></p><ol start="2"><li>自定义扫描深度</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927113703.png" alt=""></p><p><img src="https://qiniucdn.fairyever.com/20190927113709.png" alt=""></p><ol start="3"><li>只扫描文件夹</li></ol><p><img src="https://qiniucdn.fairyever.com/20190927142016.png" alt=""></p><ol start="4"><li>忽略隐藏文件</li></ol><p>支持设置忽略 <code>.</code> 开头的文件，因为这些文件在 macOS 和 Linux 上是隐藏的</p><p><img src="https://qiniucdn.fairyever.com/20190927113718.png" alt=""></p><ol start="5"><li>预设文件名</li></ol><p>几乎所有的导出都支持自定义文件名，并支持多种占位符，请注意输入框右上角的提示：</p><p><img src="https://qiniucdn.fairyever.com/20190927113740.png" alt=""></p><p>点击提示之后会弹出这个位置所有可用的占位符，点击占位符可以快速复制到剪贴板：</p><p><img src="https://qiniucdn.fairyever.com/20190927113747.png" alt=""></p><p>占位符示例：</p><p><img src="https://qiniucdn.fairyever.com/20190927113752.png" alt=""></p><blockquote><p>注：在一些其它的设置位置也支持占位符，例如：设置备注的格式化，脑图的节点内容等。</p></blockquote><p>至此，这款好用的项目结构分析工具就介绍完了。如果你也有些需求，就赶紧的用起来吧！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个比较复杂的项目来说，我们经常需要在项目文档中对其结构和重要的文件进行介绍。而要形像生动的介绍清楚项目中所有内容，无疑是用一张漂亮的目录结构图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiniucdn.fairyever.com/20190926165513.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;通常一个目录结构图的制作需要以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;扫描目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐藏希望忽略的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成美观的结构图&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天我们就给大家介绍一款可以自动扫描目录、分析文件结构和生成统计信息的利器 Folder-Explorer。 Folder-Explorer 不仅能自动分析目录和文件，还能给任意文件添加备注和导出多种格式的树形目录结构图，大大方便了项目技术文档的编写。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/d2-projects/folder-explorer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/d2-projects/folder-explorer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>浅谈集群、分布式、微服务的异同</title>
    <link href="https://www.hi-linux.com/posts/52526.html"/>
    <id>https://www.hi-linux.com/posts/52526.html</id>
    <published>2020-05-23T02:27:00.000Z</published>
    <updated>2020-05-23T15:29:29.321Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="什么是集群">什么是集群</h3><p>集群是是指将多台服务器集中在一起，每台服务器都实现相同的业务，做相同的事情。但是每台服务器并不是缺一不可，存在的作用主要是缓解并发压力和单点故障转移问题。可以利用一些廉价的符合工业标准的硬件构造高扩展、高性能、低成本、高可用的系统。</p><p>集群主要具有以下特性：</p><ul><li>伸缩性（Scalability）</li></ul><p>在一些大的系统中，预测最终用户的数量和行为是非常困难的，伸缩性是指系统适应不断增长的用户数的能力。提高这种并发会话能力的一种最直观的方式就增加资源（CPU，内存，硬盘等），集群是解决这个问题的另一种方式，它允许一组服务器组在一起，像单个服务器一样分担处理一个繁重的任务，我们只需要将新的服务器加入集群中即可，对于客户来看，服务无论从连续性还是性能上都几乎没有变化，好像系统在不知不觉中完成了升级。</p><ul><li>高可用性（High availability）</li></ul><p>单一服务器的解决方案并不是一个健壮方式，因为容易出现单点失效。像银行、账单处理这样一些关键的应用程序是不能容忍哪怕是几分钟的死机。它们需要这样一些服务在任何时间都可以访问并在可预期的合理的时间周期内有响应。高可用性集群的出现是为了使集群的整体服务尽可能可用，以便考虑计算硬件和软件的易错性。如果高可用性集群中的主节点发生了故障，那么这段时间内将由次节点代替它。次节点通常是主节点的镜像，所以当它代替主节点时，它可以完全接管其身份，并且因此使系统环境对于用户是一致的。</p><ul><li>负载均衡（Load balancing）</li></ul><p>负载均衡集群为企业需求提供了更实用的系统。如名称所暗示的，该系统使负载可以在计算机集群中尽可能平均地分摊处理。该负载可能是需要均衡的应用程序处理负载或网络流量负载。这样的系统非常适合于运行同一组应用程序的大量用户。每个节点都可以处理一部分负载，并且可以在节点之间动态分配负载，以实现平衡。</p><ul><li>高性能 (High Performance)</li></ul><p>通常，这种涉及为集群开发并行编程应用程序，以解决复杂的科学问题。这是并行计算的基础，尽管它不使用专门的并行超级计算机，这种超级计算机内部由十至上万个独立处理器组成。但它却使用商业系统，如通过高速连接来链接的一组单处理器或双处理器 PC，并且在公共消息传递层上进行通信以运行并行应用程序。因此，您会常常听说又有一种便宜的 Linux 超级计算机问世了。但它实际是一个计算机集群，其处理能力与真的超级计算机相等。</p><a id="more"></a><h3 id="什么是分布式">什么是分布式</h3><p>分布式服务顾名思义服务是分散部署在不同的机器上的，一个服务可能负责几个功能，是一种面向 SOA 架构的，服务之间也是通过 RPC 来交互或者是 Webservice 来交互的。</p><p>分布式部署是指将多台服务器集中在一起，每台服务器都实现总体中的不同业务，做不同的事情。各分开部署的部分彼此通过各种通讯协议交互信息，并且每台服务器都缺一不可，如果某台服务器故障，则部分功能缺失，或导致整体无法运行。</p><p>分布式存在的主要作用是大幅度的提高效率，缓解服务器的访问和存储压力。区别分布式的方式是一个业务分拆多个子业务，部署在不同的服务器上。</p><p>例如：将一个大的系统划分为多个业务模块，业务模块分别部署到不同的机器上，各个业务模块之间通过接口进行数据交互。</p><p><img src="https://img-blog.csdn.net/20170213134043567" alt=""></p><p>上面：service A、B、C、D 分别是业务组件，通过 API Geteway 进行业务访问。</p><h3 id="什么是微服务">什么是微服务</h3><p>微服务的概念和分布式比较相似，微服务是一种架构风格。简单来说微服务就是很小的服务，小到一个服务只对应一个单一的功能。每个微服务仅关注于完成一件任务并很好地完成该任务，这个服务可以单独部署运行。 各个微服务之间是松耦合的，服务之间可以通过 RPC 来相互交互。每个微服务都是由独立的小团队开发、测试、部署，上线，负责它的整个生命周期。</p><p>在做架构设计的时候，先做逻辑架构，再做物理架构。当你拿到需求后，估算过最大用户量和并发量后，计算单个应用服务器能否满足需求，如果用户量只有几百人的小应用，单体应用就能搞定，即所有应用部署在一个应用服务器里。如果是很大用户量，且某些功能会被频繁访问，或者某些功能计算量很大，建议将应用拆解为多个子系统，各自负责各自功能，这就是微服务架构。</p><p>微服务的设计是为了不因为某个模块的升级和 BUG 影响现有的系统业务。微服务与分布式的细微差别是，微服务的应用不一定是分散在多个服务器上，它也可以是同一个服务器。</p><p>微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低。由于每个微服务都由独立的小团队负责，因此它敏捷性更高。分布式服务最后都会向微服务架构演化，这是一种趋势。不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难。</p><h3 id="分布式-集群-微服务的异同及联系">分布式、集群、微服务的异同及联系</h3><ol><li>分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。</li></ol><p>例如：如果一个任务由 10 个子任务组成，每个子任务单独执行需 1 小时，则在一台服务器上执行该任务需 10 小时。</p><ul><li><p>采用分布式方案，提供 10 台服务器，每台服务器只负责处理一个子任务，不考虑子任务间的依赖关系，执行完这个任务只需一个小时。(这种工作模式的一个典型代表就是 Hadoop 的 Map/Reduce 分布式计算模型）</p></li><li><p>而采用集群方案，同样提供 10 台服务器，每台服务器都能独立处理这个任务。假设有 10 个任务同时到达，10 个服务器将同时工作，1 小时后，10 个任务同时完成，这样，整身来看，还是 1 小时内完成一个任务。</p></li></ul><blockquote><p>注：分布式需要做好事务管理。</p></blockquote><ol start="2"><li>集群模式是不同服务器部署同一套服务对外访问，实现服务的负载均衡。区别集群的方式是根据部署多台服务器业务是否相同，分布式中的每一个节点，都可以做集群。而集群并不一定就是分布式的。</li></ol><p>举例：就比如新浪网，访问的人多了，他可以做一个群集，前面放一个响应服务器，后面几台服务器完成同一业务，如果有业务访问的时候，响应服务器看哪台服务器的负载不是很重，就将给哪一台去完成。</p><p>而分布式，从窄意上理解，也跟集群差不多。但是它的组织比较松散，不像集群有一个组织性，一台服务器垮了，其它的服务器可以顶上来。分布式的每一个节点，都完成不同的业务，一个节点垮了，那这个业务就不可访问了。</p><blockquote><p>注：集群模式需要做好 Session 共享，确保在不同服务器切换的过程中不会因为没有获取到 Session 而中止退出服务。</p></blockquote><ul><li>分布式是否属于微服务？</li></ul><p>答案是肯定的。分布式和微服务的架构很相似，只是部署的方式不一样而已。</p><p>生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。</p><ul><li>在开发中我们可以将分布式和集群分开吗？</li></ul><p>针对这个问题，我们可以根据分布式的介绍看出，其主要的功能是用了将我们的系统模块化，将系统进行解耦的，方便我们的维护和开发的，但是其并不能解决我们的并发问题，也无法保证我们的系统在服务器宕机后的正常运转。</p><p>而集群呢？其恰好弥补了分布式的缺陷。集群，就是多个服务器处理相同的业务，这在一方面可以解决或者说改善我们系统的并发问题，一方面可以解决我们服务器如果出现一定数量的宕机后，系统仍然可以正常运转。</p><p>好的设计应该是分布式和集群的结合，先分布式再集群，具体实现就是业务拆分成很多子业务，然后针对每个子业务进行集群部署，这样每个子业务如果出了问题，整个系统完全不会受影响。</p><p>因此分布式和集群是一对好基友，谁也离不开谁。</p><h3 id="参考文档">参考文档</h3><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="http://t.cn/E9VjXwt" target="_blank" rel="noopener">http://t.cn/E9VjXwt</a></li><li><a href="http://t.cn/E9VRNNh" target="_blank" rel="noopener">http://t.cn/E9VRNNh</a></li><li><a href="http://t.cn/E9VeGiu" target="_blank" rel="noopener">http://t.cn/E9VeGiu</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是集群&quot;&gt;什么是集群&lt;/h3&gt;
&lt;p&gt;集群是是指将多台服务器集中在一起，每台服务器都实现相同的业务，做相同的事情。但是每台服务器并不是缺一不可，存在的作用主要是缓解并发压力和单点故障转移问题。可以利用一些廉价的符合工业标准的硬件构造高扩展、高性能、低成本、高可用的系统。&lt;/p&gt;
&lt;p&gt;集群主要具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伸缩性（Scalability）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一些大的系统中，预测最终用户的数量和行为是非常困难的，伸缩性是指系统适应不断增长的用户数的能力。提高这种并发会话能力的一种最直观的方式就增加资源（CPU，内存，硬盘等），集群是解决这个问题的另一种方式，它允许一组服务器组在一起，像单个服务器一样分担处理一个繁重的任务，我们只需要将新的服务器加入集群中即可，对于客户来看，服务无论从连续性还是性能上都几乎没有变化，好像系统在不知不觉中完成了升级。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高可用性（High availability）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;单一服务器的解决方案并不是一个健壮方式，因为容易出现单点失效。像银行、账单处理这样一些关键的应用程序是不能容忍哪怕是几分钟的死机。它们需要这样一些服务在任何时间都可以访问并在可预期的合理的时间周期内有响应。高可用性集群的出现是为了使集群的整体服务尽可能可用，以便考虑计算硬件和软件的易错性。如果高可用性集群中的主节点发生了故障，那么这段时间内将由次节点代替它。次节点通常是主节点的镜像，所以当它代替主节点时，它可以完全接管其身份，并且因此使系统环境对于用户是一致的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡（Load balancing）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;负载均衡集群为企业需求提供了更实用的系统。如名称所暗示的，该系统使负载可以在计算机集群中尽可能平均地分摊处理。该负载可能是需要均衡的应用程序处理负载或网络流量负载。这样的系统非常适合于运行同一组应用程序的大量用户。每个节点都可以处理一部分负载，并且可以在节点之间动态分配负载，以实现平衡。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高性能 (High Performance)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，这种涉及为集群开发并行编程应用程序，以解决复杂的科学问题。这是并行计算的基础，尽管它不使用专门的并行超级计算机，这种超级计算机内部由十至上万个独立处理器组成。但它却使用商业系统，如通过高速连接来链接的一组单处理器或双处理器 PC，并且在公共消息传递层上进行通信以运行并行应用程序。因此，您会常常听说又有一种便宜的 Linux 超级计算机问世了。但它实际是一个计算机集群，其处理能力与真的超级计算机相等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="分布式" scheme="https://www.hi-linux.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用 Sysdig 进行监控和调试 Linux 机器</title>
    <link href="https://www.hi-linux.com/posts/9561.html"/>
    <id>https://www.hi-linux.com/posts/9561.html</id>
    <published>2020-05-23T02:26:00.000Z</published>
    <updated>2020-05-23T15:22:46.161Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="sysdig-简介">Sysdig 简介</h3><p><code>Sysdig</code> 官网 上对自己的介绍是：</p><blockquote><p>Open Source Universal System Visibility With Native Contaier Support.</p></blockquote><p>它的定位是系统监控、分析和排障的工具，其实在 <code>Linux</code> 平台上，已经有很多这方面的工具 <code>strace</code>、<code>tcpdump</code>、<code>htop</code>、<code>iftop</code>、<code>lsof</code>、<code>netstat</code>，它们都能用来分析 <code>Linux</code> 系统的运行情况，而且还有很多日志、监控工具。为什么还需要 <code>Sysdig</code> 呢？在我看来，<code>Sysdig</code> 的优点可以归纳为三个词语：整合、强大、灵活。</p><h4 id="整合">整合</h4><p>虽然 <code>Linux</code> 有很多系统分析和调优的工具，但是它们一般都负责某个特殊的功能，并且使用方式有很大的差异，如果要分析和定位问题，一般都需要熟练掌握需要命令的使用。而且这些工具的数据无法进行共享，只能相互独立工作。<code>Sysdig</code> 一个工具就能实现上述所有工具的功能，并且提供了统一的使用语法。</p><h4 id="强大">强大</h4><p><code>Sysdig</code> 能获取实时的系统数据，也能把信息保存到文件中以供后面分析。捕获的数据包含系统的个个方面：</p><ul><li>全方面的系统参数：CPU、Memory、Disk IO、网络 IO</li><li>支持各种 IO 活动：进程、文件、网络连接等</li></ul><p>除了帮你捕获信息之外，<code>Sysdig</code> 还预先还有有用的工具来分析这些数据，从大量的数据中找到有用的信息变得非常简单。比如你能还简单地做到下面这些事情：</p><ul><li>按照 CPU 的使用率对进程进行排序，找到 CPU 使用率最高的那个</li><li>按照发送网络数据报文的多少对进程进行排序</li><li>找到打开最多文件描述符的进程</li><li>查看哪些进程修改了指定的文件</li><li>打印出某个进程的 HTTP 请求报文</li><li>找到用时最久的系统调用</li><li>查看系统中所有的用户都执行了哪些命令</li><li>……</li></ul><p>基本上自带的工具就能满足大部分的分析需求。</p><a id="more"></a><h4 id="灵活">灵活</h4><p><code>Sysdig</code> 有着类似于 <code>tcpdump</code> 的过滤语法，用户可以随意组合自己的过滤逻辑，从茫茫的数据中找到关心的信息。除此之外，用户还可以自己编写 <code>Lua</code> 脚本来自定义分析逻辑，基本上不受任何限制。</p><h4 id="工作原理">工作原理</h4><p><code>Sysdig</code> 通过在内核的 driver 模块注册系统调用的 hook，这样当有系统调用发生和完成的时候，它会把系统调用信息拷贝到特定的 buffer，然后用户模块的组件对数据信息处理（解压、解析、过滤等），并最终通过 <code>Sysdig</code> 命令行和用户进行交互。</p><p><img src="https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/2014/04/Blog2-pic3-1024x886.png" alt=""></p><p>更多的原理可以参考官方博客</p><p>除了 <code>Sysdig</code> 命令之外，还有一个基于终端的 UI 命令 <code>Csysdig</code>，它类似于 <code>top</code> 命令，定时对系统情况进行刷新，并且可以让用户交互。这篇文章我们只介绍 <code>Sysdig</code>，不会讲解 <code>Csysdig</code> 的使用。</p><h3 id="安装">安装</h3><p><code>Sysdig</code> 的安装在官方文档中有详细的说明，这里不再赘述。需要注意的是，<code>Sysdig</code> 对内核版本有一定的要求，请保证内核不要太旧。</p><p>另外，如果使用容器的方式安装，需要把主机的很多系统目录 mount 到容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --name sysdig --privileged -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;host&#x2F;var&#x2F;run&#x2F;docker.sock -v &#x2F;dev:&#x2F;host&#x2F;dev -v &#x2F;proc:&#x2F;host&#x2F;proc:ro -v &#x2F;boot:&#x2F;host&#x2F;boot:ro -v &#x2F;lib&#x2F;modules:&#x2F;host&#x2F;lib&#x2F;modules:ro -v &#x2F;usr:&#x2F;host&#x2F;usr:ro sysdig&#x2F;sysdig</span><br></pre></td></tr></table></figure><h3 id="sysdig-基本用法">Sysdig 基本用法</h3><h4 id="基本格式">基本格式</h4><p>直接在终端输入 <code>sysdig</code> 就能开始捕获系统信息，这个命令需要系统管理员权限，执行后你会看到终端有持续不断的输出流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysdig</span><br></pre></td></tr></table></figure><p>因为系统每时每刻都有大量的系统调用产生，这样是没办法看清更无法分析输出信息的，可以先使用 CTRL + c 来退出命令。</p><p>在讲解如何使用 <code>Sysdig</code> 的参数之前，我们先来解释一下它的输出格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5352209 11:54:08.853479695 0 ssh-agent (13314) &lt; getrusage</span><br><span class="line">5352210 11:54:08.853481094 0 ssh-agent (13314) &gt; clock_gettime</span><br><span class="line">5352211 11:54:08.853482049 0 ssh-agent (13314) &lt; clock_gettime</span><br><span class="line">5352226 11:54:08.853510313 0 ssh-agent (13314) &gt; getrusage</span><br><span class="line">5352228 11:54:08.853511089 0 ssh-agent (13314) &lt; getrusage</span><br><span class="line">5352229 11:54:08.853511646 0 ssh-agent (13314) &gt; clock_gettime</span><br><span class="line">5352231 11:54:08.853512020 0 ssh-agent (13314) &lt; clock_gettime</span><br><span class="line">5352240 11:54:08.853530285 0 ssh-agent (13314) &gt; stat</span><br><span class="line">5352241 11:54:08.853532329 0 ssh-agent (13314) &lt; stat res&#x3D;0 path&#x3D;&#x2F;home&#x2F;cizixs&#x2F;.ssh</span><br><span class="line">5352242 11:54:08.853533065 0 ssh-agent (13314) &gt; stat</span><br><span class="line">5352243 11:54:08.853533990 0 ssh-agent (13314) &lt; stat res&#x3D;0 path&#x3D;&#x2F;home&#x2F;cizixs&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line">5353954 11:54:08.857382204 0 ssh-agent (13314) &gt; write fd&#x3D;16 size&#x3D;280</span><br></pre></td></tr></table></figure><p>所有的输入都是按照行来分割的，每行都是一条记录，由多个列组成，默认的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%evt.num %evt.outputtime %evt.cpu %proc.name (%thread.tid) %evt.dir %evt.type %evt.info</span><br></pre></td></tr></table></figure><p>各个字段的含义如下：</p><ul><li>evt.num： 递增的事件号。</li><li>evt.time： 事件发生的时间。</li><li>evt.cpu： 事件被捕获时所在的 CPU，也就是系统调用是在哪个 CPU 执行的。比较上面的例子中，值 0 代表机器的第一个 CPU。</li><li><a href="http://proc.name" target="_blank" rel="noopener">proc.name</a>： 生成事件的进程名字，也就是哪个进程在运行。</li><li>thread.tid： 线程的 id，如果是单线程的程序，这也是进程的 pid。</li><li>evt.dir： 事件的方向（direction），&gt; 代表进入事件，&lt; 代表退出事件。</li><li>evt.type： 事件的名称，比如 open、stat等，一般是系统调用。</li><li>evt.args： 事件的参数。如果是系统调用，这些对应着系统调用的参数。</li></ul><h4 id="过滤">过滤</h4><p>完整的 <code>Sysdig</code> 使用方法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysdig [option]...  [filter]</span><br></pre></td></tr></table></figure><p>因为 <code>Sysdig</code> 的输出内容很多，不管是监控还是查问题我们要关注的事件只是其中很小的一部分。这个时候就要用到过滤的功能，找到感兴趣的事件。<code>Sysdig</code> 的过滤功能很强大，不仅支持的过滤项很多，而且还能够自由地进行逻辑组合。</p><p><code>Sysdig</code> 的过滤器也是分成不同类别的，比如:</p><ul><li>fd: 对文件描述符（file descriptor）进行过滤，比如 fd 标号（fd.num）、fd 名字（<a href="http://fd.name" target="_blank" rel="noopener">fd.name</a>）。</li><li>process: 进程信息的过滤，比如进程 id（<a href="http://proc.id" target="_blank" rel="noopener">proc.id</a>）、进程名（<a href="http://proc.name" target="_blank" rel="noopener">proc.name</a>）。</li><li>evt: 事件信息的过滤，比如事件编号、事件名。</li><li>user: 用户信息的过滤，比如用户 id、用户名、用户 home 目录、用户的登录 shell（user.shell）。</li><li>syslog: 系统日志的过滤，比如日志的严重程度、日志的内容。</li><li>fdlist: poll event 的文件描述符的过滤。</li></ul><p>完整的过滤器列表可以使用 <code>sysdig -l</code> 来查看，比如可以查看建立 TCP 连接的事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysdig evt.type&#x3D;accept</span><br></pre></td></tr></table></figure><p>过滤器除了直接的相等比较之外，还有其他操作符，包括 =、!=、&gt;=、&gt;、&lt;、&lt;=、contains、in 和 exists，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig fd.name contains &#x2F;etc</span><br><span class="line">$ sysdig &quot;evt.type in ( &#39;select&#39;, &#39;poll&#39; )&quot;</span><br><span class="line">$ sysdig proc.name exists</span><br></pre></td></tr></table></figure><p>更酷的是，多个过滤条件还可以通过 and、or 和 not 进行逻辑组合，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig &quot;not (fd.name contains &#x2F;proc or fd.name contains &#x2F;dev)&quot;</span><br></pre></td></tr></table></figure><p>这些强大的功能综合到一起，就能让我们很容易定位到需要的事件，分析和监控更有目的性。</p><h4 id="自定义输出格式">自定义输出格式</h4><p>标准的输出已经打印出常用的信息，sysdig 还允许你自定义打印出的内容，参数 <code>-p</code> 可以加上类似于 C 语言 printf 字符串，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -p&quot;user:%user.name dir:%evt.arg.path&quot; evt.type&#x3D;chdir</span><br><span class="line">user:ubuntu dir:&#x2F;root</span><br><span class="line">user:ubuntu dir:&#x2F;root&#x2F;tmp</span><br><span class="line">user:ubuntu dir:&#x2F;root&#x2F;Download</span><br></pre></td></tr></table></figure><p>上面的信息，可以很容易看到用户更改当前目录的情况。从上面的例子也可以使用 <code>-p</code> 的使用方法：</p><ul><li>字段必须用 % 作为前缀，所有在 <code>sysdig -l</code> 中列出来的字段都可以使用</li><li>你可以在字符串中加入其他可读性的内容，它们会如实打印出来</li><li>如果某个字段在时间中不存在，默认这个事件会过滤掉，在这个字符串最前面加上 * 符号，会打印出所有的事件，不存在的字段会变成 <na>，比如:</na></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -p&quot;*%evt.type %evt.dir %evt.arg.name&quot; evt.type&#x3D;open</span><br><span class="line">open &gt; &lt;NA&gt;</span><br><span class="line">open &lt; &#x2F;proc&#x2F;1285&#x2F;task&#x2F;1399&#x2F;stat</span><br><span class="line">open &gt; &lt;NA&gt;</span><br><span class="line">open &lt; &#x2F;proc&#x2F;1285&#x2F;task&#x2F;1400&#x2F;io</span><br><span class="line">open &gt; &lt;NA&gt;</span><br><span class="line">open &lt; &#x2F;proc&#x2F;1285&#x2F;task&#x2F;1400&#x2F;statm</span><br><span class="line">open &gt; &lt;NA&gt;</span><br></pre></td></tr></table></figure><h4 id="保存到文件">保存到文件</h4><p>尽管可以用过滤器减少输出，直接在终端查看事件流还是没有办法让我们进行深入分析。和 <code>tcpdump</code> 工具类似，<code>Sysdig</code> 也允许你把捕获的时间保存到本地的文件，然后再读取文件的内容进行分析。</p><p>保存到文件可以通过 <code>-w</code> 实现，从文件中读取需要 <code>-r</code> 参数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 捕获事件，并保存到文件中，这样在终端是看不到输出的。</span><br><span class="line">$ sudo sysdig -w sysdig-trace-file.scap</span><br><span class="line"></span><br><span class="line"># 从文件中读取 Sysdig 格式的事件进行分析。</span><br><span class="line">$ sudo sysdig -r sysdig-trace-file.scap</span><br></pre></td></tr></table></figure><p>另一个有用的功能是，你可以控制捕获到文件的内容。通常情况下，<code>Sysdig</code> 捕获了系统所有的活动，因此这些数据会很大，如果一直捕获的话，会造成磁盘空间的浪费，<code>Sysdig</code> 提供了类似于 <code>logrotate</code> 的方式，让你只保存最新捕获的文件。</p><p>控制捕获文件大小的一个办法是在捕获的使用使用过滤器，之外，你还可以通过 <code>-n 2000</code> 指定捕获 2000 条事件之后就退出，或者通过 <code>logrotate</code> 的方式来滚动文件：</p><ul><li><code>sysdig -C 5 -W 10 -w dump.pcap</code> ：保证每个文件不超过 5M 大小，并且只保存最近的 10 个文件</li><li><code>sysdig -G 60 -W 60 -w dump.pcap</code>：每个文件只保存一分钟内的系统活动（-G 60），并且只保存 60 个文件，也就是说捕获最近一个小时的系统活动，每分钟的数据一个文件</li><li><code>sysdig -e 1000 -W 5 -w dump.scap</code>：保存 5 个文件，每个文件只有 1000 个事件</li></ul><p>当使用 <code>-w</code> 保存文件的使用，还可以使用 <code>-z</code> 参数对保存的内容进行压缩，进一步减少占用的空间。</p><p>读取的时候也可以使用过滤器，如果我们只关心 write 系统调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -r sysdig-trace-nano.scap evt.type&#x3D;write</span><br></pre></td></tr></table></figure><p>而且读取的时候也可以进一步对文件进行分割，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -r dump.scap -G 300 -z -w segments.scap</span><br></pre></td></tr></table></figure><p>这个命令，就是读取 dump.scap 文件的内容，并且把它分割成五分钟（-G 300s）的多个文件。</p><h4 id="常用的参数">常用的参数</h4><p>除了上面介绍的过滤器参数，<code>Sysdig</code> 还有很多可用的参数，完整的列表和解释请参考 <code>man sysdig</code> 文档。这里介绍一下比较常用的：</p><ul><li>-A --print-ascii：把 buffer 中数据按照 ASCII 格式打印，方便用户阅读</li><li>-x --print-hex： 把 buffer 中数据按照十六进制格式打印</li><li>-X --print-hex-ascii： 把 buffer 中数据同时按照 ASCII 格式和十六进制格式打印</li><li>-s 1024：捕获 buffer 的数据大小，默认为 80，如果这个值设置的过大，会产生很大的文件</li><li>-N：不用把端口号转换成可读的名字，这个参数会提高处理的效率</li></ul><h3 id="chisels实用的工具箱">Chisels：实用的工具箱</h3><p>虽然有了过滤器和文件的输入输出，加上 <code>Sysdig</code> 其他的参数，我们可以按照需求去分析和监控系统了，但是很多场景需要更复杂的数据聚合。<code>Sysdig</code> 提供了另外一个强大的功能：<code>chisels</code>，它们是一组预定义的功能集合，通过 <code>Lua</code> 脚本实现，用来分析特定的场景。</p><p>可以通过 <code>sudo sysdig -cl</code> 列出支持的所有 <code>chisels</code>，我们来解释一些比较常用的 <code>chisels</code>：</p><ul><li>httplog：输出所有的 HTTP 请求。</li><li>topprocs_cpu：输出按照 CPU 使用率排序的进程列表。</li><li>echo_fds：输出进程读写的数据。</li><li>netstat：列出网络的连接情况。</li><li>spy_file：输出文件的读写数据，可以提供某个文件名作为参数，这样就只输出该文件的读写内容。</li></ul><p>有些 <code>chisel</code> 可能需要参数才能正常运行，如果要了解某个 <code>chisel</code> 的具体使用说明，可以用 <code>-i</code> 参数，比如要了解 <code>spy_file</code> 的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysdig -i spy_file</span><br><span class="line"></span><br><span class="line">Category: I&#x2F;O</span><br><span class="line">-------------</span><br><span class="line">spy_file        Echo any read&#x2F;write made by any process to all files. Optionall</span><br><span class="line">                y, you can provide the name of one file to only intercept reads</span><br><span class="line">                &#x2F;writes to that file.</span><br><span class="line"></span><br><span class="line">This chisel intercepts all reads and writes to all files. Instead of all files,</span><br><span class="line"> you can limit interception to one file.</span><br><span class="line">Args:</span><br><span class="line">[string] read_or_write - Specify &#39;R&#39; to capture only read event</span><br><span class="line">                s; &#39;W&#39; to capture only write events; &#39;RW&#39; to capture read and w</span><br><span class="line">                rite events. By default both read and write events are captured</span><br><span class="line">                .</span><br><span class="line">[string] spy_on_file_name - The name of the file which the chis</span><br><span class="line">                el should spy on for all read and write activity.</span><br></pre></td></tr></table></figure><p>文章最开始的时候，我提到过 <code>Sysdig</code> 可以满足大部分的日常分析，它们主要就是通过 <code>chisel</code> 完成的。比如：</p><p>按照网络的使用情况对进程进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sysdig -c topprocs_net</span><br></pre></td></tr></table></figure><p>按照建立连接数量对进程进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -c fdcount_by fd.sport &quot;evt.type&#x3D;accept&quot;</span><br></pre></td></tr></table></figure><p>查看系统中用户执行的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -r sysdig.pcap -c spy_users</span><br></pre></td></tr></table></figure><p>更多的使用案例，可以参考 Sysdig Example 这篇 wiki。</p><p>在 <code>Linux</code> 机器上，这些 <code>chisel</code> 保存在 /usr/share/sysdig/chisels 文件夹中，每个 <code>chisel</code> 对应一个 <code>Lua</code> 脚本文件。如果提供的这些 <code>chisel</code> 还不能满足需求，用户也可以根据需求编写自己的 <code>chisel</code>。</p><h3 id="对容器的支持">对容器的支持</h3><p><code>Sysdig</code> 另外一个优势是它对容器（ <code>Docker</code> 和 <code>Kubernetes</code> ）的良好支持，这对于目前采用了容器化的系统管理员来说是很好的福利。</p><p>使用 <code>-pc</code> 参数就能自动在打印的事件中添加上容器的信息（容器名、容器 id 等），比如捕获 container 名字为 zen_knuth 的所有系统活动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -pc container.name&#x3D;zen_knuth</span><br></pre></td></tr></table></figure><p>对容器的分析和原来的一样，只要通过 container.name=apache 指定要分析的容器名字就行，比如查看某个容器的网络连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysdig -pc -c topconns container.name&#x3D;wordpress1</span><br></pre></td></tr></table></figure><p>要集成 <code>Kubernetes</code> 系统监控的话，使用 <code>-k http://master_ip:8080</code> 参数，后面是 apiserver 的地址，如果 apiserver 需要认证的话，需要指定 <code>-K filename</code> 来说明 apiserver CA 证书的文件地址。关于 <code>Kubernetes</code> 的监控和分析不是这篇文章的重点，读者可以参数 <code>Sysdig</code> 的博客或者其他文档。</p><h3 id="csysdig图形化的-sysdig">Csysdig：图形化的 Sysdig</h3><p><code>Sysdig</code> 还提供了另外一个图形化的工具：<code>Csysdig</code>，它的界面和 top/htop 命令相似，并且可以接受用户的交互。</p><p><img src="https://assets.digitalocean.com/articles/sysdig_ubuntu_1604/LEhCwvI.jpg" alt=""></p><p>和 <code>Sysdig</code> 一样，<code>Csysdig</code> 可以实时捕获系统事件，也可以读取之前保存的文件。</p><h3 id="更多文档">更多文档</h3><p>这篇文章介绍的都出入门的、基础概念性的知识，如果读者希望进一步了解 sysdig，不妨继续阅读下面这些文章：</p><ul><li>sysdig 和传统的 strace、htop、lsof、tcpdump、iftop命令的比较</li><li>理解 sysdig 的输出</li><li>sysdig twitter 账号 #digoftheday</li></ul><h3 id="参考资料">参考资料</h3><p>这篇文章主要参考了一下的博客、文章和资料：</p><ul><li>Sysdig User Guide</li><li>Linux Troubleshooting Cheatsheet: strace, htop, lsof, tcpdump, iftop &amp; sysdig</li><li>DigitalOcean: How To Monitor Your Ubuntu 16.04 System with Sysdig</li><li>Sysdig vs DTrace vs Strace: a Technical Discussion</li><li>用 Sysdig 监控服务器和 Docker 容器</li></ul><blockquote><p>来源：Cizixs Blogs</p><p>原文：<a href="https://tinyurl.com/yc3tm4bf" target="_blank" rel="noopener">https://tinyurl.com/yc3tm4bf</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Sysdig-简介&quot;&gt;Sysdig 简介&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Sysdig&lt;/code&gt; 官网 上对自己的介绍是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Open Source Universal System Visibility With Native Contaier Support.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它的定位是系统监控、分析和排障的工具，其实在 &lt;code&gt;Linux&lt;/code&gt; 平台上，已经有很多这方面的工具 &lt;code&gt;strace&lt;/code&gt;、&lt;code&gt;tcpdump&lt;/code&gt;、&lt;code&gt;htop&lt;/code&gt;、&lt;code&gt;iftop&lt;/code&gt;、&lt;code&gt;lsof&lt;/code&gt;、&lt;code&gt;netstat&lt;/code&gt;，它们都能用来分析 &lt;code&gt;Linux&lt;/code&gt; 系统的运行情况，而且还有很多日志、监控工具。为什么还需要 &lt;code&gt;Sysdig&lt;/code&gt; 呢？在我看来，&lt;code&gt;Sysdig&lt;/code&gt; 的优点可以归纳为三个词语：整合、强大、灵活。&lt;/p&gt;
&lt;h4 id=&quot;整合&quot;&gt;整合&lt;/h4&gt;
&lt;p&gt;虽然 &lt;code&gt;Linux&lt;/code&gt; 有很多系统分析和调优的工具，但是它们一般都负责某个特殊的功能，并且使用方式有很大的差异，如果要分析和定位问题，一般都需要熟练掌握需要命令的使用。而且这些工具的数据无法进行共享，只能相互独立工作。&lt;code&gt;Sysdig&lt;/code&gt; 一个工具就能实现上述所有工具的功能，并且提供了统一的使用语法。&lt;/p&gt;
&lt;h4 id=&quot;强大&quot;&gt;强大&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Sysdig&lt;/code&gt; 能获取实时的系统数据，也能把信息保存到文件中以供后面分析。捕获的数据包含系统的个个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全方面的系统参数：CPU、Memory、Disk IO、网络 IO&lt;/li&gt;
&lt;li&gt;支持各种 IO 活动：进程、文件、网络连接等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了帮你捕获信息之外，&lt;code&gt;Sysdig&lt;/code&gt; 还预先还有有用的工具来分析这些数据，从大量的数据中找到有用的信息变得非常简单。比如你能还简单地做到下面这些事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照 CPU 的使用率对进程进行排序，找到 CPU 使用率最高的那个&lt;/li&gt;
&lt;li&gt;按照发送网络数据报文的多少对进程进行排序&lt;/li&gt;
&lt;li&gt;找到打开最多文件描述符的进程&lt;/li&gt;
&lt;li&gt;查看哪些进程修改了指定的文件&lt;/li&gt;
&lt;li&gt;打印出某个进程的 HTTP 请求报文&lt;/li&gt;
&lt;li&gt;找到用时最久的系统调用&lt;/li&gt;
&lt;li&gt;查看系统中所有的用户都执行了哪些命令&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上自带的工具就能满足大部分的分析需求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Sysdig" scheme="https://www.hi-linux.com/tags/Sysdig/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中 Pstree 命令使用指南</title>
    <link href="https://www.hi-linux.com/posts/35899.html"/>
    <id>https://www.hi-linux.com/posts/35899.html</id>
    <published>2020-05-23T02:25:00.000Z</published>
    <updated>2020-05-23T15:22:46.159Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在 Linux 机器上工作时，有时你可能需要找出当前正在运行的进程。你可以使用许多命令来查找有关正在运行的进程的信息，其中 <code>ps</code> 和 <code>top</code> 是最常用的命令。</p><p>在本文中，我们将讨论 <code>pstree</code> 命令。它类似于 <code>ps</code> ，但没有列出正在运行的进程，而是将它们显示在一个目录树中。树状格式是以一种更方便的方式来显示进程层次结构，并使输出在视觉上更具吸引力。</p><h2 id="如何使用-pstree-命令">如何使用 pstree 命令</h2><p><code>pstree</code> 命令的一般语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [OPTIONS] [USER or PID]</span><br></pre></td></tr></table></figure><p>以最简单的形式调用时没有任何选项或参数，<code>pstree</code> 命令将显示所有正在运行的进程的分层树结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ pstree</span><br><span class="line">systemd─┬─VBoxService───7*[&#123;VBoxService&#125;]</span><br><span class="line">        ├─accounts-daemon───2*[&#123;accounts-daemon&#125;]</span><br><span class="line">        ├─2*[agetty]</span><br><span class="line">        ├─atd</span><br><span class="line">        ├─cron</span><br><span class="line">        ├─dbus-daemon</span><br><span class="line">        ├─irqbalance───&#123;irqbalance&#125;</span><br><span class="line">        ├─2*[iscsid]</span><br><span class="line">        ├─lvmetad</span><br><span class="line">        ├─lxcfs───2*[&#123;lxcfs&#125;]</span><br><span class="line">        ├─networkd-dispat───&#123;networkd-dispat&#125;</span><br><span class="line">        ├─nginx───2*[nginx]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><a id="more"></a><p>目录树中的 <code>top/root</code> 项目是所有系统进程的父进程。在此示例中为 <code>systemd</code>，这是系统启动时启动的第一个进程。</p><p><code>pstree</code> 通过将相同的分支放在方括号之间并为它们加上代表分支数的整数作为前缀来合并它们，这使得输出更具可读性和视觉吸引力。以下是显示如何使用方括号的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pstree</span><br><span class="line">├─2*[agetty]</span><br></pre></td></tr></table></figure><p>要禁用相同分支的合并，请使用 <code>-c</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -c</span><br><span class="line">├─agetty        </span><br><span class="line">├─agetty</span><br></pre></td></tr></table></figure><p>每个进程的线程显示在父进程下，并使用花括号内的进程名称显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">├─lxcfs───2*[&#123;lxcfs&#125;]</span><br></pre></td></tr></table></figure><p>你可以使用 <code>-t</code> 选项显示完整的线程名称，如果要隐藏线程并仅显示进程，请使用 <code>-T</code> 选项。</p><p>通常，<code>pstree</code> 会在屏幕上显示多行输出。要一次查看输出一页，你可以将其结果通过管道传递到 <code>less</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pstree | less</span><br></pre></td></tr></table></figure><p>如果使用用户名作为参数，则 <code>pstree</code> 仅显示该用户拥有的进程。例如，以下命令将仅显示那些由名为 myfreax 的用户启动的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pstree myfreax</span><br></pre></td></tr></table></figure><p>如果将 <code>PID</code> 指定为参数，则 <code>pstree</code> 将显示一棵以给定进程为树根的目录树。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pstree 1943</span><br><span class="line">sshd───bash───pstree</span><br></pre></td></tr></table></figure><p>要显示给定进程的父进程，你可以使用 <code>-s</code> 选项，并在其后跟进程 <code>PID</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -s 1943</span><br><span class="line">systemd───sshd───sshd───bash───pstree</span><br></pre></td></tr></table></figure><h2 id="显示-pid-和-pgid">显示 PID 和 PGID</h2><p>通常，当运行 <code>pstree</code> 命令时，用户寻找的最重要的信息是进程 ID。例如，你知道 PID 即可让你杀死发生故障的进程。</p><p>我们可以通过 <code>-p</code> 选项让 <code>pstree</code> 显示进程的 <code>PID</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个进程或线程后的括号中均显示的是 PID。</span></span><br><span class="line">$ pstree -p</span><br><span class="line">systemd(1)─┬─VBoxService(955)─┬─&#123;VBoxService&#125;(956)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(957)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(958)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(959)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(960)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(961)</span><br><span class="line">           │                  └─&#123;VBoxService&#125;(962)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>默认情况下，<code>pstree</code> 按名称对具有相同父项的进程进行排序。 如果你想按 <code>PID</code> 排序，你则可以使用 <code>-n</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -pn</span><br></pre></td></tr></table></figure><p>一个或多个进程组 ID 是进程组的第一个成员的进程 ID。如果你要查看 <code>PGID</code>，可以使用 <code>-g</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个进程或线程之后的括号中也显示了 PID。</span></span><br><span class="line">$ pstree -g</span><br><span class="line">systemd(1)─┬─VBoxService(954)─┬─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  ├─&#123;VBoxService&#125;(954)</span><br><span class="line">           │                  └─&#123;VBoxService&#125;(954)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>注：显示 <code>PID</code> 或 <code>PGID</code> 时，将隐式禁用默认的进程合并。</p></blockquote><h2 id="显示命令行参数">显示命令行参数</h2><p>默认情况下，<code>pstree</code> 不会向你显示正在运行的进程的命令行参数。要查看进程是如何开始的，你可以使用 <code>-a</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -a</span><br><span class="line">...</span><br><span class="line">  ├─agetty -o -p -- \\u --keep-baud 115200,38400,9600 ttyS0 vt220</span><br><span class="line">  ├─agetty -o -p -- \\u --noclear tty1 linux</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="高亮">高亮</h2><p><code>pstree</code> 还可以使你突出显示进程以更好地呈现视觉效果。-h 选项指示 <code>pstree</code> 高亮显示当前进程及其所有父进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -h</span><br></pre></td></tr></table></figure><p>如果要高亮显示特定的进程，你可以使用 <code>-H</code> 选项，然后加上进程 ID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -H PID_NUMBER</span><br></pre></td></tr></table></figure><h2 id="结论">结论</h2><p>至此，我们就讲完了以树结构的形式显示正在运行的进程的 <code>pstree</code> 命令。有关所有可用 <code>pstree</code> 选项的信息，你可以通过在终端中输入 <code>man pstree</code> 进行查看。</p><blockquote><p>来源：myfreax</p><p>原文：<a href="https://url.cn/5yQDYSA" target="_blank" rel="noopener">https://url.cn/5yQDYSA</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Linux 机器上工作时，有时你可能需要找出当前正在运行的进程。你可以使用许多命令来查找有关正在运行的进程的信息，其中 &lt;code&gt;ps&lt;/code&gt; 和 &lt;code&gt;top&lt;/code&gt; 是最常用的命令。&lt;/p&gt;
&lt;p&gt;在本文中，我们将讨论 &lt;code&gt;pstree&lt;/code&gt; 命令。它类似于 &lt;code&gt;ps&lt;/code&gt; ，但没有列出正在运行的进程，而是将它们显示在一个目录树中。树状格式是以一种更方便的方式来显示进程层次结构，并使输出在视觉上更具吸引力。&lt;/p&gt;
&lt;h2 id=&quot;如何使用-pstree-命令&quot;&gt;如何使用 pstree 命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;pstree&lt;/code&gt; 命令的一般语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ps [OPTIONS] [USER or PID]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以最简单的形式调用时没有任何选项或参数，&lt;code&gt;pstree&lt;/code&gt; 命令将显示所有正在运行的进程的分层树结构。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pstree&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;systemd─┬─VBoxService───7*[&amp;#123;VBoxService&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─accounts-daemon───2*[&amp;#123;accounts-daemon&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─2*[agetty]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─atd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─cron&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─dbus-daemon&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─irqbalance───&amp;#123;irqbalance&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─2*[iscsid]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─lvmetad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─lxcfs───2*[&amp;#123;lxcfs&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─networkd-dispat───&amp;#123;networkd-dispat&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├─nginx───2*[nginx]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>浅谈劳动合同法中赔偿金 N、N+1、2N 的区别</title>
    <link href="https://www.hi-linux.com/posts/16375.html"/>
    <id>https://www.hi-linux.com/posts/16375.html</id>
    <published>2020-05-23T02:24:00.000Z</published>
    <updated>2020-05-23T15:22:46.163Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1-离职经济补偿金的法律依据是什么">1. 离职经济补偿金的法律依据是什么？</h2><p>首先需要注意的是，虽然我们遇到问题就会提到《劳动法》，但是离职经济补偿金的相关规定都在《劳动合同法》之中，两个法规并不是一回事。所以，再遇到相关问题的时候就不要拿《劳动法》说事了。</p><h2 id="2-n-是什么意思">2. N 是什么意思？</h2><p>参见第四十七条，经济补偿计算</p><p>经济补偿按劳动者在本单位工作的年限，每满一年支付一个月工资的标准向劳动者支付。六个月以上不满一年的，按一年计算；不满六个月的，向劳动者支付半个月工资的经济补偿。</p><p>这里大家俗称的 N 就是指劳动者在用人单位的工作年限。</p><h2 id="3-n1-是怎么回事">3. N+1 是怎么回事？</h2><p>参见第四十条 无过失性辞退</p><p>有下列情形之一的，用人单位提前三十日以书面形式通知劳动者本人或者额外支付劳动者一个月工资后，可以解除劳动合同：</p><p>（一）劳动者患病或者非因工负伤，在规定的医疗期满后不能从事原工作，也不能从事由用人单位另行安排的工作的；</p><p>（二）劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的；</p><p>（三）劳动合同订立时所依据的客观情况发生重大变化，致使劳动合同无法履行，经用人单位与劳动者协商，未能就变更劳动合同内容达成协议的。</p><p>也就是说如果用人单位按照以上情况主动辞退员工的时候，需要支付 N 个月的补偿金，但是必须提前三十天以书面形式通知劳动者，这实际上是为了让劳动者有一个缓冲期来找新的工作以及处理社保等内容。<strong>如果没有提前通知就要辞退的话，需要额外支付一个月的补偿金，也就是 N+1的来源。</strong></p><a id="more"></a><h2 id="4-为什么有的公司只需要赔偿-n">4. 为什么有的公司只需要赔偿 N ？</h2><p>参见第四十一条 经济性裁员</p><p>有下列情形之一，需要裁减人员二十人以上或者裁减不足二十人但占企业职工总数百分之十以上的，用人单位提前三十日向工会或者全体职工说明情况，听取工会或者职工的意见后，裁减人员方案经向劳动行政部门报告，可以裁减人员：</p><p>（一）依照企业破产法规定进行重整的；</p><p>（二）生产经营发生严重困难的；</p><p>（三）企业转产、重大技术革新或者经营方式调整，经变更劳动合同后，仍需裁减人员的；</p><p>（四）其他因劳动合同订立时所依据的客观经济情况发生重大变化，致使劳动合同无法履行的。</p><p>满足这个前提条件的情况下，公司主动辞退员工的时候，不用提前一个月通知，也不用额外支付一个月的补偿金，所以只需要赔偿N就可以了。但是，为了避免公司投机取巧，还规定了优先留用人员以及优先招用规则：</p><p>裁减人员时，应当优先留用下列人员：</p><p>（一）与本单位订立较长期限的固定期限劳动合同的；</p><p>（二）与本单位订立无固定期限劳动合同的；</p><p>（三）家庭无其他就业人员，有需要扶养的老人或者未成年人的。用人单位依照本条第一款规定裁减人员，在六个月内重新招用人员的，应当通知被裁减的人员，并在同等条件下优先招用被裁减的人员。</p><h2 id="5-什么情况公司解雇员工不用赔偿">5. 什么情况公司解雇员工不用赔偿？</h2><p>参见第三十九条 用人单位单方解除劳动合同（过失性辞退）</p><p>劳动者有下列情形之一的，用人单位可以解除劳动合同：</p><p>（一）在试用期间被证明不符合录用条件的；</p><p>（二）严重违反用人单位的规章制度的；</p><p>（三）严重失职，营私舞弊，给用人单位造成重大损害的；</p><p>（四）劳动者同时与其他用人单位建立劳动关系，对完成本单位的工作任务造成严重影响，或者经用人单位提出，拒不改正的；</p><p>（五）因本法第二十六条第一款第一项规定的情形致使劳动合同无效的；</p><p>（六）被依法追究刑事责任的。</p><p>这里重点介绍一下！当员工有过错的前提下，公司确实可以开除员工而不用支付补偿金。</p><p><strong>但是！但是！但是！</strong></p><p><strong>公司很难依照此条文解雇员工，具体常见逼退手段下面再单独讲解！</strong></p><h2 id="6-为什么有人可以获得-2n-赔偿">6. 为什么有人可以获得 2N 赔偿？</h2><p>参见第八十七条 违反解除或者终止劳动合同的法律责任</p><p>用人单位违反本法规定解除或者终止劳动合同的，应当依照本法第四十七条规定的经济补偿标准的二倍向劳动者支付赔偿金。</p><p>这里例句一些常见的一些情况，方便大家保护自身利益：</p><p>（一）从事接触职业病危害作业的劳动者未进行离岗前职业健康检查，或者疑似职业病病人在诊断或者医学观察期间的；</p><p>（二）在本单位患职业病或者因工负伤并被确认丧失或者部分丧失劳动能力的；</p><p>（三）患病或者非因工负伤，在规定的医疗期内的；</p><p>（四）女职工在孕期、产期、哺乳期的；</p><p>（五）在本单位连续工作满十五年，且距法定退休年龄不足五年的；</p><p>（六）法律、行政法规规定的其他情形。</p><p>法律上并没有 2N+1 的说法，毕竟违法裁员，根本不需要提前一个月通知，所以只有 2N，没有 2N+1。注意：2N 这个就应该叫做赔偿金了，是违法的赔偿。</p><h2 id="7-为什么有人可以获得-n6">7. 为什么有人可以获得 N+6？</h2><p>N+6 等补偿金更多的是一种操作策略，而不是出于劳动合同法上的需求。企业为了尽快解决裁员问题，减少麻烦，会提出各种补偿办法。比如今年的甲骨文裁员，5 月 22 日前签字是 N+6，6 月 7 日前签字是 N+1，6 月 7后签字走人就只有 N 了。</p><h2 id="8-员工主动离职可以提出补偿吗">8. 员工主动离职可以提出补偿吗？</h2><p>参见第三十七条 劳动者提前通知解除劳动合同</p><p>劳动者提前三十日以书面形式通知用人单位，可以解除劳动合同。劳动者在试用期内提前三日通知用人单位，可以解除劳动合同。</p><p>所以，自己提出辞职的人，就不要再想拿补偿金了。</p><h2 id="9-劳动合同到期了辞退员工如何补偿">9. 劳动合同到期了辞退员工如何补偿？</h2><p>劳动合同到期，如果公司不想续签也需要补偿 N。另外，如果员工可以签订<strong>无固定期限劳动合同</strong>的情况，公司需要支付 2N 的赔偿。</p><h2 id="10-什么是无固定期限劳动合同">10. 什么是无固定期限劳动合同？</h2><p>参见第十四条 无固定期限劳动合同</p><p>无固定期限劳动合同，是指用人单位与劳动者约定无确定终止时间的劳动合同。用人单位与劳动者协商一致，可以订立无固定期限劳动合同。有下列情形之一，劳动者提出或者同意续订、订立劳动合同的，除劳动者提出订立固定期限劳动合同外，应当订立无固定期限劳动合同：</p><p>（一）劳动者在该用人单位连续工作满十年的；</p><p>（二）用人单位初次实行劳动合同制度或者国有企业改制重新订立劳动合同时，劳动者在该用人单位连续工作满十年且距法定退休年龄不足十年的；</p><p>（三）连续订立二次固定期限劳动合同，且劳动者没有本法第三十九条和第四十条第一项、第二项规定的情形，续订劳动合同的。用人单位自用工之日起满一年不与劳动者订立书面劳动合同的，视为用人单位与劳动者已订立无固定期限劳动合同。</p><p>所以各位可以检查一下自己是否签订了无固定期限劳动合同？</p><h2 id="11-离职经济补偿金的基数怎么算">11. 离职经济补偿金的基数怎么算？</h2><p>1）合同解除前 12 个月内的货币性收入</p><p>2）应发工资（税前工资）</p><p>3）包含年终奖或年终双薪、包含津贴和补贴</p><p>4）包含加班费（据说上海规定不含，具体遇到问题的朋友请及时联系法律顾问）</p><h2 id="12-为什么我的补偿金少了">12. 为什么我的补偿金少了？</h2><p>参见第四十七条 经济补偿的计算</p><p>劳动者月工资高于用人单位所在直辖市、设区的市级人民政府公布的本地区上年度职工月平均工资三倍的，向其支付经济补偿的标准按职工月平均工资三倍的数额支付，向其支付经济补偿的年限最高不超过十二年。</p><p>所以，如果你的工资太高了，也不会给你补偿那么多的。以北京为例，2019 年平均工作为 6906，最高的离职补偿金就是：6909x3x12≈25万。</p><p>补偿金不用缴纳个税。</p><h2 id="13-劳动合同不同于劳务合同">13. 劳动合同不同于劳务合同</h2><p>劳务关系，是指不构成劳动关系的，一方提供劳务、一方支付报酬的民事关系，如家庭或个人与家政服务人员之间的关系，个体工匠与帮工、学徒之间的关系，农村承包经营户与受雇人之间的关系等。</p><p>劳务关系离职是没有补偿金说法的，所以签订协议时要明确是劳动合同还是劳务合同。</p><h2 id="14-劳动合同法是保护劳动者的">14. 劳动合同法是保护劳动者的！</h2><p>虽然我们在第 5 点里介绍了公司可以不支付补偿金的情况，<strong>但是绝大多数情况下，公司都很难以此来解除劳动合同，而在解除合同过程中任何一点瑕疵，都是违法的！</strong></p><p>所有解除的理由必须证据确凿并需要你亲自签字确认才可以，而且重大过失要有调查过程，还需要给你澄清的机会。总之，<strong>劳动者面对违法解约时，只要上诉劳动仲裁部门，基本都能赢，所以不要怕 HR 的威逼利诱！</strong></p><p>就比如严重违反用人单位的规章制度这一条，上班睡觉算不算违反，上班玩手机算不算违反？如果要按照仲裁流程的话，用人单位要提供清楚什么内容才算玩手机，玩了多久才算违规，另外还需要提供证据证明你在什么时间到什么时候玩了什么内容，对公司的生产造成了什么样的危害。总之，所有的举证责任都在公司，想要合法的开除一个人，是真的很难很难的。</p><p>再比很多 HR 会拿绩效不达标或者末尾淘汰为理由辞退员工。但是需要注意的是绩效不达标、末位淘汰≠不能胜任工作。另外，绩效考核标准必须合理，这一点就有大的解释空间和法律风险。都需要公司去举证。</p><p>另外常见的手段就是给你转岗到海外或者不发达地区，其实这个属于变动了劳动合同内容，需要与员工协商签字才可以，否则就是违法的！</p><p><strong>《中华人民共和国劳动合同法》 完整版本</strong>可参见这里：<a href="https://url.cn/5QSBTZj" target="_blank" rel="noopener">https://url.cn/5QSBTZj</a></p><blockquote><p>再提醒一点：哺乳期的同事不要同意签署延迟协议（HR 会让你哺乳期结束就滚蛋），务必直接签下一个合同，否则劳动局仲裁；</p></blockquote><p><strong>最后！和 HR 还有主管谈话时，</strong></p><p><strong>记得带好录音笔！</strong></p><p><strong>记得带好录音笔！</strong></p><p><strong>记得带好录音笔！</strong></p><p>希望这篇文章能给到广大朋友以帮助！</p><blockquote><p>本文转载自：「表哥有话讲」，原文：<a href="https://url.cn/5Ls0zGQ%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5Ls0zGQ，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-离职经济补偿金的法律依据是什么？&quot;&gt;1. 离职经济补偿金的法律依据是什么？&lt;/h2&gt;
&lt;p&gt;首先需要注意的是，虽然我们遇到问题就会提到《劳动法》，但是离职经济补偿金的相关规定都在《劳动合同法》之中，两个法规并不是一回事。所以，再遇到相关问题的时候就不要拿《劳动法》说事了。&lt;/p&gt;
&lt;h2 id=&quot;2-N-是什么意思？&quot;&gt;2. N 是什么意思？&lt;/h2&gt;
&lt;p&gt;参见第四十七条，经济补偿计算&lt;/p&gt;
&lt;p&gt;经济补偿按劳动者在本单位工作的年限，每满一年支付一个月工资的标准向劳动者支付。六个月以上不满一年的，按一年计算；不满六个月的，向劳动者支付半个月工资的经济补偿。&lt;/p&gt;
&lt;p&gt;这里大家俗称的 N 就是指劳动者在用人单位的工作年限。&lt;/p&gt;
&lt;h2 id=&quot;3-N-1-是怎么回事？&quot;&gt;3. N+1 是怎么回事？&lt;/h2&gt;
&lt;p&gt;参见第四十条 无过失性辞退&lt;/p&gt;
&lt;p&gt;有下列情形之一的，用人单位提前三十日以书面形式通知劳动者本人或者额外支付劳动者一个月工资后，可以解除劳动合同：&lt;/p&gt;
&lt;p&gt;（一）劳动者患病或者非因工负伤，在规定的医疗期满后不能从事原工作，也不能从事由用人单位另行安排的工作的；&lt;/p&gt;
&lt;p&gt;（二）劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的；&lt;/p&gt;
&lt;p&gt;（三）劳动合同订立时所依据的客观情况发生重大变化，致使劳动合同无法履行，经用人单位与劳动者协商，未能就变更劳动合同内容达成协议的。&lt;/p&gt;
&lt;p&gt;也就是说如果用人单位按照以上情况主动辞退员工的时候，需要支付 N 个月的补偿金，但是必须提前三十天以书面形式通知劳动者，这实际上是为了让劳动者有一个缓冲期来找新的工作以及处理社保等内容。&lt;strong&gt;如果没有提前通知就要辞退的话，需要额外支付一个月的补偿金，也就是 N+1的来源。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="虚拟化" scheme="https://www.hi-linux.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>30 个你应该知道的编程技巧</title>
    <link href="https://www.hi-linux.com/posts/39135.html"/>
    <id>https://www.hi-linux.com/posts/39135.html</id>
    <published>2020-05-23T02:23:00.000Z</published>
    <updated>2020-05-23T15:22:46.164Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>本文作者 Jun Wu 有着编程和统计学背景，她在 15 年前就是一名程序员。近日，她分享了给程序员的 30 条心得建议。</p></blockquote><p>如果你想成为一名程序员，这个建议可以帮助你走上正确的道路。</p><p>程序员不是一个容易的职业，每年都有许多人从国内顶尖院校的计算机科学专业毕业，这是任何人都能从事的竞争最大的职业之一。同时，编程也是令人兴奋的。随着技术的进步，工业界每天都有创新。编程对于热爱它的人来说是一项充满激情的事业。</p><p>当我 15 年前开始做程序员的时候，我希望有人能告诉我下面清单上的一切建议。这个清单可以为所有新手程序员节省大量的时间和精力，并且，你可以在编程职业发展的整个过程中都参考这些建议。即使这里面有些观点现在可能与你无关，但总有一天你会看到其中的智慧。</p><p>作为一名程序员，你正处在伟大的顶点。</p><p>你只要对自己要走的道路稍有了解就可以开始冒险了。</p><h2 id="1-你不需要学位但你需要知识">1. 你不需要学位，但你需要知识</h2><p>我和许多没有计算机科学硕士学位或计算机科学本科学位的程序员一起工作。编程是少数不依赖学位的职业之一。然而，编程是一项知识密集型的职业。如果你想开始编程生涯，这十本基础书籍你必读的。这十本书将涵盖计算机科学的基本概念以及如何在项目团队中工作。它们可以为你的技术打下坚实的基础，让你对基本概念有一个深刻的理解，并且让你有能力去编写功能性的代码，顺利进行技术面试并与同事交流。</p><h2 id="2-创造性是提高解决编程问题能力的重要因素">2. 创造性是提高解决编程问题能力的重要因素</h2><p>大多数人都有这样的认知：编程都是关于分析和解决问题的技能。这个观点并不是完全正确的，编程也非常需要创造力。通常，你可以用很多方法编写给定的代码。当你拥有了创造力，就能设计出最简单、最有效的代码。</p><h2 id="3-不要什么都学精通一部分知识">3. 不要什么都学，精通一部分知识</h2><p>编程语言有数百种。有一些编程领域有着明确的职业道路：Web 开发人员、前端开发人员、后端开发人员、软件工程师、数据库开发人员等。你需要决定要成为哪种开发人员，然后学习该职位所需的所有技术和技能。</p><h2 id="4-你不需要活的像机器人">4. 你不需要活的像机器人</h2><p>记住，你首先是一个人，其次才是程序员。当您第一次开始编程时，很容易在代码中迷失方向。有时我在完成项目的所有任务之前都不离开电脑。但是你是一个人，你需要笑，哭，减压，和人交谈。管理好你的生活，最大限度地提高工作之外的兴趣爱好，这将为程序员的工作带来更多的创造力。</p><h2 id="5-编程就是应用知识而不是为了记忆">5. 编程就是应用知识而不是为了记忆</h2><p>与研究不同，在研究中，你会发明和创造新的知识领域，但编程就是应用现有的知识。书籍、研究论文、在线文章和学习视频成为您经常使用的资源。不需要记住任何东西。你总是可以搜索资源来找到答案。随着你处理的项目越来越多，这些记忆会自动自然地出现。</p><a id="more"></a><h2 id="6-你每天都要克服自己是冒牌货的心态">6. 你每天都要克服自己是「冒牌货」的心态</h2><p>编程似乎是所有「聪明」人都倾向于做的一种职业。除非你是个天才，否则你会像我一样，每天都会怀疑自己是个冒牌货。当你每天都经历这些的时候，你往往会想出一个办法来解决这个问题。对我来说，我一直把它当做学习新事物的动力。我已经学会了站在正确的角度看待这个问题，并且满足于每天都有的一点点进步。</p><h2 id="7-你必须有程序员以外的生活否则你只会沉迷于编程">7. 你必须有程序员以外的生活，否则你只会沉迷于编程</h2><p>有时你会宅在家里。然而，要成为一个快乐的程序员，你必须主动地在电脑屏幕之外寻找生活。你事业的成功往往取决于你遇到的人。当你是一个程序员时，社交网络是必不可少的。拥有程序员以外的生活对于防止自己沉溺于编程是至关重要的。当你编程是因为激情而不是被迫的时候，你就能做出最好的工作。</p><h2 id="8-如果你和其他人共同完成一个项目你会更快地学会编程">8. 如果你和其他人共同完成一个项目，你会更快地学会编程</h2><p>在你的职业生涯刚开始的时候，你会试图把自己封闭起来，阅读关于编程的书来建立你的计算机科学基础。你猜怎么着？如果你找到一个朋友一起合作，你会学习得更快。我在和其他小伙伴合作完成一个项目的过程中看完了编程书籍。当你和其他人一起合作时，你所有的程序缺点就会暴露出来，你的代码将受到批评。你将学会编写有效的代码，因为有人在监视你。你会想找出最好的方法去做事情，因为你的朋友也在学习。当你做程序员时，总有人在审查你的代码。你永远不会独自编程，所以你需要习惯这些。</p><h2 id="9-你不需要擅长数学和科学">9. 你不需要擅长数学和科学</h2><p>在科技行业，你会遇到各种超级程序员，他们在接受了一辈子的文科教育后发现编程的逻辑思维很有吸引力。有很多画家和作家在一边追求艺术，一边做着程序员。编程是一项艰苦的工作，做一个好的程序员所需要的只是坚持，任何人都可以通过编程书籍学习基础知识。很多人在这个行业工作了一段时间后就开始学数学了。最终，这些人甚至可以理解和实现复杂的算法，尽管他们并没有接受任何形式的正式数学教育。</p><h2 id="10-你需要成为一个全明星的学习者">10. 你需要成为一个全明星的「学习者」</h2><p>程序员是一个熟练的学习者。现在你可能不是一个大师级的学习者，但你会到达那一步的。有时候你的工作会要求你在六个月内学会三种编程语言，这就是技术创新的现状。作为程序员，我们每天都在学习。对我们来说，学习就像呼吸一样自然。如果你对每天的学习感到不耐烦，你必须强迫自己去习惯这一点。</p><h2 id="11-专注于完成你的项目">11. 专注于完成你的项目</h2><p>编码是真的会上瘾。在你的编程生涯中的某个时刻，你将经历一整晚的通宵编程。在完成目标之前，你不会想睡觉的。你会忘记吃饭、喝酒，甚至忘记从办公桌上起来，因为你的大脑处理了太多的信息。没关系，在做完后，到外面散散步，度个假吧。</p><h2 id="12-你会花费整天找一个小-bug">12. 你会花费整天找一个小 Bug</h2><p>大多数时候，在一个项目中，许多部分是相互依赖的。通常，你会发现除非你修复了一个潜伏在你系统中的小 Bug，否则你无法继续前进。作为一个程序员，除非你发现这个错误，否则你会对整个项目感到有压力，你将整天坐在电脑前寻找它，在找到它之前你将在晚上梦见代码。</p><h2 id="13-你将花大部分时间搜索没有人能告诉你的答案">13. 你将花大部分时间搜索没有人能告诉你的答案</h2><p>如果你用一种流行的语言编程，你将能够找到你在网上遇到的大多数问题的答案。但是，也有例外。有时，没有人遇到过你碰到的问题。在这种情况下，参考编程书籍和在四处询问通常会为您指明正确的方向。</p><h2 id="14-你会读一本设计模式书">14. 你会读一本设计模式书</h2><p>你是否毕业于最好的计算机院校关系不大。在每一个程序员的职业生涯中，总有一段时间你会坐下来，从头到尾地阅读「 Head First Design Patterns」。对于一个新手程序员来说，这可能是阅读得最多的书之一。那么，你还在等什么？把它捡起来，从头读到尾。</p><h2 id="15-你将学会专注于准确的拼写">15. 你将学会专注于准确的拼写</h2><p>在每一个程序员职业生涯中的某个时刻，您将用您最喜欢的语言编写了足够的代码，以便按照自己想要的方式来做事情。这包括变量、类甚至数据库中的表按照你自己的命名约定进行准确的编写。你将对此进行彻底的审查。你最不想看到的是一些因为你拼写错误而出现的 Bug。记住，如果理由足够，那么请专注于一件事情。但当你没有很好的理由而去做某件事，这可能只是重复性的行为。</p><h2 id="16-你会放弃">16. 你会放弃</h2><p>我放弃了多少次？我已经数不清了。有时你会碰到你无法解决的问题，有时候你会因为困难而想停止，有时候工作环境会让你想辞职。你的激情取决于你的坚持，这些正是考验你的时候。是留下还是离开？我每次都留下来了。有时，在几年没有写一行代码之后，我会作为一个准备好完成一个项目的新人回来。当你知道你热爱你的工作时，它会变成一个家，你会愿意为之冒险。</p><h2 id="17-重启你自己">17. 重启你自己</h2><p>如果你相信更高的力量，你可能会需要这个建议。我看到过很多人重新开始编程，通常他们都是因为热爱，与钱无关。当你看到一个人像你以前一样对编程乐在其中时，你是嫉妒的，你觉得你也不能放弃编码。然后，突然间，你又回到了一个项目中。你知道，在你的内心深处，你的生活和呼吸都离不开代码。这就是你知道自己是一个真正程序员的时刻。</p><h2 id="18-你将回到某种形式的学校学习正确的做事方式">18. 你将回到某种形式的「学校」学习「正确」的做事方式</h2><p>即使是从精英计算机科学专业硕士毕业的最好的程序员也会在工作后继续学习。事实上，在职培训是在大型科技公司工作的最佳福利之一。公司会给你提供「昂贵」的课程和研讨会，让你了解他们希望你使用的最新技术。如果可能，你在工作中学到的知识是不够的，你将参加许多在线编码学院，查看 YouTube 视频来提高你的技能。</p><h2 id="19-你将被一个你不想为之工作的人雇用">19. 你将被一个你不想为之工作的人雇用</h2><p>即使你是一个平庸的程序员，某些公司也会需要你的技能。当他们面试你时，请记住你也在面试他们。由于公司的文化，你可能会发现自己想对一个轻松的 offer 说「不」。作为一名程序员，你将工作很长时间，因此，找到一个文化和你契合的公司文化至关重要。愉快的心情能让你更好地工作。如果你的技能合适，其他公司也会来敲你的门，除非有必要，请不要随意跳槽。</p><h2 id="20-你会在技术面试中失败">20. 你会在技术面试中失败</h2><p>技术面试不是开玩笑。高级程序员经常为了好玩而编造技术面试问题。通常，由于某种原因，这些问题是非常困难的。如果你没有通过技术面试，那并不是世界末日，它并不能证明你没有编程能力，它只是在测试你的知识库，试着往好的方面看。如果你的人际交往能力出众，经理们会记住你的。如果他们喜欢你，而你不适合这个职位，他们可能还会打电话给你另一个职位。</p><h2 id="21-你会被告知你很棒">21. 你会被告知你很棒</h2><p>在你的职业生涯中，有时你会觉得自己是明星。依赖于你完成项目的经理会为了激励你，会告诉你特别伟大。你会觉得自己在世界的顶端。记住，保持脚踏实地。总是有新技术需要探索，总是有比你更好的新程序员。</p><h2 id="22-你会被告知你什么都不知道">22. 你会被告知你什么都不知道</h2><p>在你的职业生涯中，有时你会觉得自己什么都不知道。对某个项目感到沮丧的人会告诉你你什么都不知道。也许他们这样做是为了让你安顿下来。但是，你完全不应该否定自己。因为你知道的可能比你想象的要多得多。每过一天，你就会知道得比前一天多一点。一年后，人们会尊敬你的。请继续努力，一段时间之后，你甚至可能得到那个告诉你你什么都不知道的人的尊重。</p><h2 id="23-你会想和其他你钦佩的程序员竞争">23. 你会想和其他你钦佩的程序员竞争</h2><p>编程最棒的方面之一就是竞争。我喜欢和我崇拜的人一起编程。当你能编写一段让你欣赏的程序员肯定的代码时，你会像刚刚中了彩票一样开心。编程中的竞争是很有趣的，它并不是比谁最好，更多的是互相学习。</p><h2 id="24-你不明白你的同事刚刚说的话">24. 你不明白你的同事刚刚说的话</h2><p>在最开始，这可能每周或每月发生一次。在你的新编程工作中，你会不理解你的同事刚刚说的话。这可能有两个原因。一个可能的原因是，你就是无法理解他们的口音。在这种情况下，可以请另一个同事翻译。不能听懂别人的话并不羞耻，很可能其他同事也花了很多年才习惯这种口音。另一个原因是，你的同事刚刚说的话完全超出了你的想象。但这也没关系，毕竟，你的同事是专家。摆好椅子，请你的同事以图片的形式解释这一切。很可能，你需要一段时间去适应。</p><h2 id="25-看到去年写的乱七八糟的代码你会感到羞愧">25. 看到去年写的乱七八糟的代码你会感到羞愧</h2><p>这也是经常发生的。在最开始，我也因为代码不规范受到过批评。当时，设计很好且有着良好文档，但我是用一种难以阅读的语言写的。但直到现在，不管我多么努力，每年我仍然会找到一些乱七八糟的代码，这通常都是因为我想很快地完成工作。实际上这就是程序员的工作，我们不停地完善和修改各种代码。这并不羞耻。当你意识到它们是你写的的时候，后退一步，如果可以的话，好好地修改它。</p><h2 id="26-当你厌倦看代码时你将在你的数据库项目中躲避">26. 当你厌倦看代码时，你将在你的数据库项目中躲避</h2><p>当你在进行一次愉快的编程之旅时，可能会发生这种情况。你已经连续工作两个月了，你需要休息一下。但你喜欢这种当时的状态，所以你继续前进。然后您会发现 SQL 很有趣。你不明白为什么你看不进去一行代码。但不知何故，将数据放入数据库并将其取出，是一件令人愉快的事情。你陶醉于这种完全符合逻辑的简单语言。</p><h2 id="27-你对黑客又爱又恨">27. 你对黑客又爱又恨</h2><p>黑客攻击现在很常见。程序员在团队中互相竞争，在这个过程中，好几个小时你都在高度紧张地学习。此时的黑客攻击就像调味剂一样，你可能会非常喜欢。但有时，你会讨厌在高速敲键盘时被打断。你也会讨厌拥挤的办公室和喧嚣的活动。</p><h2 id="28-在阅读研究论文时你会认为你一个单词都看不懂">28. 在阅读研究论文时，你会认为你一个单词都看不懂</h2><p>你会说英语吗？好吧，大多数人的回答都是肯定的。但是，我向你保证，有时你会一遍又一遍地读一些研究论文，并意识到自己完全无法理解它们。对我来说，在我学会大学数学的课程之前，大多数关于算法的研究论文都像是没有意义的森林。然后，突然某一天，一切似乎都有了意义。</p><h2 id="29-你要买耳机">29. 你要买耳机</h2><p>在你的职业生涯中的某个时刻，当你全神贯注于你的代码时，你会意识到任何一种噪音都会阻碍你的感官。一个好的耳机可以消除外部噪音，这样在拥挤的办公室里你也会隔绝外部干扰。在某些时候，你也会发现听音乐可以帮助你编码。在我编码生涯的早期，我发现音乐的节奏有助于我流畅地编码。即使现在，我也会借助一些音乐来提高自己的生产力。</p><h2 id="30-你将去一个新的地方如果幸运的话它将是拉斯维加斯">30. 你将去一个新的地方，如果幸运的话，它将是拉斯维加斯</h2><p>在你职业生涯中的某个阶段，你会成为对公司非常重要的核心开发人员。这时，你可能会被邀请到异地和其它技术人员进行交流。高层管理人员可能会利用这个机会了解你。请别误会，这并不代表着你可以无忧无虑地喝醉酒了，而是你和你的同龄人交往和交流的好机会。如果你幸运的话，活动将会在拉斯维加斯。有时，还会有其他公司的技术专家来参加这些活动。</p><blockquote><p>来源：雷锋网</p><p>原文：<a href="http://t.cn/AiY7TQ9g" target="_blank" rel="noopener">http://t.cn/AiY7TQ9g</a></p><p>译文：<a href="http://t.cn/AiY7T3uX" target="_blank" rel="noopener">http://t.cn/AiY7T3uX</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文作者 Jun Wu 有着编程和统计学背景，她在 15 年前就是一名程序员。近日，她分享了给程序员的 30 条心得建议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你想成为一名程序员，这个建议可以帮助你走上正确的道路。&lt;/p&gt;
&lt;p&gt;程序员不是一个容易的职业，每年都有许多人从国内顶尖院校的计算机科学专业毕业，这是任何人都能从事的竞争最大的职业之一。同时，编程也是令人兴奋的。随着技术的进步，工业界每天都有创新。编程对于热爱它的人来说是一项充满激情的事业。&lt;/p&gt;
&lt;p&gt;当我 15 年前开始做程序员的时候，我希望有人能告诉我下面清单上的一切建议。这个清单可以为所有新手程序员节省大量的时间和精力，并且，你可以在编程职业发展的整个过程中都参考这些建议。即使这里面有些观点现在可能与你无关，但总有一天你会看到其中的智慧。&lt;/p&gt;
&lt;p&gt;作为一名程序员，你正处在伟大的顶点。&lt;/p&gt;
&lt;p&gt;你只要对自己要走的道路稍有了解就可以开始冒险了。&lt;/p&gt;
&lt;h2 id=&quot;1-你不需要学位，但你需要知识&quot;&gt;1. 你不需要学位，但你需要知识&lt;/h2&gt;
&lt;p&gt;我和许多没有计算机科学硕士学位或计算机科学本科学位的程序员一起工作。编程是少数不依赖学位的职业之一。然而，编程是一项知识密集型的职业。如果你想开始编程生涯，这十本基础书籍你必读的。这十本书将涵盖计算机科学的基本概念以及如何在项目团队中工作。它们可以为你的技术打下坚实的基础，让你对基本概念有一个深刻的理解，并且让你有能力去编写功能性的代码，顺利进行技术面试并与同事交流。&lt;/p&gt;
&lt;h2 id=&quot;2-创造性是提高解决编程问题能力的重要因素&quot;&gt;2. 创造性是提高解决编程问题能力的重要因素&lt;/h2&gt;
&lt;p&gt;大多数人都有这样的认知：编程都是关于分析和解决问题的技能。这个观点并不是完全正确的，编程也非常需要创造力。通常，你可以用很多方法编写给定的代码。当你拥有了创造力，就能设计出最简单、最有效的代码。&lt;/p&gt;
&lt;h2 id=&quot;3-不要什么都学，精通一部分知识&quot;&gt;3. 不要什么都学，精通一部分知识&lt;/h2&gt;
&lt;p&gt;编程语言有数百种。有一些编程领域有着明确的职业道路：Web 开发人员、前端开发人员、后端开发人员、软件工程师、数据库开发人员等。你需要决定要成为哪种开发人员，然后学习该职位所需的所有技术和技能。&lt;/p&gt;
&lt;h2 id=&quot;4-你不需要活的像机器人&quot;&gt;4. 你不需要活的像机器人&lt;/h2&gt;
&lt;p&gt;记住，你首先是一个人，其次才是程序员。当您第一次开始编程时，很容易在代码中迷失方向。有时我在完成项目的所有任务之前都不离开电脑。但是你是一个人，你需要笑，哭，减压，和人交谈。管理好你的生活，最大限度地提高工作之外的兴趣爱好，这将为程序员的工作带来更多的创造力。&lt;/p&gt;
&lt;h2 id=&quot;5-编程就是应用知识而不是为了记忆&quot;&gt;5. 编程就是应用知识而不是为了记忆&lt;/h2&gt;
&lt;p&gt;与研究不同，在研究中，你会发明和创造新的知识领域，但编程就是应用现有的知识。书籍、研究论文、在线文章和学习视频成为您经常使用的资源。不需要记住任何东西。你总是可以搜索资源来找到答案。随着你处理的项目越来越多，这些记忆会自动自然地出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="编程" scheme="https://www.hi-linux.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>35 岁后的互联网人应该怎么办？</title>
    <link href="https://www.hi-linux.com/posts/1977.html"/>
    <id>https://www.hi-linux.com/posts/1977.html</id>
    <published>2020-05-23T02:22:00.000Z</published>
    <updated>2020-05-23T15:22:46.162Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>华为、腾讯、京东、阿里都曾被爆出类似「优化中年基层管理者」的新闻，面对「被倒挂」与「被优化」的危机，互联网行业从业者应该如何「自如的面对」？</p><p>这里给大家分享一个知乎上的高赞答案，共勉！</p><blockquote><p>几年前见到类似的说法，这个数字还是 30 岁。估计再过几年，这个数字会变成 40 岁。</p><p>其实长期来看，大家都会习惯，互联网和其他各个行业一样，所有行业存在的问题，互联网行业都会存在。</p><p>什么是危机？感觉周围的人都在危机，甚至包括一些财富、地位都已经很高的人，仍然逃不过焦虑。似乎焦虑就是自然而然的，伴随着每个人的成长。焦虑多了，就开始危机了。</p><p>我想在这里持续写一些感想，可能对各年龄段的朋友都有一些帮助。其实很多人真到这个年龄，见识和能力都已经很厉害了，我帮忙总结一下。</p><p>前段时间有好朋友和我说，感觉随着年龄增长，会有焦虑。因为年龄越大，会发现技能上面并没有比年轻人高太多，体力和精力可能还要差一些。这样的问题迟早大家都会遇到，无论是在职场中工作了很久，还是刚入职场，有些事实，业务应该早一些了解。</p></blockquote><a id="more"></a><p>分享一下我自己的观察和思考，对于所有年龄在增加的企业里的中层，以及未来要成为中层的大家。</p><p><strong>1. 永远贴近业务</strong></p><p>在工作中你会面临一些微妙的选择，是纯做管理，搭团队管人，还是更贴近业务。这两者往往不互斥，但是很多人会不自觉的偏向前者。所以经常看到一些朋友的焦虑，虽然纯做管理相对要轻松一点点（很多时候也未必有多轻松），但是自己的那把剑容易钝。贴近业务是很考验人的，也很累，但是能够让自己始终在一个好的节奏上。</p><p><strong>2. 注意警惕自己的体制耦合度</strong></p><p>所谓体制，在各种地方都存在。比如你在一家大公司里工作，你会发现很多时间其实在处理部门与部门之间的协调、沟通工作，这个比例不低。你在这里的时间越久，越是熟门熟路，知道该从哪些部门争取资源，如何搞定各种各样的关系。但是反过来，你也会让你的体制耦合度不断增加。等某一天你到了另一个地方，会发现自己原本得心应手的工作，对于新的工作价值不大。</p><p><strong>3. 平台能力不是个人能力</strong></p><p>在一个平台上，这个平台会让你具备很多力量。需要明白这些力量未必是自己的能力。你在一个好的平台上能够使用的资源，可能到了另一个相对小的平台上，就用不起来了，这时候自己真实的短板就出来了。我见过一些在大企业工作的朋友，在创业公司时很痛苦，因为感觉自己很多地方都是心有余而力不足。最简单的，招聘工作，你都会发现，原本大平台的品牌背书很强，而现在你的资源要少很多，但是还得做事情。需要持续提升自己的能力，不要被眼前被加成的能力蒙蔽。</p><p><strong>4. 扎扎实实积累资源</strong></p><p>很多人不理解资源的含义，以为认识一些人就是资源。其实你得成为一个网络里的节点，不能是单向的，得是双向的。我见过一些人动不动说和这个人熟那个人熟，什么叫熟呢？如果你请人帮忙，如果你需要找人合作，人家能否信任你？你做过什么事情、有什么积累值得对方信任？这是从内到外的积累，不取决于能说会道，长袖善舞。</p><p><strong>5. 成为网络中的节点</strong></p><p>专业技能是一方面，对于很多人的工作，到一定阶段会发现除了专业技能，年龄的优势在于你能「搞定事情」。这样搞定事情一方面是你能够带领团队搞定，另一方面是能够协调外部各种资源搞定。而且，这种力量不应该完全依赖于你在哪一家公司、哪个职位上工作。比如你们要做一个产品、一个项目，需要各种资源，或者某一天你想找工作，除了猎头外，是不是如果有其他朋友帮你介绍、背书，效果来的更好？你得成为一个网络中的一部分。狭义的说这个网络就是圈子，但是更广义的来说，各种各样的信息网络、协作网络，都是你需要的网络。你要成为这个网络中的节点。</p><p><strong>6. 熟人之间降低交易成</strong></p><p>本熟人可能是朋友，可能是合作伙伴等等，熟人之间做事情，可以降低交易成本（或者说合作成本等等）。长期来说，你需要尽可能降低交易交易成本，让大家能够快速达成共识。这需要你自己重视口碑，作为网络的节点，获得其他节点的背书。为什么别人会信任你？因为你靠谱，或者其他靠谱的人认为你靠谱，所以大家就信了。太侧重短期利益，往往会提升自己这个节点长期的交易成本。</p><p><strong>7. 注重复利型的积累机会</strong></p><p>「复利是指一笔资金除本金产生利息外，在下一个计息周期内，以前各计息周期内产生的利息也计算利息的计息方法。」也就是说，利能生利。有一些机会，你不断往下做的时候，以往的积累，能够成为未来新的资本基础，而不是过去就过去了。这样的机会可能是你的工作本身，也可能是一些小的工作，或者就是业余爱好。例如在网上分享知识和专业经验，往往都是我在各种碎片时间完成的，持续了很多年，这样的事情就产生了复利，做各种事情，都能用在这样的基础上，有更多的人愿意支持。当我做知群的时候，已经自然有一批朋友愿意支持，包括很多公司的高管都愿意提供资源。复利能够让我们做的事情不断增强，时间变成了朋友。</p><p><strong>8. 讲原则与结善缘</strong></p><p>首先在公司里工作，要做好事情，讲原则，这是基础。在这个基础之上，在行业里能够顺手帮忙的，尽量能够帮忙，这是结善缘。因为很多时候你也不知道未来会如何。可能今天别人是找你帮忙，过两年，就变成你要找别人帮忙了。有些人没有意识到这一点，认为自己今天的积累已经足够，但其实如前面所说，很多时候是公司和平台的能力，而不是个人的能力。在这种认识下，一些人甚至会有意为难、做一些损人未必利己的事情，现在可能还觉得挺好，某一天就会吃亏。当然这里有个最基本的点，就是要有原则，在为公司、产品做好事情的前提下去结善缘。</p><p><strong>9. 要获得帮助的时候，多想想如何对等</strong></p><p>以前有一位好友做的很好，他在和其他公司合作的时候，总会说，在这个合作里我们有很多好处，但是不能让对方吃亏，也得多想想如何能够帮到对方。这和前一点结善缘类似，需要强调的是不要短时，每次都只以自己为出点。总是自己有好处才上，总想让别人能帮到自己，给人感觉目的性太强，但是又是单向的。这样下来，很难有持续的积累。其实会发现类似的积累，在某一天都能够反过来帮到自己。</p><p><strong>10. 避免高估自己的专业或者职业</strong></p><p>需要清楚公司真正的核心是什么。很多人会说某某公司是技术驱动的、很多公司是产品驱动的，等等。往往做专业工作的人，容易陷入到一个固定的视角里，认为自己的专业非常重要。做技术的觉得技术最重要，做产品的觉得产品经理最重要，做设计的觉得设计师最重要，等等，其实大家都是整个公司的一个环节。驱动公司前进的，往往是一些更底层的商业驱动力。正确看待自己在公司里的作用和位置，积累在这个方面的能力和资源，并继续核心业务，提升自己。</p><p><strong>11. 分的清时和势对自己的影响</strong></p><p>很多人容易高估自己的能力，而低估时和势对自己的帮助，以至于做职业的决策时产生偏差。有一次和一个兄弟，拉勾的创始人马德龙一起反思，有一个很好的问题：到底是我们在成就这个时代，还是这个时代在成就我们？很多人认为自己做的好是因为自己能力强，但是这是全部原因么？其实很多人是因为在正确的时间点跟上了正确的趋势，或者进入了正确的公司。当然能力肯定不会差，但是要明白很多加成其实来自时和势。如果今天再重复一遍以往做的事，还会如之前一样顺利么？未必。所以有空正确认识这一点。一方面，寻找时和势，让自己顺流而上，另一方面，避免判断错误的时和势，认为参考以往，自己的能力已经足以驾驭。该保守估计的时候要保守，不要因为自己以前能做得好，就认为自己今天一定能做得好。</p><p><strong>12. 找到一些机会，往往是概率事件</strong></p><p>张颖有一次给我们分享了他的早期经历，挺值得借鉴。在投行工作时突然整个机构遇到问题，他被裁员了。面临着巨大的压力，在两个星期的时间，投出了两千份简历，最终他拿到了一个 Offer，后来一路成了投资圈的佼佼者。这里的重点，是两千份简历，拿到一个 Offer，这就足够了。这就是个概率事件，你不需要到处受欢迎，你又不是人民币，你只需要一个机会就足够了。</p><p><strong>13. 设定合理的期望值</strong></p><p>自己的下属现在比自己做的好？曾经认为不如自己的人现在成长速度更快？接受这一点，对自己更好。有朋友动辄就是谁谁谁以前是我的下属，我应该如何如何，言语中总觉得自己高人一等。其实，很多时候只是时间上比人家早一点而已，总有一些人成长速度非常快，把自己放的位置太高，一方面不利于外部的合作，毕竟大家都成长到一定程度了，干嘛要觉得自己比人高？另一方面也给自己太大压力，在后续的求职等等过程中，徒增困扰。</p><p><strong>14. 在核心业务的基础上扩展自己的能力边界</strong></p><p>我自己做过设计师、产品经理、用户增长和市场，所以有时会在不同的圈子里和一些朋友交流。比如一些设计圈里非常资深的朋友，基本上是在各大公司设计这个领域已经做到最高的位置上了，然后聊天的时候会聊些什么呢？不太会聊通常意义上的设计，这些已经默认你能够做好、搞定，或者你能做招到人去做好。大家经常感兴趣的，是听我聊聊线上的用户应该怎么获取、整个大的流量趋势是什么样的、流量的成本结构、如何低成本的推动增长等等。这些话题未必是这个职位的人现在直接负责的，但是为什么大家感兴趣？因为未来很可能用的到。围绕着核心业务，总是有很多机会可以挖掘，而这些机会往往需要的能力是复合型的，越是往前走，越是需要融会贯通。当然一门心思钻一个深的专业领域，同样也可以，只是存在的风险是有可能领域本身不存在了。这在做技术的人当中非常典型。对于大多数人，扩展自己的能力边界，是个好的选择。基于核心业务来有意识的扩展自己的能力边界，很可能今天的收益不是特别明显，但是到了未来某个时候，就会成为你新的竞争力。</p><p><strong>15.你的人未必是你的人</strong></p><p>一位在大公司做中层的朋友说，我出来可以带一个团队出来。其实大部分时候，很可能带不出来几个人。大家聚在一起，是因为有这个平台作为纽带。人可能是你招的、带的，但是当时人家看重的不仅仅是你，还有这个平台。明白这一点，不要产生错误的认识。如前面所说，大多数时候，我们的能力是建构在平台基础之上的。</p><p><strong>16. 保持危机感</strong></p><p>重点是针对 IT 和互联网行业的朋友，这个行业最大的特点就是变化。曾经在甲骨文工作是非常好的事，我有朋友聊起来，说他们在美国每次都感觉甲骨文是很舒服的公司，本身也很赚钱，员工的工作和生活也平衡的很好，听起来很理想，这样的公司是能够工作一辈子的地方。但是现实是残酷的，甲骨文也开始裁员，尽管有补偿，但是很多人都会面临巨大的挑战。其实从一开始就要有这个意识，在这个快速变化的领域，每个人都不可避免的会被这些变化裹挟其中。危机感是客观存在的，早点认识到这一点，在心态上做好准备，比有一天危机突然来临要好。正确认识了危机感，才能有动力让自己不断积累，有动力如这篇文章里其他各个点里提到的那样去做。</p><p><strong>互联网寒冬的当下，你还过得好吗？欢迎大家留言讨论！</strong></p><blockquote><p>本文转载自：「知乎」，原文：<a href="https://url.cn/5Edu7wT%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://url.cn/5Edu7wT，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <code>editor@hi-linux.com</code> 。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;华为、腾讯、京东、阿里都曾被爆出类似「优化中年基层管理者」的新闻，面对「被倒挂」与「被优化」的危机，互联网行业从业者应该如何「自如的面对」？&lt;/p&gt;
&lt;p&gt;这里给大家分享一个知乎上的高赞答案，共勉！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;几年前见到类似的说法，这个数字还是 30 岁。估计再过几年，这个数字会变成 40 岁。&lt;/p&gt;
&lt;p&gt;其实长期来看，大家都会习惯，互联网和其他各个行业一样，所有行业存在的问题，互联网行业都会存在。&lt;/p&gt;
&lt;p&gt;什么是危机？感觉周围的人都在危机，甚至包括一些财富、地位都已经很高的人，仍然逃不过焦虑。似乎焦虑就是自然而然的，伴随着每个人的成长。焦虑多了，就开始危机了。&lt;/p&gt;
&lt;p&gt;我想在这里持续写一些感想，可能对各年龄段的朋友都有一些帮助。其实很多人真到这个年龄，见识和能力都已经很厉害了，我帮忙总结一下。&lt;/p&gt;
&lt;p&gt;前段时间有好朋友和我说，感觉随着年龄增长，会有焦虑。因为年龄越大，会发现技能上面并没有比年轻人高太多，体力和精力可能还要差一些。这样的问题迟早大家都会遇到，无论是在职场中工作了很久，还是刚入职场，有些事实，业务应该早一些了解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="思想" scheme="https://www.hi-linux.com/tags/%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>技术驱动型公司是假命题吗？</title>
    <link href="https://www.hi-linux.com/posts/23923.html"/>
    <id>https://www.hi-linux.com/posts/23923.html</id>
    <published>2020-05-23T02:21:00.000Z</published>
    <updated>2020-05-23T15:22:46.157Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="世界上没有技术驱动型公司">世界上没有技术驱动型公司</h2><p>世界上没有技术驱动型公司，不论 Google、Facebook，还是腾讯、阿里，都不是技术驱动型公司。<strong>因为技术不是源头，需求才是。</strong></p><p>因此一切技术问题，都要服从产品交付和市场反馈。所以，任何公司都不可能以技术去驱动自身。人可以以技术驱动自己进步，但公司不行。</p><p><strong>一家公司可以以技术切入某个市场，但如果它想生存下去，就一定不能以技术为导向，坚持以技术为导向的公司的生命力为零，其下场有两个：破产或者在破产之前被收购。</strong></p><p>如果你真的很痴迷钻研技术，请读研读博最后留校，或者进研究院让国家用纳税人的钱养你。</p><h2 id="每个人都得加班">每个人都得加班</h2><p>资本富集的地方，人都得加班，加班的本质，是人跟着机器跑、人跟着钱跑。</p><p>更为本质地说，资本富集的地方，人作为劳动力，也是资本的一种。<strong>即人是资本而不是人本身。</strong></p><p>资本的运转是不能停的，因为停一下损失的钱太多了，中国和外国都一样。</p><p>知道发达国家为什么产业工人不加班吗？因为制造业已经不是这些国家主要创造财富的领域了。</p><p>发达国家资本富集的地方是金融行业，所以西方国家的金融狗一样加班。</p><p>劳动法？加班费？都不存在的。劳动法和加班费只有在资本离开这个市场后才能给你保证。</p><p>一般公司的策略是：付给你高于其他行业的薪水、换取你 “自愿” 加班。不想加班的同学们，你们可以去考公务员或者去欧洲做IT，我保证你不加班、不但不用加班，你甚至会很闲。</p><a id="more"></a><h2 id="先想后写">先想后写</h2><p>IT 是工科，不是理科，和 IT 行业相似度最高的行业是盖楼房。真的，相似度相当惊人。</p><p>IT 领域最重要的是经验，而不是你有多聪明，不聪明的人，或者更准确地说，不适合做这个行业的人，大学毕业后就改行了。</p><p>记住：你做得好不好，不取决于你是否聪明，而取决于你是否愿意不断读书、不断学习和不断积累。因此，如果你打算投身这个行业，还在学校的话就请抓紧一切时间多读书。</p><p>公司是你创造财富的地方，公司不是学校。你可以在工作中学习，但你不能放下工作然后去学习，除非你的工作已经做完了。</p><p><strong>能大规模商用的技术，都不需要智商，否则这种技术就不可能规模化。某些程序员们，请停止你们的蜜汁自信。</strong></p><p>技术栈，一旦确立了，就很难改了。一个技术人员是如此，一家公司也是如此。根本原因是：每一个栈的 Size 都太深了，就像是 <strong>ulimit -s unlimited</strong> 过一样。</p><p><strong>一个程序员，应该花 80% 的时间做代码设计、画 UML 图、画时序图，20% 的时间写 Code 和 Debug，菜鸟程序员的这个比例恰好是反的。</strong></p><p>一句话，不论这个需求有多紧急，你都一定要 “想好再动手”。“想好” 的标志就是设计文档写好了，文档一旦写好，写代码就是纯粹的无脑工作。</p><p>写文档的目的是让你在 Code 的时候，不需要停下来思考，更不需要推倒重来。如果没有文档也可以做到这一点，你当然可以不写文档，同时思考下自己水平这么高是不是可以要求升职加薪了。</p><p>或者，你是不是在做无聊的 if else 编码工作？</p><h2 id="关注软技能">关注软技能</h2><p>英语，很重要。能否使用英语查阅资料，是区分技术人员水平的重要指示之一。<strong>寄希望于 “有人迟早会翻译成中文” 的人是愚蠢的、是会被淘汰的。</strong></p><p><strong>要有分享精神，不要担心你知道的东西告诉别人后你就没价值了。你最大的价值在于你知道那些东西的过程，而不是那些东西本身。</strong></p><p>你愿意和别人分享，别人自然也会愿意和你分享，最终达到 1+1 大于 2 的效果。</p><p>不分享，就像一个失去了互联网的程序员，试问他还能创造多少价值？恐怕他连日常工作都无法展开了。</p><p>持有 “我把别人知道的都学会，把自己知道的都藏起来，别让别人学去” 想法的人，其实是默认全世界只有你聪明别人都是傻瓜，这样的人，在信息传输成本高的时代，可以活下去，但是在今天这个时代，他们的路会越走越窄，最后会自己走入死胡同。</p><p>当然，如果你真的知道了了不得的黑科技，那就请你保护好自己的知识产权，然后自己开公司玩吧。</p><h2 id="工作要有热情">工作要有热情</h2><p>智商决定你的起点，情商决定你能走多远爬多高。混职场，靠的是情商。</p><p>情商高就是：别人愿意和你一起工作、你有问题的时候别人愿意帮你。智商有时候可以稍微弥补一下情商，但不起决定性的作用。</p><p>现代管理学的精髓，就是让每个人（包括老板本人）都变得可替代。如果你觉得自己不可替代，要么是你的错觉，要么是你在一家管理非常原始的、摇摇欲坠马上要完蛋的公司。</p><h2 id="写好文档">写好文档</h2><p><strong>怎样让程序员变得可替代？三个字：写文档。</strong></p><p>不愿意写文档的程序员，应该立刻马上毫不犹豫地开掉。程序员工作创造的价值，至少一半是通过文档体现出来才对。</p><p>“一个项目换一个人就要让项目大地震一下”，“解决 Bug 换一个人就不行，因为只有老人知道要改哪一行的哪个关键字” 。这不说明这个项目所涉及的技术有多复杂、不说明这个老人是什么技术大牛，而只说明这个项目的项目经理很蠢，这个项目已经失控了。</p><p>文档不是事无巨细的流水账，写文档以及组织文档是需要智商的、是需要架构师去设计的。</p><p>美国的航天飞机那么复杂，但是在 Pilot 手里的手册也就那么多，而这个手册可以在航天飞机出问题的时候协助 Pilot 快速定位绝大多数问题。</p><p><strong>不可替代的打工者只有一种：以中高层领导的身份跟完了一个项目，而且这个项目正处于大红大紫的阶段，公司为了防止你跳槽到竞争对手那里，愿意付给你薪水，养着你天天在办公室喝茶。只要项目一直红着，公司就愿意一直养着你。</strong></p><h2 id="开发人员的文档的作用">开发人员的文档的作用</h2><p>给正在 Code 的自己看、给几个月后已经忘记这个模块当初是怎么开发的自己看、给要接手自己工作的新人看、给周边有关联开发任务的同事看、给领导等有关人员看，这是产品出 Bug 的时候用来和别人怼的武器。</p><p>如果没有文档，这些工作量都会成倍增长。</p><p>代码再精简再直观，也不可能有人类语言直观，谁觉得自己厉害到读代码和读人类语言写的文档速度一样快，那我给你一个我上大学时候写的小程序，麻烦你读一下代码，看看你多长时间可以看明白。</p><blockquote><p>项目地址：<a href="https://github.com/YvesZHI/FallingCode" target="_blank" rel="noopener">https://github.com/YvesZHI/FallingCode</a></p></blockquote><p>这段代码本身并不复杂，应该说非常简单，但是没有文档……读读看吧。</p><p>简而言之，文档，就像盖楼房的设计图，没有图纸，你是不能开始搬砖的。</p><p>领导有没有给你看需求分析文档？有没有拿着需求分析文档给你宣讲你要做什么？没有？不干活。</p><p>测试的同事有没有给你看测试用例文档？有没有给你宣讲？没有？不干活。</p><p>你自己明白领导的意图了吗？明白测试同事的意图了吗？想明白后，开始想自己要开发的模块里的各个功能模块之间的关系，可以画时序图。</p><p>时序图画完了，看看是否有（可能）频繁变化的模块/需求，如果有，请务必使用一些设计模式，如果要用设计模式，请务必画 UML 类图，如果没有频繁变化的模块/需求，请一定不要用设计模式。</p><p>最后，看看在一个功能模块中，有没有逻辑比较复杂的地方，如果有，请画流程图。</p><p>模块和模块之间有没有需要明确的协议？如果有，请把协议写出来。</p><p>上面这一段话，就是你要写的文档，这个文档的读者主要是你，在你的模块出问题之前，别人通常不会读这个文档（不排除你的领导会要求看你这个文档）。</p><p>如果你既不需要时序图又不需要类图又没什么协议需要明确，那么，你就可以不写这个文档。另外，如果这个文档写得好，你的代码是不需要任何注释的。</p><h2 id="技术驱动">技术驱动</h2><p><strong>如果一家公司打着 “我们是技术驱动型公司” 的名号在招人，我劝你一定要想好考察好，再决定是否去这家公司。</strong></p><p>为什么呢？因为我知道他的那句 “技术驱动” 很吸引你，<strong>你想学东西，但是对小公司来说，它最大的任务是活下去，然后才是其他。</strong></p><p>我不是说小公司学不到东西，我只是说小公司很难很难做到真正的技术驱动。</p><p>有人坚持认为微软这种公司是技术驱动，但微软从没大张旗鼓地说自己是 “技术驱动” 公司，并以此忽悠新人。</p><p>以华为为例：华为成功的内在原因，早就敲锣打鼓地告诉全世界了：<strong>以客户为中心，以奋斗者为本，长期艰苦奋斗，坚持自我批判。</strong></p><p>这四句话，没一句是直接和技术相关的。</p><p>这里我先特别声明一下，我不是说，技术人员在华为就不会搞技术、不会提升自己的技术水平、华为的技术水平差。我绝不是这个意思。</p><p>华为的技术，不需要我多说，全世界的人都是有目共睹的，华为公司的技术专利数就摆在那里，那是谁也抹杀不了的，华为公司里的技术大牛多了去了。</p><p>但在这里，我要说的还是第一段的意思：一个人可以以技术驱动，但一家公司不行。</p><p>华为公司的核心理念，本质就是 “成就客户”，你把客户成就了，你就把自己成就了，华为不是先成就自己再去成就客户的公司。</p><p>你去华为工作，你可以以技术驱动自己，但华为不能这样做。</p><p>这一点和微软与 IBM 的合作极其相似：IBM 说，你们微软现在搞的东西我愿意用，但是我需要你们给我搞个操作系统，这样我们才能继续合作。</p><p>然后微软怎么做的呢？它马上购买了另外一家公司搞的 DOS 操作系统，然后直接授权给 IBM 使用。</p><p>这里面有四个问题值得思考：</p><ol><li>为什么那家开发 DOS 的公司没能直接和 IBM 合作？</li><li>微软购买 DOS 系统的钱哪里来的？</li><li>微软为什么不自己开发操作系统？</li><li>技术在前三个问题中的角色和作用是什么？</li></ol><p>至于有人说 Intel 是技术驱动公司，我建议大家可以去了解一下 Intel 为什么放弃了手机市场：重点关注 Intel 决定放弃手机市场的原因，你就会发现，这个原因的本质，就是一种技术情节的产物。</p><p>Intel 放弃手机市场与华为决定进军手机市场是截然不同的。华为本来是做基站、路由器和交换机的，这是它的主营业务。</p><p>那么华为为什么决定进入手机市场？是什么原因驱使华为在没有任何技术积累的前提下进入手机市场？以至于最初华为的手机被华为员工戏称为 “暖手宝”，倒贴钱都没人愿意用，而现在却如此成功？</p><p><strong>所以，我还是那个观点：世界上没有技术驱动型公司。</strong></p><p>我本人就是程序员，我一直都以技术在驱动自己，努力提升自己的技术水平。但是我还是要说：世界上没有技术驱动型公司。</p><p>一个新的 Team  要开发一款软件，它首先要解决的问题，是在产品 1.0 开发出来并且赚到钱之前这个 Team 的经费。</p><p>其次，它要提前找好产品的客户群和可能存在的销售渠道，并且做完相应的工作。</p><p>再次，它要做产品规划，如什么时候出 1.0 版本的产品、哪个模块开发大概要多久、什么类型的问题可以暂时搁置、什么类型的问题不能搁置、要组织公关组公关等（全是项目管理相关内容，和技术没有直接关系）。</p><p>最后，进入产品开发阶段。一旦进入产品开发，就像工厂的流水线一样，是不可能出现什么导致产品开发进行不下去的技术难点的（否则技术 Leader 就是白痴，这种产品在头脑风暴阶段就应该被拍死才对）。</p><p><strong>所以，“期望出现决定产品生死的技术难点，然后自己 NB 闪闪地搞定”这种事情，是不可能发生的。</strong></p><p>同时，在开发过程中，难免出现各种意料之外的 Bug。比如：你负责的模块出现了三个 Bug，其中一个是必现问题，且直接影响功能实现，那这是一定要搞定的。如果你搞不定，Team 会找其他老手和你一起攻关。</p><p>攻关结果有两种，一种是 Bug 解决了，但是不知道为什么；另一种是 Bug 解决了也知道了是为什么。</p><p>对于第一种情况，Team 是不会为了找到原因而让你潜心研究几个月的，为什么？</p><p>因为你还有后续工作要完成，而这个 Bug 已经解决了，不影响用户使用了。</p><p>什么时候才有可能让你继续跟进这个问题呢？1.0 版本的产品市场反馈符合预期，且公司决定要继续投入 2.0 版本 ——只有这个条件满足，你才有可能继续跟进这个问题，为什么是有可能呢？</p><p>因为这个 Bug 已经不影响客户使用了，没必要投入人力去研究了，你如果花几个月的时间去找这个 Bug 的原因，那么请问：2.0版本的工作谁做？</p><p>在很多项目中，类似这种 “问题解决了但是不知道原因” 的bug，是比较常见的，很多时候，直到这个产品生命周期结束，这些 Bug 的原因都没有找到。</p><p>因此，“期望碰到神秘 Bug，然后自己潜心研究几个月，终于把原因找到” 这种事情，很多时候是不存在的。</p><p>接着上面的 “三个 Bug ”继续：另外两个 Bug，是概率发生且发生概率很低。</p><p>这个时候如果工期比较赶，公司会想办法绕过这两个 Bug，比如定时重启服务器、定时清理缓存等（这些方法通常可以绕开低概率 Bug），不会给你 “潜心研究三个月然后把 Bug 解决”的机会的。</p><p>什么时候才有可能让你继续研究这两个 Bug 呢？和第一个 Bug 一样，只有后续继续开发，才有可能让你继续跟进。</p><p>现在，请各位再重新品味一下 “技术驱动” 这个词。到底什么是技术驱动？</p><p><strong>其实这个词真正的含义就是：我们公司效益很好，能养活 NB 的技术团队，所以产品能不断迭代演进开发，随着产品的不断迭代，技术人员有可能会遇到一些其他公司遇不到的问题。</strong></p><p>所以，如果一家新成立的小公司说自己是技术驱动的……连 1.0 版本的产品都没有，就敢说自己是技术驱动？你信吗？不管你信不信，反正我不信。</p><p><strong>简而言之，“技术驱动” 的同义词就是 “我们公司很有钱” + “我们公司不是炒股炒房而是做产品的公司”。</strong></p><p>至于为什么不直接这么说呢？这是因为这种说法不容易被十年寒窗苦读、潜心研究技术的同学接受……</p><p>被 “技术驱动” 迷惑的同学，其实就是读书读傻了，什么叫 “读书读傻了” ？就是把社会和学校等同成同样的东西……</p><p>“很有钱的做 IT 产品的公司”，这个世界上当然是有的，但是这样的公司，根本不会用 “技术驱动” 这种词来忽悠新人。</p><p>最后，隔行如隔山，但隔行不隔理。如果你读完上面的东西，对自己所处的行业有了进一步的认识，我以为，是很正常的。</p><blockquote><p>作者介绍：智煜徽，洛林大学计算机专业研究生，现就职于华为，从事自动驾驶/机器学习相关研发工作。曾在卢森堡-Clearstream 参与分布式金融平台的开发；有创业经历。</p><p>这是来自知乎的一篇贴子，原文：<a href="https://url.cn/5DY4OfB%E3%80%82%E4%B8%BB%E8%A6%81%E7%9A%84%E8%A7%82%E7%82%B9%E6%98%AF%EF%BC%9A%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B2%A1%E6%9C%89%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E5%9E%8B%E5%85%AC%E5%8F%B8%E3%80%82%E8%A7%82%E7%82%B9%E9%A2%87%E6%9C%89%E4%BA%89%E8%AE%AE%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%A4%A7%E5%AE%B6%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9C%8B%E6%B3%95%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E7%95%99%E8%A8%80%E4%BA%A4%E6%B5%81%EF%BC%81" target="_blank" rel="noopener">https://url.cn/5DY4OfB。主要的观点是：世界上没有技术驱动型公司。观点颇有争议，如果大家有不同看法，欢迎大家留言交流！</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;世界上没有技术驱动型公司&quot;&gt;世界上没有技术驱动型公司&lt;/h2&gt;
&lt;p&gt;世界上没有技术驱动型公司，不论 Google、Facebook，还是腾讯、阿里，都不是技术驱动型公司。&lt;strong&gt;因为技术不是源头，需求才是。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此一切技术问题，都要服从产品交付和市场反馈。所以，任何公司都不可能以技术去驱动自身。人可以以技术驱动自己进步，但公司不行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一家公司可以以技术切入某个市场，但如果它想生存下去，就一定不能以技术为导向，坚持以技术为导向的公司的生命力为零，其下场有两个：破产或者在破产之前被收购。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你真的很痴迷钻研技术，请读研读博最后留校，或者进研究院让国家用纳税人的钱养你。&lt;/p&gt;
&lt;h2 id=&quot;每个人都得加班&quot;&gt;每个人都得加班&lt;/h2&gt;
&lt;p&gt;资本富集的地方，人都得加班，加班的本质，是人跟着机器跑、人跟着钱跑。&lt;/p&gt;
&lt;p&gt;更为本质地说，资本富集的地方，人作为劳动力，也是资本的一种。&lt;strong&gt;即人是资本而不是人本身。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;资本的运转是不能停的，因为停一下损失的钱太多了，中国和外国都一样。&lt;/p&gt;
&lt;p&gt;知道发达国家为什么产业工人不加班吗？因为制造业已经不是这些国家主要创造财富的领域了。&lt;/p&gt;
&lt;p&gt;发达国家资本富集的地方是金融行业，所以西方国家的金融狗一样加班。&lt;/p&gt;
&lt;p&gt;劳动法？加班费？都不存在的。劳动法和加班费只有在资本离开这个市场后才能给你保证。&lt;/p&gt;
&lt;p&gt;一般公司的策略是：付给你高于其他行业的薪水、换取你 “自愿” 加班。不想加班的同学们，你们可以去考公务员或者去欧洲做IT，我保证你不加班、不但不用加班，你甚至会很闲。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="思想" scheme="https://www.hi-linux.com/tags/%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>如何有效的清除 DNS 缓存</title>
    <link href="https://www.hi-linux.com/posts/56208.html"/>
    <id>https://www.hi-linux.com/posts/56208.html</id>
    <published>2020-05-23T02:20:00.000Z</published>
    <updated>2020-05-23T14:58:59.770Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>DNS 缓存是一个临时数据库，用于存储有关以前的 DNS 查找的信息。换句话说，每当你访问网站时，你的操作系统和网络浏览器都会保留该域和相应 IP 地址的记录。这消除了对远程 DNS 服务器重复查询的需要，并允许你的 OS 或浏览器快速解析网站的 URL。</p><p>但是在某些情况下，例如：对网络问题进行故障排除，或者在更改 DNS 解析器之后，你将需要刷新 DNS 缓存。这将清除缓存的 DNS 条目，并根据新配置的 DNS 设置执行后续查找以解析域。</p><p>本指南提供有关如何在不同的操作系统和 Web 浏览器上刷新 DNS 缓存的说明。</p><h2 id="在-windows-上清除刷新-dns-缓存">在 Windows 上清除/刷新 DNS 缓存</h2><p>对于所有 Windows 版本，清除 DNS 缓存的过程都是相同的。你需要使用管理员权限打开命令提示符并运行 <code>ipconfig /flushdns</code>。</p><h3 id="windows-10-和-windows-8">Windows 10 和 Windows 8</h3><p>要在 Windows 10 和 Windows 8 中清除 DNS 缓存，请执行以下步骤：</p><ol><li><p>在 Windows 搜索栏中键入 cmd 。</p></li><li><p>右键单击 “命令提示符”，然后右击 “以管理员身份运行”。这将打开 “命令提示符” 窗口。</p></li><li><p>在命令行上，键入以下行，然后按回车：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig &#x2F;flushdns</span><br></pre></td></tr></table></figure><p>成功后，系统将返回以下消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows IP Configuration</span><br><span class="line"></span><br><span class="line">Successfully flushed the DNS Resolver Cache.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="windows-7">Windows 7</h3><p>要在 Windows 7 中清除 DNS 缓存，请执行以下步骤：</p><ol><li><p>单击开始按钮。</p></li><li><p>在开始菜单搜索文本框中键入 cmd。</p></li><li><p>右键单击 “命令提示符”，然后单击 “以管理员身份运行”。这将打开 “命令提示符” 窗口。</p></li><li><p>在命令行上，键入以下行，然后按回车：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig &#x2F;flushdns</span><br></pre></td></tr></table></figure><p>成功后，系统将返回以下消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows IP Configuration</span><br><span class="line"></span><br><span class="line">Successfully flushed the DNS Resolver Cache.</span><br></pre></td></tr></table></figure><h2 id="在-linux-上清除刷新-dns-缓存">在 Linux 上清除/刷新 DNS 缓存</h2><p>在 Linux 上，除非已安装并运行诸如 <code>Systemd-Resolved</code>，<code>DNSMasq</code> 或 <code>Nscd</code> 之类的缓存服务，否则没有操作系统级 <code>DNS</code> 缓存。根据 Linux 发行版和所使用的缓存服务，清除 DNS 缓存的过程有所不同。</p><h3 id="系统化解决">系统化解决</h3><p>大多数现代 Linux 发行版，例如 Ubuntu 18.04，都使用 systemd 解析的服务来缓存 DNS 条目。</p><p>要查找服务是否正在运行，请运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl is-active systemd-resolved.service</span><br></pre></td></tr></table></figure><p>如果该服务正在运行，则将打印命令 active，否则将看到 inactive。</p><p>要清除系统解析的 DNS 缓存，你需要键入以下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemd-resolve --flush-caches</span><br></pre></td></tr></table></figure><p>成功后，该命令不会返回任何消息。</p><h3 id="dnsmasq">Dnsmasq</h3><p>Dnsmasq 是轻量级的 DHCP 和 DNS 缓存名称服务器。</p><p>如果你的系统使用 DNSMasq 作为缓存服务器，则要清除 DNS 缓存，需要重新启动 Dnsmasq 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart dnsmasq.service</span><br></pre></td></tr></table></figure><p>也可以使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service dnsmasq restart</span><br></pre></td></tr></table></figure><h3 id="nscd">NSCD</h3><p><code>NSCD</code> 是一个缓存守护程序，它是大多数基于 RedHat 的发行版的首选 DNS 缓存系统。</p><p>如果系统使用 <code>NSCD</code> 来清除 DNS 缓存，则需要重新启动 <code>NSCD</code> 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nscd.service</span><br><span class="line">或者</span><br><span class="line">$ sudo service nscd restart</span><br></pre></td></tr></table></figure><h2 id="在-macos-上清除刷新-dns-缓存">在 MacOS 上清除/刷新 DNS 缓存</h2><p>根据你所运行的版本，在 MacOS 中刷新缓存的命令略有不同。该命令必须以具有系统管理员特权的用户（sudo 用户）身份运行。</p><p>要清除 MacOS 中的 DNS 缓存，请执行以下步骤：</p><ol><li><p>打开查找器。</p></li><li><p>转到应用程序&gt;实用程序&gt;终端。这将打开终端窗口。</p></li><li><p>在命令行中，输入以下行，然后按回车：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure><p>输入你的 <code>sudo</code> 密码，然后再次按回车。成功后，系统不会返回任何消息。</p><p>对于早期版本的 MacOS，刷新缓存的命令不同。</p><ul><li>MacOS 版本 10.11 和 10.9</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dscacheutil -flushcache</span><br><span class="line">$ sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure><ul><li>MacOS 版本 10.10</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo discoveryutil mdnsflushcache</span><br><span class="line">$ sudo discoveryutil udnsflushcaches</span><br></pre></td></tr></table></figure><ul><li>MacOS 版本 10.6 和 10.5</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dscacheutil -flushcache</span><br></pre></td></tr></table></figure><h2 id="清除刷新浏览器-dns-缓存">清除/刷新浏览器 DNS 缓存</h2><p>大多数现代的 Web 浏览器都有一个内置的 DNS 客户端，以防止每次访问该网站时重复查询。</p><h3 id="谷歌浏览器-chrome">谷歌浏览器 Chrome</h3><p>要清除 Google Chrome 的 DNS 缓存，请执行以下步骤：</p><ol><li><p>打开一个新标签，然后在地址栏输入 <code>chrome://net-internals/#dnsChrome</code>。</p></li><li><p>点击 “清除主机缓存” 按钮。</p></li></ol><p>如果那对你不起作用，请尝试清除缓存和 Cookie。</p><ol><li><p>按下 <code>CTRL+Shift+Del</code> 以打开 “清除浏览数据” 对话框窗口。</p></li><li><p>选择一个时间范围。选择 “所有时间” 以删除所有内容。</p></li><li><p>选中 “Cookie 和其他站点数据” 和 “缓存的图像和文件” 框。</p></li><li><p>点击 “清除数据” 按钮。</p></li></ol><p>此方法适用于所有基于 Chrome 的浏览器，包括 Chromium，Vivaldi 和 Opera。</p><h3 id="火狐-firefox">火狐 Firefox</h3><p>要清除 Firefox 的 DNS 缓存，请执行以下步骤：</p><ol><li><p>在右上角，单击汉堡包图标 ☰ 以打开 Firefox 的菜单：</p></li><li><p>点击 ⚙ Options (Preferences) 链接。</p></li><li><p>单击左侧的 “隐私和安全性” 或 “隐私” 选项卡。</p></li><li><p>向下滚动到该 History 部分，然后单击 Clear History… 按钮。</p></li><li><p>选择要清除的时间范围。选择 “所有内容” 以删除所有内容。</p></li><li><p>选择所有框，然后单击 “立即清除” 。</p></li></ol><p>如果这对你不起作用，请尝试以下方法并暂时禁用 DNS 缓存。</p><ol><li><p>打开一个新标签，然后在 Firefox 的地址栏中输入 <code>about:config</code> 。</p></li><li><p>搜索 <code>network.dnsCacheExpiration</code>，将值暂时设置为 0，然后单击 “确定”。然后，改回默认值，然后单击 “确定” 。</p></li><li><p>搜索 <code>network.dnsCacheEntries</code>，将值暂时设置为 0，然后单击 “确定” 。然后，改回默认值，然后单击 “确定”。</p></li></ol><h2 id="结论">结论</h2><p>至此，你已经了解了如何在 Windows，Linux 和 MacOS 操作系统上清除或刷新 DNS 缓存。</p><p>如果还存在问题，Linux 和 MacOS 还可以使用 <code>dig</code> 命令来查询 DNS 并对 DNS 问题进行故障排除。</p><blockquote><p>来源：myfreax</p><p>原文：<a href="https://tinyurl.com/yyl2n44e" target="_blank" rel="noopener">https://tinyurl.com/yyl2n44e</a></p><p>题图：来自谷歌图片搜索</p><p>版权：本文版权归原作者所有</p><p>投稿：欢迎投稿，邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DNS 缓存是一个临时数据库，用于存储有关以前的 DNS 查找的信息。换句话说，每当你访问网站时，你的操作系统和网络浏览器都会保留该域和相应 IP 地址的记录。这消除了对远程 DNS 服务器重复查询的需要，并允许你的 OS 或浏览器快速解析网站的 URL。&lt;/p&gt;
&lt;p&gt;但是在某些情况下，例如：对网络问题进行故障排除，或者在更改 DNS 解析器之后，你将需要刷新 DNS 缓存。这将清除缓存的 DNS 条目，并根据新配置的 DNS 设置执行后续查找以解析域。&lt;/p&gt;
&lt;p&gt;本指南提供有关如何在不同的操作系统和 Web 浏览器上刷新 DNS 缓存的说明。&lt;/p&gt;
&lt;h2 id=&quot;在-Windows-上清除-刷新-DNS-缓存&quot;&gt;在 Windows 上清除/刷新 DNS 缓存&lt;/h2&gt;
&lt;p&gt;对于所有 Windows 版本，清除 DNS 缓存的过程都是相同的。你需要使用管理员权限打开命令提示符并运行 &lt;code&gt;ipconfig /flushdns&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Windows-10-和-Windows-8&quot;&gt;Windows 10 和 Windows 8&lt;/h3&gt;
&lt;p&gt;要在 Windows 10 和 Windows 8 中清除 DNS 缓存，请执行以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 Windows 搜索栏中键入 cmd 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右键单击 “命令提示符”，然后右击 “以管理员身份运行”。这将打开 “命令提示符” 窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在命令行上，键入以下行，然后按回车：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ipconfig &amp;#x2F;flushdns&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;成功后，系统将返回以下消息：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Windows IP Configuration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Successfully flushed the DNS Resolver Cache.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈边缘计算</title>
    <link href="https://www.hi-linux.com/posts/22481.html"/>
    <id>https://www.hi-linux.com/posts/22481.html</id>
    <published>2020-05-23T02:19:00.000Z</published>
    <updated>2020-05-23T14:58:59.774Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="什么是边缘计算">什么是边缘计算？</h2><p>云计算（Cloud Computing）从 2005 年进入我们的视线至今已经发展了 14 年，商业应用取得了巨大的成功，边缘计算（Edge Computing）则是云计算继续发酵的产物，目前还处于概念阶段。</p><p>那么到底什么是边缘计算呢？ 引用 Wikipedia 对 Edge Computing 的定义，边缘计算是指：</p><blockquote><p>Edge computing is a method of optimising cloud computing systems by performing data processing at the edge of the network, near the source of the data.</p></blockquote><p>与将数据传到远程的云端进行处理相对，边缘计算是一种分布式计算概念。边缘计算在靠近数据源头的网络边缘提供计算和存储资源，允许在数据收集源附近实时处理和分析数据。</p><p>通俗的说，边缘计算是去中心化或分布式的云计算，原始数据不传回云端，而是在本地完成分析。看好边缘计算的人认为计算能力正在从云端向边缘移动，因此边缘计算会成为下一个像云计算这样成功的技术爆发点。另一方面，边缘计算是驱动物联网的关键技术，因此边缘计算的推动者往往是从事物联网的人。</p><p>有了定义还不足以理解边缘计算，你可能会问到底什么是边缘呢？</p><p>边缘是一个很笼统的概念，它是指接近数据源的计算基础设施，不同的边缘计算提供商往往有不同的边缘。比如美国电信公司 AT&amp;T 的边缘就是离客户几英里的蜂窝网络基站；对于世界最大的 CDN 厂商阿卡麦，边缘则是指遍布全球的 CDN 设备；对于机场的监控设备，边缘就是覆盖整个机场无死角的高清摄像头。</p><p><img src="https://img.alicdn.com/tfs/TB1cJS2KhjaK1RjSZKzXXXVwXXa-3197-1854.png" alt=""></p><h2 id="云计算-边缘计算-雾计算">云计算、边缘计算、雾计算</h2><p>云计算发展至今还未到达顶峰，在一些营销的推波助澜下又冒出了个边缘计算，甚至雾计算（Fog Computing）。下面谈一谈他们的区别和联系。</p><a id="more"></a><h3 id="云计算与边缘计算">云计算与边缘计算</h3><p>云计算的概念应该是比较明确的了——一种按使用量付费、通过网络提供的虚拟资源，这些资源包括服务器、运行环境和软件，它们分别对应 IaaS、Paas 和 SaaS。</p><p>下面引用 IIOT EDGE COMPUTING VS. CLOUD COMPUTING 的观点来解释云计算和边缘计算的区别。</p><p>传统的云计算架构要求客户端将数据推送到中心服务器然后再拉回来，比如我们每天都在使用的 ICloud 帮助我们备份照片、短信等。然后这种集中式的云架构对时间敏感、带宽稀缺的工业物联网就不再适用，因此某些关键数据的处理任务最好是在数据源而不是云端，边缘计算应用而生。</p><p>云计算和边缘计算共同参与的物联网解决方案</p><p><img src="https://www.yanxurui.cc/posts/misc/2017-08-08-a-survey-of-edge-computing/edge-v-cloud-computing-graphic.png" alt=""></p><p>边缘计算并不会替代云计算，他们是相辅相成的，简单的说就是大量的计算任务在离用户最近的边缘计算节点上完成，只有少量的数据需要传到云计算中心。它们扮演的角色如下所示：</p><p><strong>CLOUD COMPUTING</strong></p><ul><li>Complex analytics</li><li>Big Data mining</li><li>Sources of business logic</li><li>Machine learning rules</li><li>Advanced visualizations</li><li>Long term data storage/warehousing</li></ul><p><strong>EDGE COMPUTING</strong></p><ul><li>Basic data visualization</li><li>Basic data analytics and short term data historian features</li><li>Data caching, buffering and streaming</li><li>Data pre-processing, cleansing, filtering and optimization</li><li>Some data aggregation</li><li>Device to Device communications/M2M</li></ul><h3 id="边缘计算与雾计算">边缘计算与雾计算</h3><p>思科最早使用雾计算这个术语来描述网络边缘的计算层，可以对数据进行预处理，使数据快速，安全地传输到云端。雾计算与边缘计算非常接近，但也是有区别的。</p><p>以下观点来自 Fog Computing vs. Edge Computing: What’s the Difference?，这篇文章采访了该行业内两位比较权威的从业人士：</p><ul><li>David King 是一家为工业和商业物联网开发边缘智能软件的公司 FogHorn Systems 的 CEO；</li><li>Matt Newton 是一家生产控制器、I/O 设备、中继器和连接边缘设备到网络的软件制造商 Opto 22 的技术市场主管；</li></ul><p>雾计算与边缘计算都是将智能和计算能力推向靠近数据来源的位置，因此他们常常被混用。他们的区别也正是计算能力（大脑）所处的位置：</p><ul><li>雾计算将计算能力推向局域网，在雾节点或物联网的网关处完成数据处理</li><li>边缘计算将边缘网关的智能，处理能力和通信能力直接推送到诸如可编程自动化控制器的设备</li></ul><p>三者的关系如下所示（图片来自Fog vs Edge Computing）：</p><p><img src="https://www.yanxurui.cc/posts/misc/2017-08-08-a-survey-of-edge-computing/cloud-edge-fog-computing.png" alt=""></p><h2 id="边缘计算的优势与问题">边缘计算的优势与问题</h2><h3 id="云计算面临的问题">云计算面临的问题</h3><p>现在的云计算都是集中式的，即把服务器集中在某一个地方，为了使用云计算的计算资源，数据需要先被传输到距离用户很远的数据中心然后集中处理。但是很多设备都无法接入云端，大致是以下两个原因：</p><ol><li><p>数据量大：对于巨大的数据量，这种传输带宽成本难以接受；比如通用电气很早就意识到工业机床上的传感器产生的大量的数据需要在设备边缘进行处理，只将有最有价值的数据移到云端进行机器学习并且在不同设备之间共享（Edge computing could push the cloud to the fringe）</p></li><li><p>速度：对于要求低延迟、密集型计算的智能设备，比如头戴式 VR，机器人，无人机等，受限于网络传输延迟而无法享受云计算的强大计算资源，这些设备还面临一个共同的问题，就是电池续航时间短；</p></li></ol><p>边缘计算概念的提出就是为了解决这样的问题。 在边缘计算中，传感器，控制器和其他连接的设备本身收集和分析物联网数据，或将其传输到附近的计算设备（如服务器或笔记本电脑）进行分析。当数据处理和分析发生在网络边缘（与数据中心或云相对）时，数据可以立即分析并投入运行。</p><h3 id="边缘计算的优势">边缘计算的优势</h3><p>Sprint 公司的物联网事业部经理 Mohamad Nasser 在 Four advantages of edge computing 一文中给出了边缘计算的应用实例，并阐述了边缘计算的四个优势。</p><p><a href="http://openedgecomputing.org" target="_blank" rel="noopener">openedgecomputing.org</a> 的首页上言简意赅的列出了边缘计算的两条优势。</p><p>结合维基百科的观点，将以上内容整理后总结如下：</p><ol><li>接近实时的数据处理：因为数据是在边缘结点进行分析，降低了延迟，提升应用的响应速度</li><li>减少数据传输：数据不需要推送到遥远的云端，减少智能设备和数据中心传输的数据量，节省带宽成本，同时还能减小核心网络的拥堵。比如 Facebook 等社交软件的用户上传的照片在边缘调整到合适的分辨率再上传到云端</li><li>数据安全：一些比较敏感的数据直接在边缘进行分析，不用当心数据泄漏</li><li>提高可用性：分担（offload）了中心服务器的计算任务，一定程度上消除了主要的瓶颈，并且降低了出现单点故障的可能，</li></ol><h3 id="边缘计算的问题">边缘计算的问题</h3><p>任何东西都是有缺点的，如果只看到优点说明理解的不够深入。边缘计算还处于概念阶段，同样存在很多问题，比如：</p><ol><li>使边缘设备具有处理能力意味着更高的成本和更容易被入侵的危险；</li><li>在大量的边缘设备上进行应用部署和服务监控会成为一个棘手的问题；</li><li>在边缘进行分布式计算并与云端协调任务会让应用编程变得更加复杂；</li></ol><h2 id="边缘计算与-cdn">边缘计算与 CDN</h2><p>CDN 的作用简单的说就是通过将图片、视频等静态文件缓存到接近用户的节点上，降低直接访问源站的延迟，从而实现加速。</p><p>CDN 公司拥有遍布各地、接近用户的庞大服务器集群自然成为了优势明显的边缘计算资源，因此结合 CDN 技术的优势，向客户提供边缘计算服务成为了传统 CDN 公司向创新型服务商转变的一个新的突破点。</p><p>以下是边缘计算在 CDN 的探索性应用：</p><ol><li><p>国内 CDN 行业的龙头老大网宿认为未来 CDN 的演进方向之一是形成边缘计算系统。因此，网宿科技对 MEC 有着清晰的规划。网宿科技将通过布局集中式数据中心+边缘计算节点，用中心云+边缘云的方式承载未来。此外，公司正在升级现有 CDN 节点为具备存储、计算、传输、安全功能的边缘计算节点，部署数量更多的边缘计算节点到距离用户更近的城域网（出处：深度报告：移动边缘计算，站在5G “中央”）。此外网宿基于边缘计算的方式，成功研发出边缘弹幕分发技术，所有的弹幕在网宿平台上直接进行分发，不用再回源，解救了直播平台弹幕压力大的一大痛点。（出处：CDN 掀起二次变革：从传输服务到边缘计算）</p></li><li><p>阿卡迈在全球节点上除了做传统 CDN 分发之外，还利用自身分布式运算的能力，帮助用户解决业务逻辑问题。举个简单例子，阿卡迈在云端部署方面，可以精确识别用户所在的位置和用户所使用的浏览器类型。还能精确识别这个客户所在的运营商所属的组织机构等。利用这些信息，我们就可以在云端帮助客户做一些逻辑判断，帮助用户完成在云端的一些通用型逻辑处理，例如把来自手机的访问自动重定向到M站（手机站），以及将浏览器语言自动定向到所属国家和地区。通过云端的逻辑智能处理，就大大节省客户在应用编码上的时间，上述的这些技术都已经产品化，并已经是经过很多客户验证过的解决方案，让客户通过简单的配置在几小时之内在云端实现，降低操作的难度以及缩短部署推向市场的时间（出处：阿卡迈梁世鹏：云计算与 CDN 是一对天生的孪生兄弟）。阿卡麦通过与 IBM 合作，使客户可以直接将 Java 应用部署到分布在全球的边缘设备上，实现就近计算，提升用户体验（出处：Akamai, IBM team for edge computing）。</p></li><li><p>英特尔提出了利用 CDN 节点直接进行视频转码、分发和存储的视频直播解决方案，数据不用回流到源站，大大节省了带宽资源，并且获得更好的用户体验（出处：边缘计算揽洪荒之力挺直播大潮 GPU 携深度学习助智能 CDN）。</p></li></ol><blockquote><p>来源：Xurui Yan Blog<br>原文：<a href="http://t.cn/AiWYM1f2" target="_blank" rel="noopener">http://t.cn/AiWYM1f2</a><br>题图：来自谷歌图片搜索<br>版权：本文版权归原作者所有<br>投稿：欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是边缘计算？&quot;&gt;什么是边缘计算？&lt;/h2&gt;
&lt;p&gt;云计算（Cloud Computing）从 2005 年进入我们的视线至今已经发展了 14 年，商业应用取得了巨大的成功，边缘计算（Edge Computing）则是云计算继续发酵的产物，目前还处于概念阶段。&lt;/p&gt;
&lt;p&gt;那么到底什么是边缘计算呢？ 引用 Wikipedia 对 Edge Computing 的定义，边缘计算是指：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Edge computing is a method of optimising cloud computing systems by performing data processing at the edge of the network, near the source of the data.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与将数据传到远程的云端进行处理相对，边缘计算是一种分布式计算概念。边缘计算在靠近数据源头的网络边缘提供计算和存储资源，允许在数据收集源附近实时处理和分析数据。&lt;/p&gt;
&lt;p&gt;通俗的说，边缘计算是去中心化或分布式的云计算，原始数据不传回云端，而是在本地完成分析。看好边缘计算的人认为计算能力正在从云端向边缘移动，因此边缘计算会成为下一个像云计算这样成功的技术爆发点。另一方面，边缘计算是驱动物联网的关键技术，因此边缘计算的推动者往往是从事物联网的人。&lt;/p&gt;
&lt;p&gt;有了定义还不足以理解边缘计算，你可能会问到底什么是边缘呢？&lt;/p&gt;
&lt;p&gt;边缘是一个很笼统的概念，它是指接近数据源的计算基础设施，不同的边缘计算提供商往往有不同的边缘。比如美国电信公司 AT&amp;amp;T 的边缘就是离客户几英里的蜂窝网络基站；对于世界最大的 CDN 厂商阿卡麦，边缘则是指遍布全球的 CDN 设备；对于机场的监控设备，边缘就是覆盖整个机场无死角的高清摄像头。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tfs/TB1cJS2KhjaK1RjSZKzXXXVwXXa-3197-1854.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;云计算、边缘计算、雾计算&quot;&gt;云计算、边缘计算、雾计算&lt;/h2&gt;
&lt;p&gt;云计算发展至今还未到达顶峰，在一些营销的推波助澜下又冒出了个边缘计算，甚至雾计算（Fog Computing）。下面谈一谈他们的区别和联系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="边缘计算" scheme="https://www.hi-linux.com/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>如何平滑的变更单表超 100000000 条记录的数据库结构</title>
    <link href="https://www.hi-linux.com/posts/33485.html"/>
    <id>https://www.hi-linux.com/posts/33485.html</id>
    <published>2020-05-23T02:18:00.000Z</published>
    <updated>2020-05-23T14:58:59.775Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>众所周知，很多互联网业务都面临着无法停机，需要在线变更数据库结构的情况。但是在线修改数据量较大的表，可能对线上业务产生较大影响，比如：</p><ol><li><p>在线修改大表的表结构执行时间往往不可预估，一般时间较长。</p></li><li><p>由于修改表结构是表级锁，因此在修改表结构时，影响表写入操作。</p></li><li><p>如果长时间的修改表结构，中途修改失败，由于修改表结构是一个事务，因此失败后会还原表结构，在这个过程中表都是锁着不可写入。</p></li><li><p>修改大表结构容易导致数据库 CPU、IO 等性能消耗，使 MySQL 服务器性能降低。</p></li><li><p>在线修改大表结构容易导致主从延时，从而影响业务读取。</p></li></ol><a id="more"></a><p>Percona-Toolkit 源自 Maatkit 和 Aspersa 工具，这两个工具是管理 MySQL 的最有名的工具，但 Maatkit 已经不维护了，全部归并到 Percona-Toolkit。Percona Toolkit 是一组高级的命令行工具，用来管理 MySQL 和系统任务，主要包括以下功能：</p><ol><li><p>验证主节点和复制数据的一致性</p></li><li><p>有效的对记录行进行归档</p></li><li><p>找出重复的索引</p></li><li><p>总结 MySQL 服务器</p></li><li><p>从日志和 tcpdump 中分析查询</p></li><li><p>问题发生时收集重要的系统信息</p></li><li><p>在线修改表结构</p></li></ol><p>pt-online-schema-change 是 Percona-Toolkit 工具集中的一个组件，很多 DBA 在使用 Percona-Toolkit 时第一个使用的工具就是它，同时也是使用最频繁的一个工具。它可以做到在修改表结构的同时（即进行 DDL 操作）不阻塞数据库表 DML 的进行，这样降低了对生产环境数据库的影响。</p><p>在 MySQL 5.6.7 之前是不支持 Online DDL 特性的，即使在添加二级索引的时候有 FIC 特性，但是在修改表字段的时候还是会有锁表并阻止表的 DML 操作。这样对于 DBA 来说是非常痛苦的，好在有 pt-online-schema-change 工具在没有 Online DDL 时解决了这一问题，pt-online-schema-change 其主要特点就是在数据库结构修改过程中不会造成读写阻塞。</p><h2 id="pt-online-schema-change-安装">pt-online-schema-change 安装</h2><p>pt-online-schema-change 安装非常简单，官方已经为我们准备好了各主流平台的安装包，只需下载对应版本安装即可。目前最新版本是 3.1.0，这里我们以 CentOS 7 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装相关依赖包</span><br><span class="line">$ yum install perl-DBI perl-DBD-MySQL perl-Time-HiRes perl-IO-Socket-SSL</span><br><span class="line">$ wget https:&#x2F;&#x2F;www.percona.com&#x2F;downloads&#x2F;percona-toolkit&#x2F;3.1.0&#x2F;binary&#x2F;redhat&#x2F;7&#x2F;x86_64&#x2F;percona-toolkit-3.1.0-2.el7.x86_64.rpm</span><br><span class="line">$ rpm -ivh percona-toolkit-3.1.0-2.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>更多平台的安装包可以直接在官网地址下载：<a href="https://www.percona.com/downloads/percona-toolkit/LATEST/" target="_blank" rel="noopener">https://www.percona.com/downloads/percona-toolkit/LATEST/</a></p><h2 id="pt-online-schema-change-语法说明">pt-online-schema-change 语法说明</h2><ol><li>常用选项说明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">$ pt-online-schema-change [OPTIONS] DSN</span><br><span class="line"></span><br><span class="line">--alter</span><br><span class="line">变更结构选项，不需要ALTER TABLE关键字，如果表有多个变更可以使用逗号分隔。</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">1.在绝大部分情况下表都需要有主键或者是唯一索引。因为这个工具会在运行的时候创建一个DELETE触发器，这是为了保证在变更中新表能够与旧表保持更新一致性。值得注意的是，如果在需要变更的列上创建主键或是唯一索引时，则会以这些列创建触发器；</span><br><span class="line">2.不能使用RENAME子句为表进行重命名；</span><br><span class="line">3.字段不能通过删除再重添加的方式进行重命名，这种方式是不会拷贝原字段的数到新字段上；</span><br><span class="line">4.如果新增 NOT NULL 的列并且没有指定 default 值，工具就会执行失败，它并不会指定默认值；</span><br><span class="line">5.涉及到删除外键时，需要指定 _constraint_name，工具会在新表上创建一个前面加了下划线的外键名称，这个外键名称与原致。如需要删除外键 fk_foo，则指定 &#39;--alter &quot;DROP FOREIGN KEY _fk_foo&quot;&#39;。</span><br><span class="line"></span><br><span class="line">--alter-foreign-keys-method</span><br><span class="line">采用何种方式修改外键以便关联到新表上。有外键约束的表需要被特殊处理，为了确保外键依然能够关联到正确的表上。当工具重命名外键关联的父表时，确保外键也必须关联到重命名后的父表。</span><br><span class="line"></span><br><span class="line">主要有以下几种方式：</span><br><span class="line"></span><br><span class="line">auto：让工具自动选择使用。优先选择 rebuild_constraints，如果不成功，则选择 drop_swap；</span><br><span class="line">rebuild_constraints：这种方式使用 ALTER TABLE 先删除然后重建外键关联到新父表。这是首选的方式，如果一张或多张子表过大会导致 ALTER 需要很长时间，子表会被阻塞；</span><br><span class="line">drop_swap：禁用外键约束 (FOREIGN_KEY_CHECKS&#x3D;0) ，在进行重命名新父表之前删除原父表，这与常规转换旧表与新表的方式不同，这个 RENAME 操作是原子性的并且对应用客户端无感知。</span><br><span class="line"></span><br><span class="line">这种方式更快速并且不会阻塞，但是也有隐患：</span><br><span class="line"></span><br><span class="line">1.删除原父表以及重命名新表这段时间很短，如果这段时间更改子表有可能会报错；</span><br><span class="line">2.如果重命名新表发生失败，而原父表已经永久删除了，这时就需要人工进行干预了。</span><br><span class="line"></span><br><span class="line">这种方式强制使用选项 &#39;--no-swap-tables&#39; 和 &#39;--no-drop-old-table&#39;。</span><br><span class="line"></span><br><span class="line">none：这种方式类似于 drop_swap，不同在于不进行 swap 原父表。子表有任何外键关联父表都将变成关联一张不存在的表，这会使得子表的外键约束失效，可以通过 SHOW ENGINE INNODB STATUS 查看。</span><br><span class="line"></span><br><span class="line">--[no]analyze-before-swap</span><br><span class="line">默认值：yes</span><br><span class="line">在新表与旧表完成转换之前对新表执行 ANALYZE TABLE 操作，默认会在 MySQL 5.6 及之后版本并且开启 innodb_stats_persistent 的情况下执行。</span><br><span class="line"></span><br><span class="line">--ask-pass</span><br><span class="line">命令行提示密码输入，保护密码安全，前提需安装模块 perl-TermReadKey。</span><br><span class="line"></span><br><span class="line">--[no]check-alter</span><br><span class="line">默认值：yes</span><br><span class="line"></span><br><span class="line">解析变更选项的内容，发出表变更警告，主要警告项为：</span><br><span class="line"></span><br><span class="line">1.字段重命名</span><br><span class="line"></span><br><span class="line">在工具的早期版本中，通过指定 CHANGE COLUMN name new_name 进行字段重命名会导致数据库的丢失，现在的版本已经通过代码解决了数据一致性问题。但这段代码并不能保证能够确保数据的不丢失。所以当涉及到字段名变更时应通过添加选项 &#39;--dry-run&#39; 和 &#39;--print&#39; 查看变更是否可以正确执行。</span><br><span class="line"></span><br><span class="line">2.删除主键</span><br><span class="line"></span><br><span class="line">如果 &#39;--alter&#39; 选项中包含 DROP PRIMARY KEY 删除主键的操作，除非指定选项 &#39;--dry-run&#39;，否则工具将退出。变更表的主键是十分危险的，工具变更时建立的触发器，尤其是 DELETE 触发器，是基于主键的，在做主键变更前先添加选项 &#39;--dry-run&#39; 和 &#39;--print&#39; 验证触发器是可用的。</span><br><span class="line"></span><br><span class="line">--[no]check-replication-filters</span><br><span class="line">默认值：yes</span><br><span class="line">如果服务器指定了任何主从复制过滤选项，该工具会查询是否有复制过滤选项，一旦发现，工具都会中止并报错。</span><br><span class="line"></span><br><span class="line">--check-slave-lag</span><br><span class="line">指定暂停旧表与新表的数据拷贝直到主从复制小于选项 &#39;--max-lag&#39; 指定的值。</span><br><span class="line"></span><br><span class="line">--skip-check-slave-lag</span><br><span class="line">DSN 类型，可重复使用</span><br><span class="line">指定 DSN 连接从库时跳过主从延迟检查，可以指定多个从库检查。</span><br><span class="line"></span><br><span class="line">--check-interval</span><br><span class="line">默认值：1s</span><br><span class="line">指定因为选项 &#39;--max-lag&#39; 检查之间休眠时间。</span><br><span class="line"></span><br><span class="line">--chunk-index</span><br><span class="line">指定使用哪个索引对表进行 chunk 分块操作。默认情况下会选择最优的索引，工具会在 SQL 语句中添加 FORCE INDEX 子句。</span><br><span class="line"></span><br><span class="line">--chunk-index-columns</span><br><span class="line">指定使用选项 &#39;--chunk-index&#39; 的索引使用最左前缀几个索引字段，只适用于复合索引。</span><br><span class="line"></span><br><span class="line">--chunk-size</span><br><span class="line">默认值：1000</span><br><span class="line">指定表分块的 chunk 大小，每个 chunk 需要拷贝的表行数，允许的后缀单位为 k、M、G。</span><br><span class="line">当指定了这个选项会覆盖工具默认动态调整 chunk 块大小以便在选项 &#39;--chunk-time&#39; 指定时间内完成行拷贝的行为。</span><br><span class="line"></span><br><span class="line">--chunk-time</span><br><span class="line">默认值：0.5</span><br><span class="line">动态调整每个 chunk 的大小使相应的表行数都在指定的时间内完成拷贝查询。如果该选项值设置为 0，则不会动态调整 chunk 的大小，就有可能造成每次拷贝查询的时间不同，但每个 chunk 大小还是一致的。</span><br><span class="line"></span><br><span class="line">--host，-h</span><br><span class="line">指定连接的数据库 IP 地址。</span><br><span class="line"></span><br><span class="line">--port，-P</span><br><span class="line">指定连接的数据库 Port 端口。</span><br><span class="line"></span><br><span class="line">--user，-u</span><br><span class="line">指定连接的数据库用户。</span><br><span class="line"></span><br><span class="line">--password，-p</span><br><span class="line">指定连接的数据库用户密码。</span><br><span class="line"></span><br><span class="line">--database，-D</span><br><span class="line">指定连接的数据库。</span><br><span class="line"></span><br><span class="line">--charset，-A</span><br><span class="line">指定连接字符集。</span><br><span class="line"></span><br><span class="line">--max-lag</span><br><span class="line">默认值：1s</span><br><span class="line">指定允许主从复制延迟时长的最大值，单位秒。如果在每次拷贝查询之后主从延迟超过指定的值，则操作将暂停执行，暂停休眠时间为选项 &#39;--check-interval&#39; 指定的值。待休眠时间结束之后再次检查主从延迟时长，检查方法是通过从库查询的 &#39;Seconds_Behind_Master&#39; 值来确定。如果主从复制延迟一直大于该参数指定值或者从库停止复制，则操作将一直等待直到从库重新启动并且延迟小于该参数指定值。</span><br><span class="line"></span><br><span class="line">--max-load</span><br><span class="line">数组类型，默认值：Threads_running &#x3D; 25</span><br><span class="line">在变更拷贝完每个 chunk 数据之后，运行 SHOW GLOBAL STATUS 检查所指定变量值高于该参数指定变量的阈值时将暂停操作。如果有多个变量阈值，可以用 &#39;,&#39;(逗号)进行分隔，参数指定型式可以为变量名 &#x3D;MAX_VALUE 或变量名 :MAX_VALUE。</span><br><span class="line">如果只是指定变量名，没有为其指定阈值，则检查当前值并增加 20% 作为阈值。如：</span><br><span class="line">    --max-load&#x3D;Threads_running：没有指定具体值，以当前查询值增加 20% 作为阈值，如当前为 100，阈值为 120；</span><br><span class="line">    --max-load&#x3D;Threads_running:10：以当前指定值为阈值。</span><br><span class="line"></span><br><span class="line">--critical-load</span><br><span class="line">数组类型，默认值：Threads_running &#x3D; 50</span><br><span class="line">指定需中止操作的状态变量阈值。用法可以参考选项 &#39;--max-load&#39;。</span><br><span class="line"></span><br><span class="line">--preserve-triggers 指定保留旧表的触发器。</span><br><span class="line"></span><br><span class="line">从 MySQL 5.7.2 起开始支持在同一张给定的表上定义具有相同触发事件和触发时间的多个触发器。这意味着如果表原来已有触发器，那么工具所需的触发器也可以创建成功。如果指定了该选项，则工具将旧表上所有的触发器复制到新表上，然后再进行表数据行的拷贝操作。</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">1.如果旧表上的触发器引用了将被工具删除的字段，则触发器失效；</span><br><span class="line">2.该选项不能与选项 &#39;--no-drop-triggers&#39;、&#39;--no-drop-old-table&#39; 和 &#39;--no-swap-tables&#39; 一起使用，因为该选项需要删除旧表的触发器并在新表上重新创建，因为表不可能有多个同名的触发器。</span><br><span class="line"></span><br><span class="line">--null-to-not-null</span><br><span class="line">指定可以将允许NULL的字段转换为 NOT NULL 字段。其中如有包含 NULL 行的字段值转换为字段默认值，如果没有字段值，则根字段类型来分配默认值。如：字符串类型为 &#39;&#39;(空字符串)，数值类型为 0。</span><br><span class="line"></span><br><span class="line">--new-table-name</span><br><span class="line">字符串类型，默认值：%T_new</span><br><span class="line">指定旧表和新表交换之前新表的名称。%T会替换为旧表名称。</span><br><span class="line"></span><br><span class="line">--[no]drop-new-table</span><br><span class="line">默认值：yes</span><br><span class="line">指定如果拷贝旧表数据到新表时失败，则删除新表。</span><br><span class="line">如果指定选项 &#39;--no-drop-new-table&#39; 以及 &#39;--no-swap-tables&#39; 将保留一份变更后的副本，但不会对旧表进行修改。</span><br><span class="line"></span><br><span class="line">限制：当选项 &#39;--alter-foreign-keys-method&#39; 指定的方式为 drop_swap 时，选项 &#39;--no-drop-new-table&#39; 不生效。</span><br><span class="line"></span><br><span class="line">--[no]drop-old-table</span><br><span class="line">默认值：yes</span><br><span class="line">指定在完成旧表与新表交换重命名之后删除旧表。如果之间发生了错误，则会保留旧表。指定选项 &#39;--no-swap-tables&#39; 同样不会删除旧表。</span><br><span class="line"></span><br><span class="line">--[no]drop-triggers</span><br><span class="line">默认值：yes</span><br><span class="line">指定旧表上删除触发器。如果指定了选项 &#39;--no-drop-triggers&#39; 就会强制指定 &#39;--no-drop-old-table&#39;。</span><br><span class="line"></span><br><span class="line">--[no]swap-tables</span><br><span class="line">默认值：yes</span><br><span class="line">指定变更交换旧表和新表。</span><br><span class="line">如果指定选项 &#39;--no-swap-tables&#39; 也会运行整个过程，只是最后不进行旧表与新表的交换，并且删除新表。</span><br><span class="line"></span><br><span class="line">--dry-run</span><br><span class="line">指定创建和变更新表，但是不创建触发器，也不拷贝数据和变更原始表。</span><br><span class="line"></span><br><span class="line">--execute</span><br><span class="line">指定需要执行真正的变更操作。当确定要执行变更操作时必须指定该选项，如果不指定该选项，则工具会进行安全检查之后退出。</span><br><span class="line"></span><br><span class="line">--[no]check-unique-key-change</span><br><span class="line">默认值：yes</span><br><span class="line">当工具要进行添加唯一索引的变更时停止运行。因为工具使用语句 INSERT IGNORE 从旧表进行数据拷贝插入新表，如果插入的值违返唯一性约束，数据插入不会明确提示失败但这样会造成数据丢失。</span><br><span class="line"></span><br><span class="line">--recursion-method</span><br><span class="line">默认值：processlist，hosts</span><br><span class="line">指定获取从库的方式。</span><br><span class="line">METHOD       USES</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">processlist  SHOW PROCESSLIST   </span><br><span class="line">hosts        SHOW SLAVE HOSTS   </span><br><span class="line">dsn&#x3D;DSN      DSNs from a table</span><br><span class="line">none         Do not find slaves</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">processlist：通过SHOW PROCESSLIST方式找到 slave，为默认方式，当 SHOW SLAVE HOSTS 不可用时。一旦实例运行在非 3306 端口上时，hosts 方式就会变为默认方式；</span><br><span class="line">hosts：通过 SHOW SLAVE HOSTS 方式找到 slave，hosts 方式要求从库配置 &#39;--report_host&#39; 和 &#39;--report_port&#39; 这两个参数；</span><br><span class="line">dsn：通过读取表中从库的 DSN 信息进行连接。</span><br><span class="line"></span><br><span class="line">--recurse</span><br><span class="line">指定搜寻从库的层级，默认无限级。</span><br><span class="line"></span><br><span class="line">--set-vars</span><br><span class="line">默认：</span><br><span class="line">    wait_timeout&#x3D;10000</span><br><span class="line">    innodb_lock_wait_timeout&#x3D;1</span><br><span class="line">    lock_wait_timeout&#x3D;60</span><br><span class="line">运行检查时指定参数值，如有多个用&#39;,&#39;(逗号)分隔。如 &#96;--set-vars&#x3D;wait_timeout&#x3D;5000&#96;。</span><br><span class="line"></span><br><span class="line">--sleep</span><br><span class="line">默认值：0s</span><br><span class="line">指定表变更拷贝数据时的间隔时间。</span><br><span class="line"></span><br><span class="line">--print</span><br><span class="line">打印工具执行过程中的语句到 STDOUT。可以结合 &#39;--dry-run&#39;一起使用。</span><br><span class="line"> </span><br><span class="line">--progress</span><br><span class="line">打印工具执行过程的进度提示到 STDERR。选项值有两部分组成，用逗号进行分隔，第一部分为百分比，时间和迭代。第二部分为根据第一部分数据更新频率，也分为百分比，时间和迭代。</span><br><span class="line"></span><br><span class="line">--quiet，-q</span><br><span class="line">不打印工具执行过程的信息到 STDOUT (禁用&#39;--progress&#39;)。但错误和警告还是打印到 STDERR。</span><br><span class="line"></span><br><span class="line">--statistics</span><br><span class="line">打印内部计数的统计信息。</span><br><span class="line"></span><br><span class="line">--version</span><br><span class="line">显示工具的版本并退出。</span><br><span class="line"></span><br><span class="line">--[no]version-check</span><br><span class="line">默认值：yes</span><br><span class="line">检查 Percona Toolkit、MySQL 和其他程序的最新版本。</span><br></pre></td></tr></table></figure><ol start="2"><li>DSN 选项(DSN)</li></ol><p>可以使用 DSN 方式来连接数据库，DSN 选项为 key=value 方式，在等号的两侧不能有空格出现，并且区分大小写，多个选项之前以’,’(逗号)隔开，主要选项如下：</p><ul><li><p>A 指定字符集</p></li><li><p>D 指定变更表所在数据库</p></li><li><p>t 指定需要变更的表</p></li><li><p>h 指定要连接的 HOST</p></li><li><p>P 指定要连接的 PORT</p></li><li><p>S 指定连接所使用的 SOCKET 文件(Unix systems)</p></li><li><p>u 指定连接的用户名</p></li><li><p>p 指定连接的用户名密码</p></li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;employees</span><br></pre></td></tr></table></figure><h2 id="pt-online-schema-change-使用限制">pt-online-schema-change 使用限制</h2><ol><li><p>要求需要执行变更的表有主键 (Primary key) 或唯一索引 (Unique index)，否则工具会执行失败，参考选项 --alter 说明；</p></li><li><p>如果检测到表有外键约束 (Foreign key)，工具除非选项 --alter-foreign-keys-method，否则不会执行变更；</p></li><li><p>如果检测到主从复制中存在过滤，则工具不会执行，参考选项 --[no]check-replication-filters 说明；</p></li><li><p>如果检测到主从复制有延迟，则工具有可能会暂停数据拷贝，参考选项 --max-lag 说明；</p></li><li><p>如果检测到连接当前服务器负载过高，则工具有可能暂停执行或中止退出，参考选项 --max-load 各 --critical-load 说明。</p></li></ol><h2 id="pt-online-schema-change-使用实例">pt-online-schema-change 使用实例</h2><ol><li>测试数据准备</li></ol><p>本文基于 MySQL 官方示例数据库 employee：Example Databases 进行测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">-- employees：</span><br><span class="line">mysql root@localhost:employees&gt; show create table employees\G;</span><br><span class="line">***************************[ 1. row ]***************************</span><br><span class="line">Table        | employees</span><br><span class="line">Create Table | CREATE TABLE &#96;employees&#96; (</span><br><span class="line">  &#96;emp_no&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;birth_date&#96; date NOT NULL,</span><br><span class="line">  &#96;first_name&#96; varchar(14) NOT NULL,</span><br><span class="line">  &#96;last_name&#96; varchar(16) NOT NULL,</span><br><span class="line">  &#96;gender&#96; enum(&#39;M&#39;,&#39;F&#39;) NOT NULL,</span><br><span class="line">  &#96;hire_date&#96; date NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;emp_no&#96;),</span><br><span class="line">  KEY &#96;idx_first_last&#96; (&#96;first_name&#96;,&#96;last_name&#96;),</span><br><span class="line">  KEY &#96;idx_birth_hire&#96; (&#96;birth_date&#96;,&#96;hire_date&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.008s</span><br><span class="line"></span><br><span class="line">-- dept_emp：</span><br><span class="line">mysql root@localhost:employees&gt; show create table dept_emp\G;</span><br><span class="line">***************************[ 1. row ]***************************</span><br><span class="line">Table        | dept_emp</span><br><span class="line">Create Table | CREATE TABLE &#96;dept_emp&#96; (</span><br><span class="line">  &#96;emp_no&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;dept_no&#96; char(4) NOT NULL,</span><br><span class="line">  &#96;from_date&#96; date NOT NULL,</span><br><span class="line">  &#96;to_date&#96; date NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;emp_no&#96;,&#96;dept_no&#96;),</span><br><span class="line">  KEY &#96;dept_no&#96; (&#96;dept_no&#96;),</span><br><span class="line">  CONSTRAINT &#96;dept_emp_ibfk_1&#96; FOREIGN KEY (&#96;emp_no&#96;) REFERENCES &#96;employees&#96; (&#96;emp_no&#96;) ON DELETE CASCADE,</span><br><span class="line">  CONSTRAINT &#96;dept_emp_ibfk_2&#96; FOREIGN KEY (&#96;dept_no&#96;) REFERENCES &#96;departments&#96; (&#96;dept_no&#96;) ON DELETE CASCADE</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.010s</span><br><span class="line"></span><br><span class="line">-- departments：</span><br><span class="line">mysql root@localhost:employees&gt; show create table departments\G;</span><br><span class="line">***************************[ 1. row ]***************************</span><br><span class="line">Table        | departments</span><br><span class="line">Create Table | CREATE TABLE &#96;departments&#96; (</span><br><span class="line">  &#96;dept_no&#96; char(4) NOT NULL,</span><br><span class="line">  &#96;dept_name&#96; varchar(40) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;dept_no&#96;),</span><br><span class="line">  UNIQUE KEY &#96;dept_name&#96; (&#96;dept_name&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.012s</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; select count(*) from employees;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">| 300024   |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.342s</span><br><span class="line">mysql root@localhost:employees&gt; select count(*) from dept_emp;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">| 331603   |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.306s</span><br><span class="line">mysql root@localhost:employees&gt; select count(*) from departments;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">| 9        |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.050s</span><br></pre></td></tr></table></figure><ol start="2"><li>添加一个字段</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;employees --user&#x3D;admin --ask-pass --alter &quot;add comment varchar(50) not null default &#39;pt-osc&#39;&quot; --charset&#x3D;utf8</span><br></pre></td></tr></table></figure><p>因为 employees 表中的 emp_no 字段被其他表外建关联，以下命令执行时会报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You did not specify --alter-foreign-keys-method, but there are foreign keys that reference the table. Please read the tool&#39;s documentation carefully.</span><br></pre></td></tr></table></figure><p>根据报错信息的提示，加入选项 <code>--alter-foreign-keys-method</code> 重新执行并通过选项 <code>--dry-run</code> 查看执行过程主要信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;employees --user&#x3D;admin --ask-pass --alter &quot;add comment varchar(50) not null default &#39;pt-osc&#39;&quot; --alter-foreign-keys-method&#x3D;auto --charset&#x3D;utf8 --dry-run</span><br><span class="line">Enter MySQL password:</span><br><span class="line"></span><br><span class="line">Operation, tries, wait:</span><br><span class="line">  analyze_table, 10, 1</span><br><span class="line">  copy_rows, 10, 0.25</span><br><span class="line">  create_triggers, 10, 1</span><br><span class="line">  drop_triggers, 10, 1</span><br><span class="line">  swap_tables, 10, 1</span><br><span class="line">  update_foreign_keys, 10, 1</span><br><span class="line">Child tables:</span><br><span class="line">  &#96;employees&#96;.&#96;dept_emp&#96; (approx. 331143 rows)</span><br><span class="line">  &#96;employees&#96;.&#96;dept_manager&#96; (approx. 24 rows)</span><br><span class="line">Will automatically choose the method to update foreign keys.</span><br><span class="line">Starting a dry run.  &#96;employees&#96;.&#96;employees&#96; will not be altered.  Specify --execute instead of --dry-run to alter the table.</span><br><span class="line">Creating new table...</span><br><span class="line">Created new table employees._employees_new OK.</span><br><span class="line">Altering new table...</span><br><span class="line">Altered &#96;employees&#96;.&#96;_employees_new&#96; OK.</span><br><span class="line">Not creating triggers because this is a dry run.</span><br><span class="line">Not copying rows because this is a dry run.</span><br><span class="line">Not determining the method to update foreign keys because this is a dry run.</span><br><span class="line">Not swapping tables because this is a dry run.</span><br><span class="line">Not updating foreign key constraints because this is a dry run.</span><br><span class="line">Not dropping old table because this is a dry run.</span><br><span class="line">Not dropping triggers because this is a dry run.</span><br><span class="line">2019-03-25T13:30:05 Dropping new table...</span><br><span class="line">2019-03-25T13:30:05 Dropped new table OK.</span><br><span class="line">Dry run complete.  &#96;employees&#96;.&#96;employees&#96; was not altered.</span><br><span class="line"></span><br><span class="line">-- 确保信息无误之后可以真正执行变更操作</span><br><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;employees --user&#x3D;admin --ask-pass --alter &quot;add comment varchar(50) not null default &#39;pt-osc&#39;&quot; --alter-foreign-keys-method&#x3D;auto --charset&#x3D;utf8 --execute</span><br><span class="line"></span><br><span class="line">……省略……</span><br><span class="line">Will automatically choose the method to update foreign keys.</span><br><span class="line">Altering &#96;employees&#96;.&#96;employees&#96;...</span><br><span class="line">Creating new table...</span><br><span class="line">Created new table employees._employees_new OK.</span><br><span class="line">Altering new table...</span><br><span class="line">Altered &#96;employees&#96;.&#96;_employees_new&#96; OK.</span><br><span class="line">2019-03-25T13:35:25 Creating triggers...</span><br><span class="line">2019-03-25T13:35:25 Created triggers OK.</span><br><span class="line">2019-03-25T13:35:25 Copying approximately 299512 rows...</span><br><span class="line">2019-03-25T13:35:31 Copied rows OK.</span><br><span class="line">2019-03-25T13:35:31 Max rows for the rebuild_constraints method: 99266</span><br><span class="line">Determining the method to update foreign keys...</span><br><span class="line">2019-03-25T13:35:31   &#96;employees&#96;.&#96;dept_emp&#96;: too many rows: 331143; must use drop_swap</span><br><span class="line">2019-03-25T13:35:31 Drop-swapping tables...</span><br><span class="line">2019-03-25T13:35:31 Analyzing new table...</span><br><span class="line">2019-03-25T13:35:31 Dropped and swapped tables OK.</span><br><span class="line">Not dropping old table because --no-drop-old-table was specified.</span><br><span class="line">2019-03-25T13:35:31 Dropping triggers...</span><br><span class="line">2019-03-25T13:35:31 Dropped triggers OK.</span><br><span class="line">Successfully altered &#96;employees&#96;.&#96;employees&#96;.</span><br></pre></td></tr></table></figure><ol start="3"><li>修改一个字段</li></ol><p>将表 employees 的 comment 字段的字符集修改为 utf8mb4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;employees --user&#x3D;admin --ask-pass --alter &quot;modify column comment varchar(50) character set utf8mb4&quot; --alter-foreign-keys-method&#x3D;auto --charset&#x3D;utf8 --execute</span><br></pre></td></tr></table></figure><ol start="4"><li>删除字段</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;employees --user&#x3D;admin --ask-pass --alter &quot;drop column comment&quot; --alter-foreign-keys-method&#x3D;auto --charset&#x3D;utf8 --execute</span><br></pre></td></tr></table></figure><ol start="5"><li>添加索引</li></ol><p>为表 dept_emp 的字段 from_date 和 to_date 创建复合索引 idx_fr_to_date。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;dept_emp --user&#x3D;admin --ask-pass --alter &quot;add index idx_fr_to_date(from_date,to_date)&quot; --alter-foreign-keys-method&#x3D;auto --charset&#x3D;utf8 --execute</span><br></pre></td></tr></table></figure><ol start="6"><li>删除索引</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;dept_emp --user&#x3D;admin --ask-pass --alter &quot;drop index idx_fr_to_date&quot; --alter-foreign-keys-method&#x3D;auto --charset&#x3D;utf8 --execute</span><br></pre></td></tr></table></figure><ol start="7"><li>修改字段允许 NULL</li></ol><p>将表 dept_emp 的字段 to_date 指定为允许 NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;dept_emp --user&#x3D;admin --ask-pass --alter &quot;modify column to_date date null&quot; --alter-foreign-keys-method&#x3D;auto --charset&#x3D;utf8 --execute</span><br></pre></td></tr></table></figure><ol start="8"><li>修改字段不允许 NULL (NOT NULL)</li></ol><p>为表 employees 添加字段 ptosc_num 并允许 NULL，字段类型为 int，没有指定默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;employees --user&#x3D;admin --ask-pass --alter &quot;add ptosc_num int null&quot; --alter-foreign-keys-method&#x3D;auto --charset&#x3D;utf8 --execute</span><br></pre></td></tr></table></figure><p>修改字段 ptosc_num 为不允许 NULL (NOT NULL)，需要通过指定选项 <code>--null-to-not-null</code>，否则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;employees --user&#x3D;admin --ask-pass --alter &quot;modify column ptosc_num int not null&quot; --alter-foreign-keys-method&#x3D;auto --null-to-not-null --charset&#x3D;utf8 --execute</span><br><span class="line"></span><br><span class="line">-- 因为字段ptosc_num没有指定默认值，字段类型为int，所以默认值为0</span><br><span class="line">mysql root@localhost:employees&gt; select * from employees limit 5;</span><br><span class="line">+--------+------------+------------+-----------+--------+------------+-----------+</span><br><span class="line">| emp_no | birth_date | first_name | last_name | gender | hire_date  | ptosc_num |</span><br><span class="line">+--------+------------+------------+-----------+--------+------------+-----------+</span><br><span class="line">| 10001  | 1953-09-02 | Georgi     | Facello   | M      | 1986-06-26 | 0         |</span><br><span class="line">| 10002  | 1964-06-02 | Bezalel    | Simmel    | F      | 1985-11-21 | 0         |</span><br><span class="line">| 10003  | 1959-12-03 | Parto      | Bamford   | M      | 1986-08-28 | 0         |</span><br><span class="line">| 10004  | 1954-05-01 | Chirstian  | Koblick   | M      | 1986-12-01 | 0         |</span><br><span class="line">| 10005  | 1955-01-21 | Kyoichi    | Maliniak  | M      | 1989-09-12 | 0         |</span><br><span class="line">+--------+------------+------------+-----------+--------+------------+-----------+</span><br><span class="line">5 rows in set</span><br><span class="line">Time: 0.022s</span><br></pre></td></tr></table></figure><ol start="9"><li>删除外键</li></ol><p>需要为外键指定名称为 _forigen_key，因为在创建新表时候默认为新表上的外键创建这样的名称，如果没这样指定则无法删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;dept_emp --user&#x3D;admin --ask-pass --alter &quot;drop foreign key _dept_emp_ibfk_1&quot; --alter-foreign-keys-method&#x3D;auto --charset&#x3D;utf8 --execute</span><br></pre></td></tr></table></figure><ol start="10"><li>重建表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;employees --user&#x3D;admin --ask-pass --alter &quot;engine&#x3D;InnoDB&quot; --alter-foreign-keys-method&#x3D;auto --charset&#x3D;utf8 --execute</span><br></pre></td></tr></table></figure><ol start="11"><li>变更后保留旧表</li></ol><p>如果是涉及外键关联的父表进行变更，则建议选项 <code>--alter-foreign-keys-method=rebuild_constraints</code>，这样在子表中会重命名外键约束名，如果选项 <code>--alter-foreign-keys-method</code> 有可能取值 drop_swap 时，则会强制使用选项 <code>--no-swap-tables</code> 和<code>--no-drop-old-table</code>，其中 <code>--no-swap-tables</code> 并不会有旧表的产生，就不存在保留之说了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;dept_emp --user&#x3D;admin --ask-pass --alter &quot;add comment varchar(50) notnull default &#39;pt-osc&#39;&quot; --no-drop-old-table --charset&#x3D;utf8 --execute</span><br></pre></td></tr></table></figure><p>以上语句执行完成后会在数据库中生成名为 _dept_emp_old 的表，即变更之前的旧表。</p><ol start="12"><li>变更后保留新表</li></ol><p>顾名思义，就是先做一次完整的表变更操作，但是不进行旧表与新表的交换，也不删除变更之后的新表，通过指定选项 <code>--no-drop-new-table</code> 和 <code>--no-swap-tables</code> 实现，可以通过选项 <code>--new-table-name</code> 指定新表名，当选项 <code>--alter-foreign-keys-method=drop_swap</code> 时，<code>--no-drop-new-table</code> 不生效，与保留旧表的情形一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;dept_emp --user&#x3D;admin --ask-pass --alter &quot;add comment varchar(50) notnull default &#39;pt-osc&#39;&quot; --no-drop-new-table --no-swap-tables --new-table-name&#x3D;&#39;dept_emp_bak&#39; --charset&#x3D;utf8 --execute</span><br></pre></td></tr></table></figure><p>以上语句执行完成后会在数据库中生成名为 dept_emp_bak 的表，即变更之后的新表，但对旧表不会做任何修改。</p><ol start="13"><li>添加主键</li></ol><p>如果是 <code>InnoDB</code> 表没有主键，真的不敢想像啊，但还是要进行测式下。这里测试基于 employees 表创建 employees_ptosc 表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:employees&gt; create table employees_ptosc as select * from employees;</span><br><span class="line">Query OK, 300024 rows affected</span><br><span class="line">Time: 2.010s</span><br><span class="line">mysql root@localhost:employees&gt; show create table employees_ptosc;</span><br><span class="line">+-----------------+--------------------------------------+</span><br><span class="line">| Table           | Create Table                         |</span><br><span class="line">+-----------------+--------------------------------------+</span><br><span class="line">| employees_ptosc | CREATE TABLE &#96;employees_ptosc&#96; (     |</span><br><span class="line">|                 |   &#96;emp_no&#96; int(11) NOT NULL,         |</span><br><span class="line">|                 |   &#96;birth_date&#96; date NOT NULL,        |</span><br><span class="line">|                 |   &#96;first_name&#96; varchar(14) NOT NULL, |</span><br><span class="line">|                 |   &#96;last_name&#96; varchar(16) NOT NULL,  |</span><br><span class="line">|                 |   &#96;gender&#96; enum(&#39;M&#39;,&#39;F&#39;) NOT NULL,   |</span><br><span class="line">|                 |   &#96;hire_date&#96; date NOT NULL          |</span><br><span class="line">|                 | ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 |</span><br><span class="line">+-----------------+--------------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.022s</span><br></pre></td></tr></table></figure><p>对 employees_ptosc 表添加主键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-- 如果 employees_ptosc 表没有任何索引和约束会报如下信息，工具执行失败</span><br><span class="line">Cannot chunk the original table &#96;employees&#96;.&#96;employees_ptosc&#96;: There is no good index and the table is oversized. at &#x2F;usr&#x2F;bin&#x2F;pt-online-schema-change line 5882.</span><br><span class="line"></span><br><span class="line">-- 先为 employees_ptosc 表创建基于 first_name 的索引 idx_first_name，再次执行添加主键</span><br><span class="line">mysql root@localhost:employees&gt; create index idx_first_name on employees_ptosc(first_name);</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 1.175s</span><br><span class="line"></span><br><span class="line">-- 如果没有加选项 --no-check-unique-key-change 会报如下信息</span><br><span class="line">……省略……</span><br><span class="line">Altering &#96;employees&#96;.&#96;employees_ptosc&#96;...</span><br><span class="line">&#96;employees&#96;.&#96;employees_ptosc&#96; was not altered.</span><br><span class="line">You are trying to add an unique key. This can result in data loss if the data is not unique.</span><br><span class="line">Please read the documentation for the --check-unique-key-change parameter.</span><br><span class="line">You can check if the column(s) contain duplicate content by running this&#x2F;these query&#x2F;queries:</span><br><span class="line"></span><br><span class="line">SELECT IF(COUNT(DISTINCT emp_no) &#x3D; COUNT(*),</span><br><span class="line">       &#39;Yes, the desired unique index currently contains only unique values&#39;,</span><br><span class="line">       &#39;No, the desired unique index contains duplicated values. There will be data loss&#39;</span><br><span class="line">) AS IsThereUniqueness FROM &#96;employees&#96;.&#96;employees_ptosc&#96;;</span><br><span class="line"></span><br><span class="line">Keep in mind that these queries could take a long time and consume a lot of resources</span><br><span class="line"></span><br><span class="line">大致意思就是工具无法确定需要创建主键基于的字段值是否唯一，一旦有重复值出现，在数据拷贝的时候容易出现数据丢失，并给出了检查的语句。</span><br><span class="line"></span><br><span class="line">mysql root@localhost:employees&gt; SELECT IF(COUNT(DISTINCT emp_no) &#x3D; COUNT(*),</span><br><span class="line">                                       &#39;Yes, the desired unique index currently contains only unique values&#39;,</span><br><span class="line">                                       &#39;No, the desired unique index contains duplicated values. There will be data loss&#39;</span><br><span class="line">                                ) AS IsThereUniqueness FROM &#96;employees&#96;.&#96;employees_ptosc&#96;;</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">| IsThereUniqueness                                                   |</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">| Yes, the desired unique index currently contains only unique values |</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line">Time: 0.274s</span><br></pre></td></tr></table></figure><p>使用选项 <code>--no-check-unique-key-change</code> 再次执行添加主键操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pt-online-schema-change h&#x3D;192.168.58.3,P&#x3D;3306,D&#x3D;employees,t&#x3D;employees_ptosc --user&#x3D;admin --ask-pass --alter &quot;add primary key(emp_no)&quot; --charset&#x3D;utf8 --no-check-unique-key-change --charset&#x3D;utf8 --execute</span><br></pre></td></tr></table></figure><h2 id="pt-online-schema-change-工作流程">pt-online-schema-change 工作流程</h2><p>为了了解 pt-online-schema-change 工具是如何做到不阻塞 DML 的，还是通过 General log 来了解。</p><p>以添加字段的执行语句获得的 General log 为例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">-- 初始的一些检查数据库参数、负载信息这里不再细说。</span><br><span class="line">…………省略…………</span><br><span class="line"></span><br><span class="line">-- 查看需要执行变更的表状态</span><br><span class="line">200 Query   SHOW TABLES FROM &#96;employees&#96; LIKE &#39;employees&#39;</span><br><span class="line">200 Query   SELECT VERSION()</span><br><span class="line"></span><br><span class="line">-- 查看表是否存在触发器</span><br><span class="line">200 Query   SHOW TRIGGERS FROM &#96;employees&#96; LIKE &#39;employees&#39;</span><br><span class="line"></span><br><span class="line">-- 查看表的建表语句</span><br><span class="line">200 Query   &#x2F;*!40101 SET @OLD_SQL_MODE :&#x3D; @@SQL_MODE, @@SQL_MODE :&#x3D; &#39;&#39;, @OLD_QUOTE :&#x3D; @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE :&#x3D; 1 *&#x2F;</span><br><span class="line">200 Query   USE &#96;employees&#96;</span><br><span class="line">200 Query   SHOW CREATE TABLE &#96;employees&#96;.&#96;employees&#96;</span><br><span class="line">200 Query   &#x2F;*!40101 SET @@SQL_MODE :&#x3D; @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE :&#x3D; @OLD_QUOTE *&#x2F;</span><br><span class="line"></span><br><span class="line">-- 查询表的执行计划，确定表是否有外键关联</span><br><span class="line">200 Query   EXPLAIN SELECT * FROM &#96;employees&#96;.&#96;employees&#96; WHERE 1&#x3D;1</span><br><span class="line">200 Query   SELECT table_schema, table_name FROM information_schema.key_column_usage WHERE referenced_table_schema&#x3D;&#39;employees&#39; AND referenced_table_name&#x3D;&#39;employees&#39;</span><br><span class="line">200 Query   EXPLAIN SELECT * FROM &#96;employees&#96;.&#96;dept_emp&#96; WHERE 1&#x3D;1</span><br><span class="line">200 Query   EXPLAIN SELECT * FROM &#96;employees&#96;.&#96;dept_manager&#96; WHERE 1&#x3D;1</span><br><span class="line">200 Query   SHOW VARIABLES LIKE &#39;wsrep_on&#39;</span><br><span class="line">200 Query   &#x2F;*!40101 SET @OLD_SQL_MODE :&#x3D; @@SQL_MODE, @@SQL_MODE :&#x3D; &#39;&#39;, @OLD_QUOTE :&#x3D; @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE :&#x3D; 1 *&#x2F;</span><br><span class="line"></span><br><span class="line">-- 创建&#39;_&#39;(下划线)开头相同表结构的新表，并先在新表上执行变更操作</span><br><span class="line">200 Query   USE &#96;employees&#96;</span><br><span class="line">200 Query   SHOW CREATE TABLE &#96;employees&#96;.&#96;employees&#96;</span><br><span class="line">200 Query   &#x2F;*!40101 SET @@SQL_MODE :&#x3D; @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE :&#x3D; @OLD_QUOTE *&#x2F;</span><br><span class="line">200 Query   CREATE TABLE &#96;employees&#96;.&#96;_employees_new&#96; (</span><br><span class="line">  &#96;emp_no&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;birth_date&#96; date NOT NULL,</span><br><span class="line">  &#96;first_name&#96; varchar(14) NOT NULL,</span><br><span class="line">  &#96;last_name&#96; varchar(16) NOT NULL,</span><br><span class="line">  &#96;gender&#96; enum(&#39;M&#39;,&#39;F&#39;) NOT NULL,</span><br><span class="line">  &#96;hire_date&#96; date NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;emp_no&#96;),</span><br><span class="line">  KEY &#96;idx_first_last&#96; (&#96;first_name&#96;,&#96;last_name&#96;),</span><br><span class="line">  KEY &#96;idx_birth_hire&#96; (&#96;birth_date&#96;,&#96;hire_date&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">200 Query   ALTER TABLE &#96;employees&#96;.&#96;_employees_new&#96; add comment varchar(50) not null default &#39;pt-osc&#39;</span><br><span class="line"></span><br><span class="line">-- 在原表上分别创建 DELETE、UPDATE、INSERT 三个触发器</span><br><span class="line">200 Query   &#x2F;*!40101 SET @OLD_SQL_MODE :&#x3D; @@SQL_MODE, @@SQL_MODE :&#x3D; &#39;&#39;, @OLD_QUOTE :&#x3D; @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE :&#x3D; 1 *&#x2F;</span><br><span class="line">200 Query   USE &#96;employees&#96;</span><br><span class="line">200 Query   SHOW CREATE TABLE &#96;employees&#96;.&#96;_employees_new&#96;</span><br><span class="line">200 Query   &#x2F;*!40101 SET @@SQL_MODE :&#x3D; @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE :&#x3D; @OLD_QUOTE *&#x2F;</span><br><span class="line"></span><br><span class="line">……省略……</span><br><span class="line"></span><br><span class="line">200 Query   CREATE TRIGGER &#96;pt_osc_employees_employees_del&#96; AFTER DELETE ON &#96;employees&#96;.&#96;employees&#96; FOR EACH ROW DELETE IGNORE FROM &#96;employees&#96;.&#96;_employees_new&#96; WHERE &#96;employees&#96;.&#96;_employees_new&#96;.&#96;emp_no&#96; &lt;&#x3D;&gt; OLD.&#96;emp_no&#96;</span><br><span class="line">200 Query   CREATE TRIGGER &#96;pt_osc_employees_employees_upd&#96; AFTER UPDATE ON &#96;employees&#96;.&#96;employees&#96; FOR EACH ROW BEGIN DELETE IGNORE FROM &#96;employees&#96;.&#96;_employees_new&#96; WHERE !(OLD.&#96;emp_no&#96; &lt;&#x3D;&gt; NEW.&#96;emp_no&#96;) AND &#96;employees&#96;.&#96;_employees_new&#96;.&#96;emp_no&#96; &lt;&#x3D;&gt; OLD.&#96;emp_no&#96;;REPLACE INTO &#96;employees&#96;.&#96;_employees_new&#96; (&#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96;) VALUES (NEW.&#96;emp_no&#96;, NEW.&#96;birth_date&#96;, NEW.&#96;first_name&#96;, NEW.&#96;last_name&#96;, NEW.&#96;gender&#96;, NEW.&#96;hire_date&#96;);END</span><br><span class="line">200 Query   CREATE TRIGGER &#96;pt_osc_employees_employees_ins&#96; AFTER INSERT ON &#96;employees&#96;.&#96;employees&#96; FOR EACH ROW REPLACE INTO &#96;employees&#96;.&#96;_employees_new&#96; (&#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96;) VALUES (NEW.&#96;emp_no&#96;, NEW.&#96;birth_date&#96;, NEW.&#96;first_name&#96;, NEW.&#96;last_name&#96;, NEW.&#96;gender&#96;, NEW.&#96;hire_date&#96;)</span><br><span class="line"></span><br><span class="line">-- 根据执行计划判断 chunk 包含的行数，以 chunk 数为单位拷贝数据，为在拷贝过程中为这些行加共享读锁</span><br><span class="line">200 Query   EXPLAIN SELECT * FROM &#96;employees&#96;.&#96;employees&#96; WHERE 1&#x3D;1</span><br><span class="line">200 Query   SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; &#96;emp_no&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) ORDER BY &#96;emp_no&#96; LIMIT 1 &#x2F;*first lower boundary*&#x2F;</span><br><span class="line">200 Query   SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; &#96;emp_no&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX (&#96;PRIMARY&#96;) WHERE &#96;emp_no&#96; IS NOT NULL ORDER BY &#96;emp_no&#96; LIMIT 1 &#x2F;*key_len*&#x2F;</span><br><span class="line">200 Query   EXPLAIN SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; * FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX (&#96;PRIMARY&#96;) WHERE &#96;emp_no&#96; &gt;&#x3D; &#39;10001&#39; &#x2F;*key_len*&#x2F;</span><br><span class="line">200 Query   EXPLAIN SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; &#96;emp_no&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;10001&#39;)) ORDER BY &#96;emp_no&#96; LIMIT 999, 2 &#x2F;*next chunk boundary*&#x2F;</span><br><span class="line">200 Query   SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; &#96;emp_no&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;10001&#39;)) ORDER BY &#96;emp_no&#96; LIMIT 999, 2 &#x2F;*next chunk boundary*&#x2F;</span><br><span class="line">200 Query   EXPLAIN SELECT &#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;10001&#39;)) AND ((&#96;emp_no&#96; &lt;&#x3D; &#39;11000&#39;)) LOCK IN SHARE MODE &#x2F;*explain pt-online-schema-change 31797 copy nibble*&#x2F;</span><br><span class="line">200 Query   INSERT LOW_PRIORITY IGNORE INTO &#96;employees&#96;.&#96;_employees_new&#96; (&#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96;) SELECT &#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;10001&#39;)) AND ((&#96;emp_no&#96; &lt;&#x3D; &#39;11000&#39;)) LOCK IN SHARE MODE &#x2F;*pt-online-schema-change 31797 copy nibble*&#x2F;</span><br><span class="line"></span><br><span class="line">-- 每次拷贝完 chunk 中数据后，查看是否有警告，查看服务器的负载情况，这是在每个 chunk 拷贝完成后进行的</span><br><span class="line">200 Query   SHOW WARNINGS</span><br><span class="line">200 Query   SHOW GLOBAL STATUS LIKE &#39;Threads_running&#39;</span><br><span class="line">200 Query   EXPLAIN SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; &#96;emp_no&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;11001&#39;)) ORDER BY &#96;emp_no&#96; LIMIT 12909, 2 &#x2F;*next chunk boundary*&#x2F;</span><br><span class="line">200 Query   SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; &#96;emp_no&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;11001&#39;)) ORDER BY &#96;emp_no&#96; LIMIT 12909, 2 &#x2F;*next chunk boundary*&#x2F;</span><br><span class="line">200 Query   EXPLAIN SELECT &#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;11001&#39;)) AND ((&#96;emp_no&#96; &lt;&#x3D; &#39;23910&#39;)) LOCK IN SHARE MODE &#x2F;*explain pt-online-schema-change 31797 copy nibble*&#x2F;</span><br><span class="line">200 Query   INSERT LOW_PRIORITY IGNORE INTO &#96;employees&#96;.&#96;_employees_new&#96; (&#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96;) SELECT &#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;11001&#39;)) AND ((&#96;emp_no&#96; &lt;&#x3D; &#39;23910&#39;)) LOCK IN SHARE MODE &#x2F;*pt-online-schema-change 31797 copy nibble*&#x2F;</span><br><span class="line">200 Query   SHOW WARNINGS</span><br><span class="line">200 Query   SHOW GLOBAL STATUS LIKE &#39;Threads_running&#39;</span><br><span class="line">200 Query   EXPLAIN SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; &#96;emp_no&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;23911&#39;)) ORDER BY &#96;emp_no&#96; LIMIT 19857, 2 &#x2F;*next chunk boundary*&#x2F;</span><br><span class="line">200 Query   SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; &#96;emp_no&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;23911&#39;)) ORDER BY &#96;emp_no&#96; LIMIT 19857, 2 &#x2F;*next chunk boundary*&#x2F;</span><br><span class="line">200 Query   EXPLAIN SELECT &#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;23911&#39;)) AND ((&#96;emp_no&#96; &lt;&#x3D; &#39;43768&#39;)) LOCK IN SHARE MODE &#x2F;*explain pt-online-schema-change 31797 copy nibble*&#x2F;</span><br><span class="line">200 Query   INSERT LOW_PRIORITY IGNORE INTO &#96;employees&#96;.&#96;_employees_new&#96; (&#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96;) SELECT &#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;23911&#39;)) AND ((&#96;emp_no&#96; &lt;&#x3D; &#39;43768&#39;)) LOCK IN SHARE MODE &#x2F;*pt-online-schema-change 31797 copy nibble*&#x2F;</span><br><span class="line">200 Query   SHOW WARNINGS</span><br><span class="line">200 Query   SHOW GLOBAL STATUS LIKE &#39;Threads_running&#39;</span><br><span class="line"></span><br><span class="line">……省略……</span><br><span class="line"></span><br><span class="line">200 Query   EXPLAIN SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; &#96;emp_no&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;480121&#39;)) ORDER BY &#96;emp_no&#96; LIMIT 26664, 2 &#x2F;*next chunk boundary*&#x2F;</span><br><span class="line">200 Query   SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; &#96;emp_no&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;480121&#39;)) ORDER BY &#96;emp_no&#96; LIMIT 26664, 2 &#x2F;*next chunk boundary*&#x2F;</span><br><span class="line">200 Query   SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; &#96;emp_no&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) ORDER BY &#96;emp_no&#96; DESC LIMIT 1 &#x2F;*last upper boundary*&#x2F;</span><br><span class="line">200 Query   EXPLAIN SELECT &#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;480121&#39;)) AND ((&#96;emp_no&#96; &lt;&#x3D; &#39;499999&#39;)) LOCK IN SHARE MODE &#x2F;*explain pt-online-schema-change 31797 copy nibble*&#x2F;</span><br><span class="line">200 Query   INSERT LOW_PRIORITY IGNORE INTO &#96;employees&#96;.&#96;_employees_new&#96; (&#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96;) SELECT &#96;emp_no&#96;, &#96;birth_date&#96;, &#96;first_name&#96;, &#96;last_name&#96;, &#96;gender&#96;, &#96;hire_date&#96; FROM &#96;employees&#96;.&#96;employees&#96; FORCE INDEX(&#96;PRIMARY&#96;) WHERE ((&#96;emp_no&#96; &gt;&#x3D; &#39;480121&#39;)) AND ((&#96;emp_no&#96; &lt;&#x3D; &#39;499999&#39;)) LOCK IN SHARE MODE &#x2F;*pt-online-schema-change 31797 copy nibble*&#x2F;</span><br><span class="line">200 Query   SHOW WARNINGS</span><br><span class="line">200 Query   SHOW GLOBAL STATUS LIKE &#39;Threads_running&#39;</span><br><span class="line"></span><br><span class="line">-- 当拷贝数据完成之后，及时分析表进行统计信息的收集</span><br><span class="line">200 Query   EXPLAIN SELECT * FROM &#96;employees&#96;.&#96;dept_emp&#96; WHERE 1&#x3D;1</span><br><span class="line">200 Query   SHOW VARIABLES LIKE &#39;version%&#39;</span><br><span class="line">200 Query   SHOW ENGINES</span><br><span class="line">200 Query   SHOW VARIABLES LIKE &#39;innodb_version&#39;</span><br><span class="line">200 Query   ANALYZE TABLE &#96;employees&#96;.&#96;_employees_new&#96; &#x2F;* pt-online-schema-change *&#x2F;</span><br><span class="line"></span><br><span class="line">-- 完成旧表与新表的交换，主要受选项 --alter-foreign-keys-method 取值不同来进行</span><br><span class="line">&#39;</span><br><span class="line">当 --alter-foreign-keys-method&#x3D;drop_swap 时，先禁用外键约束检查，删除旧表，将临时表重命名为原旧表名，完成变更</span><br><span class="line">&#39;</span><br><span class="line">200 Query   SET foreign_key_checks&#x3D;0</span><br><span class="line">200 Query   DROP TABLE IF EXISTS &#96;employees&#96;.&#96;employees&#96;</span><br><span class="line">200 Query   RENAME TABLE &#96;employees&#96;.&#96;_employees_new&#96; TO &#96;employees&#96;.&#96;employees&#96;</span><br><span class="line"></span><br><span class="line">&#39;</span><br><span class="line">当 --alter-foreign-keys-method&#x3D;rebuild_constraints 时，做一个原子性的交换重命名表的操作，删除旧表的操作在删除触发器时一并操作</span><br><span class="line">&#39;</span><br><span class="line">203 Query     ANALYZE TABLE &#96;employees&#96;.&#96;_employees_new&#96; &#x2F;* pt-online-schema-change *&#x2F;</span><br><span class="line">203 Query     RENAME TABLE &#96;employees&#96;.&#96;employees&#96; TO &#96;employees&#96;.&#96;_employees_old&#96;, &#96;employees&#96;.&#96;_employees_new&#96; TO &#96;employees&#96;.&#96;employees&#96;</span><br><span class="line"></span><br><span class="line">-- 删除 3 个触发器</span><br><span class="line">&#39;</span><br><span class="line">当 --alter-foreign-keys-method&#x3D;drop_swap 时，直接删除。</span><br><span class="line">&#39;</span><br><span class="line">200 Query   DROP TRIGGER IF EXISTS &#96;employees&#96;.&#96;pt_osc_employees_employees_del&#96;</span><br><span class="line">200 Query   DROP TRIGGER IF EXISTS &#96;employees&#96;.&#96;pt_osc_employees_employees_upd&#96;</span><br><span class="line">200 Query   DROP TRIGGER IF EXISTS &#96;employees&#96;.&#96;pt_osc_employees_employees_ins&#96;</span><br><span class="line">200 Query   SHOW TABLES FROM &#96;employees&#96; LIKE &#39;\_employees\_new&#39;</span><br><span class="line">201 Quit    </span><br><span class="line">200 Quit</span><br><span class="line"></span><br><span class="line">&#39;</span><br><span class="line">当 --alter-foreign-keys-method&#x3D;rebuild_constraints 时，对于关联的外键表执行重建外键操作，删除旧表，完成变更。</span><br><span class="line">&#39;</span><br><span class="line">203 Query     USE &#96;employees&#96;</span><br><span class="line">203 Query     SHOW CREATE TABLE &#96;employees&#96;.&#96;dept_emp&#96;</span><br><span class="line">203 Query     &#x2F;*!40101 SET @@SQL_MODE :&#x3D; @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE :&#x3D; @OLD_QUOTE *&#x2F;</span><br><span class="line">203 Query     ALTER TABLE &#96;employees&#96;.&#96;dept_emp&#96; DROP FOREIGN KEY &#96;_dept_emp_ibfk_1&#96;, ADD CONSTRAINT &#96;__dept_emp_ibfk_1&#96; FOREIGN KEY (&#96;emp_no&#96;) REFERENCES &#96;employees&#96;.&#96;employees&#96; (&#96;emp_no&#96;) ON DELETE CASCADE</span><br><span class="line">203 Query     &#x2F;*!40101 SET @OLD_SQL_MODE :&#x3D; @@SQL_MODE, @@SQL_MODE :&#x3D; &#39;&#39;, @OLD_QUOTE :&#x3D; @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE :&#x3D; 1 *&#x2F;</span><br><span class="line"></span><br><span class="line">203 Query     USE &#96;employees&#96;</span><br><span class="line">203 Query     SHOW CREATE TABLE &#96;employees&#96;.&#96;dept_manager&#96;</span><br><span class="line">203 Query     &#x2F;*!40101 SET @@SQL_MODE :&#x3D; @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE :&#x3D; @OLD_QUOTE *&#x2F;</span><br><span class="line">203 Query     ALTER TABLE &#96;employees&#96;.&#96;dept_manager&#96; DROP FOREIGN KEY &#96;__dept_manager_ibfk_1&#96;, ADD CONSTRAINT &#96;dept_manager_ibfk_1&#96; FOREIGN KEY (&#96;emp_no&#96;) REFERENCES &#96;employees&#96;.&#96;employees&#96; (&#96;emp_no&#96;) ON DELETE CASCADE</span><br><span class="line"></span><br><span class="line">203 Query     DROP TABLE IF EXISTS &#96;employees&#96;.&#96;_employees_old&#96;</span><br><span class="line">203 Query     DROP TRIGGER IF EXISTS &#96;employees&#96;.&#96;pt_osc_employees_employees_del&#96;</span><br><span class="line">203 Query     DROP TRIGGER IF EXISTS &#96;employees&#96;.&#96;pt_osc_employees_employees_upd&#96;</span><br><span class="line">203 Query     DROP TRIGGER IF EXISTS &#96;employees&#96;.&#96;pt_osc_employees_employees_ins&#96;</span><br><span class="line">203 Query     SHOW TABLES FROM &#96;employees&#96; LIKE &#39;\_employees\_new&#39;</span><br><span class="line">204 Quit</span><br><span class="line">203 Quit</span><br></pre></td></tr></table></figure><p>整个工作流程总结如下：</p><ol><li><p>查询当前数据库服务器信息，包括参数设置，负载信息等，判断表是否有存在触发器，是否有外键关联；</p></li><li><p>创建一张与旧表结构相同的新表，表名为_旧表名；</p></li><li><p>在新创建的表上做变更操作；</p></li><li><p>旧表上创建 DELETE、UPDATE、INSERT 3 个触发器；</p></li><li><p>拷贝旧表数据到新表上，以 chunk 为单位进行，拷贝期间涉及的行会持有共享读锁；</p></li><li><p>拷贝期间如果旧表如有 DML 操作，则通过触发器更新同步到新表上；</p></li><li><p>当拷贝数据完成之后旧表与新表进行重命名；</p></li><li><p>如果有涉及到外键，根据工具指定选项进行外键处理；</p></li><li><p>删除旧表；</p></li><li><p>删除旧表上触发器。</p></li></ol><h2 id="总结">总结</h2><p>当业务量较大时，修改操作会等待没有数据修改后，执行最后的 rename 操作。因此，在修改表结构时，应该尽量选择在业务相对空闲时，至少修改表上的数据操作较低时，执行较为妥当。由于可能存在一定的风险，在操作之前，建议对数据表进行备份，可以使得操作更安全、可靠。</p><p>pt-online-schema-change 工具对于任意的 DDL 语句都是通过创新表拷贝数据来进行，期间都支持 DML，而 Online DDL 根据 DDL 类型的来区分是否需要对表进行 COPY TABLE 操作，有点类似于工具的创建临时表进行变更，而不需要 COPY TABLE 操作的 DDL 语句在执行期间支持DML。</p><p>关于在对表进行 DDL 时使用 MySQL 原生的 Online DDL 特性还是使用 pt-online-schema-change 工具，通过以上对工具使用的说明与用法测试可以总结如下：</p><ol><li><p>如果 MySQL 版本不支持 Online DDL 特性，比如早于 5.6 版本的 MySQL，则使用 pt-online-schema-change 工具；</p></li><li><p>如果 MySQL 版本支持 Online DDL 特性，则优先考虑使用 Online DDL，因为毕竟原生的支持较好，同时不容易产生不可预知的错误；</p></li><li><p>如果 DDL 语句在使用 Online DDL 时需要进行 COPY TABLE 操作，建议使用 pt-online-schema-change 工具，因为期间支持 DML 操作。</p></li><li><p>如果表存在触发器的情况下，优先使用 Online DDL，对于 MySQL 5.7.2 之后版本则可以 pt-online-schema-change 工具并通过指定选项 --preserve-triggers；</p></li><li><p>如果涉及外键关联的表，优先考虑使用 Online DDL。</p></li></ol><h2 id="参考文档">参考文档</h2><ol><li><p><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p></li><li><p><a href="http://einverne.github.io/post/2018/03/pt-online-schema-change-mysql-alter-table.html" target="_blank" rel="noopener">http://einverne.github.io/post/2018/03/pt-online-schema-change-mysql-alter-table.html</a></p></li><li><p><a href="https://www.cnblogs.com/dbabd/p/10605629.html" target="_blank" rel="noopener">https://www.cnblogs.com/dbabd/p/10605629.html</a></p></li><li><p><a href="https://www.cnblogs.com/xinysu/p/6758170.html" target="_blank" rel="noopener">https://www.cnblogs.com/xinysu/p/6758170.html</a></p></li><li><p><a href="https://sanyuesha.com/2017/10/19/mysql-online-migration-program-and-tool-compare/" target="_blank" rel="noopener">https://sanyuesha.com/2017/10/19/mysql-online-migration-program-and-tool-compare/</a></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，很多互联网业务都面临着无法停机，需要在线变更数据库结构的情况。但是在线修改数据量较大的表，可能对线上业务产生较大影响，比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在线修改大表的表结构执行时间往往不可预估，一般时间较长。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于修改表结构是表级锁，因此在修改表结构时，影响表写入操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果长时间的修改表结构，中途修改失败，由于修改表结构是一个事务，因此失败后会还原表结构，在这个过程中表都是锁着不可写入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改大表结构容易导致数据库 CPU、IO 等性能消耗，使 MySQL 服务器性能降低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在线修改大表结构容易导致主从延时，从而影响业务读取。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://www.hi-linux.com/categories/MySQL/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="MySQL" scheme="https://www.hi-linux.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
