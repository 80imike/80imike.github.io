<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇妙的 Linux 世界</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2021-06-04T06:15:16.306Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文读懂 DevOps 和 SRE 的区别</title>
    <link href="https://www.hi-linux.com/posts/38404.html"/>
    <id>https://www.hi-linux.com/posts/38404.html</id>
    <published>2021-06-04T01:00:00.000Z</published>
    <updated>2021-06-04T06:15:16.306Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="devops-和-sre">DevOps 和 SRE</span></h2><p>最近有一位朋友和我聊职业发展方向问题，聊了不少 DevOps 和 SRE 话题。 我几年前刚接触这两个概念时也常常将之混淆，可惜当时没有人来解答我困惑。 现在这虽然已经极为流行，但是我发现我这位朋友对这两个职位还存在一些误区。 于是我给了一些见解并整理成文章以饕大众。</p><p>最常见的误区：</p><ul><li>DevOps 新概念，好高级哦</li><li>SRE 是高级版 DevOps</li><li>运维可以轻松转身 DevOps 工程师</li></ul><h2><span id="devops-和-sre-定义">DevOps 和 SRE 定义</span></h2><p>DevOps 是字面上 Dev 开发 / Ops 运维两者组合， 严格意义上 DevOps 如下（via DevOps - Wikipedia）：</p><blockquote><p>DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev） ”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。</p></blockquote><p>SRE 全称是 Site Reliability Engineering，最早是由 Google 提出，并且在其工程实践中发扬光大。 他们还出了一本同名书籍「Site Reliability Engineering」， 让这个理念在互联网工程师圈子里广泛传播。</p><p>Google 对 SRE 解释是（via Site Reliability Engineering - Wikipedia）：</p><blockquote><p>Site reliability engineering (SRE) is a discipline that incorporates aspects of software engineering and applies that to operations whose goals are to create ultra-scalable and highly reliable software systems.</p></blockquote><p>我将其翻译翻译为中文：</p><blockquote><p>网站稳定性工程师是致力于打造「高扩展、高可用系统」，并将其贯彻为原则的软件工程师。</p></blockquote><p>从定义来看，DevOps 是文化、运动和惯例，而 SRE 是有严格任职要求的职位。 文化是软性定义，文化有更多概念可以捏造，而 SRE 定义精准，就少了想象空间（也可能 SRE 门槛高 ）。 按 Google 给出的说法是，SRE 工程师实践了 DevOps 文化。这个观点没错，但是国内的 DevOps 逐步独立出 DevOps 工程师， 所以在本文，我着重讨论的是 DevOps 工程师和 SRE 工程师两种职位对比。</p><a id="more"></a><h2><span id="两者产生背景和历史">两者产生背景和历史</span></h2><p>互联网需求催生了 DevOps 。在最传统软件企业中，是只有 Dev 没有 Ops， 那时 Ops 可能还是只是技术支持人员。开发按照瀑布流：需求分析、系统设计、开发、测试、交付、运行， 传统软件发布是一个重量级操作。一旦发布，Dev 几乎不再直接操作。 80 后可能会记得 QQ 每年都会有一个大版本发布吧，QQ 2000 / 2003 / 2004 等等。 此时 Ops 不用和 Dev 直接高频接触，甚至针对一些纯离线业务，压根没有设立 Ops 这个岗位。</p><p>互联网浪潮之后，软件由传统意义上桌面软件演变为面向网站、手机应用。 这时候业务核心逻辑，比如交易，社交行为都不在用户桌面完成，而是在服务器后端完成。 这给互联网企业给予了极大操作空间：随时可以改变业务逻辑，这促进了业务快速迭代变更。 但即便这样，Dev 和 Ops 是极其分裂的两个环节。Ops 不关心代码是如何运作的，Dev 不知道代码如何运行在服务器上。</p><p>当业界还沉浸在可以每周发布版本喜悦中时，2009 年，Flicker 提出了每天发布 10+ 次概念，大大震撼了业界。 Flicker 提出了几个核心理念：</p><ul><li>业务快速发展，需要拥抱变更，小步快跑</li><li>Ops 目标不是为了网站稳定和快速，而是推动业务快速发展</li><li>基于自动化工具提高 Dev / Ops 联接：代码版本管理、监控</li><li>高效沟通：IRC / IM Robot（现在那些 ChatBot 套路，10 年前就被 Flicker 玩过了）</li><li>信任、透明、高效、互助的沟通文化</li></ul><p>真是让人难以想象，今天各种培训公司和一些知名大 V 在呼唤这些 DevOps 理念， 竟然在 2009 年一份幻灯片中就展现淋漓尽致。经典总是不过时，在尘封下闪耀着智慧光芒。 有些人将 DevOps 和运维自动化等同，这是只看到表象。 DevOps 目标是提高业务系统交付速度，并为之提供相关工具、制度和服务。 一些个人或培训机构添油加醋和衍生含义，都是围绕这 DevOps 本质而发散。</p><p>接下来聊聊 SRE 历史， SRE 出现要晚一些。在 2003 年时候 Google 的 Ben Treynor 招募了几个软件工程师，这个团队设立目的是帮助 Google 生产环境服务运行更稳定、健壮、可靠。 不同于中小型规模公司，Google 服务于十几亿用户服务，短暂服务不可用会带来致命后果。 因此 Google 走在了时代最前面，SRE 产生了。 这个职位为大规模集群服务，小型团队不需要这样职位设定（可能也招不起真正 SRE ）。 Google 在探索若干年之后，SRE 团队开始将自己心得体会写在线上，并在 2016 年将此书出版。</p><h2><span id="两者的职能不同">两者的职能不同</span></h2><p>现在不少公司将 DevOps 职能单独抽取出来，称之为 DevOps 工程师。 那让我们看看 DevOps 工程师关心什么：DevOps 文化目的是提交交付速度， DevOps 工程师就自然会关心软件 / 服务的整个生命周期。 一个简单的公式：速度 = 总量 / 时间，添上工程行业术语，即 交付速度 = （（功能特性 * 工程质量） / 交付时间） * 交付风险。</p><p>功能特性交给产品经理和项目经理管理，DevOps 工程师需要关心剩下几个因素：工程质量 / 交付时间 / 交付风险。 DevOps 工程师职能如下：</p><ul><li>管理应用全生命周期（需求、设计、开发、QA、发布、运行）</li><li>关注全流程效率提升，挖掘瓶颈点并将其解决</li><li>自动化运维平台设计和研发工作（标准化、自动化、平台化）</li><li>支持运维系统，包括 虚拟化技术、资源管理技术、监控技术、网络技术</li></ul><p>SRE 关键词是「高扩展性」「高可用性」。高扩展性是指当服务用户数量暴增时， 应用系统以及支撑其服务（服务器资源、网络系统、数据库资源）可以在不调整系统结构，不强化机器本身性能 ，仅仅增加实例数量方式进行扩容。高可用性是指，应用架构中任何环节出现不可用时，比如应用服务、网关、数据库 等系统挂掉，整个系统可以在可预见时间内恢复并重新提供服务。当然，既然是「高」可用， 那么这个时间一般期望在分钟级别。SRE 职能可以概括为以下：</p><ul><li>为 应用、中间件、基础设施等提供 选型、设计、开发、容量规划、调优、故障处理</li><li>为业务系统提供基于可用性、可扩展性考虑决策，参与业务系统设计和实施</li><li>定位、处理、管理故障，优化导致故障发生相关部件</li><li>提高各部件资源利用率</li></ul><h2><span id="工作内容不同">工作内容不同</span></h2><p>职责不同导致两个职位工作内容也不尽相同，我将 DevOps 工程师和 SRE 工程师职能列举如下：</p><ul><li><p>DevOps</p><ul><li>设定应用生命管理周期制度，扭转流程</li><li>开发、管理 开发工程师 /QA 工程师使用 开发平台系统</li><li>开发、管理 发布系统</li><li>开发、选型、管理 监控、报警系统</li><li>开发、管理 权限系统</li><li>开发、选型、管理 CMBD</li><li>管理变更</li><li>管理故障</li></ul></li><li><p>SRE</p><ul><li>管理变更</li><li>管理故障</li><li>制定 SLA 服务标准</li><li>开发、选型、管理 各类中间件</li><li>开发、管理 分布式监控系统</li><li>开发、管理 分布式追踪系统</li><li>开发、管理 性能监控、探测系统（dtrace、火焰图）</li><li>开发、选型、培训 性能调优工具</li></ul></li></ul><p>很有趣的对比，DevOps 和 SRE 都会关心应用生命周期，特别是生命周期里面的变更和故障。 但是 DevOps 工作内容是主要为开发链路服务，一个 DevOps Team 通常会提供一串工具链， 这其中会包括：开发工具、版本管理工具、CI 持续交付工具、CD 持续发布工具、报警工具、故障处理。 而 SRE Team 则关注更为关注变更、故障、性能、容量相关问题，会涉及具体业务，产出工具链会有： 容量测量工具、Logging 日志工具、Tracing 调用链路跟踪工具、Metrics 性能度量工具、监控报警工具等。</p><h2><span id="devops-和-sre-关系">DevOps 和 SRE 关系</span></h2><p>DevOps 首先是一种文化，后期逐渐独立成一个职位；SRE 一开始就明确是一个职位； 不少同学把 DevOps 和 SRE 搞混，是被两者表象锁迷惑，看上去这两者都有的工具属性、自动化要求也相似。 甚至有一些开发同学把这类运维工作都统一理解为：服务器 + 工具 + 自动化。这是盲人摸象，管中窥豹。</p><p>从技能上来说，两者都需要较强的运维技能。 在职业发展天花板上，DevOps 可能缺乏 SRE 在一些专业领域的技能： 计算机体系结构能力；高吞吐高并发优化能力；可扩展系统设计能力；复杂系统设计能力；业务系统排查能力。 两者都需要软实力，但是 SRE 面临复杂度更高，挑战更大，要求也更高：</p><p>DevOps 具有普遍意义，现代互联网公司都需要 DevOps，但是并非所有团队对高可用性、高扩展性存在需求，它们不需要 SRE。 DevOps 工程师掌握相关技能之后，也有机会可以发展为 SRE 工程师。 而一位合格 SRE 工程师，在有选择情况下面，我相信不会去转型为 DevOps 工程师。</p><p>从专业背景来看，无论是 DevOps 还是 SRE 工程师，都需要研发背景，前者需要开发工具链，后者需要有较强架构设计经验。 如果有运维工程师想转型成为 DevOps 或者 SRE，那么需要补上相关技术知识。 毕竟，不是会搭建一套 Jenkins + Kubernetes 就可以自称为 DevOps / SRE 工程师。</p><p>怎么样，有没有解开这几个常见误区呢？希望你看到这里可以豁然开朗，最后附上两个工程师的技能点， 期望有志成为这两种工程师的同学，加油努力。</p><h2><span id="附录技能点">附录：技能点</span></h2><p>DevOps：</p><ul><li><p>Operator 技能</p><ul><li><p>Linux Basis</p><ul><li>基本命令操作</li><li>Linux FHS（Filesystem Hierarchy Standard 文件系统层次结构标准）</li><li>Linux 系统（差异、历史、标准、发展）</li></ul></li><li><p>脚本</p><ul><li>Bash / Python</li></ul></li><li><p>基础服务</p><ul><li>DHCP / NTP / DNS / SSH / iptables / LDAP / CMDB</li></ul></li><li><p>自动化工具</p><ul><li>Fabric / Saltstack / Chef / Ansible</li></ul></li><li><p>基础监控工具</p><ul><li>Zabbix / Nagios / Cacti</li></ul></li><li><p>虚拟化</p><ul><li>KVM 管理 / XEN 管理 / vSphere 管理 / Docker</li><li>容器编排 / Mesos / Kubernetes</li></ul></li><li><p>服务</p><ul><li>Nginx / F5 / HAProxy / LVS 负载均衡</li><li>常见中间件 Operate（启动、关闭、重启、扩容）</li></ul></li></ul></li><li><p>Dev</p><ul><li><p>语言</p><ul><li>Python</li><li>Go（可选）</li><li>Java（了解部署）</li></ul></li><li><p>流程和理论</p><ul><li>Application Life Cycle</li><li>12 Factor</li><li>微服务概念、部署、生命周期</li><li>CI 持续集成 / Jenkins / Pipeline / Git Repo Web Hook</li><li>CD 持续发布系统</li></ul></li><li><p>基础设施</p><ul><li>Git Repo / Gitlab / Github</li><li>Logstash / Flume 日志收集</li><li>配置文件管理（应用、中间件等）</li><li>Nexus / JFrog / Pypi 包依赖管理</li><li>面向 开发 / QA 开发环境管理系统</li><li>线上权限分配系统</li><li>监控报警系统</li><li>基于 Fabric / Saltstack / Chef / Ansible 自动化工具开发</li></ul></li></ul></li></ul><p>SRE：</p><ul><li><p>语言和工程实现</p><ul><li><p>深入理解开发语言（假设是 Java）</p><ul><li>业务部门使用开发框架</li><li>并发、多线程和锁</li><li>资源模型理解：网络、内存、CPU</li><li>故障处理能力（分析瓶颈、熟悉相关工具、还原现场、提供方案）</li></ul></li><li><p>常见业务设计方案和陷阱（比如 Business Modeling，N+1、远程调用、不合理 DB 结构）</p></li><li><p>MySQL / Mongo OLTP 类型查询优化</p></li><li><p>多种并发模型，以及相关 Scalable 设计</p></li></ul></li><li><p>问题定位工具</p><ul><li>容量管理</li><li>Tracing 链路追踪</li><li>Metrics 度量工具</li><li>Logging 日志系统</li></ul></li><li><p>运维架构能力</p><ul><li>Linux 精通，理解 Linux 负载模型，资源模型</li><li>熟悉常规中间件（MySQL Nginx Redis Mongo ZooKeeper 等），能够调优</li><li>Linux 网络调优，网络 IO 模型以及在语言里面实现</li><li>资源编排系统（Mesos / Kubernetes）</li></ul></li><li><p>理论</p><ul><li>容量规划方案</li><li>熟悉分布式理论（Paxos / Raft / BigTable / MapReduce / Spanner 等），能够为场景决策合适方案</li><li>性能模型（比如 Pxx 理解、Metrics、Dapper）</li><li>资源模型（比如 Queuing Theory、负载方案、雪崩问题）</li><li>资源编排系统（Mesos / Kurbernetes）</li></ul></li></ul><blockquote><p>本文转载自：「 知乎 」，原文：<a href="https://tinyurl.com/fbjbzcn4" target="_blank" rel="noopener">https://tinyurl.com/fbjbzcn4</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DevOps-和-SRE&quot;&gt;DevOps 和 SRE&lt;/h2&gt;
&lt;p&gt;最近有一位朋友和我聊职业发展方向问题，聊了不少 DevOps 和 SRE 话题。 我几年前刚接触这两个概念时也常常将之混淆，可惜当时没有人来解答我困惑。 现在这虽然已经极为流行，但是我发现我这位朋友对这两个职位还存在一些误区。 于是我给了一些见解并整理成文章以饕大众。&lt;/p&gt;
&lt;p&gt;最常见的误区：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DevOps 新概念，好高级哦&lt;/li&gt;
&lt;li&gt;SRE 是高级版 DevOps&lt;/li&gt;
&lt;li&gt;运维可以轻松转身 DevOps 工程师&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;DevOps-和-SRE-定义&quot;&gt;DevOps 和 SRE 定义&lt;/h2&gt;
&lt;p&gt;DevOps 是字面上 Dev 开发 / Ops 运维两者组合， 严格意义上 DevOps 如下（via DevOps - Wikipedia）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev） ”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SRE 全称是 Site Reliability Engineering，最早是由 Google 提出，并且在其工程实践中发扬光大。 他们还出了一本同名书籍「Site Reliability Engineering」， 让这个理念在互联网工程师圈子里广泛传播。&lt;/p&gt;
&lt;p&gt;Google 对 SRE 解释是（via Site Reliability Engineering - Wikipedia）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Site reliability engineering (SRE) is a discipline that incorporates aspects of software engineering and applies that to operations whose goals are to create ultra-scalable and highly reliable software systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我将其翻译翻译为中文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网站稳定性工程师是致力于打造「高扩展、高可用系统」，并将其贯彻为原则的软件工程师。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从定义来看，DevOps 是文化、运动和惯例，而 SRE 是有严格任职要求的职位。 文化是软性定义，文化有更多概念可以捏造，而 SRE 定义精准，就少了想象空间（也可能 SRE 门槛高 ）。 按 Google 给出的说法是，SRE 工程师实践了 DevOps 文化。这个观点没错，但是国内的 DevOps 逐步独立出 DevOps 工程师， 所以在本文，我着重讨论的是 DevOps 工程师和 SRE 工程师两种职位对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DevOps" scheme="https://www.hi-linux.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>最 COOL 的 Kubernetes 网络方案 CILIUM 入门教程</title>
    <link href="https://www.hi-linux.com/posts/60044.html"/>
    <id>https://www.hi-linux.com/posts/60044.html</id>
    <published>2021-06-03T01:00:00.000Z</published>
    <updated>2021-06-04T06:19:07.281Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>最近业界使用范围最广的K8S CNI网络方案<a href="https://www.projectcalico.org/introducing-the-calico-ebpf-dataplane/" target="_blank" rel="noopener">Calico宣布支持eBPF</a>，而作为第一个通过 eBPF 实现了 kube-proxy 所有功能的 K8S 网络方案——Cilium，它的先见之名是否能转成优势，继而成为 CNI 新的头牌呢？今天我们一起来入门最 Cool Kubernetes 网络方案 Cilium。</p></blockquote><h2><span id="cilium介绍">Cilium介绍</span></h2><blockquote><p>以下基于<a href="https://cilium.readthedocs.io/en/stable/" target="_blank" rel="noopener">Cilium官网文档</a>翻译整理。</p></blockquote><h3><span id="当前趋势">当前趋势</span></h3><p>现代数据中心的应用系统已经逐渐转向基于微服务架构的开发体系，一个微服务架构的应用系统是由多个小的独立的服务组成，它们之间通过轻量通信协议如 HTTP、gRPC、Kafka 等进行通信。微服务架构下的服务天然具有动态变化的特点，结合容器化部署，时常会引起大规模的容器实例启动或重启。要确保这种向高度动态化的微服务应用之间的安全可达，既是挑战，也是机遇。</p><h3><span id="现有问题">现有问题</span></h3><p>传统的 Linux 网络访问安全控制机制（如 iptables）是基于静态环境的IP地址和端口配置网络转发、过滤等规则，但是 IP 地址在微服务架构下是不断变化的，非固定的；出于安全目的，协议端口(例如 HTTP 传输的 TCP 端口 80)也不再固定用来区分应用系统。为了匹配大规模容器实例快速变化的生命周期，传统网络技术需要维护成千上万的负载均衡规则和访问控制规则，并且需要以不断增长的频率更新这些规则，而如果没有准确的可视化功能，要维护这些规则也是十分困难，这些对传统网络技术的可用性和性能都是极大的挑战。比如经常会有人对 kube-proxy 基于 iptables 的服务负载均衡功能在大规模容器场景下具有严重的性能瓶颈，同时由于容器的创建和销毁非常频繁，基于 IP 做身份关联的故障排除和安全审计等也很难实现。</p><a id="more"></a><h3><span id="解决方案">解决方案</span></h3><p>Cilium 作为一款 Kubernetes CNI 插件，从一开始就是为大规模和高度动态的容器环境而设计，并且带来了 API 级别感知的网络安全管理功能，通过使用基于 Linux 内核特性的新技术——<a href="https://docs.cilium.io/en/stable/bpf/" target="_blank" rel="noopener">BPF</a>，提供了基于 service/pod/container 作为标识，而非传统的 IP 地址，来定义和加强容器和 Pod 之间网络层、应用层的安全策略。因此，Cilium 不仅将安全控制与寻址解耦来简化在高度动态环境中应用安全性策略，而且提供传统网络第 3 层、4 层隔离功能，以及基于 http 层上隔离控制，来提供更强的安全性隔离。</p><p>另外，由于 BPF 可以动态地插入控制 Linux 系统的程序，实现了强大的安全可视化功能，而且这些变化是不需要更新应用代码或重启应用服务本身就可以生效，因为 BPF 是运行在系统内核中的。</p><p>以上这些特性，使 Cilium 能够在大规模容器环境中也具有高度可伸缩性、可视化以及安全性。</p><p><img src="https://img.hi-linux.com/staticfile/cilium-arch2020-1024x584-2021-05-29-H9lm7N.png" alt></p><h2><span id="部署-cilium">部署 Cilium</span></h2><p>部署 Cilium 非常简单，可以通过单独的 yaml 文件部署全部组件（目前我使用了这个方式部署了1.7.1 版本），也可以通过 helm chart 一键完成。重要的是部署环境和时机：</p><ol><li><p>官方建议所有部署节点都使用 Linux 最新稳定内核版本，这样所有的功能都能启用，具体部署环境建议可以参照<a href="https://cilium.readthedocs.io/en/stable/install/system_requirements/" target="_blank" rel="noopener">这里</a>。</p></li><li><p>作为一个 Kubernetes 网络组件，它应该在部署 Kubernetes 其他基础组件之后，才进行部署。这里，我自己遇到的问题是，因为还没有 CNI 插件，coredns 组件的状态一直是 pending的，直到部署完 Cilium 后，coredns 完成了重置变成running状态。</p></li></ol><p>下图是 Cilium 的整体部署组件图：</p><p><img src="https://img.hi-linux.com/staticfile/cilium-provision-2021-05-29-mP4svg.png" alt></p><h2><span id="测试安装效果">测试安装效果</span></h2><p>官方提供了一个<a href="https://github.com/cilium/cilium/blob/master/examples/kubernetes/connectivity-check/connectivity-check.yaml" target="_blank" rel="noopener">connectivity检查工具</a>，以检测部署好的 Cilium 是否工作正常。如果你的网络环境有些限制，我作了一些简单修改，可以参照<a href="https://github.com/nevermosby/K8S-CNI-Cilium-Tutorial/blob/master/cilium/connectivity-check.yaml" target="_blank" rel="noopener">这里</a>。部署起来很简单，请确保至少有两个可用的节点，否则有几个 deployment 会无法成功运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl apply -f connectivity-check.yaml</span><br><span class="line"></span><br><span class="line">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">echo-a                                  1&#x2F;1     1            1           16d</span><br><span class="line">echo-b                                  1&#x2F;1     1            1           16d</span><br><span class="line">host-to-b-multi-node-clusterip          1&#x2F;1     1            1           16d</span><br><span class="line">host-to-b-multi-node-headless           1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a                                1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a-allowed-cnp                    1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a-external-1111                  1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-a-l3-denied-cnp                  1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-b-intra-node                     1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-b-multi-node-clusterip           1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-b-multi-node-headless            1&#x2F;1     1            1           16d</span><br><span class="line">pod-to-external-fqdn-allow-google-cnp   1&#x2F;1     1            1           16d</span><br></pre></td></tr></table></figure><p>如果所有的 deployment 都能成功运行起来，说明 Cilium 已经成功部署并工作正常。</p><p><img src="https://img.hi-linux.com/staticfile/draggedimage-13-2021-05-29-wnSUP8.png" alt></p><h2><span id="网络可视化神器-hubble">网络可视化神器 Hubble</span></h2><p>上文提到了 Cilium 强大之处就是提供了简单高效的网络可视化功能，它是通过<a href="https://github.com/cilium/hubble" target="_blank" rel="noopener">Hubble</a>组件完成的。<a href="https://cilium.io/blog/2019/11/19/announcing-hubble" target="_blank" rel="noopener">Cilium在1.7版本后推出并开源了Hubble</a>，它是专门为网络可视化设计，能够利用 Cilium 提供的 eBPF 数据路径，获得对 Kubernetes 应用和服务的网络流量的深度可见性。这些网络流量信息可以对接 Hubble CLI、UI 工具，可以通过交互式的方式快速诊断如与 DNS 相关的问题。除了 Hubble 自身的监控工具，还可以对接主流的云原生监控体系—— Prometheus 和  Grafana，实现可扩展的监控策略。</p><p><img src="https://img.hi-linux.com/staticfile/hubble_arch-2021-05-29-Z4N8xr.png" alt></p><p><img src="https://cilium.io/static/hubble-arch-aa2f9af8628edc26f6c8473854d97a8a-50393.png" alt></p><h3><span id="部署-hubble-和-hubble-ui">部署 Hubble 和 Hubble UI</span></h3><p>官方提供了基于 Helm Chart 部署方式，这样可以灵活控制部署变量，实现不同监控策略。出于想要试用 hubble UI 和对接 Grafana，我是这样的部署的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; helm template hubble \</span><br><span class="line">    --namespace kube-system \</span><br><span class="line">    --set metrics.enabled&#x3D;&quot;&#123;dns:query;ignoreAAAA;destinationContext&#x3D;pod-short,drop:sourceContext&#x3D;pod;destinationContext&#x3D;pod,tcp,flow,port-distribution,icmp,http&#125;&quot; \</span><br><span class="line">    --set ui.enabled&#x3D;true \</span><br><span class="line">    &gt; hubble.yaml</span><br><span class="line">&gt; kubectl apply -f hubble.yaml</span><br><span class="line"># 包含两个组件</span><br><span class="line"># - daemonset hubble</span><br><span class="line"># - deployment hubble UI</span><br><span class="line">&gt; kubectl get pod -n kube-system |grep hubble</span><br><span class="line">hubble-67ldp                       1&#x2F;1     Running   0          21h</span><br><span class="line">hubble-f287p                       1&#x2F;1     Running   0          21h</span><br><span class="line">hubble-fxzms                       1&#x2F;1     Running   0          21h</span><br><span class="line">hubble-tlq64                       1&#x2F;1     Running   1          21h</span><br><span class="line">hubble-ui-5f9fc85849-hkzkr         1&#x2F;1     Running   0          15h</span><br><span class="line">hubble-vpxcb                       1&#x2F;1     Running   0          21h</span><br></pre></td></tr></table></figure><h3><span id="运行效果">运行效果</span></h3><p>由于默认的 Hubble UI 只提供了 ClusterIP 类似的 service，无法通过外部访问。因此需要创建一个 NodePort 类型的 service，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># hubble-ui-nodeport-svc.yaml</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  name: hubble-ui-np</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: hubble-ui</span><br><span class="line">  ports:</span><br><span class="line">    - name: http</span><br><span class="line">      port: 12000</span><br><span class="line">      nodePort: 32321</span><br><span class="line">  type: NodePort</span><br></pre></td></tr></table></figure><p>执行 <code>kubectl apply -f hubble-ui-nodeport-svc.yaml</code>，就可以通过任意集群节点 IP 地址加上 32321 端口访问 Hubble UI 的 web 服务了。打开效果如下所示：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-000-2021-05-29-tnYtAT.png" alt></p><ul><li>页面上半部分是之前部署的一整套 conectivity-check 组件的数据流向图，官方叫做 <code>Service Map</code>，默认情况下可以自动发现基于网络 3 层和 4 层的访问依赖路径，看上去非常 cool，也有点分布式链路追踪图的感觉。点击某个服务，还能看到更为详细的关系图：</li></ul><p><img src="https://img.hi-linux.com/staticfile/service-map-ex001-2021-05-29-fFJ0Ts.png" alt></p><ul><li>下图是 kube-system 命名空间下的数据流图，能看到 Hubble-UI 组件和 Hubble 组件是通过gRPC 进行通信的，非常有趣。但令人感到的好奇的是，为何没有显示 Kubernetes 核心组件之间的调用关系图:</li></ul><p><img src="https://img.hi-linux.com/staticfile/draggedimage-1-1-2021-05-29-za8OnA.png" alt></p><p>页面的下半部分默认显示的是对于每条数据流路径的详细描述，包括发起请求的 pod 名称、发起请求的 service 名称、请求目标的 pod 名称、请求目标的 service 名称、目标 IP、目标端口、目标 7 层信息、请求状态、最后一次查看时间等，如下图所示：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-flow-000-2021-05-29-HqW2Pi.png" alt></p><p>点击任意一条 flow，可以查看到更多详细信息：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-flow-001-2021-05-29-11nSZ4.png" alt></p><p>页面的下半部分可以通过点击切换成显示 network policy 模式，列出了当前命名空间下所有的网络策略：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-ui-policy-000-2021-05-29-HRJMNo.png" alt></p><p>如果想开启网络 7 层的可视化观察，就需要对目标 pod 进行 annotations ，感兴趣可以看<a href="http://docs.cilium.io/en/stable/policy/visibility/" target="_blank" rel="noopener">这里</a>，就不在入门篇详述了。</p><p>这样的网络可视化是不是你梦寐以求的，绝对能在排查请求调用问题的时候帮上大忙。</p><h3><span id="对接-grafana-prometheus">对接 Grafana + Prometheus</span></h3><p>如果你跟一样是 Grafana+ Prometheus 的忠实粉丝，那么使 Hubble 对接它们就是必然操作了。仔细的同学已经发现之前 helm template 的玄机了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--set metrics.enabled&#x3D;&quot;&#123;dns:query;ignoreAAAA;destinationContext&#x3D;pod-short,drop:sourceContext&#x3D;pod;destinationContext&#x3D;pod,tcp,flow,port-distribution,icmp,http&#125;&quot;</span><br><span class="line"># 上面的设置，表示开启了 hubble 的 metrics 输出模式，并输出以上这些信息。</span><br><span class="line"># 默认情况下，Hubble daemonset 会自动暴露 metrics API 给 Prometheus。</span><br></pre></td></tr></table></figure><p>你可以对接现有的 Grafana+Prometheus 服务，也可以部署一个简单的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下面的命令会在命名空间 cilium-monitoring 下部署一个 Grafana 服务和 Prometheus 服务</span><br><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;cilium&#x2F;cilium&#x2F;v1.6&#x2F;examples&#x2F;kubernetes&#x2F;addons&#x2F;prometheus&#x2F;monitoring-example.yaml</span><br><span class="line"># 创建对应 NodePort Service，方便外部访问 web 服务</span><br><span class="line">$ kubectl expose deployment&#x2F;grafana --type&#x3D;NodePort --port&#x3D;3000 --name&#x3D;gnp -n cilium-monitoring </span><br><span class="line">$ kubectl expose deployment&#x2F;prometheus --type&#x3D;NodePort --port&#x3D;9090 --name&#x3D;pnp -n cilium-monitoring</span><br></pre></td></tr></table></figure><p>完成部署后，打开 Grafana 网页，导入官方制作的<a href="https://github.com/cilium/hubble/blob/master/tutorials/deploy-hubble-and-grafana/grafana.json" target="_blank" rel="noopener">dashboard</a>，可以快速创建基于 Hubble 的 metrics 监控。等待一段时间，就能在 Grafana 上看到数据了：</p><p><img src="https://img.hi-linux.com/staticfile/hubble-grafana-000-2021-05-29-trvJCq.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/hubble-grafana-001-2021-05-29-sF10Ae.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/hubble-grafana-002-2021-05-29-a0lhJn.png" alt></p><p>Cilium 配合 Hubble，的确非常好用！</p><h2><span id="取代-kube-proxy-组件">取代 kube-proxy 组件</span></h2><p>Cilium 另外一个很大的宣传点是宣称已经全面实现kube-proxy的功能，包括 <code>ClusterIP</code>, <code>NodePort</code>, <code>ExternalIPs</code> 和 <code>LoadBalancer</code>，可以完全取代它的位置，同时提供更好的性能、可靠性以及可调试性。当然，这些都要归功于 eBPF 的能力。</p><p>官方文档中提到，如果你是在先有 kube-proxy 后部署的 Cilium，那么他们是一个 “共存” 状态，Cilium 会根据节点操作系统的内核版本来决定是否还需要依赖 kube-proxy 实现某些功能，可以通过以下手段验证是否能停止 kube-proxy 组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 检查 Cilium 对于取代 kube-proxy 的状态</span><br><span class="line">&gt; kubectl exec -it -n kube-system [Cilium-agent-pod] -- cilium status | grep KubeProxyReplacement</span><br><span class="line"># 默认是 Probe 状态</span><br><span class="line"># 当 Cilium agent 启动并运行，它将探测节点内核版本，判断 BPF 内核特性的可用性，</span><br><span class="line"># 如果不满足，则通过依赖 kube-proxy 来补充剩余的 Kubernetess，</span><br><span class="line"># 并禁用 BPF 中的一部分功能</span><br><span class="line">KubeProxyReplacement:   Probe   [NodePort (SNAT, 30000-32767), ExternalIPs, HostReachableServices (TCP, UDP)]</span><br><span class="line"># 查看 Cilium 保存的应用服务访问列表</span><br><span class="line"># 有了这些信息，就不需要 kube-proxy 进行中转了</span><br><span class="line">&gt; kubectl exec -it -n kube-system [Cilium-agent-pod] -- cilium service list</span><br><span class="line">ID   Frontend              Service Type   Backend</span><br><span class="line">1    10.96.0.10:53         ClusterIP      1 &#x3D;&gt; 100.64.0.98:53</span><br><span class="line">                                          2 &#x3D;&gt; 100.64.3.65:53</span><br><span class="line">2    10.96.0.10:9153       ClusterIP      1 &#x3D;&gt; 100.64.0.98:9153</span><br><span class="line">                                          2 &#x3D;&gt; 100.64.3.65:9153</span><br><span class="line">3    10.96.143.131:9090    ClusterIP      1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">4    10.96.90.39:9090      ClusterIP      1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">5    0.0.0.0:32447         NodePort       1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">6    10.1.1.179:32447      NodePort       1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">7    100.64.0.74:32447     NodePort       1 &#x3D;&gt; 100.64.4.100:9090</span><br><span class="line">8    10.96.190.1:80        ClusterIP</span><br><span class="line">9    10.96.201.51:80       ClusterIP</span><br><span class="line">10   10.96.0.1:443         ClusterIP      1 &#x3D;&gt; 10.1.1.171:6443</span><br><span class="line">                                          2 &#x3D;&gt; 10.1.1.179:6443</span><br><span class="line">                                          3 &#x3D;&gt; 10.1.1.188:6443</span><br><span class="line">11   10.96.129.193:12000   ClusterIP      1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">12   0.0.0.0:32321         NodePort       1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">13   10.1.1.179:32321      NodePort       1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">14   100.64.0.74:32321     NodePort       1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line">15   10.96.0.30:3000       ClusterIP</span><br><span class="line">16   10.96.156.253:3000    ClusterIP</span><br><span class="line">17   100.64.0.74:31332     NodePort</span><br><span class="line">18   0.0.0.0:31332         NodePort</span><br><span class="line">19   10.1.1.179:31332      NodePort</span><br><span class="line">20   10.96.131.215:12000   ClusterIP      1 &#x3D;&gt; 100.64.4.221:12000</span><br><span class="line"># 查看 iptables 是否有 kube-proxy 维护的规则</span><br><span class="line">&gt; iptables-save | grep KUBE-SVC</span><br><span class="line">&lt;Empty&gt; # 说明 kube-proxy 没有维护任何应用服务跳转，即可以停止它了。</span><br></pre></td></tr></table></figure><h2><span id="小结">小结</span></h2><p>Cilium 作为当下最 Cool 的 Kubernetes CNI 网络插件，还有很多特性，如高阶 network policy、7 层流量控制等，这款基于 BPF/eBPF 打造出的简单、高效、易用的网络管理体验，有机会大家都来试用吧。</p><blockquote><p>本文转载自：「  MY X FILES 」，原文：<a href="https://tinyurl.com/54h8zzvd" target="_blank" rel="noopener">https://tinyurl.com/54h8zzvd</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近业界使用范围最广的K8S CNI网络方案&lt;a href=&quot;https://www.projectcalico.org/introducing-the-calico-ebpf-dataplane/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Calico宣布支持eBPF&lt;/a&gt;，而作为第一个通过 eBPF 实现了 kube-proxy 所有功能的 K8S 网络方案——Cilium，它的先见之名是否能转成优势，继而成为 CNI 新的头牌呢？今天我们一起来入门最 Cool Kubernetes 网络方案 Cilium。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Cilium介绍&quot;&gt;Cilium介绍&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;以下基于&lt;a href=&quot;https://cilium.readthedocs.io/en/stable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cilium官网文档&lt;/a&gt;翻译整理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;当前趋势&quot;&gt;当前趋势&lt;/h3&gt;
&lt;p&gt;现代数据中心的应用系统已经逐渐转向基于微服务架构的开发体系，一个微服务架构的应用系统是由多个小的独立的服务组成，它们之间通过轻量通信协议如 HTTP、gRPC、Kafka 等进行通信。微服务架构下的服务天然具有动态变化的特点，结合容器化部署，时常会引起大规模的容器实例启动或重启。要确保这种向高度动态化的微服务应用之间的安全可达，既是挑战，也是机遇。&lt;/p&gt;
&lt;h3 id=&quot;现有问题&quot;&gt;现有问题&lt;/h3&gt;
&lt;p&gt;传统的 Linux 网络访问安全控制机制（如 iptables）是基于静态环境的IP地址和端口配置网络转发、过滤等规则，但是 IP 地址在微服务架构下是不断变化的，非固定的；出于安全目的，协议端口(例如 HTTP 传输的 TCP 端口 80)也不再固定用来区分应用系统。为了匹配大规模容器实例快速变化的生命周期，传统网络技术需要维护成千上万的负载均衡规则和访问控制规则，并且需要以不断增长的频率更新这些规则，而如果没有准确的可视化功能，要维护这些规则也是十分困难，这些对传统网络技术的可用性和性能都是极大的挑战。比如经常会有人对 kube-proxy 基于 iptables 的服务负载均衡功能在大规模容器场景下具有严重的性能瓶颈，同时由于容器的创建和销毁非常频繁，基于 IP 做身份关联的故障排除和安全审计等也很难实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="微服务" scheme="https://www.hi-linux.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linux 下优雅的查看系统 CPU 信息</title>
    <link href="https://www.hi-linux.com/posts/13355.html"/>
    <id>https://www.hi-linux.com/posts/13355.html</id>
    <published>2021-05-28T01:00:00.000Z</published>
    <updated>2021-05-28T08:44:37.102Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>我们在进行机器学习的时候，肯定需要使用一个比较好的 <code>GPU</code> 显卡，其次就是一个性能强劲的 <code>CPU</code> 了。主频高的 <code>CPU</code> 在跑程序的时候，真的有时候比使用 <code>GPU</code> 都跑的块，所以如何查看自己机器的 <code>CPU</code> 就是必不可少的步骤了。我们常常选购笔记本或者服务器的时候，总是会看到 <strong>X 核 XG</strong> 这样的表示，今天我们就一起来了解下其中的一些常见术语吧！</p><ul><li><strong>[1] 查看 CPU 型号和频率 - model</strong></li></ul><p>通过 <code>CPU</code> 的型号，我们可以直观的分辨其好坏和优劣，而频率则反馈的是其性能如何。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CPU型号</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"model name"</span> | uniq</span><br><span class="line">model name      : Intel(R) Xeon(R) CPU E5-2640 v4 @ 2.40GHz</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU频率</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"cpu MHz"</span> | uniq</span><br><span class="line">cpu MHz         : 1547.537</span><br><span class="line">cpu MHz         : 1250.590</span><br><span class="line">cpu MHz         : 2183.637</span><br></pre></td></tr></table></figure><ul><li><strong>[2] 查看物理 CPU 个数 - chip</strong></li></ul><p>主板上实际插入的 <code>CPU</code> 数量，可以数不重复的 <code>physical id</code> 字段有几个，即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 物理CPU数量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | sort | uniq | wc -l</span><br><span class="line">2</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><strong>[3] 查看每个物理 CPU 中 core 的个数 - core - 核数</strong></li></ul><p>单块 <code>CPU</code> 上面能处理数据的芯片组的数量，如双核、四核等，成为 <code>cpu cores</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CPU核数</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"cpu cores"</span> | uniq</span><br><span class="line">cpu cores       : 10</span><br></pre></td></tr></table></figure><ul><li><strong>[4] 查看逻辑 CPU 的个数 - processor</strong></li></ul><p>一般情况下，<strong>逻辑 CPU = 物理 CPU 个数 × 每颗核数</strong>，如果不相等的话，则表示服务器的 <code>CPU</code> 支持超线程技术。<strong>超线程技术(HTT)</strong>：简单来说，它可使处理器中的 <code>1</code> 颗内核如 <code>2</code> 颗内核那样在操作系统中发挥作用。这样一来，操作系统可使用的执行资源扩大了一倍，大幅提高了系统的整体性能，此时<strong>逻辑 CPU = 物理 CPU 个数 × 每颗核数 × 2</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逻辑CPU数</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"processor"</span> | wc -l</span><br><span class="line">40</span><br></pre></td></tr></table></figure><ul><li><strong>[5] 查询系统 CPU 是否启用超线程 - HTT</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询方式</span></span><br><span class="line">$ cat /proc/cpuinfo | grep -e <span class="string">"cpu cores"</span>  -e <span class="string">"siblings"</span> | sort | uniq</span><br><span class="line">cpu cores       : 10</span><br><span class="line">siblings        : 20</span><br></pre></td></tr></table></figure><ul><li><p>参考链接地址</p><ol><li><a href="https://wiki.mbalib.com/wiki/%E8%B6%85%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF" target="_blank" rel="noopener">超线程技术</a></li><li><a href="https://blog.csdn.net/ztguang/article/details/83089905" target="_blank" rel="noopener">CPU：chip、core 和 processor 的关系</a></li></ol></li></ul><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/yy2m9ayn" target="_blank" rel="noopener">https://tinyurl.com/yy2m9ayn</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在进行机器学习的时候，肯定需要使用一个比较好的 &lt;code&gt;GPU&lt;/code&gt; 显卡，其次就是一个性能强劲的 &lt;code&gt;CPU&lt;/code&gt; 了。主频高的 &lt;code&gt;CPU&lt;/code&gt; 在跑程序的时候，真的有时候比使用 &lt;code&gt;GPU&lt;/code&gt; 都跑的块，所以如何查看自己机器的 &lt;code&gt;CPU&lt;/code&gt; 就是必不可少的步骤了。我们常常选购笔记本或者服务器的时候，总是会看到 &lt;strong&gt;X 核 XG&lt;/strong&gt; 这样的表示，今天我们就一起来了解下其中的一些常见术语吧！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[1] 查看 CPU 型号和频率 - model&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 &lt;code&gt;CPU&lt;/code&gt; 的型号，我们可以直观的分辨其好坏和优劣，而频率则反馈的是其性能如何。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# CPU型号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat /proc/cpuinfo | grep &lt;span class=&quot;string&quot;&gt;&quot;model name&quot;&lt;/span&gt; | uniq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model name      : Intel(R) Xeon(R) CPU E5-2640 v4 @ 2.40GHz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# CPU频率&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat /proc/cpuinfo | grep &lt;span class=&quot;string&quot;&gt;&quot;cpu MHz&quot;&lt;/span&gt; | uniq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cpu MHz         : 1547.537&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cpu MHz         : 1250.590&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cpu MHz         : 2183.637&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[2] 查看物理 CPU 个数 - chip&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主板上实际插入的 &lt;code&gt;CPU&lt;/code&gt; 数量，可以数不重复的 &lt;code&gt;physical id&lt;/code&gt; 字段有几个，即可。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 物理CPU数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat /proc/cpuinfo | grep &lt;span class=&quot;string&quot;&gt;&quot;physical id&quot;&lt;/span&gt; | sort | uniq | wc -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Shell" scheme="https://www.hi-linux.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>万字总结，体系化带你全面认识 Linux 系统安全强化</title>
    <link href="https://www.hi-linux.com/posts/38523.html"/>
    <id>https://www.hi-linux.com/posts/38523.html</id>
    <published>2021-05-24T01:00:00.000Z</published>
    <updated>2021-05-26T06:08:29.931Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本指南旨在说明如何尽可能地加强 Linux 的安全性和隐私性，并且不限于任何特定的指南。</p><p>免责声明：如果您不确定自己在做什么，请不要尝试在本文中使用任何内容。</p><p>本指南仅关注安全性和隐私性，而不关注性能，可用性或其他内容。</p><p>列出的所有命令都将需要 root 特权。以 <code>$</code> 符号开头的单词表示一个变量，不同终端之间可能会有所不同。</p><h2><span id="选择正确的linux发行版">选择正确的Linux发行版</span></h2><p>选择一个好的 Linux 发行版有很多因素。</p><ul><li><p>避免分发冻结程序包，因为它们在安全更新中通常很落后</p></li><li><p>不使用与 Systemd 机制的发行版。 Systemd 包含许多不必要的攻击面；它尝试做的事情远远超出了必要，并且超出了初始化系统应做的事情。</p></li><li><p>使用 musl 作为默认的 C 库。 Musl 专注于最小化，这会导致很小的攻击面，而其他 C 库（例如 glibc）过于复杂，容易产生漏洞。例如，与 musl 中的极少数漏洞相比，glibc 中的一百多个漏洞已被公开披露。尽管仅靠披露的 CVE 本身通常是不准确的统计信息，但有时这种情况有时可以用来表示过分的问题。 Musl还具有不错的漏洞利用缓解措施，尤其是其新的强化内存分配器。</p></li><li><p>最好默认情况下使用 LibreSSL 而不是 OpenSSL 的发行版。OpenSSL 包含大量完全不必要的攻击面，并且遵循不良的安全做法。例如，它仍然保持 OS / 2和 VMS 支持这些已有数十年历史的古老操作系统。这些令人讨厌的安全做法导致了可怕的 Heartbleed 漏洞。LibreSSL 是 OpenBSD 团队的 OpenSSL 分支，它采用了出色的编程实践并消除了很多攻击面。在 LibreSSL 成立的第一年内，它缓解了许多漏洞，其中包括一些高严重性的漏洞。</p></li></ul><p>用作强化操作系统基础的最佳发行版是 Gentoo Linux，因为它可以让您精确地配置系统，以达到理想的效果，这将非常有用，尤其是参考我们在后面的章节中使用更安全的编译标志。</p><p>但是，由于 Gentoo 的巨大可用性缺陷，它对于许多人来说可能并不顺手。在这种情况下，Void Linux的 Musl 构建是一个很好的折衷方案。</p><a id="more"></a><h2><span id="内核">内核</span></h2><p>内核是操作系统的核心，不幸的是很容易受到攻击。正如Brad Spengler曾经说过的那样，可以将其视为系统上最大，最易受攻击的setuid根二进制文件。因此，对内核进行尽可能多的强化非常重要。</p><h3><span id="stable-vs-lts-内核">Stable vs LTS 内核</span></h3><p>Linux 内核以两种主要形式发布：稳定和长期支持（LTS）。稳定版本是较新的版本，而 LTS 发行版本是较老的稳定版本，长期以来一直受支持。选择上述任何一个发行版本都有许多后果。</p><p>Linux 内核未使用 CVE 标识安全漏洞。这意味着大多数安全漏洞的修复程序不能向后移植到 LTS 内核。但是稳定版本包含到目前为止进行的所有安全修复。</p><p>但是，有了这些修复程序，稳定的内核将包含更多新功能，因此大大增加了内核的攻击面，并引入了大量新错误。相反，LTS 内核的受攻击面较小，因为这些功能没有被不断添加。</p><p>此外，稳定的内核还包括更新的强化功能，以减轻 LTS 内核没有的某些利用。此类功能的一些示例是Lockdown LSM 和 STACKLEAK GCC 插件。</p><p>总而言之，在选择稳定或 LTS 内核时需要权衡取舍。LTS 内核具有较少的强化功能，并且并非当时所有的公共错误修复都已向后移植，但是通常它的攻击面更少，并且引入未知错误的可能性也较小。稳定的内核具有更多的强化功能，并且包括所有已知的错误修复，但它也具有更多的攻击面以及引入更多未知错误的机会更大。最后，最好使用较新的 LTS 分支（如4.19内核）。</p><h3><span id="sysctl">Sysctl</span></h3><p>Sysctl 是允许用户配置某些内核设置并启用各种安全功能或禁用危险功能以减少攻击面的工具。要临时更改设置，您可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w $tunable &#x3D; $value</span><br></pre></td></tr></table></figure><p>要永久更改 sysctls，您可以将要更改的 sysctls 添加到 /etc/sysctl.conf 或 /etc/sysctl.d 中的相应文件，具体取决于您的Linux发行版。</p><p>以下是您应更改的建议 sysctl 设置。</p><h3><span id="kernel-self-protection">Kernel self-protection</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.kptr_restrict&#x3D;2</span><br></pre></td></tr></table></figure><p>内核指针指向内核内存中的特定位置。这些在利用内核方面可能非常有用，但是默认情况下不会隐藏内核指针，例如，通过读取 /proc/kallsyms 的内容即可轻松发现它们。此设置旨在减轻内核指针泄漏。另外，您可以设置 <code>kernel.kptr_restrict = 1</code> 以仅从没有 CAP_SYSLOG 功能的进程中隐藏内核指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.dmesg_restrict&#x3D;1</span><br></pre></td></tr></table></figure><p>dmesg 是内核日志，它公开了大量有用的内核调试信息，但这通常会泄漏敏感信息，例如内核指针。更改上述 sysctl 设置会将内核日志限制为 CAP_SYSLOG 功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.printk&#x3D;3 3 3 3</span><br></pre></td></tr></table></figure><p>尽管 dmesg_restrict 的值，启动过程中内核日志仍将显示在控制台中。能够在引导过程中记录屏幕的恶意软件可能会滥用此恶意软件以获得更高的特权。此选项可防止这些信息泄漏。必须将其与下面描述的某些引导参数结合使用才能完全有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel.unprivileged_bpf_disabled&#x3D;1</span><br><span class="line">net.core.bpf_jit_harden&#x3D;2</span><br></pre></td></tr></table></figure><p>eBPF 暴露了很大的攻击面，因此需加以限制。这些系统将 eBPF 限制为 CAP_BPF 功能（在 5.8 之前的内核版本上为 CAP_SYS_ADMIN ），并启用 JIT 强化技术，例如常量绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev.tty.ldisc_autoload&#x3D;0</span><br></pre></td></tr></table></figure><p>这将加载 TTY 行规则限制为 CAP_SYS_MODULE 功能，以防止非特权的攻击者使用 TIOCSETD ioctl加载易受攻击的线路规则，而该 TIOCSETD ioctl 之前已在许多漏洞利用中被滥用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.unprivileged_userfaultfd&#x3D;0</span><br></pre></td></tr></table></figure><p>userfaultfd() 系统调用经常被滥用以利用“事后使用(use-after-free)”缺陷。因此，该 sysctl 用于将此 syscall 限制为 CAP_SYS_PTRACE 功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.kexec_load_disabled&#x3D;1</span><br></pre></td></tr></table></figure><p>kexec 是一个系统调用，用于在运行时引导另一个内核。可以滥用此功能来加载恶意内核并在内核模式下获得任意代码执行能力，因此该 sysctl 设置将被禁用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.sysrq&#x3D;4</span><br></pre></td></tr></table></figure><p>SysRq 密钥向非特权用户公开了许多潜在的危险调试功能。与通常的假设相反，SysRq 不仅是物理攻击的问题，而且还可以远程触发。该 sysctl 的值使其可以使用户只能使用SAK密钥，这对于安全地访问 root 是必不可少的。或者，您可以简单地将值设置为 0 以完全禁用 SysRq。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.unprivileged_userns_clone&#x3D;0</span><br></pre></td></tr></table></figure><p>用户名称空间是内核中的一项功能，旨在改善沙箱并使非特权用户易于访问它，但是，此功能公开了重要的内核攻击面，以进行特权升级，因此该 sysctl 将用户名称空间的使用限制为 CAP_SYS_ADMIN 功能。对于无特权的沙箱，建议使用具有很少攻击面的 setuid 二进制文件，以最大程度地减少特权升级的可能性。沙箱章节部分将进一步讨论此主题。</p><p>请注意，尽管该 sysctl 仅在某些Linux发行版中存在，因为它需要内核补丁。如果您的内核不包含此补丁，则可以通过设置 user.max_user_namespaces = 0 来完全禁用用户名称空间（包括 root 用户）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.perf_event_paranoid&#x3D;3</span><br></pre></td></tr></table></figure><p>性能事件会增加大量内核攻击面，并导致大量漏洞。此 sysctl 设置将性能事件的所有使用限制为 CAP_PERFMON 功能（5.8 之前的内核版本为 CAP_SYS_ADMIN）。</p><p>请注意，此 sysctl 设置需要在某些发行版中具备相关的内核补丁。否则，此设置等效于<code>kernel.perf_event_paranoid = 2</code>，它仅限制此功能的子集。</p><h3><span id="网络">网络</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies&#x3D;1</span><br></pre></td></tr></table></figure><p>这有助于防止 SYN 泛洪攻击，这种攻击是拒绝服务攻击的一种形式，在这种攻击中，攻击者发送大量虚假的 SYN 请求，以尝试消耗足够的资源以使系统对合法流量不响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_rfc1337&#x3D;1</span><br></pre></td></tr></table></figure><p>这通过丢弃处于时间等待状态的套接字的RST数据包来防止 time-wait 状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.rp_filter&#x3D;1</span><br><span class="line">net.ipv4.conf.default.rp_filter&#x3D;1</span><br></pre></td></tr></table></figure><p>这些启用了源验证，以验证从计算机所有网络接口接收到的数据包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.all.secure_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.secure_redirects&#x3D;0</span><br><span class="line">net.ipv6.conf.all.accept_redirects&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.all.send_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.send_redirects&#x3D;0</span><br></pre></td></tr></table></figure><p>这些设置禁用了 ICMP 重定向，以防止中间人攻击并最大程度地减少信息泄露。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.icmp_echo_ignore_all&#x3D;1</span><br></pre></td></tr></table></figure><p>此设置使您的系统忽略所有 ICMP 请求，以避免 Smurf 攻击，使设备更难以在网络上枚举，并防止通过 ICMP 时间戳识别时钟指纹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.accept_source_route&#x3D;0</span><br><span class="line">net.ipv4.conf.default.accept_source_route&#x3D;0</span><br><span class="line">net.ipv6.conf.all.accept_source_route&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_source_route&#x3D;0</span><br></pre></td></tr></table></figure><p>源路由是一种允许用户重定向网络流量的机制。由于这可用于执行中间人攻击，在中间人攻击中，出于恶意目的将流量重定向，因此上述设置将会禁用此功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.accept_ra&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_ra&#x3D;0</span><br></pre></td></tr></table></figure><p>恶意的 IPv6 路由广告可能会导致中间人攻击，因此应将其禁用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_sack&#x3D;0</span><br><span class="line">net.ipv4.tcp_dsack&#x3D;0</span><br><span class="line">net.ipv4.tcp_fack&#x3D;0</span><br></pre></td></tr></table></figure><p>禁用 TCP SACK。ACK 通常被利用，并且在许多情况下是不必要的，因此如果您不需要它，则应将其禁用。</p><h3><span id="用户空间">用户空间</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.yama.ptrace_scope&#x3D;2</span><br></pre></td></tr></table></figure><p>ptrace 是一个系统调用，它允许程序调试、修改和检查另一个正在运行的进程，从而使攻击者可以轻易修改其他正在运行的程序的内存。设置将 ptrace 的使用限制为仅具有 CAP_SYS_PTRACE 功能的进程。或者，将 sysctl 设置为 3 以完全禁用 ptrace。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.mmap_rnd_bits&#x3D;32</span><br><span class="line">vm.mmap_rnd_compat_bits&#x3D;16</span><br></pre></td></tr></table></figure><p>ASLR 是一种常见的漏洞利用缓解措施，它可以使进程的关键部分在内存中的位置随机化。这可能会使各种各样的漏洞利用更困难，因为它们首先需要信息泄漏。上述设置增加了用于 mmap ASLR 的熵的位数，从而提高了其有效性。</p><p><strong>这些sysctls的值必须根据CPU体系结构进行设置。以上值与x86兼容，但其他体系结构可能有所不同。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.protected_symlinks&#x3D;1</span><br><span class="line">fs.protected_hardlinks&#x3D;1</span><br></pre></td></tr></table></figure><p>仅当在可全局写入的粘性目录之外，当符号链接和关注者的所有者匹配或目录所有者与符号链接的所有者匹配时，才允许遵循符号链接。这还可以防止没有对源文件的读/写访问权限的用户创建硬链接。这两者都阻止了许多常见的 TOCTOU 漏洞（time-of-check-to-time-of-use）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.protected_fifos&#x3D;2</span><br><span class="line">fs.protected_regular&#x3D;2</span><br></pre></td></tr></table></figure><p>这些阻止了在可能由攻击者控制的环境（例如，全局可写目录）中创建文件，从而使数据欺骗攻击更加困难。</p><h3><span id="引导参数">引导参数</span></h3><p>引导参数在引导时使用引导加载程序（bootloader）将设置传递给内核。类似于sysctl，可以使用某些设置来提高安全性。引导加载程序通常在引导参数设置方式上有所不同。下面列出了一些示例，但是您应该研究特定 bootloader 的修改参数的必要步骤。</p><p>如果使用 GRUB 作为引导程序，请编辑 <code>/etc/default/grub</code> 并将参数添加到<code>GRUB_CMDLINE_LINUX_DEFAULT=line</code>。</p><p>如果使用 Syslinux，请编辑 /boot/syslinux/syslinux.cfg 并将它们添加到 APPEND 行中。</p><p>如果使用 systemd-boot，请编辑您的加载程序条目，并将其附加到 linux 行的末尾。</p><p>建议使用以下设置以提高安全性。</p><h3><span id="kernel-self-protection">Kernel self-protection</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slab_nomerge</span><br></pre></td></tr></table></figure><p>这将禁用 slab 合并，这将通过防止覆盖合并的缓存中的对象并使其更难以影响 slab 缓存的布局，从而大大增加了堆利用的难度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slub_debug&#x3D;FZ</span><br></pre></td></tr></table></figure><p>这些启用健全性检查（F）和重新分区（Z）。健全性检查会添加各种检查，以防止某些slab操作中的损坏。重新分区会在 slab 周围添加额外的区域，以检测 slab 何时被覆盖超过其实际大小，从而有助于检测溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_on_alloc&#x3D;1 init_on_free&#x3D;1</span><br></pre></td></tr></table></figure><p>这样可以在分配和空闲时间期间将内存清零，这可以帮助减轻使用后使用的漏洞并清除内存中的敏感信息。如果您的内核版本低于 5.3，则这些选项不存在。而是在上述 slub_debug 选项后面附加 “P”，以获得 slub_debug=FZP 并添加 page_poison=1。由于它们实际上是一种调试功能，刚好具有一些安全性，因此它们在释放时提供的内存擦除形式较弱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page_alloc.shuffle&#x3D;1</span><br></pre></td></tr></table></figure><p>此选项使页分配器空闲列表随机化，从而通过降低页分配的可预测性来提高安全性，同时这也提高了性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pti&#x3D;on</span><br></pre></td></tr></table></figure><p>这将启用内核页表隔离，从而减轻崩溃并防止某些 KASLR 绕过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsyscall&#x3D;none</span><br></pre></td></tr></table></figure><p>这将禁用 vsyscall，因为它们已过时且已被 vDSO 取代。 vsyscall 也在内存中的固定地址上，使其成为 ROP 攻击的潜在目标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugfs&#x3D;off</span><br></pre></td></tr></table></figure><p>这将禁用 debugfs，它会公开许多有关内核的敏感信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oops&#x3D;panic</span><br></pre></td></tr></table></figure><p>有时某些内核漏洞利用会导致所谓的 “oops”。此参数将引发内核对此类事件 panic，从而防止这些攻击。但是，有时错误的驱动程序会导致无害的操作，这会导致系统崩溃，这意味着此引导参数只能在某些硬件上使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.sig_enforce&#x3D;1</span><br></pre></td></tr></table></figure><p>这仅允许加载已使用有效密钥签名的内核模块，使加载恶意内核模块更加困难。</p><p>这可以防止加载所有树外内核模块（包括 DKMS 模块），除非您已对其进行签名，这意味着诸如 VirtualBox 或 Nvidia 驱动程序之类的模块可能不可用，但根据您的设置可能并不重要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lockdown&#x3D;confidentiality</span><br></pre></td></tr></table></figure><p>内核锁定 LSM 可以消除用户空间代码滥用以升级为内核特权并提取敏感信息的许多方法。为了在用户空间和内核之间实现清晰的安全边界，此LSM是必需的。上面的选项在 confidentiality 模式（最严格的选项）中启用此功能。这意味着 <code>module.sig_enforce=1</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mce&#x3D;0</span><br></pre></td></tr></table></figure><p>这将导致内核对 ECC 内存中无法利用的错误 panic，而这些错误可能会被利用。对于没有 ECC 内存的系统，这是不必要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quiet loglevel&#x3D;0</span><br></pre></td></tr></table></figure><p>这些参数可防止引导期间信息泄漏，并且必须与上面的 kernel.printk sysctl 结合使用。</p><h3><span id="cpu缓解">CPU缓解</span></h3><p>最好启用适用于您的CPU的所有CPU缓解措施，以确保您不受已知漏洞的影响。这是启用所有内置缓解措施的列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spectre_v2&#x3D;on spec_store_bypass_disable&#x3D;on tsx&#x3D;off tsx_async_abort&#x3D;full,nosmt mds&#x3D;full,nosmt l1tf&#x3D;full,force nosmt&#x3D;force kvm.nx_huge_pages&#x3D;force</span><br></pre></td></tr></table></figure><p>您必须研究系统受其影响的 CPU 漏洞，并相应地选择上述缓解措施。请记住，您将需要安装微代码更新，以完全免受这些漏洞的影响。但所有这些操作都可能导致性能显着下降。</p><h3><span id="结果">结果</span></h3><p>如果遵循了以上所有建议（不包括特定的 CPU 缓解措施），则将具有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slab_nomerge slub_debug&#x3D;FZ init_on_alloc&#x3D;1 init_on_free&#x3D;1 page_alloc.shuffle&#x3D;1 pti&#x3D;on vsyscall&#x3D;none debugfs&#x3D;off oops&#x3D;panic module.sig_enforce&#x3D;1 lockdown&#x3D;confidentiality mce&#x3D;0 quiet loglevel&#x3D;0</span><br></pre></td></tr></table></figure><p>如果将 GRUB 用作引导加载程序，则可能需要重新生成 GRUB 配置文件才能应用这些文件。</p><h3><span id="hidepid">hidepid</span></h3><p>proc 是一个伪文件系统，其中包含有关系统上当前正在运行的所有进程的信息。默认情况下，所有用户都可以访问此程序，这可能使攻击者可以窥探其他进程。要只允许用户看到自己的进程，而不能看到其他用户的进程，则必须使用 hidepid=2，gid=proc 挂载选项来挂载 /proc。gid=proc 将 proc 组从此功能中排除，因此您可以将特定的用户或进程列入白名单。添加这些选项的一种方法是编辑 /etc/fstab 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc &#x2F;proc proc nosuid,nodev,noexec,hidepid&#x3D;2,gid&#x3D;proc 0 0</span><br></pre></td></tr></table></figure><p>systemd-logind 仍然需要查看其他用户的进程，因此，要使用户会话在 systemd 系统上正常工作，必须创建 <code>/etc/systemd/system/systemd-logind.service.d/hidepid.conf</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">SupplementaryGroups&#x3D;proc</span><br></pre></td></tr></table></figure><h3><span id="减少内核攻击面">减少内核攻击面</span></h3><p>最好禁用不是绝对必要的任何功能，以最大程度地减少潜在的内核攻击面。这些功能不必一定很危险，它们可以只是被删除以减少攻击面的良性代码。切勿禁用您不了解的随机事物。以下是一些可能有用的示例，具体取决于您的设置。</p><h3><span id="引导参数">引导参数</span></h3><p>引导参数通常可以用来减少攻击面，这样的例子之一是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipv6.disable&#x3D;1</span><br></pre></td></tr></table></figure><p>这将禁用整个IPv6堆栈，如果您尚未迁移到该堆栈，则可能不需要该堆栈。如果正在使用的IPv6，请不要使用此引导参数。</p><h3><span id="将内核模块列入黑名单">将内核模块列入黑名单</span></h3><p>内核允许非特权的用户通过模块自动加载来间接导致某些模块被加载。这使攻击者可以自动加载易受攻击的模块，然后加以利用。一个这样的示例是 CVE-2017-6074，其中攻击者可以通过启动DCCP连接来触发DCCP内核模块的加载，然后利用该内核模块中的漏洞。</p><p>可以通过将文件插入 <code>/etc/modprobe.d</code> 并将指定的内核模块列入黑名单的方法，将特定的内核模块列入黑名单。</p><p>Install 参数告诉 modprobe 运行特定命令，而不是像往常一样加载模块。 /bin/false 是仅返回 1 的命令，该命令实际上不会执行任何操作。两者都告诉内核运行 /bin/false 而不是加载模块，这将防止攻击者利用该模块。以下是最有可能不需要的内核模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">install dccp &#x2F;bin&#x2F;false</span><br><span class="line">install sctp &#x2F;bin&#x2F;false</span><br><span class="line">install rds &#x2F;bin&#x2F;false</span><br><span class="line">install tipc &#x2F;bin&#x2F;false</span><br><span class="line">install n-hdlc &#x2F;bin&#x2F;false</span><br><span class="line">install ax25 &#x2F;bin&#x2F;false</span><br><span class="line">install netrom &#x2F;bin&#x2F;false</span><br><span class="line">install x25 &#x2F;bin&#x2F;false</span><br><span class="line">install rose &#x2F;bin&#x2F;false</span><br><span class="line">install decnet &#x2F;bin&#x2F;false</span><br><span class="line">install econet &#x2F;bin&#x2F;false</span><br><span class="line">install af_802154 &#x2F;bin&#x2F;false</span><br><span class="line">install ipx &#x2F;bin&#x2F;false</span><br><span class="line">install appletalk &#x2F;bin&#x2F;false</span><br><span class="line">install psnap &#x2F;bin&#x2F;false</span><br><span class="line">install p8023 &#x2F;bin&#x2F;false</span><br><span class="line">install p8022 &#x2F;bin&#x2F;false</span><br><span class="line">install can &#x2F;bin&#x2F;false</span><br><span class="line">install atm &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>特别是模糊的网络协议会增加大量的远程攻击面。此黑名单：</p><ul><li>DCCP — Datagram Congestion Control Protocol</li><li>SCTP — Stream Control Transmission Protocol</li><li>RDS — Reliable Datagram Sockets</li><li>TIPC — Transparent Inter-process Communication</li><li>HDLC — High-Level Data Link Control</li><li>AX25 — Amateur X.25</li><li>NetRom</li><li>X25</li><li>ROSE</li><li>DECnet</li><li>Econet</li><li>af_802154 — IEEE 802.15.4</li><li>IPX — Internetwork Packet Exchange</li><li>AppleTalk</li><li>PSNAP — Subnetwork Access Protocol</li><li>p8023 — Novell raw IEEE 802.3</li><li>p8022 — IEEE 802.2</li><li>CAN — Controller Area Network</li><li>ATM</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">install cramfs &#x2F;bin&#x2F;false</span><br><span class="line">install freevxfs &#x2F;bin&#x2F;false</span><br><span class="line">install jffs2 &#x2F;bin&#x2F;false</span><br><span class="line">install hfs &#x2F;bin&#x2F;false</span><br><span class="line">install hfsplus &#x2F;bin&#x2F;false</span><br><span class="line">install squashfs &#x2F;bin&#x2F;false</span><br><span class="line">install udf &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>将各种稀有文件系统列入黑名单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">install cifs &#x2F;bin&#x2F;true</span><br><span class="line">install nfs &#x2F;bin&#x2F;true</span><br><span class="line">install nfsv3 &#x2F;bin&#x2F;true</span><br><span class="line">install nfsv4 &#x2F;bin&#x2F;true</span><br><span class="line">install gfs2 &#x2F;bin&#x2F;true</span><br></pre></td></tr></table></figure><p>如果不使用网络文件系统，也可以将其列入黑名单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install vivid &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p><a href="https://href.li/?https://www.kernel.org/doc/html/v4.12/media/v4l-drivers/vivid.html" target="_blank" rel="noopener">vivid driver</a>驱动程序仅用于测试目的，并且是特权提升漏洞的原因，因此应禁用它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install bluetooth &#x2F;bin&#x2F;false</span><br><span class="line">install btusb &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>禁用具有安全问题历史记录的蓝牙。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install uvcvideo &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><p>这会禁用网络摄像头，以防止其被用来监视您。</p><p>您也可以将麦克风模块列入黑名单，但这在系统之间可能会有所不同。要查找模块的名称，请在 /proc/asound/modules 中查找并将其列入黑名单。例如，一个这样的模块是 snd_hda_intel。</p><p>请注意，尽管有时麦克风的内核模块与扬声器的模块相同。这意味着像这样禁用麦克风也可能会无意中禁用任何扬声器，虽然扬声器也有可能变成麦克风，所以这不一定是消极的结果。</p><p>最好从物理上删除这些设备，或者至少在 BIOS/UEFI 中禁用它们。禁用内核模块并不总是那么有效。</p><h3><span id="rfkill">rfkill</span></h3><p>可以通过rfkill将无线设备列入黑名单，以进一步减少远程攻击面。要将所有无线设备列入黑名单，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill block all</span><br></pre></td></tr></table></figure><p>WiFi可以通过以下方式解锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill unblock wifi</span><br></pre></td></tr></table></figure><p>在使用systemd的系统上，rfkill在所有会话中均保持不变，但是，在使用其他init系统的系统上，您可能必须创建一个init脚本以在引导时执行这些命令。</p><h3><span id="其他内核指针泄漏">其他内核指针泄漏</span></h3><p>前面的部分已经防止了一些内核指针泄漏，但是还有更多泄漏。</p><p>在文件系统上，/boot 中存在内核映像和 System.map 文件。/usr/src和/{,usr/} lib/modules目录中还有其他敏感的内核信息。您应该限制这些目录的文件权限，以使它们只能由root用户读取。您还应该删除 System.map 文件，因为除高级调试外，它们都不需要。</p><p>此外，某些日志记录守护程序（例如 systemd 的 journalctl ）包括内核日志，可用于绕过上述 dmesg_restrict 保护。从 adm 组中删除用户通常足以撤销对以下日志的访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -d $user adm</span><br></pre></td></tr></table></figure><h3><span id="限制对-sysfs-的访问">限制对 sysfs 的访问</span></h3><p>sysfs 是伪文件系统，可提供大量的内核和硬件信息。它通常安装在/sys上。 sysfs 导致大量信息泄漏，尤其是内核指针泄漏。Whonix 的 security-misc 软件包包括 hide-hardware-info 脚本，该脚本限制访问此目录以及 /proc 中的一些脚本，以试图隐藏潜在的硬件标识符并防止内核指针泄漏。该脚本是可配置的，并允许基于组将特定的应用程序列入白名单。建议应用此方法，并使其在启动时使用 init 脚本执行。或者这样<a href="https://href.li/?https://github.com/Whonix/security-misc/blob/master/lib/systemd/system/hide-hardware-info.service" target="_blank" rel="noopener">做成systemd服务</a>。</p><p>为了使基本功能在使用 systemd 的系统上运行，必须将一些系统服务列入白名单。这可以通过创建 <code>/etc/systemd/system/user@.service.d/sysfs.conf</code> 并添加以下内容来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">SupplementaryGroups&#x3D;sysfs</span><br></pre></td></tr></table></figure><p>但是，这不能解决所有问题。许多应用程序可能仍会中断，您需要将它们正确列入白名单。</p><h3><span id="linux强化">Linux强化</span></h3><p>某些发行版（例如 Arch Linux ）包括强化的内核程序包。它包含许多强化补丁程序和更注重安全性的内核配置。如果可能的话，建议安装它。</p><h3><span id="grsecurity">Grsecurity</span></h3><p>Grsecurity 是一组内核修补程序，可以大大提高内核安全性。这些补丁曾经可以免费获得，但是现在<a href="https://href.li/?https://grsecurity.net/passing_the_baton" target="_blank" rel="noopener">需要购买</a>了。如果可用，则强烈建议您获取它。Grsecurity 提供了最新的内核和用户空间保护。</p><h3><span id="内核运行时防护">内核运行时防护</span></h3><p>Linux Kernel Runtime Guard（LKRG）是一个内核模块，可确保运行时内核的完整性并检测漏洞。它可以杀死整个类别的内核漏洞。但这并不是一个完美的缓解方法，因为LKRG在设计上可以绕开。它仅适用于现成的恶意软件。但是，尽管可能性不大，但LKRG本身可能会像其他任何内核模块一样公开新的漏洞。</p><h3><span id="自编译内核">自编译内核</span></h3><p>建议编译您自己的内核，同时启用尽可能少的内核模块和尽可能多的安全性功能，以将内核的受攻击面保持在绝对最低限度。</p><p>另外，应用内核强化补丁，例如如上所述的 linux-hardened 或 grsecurity。</p><p>发行版编译的内核还具有公共内核指针/符号，这对于漏洞利用非常有用。编译自己的内核将为您提供独特的内核符号，连同 kptr_restrict，dmesg_restrict 和其他针对内核指针泄漏的强化措施，将使攻击者更加难以创建依赖于内核指针知识的漏洞利用程序。</p><p>您就可以从<a href="https://href.li/?https://www.whonix.org/wiki/Hardened-kernel" target="_blank" rel="noopener">Whonix的强化内核</a>中汲取灵感或使用它。</p><h2><span id="强制访问措施">强制访问措施</span></h2><p>强制访问控制（MAC）系统对程序可以访问的内容进行细粒度的控制。这意味着您的浏览器将无权访问您的整个主目录或类似目录。</p><p>最常用的 MAC 措施是 SELinux 和 AppArmor。SELinux比AppArmor 更安全，因为它的粒度更细。例如，它是基于inode而不是基于路径的，允许强制执行明显更严格的限制，可以过滤内核 ioctl 等。不幸的是，这是以难以使用和难以学习为代价的，因此某些人可能会首选 AppArmor。</p><p>要在内核中启用 AppArmor，必须设置以下引导参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apparmor&#x3D;1 security&#x3D;apparmor</span><br></pre></td></tr></table></figure><p>要启用 SELinux，请设置以下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selinux&#x3D;1 security&#x3D;selinux</span><br></pre></td></tr></table></figure><p>请记住，仅启用 MAC 措施本身并不能神奇地提高安全性。您必须制定严格的政策才能充分利用它。例如，要创建 AppArmor 配置文件，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa-genprof $path_to_program</span><br></pre></td></tr></table></figure><p>打开程序，然后像往常一样开始使用它。AppArmor 将检测需要访问哪些文件，并将它们添加到配置文件中（如果您选择的话）。但是，仅凭这一点不足以提供高质量的配置文件。请参阅<a href="https://href.li/?https://gitlab.com/apparmor/apparmor/-/wikis/Documentation" target="_blank" rel="noopener">AppArmor文档</a>以获取更多详细信息。</p><p>如果您想更进一步，则可以通过实施 initramfs 勾子来设置一个完整的系统MAC策略，该策略限制每个单个用户空间进程，该挂钩对 init 系统强制实施MAC策略。这就是 Android 使用 SELinux 的方式，以及 Whonix 未来将如何使用 AppArmor 的方式。对于加强实施最小特权原则的强大安全模型是必要的。</p><h2><span id="沙箱">沙箱</span></h2><h3><span id="应用沙箱">应用沙箱</span></h3><p>沙箱可让您在隔离的环境中运行程序，该环境对系统的其余部分具有有限的访问权限或完全没有访问权限。您可以使用它们来保护应用程序安全或运行不受信任的程序。</p><p>建议与 AppArmor 或 SELinux 一起在单独的用户帐户中使用<a href="https://href.li/?https://github.com/containers/bubblewrap" target="_blank" rel="noopener">Bubblewrap</a>到沙箱程序。您也可以考虑改用 gVisor，它的优点是为每个来宾提供了自己的内核。</p><p>这些方法中的任何一个都可以用来创建一个功能强大的沙箱，并且暴露的攻击面最小。如果您不想自己创建沙箱，请在完成后考虑使用 Whonix 的 sandbox-app-launcher。<a href="https://href.li/?https://madaidans-insecurities.github.io/linux.html#firejail" target="_blank" rel="noopener">您不应该使用Firejail</a>。</p><p>诸如 Docker 和 LXC 之类的容器解决方案经常被误导为沙盒形式。它们太宽松了，无法广泛支持各种应用程序，因此不能认为它们是强大的应用程序沙箱。</p><h3><span id="常见沙箱逃逸">常见沙箱逃逸</span></h3><h4><span id="pulseaudio">PulseAudio</span></h4><p>PulseAudio 是一种常见的声音服务器，但在编写时并未考虑隔离或沙盒的问题，这使其成为重复出现的沙盒逃逸漏洞。为了防止这种情况，建议您从沙箱中阻止对 PulseAudio 的访问，或者从系统中完全卸载它。</p><h4><span id="d-bus">D-Bus</span></h4><p>D-Bus 是台式机 Linux 上最流行的进程间通信形式，但它也是沙箱逃逸的另一种常见途径，因为它允许与服务自由交互。这些漏洞的一个例子就是 Firejail。您应该从沙箱中阻止对 D-Bus 的访问，或者通过 MAC 以细粒度的规则进行调解。</p><h4><span id="gui隔离">GUI隔离</span></h4><p>任何 Xorg 窗口都可以访问另一个窗口。这允许琐碎的键盘记录或屏幕截图程序，甚至可以记录诸如 root 密码之类的内容。您可以使用嵌套的 X11 服务器（例如 Xpra 或 Xephyr 和 bubblewrap）将 Xorg 窗口沙箱化。默认情况下，Wayland 将窗口彼此隔离，这将是一个比 Xorg 更好的选择，尽管 Wayland 可能不如 Xorg 普遍可用，因为它在开发中较早。</p><h4><span id="ptrace">ptrace</span></h4><p>如前所述，ptrace 是一个系统调用，可能会被滥用破坏在沙箱外部运行的进程。为避免这种情况，您可以通过 sysctl 启用内核 YAMA ptrace 限制，也可以在 seccomp 过滤器中将 ptrace syscall 列入黑名单。</p><h4><span id="tiocsti">TIOCSTI</span></h4><p>TIOCSTI 是一个 ioctl，它允许注入终端命令，并为攻击者提供了一种简单的机制，可以在同一用户会话内的其他进程之间横向移动。可以通过将 seccomp 过滤器中的 ioctl 列入黑名单或使用 bubblewrap 的 <code>–new-session</code> 参数来缓解这种攻击。</p><h4><span id="systemd-沙箱">Systemd 沙箱</span></h4><p>虽然不建议使用 systemd，但有些系统可能无法切换。这些人至少可以使用沙盒服务，因此他们只能访问所需的内容。这是一个沙箱化 systemd 服务的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">CapabilityBoundingSet&#x3D;CAP_NET_BIND_SERVICE</span><br><span class="line">ProtectSystem&#x3D;strict</span><br><span class="line">ProtectHome&#x3D;true</span><br><span class="line">ProtectKernelTunables&#x3D;true</span><br><span class="line">ProtectKernelModules&#x3D;true</span><br><span class="line">ProtectControlGroups&#x3D;true</span><br><span class="line">ProtectKernelLogs&#x3D;true</span><br><span class="line">ProtectHostname&#x3D;true</span><br><span class="line">ProtectClock&#x3D;true</span><br><span class="line">ProtectProc&#x3D;invisible</span><br><span class="line">ProcSubset&#x3D;pid</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line">PrivateUsers&#x3D;yes</span><br><span class="line">PrivateDevices&#x3D;true</span><br><span class="line">MemoryDenyWriteExecute&#x3D;true</span><br><span class="line">NoNewPrivileges&#x3D;true</span><br><span class="line">LockPersonality&#x3D;true</span><br><span class="line">RestrictRealtime&#x3D;true</span><br><span class="line">RestrictSUIDSGID&#x3D;true</span><br><span class="line">RestrictAddressFamilies&#x3D;AF_INET</span><br><span class="line">RestrictNamespaces&#x3D;yes</span><br><span class="line">SystemCallFilter&#x3D;write read openat close brk fstat lseek mmap mprotect munmap rt_sigaction rt_sigprocmask ioctl nanosleep select access execve getuid arch_prctl set_tid_address set_robust_list prlimit64 pread64 getrandom</span><br><span class="line">SystemCallArchitectures&#x3D;native</span><br><span class="line">UMask&#x3D;0077</span><br><span class="line">IPAddressDeny&#x3D;any</span><br><span class="line">AppArmorProfile&#x3D;&#x2F;etc&#x2F;apparmor.d&#x2F;usr.bin.example</span><br></pre></td></tr></table></figure><p>所有选项的说明：</p><ul><li><code>CapabilityBoundingSet=</code> — Specifies the <a href="https://href.li/?https://madaidans-insecurities.github.io/guides/linux-hardening.html#capabilities" target="_blank" rel="noopener">capabilities</a> the process is given.</li><li><code>ProtectHome=true</code> — Makes all home directories inaccessible.</li><li><code>ProtectKernelTunables=true</code> — Mounts kernel tunables such as those modified through <code>sysctl</code> as read-only.</li><li><code>ProtectKernelModules=true</code> — Denies module loading and unloading.</li><li><code>ProtectControlGroups=true</code> — Mounts all control group hierarchies as read-only.</li><li><code>ProtectKernelLogs=true</code> — Prevents accessing the kernel logs.</li><li><code>ProtectHostname=true</code> — Prevents changes to the system hostname.</li><li><code>ProtectClock</code> — Prevents changes to the system clock.</li><li><code>ProtectProc=invisible</code> — Hides all outside processes.</li><li><code>ProcSubset=pid</code> — Permits access to only the pid subset of <code>/proc</code>.</li><li><code>PrivateTmp=true</code> — Mounts an empty tmpfs over <code>/tmp</code> and <code>/var/tmp</code>, therefore hiding their previous contents.</li><li><code>PrivateUsers=true</code> — Sets up an empty user namespace to hide other user accounts on the system.</li><li><code>PrivateDevices=true</code> — Creates a new <code>/dev</code> mount with minimal devices present.</li><li><code>MemoryDenyWriteExecute=true</code> — Enforces a memory W^X policy.</li><li><code>NoNewPrivileges=true</code> — Prevents escalating privileges.</li><li><code>LockPersonality=true</code> — Locks down the <code>personality()</code> syscall to prevent switching execution domains.</li><li><code>RestrictRealtime=true</code> — Prevents attempts to enable realtime scheduling.</li><li><code>RestrictSUIDSGID=true</code> — Prevents executing setuid or setgid binaries.</li><li><code>RestrictAddressFamilies=AF_INET</code> — Restricts the usable socket address families to IPv4 only (<code>AF_INET</code>).</li><li><code>RestrictNamespaces=true</code> — Prevents creating any new namespaces.</li><li><code>SystemCallFilter=...</code> — Restricts the allowed syscalls to the absolute minimum. If you aren’t willing to maintain your own custom seccomp filter, then systemd provides many [predefined system call sets](<a href="https://href.li/?https://www.freedesktop.org/software/systemd/man/systemd.exec.html#System" target="_blank" rel="noopener">https://www.freedesktop.org/software/systemd/man/systemd.exec.html#System</a> Call Filtering) that you can use. <code>@system-service</code> will be suitable for many use cases.</li><li><code>SystemCallArchitectures=native</code> — Prevents executing syscalls from other CPU architectures.</li><li><code>UMask=0077</code> — Sets the <a href="https://href.li/?https://madaidans-insecurities.github.io/guides/linux-hardening.html#umask" target="_blank" rel="noopener">umask</a> to a more restrictive value.</li><li><code>IPAddressDeny=any</code> — Blocks all incoming and outgoing traffic to/from any IP address. Set <code>IPAddressAllow=</code> to configure a whitelist. Alternatively, setup a network namespace with <code>PrivateNetwork=true</code>.</li><li><code>AppArmorProfile=...</code> — Runs the process under the specified AppArmor profile.</li></ul><p>您不能仅将此示例配置复制到您的配置中，每种服务的要求各不相同，并且必须针对每种服务微调沙箱。要了解有关您可以设置的所有选项的更多信息，请阅读<a href="https://href.li/?https://www.freedesktop.org/software/systemd/man/systemd.exec.html" target="_blank" rel="noopener">systemd.exec手册页</a>。</p><p>如果您使用的系统不是 systemd 而是 init，那么可以使用 bubblewrap 轻松复制所有这些选项。</p><h3><span id="gvisor">gVisor</span></h3><p>普通沙箱固有地与主机共享同一内核。您信任我们已经评估为不安全的内核，可以正确限制这些程序。由于主机内核的整个攻击面已完全暴露，因此沙盒中的内核利用程序可以绕过任何限制。已经进行了一些努力来限制使用 seccomp 的攻击面，但不足以完全解决此问题。</p><p>GVisor 是解决此问题的方法。它为每个应用程序提供了自己的内核，该内核以内存安全的语言重新实现了 Linux 内核的大部分系统调用，从而提供了明显更强的隔离性。</p><h3><span id="虚拟机">虚拟机</span></h3><p>虽然不是传统的 “沙盒”，但虚拟机通过虚拟化全新系统来分离进程，从而提供了非常强大的隔离性。KVM是内核模块，它允许内核充当管理程序，而QEMU是利用KVM的仿真器。Virt-manager 和 GNOME Boxs都是良好且易于使用的 GUI，用于管理 KVM / QEMU 虚拟机。不建议使用 Virtualbox 的<a href="https://href.li/?https://www.whonix.org/wiki/KVM#Why_Use_KVM_Over_VirtualBox.3F" target="_blank" rel="noopener">原因</a>有很多。</p><h2><span id="强化内存分配器">强化内存分配器</span></h2><p>hardened_malloc 是一种硬化的内存分配器，可为堆内存损坏漏洞提供实质性的保护。它很大程度上基于 OpenBSD 的 malloc 设计，但具有许多改进。</p><p>可以通过 LD_PRELOAD 环境变量针对每个应用程序使用 hardened_malloc。例如，假设您编译的库位于 <code>/usr/lib/libhardened_malloc.so</code>，则可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD&#x3D;&quot;&#x2F;usr&#x2F;lib&#x2F;libhardened_malloc.so&quot; $program</span><br></pre></td></tr></table></figure><p>通过全局预加载该库，也可以在系统范围内使用它，这是使用它的推荐方法。为此，请编辑 /etc/ld.so.preload 并插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;lib&#x2F;libhardened_malloc.so</span><br></pre></td></tr></table></figure><p>尽管大多数应用程序都可以正常工作，但 hardened_malloc 可能会破坏某些应用程序。建议使用以下选项编译 hardened_malloc 以最大程度地减少损坏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SLAB_QUARANTINE_RANDOM_LENGTH&#x3D;0 </span><br><span class="line">CONFIG_SLAB_QUARANTINE_QUEUE_LENGTH&#x3D;0 </span><br><span class="line">CONFIG_GUARD_SLABS_INTERVAL&#x3D;8</span><br></pre></td></tr></table></figure><p>您还应该使用sysctl设置以下内容，以适应hardened_malloc创建的大量保护页：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count&#x3D;524240</span><br></pre></td></tr></table></figure><p><a href="https://href.li/?https://www.whonix.org/wiki/Hardened_Malloc" target="_blank" rel="noopener">Whonix项目</a>为基于Debian的发行版提供了hardened_malloc软件包。</p><h2><span id="强化编译标志">强化编译标志</span></h2><p>编译自己的程序可以带来很多好处，因为它使您能够优化程序的安全性。但是，执行完全相反的操作并降低安全性很容易，如果您不确定自己在做什么，请跳过本节。在基于源的发行版（例如Gentoo）上，这将是最简单的，但也可以在其他发行版上这样做。</p><p>某些编译选项可用于添加其他漏洞利用缓解措施，从而消除整个类别的常见漏洞。您可能听说过常规保护，例如位置独立可执行文件，堆栈粉碎保护程序，立即绑定，只读重定位和 FORTIFY_SOURCE，但是本节将不做介绍，因为它们已被广泛采用。相反，它将讨论诸如控制流完整性和影子堆栈之类的现代漏洞利用缓解措施。</p><p>本节涉及主要用 C 或 C ++ 编写的本机程序。您必须使用 Clang 编译器，因为这些功能在 GCC 上不可用。请记住，由于未广泛采用这些缓解措施，因此某些应用程序在启用它们后可能无法运行。</p><ul><li>控制流完整性（CFI）是一种缓解漏洞利用的方法，旨在防止诸如 ROP 或 JOP 之类的代码重用攻击。由于更广泛采用的缓解措施（例如 NX）使过时的利用技术过时了，因此使用这些技术利用了很大一部分漏洞。Clang 支持细粒度的前沿 CFI，这意味着它可以有效缓解JOP攻击。Clang 的 CFI 本身并不能减轻ROP；您还必须使用下面记录的单独机制。要启用此功能，必须应用以下编译标志： <code>-flto -fvisibility=hidden -fsanitize=cfi</code></li><li>影子堆栈通过将程序复制到其他隐藏堆栈中来保护程序的返回地址。然后比较主堆栈和影子堆栈中的返回地址，看两者是否不同。如果是这样，则表明存在攻击，程序将中止，从而减轻了 ROP 攻击。Clang 具有称为 ShadowCallStack 的功能，可以完成此操作，但是，仅在 ARM64 上可用。要启用此功能，必须应用以下编译标志： <code>-fsanitize=shadow-call-stack</code></li><li>如果上述 ShadowCallStack 不是一个选项，则可以选择使用具有相似目标的 SafeStack。但是，不幸的是，此功能有许多漏洞，因此效果不甚理想。如果仍然希望启用此功能，则必须应用以下编译标志： <code>-fsanitize=safe-stack</code></li><li>最常见的内存损坏漏洞之一是未初始化的内存。Clang 有一个选项可以使用零或特定模式自动初始化变量。建议将变量初始化为零，因为使用其他模式比利用漏洞缓解功能更适合发现错误。要启用此功能，必须应用以下编译标志： -ftrivial-auto-var-init=zero -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang 但该选项的存在目前正在<a href="https://href.li/?https://lists.llvm.org/pipermail/cfe-dev/2020-April/065221.html" target="_blank" rel="noopener">辩论</a>中。</li></ul><h2><span id="内存安全语言">内存安全语言</span></h2><p>用内存安全语言编写的程序会自动受到保护，免受各种安全漏洞的影响，这些安全漏洞包括缓冲区溢出，未初始化的变量，售后使用等。</p><p>Microsoft 和 Google 的安全研究人员进行的研究证明，已发现的大多数漏洞都是内存安全问题。这样的内存安全语言的示例包括 Rust，Swift 和 Java，而内存不安全语言的示例包括 C 和 C ++。如果可行，应使用内存安全替代品替换尽可能多的程序。</p><h2><span id="root-账户">Root 账户</span></h2><p>root 可以执行任何操作，并且可以访问您的整个系统。因此，应尽可能将其锁定，以使攻击者无法轻松获得 root 用户访问权限。</p><h3><span id="etcsecuretty">/etc/securetty</span></h3><p>/etc/securetty 文件指定允许您以 root 用户身份登录的位置。该文件应保留为空，以便任何人都不能从终端上这样做。</p><h3><span id="限制-su">限制 su</span></h3><p>su 可让您从终端切换用户。默认情况下，它尝试以 root 用户身份登录。要将 su 的使用限制在 wheel 组中，请编辑 <code>/etc/pam.d/su</code> 和 <code>/etc/pam.d/su-l</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth required pam_wheel.so use_uid</span><br></pre></td></tr></table></figure><p>您应该在 wheel 组中拥有尽可能少的用户。</p><h3><span id="锁定-root-账户">锁定 root 账户</span></h3><p>要锁定 root 帐户以防止任何人以 root 身份登录，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -l root</span><br></pre></td></tr></table></figure><p>在执行此操作之前，请确保您具有获取根的替代方法（例如，从活动 USB 引导并更改为文件系统的chroot ），以免您无意中将自己锁定在系统之外。</p><h3><span id="拒绝通过-ssh-的远程-root-登陆">拒绝通过 SSH 的远程 root 登陆</span></h3><p>为了防止某人通过 SSH 以 root 身份登录，请编辑 <code>/etc/ssh/sshd_config</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br></pre></td></tr></table></figure><h3><span id="增加散列回合数">增加散列回合数</span></h3><p>您可以增加 shadow 使用的哈希回合数，从而通过迫使攻击者计算更多的哈希值来破解您的密码，从而提高哈希密码的安全性。默认情况下，shadow 使用 5000 次回合，但是您可以将其增加到任意数量。尽管配置的回合越多，登录速度就越慢。编辑 /etc/pam.d/passwd 并添加回合选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password required pam_unix.so sha512 shadow nullok rounds&#x3D;65536</span><br></pre></td></tr></table></figure><p>这使 shadow 执行 65536 次散列回合。</p><p>应用此设置后，密码不会自动重新加密，因此您需要使用以下方法重置密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd $username</span><br></pre></td></tr></table></figure><h3><span id="限制-xorg-root-访问">限制 Xorg root 访问</span></h3><p>默认情况下，某些发行版以 root 用户身份运行 Xorg，这是一个问题，因为 Xorg 包含大量古老而又复杂的代码，这增加了巨大的攻击面，并使其更有可能拥有可以获取 root 特权的漏洞利用程序。要阻止它作为 root 用户执行，请编辑 <code>/etc/X11/Xwrapper.config</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">needs_root_rights &#x3D; no</span><br></pre></td></tr></table></figure><h3><span id="安全访问root">安全访问root</span></h3><p>恶意软件可以使用多种方法来嗅探 root 帐户的密码。因此，访问根帐户的传统方式是不安全的，最好根本不访问根，但这实际上是不可行的。本节详细介绍了访问根帐户的最安全方法。在安装操作系统后，应立即应用这些说明，以确保该软件不含恶意软件。</p><p>您绝对不能使用普通用户帐户访问 root，因为 root 可能已被盗用。您也不能直接登录到根帐户。通过执行以下操作，创建一个单独的“管理员”用户帐户，该帐户仅用于访问 root 用户，而不能用于访问其他用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd admin</span><br></pre></td></tr></table></figure><p>执行并来设置一个非常强的密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd admin</span><br></pre></td></tr></table></figure><p>仅允许该帐户使用您首选的权限提升机制。例如，如果使用 sudo，则通过执行以下命令来添加 sudoers异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo -f &#x2F;etc&#x2F;sudoers.d&#x2F;admin-account</span><br></pre></td></tr></table></figure><p>然后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>确保没有其他帐户可以访问 sudo（或您的首选机制）</p><p>现在，要实际登录到该帐户，请先重新启动-例如，这可以防止受损的窗口管理器执行登录欺骗。当提供登录提示时，请通过按键盘上的以下组合键来激活安全注意键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alt + SysRq + k</span><br></pre></td></tr></table></figure><p>这将杀死当前虚拟控制台上的所有应用程序，从而克服登录欺骗攻击。现在，您可以安全地登录到您的管理员帐户，并使用 root 用户执行任务。完成后，注销管理员帐户，然后重新登录到非特权用户帐户。</p><h2><span id="防火墙">防火墙</span></h2><p>防火墙可以控制传入和传出的网络流量，并且可以用来阻止或允许某些类型的流量。除非有特殊原因，否则应始终阻止所有传入流量。建议设置严格的 iptables 或 nftables 防火墙。火墙必须针对您的系统进行微调，并且没有一个适合所有防火墙的规则集。建议您熟悉创建防火墙规则。<a href="https://href.li/?https://wiki.archlinux.org/index.php/Iptables" target="_blank" rel="noopener">Arch Wiki</a>和<a href="https://href.li/?https://linux.die.net/man/8/iptables" target="_blank" rel="noopener">手册页</a>都是很好的资源。</p><p>这是基本 iptables 配置的示例，该配置禁止所有传入的网络流量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD DROP [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">:TCP - [0:0]</span><br><span class="line">:UDP - [0:0]</span><br><span class="line">-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -m conntrack --ctstate INVALID -j DROP</span><br><span class="line">-A INPUT -p udp -m conntrack --ctstate NEW -j UDP</span><br><span class="line">-A INPUT -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP</span><br><span class="line">-A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">-A INPUT -p tcp -j REJECT --reject-with tcp-reset</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-proto-unreachable</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p>但是，您不应尝试在实际系统上使用此示例。它仅适用于某些台式机系统。</p><h2><span id="身份标识">身份标识</span></h2><p>为了保护隐私，最好最大程度地减少可追溯到您的信息量。</p><h3><span id="主机名和用户名">主机名和用户名</span></h3><p>请勿在主机名或用户名中添加唯一标识的内容。将它们保留为通用名称，例如 “host” 和 “user”，以便它们无法识别您。</p><h3><span id="timezones-locales-keymaps">Timezones / Locales / Keymaps</span></h3><p>如果可能，应将您的时区设置为 “UTC”，将区域设置和键盘映射设置为 “US”。</p><h3><span id="机器id">机器ID</span></h3><p>一个独一无二的机器ID被存储在 <code>/var/lib/dbus/machine-id</code> （ systemd 系统是保存在 <code>/etc/machine-id</code> ）这些应编辑为通用名称，例如<a href="https://href.li/?https://github.com/Whonix/dist-base-files/blob/master/etc/machine-id" target="_blank" rel="noopener">Whonix ID</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b08dfa6083e7567a1921a715000001fb</span><br></pre></td></tr></table></figure><h3><span id="mac地址欺骗">MAC地址欺骗</span></h3><p>MAC 地址是分配给网络接口控制器（NIC）的唯一标识符。每次您连接到网络时（ WIFI 或以太网）则您的 MAC 地址已暴露。这使人们可以使用它来跟踪您并在本地网络上唯一地标识您。</p><p>但您不应该完全随机化 MAC 地址。拥有完全随机的 MAC 地址是显而易见的，并且会对您脱颖而出的行为产生不利影响。</p><p>MAC 地址的 OUI（组织唯一标识符）部分标识芯片组的制造商。对 MAC 地址的这一部分进行随机化处理可能会为您提供以前从未使用过的OUI，数十年来从未使用过的 OUI 或在您所在的地区极为罕见的 OUI，因此使您脱颖而出，很明显地表明您在欺骗 MAC 地址。</p><p>MAC 地址的末尾标识您的特定设备，并且可以用来跟踪您的设备。仅对 MAC 地址的这一部分进行随机化可防止您被跟踪，同时仍使MAC地址看起来可信。</p><p>要欺骗这些地址，请首先执行以下命令找出您的网络接口名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure><p>接下来，安装 macchanger 并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">macchanger -e $network_interface</span><br></pre></td></tr></table></figure><p>要在每次引导时随机分配 MAC 地址，您应该为您的特定初始化系统创建一个初始化脚本。这是 systemd的一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;macchanger on eth0</span><br><span class="line">Wants&#x3D;network-pre.target</span><br><span class="line">Before&#x3D;network-pre.target</span><br><span class="line">BindsTo&#x3D;sys-subsystem-net-devices-eth0.device</span><br><span class="line">After&#x3D;sys-subsystem-net-devices-eth0.device</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;macchanger -e eth0</span><br><span class="line">Type&#x3D;oneshot</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>上面的示例在启动时欺骗了 eth0 接口的 MAC 地址。将 eth0 替换为您的网络接口。</p><h3><span id="时间攻击">时间攻击</span></h3><p>几乎每个系统都有不同的时间。这可用于时钟偏斜指纹攻击，几毫秒的差异足以使用户被暴露识别。</p><h4><span id="icmp时间戳">ICMP时间戳</span></h4><p>ICMP 时间戳会在查询答复中泄漏系统时间。阻止这些攻击的最简单方法是利用防火墙阻止传入连接，或者使内核忽略 ICMP 请求。</p><h4><span id="tcp-时间戳">TCP 时间戳</span></h4><p>TCP 时间戳也会泄漏系统时间。内核尝试通过对每个连接使用随机偏移量来解决此问题，但<a href="https://href.li/?https://forums.whonix.org/t/do-ntp-and-tcp-timestamps-really-leak-your-local-time/7824/10" target="_blank" rel="noopener">这不足以解决问题</a>。因此应该禁用 TCP 时间戳，可以通过使用 sysctl 设置以下内容来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps&#x3D;0</span><br></pre></td></tr></table></figure><h4><span id="tcp-初始化序号">TCP 初始化序号</span></h4><p>TCP 初始序列号（ISN）是泄漏系统时间的另一种方法。为了减轻这种情况，您必须<a href="https://href.li/?https://github.com/0xsirus/tirdad" target="_blank" rel="noopener">安装tirdad内核模块</a>，该模块会生成用于连接的随机ISN。</p><h4><span id="时间同步">时间同步</span></h4><p>时间同步对于匿名性和安全性至关重要。错误的系统时钟可能使您遭受时钟偏斜指纹攻击，或者可以用来为您提供过时的 HTTPS 证书，从而绕过证书到期或吊销。</p><p>最流行的时间同步方法 NTP 是不安全的，因为它未经加密和未经身份验证，因此攻击者可以轻易地拦截和修改请求。NTP 还会以 NTP 时间戳格式泄漏本地系统时间，该格式可用于时钟偏斜指纹识别，如前所述。</p><p>因此，您应该卸载所有 NTP 客户端并禁用 systemd-timesyncd（如果正在使用）。您可以通过安全连接（HTTPS或最好是Torion服务）连接到受信任的网站，而不是 NTP，并从 HTTP 标头中提取当前时间。达到此目的的工具是 sdwdate 或我自己的<a href="https://href.li/?https://gitlab.com/madaidan/secure-time-sync" target="_blank" rel="noopener">安全时间同步工具</a>。</p><h3><span id="按键指纹">按键指纹</span></h3><p>可以通过他们在键盘上输入键的方式来对人进行指纹识别。您可以通过键入速度，在两次按键之间的暂停，每次按键被按下和释放的确切时间等方式来唯一地进行指纹识别。可以使用<a href="https://href.li/?https://www.keytrac.net/en/tryout" target="_blank" rel="noopener">KeyTrac</a>在线进行测试。</p><p><a href="https://href.li/?https://github.com/vmonaco/kloak" target="_blank" rel="noopener">Kloak</a>是一种工具，旨在通过混淆按键和释放事件之间的时间间隔来克服这种跟踪方法。当按键被按下时，它会引入随机延迟，然后由应用程序选择。</p><h2><span id="文件权限">文件权限</span></h2><p>默认情况下，文件的权限是非常宽松的。您应该在整个系统中搜索权限不当的文件和目录，并对其进行限制。例如，在诸如 Debian 之类的某些发行版中，用户的 Home 目录是全局可读的。</p><p>这可以通过执行以下操作来限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 &#x2F;home&#x2F;$user</span><br></pre></td></tr></table></figure><p>另外一些示例是/boot，/usr /src和/ {,usr /} lib/modules 它们包含内核映像，System.map和其他各种文件，所有这些文件都可能泄漏有关内核的敏感信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 &#x2F;boot &#x2F;usr&#x2F;src &#x2F;lib&#x2F;modules &#x2F;usr&#x2F;lib&#x2F;modules</span><br></pre></td></tr></table></figure><p>在基于 Debian 的发行版中，必须使用 dpkg-statoverride 保留文件许可权。否则，它们将在更新期间被覆盖。</p><p>Whonix的<a href="https://href.li/?https://www.whonix.org/wiki/SUID_Disabler_and_Permission_Hardener" target="_blank" rel="noopener">SUID Disabler和Permission Hardener</a>会自动应用本节中详细介绍的步骤。</p><h3><span id="setuid-setgid">setuid / setgid</span></h3><p>Setuid / SUID 允许用户使用二进制文件所有者的特权执行二进制文件。这通常用于允许非特权用户使用通常仅为 root 用户保留的某些功能。因此，许多 SUID 二进制文件都有特权升级安全漏洞的历史记录。 Setgid / SGID 类似，但适用于组而不是用户。要使用 setuid 或 setgid 位查找系统上的所有二进制文件，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -type f \( -perm -4000 -o -perm -2000 \)</span><br></pre></td></tr></table></figure><p>然后，您应该删除不使用的程序上的所有不必要的 setuid / setgid 位，或将其替换为功能。要删除 setuid 位，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-s $path_to_program</span><br></pre></td></tr></table></figure><p>要删除 setgid 位，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod g-s $path_to_program</span><br></pre></td></tr></table></figure><p>要向文件添加功能，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcap $capability+ep $path_to_program</span><br></pre></td></tr></table></figure><p>或者，要删除不必要的功能，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcap -r $path_to_program</span><br></pre></td></tr></table></figure><h3><span id="umask">umask</span></h3><p>umask 设置新创建文件的默认文件权限。默认的 umask 是0022，它不是很安全，因为它为系统上的每个用户提供了对新创建文件的读取访问权限。要使所有者以外的任何人都不可读新文件，请编辑 /etc/profile 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask 0077</span><br></pre></td></tr></table></figure><h2><span id="核心转储">核心转储</span></h2><p>核心转储包含特定时间（通常是该程序崩溃时）该程序的已记录内存。它们可能包含敏感信息，例如密码和加密密钥，因此必须将其禁用。</p><p>禁用它们的方法主要有三种：sysctl，systemd 和 ulimit</p><h3><span id="sysctl">sysctl</span></h3><p>通过 sysctl 设置以下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.core_pattern&#x3D;|&#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><h3><span id="systemd">systemd</span></h3><p>创建 <code>/etc/systemd/coredump.conf.d/disable.conf</code> 并添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Coredump]</span><br><span class="line">Storage&#x3D;none</span><br></pre></td></tr></table></figure><h3><span id="ulimit">ulimit</span></h3><p>编辑/etc/security/limits.conf并添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* hard core 0</span><br></pre></td></tr></table></figure><h3><span id="setuid进程">setuid进程</span></h3><p>即使在进行了这些设置之后，以提升的特权运行的进程仍可能会转储其内存。</p><p>为了防止他们这样做，请通过 sysctl 设置以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.suid_dumpable&#x3D;0</span><br></pre></td></tr></table></figure><h2><span id="swap">Swap</span></h2><p>与核心转储类似，交换或分页将部分内存复制到磁盘，其中可能包含敏感信息。应该将内核配置为仅在绝对必要时进行交换，相应的 sysctl 设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness&#x3D;1</span><br></pre></td></tr></table></figure><h2><span id="pam">PAM</span></h2><p>PAM 是用于用户身份验证的框架。这就是您登录时使用的机制。您可以通过要求使用强密码或在失败的登录尝试后强制执行延迟验证来使其更加安全。</p><p>要强制使用强密码，可以使用 pam_pwquality。它强制执行密码的可配置策略。例如，如果您希望密码至少包含 16 个字符（最小），与旧密码（difok）至少 6 个不同的字符，至少 3 个数字（dcredit），至少 2 个大写字母（ucredit），至少 2 个字符小写字母（lcredit）和至少 3 个其他字符（ocredit），然后编辑 /etc/pam.d/passwd 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password required pam_pwquality.so retry&#x3D;2 minlen&#x3D;16 difok&#x3D;6 dcredit&#x3D;-3 ucredit&#x3D;-2 lcredit&#x3D;-2 ocredit&#x3D;-3 enforce_for_root</span><br><span class="line">password required pam_unix.so use_authtok sha512 shadow</span><br></pre></td></tr></table></figure><p>要强制执行延迟验证，可以使用 pam_faildelay。要在两次失败的登录尝试之间添加至少4秒的延迟以阻止暴力破解尝试，请编辑 /etc/pam.d/system-login 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth optional pam_faildelay.so delay&#x3D;4000000</span><br></pre></td></tr></table></figure><p>4000000 是 4 秒（以微秒为单位）。</p><h2><span id="microcode更新">Microcode更新</span></h2><p>Microcode 更新对于修复关键的 CPU 漏洞（如 Meltdown 和 Spectre 等）至关重要。大多数发行版都将这些发行版包含在其软件仓库中，例如<a href="https://href.li/?https://wiki.archlinux.org/index.php/Microcode" target="_blank" rel="noopener">Arch Linux</a>和<a href="https://href.li/?https://wiki.debian.org/Microcode" target="_blank" rel="noopener">Debian</a>。</p><h2><span id="ipv6-隐私扩展">IPv6 隐私扩展</span></h2><p>IPv6 地址是从计算机的 MAC 地址生成的，从而使您的 IPv6 地址是唯一的，并直接绑定到计算机。隐私扩展会生成一个随机的 IPv6 地址，以减轻这种形式的跟踪。请注意，如果您开启了 MAC 地址欺骗机制或禁用了 IPv6，则无需执行这些步骤。</p><p>要启用这些功能，请通过sysctl设置以下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.use_tempaddr&#x3D;2</span><br><span class="line">net.ipv6.conf.default.use_tempaddr&#x3D;2</span><br></pre></td></tr></table></figure><h3><span id="networkmanager">NetworkManager</span></h3><p>要为NetworkManager启用隐私扩展，请编辑 <code>/etc/NetworkManager/NetworkManager.conf</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[connection]</span><br><span class="line">ipv6.ip6-privacy&#x3D;2</span><br></pre></td></tr></table></figure><h3><span id="systemd-networkd">systemd-networkd</span></h3><p>要为 systemd-networkd 启用隐私扩展，请创建 <code>/etc/systemd/network/ipv6-privacy.conf</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Network]</span><br><span class="line">IPv6PrivacyExtensions&#x3D;kernel</span><br></pre></td></tr></table></figure><h3><span id="分区和挂载选项">分区和挂载选项</span></h3><p>文件系统应分为多个分区，以对其权限进行细粒度控制。可以添加不同的安装选项以限制可以执行的操作：</p><ul><li>nodev - 禁止使用设备</li><li>nosuid - 禁止setuid或setgid位</li><li>noexec - 禁止执行任何二进制文件</li></ul><p>这些安装选项应在 /etc/fstab 中尽可能设置。如果您不能使用单独的分区，请创建绑定挂载。一个更安全的 /etc/fstab 的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;        &#x2F;          ext4    defaults                              1 1</span><br><span class="line">&#x2F;home    &#x2F;home      ext4    defaults,nosuid,noexec,nodev          1 2</span><br><span class="line">&#x2F;tmp     &#x2F;tmp       ext4    defaults,bind,nosuid,noexec,nodev     1 2</span><br><span class="line">&#x2F;var     &#x2F;var       ext4    defaults,bind,nosuid                  1 2</span><br><span class="line">&#x2F;boot    &#x2F;boot      ext4    defaults,nosuid,noexec,nodev          1 2</span><br></pre></td></tr></table></figure><p>请注意，可以<a href="https://href.li/?https://chromium.googlesource.com/chromiumos/docs/+/master/security/noexec_shell_scripts.md" target="_blank" rel="noopener">通过shell脚本绕过noexec</a>。</p><h2><span id="熵">熵</span></h2><p>熵基本上反应操作系统信息收集的随机程度，对于诸如加密之类的事情至关重要。因此，最好通过安装其他随机数生成器（如<a href="https://href.li/?http://www.issihosts.com/haveged/" target="_blank" rel="noopener">haveged</a>和<a href="https://href.li/?https://github.com/smuellerDD/jitterentropy-rngd" target="_blank" rel="noopener">jitterentropy</a>）从各种来源收集尽可能多的熵。</p><p>为了使jitterentropy正确运行，必须通过创建 <code>/usr/lib/modules-load.d/jitterentropy.conf</code> 并添加以下内容尽早加载内核模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jitterentropy_rng</span><br></pre></td></tr></table></figure><h3><span id="rdrand">RDRAND</span></h3><p>RDRAN 是提供随机数的 CPU 指令。如果可用，内核会自动将其用作熵源。但是由于它是专有的并且是 CPU 身的一部分，因此无法审核和验证其安全性。您甚至无法对代码进行反向工程。该RNG以前曾遭受过漏洞的攻击，其中有些可能是后门攻击。通过设置以下引导参数可以不信任此功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random.trust_cpu&#x3D;off</span><br></pre></td></tr></table></figure><h2><span id="以-root-身份编辑文件">以 root 身份编辑文件</span></h2><p>建议不要以 root 用户身份运行普通的文本编辑器。大多数文本编辑器可以做的不仅仅是简单地编辑文本文件，而且还可以被利用。例如，以 root 身份打开 vi 并输入：sh。现在，您具有一个可以访问整个系统的 root shell，攻击者可以轻松利用该 shell。</p><p>解决方案是使用 sudoedit。这会将文件复制到一个临时位置，以普通用户身份打开文本编辑器，编辑该临时文件并以root用户身份覆盖原始文件。这样，实际的编辑器就不会以 root 身份运行。要使用 sudoedit，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudoedit $path_to_file</span><br></pre></td></tr></table></figure><p>默认情况下，它使用 vi，但是可以通过 EDITOR 或 SUDO_EDITOR 环境变量来切换默认编辑器。例如，要使用 nano，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR&#x3D;nano sudoedit $path_to_file</span><br></pre></td></tr></table></figure><p>可以在 /etc/environment 中全局设置此环境变量。</p><h2><span id="特定发行版的安全强化">特定发行版的安全强化</span></h2><h3><span id="http包管理器镜像">HTTP包管理器镜像</span></h3><p>默认情况下，Linux发行版通常使用 HTTP 或 HTTP 和 HTTPS 镜像的混合来从其软件存储库下载软件包。人们认为这很好，因为程序包管理器会在安装前验证程序包的签名。但是，从历史上看，已经有很多绕过此方法的地方。您应将软件包管理器配置为从 HTTPS 镜像专门下载以进行深度防御。</p><h3><span id="apt-seccomp-bpf">APT seccomp-bpf</span></h3><p>自软件包管理器 Debian Buster 以来，APT 已支持可选的 seccomp-bpf 过滤。这限制了允许执行APT的系统调用，这可能严重限制攻击者尝试利用APT中的漏洞时对系统造成危害的能力。要启用此功能，请创建 <code>/etc/apt/apt.conf.d/40sandbox</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APT::Sandbox::Seccomp &quot;true&quot;;</span><br></pre></td></tr></table></figure><h2><span id="物理安全">物理安全</span></h2><p>全盘加密可确保对驱动器上的所有数据进行加密，并且不会被物理攻击者读取。大多数发行版都支持在安装过程中启用加密，请确保设置了强密码。您也可以使用<a href="https://href.li/?https://wiki.archlinux.org/index.php/Dm-crypt" target="_blank" rel="noopener">dm-crypt</a>手动加密驱动器。</p><p>请注意，全盘加密不包括 /boot，这样仍然可以修改内核、引导加载程序和其他关键文件。为了完全防止篡改，您还必须实施经过验证的引导。</p><h3><span id="bios-uefi强化">BIOS / UEFI强化</span></h3><p>如果您仍在使用旧版 BIOS，则应迁移到 UEFI，以利用较新的安全功能。大多数 BIOS 或 UEFI 实现都支持设置密码。最好启用它并设置一个非常强壮的密码。虽然这是很弱的保护，因为重置密码很简单。它通常存储在易失性内存中，因此攻击者只需要能够卸下 CMOS 电池几秒钟，或者他们就可以使用某些主板上的跳线将其重置。</p><p>您还应该禁用所有未使用的设备和引导选项，例如USB引导，以减少攻击面。</p><p>别忽略 BIOS 或 UEFI 的更新，确保将其更新。将其与常规操作系统更新一样重要。</p><p>此外，请参阅<a href="https://href.li/?https://github.com/nsacyber/Hardware-and-Firmware-Security-Guidance" target="_blank" rel="noopener">《NSA的硬件和固件安全指南》</a></p><h3><span id="bootloader-密码">Bootloader 密码</span></h3><p>引导加载程序会在引导过程的早期执行，并负责加载操作系统。保护它非常重要，否则，它可能会被篡改。例如，本地攻击者可以通过在启动时使用 <code>init=/bin/bash</code> 作为内核参数来轻松获得 root shell，该命令告诉内核执行 /bin/bash 而不是常规的 init 系统。您可以通过为引导加载程序设置密码来防止这种情况。仅设置引导程序密码不足以完全保护它。还必须按照以下说明设置经过验证的启动。</p><h4><span id="grub">Grub</span></h4><p>要为 GRUB 设置密码，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkpasswd-pbkdf2</span><br></pre></td></tr></table></figure><p>输入您的密码，该密码将生成一个字符串。它将类似于 &quot;grub.pbkdf2.sha512.10000.C4009… &quot; 。创建 <code>/etc/grub.d/40_password</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set superusers&#x3D;&quot;$username&quot;</span><br><span class="line">password_pbkdf2 $username $password</span><br></pre></td></tr></table></figure><p>用 grub-mkpasswd-pbkdf2 生成的字符串替换 “$password”。 “$username” 将用于被允许使用GRUB命令行，编辑菜单项和执行任何菜单项的超级用户。对于大多数人来说，这只是 &quot;root”。</p><p>重新生成您的配置文件，GRUB 现在将受到密码保护。</p><p>要仅限制编辑引导参数并访问 GRUB 控制台，同时仍然允许您引导，请编辑 <code>/boot/grub/grub.cfg</code> 并在 &quot;menuentry $OSName &quot; 旁边添加 <code>-–unrestricted</code> 参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menuentry &#39;Arch Linux&#39; --unrestricted</span><br></pre></td></tr></table></figure><p>您将需要再次重新生成配置文件以应用此更改。</p><h3><span id="syslinux">Syslinux</span></h3><p>Syslinux 可以设置主密码或菜单密码。引导任何条目都需要主密码，而引导特定条目仅需要菜单密码。</p><p>要为 Syslinux 设置主密码，请编辑 <code>/boot/syslinux/syslinux.cfg</code> 并添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MENU MASTER PASSWD $password</span><br></pre></td></tr></table></figure><p>要设置菜单密码，请编辑 <code>/boot/syslinux/syslinux.cfg</code> ，并在带有您要密码保护的项目的标签内，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MENU PASSWD $password</span><br></pre></td></tr></table></figure><p>将 “$password” 替换为您要设置的密码。</p><p>这些密码可以是纯文本，也可以使用MD5，SHA-1，SHA-256 或 SHA-512 进行散列。建议先使用强哈希算法（例如SHA-256或SHA-512）对密码进行哈希处理，以避免将其存储为明文形式。</p><h3><span id="systemd-boot">systemd-boot</span></h3><p>systemd-boot 具有防止在引导时编辑内核参数的选项。在 loader.conf文件中，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editor no</span><br></pre></td></tr></table></figure><p>systemd-boot 并不正式支持保护内核参数编辑器的密码，但是您可以<a href="https://href.li/?https://github.com/kitsunyan/systemd-boot-password" target="_blank" rel="noopener">使用systemd-boot-password来实现</a>。</p><h3><span id="验证引导">验证引导</span></h3><p>经过验证的引导通过密码验证来确保引导链和基本系统的完整性。这可用于确保物理攻击者无法修改设备上的软件。</p><p>如果没有经过验证的引导，则一旦获得物理访问权限，就可以轻松绕过上述所有预防措施。经过验证的引导不仅像许多人认为的那样是为了物理安全。它还可以用于防止远程恶意软件持久化——如果攻击者设法破坏了整个系统并获得了很高的特权，则经过验证的引导将在重新引导后还原其更改，并确保它们无法持久化。</p><p>经过验证的最常见的引导实现是UEFI安全引导，但是它本身并不是一个完整的实现，因为它仅会验证引导加载程序和内核，这意味着可以通过以下方法：</p><ul><li>仅UEFI安全启动就没有一成不变的信任根，因此物理攻击者仍然可以刷新设备的固件。为了减轻这种情况，请结合使用UEFI安全启动和 Intel Boot Guard 或 AMD Secure Boot。</li><li>远程攻击者（或不使用加密的物理攻击者）可以简单地修改操作系统的任何其他特权部分。例如，如果他们有修改内核的特权，那么他们也可以修改 /sbin/init 来有效地获得相同的结果。因此，仅验证内核和引导加载程序不会对远程攻击者产生任何影响。为了减轻这种情况，您必须使用<a href="https://href.li/?https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/verity.html" target="_blank" rel="noopener">dm-verity</a>验证基本操作系统，尽管由于传统Linux发行版的布局，这非常困难且笨拙。</li></ul><p>通常，很难在传统Linux上实现可靠的经过验证的引导实现。</p><h3><span id="usbs">USBs</span></h3><p>USB设备为物理攻击提供了重要的攻击面。例如<a href="https://href.li/?https://srlabs.de/bites/badusb/" target="_blank" rel="noopener">BadUSB</a>和<a href="https://href.li/?https://en.wikipedia.org/wiki/Stuxnet" target="_blank" rel="noopener">Stuxnet</a>是此类攻击的范例。最佳实践是禁止所有新连接的USB且仅将受信任设备列入白名单，<a href="https://href.li/?https://usbguard.github.io/" target="_blank" rel="noopener">USBGuard</a>对此非常有用。</p><p>您也可以将nousb用作内核引导参数，以禁用内核中的所有USB支持。可以 sysctl 设置kernel.deny_new_usb=1</p><h3><span id="dma攻击">DMA攻击</span></h3><p>直接内存访问（DMA）攻击涉及通过插入某些物理设备来完全访问所有系统内存。这可以通过控制设备可访问的内存区域的<a href="https://href.li/?https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit" target="_blank" rel="noopener">IOMMU</a>或将特别易受攻击的内核模块列入黑名单来缓解。</p><p>要启用 IOMMU，请设置以下内核引导参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intel_iommu&#x3D;on amd_iommu&#x3D;on</span><br></pre></td></tr></table></figure><p>您只需要为特定的 CPU 制造商启用该选项，但同时启用这两个选项就没有问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efi&#x3D;disable_early_pci_dma</span><br></pre></td></tr></table></figure><p>通过在非常早的启动过程中禁用所有 PCI 桥接器上的 busmaster 位，此选项可<a href="https://href.li/?https://mjg59.dreamwidth.org/54433.html" target="_blank" rel="noopener">修复上述IOMMU中的漏洞</a>。</p><p>此外，Thunderbolt 和 FireWire 通常容易受到 DMA 攻击。要禁用它们，请将这些内核模块列入黑名单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install firewire-core &#x2F;bin&#x2F;false</span><br><span class="line">install thunderbolt &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure><h3><span id="冷启动攻击">冷启动攻击</span></h3><p>当攻击者在擦除 RAM 中的数据之前对其进行分析时，就会发生<a href="https://href.li/?https://en.wikipedia.org/wiki/Cold_boot_attack" target="_blank" rel="noopener">冷启动攻击</a>。使用现代 RAM 时，冷启动攻击不太实用，因为 RAM 通常会在几秒钟或几分钟内清除，除非将其放入冷却液（如液氮或冷冻机）中。攻击者必须在几秒钟内将设备中的RAM棒拔出并将其暴露于液氮中，而且确保用户不会注意到。</p><p>如果冷启动攻击是威胁模型的一部分，请在关机后保护计算机几分钟，以确保没有人可以访问您的 RAM 记忆棒。您也可以将 RAM 棒焊接到主板上，以使其更难以卡住。如果使用笔记本电脑，请取出电池，然后直接用充电电缆供电。关机后请拔出电缆，以确保RAM彻底断电无法访问。</p><p>在内核自我保护启动参数部分中，空闲时内存清零选项将用零覆盖内存中的敏感数据。此外，强化的内存分配器可以通过 <code>CONFIG_ZERO_ON_FREE</code> 配置选项清除用户空间堆内存中的敏感数据。尽管如此，某些数据仍可能保留在内存中。</p><p>此外，现代内核还包括<a href="https://href.li/?https://lwn.net/Articles/730006/" target="_blank" rel="noopener">复位攻击缓解</a>措施，该命令可命令固件在关机时擦除数据，尽管这需要<a href="https://href.li/?https://www.trustedcomputinggroup.org/wp-content/uploads/Platform-Reset-Attack-Mitigation-Specification.pdf" target="_blank" rel="noopener">固件支持</a>。</p><p>确保正常关闭计算机，以使上述缓解措施可以开始。</p><p>如果以上都不适用您的威胁模型，则可以实施<a href="https://href.li/?https://tails.boum.org/contribute/design/memory_erasure/" target="_blank" rel="noopener">Tails的内存擦除过程</a>，该过程将擦除大部分内存（视频内存除外），并且已被证明是有效的。</p><h2><span id="最佳实践">最佳实践</span></h2><p>一旦对系统进行了尽可能多的加固，就应该遵循良好的隐私和安全性惯例：</p><ul><li>禁用或删除不需要的东西以最小化攻击面。</li><li>保持更新。配置 cron 任务或 init 脚本以每天更新系统。</li><li>不要泄漏有关您或您的系统的任何信息，无论它看起来多么渺小。</li><li>遵循<a href="https://href.li/?https://madaidans-insecurities.github.io/security-privacy-advice.html" target="_blank" rel="noopener">常规的安全和隐私建议</a></li></ul><p>尽管已经进行了强化，但您必须记住 Linux 仍然是一个有缺陷的操作系统，没有任何强化可以完全修复它。</p><h2><span id="其他指南">其他指南</span></h2><p>您应该进行尽可能多的研究，而不要依赖单一的信息来源。最大的安全问题之一就是用户。这些是我认为有价值的其他指南的链接：</p><ul><li><p><a href="https://href.li/?https://wiki.archlinux.org/index.php/Security" target="_blank" rel="noopener">Arch Linux Security wiki page</a></p></li><li><p><a href="https://href.li/?https://www.whonix.org/wiki/Documentation" target="_blank" rel="noopener">Whonix Documentation</a></p></li><li><p><a href="https://href.li/?https://apps.nsa.gov/iaarchive/library/ia-guidance/security-configuration/operating-systems/guide-to-the-secure-configuration-of-red-hat-enterprise.cfm" target="_blank" rel="noopener">NSA RHEL 5 Hardening Guide</a> (稍有过时，但仍包含有用的信息）</p></li><li><p><a href="https://href.li/?https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings" target="_blank" rel="noopener">KSPP recommended kernel settings</a></p></li><li><p><a href="https://href.li/?https://github.com/a13xp0p0v/kconfig-hardened-check/" target="_blank" rel="noopener">kconfig-hardened-check</a></p></li></ul><h2><span id="术语">术语</span></h2><p>您可能需要重新生成 GRUB 配置，以应用对引导加载程序所做的某些更改。在不同的发行版之间，执行此操作的步骤有时可能会有所不同。例如，在诸如 Arch Linux 之类的发行版上，应通过执行以下命令来重新生成配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o $path_to_grub_config</span><br></pre></td></tr></table></figure><p>“$path_to_grub_config” 取决于您如何设置系统。它通常是 <code>/boot/grub/grub.cfg</code>或 <code>/boot/EFI/grub/grub.cfg</code>，但是在执行此命令之前，请务必确保正确。</p><p>另外，在 Debian 或 Ubuntu 等发行版上，您应该执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure><h2><span id="能力">能力</span></h2><p>在 Linux 内核中，“root 特权” 分为各种不同的能力（<a href="https://href.li/?https://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">capabilities</a>）。这在应用最小特权原则时很有帮助——可以给它们仅授予特定的子集，而不是授予进程总的 root 特权。例如，如果程序只需要设置系统时间，则只需要 CAP_SYS_TIME 而不是 root 所有能力。这会限制可能造成的损害，但是，您仍必须谨慎授予能力，因为无论如何，其中许多能力<a href="https://href.li/?https://forums.grsecurity.net/viewtopic.php?t=2522" target="_blank" rel="noopener">可能会被滥用以获取完整的root特权</a>。</p><p>本文翻译自：<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html" target="_blank" rel="noopener">https://madaidans-insecurities.github.io/guides/linux-hardening.html</a></p><p><strong>如需『 Linux 系统安全强化指南 』PDF 高清版，可在公众号对话框回复关键字：「<code>LinuxSecurity</code>」获取。</strong></p><blockquote><p>本文转载自：「 GAO CHAO’S NEW BLOG 」，原文：<a href="http://t.cn/A6VwHzjQ" target="_blank" rel="noopener">http://t.cn/A6VwHzjQ</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本指南旨在说明如何尽可能地加强 Linux 的安全性和隐私性，并且不限于任何特定的指南。&lt;/p&gt;
&lt;p&gt;免责声明：如果您不确定自己在做什么，请不要尝试在本文中使用任何内容。&lt;/p&gt;
&lt;p&gt;本指南仅关注安全性和隐私性，而不关注性能，可用性或其他内容。&lt;/p&gt;
&lt;p&gt;列出的所有命令都将需要 root 特权。以 &lt;code&gt;$&lt;/code&gt; 符号开头的单词表示一个变量，不同终端之间可能会有所不同。&lt;/p&gt;
&lt;h2 id=&quot;选择正确的Linux发行版&quot;&gt;选择正确的Linux发行版&lt;/h2&gt;
&lt;p&gt;选择一个好的 Linux 发行版有很多因素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;避免分发冻结程序包，因为它们在安全更新中通常很落后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用与 Systemd 机制的发行版。 Systemd 包含许多不必要的攻击面；它尝试做的事情远远超出了必要，并且超出了初始化系统应做的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 musl 作为默认的 C 库。 Musl 专注于最小化，这会导致很小的攻击面，而其他 C 库（例如 glibc）过于复杂，容易产生漏洞。例如，与 musl 中的极少数漏洞相比，glibc 中的一百多个漏洞已被公开披露。尽管仅靠披露的 CVE 本身通常是不准确的统计信息，但有时这种情况有时可以用来表示过分的问题。 Musl还具有不错的漏洞利用缓解措施，尤其是其新的强化内存分配器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最好默认情况下使用 LibreSSL 而不是 OpenSSL 的发行版。OpenSSL 包含大量完全不必要的攻击面，并且遵循不良的安全做法。例如，它仍然保持 OS / 2和 VMS 支持这些已有数十年历史的古老操作系统。这些令人讨厌的安全做法导致了可怕的 Heartbleed 漏洞。LibreSSL 是 OpenBSD 团队的 OpenSSL 分支，它采用了出色的编程实践并消除了很多攻击面。在 LibreSSL 成立的第一年内，它缓解了许多漏洞，其中包括一些高严重性的漏洞。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用作强化操作系统基础的最佳发行版是 Gentoo Linux，因为它可以让您精确地配置系统，以达到理想的效果，这将非常有用，尤其是参考我们在后面的章节中使用更安全的编译标志。&lt;/p&gt;
&lt;p&gt;但是，由于 Gentoo 的巨大可用性缺陷，它对于许多人来说可能并不顺手。在这种情况下，Void Linux的 Musl 构建是一个很好的折衷方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="安全" scheme="https://www.hi-linux.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>小白也能看懂的网络基础 | 02 连接设备？</title>
    <link href="https://www.hi-linux.com/posts/50201.html"/>
    <id>https://www.hi-linux.com/posts/50201.html</id>
    <published>2021-05-21T01:00:00.000Z</published>
    <updated>2021-05-21T10:02:25.206Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言">引言</span></h2><p>欢迎来到网络世界，《小白也能看懂的网络基础》系列文章会从零开始帮助你构建网络的基础知识。如果你完全没有接触过网络相关的内容，那我们是一样的，在学习过程中我们肯定遇到了相同的问题！写下这些文章一方面要记录自己的学习历程，另一方面也希望帮到同样想要学习网络基础的小伙伴。</p><p>文章的部分内容与素材是我从【Youtube平台】的【<a href="https://www.youtube.com/channel/UCtuXekfqj-paqsxtqVNCC2A" target="_blank" rel="noopener">Network Direction</a>】发布的系列视频学习和搜集过来的，翻译不易，部分内容可能无法做到尽善尽美，甚至可能会有部分瑕疵，我会尽力让文章内容通俗易懂，覆盖全面。若各位小伙伴发现任何问题，希望能够留言或私信告诉我，在下不胜感激！当然，我也会在第一时间进行更正。</p><p>在往后的每一篇文章中，我都会把看到文章的小伙伴当成是完全没有网络经验的小白，我的目标是和零基础小白一起建立坚实的网络基础，网络大神请略过此系列文章。</p><p>让我们开始网络之旅吧！</p><a id="more"></a><h2><span id="线缆和-wi-fi">线缆和 Wi-Fi</span></h2><h3><span id="1连接设备">1.连接设备</span></h3><p>首先我们需要知道，想要将设备连接到网络，有两种方式可供选择，那就是「<strong>有线和无线</strong>」。</p><p>相信大家对这两兄弟都不陌生了，有线连接从很早以前就出现了，最早可追溯到1960年代，有线网络使用电缆进行连接。</p><p>而无线技术的发展，也已经有相当长的一段历史了，最早可追溯到1990年代。说到无线，我们最先想到的就是与它相关的移动设备，例如：收音机、手机、便携式笔记本电脑等。对于无线技术，我们经常称它为「Wi-Fi」。</p><p><img src="https://img.hi-linux.com/staticfile/a4eb6a3ea8ddc076a20906b97cd2cfa1-2021-03-17-ssNJJ7.gif" alt="有线和无线"></p><h4><span id="1-有线设备">1. 有线设备</span></h4><p>电缆通常使用铜线制成，铜缆更便宜，常用于短距离传输，同时因为它是使用电信号进行信息传播，这就意味着它可能会受到外界电磁干扰的影响，所以，我们常见的网线多由多股线栏缠绕制成，后面的小节会讲到原因。</p><p>光纤通常使用玻璃作为传输介质，可用于较长距离信号传输，因其使用光信号，所以不易受外界信号干扰，但因为其材质的特殊，导致光纤的价格通常都比较昂贵。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140149102-2021-03-16-BzMdPa.png" alt></p><table><thead><tr><th><strong>铜缆</strong></th><th><strong>光纤</strong></th></tr></thead><tbody><tr><td>铜丝制作</td><td>玻璃制作</td></tr><tr><td>更便宜</td><td>更昂贵</td></tr><tr><td>短距离传输</td><td>较长距离传输</td></tr><tr><td>使用电信号</td><td>使用光信号</td></tr><tr><td>容易受到外界干扰</td><td>不受外界干扰</td></tr></tbody></table><h4><span id="2-无线设备">2. 无线设备</span></h4><p>无论是台式机，还是移动笔记本，或者是手机平板电脑，如果想要实现无线连接，就必须配备无线网卡，大部分情况下，台式机是没有无线网卡的，因此需要单独购买无线网卡，可以直接通过USB连接以实现无线上网。</p><h2><span id="以太网协议">以太网协议</span></h2><p>由于 <strong>「以太网」</strong> 构建简单、成本低、可扩展性强、与IP网能够很好地结合等特点，使它成为局域网网络构建中最常用的一种技术。对于 <strong>「以太网协议」</strong>，则代表了接入以太网的节点设备都达成一致的一组规则。想要接入以太网，就必须按 <strong>「合同」</strong> 办事儿。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-4rjH9z.gif" alt="以太网"></p><p><strong>「以太网」</strong> 由许多不同的部分组成，其中一部分描述了 <strong>线缆的类型</strong> 以及 <strong>不同线缆的传输速度</strong>；另一部分则描述了数据应该 <strong>如何进行格式化</strong> 和 <strong>发送</strong> 的操作，这部分被称为 <strong>「媒体访问控制」</strong>。</p><p><strong>「以太网」</strong> 这样来分层的主要原因，是为了兼容不同线缆以不同速度访问不同的设备，却依然能够保证设备间的正常通信，毕竟我们无法保证每台设备、线缆及其传输速度都相同，差异性是不可避免的问题！</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-bpNhFR.gif" alt="本地主机访问服务器"></p><p>举个例子：一个具有 1G b网络带宽的本地主机，想要将数据发送到具有10Gb带宽的服务器上，这中间经历了哪些操作？</p><p>首先，本地主机根据「媒体访问控制」规则准备一条信息，接下来，再根据它必须遵循的物理规则来发送信息；然后，信息通过物理线缆发送到了服务器这边，当服务器收到消息，它会对这段消息进行解码，并通过「媒体访问控制」，传递到服务器主机。</p><p>正是因为本地主机与服务器主机都遵循了以太网的协议规则，才能保证彼此间的通信不会出现问题，并最终将信息传递到目的地。即使双方使用不同的线缆、带宽与设备， 该分层系统仍然畅通无阻 ！</p><h3><span id="1-以太网协议标准">1. 以太网协议标准</span></h3><p>以太网技术诞生以后，IEEE 组织制定了众多以太网不同的技术标准，每一个标准都会用一段代号来命名（就像007和9527一样）。以 802 开头的标准用于局域网技术。而以太网技术的代号是 <strong>802.3</strong> ，再配合一到两个字母就组成了以太网不同的类型。</p><table><thead><tr><th>速度</th><th>常用名称</th><th>非正式名称</th><th>正式名称</th><th>线缆类型</th><th>最大传输距离</th></tr></thead><tbody><tr><td>10Mbps</td><td>以太网</td><td>10BASE-T</td><td>802.3</td><td>双绞线</td><td>100m</td></tr><tr><td>100Mbps</td><td>快速以太网</td><td>100BASE-T</td><td>802.3u</td><td>双绞线</td><td>100m</td></tr><tr><td>1Gbps</td><td>1吉比特以太网</td><td>1000BASE-LX</td><td>802.3z</td><td>光纤</td><td>5000m</td></tr><tr><td>1Gbps</td><td>1吉比特以太网</td><td>1000BASE-T</td><td>802.3ab</td><td>双绞线</td><td>100m</td></tr><tr><td>10Gbpx</td><td>10吉比特以太网</td><td>10GBASE-T</td><td>802.3an</td><td>双绞线</td><td>100m</td></tr></tbody></table><p>单独通过正式名称来记忆这些类型实属不易，因此 IEEE 组织还给我们准备了便于记忆的非正式名称。拿 <strong>10GBASE-T</strong> 来举例，里面的 <strong>10G</strong> 代表了其传输速度为 <strong>「10G比特每秒」</strong>，<strong>「比特」</strong> 是传输速率的单位，比特值越高，其传输速度也越快；<strong>BASE = Baseband</strong>(cables) 是 <strong>基带</strong> 的意思，代表它使用数字信号进行传输（另一种是模拟信号）；而后面的 <strong>T</strong> ，则代表了所使用的线缆类型，T=UTP 也就是双绞线（另一种是LX光纤）。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-gleloB.gif" alt="以太网标准"></p><p>我们已经知道了，电缆使用电信号来传输数据；而光纤使用光信号来传输数据；无论使用哪种信号，这里的数据指的都是我们熟知的 <strong>「01代码」</strong>，接收器会对接收到的 <strong>「01代码」</strong> 进行相应解码，这就是所谓的 <strong>「编码方案」。</strong></p><h3><span id="2-电信号">2. 电信号</span></h3><p>首先我们来看一下电信号，想要发送电信号，就需要拥有电路，这意味着我们需要准备多根电线以传输数据，而我们最常见的线缆称为 <strong>「非屏蔽双绞线」</strong>（UTP，也就是常见的网线），每对电线构成一个电路。</p><p><img src="https://img.hi-linux.com/staticfile/d669b71f87224584ff5ffcc4719382f4-2021-03-16-c7n3d4.gif" alt="非屏蔽双绞线（UTP）"></p><p>听名字我们也知道了，它是非屏蔽的线缆，也就意味着如果外界有电磁干扰，它就会受影响，在初中的时候我们就学习过了，电和磁铁是有一定关系的。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-bzNOtC.gif" alt="电磁干扰"></p><p>电流通过铜缆会产生磁场，同时也生成了电力。问题就出在这里，一对平行运行的电线会产生小的电磁场，如果一对铜线有电流经过，则必定会对其旁边的另一对电线的信号产生电磁干扰，我们称其为 <strong>「串扰」</strong>。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-SvuLn5.gif" alt="串扰"></p><p>为了解决 <strong>「串扰」</strong> 的问题，非屏蔽双绞线则将平行的两根铜缆绞在一起，这样一来，就有效的避免了电磁干扰，而这也是它名字的由来。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-EHSYQH.gif" alt="双绞线"></p><p>如果条件允许的话，你可以找到一条废弃的双绞线，将水晶头去掉，观察一下内部的线缆，就可以清晰的看到，线缆确实是绞在一起的。</p><p><img src="https://img.hi-linux.com/staticfile/1da9a14e0901077a05fd8f67703af114-2021-03-16-7LbeG3.gif" alt="真实的双绞线"></p><h3><span id="3-双绞线">3. 双绞线</span></h3><p>我们可以看到多种不同类型的双绞线，有的中间有塑料芯，有的则是一根细线。通常，我们使用颜色对其进行编码，每对电线都是由<strong>纯色</strong>和<strong>条纹色</strong>组成的，观察图片就不难看出。例如蓝色和蓝白线缆绞在一起，而棕色和棕白线缆绞在一起。</p><p>通常，我们常见的网线都是由四对电线组成的，而在早期的标准中，其线缆并不一定是由四对组成的（例如：10BASE-T 和 100BASE-T 都是由两对绞线组成），但是如果想要让传输速度达到1Gbps或10Gbps，就必须使用全部四对电线才可以。</p><p>不同的以太网标准，需要使用不同的线缆，我们应该都听说过 「5类线」 或 「6类线」 这样的名称，其实这就是不同网线的专用术语，不同的类别对应了不同线缆的标准（例如：线缆的对数、线缆的粗细以及线缆的交合程度）。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140149821-2021-03-16-iD7GHf.png" alt="线缆的不同标准"></p><p>例如：Cat2 仅具有两对线缆，而Cat5具有四对线缆，Cat6 具有比 Cat5 更粗的四对线缆等等</p><p>不同类别的线缆会定义不同的名称，除了数字的不同，后面的英文字母也不同，比如：Cat5e，Cat6，Cat6a，数字越大，标准越新，意味着传输距离越远，速度越高！！</p><p>举一个现实一些的案例，我们可以在 100Mbps 的网络上使用5类线；但如果你想让网速达到千兆，就至少需要使用 Cat5e 这样标准的线缆；而如果你想让网速达到万兆，那就需要使用 Cat6 也就是6类网线才能达到理论速度。</p><p>如果你的带宽达到了万兆，但你的线缆跟不上，仅仅使用5类线 Cat5，那你的实际使用网速肯定达不到万兆，其原因是线缆没法支持那么快的速度！</p><p>所以，回家赶紧看看你家网络的带宽是多少，为什么理论速度达到了，可实际使用却达不到那么快的网速，原因可能就是因为你的线缆太老旧了，扔了换新的吧。</p><table><thead><tr><th>线缆名称</th><th>线缆介绍</th><th>线缆速率</th></tr></thead><tbody><tr><td>CAT-1</td><td>以往用在传统电话的网络线路</td><td>无</td></tr><tr><td>CAT-2</td><td>以往用在令牌环网络</td><td>4 Mbit/s</td></tr><tr><td>CAT-3</td><td>提供16MHz的带宽，曾经常用在 10 Mbit/s 以太网络</td><td>10 Mbit/s</td></tr><tr><td>CAT-4</td><td>提供20MHz的带宽，曾经常用在 16 Mbit/s 的令牌环网</td><td>16 Mbit/s</td></tr><tr><td>CAT-5</td><td>提供100MHz的带宽，目前常用在快速以太网（100 Mbit/s）中</td><td>100 Mbit/s</td></tr><tr><td>CAT-5e</td><td>提供125MHz的带宽，目前常用在快速以太网及千兆以太网（1000Mbit/s）中</td><td>1000 Mbit/s</td></tr><tr><td>CAT-6</td><td>提供250MHz的带宽，比CAT-5与CAT-5e高出一倍半</td><td>2500 Mbit/s</td></tr><tr><td>CAT-6A</td><td>提供500MHz的带宽，使用在万兆以太网（10 Gbit/s）中</td><td>10 Gbit/s</td></tr><tr><td>CAT-7</td><td>设计供以600MHz频率传输信号</td><td>未定</td></tr></tbody></table><h3><span id="4-电缆的连接器">4. 电缆的连接器</span></h3><p>我们的线缆两端都会安装一个连接器，这个连接器的名字叫做 <strong>「rj45连接器」</strong>，其实就是我们所说的水晶头，它们是接入到网卡与交换机端口的部分，该连接器有八个引脚，它们与电缆内部的八根铜线对齐，必须按正确的顺序与引脚对齐才能保证通信。</p><p><img src="https://img.hi-linux.com/staticfile/cf3d4d7d0e9a0c5bf3215eb87e13aff8-2021-03-16-57dxiR.gif" alt="线缆与引脚对齐方式"></p><p>大家应该听到过连接线缆的口诀，那就是「橙白橙，绿白蓝，蓝白绿，棕白棕」，这种连接方式称为「568b」，其实就是图示中的这种顺序，确保顺序正确，再将其与水晶头的8个引脚对齐，这样就大功告成了！</p><p><img src="https://img.hi-linux.com/staticfile/127e61edc2578c46acf2e72bea56647e-2021-03-16-hjQZXx.gif" alt="引脚连接"></p><p>在网络通信中，其实就是将一端的 <strong>引脚1对接另一端的引脚1</strong> ，<strong>引脚2对接另一端的引脚2</strong> ，以此类推，因其线缆直通另一端线缆的特性，我们称这种连接方式为 「 <strong>直通电缆(Straight Through)</strong> 」。</p><p><img src="https://img.hi-linux.com/staticfile/31c4a596fa089776220b84cd1e4b140f-2021-03-16-ReBzhU.gif" alt="数据传输与接收"></p><p>这些线缆中的一部分用于<strong>传输数据</strong>，另一部分则用于<strong>接收数据</strong>，在这里，我们使用TX表示传输，TR表示接收，如图所示，第一对引脚就用来传输数据，而第二对引脚则用来接收数据。</p><p><img src="https://img.hi-linux.com/staticfile/056930b3f4c75795fa01bc7e29f135b9-2021-03-16-xRL1sZ.gif" alt="主机直连到交换机"></p><p>当我们将一台主机通过网线接入到交换机上，交换机非常聪明，在它这一端的水晶头接口处，它知道用第一对引脚来接收数据，用第二对引脚来传输数据。也正因为此，它的名字叫做交换机，交换的就是这个位置的信息。</p><p><img src="https://img.hi-linux.com/staticfile/6d389681f72bb6edfdefba7ac1ad9bff-2021-03-16-glvHXk.gif" alt="主机直连到主机（或交换器）"></p><p>但是，如果我们将这台主机的网线接入到另一台主机或路由器，而不是交换机呢？这会遇到什么情况？引脚的排列顺序不对了，它们使用相同的引脚来收发数据，这就导致数据传不出去了呀！所以，我们这里就不能使用「直通电缆」，而需要使用 <strong>「交叉电缆(Crossover)」</strong>，那就是将用于传输数据一端的引脚对应接收数据的引脚，即可解决问题（将一台交换机接入到另一台交换机，也是同样的道理）。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-5SjT3C.gif" alt="Auto MDI-X 自动引脚逻辑切换功能"></p><p>我能理解你此刻的心情，你肯定会说，这太痛苦了吧？不但要使用不同的以太网线缆或接头，还要保证线序完全对应，我只想说「恕臣无能！」。为了避免我们陷入此困境，我们拥有一项成为「 <strong>Auto MDI-X</strong> 」 的技术，尽管 「 <strong>Auto MDI-X</strong> 」 可以支持的设备可以检测是否使用了错误的线缆，然后，可以再逻辑上切换引脚的功能，使其与电缆相匹配，但是需要注意的是在以太网为 100BASE-T 及以上的标准才可以支持这项技术。</p><p>因为现在我们现在应用的以太网标准基本都处于 100BASE-T 之上，所以我们可以不必担心直通电缆与交叉电缆的问题，不过我们还是应该记住它们两个之间的区别。</p><p>当我们的以太网标准达到 1000BASE-TX 时，情况发生了一些变化，此时，我们会利用所有的四对电线进行数据传输（较旧的标准只需要使用两对），这里有两种工作方式，分别是 1000BASE-T 和 1000BASE-TX。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-Hc2lb6.gif" alt="1000BASE-TX标准"></p><p>1000BASE-TX 的标准是使用两对电线用于传输，另外两对电线用于接收，如果想要使用这种标准的话，我们需要将网线升级到 cat6 或更高级别。</p><p><img src="https://img.hi-linux.com/staticfile/a883ca8bbb5e809ba5f846ebf7beae1b-2021-03-16-fJhz8M.gif" alt="1000BASE-T标准"></p><p>1000BASE-T 的标准是使用所有的四对电线同时进行发送和接受，这是非常特别的一种方式，它只需要使用 cat5e 标准的线缆即可。</p><h3><span id="5-光纤">5. 光纤</span></h3><p><img src="https://img.hi-linux.com/staticfile/Z75exR-2021-03-17-6BfdtD.jpg" alt="光纤"></p><p>铜缆的替代品就是光纤，光纤使用的材质是「玻璃束」，使用这种材质，脉冲信号会从「玻璃束」的一端通过「玻璃束体」向另一端传递。回顾一下我们初中时做的物理实验，将一束光打到流动的弯曲水柱上，光会跟随水柱的方向进行传递，这里用的就是「光的全反射」原理。</p><p><img src="https://img.hi-linux.com/staticfile/4683047a308f46d8d149111d18bbba8a-2021-03-16-T8boZ1.gif" alt="光的全反射"></p><p>光纤通常用在路由器和交换机之类的网络设备之间，也可能用在我们从未见过的服务器中。</p><h3><span id="6-全双工与半双工">6. 全双工与半双工</span></h3><p>我们回过头来看一下全双工和半双工，看看它们是如何工作的。</p><h4><span id="61-全双工full-duplex">6.1 全双工（Full Duplex）</span></h4><p><strong>全双工</strong> 的意思就是，UTP非屏蔽双绞线的线缆需要同时发送和接受信息，如图所示，这需要两端的设备都支持同时发送和接受。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-9j6gVj.gif" alt="全双工"></p><h4><span id="62-半双工half-duplex">6.2 半双工（Half Duplex）</span></h4><p>有时候，两端设备中的某一端可能并不支持同时发送和接受信息，因此，信息发送完毕后，需要等待一会，待收到对方回复信息后，才能再次发送信息，这种方式就是 <strong>「半双工」</strong>。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-6Qy6Kp.gif" alt="半双工"></p><p>根据 <strong>全双工</strong>与<strong>半双工</strong> 的特性，光纤就有两种不同的使用方式：</p><h3><span id="7-单芯光纤与双芯光纤">7. 单芯光纤与双芯光纤</span></h3><h4><span id="71-单芯光纤single-core">7.1 单芯光纤（Single Core）</span></h4><p>由于无法同时发送和接受，因此单芯光纤只能使用半双工模式运行。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-BoiZZt.gif" alt="单芯光纤"></p><h4><span id="72-双芯光纤dual-core">7.2 双芯光纤（Dual Core）</span></h4><p>因其双芯的特性，其中一个芯专用于发送，而另一个芯则用于接收，因此双芯光纤支持全双工模式的运行。</p><p><img src="https://img.hi-linux.com/staticfile/bc47f38f17cebd00f367a8a06a73c8fb-2021-03-16-rwcK3K.gif" alt="双芯光纤"></p><p>如果我们自行连接光纤，却不能正常使用时，可以尝试交换光纤方向，问题也许就可以解决。</p><p><img src="https://img.hi-linux.com/staticfile/x2EUqr-2021-03-17-c7IHR0.jpg" alt="双芯光纤与单芯光纤"></p><p>企业网络通常使用双芯光纤，通常是使用在交换机、路由器和服务器之间。对于家庭中使用的光纤，网络服务提供商通常只会提供单核光纤。</p><h3><span id="8-单模与多模光纤">8. 单模与多模光纤</span></h3><p>接下来，我们来聊一下单模光纤与多模光纤，它们可能看起来很相似，但因为使用光的类型不同而产生了很大的差别。</p><h4><span id="81-单模光纤smfsingle-mode-fibre">8.1 单模光纤（SMF：Single Mode Fibre）</span></h4><p>单模光纤使用激光作为光源，这是其价格更高，但这中广可以传输更远的距离，很容易就可以达到2公里或更长的距离，服务提供商通常会在不同的建筑中使用单模光纤，以方便每栋用户流畅的访问Internet。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140150598-2021-03-16-Nun3KQ.png" alt="单模光纤"></p><h4><span id="82-多模光纤mmfmulti-mode-fibre">8.2 多模光纤（MMF：Multi Mode Fibre）</span></h4><p>多模光纤使用LED作为光源，它并不是特别强的光， 所以只能在较短的距离（500m或更短）传输，通常用于同一栋建筑中的网络连接，效果非常好。同时因为LED的生产成本比较低，因此如果你很在乎价格，可以选择这种类型的光纤。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140150629-2021-03-16-vWgjl5.png" alt="多模光纤"></p><h3><span id="9-光纤弯曲程度">9. 光纤弯曲程度</span></h3><p>尽管光纤是由玻璃制成的，但它具有很强的柔韧性，即便对它进行一定程度的弯曲也不会造成它的损坏。光纤都具有最大弯曲半径（根据光纤的不同而不同），光纤缠绕的程度会导致不同程度的信号衰减（信号衰减或丢失的地方），如果你想知道你家的光纤最大的弯曲程度是多少，可以联系网络服务提供商。</p><p><img src="https://img.hi-linux.com/staticfile/111-2021-03-17-6c20sX.gif" alt="光纤的弯曲程度"></p><h3><span id="10-光纤的连接器">10. 光纤的连接器</span></h3><p>光纤有非常多不同类型的连接器（接头），这里大家要知道，光纤不仅仅用于网络连接，它可能还会有一些其他用途。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140150728-2021-03-16-NY1h3U.png" alt="光纤连接器"></p><p>例如：LC类型的接头就通常用与与交换机和路由器的连接，我们通常会在双核配置中看到它们；而SC类型的接头属于比较老旧的类型，它看起来更大，通常我们会在配线柜中看到它。</p><p><img src="https://img.hi-linux.com/staticfile/222-2021-03-17-6C0lhd.png" alt="配线柜"></p><p>一些交换机会有一些看起来很空的特殊的接口，而一些交换机则完全由这些接口组成，这些接口都是用于安装收发器模块的，这些接口都可以用于不同目的，但通常情况下，他们都是用于很合匹配不同线缆的接头的，这些收发器接口支持不同的电缆类型，包括了单模和多模光纤。同时它们还支持不同的速度，例如1G或10G的速度；它们也支持不同的电缆长度，例如长40公里电缆的收发器比1公里的收法器要贵得多。</p><p><img src="https://img.hi-linux.com/staticfile/618afb36222910564c757147daa9da90-2021-03-16-gAEahw.gif" alt="交换机上的特殊接口"></p><p>这些交换机准备这么多端口最终原因是为了方便我们搭配不同的收发器，以完成不同的业务场景。我们甚至可以为其安装上「rj45收发器」，以满足我想要安装双绞线的需求。</p><p><img src="https://img.hi-linux.com/staticfile/996b1c608e3680334b1b919f839449ac-2021-03-17-bA5vdN.gif" alt="RJ45收发器"></p><h3><span id="11-wi-fi-连接">11. Wi-Fi 连接</span></h3><p>我们的另一种通信方法就是无线Wi-Fi通信，它不需要使用电缆连接，无线网络就像一个无线的交换机，可以让手机、笔记本之类的无线设备链接到接入点，但这个接入点是需要链接到有线网络的，此时，有线和无线设备可以在同一个网络当中使用。当然，并不是所有的设备都会连接到无线接入点的，例如我们不能把路由器或服务器连接到无线接入点。</p><p><img src="https://img.hi-linux.com/staticfile/2622f77fdd2700d1ee34df375fac4d23-2021-03-16-lOiRLs.gif" alt="无线网络"></p><p>Wi-Fi网络不适用 802.3 的以太网标准，它使用的是 802.11 的标准（802.11 标准描述了信息是如何使用无线电波来格式化和编码信息），虽然它们不是同一个以太网，但它们都是由 IEEE 制定，因此在数据格式化方面有很多相似之处。</p><h3><span id="总结">总结</span></h3><ol><li>网络可以是有线或无线的，网络连接可以使用铜缆或光缆</li><li>以太网标准用于描述了物理连接线缆的类型以及如何格式化数据</li><li>UTP有四对双绞线，其中一些用于数据发送，另一些用于数据接收</li><li>线缆可以以直通方式或交叉方式连接到交换机</li><li>现如今的大部分平台都支持 Auto MDI-X，可自动对线缆进行检测并做出调整</li><li>双工设备可以同时发送和接受数据，半双工则需要收到响应后再发送数据</li><li>双芯光纤支持全双工，单芯光纤支持半双工</li><li>若想要短距离连接，并节省更多成本，可以选择多模光纤</li><li>若想要远距离连接，则需要支付更高的价格，选择单模光纤，同时需采用正确收发器</li><li>如果有线连接无法满足你的需求，可以采用无线网络连接</li></ol><h3><span id="问题">问题</span></h3><ol><li>1000BASE-T以什么速度运行？需要使用什么类型的电缆？</li><li>使用哪种类型的UTP电缆将主机连接到交换机？那种类型的电缆可以将一个交换机连接到另一个交换机？</li><li>哪种情况下我们需要使用 Auto MDI-X 技术？</li><li>那种情况下需要使用光纤代替UTP？什么时候需要单模式光纤而不是多模光纤？</li><li>什么是弯曲半径？使用哪种类型的电缆，需要特别注意弯曲半径？</li><li>请简单阐述全双工工作模式的特点</li></ol><h2><span id="网络寻址">网络寻址</span></h2><p><img src="https://img.hi-linux.com/staticfile/aa699b8601737a0d0ef782babcb58570-2021-03-16-SXOTWq.gif" alt="模拟 soho 网络"></p><p>让我们回到  <strong>「soho网络」</strong> ，一起来看一个比较特殊的案例，我们用下图作为一个模拟的 <strong>「soho网络」</strong> 。假如，我们想通过网络中的一台主机，将需要打印的文件信息传递给打印机，因为打印机已入网，所以我们可以实现这一功能，在这个网络中有多个节点存在，试问一下，我们的电脑主机如何才能知道将信息发送到什么位置呢？</p><p><img src="https://img.hi-linux.com/staticfile/92ed8da29ce74e745fbad62319ea2b55-2021-03-16-pxwChj.gif" alt="soho 网络中的节点同时发送信息"></p><p>虽然，我们可以将打印信息发送给网络中的所有节点，然后让节点去判断这个信息是否是发给自己的，但这样一来信息的安全性且不说，效率低下才是最致命的；试想一下，如果所有的设备同时发送信息，该怎么办？如果网络环境下有多台打印机，该怎么办？会出现什么状况？网络将变得一团糟！所以呢，我们需要一个解决方法。</p><p><img src="https://img.hi-linux.com/staticfile/bef18e90b170848a5d55c0019ccc1290-2021-03-16-ys8kRE.gif" alt="网络设备地址"></p><p>其实，网络上的每台设备都有一个地址，这就类似于我们公司的、家庭的或亲朋好友的家庭住址，这个地址一定是唯一的，因此，我们邮寄包裹或网络购物可以找到准确的位置。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210316140151841-2021-03-16-LerkaC.png" alt="MAC 地址与 IP 地址"></p><p>在同一个域中，每台设备都会有两个地址，分别是 MAC 地址和 IP 地址，这两个地址的使用方式不同，目前，我们先大概了解它们的特点与基本使用，后面的章节会做展开讲解。</p><h3><span id="1mac地址">1.MAC地址</span></h3><p><img src="https://img.hi-linux.com/staticfile/84fb3871865da2ed8b3a89d1c1ceebcd-2021-03-16-BQaks6.gif" alt="MAC 地址"></p><p>首先来看一下 <strong>「MAC地址」</strong>，每台设备都至少拥有一个 <strong>「MAC地址」</strong>，确切地说，应该是每一块网卡都拥有一个 <strong>「MAC地址」</strong>，如果你的机器有多块网卡，那就会拥有多个 <strong>「MAC地址」</strong>。网卡从被生产出来就会被烧录一个永久的 <strong>「MAC地址」。</strong></p><p>这非常类似于烙印在动物身上的标记，主要是为了方便我们快速寻找并确认这头羊是不是我的，是我的第几头羊……扯远了，回过头来，<strong>「MAC地址」</strong> 就是烙印在网卡上的标记，且可以保证的是，每个 <strong>「MAC地址」</strong> 都是唯一的。</p><p><img src="https://img.hi-linux.com/staticfile/f5b3b6c3bd562a28f1af5d696f9bdc0b-2021-03-16-wGJjBj.gif" alt="MAC 寻址并发送信息"></p><p>在同一网络中，当一台设备想要快速找到另一台设备，可以通过该地址来寻找，因为 <strong>「MAC地址」</strong> 的唯一性，我们可以轻松的找到目标设备，并将信息精确的发送给它。</p><h3><span id="2ip地址">2.IP地址</span></h3><p><img src="https://img.hi-linux.com/staticfile/129b8d43e31e323d1482fc6f377f151f-2021-03-16-kRNHUE.gif" alt="IP 地址"></p><p>除了 <strong>「MAC地址」</strong>，每台设备同时拥有另一个地址，那就是 <strong>「IP地址」</strong>，改地址并不是烙印在设备上的，而是需要网络管理员来给我们分配。相比较 <strong>「MAC地址」</strong> 又长又无规律的特点，<strong>「IP地址」</strong> 显得相对容易记忆，大家可能会问，都已经有一个「MAC 地址 」了，为什么还要用「IP 地址」呢？</p><p>这里我们要考虑一个问题，目前全球有 60 多亿人，如果每个人都拥有一台设备，那就意味着我们拥有 60亿个 <strong>「MAC地址」</strong>，这是一个庞大的 <strong>「MAC地址库」</strong>，在这样庞大的库中查找具体的某一个设备无异于大海捞针。</p><p><img src="https://img.hi-linux.com/staticfile/0ad479635eb0798b0b2dfb7853255fca-2021-03-16-yLWu1i.gif" alt="IP 寻址并发送信息"></p><p>所以 <strong>「MAC地址」</strong> 通常都用于局部网络中的设备查找，而 <strong>「IP地址」</strong> 因为由管理员分配，这意味着每个国家，每个地区，每个城市的「IP地址」都有具体分配的 <strong>「IP地址段」</strong>，这就很方便我们查找了，当我们想要给一个异国他乡的亲友发送信息时，只需要先来确定它的 <strong>「IP地址」</strong> 所在地区，然后再具体查找它的设备，这将变得非常容易。</p><h3><span id="3网络寻址">3.网络寻址</span></h3><p><img src="https://img.hi-linux.com/staticfile/927e9f7bb99a48428d1b5803b3068fdc-2021-03-16-wam8yc.gif" alt="两个局域网连接"></p><p>举个例子，当一个公司的规模越来越大，分公司必然会出现，这种情况下会出现多个网络区域，此时我们需要将两个网络通过路由器连接在一起，这个路由器同时属于两个局域网LAN的一部分，它的工作就是将一个网段的信息传递到另一个网段。</p><p>通过刚才的学习，我们都知道了，MAC地址是用于本地局域网中的地址，因此，当我们想要把一段打印信息发送给另一个网段的打印机时，仅仅使用MAC地址就不够用了，此时我们就可以通过IP地址来定位打印机所处的位置。</p><p><img src="https://img.hi-linux.com/staticfile/1b93b0d809a4a4c659e60ec9d9bcc3e3-2021-03-16-QHiFsP.gif" alt="IP 地址的工作流程"></p><p>我们看一下具体的工作流程，当一个网段中的电脑准备好了要传递给打印机打印信息，我们的电脑会在这段消息上追加一个 <strong>「IP地址」</strong>，这个 <strong>「IP地址」</strong> 就是打印机的 <strong>「IP地址」</strong>。同时，因为该打印机在另一段网络，所以，电脑又在该信息上追加了路由器的 <strong>「MAC地址」</strong>，先找到路由器，路由器接到信息后把这个 <strong>「MAC地址」</strong> 更改成打印机的 <strong>「MAC地址」</strong>，接着，就可以精确的将该信息传递给打印机。</p><h3><span id="总结">总结</span></h3><ol><li>主机都同时拥有一个MAC地址和一个IP地址</li><li>MAC地址常用于一个局域网络</li><li>IP地址可以可以在本地的网段使用，同样可以再其他网段使用</li></ol><h3><span id="问题">问题</span></h3><ol><li>谁把Mac地址分配给计算机？一台计算机有多少个Mac地址？</li><li>要在本地网段中发送消息，是否需要IP地址？</li></ol><h3><span id="结语">结语</span></h3><p>如果你觉得文章很棒，可以转发，评论该文章；如果文章有问题，请留言或私信告诉我，我会在第一时间对内容进行调整，这将会帮助每一位想要学习网络基础的小伙伴，感谢！抱拳！</p><h4><span id="原作者">原作者：</span></h4><ul><li>原文作者：Network Direction</li><li>链接地址：<a href="https://www.youtube.com/watch?v=v8aYhOxZuNg&amp;list=PLDQaRcbiSnqF5U8ffMgZzS7fq1rHUI3Q8&amp;index=16&amp;t=28s" target="_blank" rel="noopener">点击查看</a></li></ul><blockquote><p>本文转载自：「 少数派 」，原文：<a href="https://sspai.com/post/64640" target="_blank" rel="noopener">https://sspai.com/post/64640</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;欢迎来到网络世界，《小白也能看懂的网络基础》系列文章会从零开始帮助你构建网络的基础知识。如果你完全没有接触过网络相关的内容，那我们是一样的，在学习过程中我们肯定遇到了相同的问题！写下这些文章一方面要记录自己的学习历程，另一方面也希望帮到同样想要学习网络基础的小伙伴。&lt;/p&gt;
&lt;p&gt;文章的部分内容与素材是我从【Youtube平台】的【&lt;a href=&quot;https://www.youtube.com/channel/UCtuXekfqj-paqsxtqVNCC2A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Network Direction&lt;/a&gt;】发布的系列视频学习和搜集过来的，翻译不易，部分内容可能无法做到尽善尽美，甚至可能会有部分瑕疵，我会尽力让文章内容通俗易懂，覆盖全面。若各位小伙伴发现任何问题，希望能够留言或私信告诉我，在下不胜感激！当然，我也会在第一时间进行更正。&lt;/p&gt;
&lt;p&gt;在往后的每一篇文章中，我都会把看到文章的小伙伴当成是完全没有网络经验的小白，我的目标是和零基础小白一起建立坚实的网络基础，网络大神请略过此系列文章。&lt;/p&gt;
&lt;p&gt;让我们开始网络之旅吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="https://www.hi-linux.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="网络" scheme="https://www.hi-linux.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你给 Kubernetes Dashboard 增加用户名密码认证功能</title>
    <link href="https://www.hi-linux.com/posts/7928.html"/>
    <id>https://www.hi-linux.com/posts/7928.html</id>
    <published>2021-05-20T01:00:00.000Z</published>
    <updated>2021-05-20T01:22:08.887Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>仪表板是基于 <code>Web</code> 的 <code>Kubernetes</code> 用户界面。您可以使用仪表板将容器化应用程序部署到 <code>Kubernetes</code> 集群，对容器化应用程序进行故障排除，并管理集群本身及其伴随资源。您可以使用仪表板来概述群集上运行的应用程序，以及创建或修改单个 <code>Kubernetes</code> 资源。</p><p><img src="https://img.hi-linux.com/staticfile/use-name-passwd-login-dashborad-2021-04-15-evt2DM.png" alt="Dashboard开启用户名密码登录"></p><p>通过 <code>yaml</code> 文件默认安装完 <code>k8s</code> 集群和 <code>Dashboard</code> 服务之后，都是使用 <strong><code>token</code></strong> 或者 <strong><code>Kubeconfig</code> 文件</strong> 来登录的，这样使用起来比较安全。但是如果我们部署的是测试或者实验环境的话，每次都要输入一长串的 <code>token</code> 还是很方便的。所以，这里我们介绍如何使用 <strong>用户名和密码</strong> 的方式来登录 <code>Dashboard</code> 服务。</p><table><thead><tr><th style="text-align:left">集群环境</th><th style="text-align:left">集群版本</th><th style="text-align:left">搭建方式</th><th style="text-align:left">dashboard 的版本</th></tr></thead><tbody><tr><td style="text-align:left">master</td><td style="text-align:left">v1.20.4</td><td style="text-align:left">kubeadm</td><td style="text-align:left">dashboard:v2.0.4</td></tr><tr><td style="text-align:left">node01</td><td style="text-align:left">v1.20.4</td><td style="text-align:left">kubeadm</td><td style="text-align:left">dashboard:v2.0.4</td></tr><tr><td style="text-align:left">node02</td><td style="text-align:left">v1.20.4</td><td style="text-align:left">kubeadm</td><td style="text-align:left">dashboard:v2.0.4</td></tr></tbody></table><ul><li>创建用户文件<ul><li>格式：<code>user</code>、<code>password</code>、<code>userID</code>、<code>&quot;group1,group2&quot;</code></li><li>注意：<code>userID</code> 不可重复</li></ul></li></ul><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户名密码配置文件</span></span><br><span class="line"><span class="comment"># 在所有的master节点配置用户名密码</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'admin,admin,1'</span> | sudo tee /etc/kubernetes/pki/basic_auth_file</span><br></pre></td></tr></table></figure><ul><li>修改配置文件<ul><li>将上述创建好的用户名密码文件添加到下述文件中</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置修改</span></span><br><span class="line">$ sudo vim /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - <span class="built_in">command</span>:</span><br><span class="line">    - kube-apiserver</span><br><span class="line">    - --advertise-address=192.168.30.30</span><br><span class="line">    - --basic-auth-file=/etc/kubernetes/pki/basic_auth_file</span><br><span class="line">    ......</span><br><span class="line">  volumeMounts:</span><br><span class="line">  – mountPath: /etc/kubernetes/basic_auth_file</span><br><span class="line">    name: basic-auth-file</span><br><span class="line">    readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">  – hostPath:</span><br><span class="line">    name: basic-auth-file</span><br><span class="line">      path: /etc/kubernetes/basic_auth_file</span><br></pre></td></tr></table></figure><ul><li>重启 apiserver 服务<ul><li>使刚才的修改生效</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启</span></span><br><span class="line">$ kubectl apply -f /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">$ kubectl get pod -n kube-system | grep apiserver</span><br><span class="line">kube-apiserver-k8s-01            1/1     Running   0          24s</span><br><span class="line">kube-apiserver-k8s-02            1/1     Running   0          44s</span><br><span class="line">kube-apiserver-k8s-03            1/1     Running   0          50s</span><br></pre></td></tr></table></figure><ul><li>将用户与权限绑定<ul><li>创建集群 <code>admin</code> 角色绑定</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 权限绑定</span></span><br><span class="line">$ kubectl create clusterrolebinding \</span><br><span class="line">    login-on-dashboard-with-cluster-admin \</span><br><span class="line">    --clusterrole=cluster-admin --user=admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看绑定</span></span><br><span class="line">$ kubectl get clusterrolebinding login-on-dashboard-with-cluster-admin</span><br><span class="line">NAME                                    ROLE                        AGE</span><br><span class="line">login-on-dashboard-with-cluster-admin   ClusterRole/cluster-admin   2m23s</span><br></pre></td></tr></table></figure><ul><li>开启 basic 配置<ul><li>修改 <code>kubernetes-dashboard.yaml</code> 配置文件</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim kubernetes-dashboard.yaml</span><br><span class="line">args:</span><br><span class="line">  - --auto-generate-certificates</span><br><span class="line">  - --namespace=kubernetes-dashboard</span><br><span class="line">  - --token-ttl=43200 <span class="comment"># 过期秒数</span></span><br><span class="line">  - --authentication-mode=basic <span class="comment"># 启用basic登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">$ kubectl apply -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><ul><li>登录验证<ul><li>使用用户名和密码登录 <code>Dashboard</code> 服务</li></ul></li></ul><p><img src="https://www.escapelife.site/images/use-name-passwd-login-dashborad-01.png" alt="Dashboard开启用户名密码登录"></p><blockquote><p>本文转载自：「 Ecsape 的博客 」，原文：<a href="http://t.cn/A6c6nQfG" target="_blank" rel="noopener">http://t.cn/A6c6nQfG</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;仪表板是基于 &lt;code&gt;Web&lt;/code&gt; 的 &lt;code&gt;Kubernetes&lt;/code&gt; 用户界面。您可以使用仪表板将容器化应用程序部署到 &lt;code&gt;Kubernetes&lt;/code&gt; 集群，对容器化应用程序进行故障排除，并管理集群本身及其伴随资源。您可以使用仪表板来概述群集上运行的应用程序，以及创建或修改单个 &lt;code&gt;Kubernetes&lt;/code&gt; 资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/use-name-passwd-login-dashborad-2021-04-15-evt2DM.png&quot; alt=&quot;Dashboard开启用户名密码登录&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;yaml&lt;/code&gt; 文件默认安装完 &lt;code&gt;k8s&lt;/code&gt; 集群和 &lt;code&gt;Dashboard&lt;/code&gt; 服务之后，都是使用 &lt;strong&gt;&lt;code&gt;token&lt;/code&gt;&lt;/strong&gt; 或者 &lt;strong&gt;&lt;code&gt;Kubeconfig&lt;/code&gt; 文件&lt;/strong&gt; 来登录的，这样使用起来比较安全。但是如果我们部署的是测试或者实验环境的话，每次都要输入一长串的 &lt;code&gt;token&lt;/code&gt; 还是很方便的。所以，这里我们介绍如何使用 &lt;strong&gt;用户名和密码&lt;/strong&gt; 的方式来登录 &lt;code&gt;Dashboard&lt;/code&gt; 服务。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;集群环境&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;集群版本&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;搭建方式&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;dashboard 的版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;master&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;v1.20.4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;kubeadm&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;dashboard:v2.0.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;node01&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;v1.20.4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;kubeadm&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;dashboard:v2.0.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;node02&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;v1.20.4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;kubeadm&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;dashboard:v2.0.4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;创建用户文件
&lt;ul&gt;
&lt;li&gt;格式：&lt;code&gt;user&lt;/code&gt;、&lt;code&gt;password&lt;/code&gt;、&lt;code&gt;userID&lt;/code&gt;、&lt;code&gt;&amp;quot;group1,group2&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意：&lt;code&gt;userID&lt;/code&gt; 不可重复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>万字总结，Redis 性能问题排查解决手册（强烈建议收藏）</title>
    <link href="https://www.hi-linux.com/posts/54695.html"/>
    <id>https://www.hi-linux.com/posts/54695.html</id>
    <published>2021-05-18T01:00:00.000Z</published>
    <updated>2021-05-18T06:15:32.878Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="阅读目录">阅读目录</span></h2><ol><li>性能相关的数据指标</li><li>内存使用率used_memory</li><li>命令处理总数total_commands_processed</li><li>延迟时间</li><li>内存碎片率</li><li>回收key</li><li>总结</li></ol><h2><span id="性能相关的数据指标">性能相关的数据指标</span></h2><p>通过Redis-cli命令行界面访问到Redis服务器，然后使用info命令获取所有与Redis服务相关的信息。通过这些信息来分析文章后面提到的一些性能指标。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134751769-2021-05-18-Y5iyDV.png" alt></p><p>info命令输出的数据可分为10个类别，分别是：</p><ul><li>server</li><li>clients</li><li>memory</li><li>persistence</li><li>stats</li><li>replication</li><li>cpu</li><li>commandstats</li><li>cluster</li><li>keyspace</li></ul><p>这篇主要介绍比较重要的2部分性能指标memory和stats。</p><p>需要注意的是info命令返回的信息，并没有命令响应延迟相关的数据信息，所以后面会详细介绍怎么获取与延迟相关的数据指标。</p><a id="more"></a><p>倘若你觉得info输出的信息太多并且杂乱无章，可以指定info命令的参数来获取单个分类下的数据。比如输入info memory命令，会只返回与内存相关的数据。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134817564-2021-05-18-EtD7Ca.png" alt></p><p>为了快速定位并解决性能问题，这里选择5个关键性的数据指标，它包含了大多数人在使用Redis上会经常碰到的性能问题。</p><h2><span id="内存使用率used_memory">内存使用率used_memory</span></h2><p>上图中used_memory 字段数据表示的是：由Redis分配器分配的内存总量，以字节（byte）为单位。其中used_memory_human上的数据和used_memory是一样的值，它以M为单位显示，仅为了方便阅读。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134824172-2021-05-18-6SNalM.png" alt></p><p>used_memory是Redis使用的内存总量，它包含了实际缓存占用的内存和Redis自身运行所占用的内存(如元数据、lua)。它是由Redis使用内存分配器分配的内存，所以这个数据并没有把内存碎片浪费掉的内存给统计进去。</p><p>其他字段代表的含义，都以字节为单位：</p><ul><li>used_memory_rss：从操作系统上显示已经分配的内存总量。</li><li>mem_fragmentation_ratio：内存碎片率。</li><li>used_memory_lua：Lua脚本引擎所使用的内存大小。</li><li>mem_allocator：在编译时指定的Redis使用的内存分配器，可以是libc、jemalloc、tcmalloc。</li></ul><h3><span id="因内存交换引起的性能问题">因内存交换引起的性能问题</span></h3><p>内存使用率是Redis服务最关键的一部分。如果一个Redis实例的内存使用率超过可用最大内存 (used_memory &gt; 可用最大内存)，那么操作系统开始进行内存与swap空间交换，把内存中旧的或不再使用的内容写入硬盘上（硬盘上的这块空间叫Swap分区），以便腾出新的物理内存给新页或活动页(page)使用。</p><p>在硬盘上进行读写操作要比在内存上进行读写操作，时间上慢了近5个数量级，内存是0.1μs单位、而硬盘是10ms。如果Redis进程上发生内存交换，那么Redis和依赖Redis上数据的应用会受到严重的性能影响。</p><p>通过查看used_memory指标可知道Redis正在使用的内存情况，如果used_memory&gt;可用最大内存，那就说明Redis实例正在进行内存交换或者已经内存交换完毕。管理员根据这个情况，执行相对应的应急措施。</p><h3><span id="跟踪内存使用率">跟踪内存使用率</span></h3><p>若是在使用Redis期间没有开启rdb快照或aof持久化策略，那么缓存数据在Redis崩溃时就有丢失的危险。因为当Redis内存使用率超过可用内存的95%时，部分数据开始在内存与swap空间来回交换，这时就可能有丢失数据的危险。</p><p>当开启并触发快照功能时，Redis会fork一个子进程把当前内存中的数据完全复制一份写入到硬盘上。因此若是当前使用内存超过可用内存的45%时触发快照功能，那么此时进行的内存交换会变的非常危险(可能会丢失数据)。倘若在这个时候实例上有大量频繁的更新操作，问题会变得更加严重。</p><p>通过减少Redis的内存占用率，来避免这样的问题，或者使用下面的技巧来避免内存交换发生：</p><ol><li>假如缓存数据小于4GB，就使用32位的Redis实例</li></ol><p>因为32位实例上的指针大小只有64位的一半，它的内存空间占用空间会更少些。这有一个坏处就是，假设物理内存超过4GB，那么32位实例能使用的内存仍然会被限制在4GB以下。</p><p>要是实例同时也共享给其他一些应用使用的话，那可能需要更高效的64位Redis实例，这种情况下切换到32位是不可取的。不管使用哪种方式，Redis的dump文件在32位和64位之间是互相兼容的， 因此倘若有减少占用内存空间的需求，可以尝试先使用32位，后面再切换到64位上。</p><ol start="2"><li>尽可能的使用Hash数据结构</li></ol><p>因为Redis在储存小于100个字段的Hash结构上，其存储效率是非常高的。所以在不需要集合(set)操作或list的push/pop操作的时候，尽可能的使用Hash结构。比如，在一个web应用程序中，需要存储一个对象表示用户信息，使用单个key表示一个用户，其每个属性存储在Hash的字段里，这样要比给每个属性单独设置一个key-value要高效的多。</p><p>通常情况下倘若有数据使用string结构，用多个key存储时，那么应该转换成单key多字段的Hash结构。如上述例子中介绍的Hash结构应包含，单个对象的属性或者单个用户各种各样的资料。Hash结构的操作命令是HSET(key, fields, value)和HGET(key, field)，使用它可以存储或从Hash中取出指定的字段。</p><ol start="3"><li>设置key的过期时间</li></ol><p>一个减少内存使用率的简单方法就是，每当存储对象时确保设置key的过期时间。倘若key在明确的时间周期内使用或者旧key不大可能被使用时，就可以用Redis过期时间命令(expire,expireat, pexpire, pexpireat)去设置过期时间，这样Redis会在key过期时自动删除key。</p><p>假如你知道每秒钟有多少个新key-value被创建，那可以调整key的存活时间，并指定阀值去限制Redis使用的最大内存。</p><ol start="4"><li>回收key</li></ol><p>在Redis配置文件中(一般叫Redis.conf)，通过设置“maxmemory”属性的值可以限制Redis最大使用的内存，修改后重启实例生效。</p><p>也可以使用客户端命令config set maxmemory 去修改值，这个命令是立即生效的，但会在重启后会失效，需要使用config rewrite命令去刷新配置文件。</p><p>若是启用了Redis快照功能，应该设置“maxmemory”值为系统可使用内存的45%，因为快照时需要一倍的内存来复制整个数据集，也就是说如果当前已使用45%，在快照期间会变成95%(45%+45%+5%)，其中5%是预留给其他的开销。如果没开启快照功能，maxmemory最高能设置为系统可用内存的95%。</p><p>当内存使用达到设置的最大阀值时，需要选择一种key的回收策略，可在Redis.conf配置文件中修改“maxmemory-policy”属性值。若是Redis数据集中的key都设置了过期时间，那么“volatile-ttl”策略是比较好的选择。</p><p>但如果key在达到最大内存限制时没能够迅速过期，或者根本没有设置过期时间。那么设置为“allkeys-lru”值比较合适，它允许Redis从整个数据集中挑选最近最少使用的key进行删除(LRU淘汰算法)。Redis还提供了一些其他淘汰策略，如下：</p><ul><li>volatile-lru：使用LRU算法从已设置过期时间的数据集合中淘汰数据。</li><li>volatile-ttl：从已设置过期时间的数据集合中挑选即将过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集合中随机挑选数据淘汰。</li><li>allkeys-lru：使用LRU算法从所有数据集合中淘汰数据。</li><li>allkeys-random：从数据集合中任意选择数据淘汰</li><li>no-enviction：禁止淘汰数据。</li></ul><p>通过设置maxmemory为系统可用内存的45%或95%(取决于持久化策略)和设置“maxmemory-policy”为“volatile-ttl”或“allkeys-lru”(取决于过期设置)，可以比较准确的限制Redis最大内存使用率，在绝大多数场景下使用这2种方式可确保Redis不会进行内存交换。倘若你担心由于限制了内存使用率导致丢失数据的话，可以设置noneviction值禁止淘汰数据。</p><h2><span id="命令处理数-total_commands_processed">命令处理数 total_commands_processed</span></h2><p>在info信息里的total_commands_processed字段显示了Redis服务处理命令的总数，其命令都是从一个或多个Redis客户端请求过来的。Redis每时每刻都在处理从客户端请求过来的命令，它可以是Redis提供的140种命令的任意一个。</p><p>total_commands_processed字段的值是递增的，比如Redis服务分别处理了client_x请求过来的2个命令和client_y请求过来的3个命令，那么命令处理总数(total_commands_processed)就会加上5。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518133455574-2021-05-18-VcSVHk.png" alt></p><h3><span id="分析命令处理总数诊断响应延迟">分析命令处理总数，诊断响应延迟</span></h3><p>在Redis实例中，跟踪命令处理总数是解决响应延迟问题最关键的部分，因为Redis是个单线程模型，客户端过来的命令是按照顺序执行的。比较常见的延迟是带宽，通过千兆网卡的延迟大约有200μs。倘若明显看到命令的响应时间变慢，延迟高于200μs，那可能是Redis命令队列里等待处理的命令数量比较多。</p><p>如上所述，延迟时间增加导致响应时间变慢可能是由于一个或多个慢命令引起的，这时可以看到每秒命令处理数在明显下降，甚至于后面的命令完全被阻塞，导致Redis性能降低。要分析解决这个性能问题，需要跟踪命令处理数的数量和延迟时间。</p><p>比如可以写个脚本，定期记录 total_commands_processed 的值。当客户端明显发现响应时间过慢时，可以通过记录的 total_commands_processed 历史数据值来判断命理处理总数是上升趋势还是下降趋势，以便排查问题。</p><h3><span id="使用命令处理总数解决延迟时间增加">使用命令处理总数解决延迟时间增加</span></h3><p>通过与记录的历史数据比较得知，命令处理总数确实是处于上升或下降状态，那么可能是有2个原因引起的:</p><ul><li>命令队列里的命令数量过多，后面命令一直在等待中。</li><li>几个慢命令阻塞Redis。</li></ul><p>下面有三个办法可以解决，因上面2条原因引起的响应延迟问题。</p><ol><li>使用多参数命令</li></ol><p>若是客户端在很短的时间内发送大量的命令过来，会发现响应时间明显变慢，这由于后面命令一直在等待队列中前面大量命令执行完毕。有个方法可以改善延迟问题，就是通过单命令多参数的形式取代多命令单参数的形式。</p><p>举例来说，循环使用LSET命令去添加1000个元素到list结构中，是性能比较差的一种方式，更好的做法是在客户端创建一个1000元素的列表，用单个命令LPUSH或RPUSH，通过多参数构造形式一次性把1000个元素发送的Redis服务上。下面的表格是Redis的一些操作命令，有单个参数命令和支持多个参数的命令，通过这些命令可尽量减少使用多命令的次数。                                             <img src="https://img.hi-linux.com/staticfile/640-20210518134848518-2021-05-18-4aq6rE.png" alt></p><ol start="2"><li>管道命令</li></ol><p>另一个减少多命令的方法是使用管道(pipeline)，把几个命令合并一起执行，从而减少因网络开销引起的延迟问题。因为10个命令单独发送到服务端会引起10次网络延迟开销，使用管道会一次性把执行结果返回，仅需要一次网络延迟开销。Redis本身支持管道命令，大多数客户端也支持，倘若当前实例延迟很明显，那么使用管道去降低延迟是非常有效的。</p><ol start="3"><li>避免操作大集合的慢命令</li></ol><p>如果命令处理频率过低导致延迟时间增加，这可能是因为使用了高时间复杂度的命令操作导致，这意味着每个命令从集合中获取数据的时间增大。</p><p>所以减少使用高时间复杂的命令，能显著的提高的Redis的性能。下面的表格是高时间复杂度命令的列表，其详细描述了命令的属性，有这助于高效合理的、最优化的使用这些命令(如果不得不使用的话)，以提高Redis性能。</p><p><img src="https://img.hi-linux.com/staticfile/640-2021-05-18-U0h99k.jpg" alt></p><h2><span id="延迟时间">延迟时间</span></h2><p>Redis的延迟数据是无法从info信息中获取的。倘若想要查看延迟时间，可以用 Redis-cli工具加–latency参数运行，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis-cli --latency -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure><p>其host和port是Redis实例的ip及端口。由于当前服务器不同的运行情况，延迟时间可能有所误差，通常1G网卡的延迟时间是200μs。</p><p>以毫秒为单位测量Redis的响应延迟时间，楼主本机的延迟是300μs：</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518133700583-2021-05-18-xKRykn.png" alt></p><h3><span id="跟踪redis延迟性能">跟踪Redis延迟性能</span></h3><p>Redis之所以这么流行的主要原因之一就是低延迟特性带来的高性能，所以说解决延迟问题是提高Redis性能最直接的办法。拿1G带宽来说，若是延迟时间远高于200μs，那明显是出现了性能问题。</p><p>虽然在服务器上会有一些慢的IO操作，但Redis是单核接受所有客户端的请求，所有请求是按良好的顺序排队执行。因此若是一个客户端发过来的命令是个慢操作，那么其他所有请求必须等待它完成后才能继续执行。</p><h3><span id="使用延迟命令提高性能">使用延迟命令提高性能</span></h3><p>一旦确定延迟时间是个性能问题后，这里有几个办法可以用来分析解决性能问题。</p><ol><li>使用 slowlog 查出引发延迟的慢命令</li></ol><p>Redis中的slowlog命令可以让我们快速定位到那些超出指定执行时间的慢命令，默认情况下命令若是执行时间超过10ms就会被记录到日志。slowlog只会记录其命令执行的时间，不包含io往返操作，也不记录单由网络延迟引起的响应慢。</p><p>通常1gb带宽的网络延迟，预期在200μs左右，倘若一个命令仅执行时间就超过10ms，那比网络延迟慢了近50倍。想要查看所有执行时间比较慢的命令，可以通过使用Redis-cli工具，输入slowlog get命令查看，返回结果的第三个字段以微妙位单位显示命令的执行时间。</p><p>假如只需要查看最后10个慢命令，输入slowlog get 10即可。关于怎么定位到是由慢命令引起的延迟问题，可查看total_commands_processed介绍章节。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134858745-2021-05-18-EHBvbl.png" alt></p><p>图中字段分别意思是：</p><ul><li>1=日志的唯一标识符</li><li>2=被记录命令的执行时间点，以 UNIX 时间戳格式表示</li><li>3=查询执行时间，以微秒为单位。例子中命令使用54毫秒。</li><li>4= 执行的命令，以数组的形式排列。完整命令是config get *。</li></ul><p>倘若你想自定义慢命令的标准，可以调整触发日志记录慢命令的阀值。若是很少或没有命令超过10ms，想降低记录的阀值，比如5毫秒，可在Redis-cli工具中输入下面的命令配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set slowlog-log-slower-than 5000</span><br></pre></td></tr></table></figure><p>也可以在Redis.config配置文件中设置，以微妙位单位。</p><ol start="2"><li>监控客户端的连接</li></ol><p>因为Redis是单线程模型(只能使用单核)，来处理所有客户端的请求， 但由于客户端连接数的增长，处理请求的线程资源开始降低分配给单个客户端连接的处理时间，这时每个客户端需要花费更多的时间去等待Redis共享服务的响应。</p><p>这种情况下监控客户端连接数是非常重要的，因为客户端创建连接数的数量可能超出预期的数量，也可能是客户端端没有有效的释放连接。在Redis-cli工具中输入info clients可以查看到当前实例的所有客户端连接信息。</p><p>如下图，第一个字段(connected_clients)显示当前实例客户端连接的总数：</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518133148021-2021-05-18-kgCwYv.png" alt></p><p>Redis默认允许客户端连接的最大数量是10000。若是看到连接数超过5000以上，那可能会影响Redis的性能。倘若一些或大部分客户端发送大量的命令过来，这个数字会低的多。</p><ol start="3"><li>限制客户端连接数</li></ol><p>自 Redis 2.6 以后，允许使用者在配置文件(Redis.conf)maxclients属性上修改客户端连接的最大数，也可以通过在 Redis-cli 工具上输入 config set maxclients 去设置最大连接数。</p><p>根据连接数负载的情况，这个数字应该设置为预期连接数峰值的110%到150之间，若是连接数超出这个数字后，Redis会拒绝并立刻关闭新来的连接。通过设置最大连接数来限制非预期数量的连接数增长，是非常重要的。</p><p>另外，新连接尝试失败会返回一个错误消息，这可以让客户端知道，Redis此时有非预期数量的连接数，以便执行对应的处理措施。上述二种做法对控制连接数的数量和持续保持Redis的性能最优是非常重要的，</p><ol start="4"><li>加强内存管理</li></ol><p>较少的内存会引起Redis延迟时间增加。如果Redis占用内存超出系统可用内存，操作系统会把Redis进程的一部分数据，从物理内存交换到硬盘上，内存交换会明显的增加延迟时间。关于怎么监控和减少内存使用，可查看used_memory介绍章节。</p><ol start="5"><li>性能数据指标</li></ol><p>分析解决Redis性能问题，通常需要把延迟时间的数据变化与其他性能指标的变化相关联起来。命令处理总数下降的发生可能是由慢命令阻塞了整个系统，但如果命令处理总数的增加，同时内存使用率也增加，那么就可能是由于内存交换引起的性能问题。</p><p>对于这种性能指标相关联的分析，需要从历史数据上来观察到数据指标的重要变化，此外还可以观察到单个性能指标相关联的所有其他性能指标信息。这些数据可以在Redis上收集，周期性的调用内容为Redis info的脚本，然后分析输出的信息，记录到日志文件中。当延迟发生变化时，用日志文件配合其他数据指标，把数据串联起来排查定位问题。</p><h2><span id="内存碎片率">内存碎片率</span></h2><p>info信息中的 mem_fragmentation_ratio 给出了内存碎片率的数据指标，它是由操系统分配的内存除以Redis分配的内存得出：</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134928605-2021-05-18-wiJNx3.png" alt></p><p>used_memory和used_memory_rss数字都包含的内存分配有：</p><ul><li>用户定义的数据：内存被用来存储key-value值。</li><li>内部开销：存储内部Redis信息用来表示不同的数据类型。</li></ul><p>used_memory_rss的rss是Resident Set Size的缩写，表示该进程所占物理内存的大小，是操作系统分配给Redis实例的内存大小。除了用户定义的数据和内部开销以外，used_memory_rss指标还包含了内存碎片的开销，内存碎片是由操作系统低效的分配/回收物理内存导致的。</p><p>操作系统负责分配物理内存给各个应用进程，Redis使用的内存与物理内存的映射是由操作系统上虚拟内存管理分配器完成的。</p><p>举个例子来说，Redis需要分配连续内存块来存储1G的数据集，这样的话更有利，但可能物理内存上没有超过1G的连续内存块，那操作系统就不得不使用多个不连续的小内存块来分配并存储这1G数据，也就导致内存碎片的产生。</p><p>内存分配器另一个复杂的层面是，它经常会预先分配一些内存块给引用，这样做会使加快应用程序的运行。</p><h3><span id="理解资源性能">理解资源性能</span></h3><p>跟踪内存碎片率对理解Redis实例的资源性能是非常重要的。内存碎片率稍大于1是合理的，这个值表示内存碎片率比较低，也说明redis没有发生内存交换。但如果内存碎片率超过1.5，那就说明Redis消耗了实际需要物理内存的150%，其中50%是内存碎片率。</p><p>若是内存碎片率低于1的话，说明Redis内存分配超出了物理内存，操作系统正在进行内存交换。内存交换会引起非常明显的响应延迟，可查看 used_memory 介绍章节。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518133905109-2021-05-18-aBjwpT.png" alt></p><p>上图中的 0.99 即 99%。</p><h3><span id="用内存碎片率预测性能问题">用内存碎片率预测性能问题</span></h3><p>倘若内存碎片率超过了1.5，那可能是操作系统或Redis实例中内存管理变差的表现。下面有3种方法解决内存管理变差的问题，并提高Redis性能：</p><ol><li>重启Redis服务器</li></ol><p>如果内存碎片率超过1.5，重启Redis服务器可以让额外产生的内存碎片失效并重新作为新内存来使用，使操作系统恢复高效的内存管理。额外碎片的产生是由于Redis释放了内存块，但内存分配器并没有返回内存给操作系统，这个内存分配器是在编译时指定的，可以是libc、jemalloc或者tcmalloc。</p><p>通过比较used_memory_peak, used_memory_rss和used_memory_metrics的数据指标值可以检查额外内存碎片的占用。从名字上可以看出，used_memory_peak是过去Redis内存使用的峰值，而不是当前使用内存的值。</p><p>如果used_memory_peak和used_memory_rss的值大致上相等，而且二者明显超过了used_memory值，这说明额外的内存碎片正在产生。</p><p>在Redis-cli工具上输入info memory可以查看上面三个指标的信息：</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134944908-2021-05-18-tk0wzc.png" alt></p><p>在重启服务器之前，需要在Redis-cli工具上输入shutdown save命令，意思是强制让Redis数据库执行保存操作并关闭Redis服务，这样做能保证在执行Redis关闭时不丢失任何数据。在重启后，Redis会从硬盘上加载持久化的文件，以确保数据集持续可用。</p><ol start="2"><li>限制内存交换</li></ol><p>如果内存碎片率低于1，Redis实例可能会把部分数据交换到硬盘上。内存交换会严重影响Redis的性能，所以应该增加可用物理内存或减少实Redis内存占用。可查看used_memory章节的优化建议。</p><ol start="3"><li>修改内存分配器</li></ol><p>Redis支持glibc’s malloc、jemalloc11、tcmalloc几种不同的内存分配器，每个分配器在内存分配和碎片上都有不同的实现。</p><p>不建议普通管理员修改Redis默认内存分配器，因为这需要完全理解这几种内存分配器的差异，也要重新编译Redis。这个方法更多的是让其了解Redis内存分配器所做的工作，当然也是改善内存碎片问题的一种办法。</p><h2><span id="回收key">回收key</span></h2><p>info信息中的evicted_keys字段显示的是，因为maxmemory限制导致key被回收删除的数量。关于maxmemory的介绍见前面章节，回收key的情况只会发生在设置maxmemory值后，不设置会发生内存交换。当Redis由于内存压力需要回收一个key时，Redis首先考虑的不是回收最旧的数据，而是在最近最少使用的key或即将过期的key中随机选择一个key，从数据集中删除。</p><p>这可以在配置文件中设置maxmemory-policy值为“volatile-lru”或“volatile-ttl”，来确定Redis是使用lru策略还是过期时间策略。倘若所有的key都有明确的过期时间，那过期时间回收策略是比较合适的。若是没有设置key的过期时间或者说没有足够的过期key，那设置lru策略是比较合理的，这可以回收key而不用考虑其过期状态。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210518134952294-2021-05-18-gSRj4a.png" alt></p><h3><span id="根据key回收定位性能问题">根据key回收定位性能问题</span></h3><p>跟踪key回收是非常重要的，因为通过回收key，可以保证合理分配Redis有限的内存资源。如果evicted_keys值经常超过0，那应该会看到客户端命令响应延迟时间增加，因为Redis不但要处理客户端过来的命令请求，还要频繁的回收满足条件的key。</p><p>需要注意的是，回收key对性能的影响远没有内存交换严重，若是在强制内存交换和设置回收策略做一个选择的话，选择设置回收策略是比较合理的，因为把内存数据交换到硬盘上对性能影响非常大(见前面章节)。</p><h3><span id="减少回收key以提升性能">减少回收key以提升性能</span></h3><p>减少回收key的数量是提升Redis性能的直接办法，下面有2种方法可以减少回收key的数量：</p><ol><li>增加内存限制</li></ol><p>倘若开启快照功能，maxmemory 需要设置成物理内存的45%，这几乎不会有引发内存交换的危险。若是没有开启快照功能，设置系统可用内存的95%是比较合理的，具体参考前面的快照和maxmemory限制章节。如果maxmemory的设置是低于45%或95%(视持久化策略)，通过增加maxmemory的值能让Redis在内存中存储更多的key，这能显著减少回收key的数量。</p><p>若是maxmemory已经设置为推荐的阀值后，增加maxmemory限制不但无法提升性能，反而会引发内存交换，导致延迟增加、性能降低。maxmemory的值可以在Redis-cli工具上输入config set maxmemory命令来设置。</p><p>需要注意的是，这个设置是立即生效的，但重启后丢失，需要永久化保存的话，再输入config rewrite命令会把内存中的新配置刷新到配置文件中。</p><ol start="2"><li>对实例进行分片</li></ol><p>分片是把数据分割成合适大小，分别存放在不同的Redis实例上，每一个实例都包含整个数据集的一部分。通过分片可以把很多服务器联合起来存储数据，相当于增加总的物理内存，使其在没有内存交换和回收key的策略下也能存储更多的key。</p><p>假如有一个非常大的数据集，maxmemory已经设置，实际内存使用也已经超过了推荐设置的阀值，那通过数据分片能明显减少key的回收，从而提高Redis的性能。分片的实现有很多种方法，下面是Redis实现分片的几种常见方式：</p><p>a. Hash分片：一个比较简单的方法实现，通过Hash函数计算出key的Hash值，然后值所在范围对应特定的Redis实例。</p><p>b. 代理分片：客户端把请求发送到代理上，代理通过分片配置表选择对应的Redis实例。如Twitter的Twemproxy，豌豆荚的codis。</p><p>c. 一致性Hash分片：参见前面博客</p><blockquote><p><a href="http://www.cnblogs.com/mushroom/p/4472369.html" target="_blank" rel="noopener">http://www.cnblogs.com/mushroom/p/4472369.html</a></p></blockquote><p>d. 虚拟桶分片：</p><blockquote><p><a href="http://www.cnblogs.com/mushroom/p/4542772.html" target="_blank" rel="noopener">http://www.cnblogs.com/mushroom/p/4542772.html</a></p></blockquote><h2><span id="总结">总结</span></h2><p>对于开发者来说，Redis 是个速度非常快的 key-value 内存数据库，并提供了方便的API接口。为了最好最优的使用 Redis，需要理解哪些因素能影响到 Redis 性能，哪些数据指标能帮助我们避免性能陷阱。通过本篇，能理解Redis中的重要性能指标，怎么查看，更重要的是怎么利用这些数据排查解决Redis性能问题。</p><p>本篇博客主要翻译了一电子书的中间15页，电子书地址是</p><blockquote><p><a href="https://www.datadoghq.com/wp-content/uploads/2013/09/Understanding-the-Top-5-Redis-Performance-Metrics.pdf" target="_blank" rel="noopener">https://www.datadoghq.com/wp-content/uploads/2013/09/Understanding-the-Top-5-Redis-Performance-Metrics.pdf</a></p></blockquote><p>楼主翻译水平有限，如有错误之处请多多包涵，也欢迎指出交流，希望本文对大家有所帮助。</p><blockquote><p>本文转载自：「 博客园 」，原文：<a href="http://t.cn/A6Vb0mIY" target="_blank" rel="noopener">http://t.cn/A6Vb0mIY</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;阅读目录&quot;&gt;阅读目录&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;性能相关的数据指标&lt;/li&gt;
&lt;li&gt;内存使用率used_memory&lt;/li&gt;
&lt;li&gt;命令处理总数total_commands_processed&lt;/li&gt;
&lt;li&gt;延迟时间&lt;/li&gt;
&lt;li&gt;内存碎片率&lt;/li&gt;
&lt;li&gt;回收key&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;性能相关的数据指标&quot;&gt;性能相关的数据指标&lt;/h2&gt;
&lt;p&gt;通过Redis-cli命令行界面访问到Redis服务器，然后使用info命令获取所有与Redis服务相关的信息。通过这些信息来分析文章后面提到的一些性能指标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/640-20210518134751769-2021-05-18-Y5iyDV.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;info命令输出的数据可分为10个类别，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;server&lt;/li&gt;
&lt;li&gt;clients&lt;/li&gt;
&lt;li&gt;memory&lt;/li&gt;
&lt;li&gt;persistence&lt;/li&gt;
&lt;li&gt;stats&lt;/li&gt;
&lt;li&gt;replication&lt;/li&gt;
&lt;li&gt;cpu&lt;/li&gt;
&lt;li&gt;commandstats&lt;/li&gt;
&lt;li&gt;cluster&lt;/li&gt;
&lt;li&gt;keyspace&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇主要介绍比较重要的2部分性能指标memory和stats。&lt;/p&gt;
&lt;p&gt;需要注意的是info命令返回的信息，并没有命令响应延迟相关的数据信息，所以后面会详细介绍怎么获取与延迟相关的数据指标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://www.hi-linux.com/categories/Redis/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Redis" scheme="https://www.hi-linux.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现一个支持无限层级泛域名解析的 DNS 服务器 Xip</title>
    <link href="https://www.hi-linux.com/posts/12599.html"/>
    <id>https://www.hi-linux.com/posts/12599.html</id>
    <published>2021-05-17T01:00:00.000Z</published>
    <updated>2021-05-17T02:18:52.381Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="什么是-xipio">什么是 </span></h2><p><code>xip.io</code> 是一个提供通配符 <code>DNS</code> 解析的魔法域名。你可以无需配置，将自定义的任何域名解析到指定的 <code>IP</code> 地址。假设你的 <code>IP</code> 地址是 <code>10.0.0.1</code>，你只需使用 <code>前缀域名+IP地址+xip.io</code> 即可完成相应自定义域名解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.1.xip.io         # 解析到 10.0.0.1</span><br><span class="line">www.10.0.0.2.xip.io     # www 子域解析到 10.0.0.2</span><br><span class="line">mysite.10.0.0.3.xip.io  # mysite 子域解析到 10.0.0.3</span><br><span class="line">foo.bar.10.0.0.4.xip.io # foo.bar 子域解析到 10.0.0.4</span><br></pre></td></tr></table></figure><p><code>xip.io</code> 使用上已经很简单了，如果你想使用自己的域名来实现一个类似 <code>xip.io</code> 同样功能也是很容易的。你只需部署一个 <code>xip.name</code> 的开源软件就可以简单实现了!</p><h2><span id="什么是-xipname">什么是 </span></h2><p><code>xip.name</code> 是受 <code>xip.io</code> 启发，使用 <code>Golang</code> 开发的一个支持通配符的 <code>DNS</code> 服务器。</p><blockquote><p>项目地址：<a href="https://github.com/peterhellberg/xip.name" target="_blank" rel="noopener">https://github.com/peterhellberg/xip.name</a></p></blockquote><p><a href="http://xip.name" target="_blank" rel="noopener">xip.name</a> 也同样提供了一个和 <a href="http://xip.io" target="_blank" rel="noopener">xip.io</a> 类似的公共 DNS 服务，它的使用上和 <code>xip.io</code> 无异。你同样可以直接使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.1.xip.name         # 解析到 10.0.0.1</span><br><span class="line">www.10.0.0.2.xip.name     # www 子域解析到 10.0.0.2</span><br><span class="line">mysite.10.0.0.3.xip.name  # mysite 子域解析到 10.0.0.3</span><br><span class="line">foo.bar.10.0.0.4.xip.name # foo.bar 子域解析到 10.0.0.4</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="xipname-部署教程"> 部署教程</span></h2><p><strong>前置条件：</strong></p><ul><li>一台有公网 <code>IP</code> 并开放 <code>53</code> 端口的服务器</li><li>一个有管理权限的域名</li><li>一个提供支持通配 <code>NS</code> 记录的 <code>DNS</code> 解析服务的帐号</li></ul><h3><span id="安装-xipname">安装 </span></h3><p><code>xip.name</code> 使用 <code>Go</code> 语言开发，通常情况下，安装是很容易的，你只需直接下载并放到相应路径即可使用它。</p><p>由于 <code>xip.name</code> 项目没有直接提供二进制包下载，所以这里我们使用 <code>go</code> 命令进行源码下载后，进行编译安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装 GO 环境</span><br><span class="line">$ yum install -y golang</span><br><span class="line"># 获取、编译代码</span><br><span class="line">$ go get github.com&#x2F;peterhellberg&#x2F;xip.name</span><br><span class="line"># 将编译好的二进制文件放到系统 PATH 路径下</span><br><span class="line">$ cp go&#x2F;bin&#x2F;xip.name &#x2F;usr&#x2F;local&#x2F;bin&#x2F;xip</span><br></pre></td></tr></table></figure><p>安装完成后，我们给 <code>xip.name</code> 增加一个 <code>Systemd</code> 配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt; EOF &gt; &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;xip.service</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;xip</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;xip -ip 0.0.0.0 -fqdn ywzm.org.</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p>注： ExecStart 配置的启动命令的 -fqdn 是用来定义 DNS 服务器要支持的域名，这里设置的是 <a href="http://ywzm.org" target="_blank" rel="noopener">ywzm.org</a>.。你可以根据实际情况进行调整。</p></blockquote><p>一些常规的 <code>xip</code> 服务管理操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 启动 xip</span><br><span class="line">$ systemctl start xip</span><br><span class="line"># 关闭 xip</span><br><span class="line">$ systemctl stop xip</span><br><span class="line"># 重启 xip</span><br><span class="line">$ systemctl restart xip</span><br><span class="line"># 配置开机自启 xip</span><br><span class="line">$ systemctl enable xip</span><br></pre></td></tr></table></figure><h3><span id="配置-dns">配置 DNS</span></h3><p>要成功实现 <code>xip.name</code> 提供的服务，只部署相关程序是不够的。还需要配置你自定义域名的 <code>NS</code> 解析记录，目前国内支持通配 <code>NS</code> 记录的免费 <code>DNS</code> 服务商不多，这里我使用的是阿里云 <code>DNS</code> 解析。</p><p>配置其实也很简单，主要需要配置一个通配的 <code>NS</code> 记录和一个指向 <code>DNS</code> 服务器的 A 记录。</p><p>以我的域名 <a href="http://ywzm.org" target="_blank" rel="noopener">ywzm.org</a> 为例，假设部署 <a href="http://xip.name" target="_blank" rel="noopener">xip.name</a> 服务器的公网 IP 是 <code>11.22.33.44</code>。DNS 就应该增加以下两条解析记录：</p><ul><li>增加一条通配 NS 记录解析到 <a href="http://ns1.ywzm.org" target="_blank" rel="noopener">ns1.ywzm.org</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  ns ns1.ywzm.org</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/image-20210425142336948-2021-04-25-u6uGGL.png" alt></p><ul><li>增加一条 A 记录解析到 11.22.33.44</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ns1.ywzm.org  A  11.22.33.44</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/image-20210425142441740-2021-04-25-6911Td.png" alt></p><p>以上配置好就完成了，看下最终效果吧！</p><p><img src="https://img.hi-linux.com/staticfile/image-20210425142632078-2021-04-25-jrYChV.png" alt></p><p>最后，我们来验证一下吧：</p><p><img src="https://img.hi-linux.com/staticfile/image-20210425145305223-2021-04-25-bk0Kaq.png" alt></p><p>从上面的结果可以看到，我们并未对域名进行任何配置就自动实现了相应解析，是不是很给力呢？有兴趣的同学赶紧用起来吧！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-xip-io&quot;&gt;什么是 &lt;a href=&quot;http://xip.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xip.io&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;xip.io&lt;/code&gt; 是一个提供通配符 &lt;code&gt;DNS&lt;/code&gt; 解析的魔法域名。你可以无需配置，将自定义的任何域名解析到指定的 &lt;code&gt;IP&lt;/code&gt; 地址。假设你的 &lt;code&gt;IP&lt;/code&gt; 地址是 &lt;code&gt;10.0.0.1&lt;/code&gt;，你只需使用 &lt;code&gt;前缀域名+IP地址+xip.io&lt;/code&gt; 即可完成相应自定义域名解析。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10.0.0.1.xip.io         # 解析到 10.0.0.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;www.10.0.0.2.xip.io     # www 子域解析到 10.0.0.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysite.10.0.0.3.xip.io  # mysite 子域解析到 10.0.0.3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo.bar.10.0.0.4.xip.io # foo.bar 子域解析到 10.0.0.4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;xip.io&lt;/code&gt; 使用上已经很简单了，如果你想使用自己的域名来实现一个类似 &lt;code&gt;xip.io&lt;/code&gt; 同样功能也是很容易的。你只需部署一个 &lt;code&gt;xip.name&lt;/code&gt; 的开源软件就可以简单实现了!&lt;/p&gt;
&lt;h2 id=&quot;什么是-xip-name&quot;&gt;什么是 &lt;a href=&quot;http://xip.name&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xip.name&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;xip.name&lt;/code&gt; 是受 &lt;code&gt;xip.io&lt;/code&gt; 启发，使用 &lt;code&gt;Golang&lt;/code&gt; 开发的一个支持通配符的 &lt;code&gt;DNS&lt;/code&gt; 服务器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/peterhellberg/xip.name&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/peterhellberg/xip.name&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://xip.name&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xip.name&lt;/a&gt; 也同样提供了一个和 &lt;a href=&quot;http://xip.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xip.io&lt;/a&gt; 类似的公共 DNS 服务，它的使用上和 &lt;code&gt;xip.io&lt;/code&gt; 无异。你同样可以直接使用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10.0.0.1.xip.name         # 解析到 10.0.0.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;www.10.0.0.2.xip.name     # www 子域解析到 10.0.0.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysite.10.0.0.3.xip.name  # mysite 子域解析到 10.0.0.3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo.bar.10.0.0.4.xip.name # foo.bar 子域解析到 10.0.0.4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="DNS" scheme="https://www.hi-linux.com/categories/DNS/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>你在拥有「加密货币」前，必须要搞清楚的事</title>
    <link href="https://www.hi-linux.com/posts/6273.html"/>
    <id>https://www.hi-linux.com/posts/6273.html</id>
    <published>2021-05-13T01:00:00.000Z</published>
    <updated>2021-05-13T07:46:27.256Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>相对于通过数字货币的获利、区块链的技术原理，如果你更想了解如何拥有自己的加密货币、不同的<strong>加密货币有何区别</strong>、加密货币的<strong>应用场景</strong>，或是<strong>参与到加密货币</strong>的洪流里来，希望本文能够给到一定帮助。文中个别链接需要在特殊网络环境下访问。需要注意，<strong>本文不具有任何投资建议</strong>。</p><p>和历年来科技上大部分的新技术不同，区块链技术在给大众生活带来显著正面影响之前，就已经带来了显著又负面的大范围影响——显卡涨价。而在本文编辑的这段时间里，热度旺盛的 Chia 币因为其需要通过硬盘参与挖矿，导致了大容量硬盘继显卡后成为了下一个「受害者」。</p><a id="more"></a><p>由此很多人莫名其妙进入了这挖矿狂潮的辐射范围内，一些人开始通过抢购、倒卖显卡、组装矿机挖矿、囤积硬盘等等形式从中获利，甚至有网吧老板关门挖矿。区块链技术和比特币就以这样的方式「火」了起来。</p><p><img src="https://img.hi-linux.com/staticfile/1-2021-05-13-njL8AJ.png" alt="官网标注售价 3899 元起的显卡 RTX 3070 如今在京东随手一搜就是 11000+ 元的售价"></p><h2><span id="那些陌生的名词">那些陌生的名词</span></h2><p>以下挑选下文中出现的几个相对陌生的名词，仅以不影响阅读体验的最低程度展开介绍。想要更精准全面地了解相关名词需要另外查阅。</p><h3><span id="公有链"><strong>公有链</strong></span></h3><blockquote><p>公有链是指全世界任何人都可读取、发送交易且交易能获得有效确认的、也可以参与其中共识过程的区块链。</p></blockquote><p><a href="https://baike.baidu.com/item/%E5%85%AC%E6%9C%89%E9%93%BE/22447233?fr=aladdin" target="_blank" rel="noopener">公有链</a>（公共区块链）一般被称为公链，一般理解为记录信息的公共「账本」或是构建应用的「操作系统」，最为人熟知的账本有比特币、以太坊、EOS 等，不同的公链上的交易手续费（Gas Fee）与并发量（每秒处理的交易量）都可能不同，导致了不同程度的网络拥堵，也会影响到交易中的到账时间。</p><h3><span id="同质化代币ft">同质化代币（FT）</span></h3><p>大多数人了解的 BTC、ETH 等加密货币多数是同质化代币。像💴人民币、💵美元也是广义上的同质化代币，两张不同的一元人民币在价值上是不会有任何区别的（不考虑错版、靓号等特殊情况），同质化代币互相能够替换，具有统一性、可接近无穷拆分的特性。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043141-2021-05-13-3NUd5Z.png" alt></p><h3><span id="非同质化代币nft">非同质化代币（NFT）</span></h3><p>NFT 即非同质化代币（Non-Fungible Token），具有不可分割、不可替代、独一无二等特点。在现实生活中具有实际价值的事物是不可替代的，如一份📜合同、🏠房屋产权、🎨艺术作品、出生证明等，为了能数字化这些资产，就诞生了 NFT 这一概念。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043168-2021-05-13-0Y3U96.png" alt></p><p>NFT 这一概念最早产生于「<a href="https://cryptokitties.co/" target="_blank" rel="noopener">加密猫</a>」——全球首款区块链游戏，这么简单的一张图能卖上千元，离不开这张图在区块链上这一特性，保证了这猫咪在数字世界中的独一无二，即便这张图谁都可以保存数字版或打印出来一万份，也只有掌握「密码」的人能拥有这猫咪的价值或售卖交易。</p><blockquote><p>加密猫是一群讨人喜欢的数字喵咪，每一只猫咪都拥有独一无二的基因组，这决定它的外观和特征。玩家可以收集和繁殖喵咪，创造出全新的喵星人并解锁珍稀属性。</p></blockquote><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043181-2021-05-13-FKF8dG.png" alt="基于不同毛色、稀有度的价格不一的加密猫"></p><p>「加密猫」只是 NFT 中的开始，极具知名度的奢侈品品牌「GUCCI」「DC 漫画」「NBA」「波多野结衣」等等，都有宣布关于 NFT 的计划或已卖起了各自的 NFT 。</p><p><img src="https://cdn.sspai.com/2021/05/07/cbc3221dae42b4a0ec73e4b5fc32959e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><h3><span id="dapp">DApp</span></h3><p>DApp 即去中心化应用（Decentralization Application），实际上还是 app，只是有着去中心化的属性，不部署在中心化的服务器当中。也因为这个特性，影响到普通用户的地方主要在于 DApp 中的交易行为都需要连接到去中心化钱包，一般 PC 在浏览器中打开 DApp，然后连接到钱包插件；；手机端则是在钱包 app 内嵌的浏览器中打开 DApp 然后再连接到当前的钱包。</p><p><img src="https://cdn.sspai.com/2021/05/08/e5ef651a0c8f22046623f1d651016ce4.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><h3><span id="去中心化钱包">去中心化钱包</span></h3><p>去中心化钱包的奇怪名称起源于区块链技术的应用，可以简单理解为可以存放各种加密货币的钱包，是数字货币界中的「支付宝钱包」「微信钱包」。</p><p>PC 端操作可以在 Edge 或 Chrome 浏览器中下载一个去中心化钱包插件，在这里推荐「<a href="https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn" target="_blank" rel="noopener">MetaMask</a>」。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043299-2021-05-13-oyiUOa.png" alt="MetaMask"></p><p>而手机应用中常用的也有 「<a href="https://tokenpocket.pro/" target="_blank" rel="noopener">TokenPocket</a>」「<a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>」「<a href="https://trustwallet.com/" target="_blank" rel="noopener">Trust Wallet</a>」等。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043321-2021-05-13-059jzA.png" alt></p><p>另外一点需要注意的区别在于钱包不再以你身份信息、手机号码、认证邮箱作为被盗后找回密码的依据，取而代之的是「助记词」，需要谨慎保存。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043365-2021-05-13-jvb5fO.png" alt></p><p><img src="https://cdn.sspai.com/2021/04/29/f05fb693e509674858e0c4760d1e32e8.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><p>关于助记词，要是钱包没钱，也大可不必把这助记词的安全当回事🙄。但如果数字惊人，可以抄写到自己墙上，万一有好学的侄子侄女问起来怎么解释？当然是告诉他/她这是中考重点单词建议抄写背诵。</p><h2><span id="从哪里获取加密货币">从哪里获取加密货币</span></h2><h3><span id="参加空投">参加空投</span></h3><p>许多尚未发行或廉价的币为了提高知名度、宣传项目，会提供空投活动，免费发放各式各样的加密货币，除了部分含金量较高的加密货币为了防止不可控的白嫖，会要求钱包里预存一定等值金额的币种才能收到空投。</p><p>而大部分空投活动中要求的是只需动动手指就能完成的任务，像关注推特账号、转发推特、加入 「Discord」「Telegram」 频道、登记钱包地址、每日签到、邀请好友、位于积分排行榜前列等等。比起拼多多的无底线拉新活动，这些项目团队设置的规则要老实得多，自行配置好网络条件以及注册一个去中心化钱包后，可以通过空投导航网站 <a href="https://tokenairdrop.org/" target="_blank" rel="noopener">币空投</a> 体验白嫖空投的快感。</p><p><img src="https://cdn.sspai.com/2021/04/21/720e6044479bf8024797bed089f902df.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><h3><span id="交易所获取">交易所获取</span></h3><p>由于 2017 年 9 月 4 日开始国内禁止交易所运营，内地环境中的手机应用商店也没有任何交易所 app 可供下载，身处港澳台以及国外的读者可以自行了解主流交易所。</p><h3><span id="家用机挖矿">家用机挖矿</span></h3><p>如果你家里恰好有一台性能不错的机器，那么仅需要电费和时间，就能获得不同种类的加密货币，这类软件有很多，以 <a href="http://www.qskg.top/welcome.html" target="_blank" rel="noopener">轻松矿工</a> 为例，支持多个币种，操作傻瓜化，相对适合我们这种尝尝鲜并不打算以此盈利的小白用户。但不是所有币种都能通过硬件挖矿的方式获取，能选择的币种相当有限。</p><h3><span id="朋友转账">朋友转账</span></h3><p>注册好去中心化钱包后，1️⃣选择好一条公链2️⃣复制你的钱包地址3️⃣找到一个有加密货币的朋友（重点🐢）。然后就可以告诉你的朋友让他给你转账啦！</p><p>数字货币钱包之间的转账行为区别于并没有我们常用的如支付宝、银行转账的体验如此之好，除了需要提供钱包地址，还需要确定公链的选择，不同公链上的交易手续费用（Gas Fee，即矿工费）、网络拥堵程度（影响到账时间）都不同。要是两个信息（钱包地址、公链）选错了一个，就只能做好准备接受数字货币消失带来的悲痛了💔。</p><h2><span id="加密货币不止比特币">加密货币不止比特币</span></h2><p>就我身边群体而言，大部分人只知道比特币，而实际上加密货币种类可谓是百花齐放，其中也包括一些相当<strong>有趣</strong>（但不具有投资价值）的币种。</p><p><img src="https://cdn.sspai.com/2021/04/27/8a185f6beb16b5d5bdf8f66ecf76778f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt>加密货币市值分布</p><h3><span id="doge狗狗币">Doge（狗狗币）</span></h3><p><img src="https://cdn.sspai.com/2021/04/27/ad4a2ab01d2a1ea19aadbde7ed39869d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt>Dogecoin</p><p>Doge（狗狗币）可谓是加密货币中的「潮牌」。Adobe 任职的 Jackson Palmer 觉得好玩把Doge Meme 加入到加密货币后便一发不可收拾，狗狗币诞生后便在国外论坛 Reddit 上一直保持着惊人的热度。而后被作为各种社交平台的打赏道具，赞助了各种慈善活动和赛事，特斯拉 CEO 马斯克对其“可能是我最喜欢的数字货币”的评价，陆续被作为各个平台的支付手段，因此用户量和市值也在不停增长，这个相当不正经的数字货币目前已经成为了有着市值前十的货币之一。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043526-2021-05-13-DADPFm.png" alt="马斯克日常推特 cue 狗狗币"></p><h3><span id="mona萌奈币">Mona（萌奈币）</span></h3><p><img src="https://cdn.sspai.com/2021/05/08/8729ad399a2c1e3e223239ebee45d8a2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt>Monacoin</p><p><a href="https://monacoin.org/" target="_blank" rel="noopener">Mona</a>（萌奈币）是日本本土的首个加密货币，在（也仅仅在）日本拥有庞大的支持社区（<a href="https://monappy.jp/" target="_blank" rel="noopener">Monappy</a>），在社区中的各种交易行为都可以通过 Mona 来支付。包括游戏充值、文章打赏、图片打赏、自由买卖、购买礼品卡赠送等等。</p><p><img src="https://cdn.sspai.com/2021/05/08/b7b4bbb66e486c9d7fb5e14bb861c7c6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><h3><span id="flow">Flow</span></h3><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043605-2021-05-13-gEQuMt.png" alt></p><p><a href="https://www.onflow.org/" target="_blank" rel="noopener">Flow</a> 是 NFT 的公链代币，由前文提及到的「加密猫」团队打造，而 NBA 也基于 Flow 公链开发了「<a href="https://nbatopshot.com/" target="_blank" rel="noopener">NBA TOP SHOT</a>」  这一火爆的 DApp。购买 NFT 并非必须使用 Flow 付款，所以对于仅仅想要购买 NFT 的人而言可以选择忽略 Flow。</p><blockquote><p>Open Worlds</p><p>Flow is a new blockchain built for the next generation of apps, games, and the digital assets that power them.（Flow 定义为“开放世界的区块链”，旨在成为下一代游戏、应用程序及数字资产的基础。）</p></blockquote><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043646-2021-05-13-dbMc3A.png" alt="Flow 社区中还有 UFC、育碧、三星等知名赛事/企业"></p><h3><span id="shib柴犬币">SHIB（柴犬币）</span></h3><p><img src="https://cdn.sspai.com/2021/05/09/bec63295e1299fed885e07a3306040b2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt>SHIB</p><blockquote><p>What would happen if a crypto currency project was 100% run by its community?（如果一个加密货币项目 100% 由其社区管理会发生什么？）</p></blockquote><p><a href="https://www.shibatoken.com/" target="_blank" rel="noopener">SHIB（柴犬币）</a>来自于一个去中心化自发社区「Shiba Inu」的实验，团队在白皮书中如此描述去中心化社区：建立在社区参与基础上的项目是我们未来里待征服的荒漠。当我们离僵化的金融结构和传统思维方式越来越远，我们发现了解决问题与相互产生联系的新方式。当成功仅取决于组织创建团队的力量时，我们为了和其他人保持一致而改变了自己的观点。通过研究社区成员后发现力量并非来源与个体而是和谐的团体合作。而其创造的社区的代币「SHIB」也被称为「狗狗币杀手」,同时又是一个被马斯克「带货」而爆红的加密货币。</p><h3><span id="其他山寨币">其他山寨币</span></h3><p>「山寨币」并没有明确的定义和覆盖范围，用来统称一些没有明显创新和实用价值，市价极其不稳定，崩盘风险极高，常被用来投机交易的币种，而被称为山寨币中的莱特币和狗狗币甚至有着前十的市值。但有许多山寨币仅凭借着吸引眼球的名字便吸引了不少的持币者。</p><p><img src="https://cdn.sspai.com/2021/05/09/689eca4fc75ecae8e67de0a6b7c82e97.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt>LOWB</p><p>「<a href="https://losercoin.org/" target="_blank" rel="noopener">LOWB</a>」又称为 Loser Coin，这一符合当代青年自嘲特性的名字完全不输狗狗币。而其创立背景也名副其实：</p><blockquote><p>中国一个四线城市的贫困青年，邀请另一位贫困程序员，一同发起了Loser Coin项目，代币 LOWB。两人于 17 年接触 BTC，进入币圈，陆续炒币亏了许多钱，本次抱着归零的心态，成立此项目，在项目上线当天拿出全部积蓄添加流动性池子。本项目承诺不护盘（主要没实力），不跑路（无私募公募）。</p></blockquote><p>官网中的介绍有着相当贴地气的颓废和鸡血，👻看起来压根不打算找得到投资的样子。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043738-2021-05-13-D6rHua.png" alt></p><h2><span id="多多少少有点用处">多多少少有点用处</span></h2><p>世界上第一个加密货币比特币的白皮书上第一段话如此写道：</p><blockquote><p>本文提出了一种完全通过点对点技术实现的电子现金系统，它使得在线支付能够直接由一方发起并支付给另外一方，中间不需要通过任何的金融机构。</p></blockquote><p>可以知道的是创造者中本聪的初衷与目前大家感知到的炒币、挖矿、炒显卡、屯硬盘大相径庭，也是因为这些加密货币直接给人们带来的负面影响，很多人对加密货币嗤之以鼻，诸如「污染环境」「浪费资源」「影响显卡价格」「傻子才买」「割韭菜」等评价，但除了这些缺点，目前加密货币也已经有许多较为实用的应用场景。</p><h3><span id="藏品">藏品</span></h3><p><a href="https://opensea.io/" target="_blank" rel="noopener">OpenSea</a> 是全球第一个也是目前最大规模的 NFT 市场，可以购买「艺术品」「域名」「虚拟世界（Virtual Worlds）」「交易卡（Trading Cards）」「收藏品（Collectibles）」等各种分类的 NFT。</p><blockquote><p>Discover, collect, and sell extraordinary NFTs</p><p>on the world’s first &amp; largest NFT marketplace</p></blockquote><p><img src="https://cdn.sspai.com/2021/05/08/8674ee3052051d85f8c450b641b72480.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="马斯克再次客串"></p><p>近期在 OpenSea 上拍卖最引人注目的 NFT 之一，是街头艺术家 Banksy 的画作《Morons》（《白痴》），有趣的是这张画作本身是实体艺术品，被区块链公司 Injective Protocol 买下来后便在网络直播中销毁了实体，利用区块链技术做数位化处理后作为 NFT 拍卖，价格也从买入价 9.5 万美元翻了四倍以 38 万美元成交。更有趣的是 Banksy 这张画意在讽刺 1987 年梵高作品《Sunflowers》拍卖会现场，作品上写下「I can’t believe you morons actually buy this shit.」</p><p><img src="https://cdn.sspai.com/2021/05/08/a6b168df40d166716b7cc7a30a7de846.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="《Morons》"></p><p>而另一张著名的纯 NFT 画作《EVERYDAYS: THE FIRST 5000 DAYS》，诞生于数码艺术家 Beeple（Mike Winkleman）之手，是历史上第一次在大型拍卖行以 NFT 形式进行拍卖的纯数码拍品，最终在佳士得拍卖行以 6900 万美元成交。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043898-2021-05-13-JV5B1t.jpeg" alt="《EVERYDAYS: THE FIRST 5000 DAYS》"></p><p>如果对艺术品没有兴趣，NBA 爱好者还能通过「<a href="https://www.nbatopshot.com/" target="_blank" rel="noopener">NBA TOP SHOT</a>」中购买各种 NFT 卡包，解锁不同稀有度的球星卡片，不同球星的拉杆、隔扣、绝杀、退役录像/图片，作为你偶像名场面在区块链上的拥有者，这独特的 NFT 相信比保存在相册里的视频更加珍贵（价钱也确实很珍贵）。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133043936-2021-05-13-7qHfuN.png" alt></p><p>颇有知名度日本女演员波多野结衣、上原亚衣等，也推出了自己的 NFT 形式的写真集，相比纸质版的写真集，也多出了游戏上常用的盲盒玩法以及稀有度机制，区分了普通、高级、稀有、珍奇、史诗、传说多个档次，除了二次市场的价格以外，实际上不同稀有度的写真也确实有所不同（就是你想象的那样）。</p><p><img src="https://cdn.sspai.com/2021/05/08/1994dffdb2dafa4ba4aab9d7a1829974.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt></p><h3><span id="游戏">游戏</span></h3><p>依赖区块链技术上的三个特性：公开性、安全性和唯一性，区块链游戏也找到了一席之地，去中心化的游戏保证了以前从来没有的公平，因为数据上链，游戏里的资产都只属于玩家，由玩家进行自由交易，游戏厂商不能做出诸如收回、销毁等操作的干预，而老网游玩家必定经历过的数据泄露或资产被盗成为了不再需要担心的问题等等优势。</p><p><img src="https://cdn.sspai.com/2021/05/08/5ff1462e82e82857e68f13900f0567e2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="基本区块链游戏都会在首页中宣传基于区块链所获得的游戏特性；来源：「加密三国」"></p><p>除了以上提到的改变，即便区块链游戏的前期玩家通常都能有机会通过质押挖矿等形式获得游戏的分红，游戏本身的乐趣并没有因为区块链的技术带来显著的体验加强，目前游戏的玩法也是早已普遍的卡牌、养成、创造类游戏，还有许多可玩性一眼望穿且极具 4399 既视感的游戏，作为一名游戏玩家，区块链游戏的特点中我只对「资产自由交易」这一点比较感兴趣，在「地下城与勇士」「梦幻西游」等游戏中混迹大小街头摆摊，刷出深渊史诗转手拍卖的体验在如今的游戏中已几乎绝迹。</p><p>「<a href="https://www.sandbox.game/en/" target="_blank" rel="noopener">The Sandbox</a>」是区块链游戏中关注度较高的代表之一，游戏类型为沙盒游戏，允许玩家买卖土地、个人创作的模型资产。虽然目前还在预注册阶段，但精美的 UI、已公布的丰富的游戏元素也能让玩家们以小见大了。</p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133044086-2021-05-13-dpKZ20.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/1-20210513133044148-2021-05-13-mRL7Vq.png" alt></p><h3><span id="购物">购物</span></h3><p>除了像 OpenSea 的各个 NFT 交易平台提供了使用加密货币进行支付以外，目前也有越来越多的品牌、电商平台提供了使用加密货币付款的支付方式。而像苹果礼品卡兑换、亚马逊购物、微软积分兑换、网络域名购买、订阅 Twitch 流媒体付费服务、连锁餐饮店支付、航空公司服务支付等等，加密货币的用途也在不断地扩大范围，覆盖人们的购物行为。</p><h2><span id="结语">结语</span></h2><p>体验了各种加密货币的应用后，能感受到这些应用场景中的各种不完善。</p><ul><li>区块链游戏中总是强调着并不能带来乐趣的去中心化特性，和堆砌在显眼的位置上的一堆陌生术语，让只想玩游戏的我兴致全无。</li><li>各种去中心化钱包的交互体验堪比 2010 年的各大银行 app 般难用。</li><li>各个平台使用加密货币作为支付手段的流程相当复杂，主流币种每次交易需扣除的手续费（Gas Fee）也并不低廉，让这种概念先进的支付手段成了麻烦又昂贵的选择。</li></ul><p>总得来说这种种糟糕的体验就像是一台 Microsoft HoloLens ，除了让我这普通互联网用户感觉到「牛」之外，并没有带来实用价值。</p><p>这种情况也是部分互联网用户对于加密货币的应用还比较陌生的原因，但不能否认加密货币在全球范围内正蓬勃发展，即便带来了许多让人懊恼的负面影响，也或多或少正面影响甚至改变了如购物、社区、艺术品、音乐、游戏等多个领域的发展方向。</p><p>感谢你看到这里，本文仅从自身兴趣角度片面地泛泛而谈，如有错误欢迎指出。</p><blockquote><p>本文转载自：「 少数派 」，原文：<a href="https://sspai.com/post/65694" target="_blank" rel="noopener">https://sspai.com/post/65694</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相对于通过数字货币的获利、区块链的技术原理，如果你更想了解如何拥有自己的加密货币、不同的&lt;strong&gt;加密货币有何区别&lt;/strong&gt;、加密货币的&lt;strong&gt;应用场景&lt;/strong&gt;，或是&lt;strong&gt;参与到加密货币&lt;/strong&gt;的洪流里来，希望本文能够给到一定帮助。文中个别链接需要在特殊网络环境下访问。需要注意，&lt;strong&gt;本文不具有任何投资建议&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;和历年来科技上大部分的新技术不同，区块链技术在给大众生活带来显著正面影响之前，就已经带来了显著又负面的大范围影响——显卡涨价。而在本文编辑的这段时间里，热度旺盛的 Chia 币因为其需要通过硬盘参与挖矿，导致了大容量硬盘继显卡后成为了下一个「受害者」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链" scheme="https://www.hi-linux.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="区块链" scheme="https://www.hi-linux.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Docker 兴衰记 | 十年弹指一挥间，看容器霸业谁主沉浮！</title>
    <link href="https://www.hi-linux.com/posts/176.html"/>
    <id>https://www.hi-linux.com/posts/176.html</id>
    <published>2021-05-08T01:00:00.000Z</published>
    <updated>2021-05-08T01:34:39.445Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>Docker support in the kubelet is now deprecated and will be removed in a future release. The kubelet uses a module called “dockershim” which implements CRI support for Docker and it has seen maintenance issues in the Kubernetes community. We encourage you to evaluate moving to a container runtime that is a full-fledged implementation of CRI (v1alpha1 or v1 compliant) as they become available. (#94624, @dims) [SIG Node]</p></blockquote><p>上述引言来自 Kubernetes 1.120 的 Release Note，标志着 Docker 的丧钟进入尾声。事实上，当 2018 年 Docker 创始人 CTO Solomon Hykes 宣布离职时，Docker 和公司的命运已是江河日下。在复杂商业利益的驱使和一意孤行的错误决策下，从 2016 年至今诞生了 CRI、OCI 等标准和 Containerd、Runc、Docker-shim、CRI-O 等眼花缭乱却、功能盘龙交错重叠的项目，Kubelet 和容器运行时的调用链路复杂冗长且多次变化，整个生态为此苦不堪言。</p><p>回想 1981 年 IBM 推出 PC 时，采用了非常开放的标准，凝聚了硬件和软件的生态，迅速占据市场第一把交椅。开放也导致了广大廉价而有竞争力的兼容机出现，渐渐蚕食 IBM 的市场份额。于是 1987 年 IBM 从开放走向封闭，推出一款不再兼容外部硬件的机器 IBM PS/2，彻底走上了一条不归路，失去市场的同时失去了 PC 产业话语权。让我们再次回顾 Docker 从一鸣惊人再到由盛而衰的历史，并思考开源商业、技术和文化和内在逻辑和一些教训。</p><a id="more"></a><h2><span id="小船出海">小船出海</span></h2><p>PaaS 历来是兵家必争之地，通过类似 Container 技术将应用封装并交由编排系统管理，将给 DevOps 带来巨大的效率和成本优化。2002 年诞生的 linux namespace 和 2006 年诞生的 cgroup 为此奠定基本技术基础，此后 Google 和百度依次建设了 Borg 和 Matrix 平台，并取得巨大的成功；与此同时开源界也诞生了 Cloud Foundry 等项目。但在外人看来，Borg 和 Matrix 只闻其名，未见其实；而 Cloud Foundry 一直不愠不火，未得到广泛的普及。</p><p>究其根本原因乃是对应用(交付)的标准抽象的不过友好。以 Cloud Foundry 为例，它针对每种语言指定了一系列的标准，比如目录、可执行文件、二进制等等。这用在内部场景用无可厚非，绝大部分上规模的公司都会为应用设定一系列的规则，比如编码、配置、打包、运行环境和依赖，并形成各自的特色的标准；但是放眼整个生态，这种要求过于苛刻而缺乏普及性。Docker 真正革命之处在于开创了基于镜像交付应用的先河，它把应用的代码、配置和所有用户态层次依赖的整合成一个镜像，保证了运行环境的高度闭环和统一，对宿主机的依赖仅限于内核，而内核的 posix 接口非常稳定和兼容，所以保证了 Docker 镜像具有一次制作，四处运行的强大兼容强大威力。</p><p>2013 年，成立三年的 dotCloud(Docker 公司前身) 在 PaaS 平台产品商业化走到穷途末路时选择了开源核心引擎 Docker，换来的是柳暗花明又一村。这种轻量级虚拟化、语音无关、可移植性强的技术给出完美的应用交付标准，直击用户痛点，立马一石激起千层浪。这一年，Docker 迅速成长为云计算领域最受欢迎的项目，诸多巨头逐步增加了对 Docker 的支持，很多应用软件的交付也提供了 Docker 镜像；这一年，dotCloud 更名为 Docker，注册了 Docker 商标，出售了 PaaS 平台产品，全力转向 Docker 技术研发和生态建设。</p><p>此后的两年里，Docker 的发展可谓顺风顺水，生态版图持续扩大，从 linux 到 windows，从云计算到广义的应用市场，已俨然成为容器的标准。即使 Google 和 CoreOS 强势推出竞品 lmctfy 和 rkt，面对已成气候的 Docker 毫无招架之力。伴随生态的成功，Docker 前后拿下 4000万刀和 9500万刀的两轮重要融资补充粮草。当 2016 年夏天 DockerCon 举办时，Docker Hub 镜像总下载数量高达 40 多亿次，甚至一度传出微软欲以 40 亿美金收购这家只有数百人的公司！</p><h2><span id="群雄逐鹿">群雄逐鹿</span></h2><p>技术的持续发展离不开商业化的支持，Docker 作为一家创业公司从出身就背负着商业化的根本任务。尽管取得生态和技术上的巨大成功，带来了普世的巨大价值，却面临着商业化的巨大挑战。和其它通用而基础的开源技术一样，比如操作系统 linux、编译工具 GCC、虚拟化技术 Qemu-KVM，开源决定了 Liscense 之路不通，而单一的技术无法带来服务的溢价。打造 PaaS 平台层次的产品便成最具备可行性之路，和 2013 年卖掉 PaaS 平台相反，2014 年 Docker 收购 Fig 项目，以此推出编排产品 Docker Swarm，拉开了编排领域群雄逐鹿的帷幕。</p><p>开源的长河充满了合作和竞争，推动着生态不断发展和演进。这一年，Mesos 背后的公司 Mesospheres 推出 Marathon 项目；Google 基于 Borg 推出开源版本的编排项目 Kubernetes。和 Google、Redhat 等深谙道理的老玩家相比，年少气盛的 Docker 公司显得不易相处，2014 年 Docker 项目最早积极贡献者 CoreOS 不久后分道扬镳，和 Google、Redhat 创建了 OCI 规范，定义了容器运行时标准，妥协之下 Docker 公司从 libcontainer 捐献出 RunC 项目作为符合 OCI 标准的容器运行时。2015 年 Google、Redhat 等共同发起了 CNFC 基金会，并迅速增加了 Prometheus、Etcd、Helm、CNI 等众多知名项目，生态发展的风向标逐步由 Docker 转向 Kubernetes，开始建造了坚固的护城河。</p><p>当时间来到 2016 年时，一切尘埃落定，远去了鼓角争鸣，Kubernetes 已成了容器编排领域的绝对标准。和暴发户 Docker 如日中天变得专横独断相比，K8S 民主化的风格和 Plugin 的架构迅速的吸引了周边的生态伙伴；其次 K8S 源自于 Google 基础设施领域多年的宝贵实践和升华，其设计的理念和抽象形态更贴近本质的需求。</p><p>即使 K8S 赢得编排的标准，由于 Docker 已成容器的标准，所以早期的 Kubelet 内嵌 Docker 客户端，默认其为容器的运行时，因而从 Kubelet 到容器运行时的代码整体比较路径简短优雅 —— 容器的归容器、编排的归编排。但之后 Docker 公司祭出以自杀八百、损敌一千的姿态做出损人不利己的骚招。在面对 Swarm 的失败后，由于 Docker 名声和美誉广为人知，于是公司将 PaaS 平台的能力沉淀到名为 Docker 产品(甚至集成了 K8S)，并将 Docker 项目改名为 moby，压上名气这张最后的筹码孤注一掷。</p><p>群雄逐鹿过程中，Docker 和 K8S 之间的纠葛埋下广大同行深受其苦的坑，从 Kubelet 到运行时主要经历了如下调用链路的变更，诞生了一堆临时和更多凑热闹的项目，给广大的开发者带来沉重的心智负担，留下一地鸡毛。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+    +---------+    +-----------+</span><br><span class="line">| Kubelet(Dockerclient) | -&gt; | Dockerd | -&gt; | Container |</span><br><span class="line">+-----------------------+    +---------+    +-----------+</span><br><span class="line"></span><br><span class="line">+--------------+    +-------------+    +---------+    +------------+    +------+    +------------+</span><br><span class="line">| Kubelet(CRI) | -&gt; | Docker-shim | -&gt; | Dockerd | -&gt; | Containerd | -&gt; | Runc | -&gt; | Containers |</span><br><span class="line">+--------------+    +-------------+    +---------+.   +------------+    +------+    +------------+</span><br><span class="line"></span><br><span class="line">+--------------+    +----------------+    +------------+    +------+    +-----------+</span><br><span class="line">| Kubelet(CRI) | -&gt; | CRI-Containerd | -&gt; | Containerd | -&gt; | RunC | -&gt; | Container | </span><br><span class="line">+--------------+    +----------------+    +------------+    +------+    +-----------+</span><br><span class="line"></span><br><span class="line">+--------------+    +------------+    +------+    +-----------+</span><br><span class="line">| Kubelet(CRI) | -&gt; | Containerd | -&gt; | RunC | -&gt; | Container | </span><br><span class="line">+--------------+    +------------+    +------+    +-----------+</span><br></pre></td></tr></table></figure><h2><span id="最佳选择">最佳选择</span></h2><p>有些历史被成为绝唱，那是因为没如果和重来。但是似曾相识的故事总是在不断的轮回，上世纪八十年代，蓝色巨人坐拥拥无人可撼动的市场霸主地位，当它试图以一己之力关闭兼容机的大门时，换来了作茧自缚。巅峰时期的 Docker 在生态上虽然取得了巨大的成功，但它的地位和当年的 IBM 丝毫不能相提并论，当然，这也是马后炮式的分析。</p><p>让我们站在 Docker 的曾经的巅峰上，俯瞰整个应用的交付标准唯我独尊，Docker hub 囊括了海量应用镜像，和下一个 “vmware” 相比，微软抛出区区 40 亿美金收购的橄榄枝又是多么的微不足道，我想换成任何人都愿意跃跃欲试，放手一搏向 PaaS 平台进军。当错失闪烁瞬间的机会后，便是土崩瓦解般的故事，2018 年创始人兼 CTO 离职，2019 年裁员，2020 年 Dockerhub 离奇的推出限速下载。</p><p>从商业的视角来看，基础而通用的开源技术项目本身价值和需求重大，但是成功的商业故事却寥寥无几。开源注定卖 License 之路不通，单一的基础技术很难带来服务的溢价，技术培训、二次开发的收益则是杯水车薪，而捐助等对于一家数百人的公司更天方夜谭，所以特别对于基础通用的技术来说，开源几乎不可能成为商业模式。但是从另外一个角度来说，开源更是一种市场策略，它可以快速试错，推广产品和思路，获得用户粘性，构建生态的护城河。如果顺着这个思路，从短期盈利的价值来看，Docker 公司卖给微软和 AWS 是中策，背靠着金主爸爸和强大的云计算服务；从长远的生态和普世价值角度来看，我认为 Redhat 收购 Docker 应该是最佳的选择，以 Redhat 的智慧，或将带来全方位的共赢和持久的繁荣。可以说，对于绝大部分做基础通用的开源技术产品的创业公司来说，被巨头收购已是最好的结局。</p><p>正如《大教堂和集市》所言：“开放式的文化会最终胜利，这或许不是因为”开放”在道德上正确，或者”封闭”在道德上错误，而只是因为开放式合作可以在一个问题上投入多几个数量级的技术工时，封闭的世界无法赢得这样的竞争。”当 Docker 开源时，它以新颖的理念解决应用交付的巨大痛点，描绘了 PaaS 的新蓝图，吸引了广泛的合作者。但是 Docker 的管理者既没有充分的识别和吸收他人优秀的想法，更没有良好的人际关系、交流技能和人格魅力。先后和 CoreOS、Redhat、Google 等开源巨头分道扬镳，最后又为一己之利和生态背离。开源生态的发展如一股大洪流滚滚向前，只能顺势和引领，不可阻挡，妄图借垄断之势损坏普遍大众的利益的行为只会被这股洪流冲垮和抛弃。</p><p>回首这八年，Docker 已到棺盖定论之时，它掀起了一场轰轰烈烈的 PaaS 革命，给 DevOps、云原生等带来了巨大的理念突破和奠定技术基础；而管理者的战略和战术的种种失误措施良机，接连败北，丢失了商业市场，失去了生态和名声，拉下一地鸡毛。数年以后，容器一词依旧盛行，而 Docker 或将无人提及，唯有一声叹息。</p><blockquote><p>本文转载自：「 Koala Bear 」，原文：<a href="http://t.cn/A6tYaES0" target="_blank" rel="noopener">http://t.cn/A6tYaES0</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Docker support in the kubelet is now deprecated and will be removed in a future release. The kubelet uses a module called “dockershim” which implements CRI support for Docker and it has seen maintenance issues in the Kubernetes community. We encourage you to evaluate moving to a container runtime that is a full-fledged implementation of CRI (v1alpha1 or v1 compliant) as they become available. (#94624, @dims) [SIG Node]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述引言来自 Kubernetes 1.120 的 Release Note，标志着 Docker 的丧钟进入尾声。事实上，当 2018 年 Docker 创始人 CTO Solomon Hykes 宣布离职时，Docker 和公司的命运已是江河日下。在复杂商业利益的驱使和一意孤行的错误决策下，从 2016 年至今诞生了 CRI、OCI 等标准和 Containerd、Runc、Docker-shim、CRI-O 等眼花缭乱却、功能盘龙交错重叠的项目，Kubelet 和容器运行时的调用链路复杂冗长且多次变化，整个生态为此苦不堪言。&lt;/p&gt;
&lt;p&gt;回想 1981 年 IBM 推出 PC 时，采用了非常开放的标准，凝聚了硬件和软件的生态，迅速占据市场第一把交椅。开放也导致了广大廉价而有竞争力的兼容机出现，渐渐蚕食 IBM 的市场份额。于是 1987 年 IBM 从开放走向封闭，推出一款不再兼容外部硬件的机器 IBM PS/2，彻底走上了一条不归路，失去市场的同时失去了 PC 产业话语权。让我们再次回顾 Docker 从一鸣惊人再到由盛而衰的历史，并思考开源商业、技术和文化和内在逻辑和一些教训。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Tmuxp 来优雅的管理多个 Tmux 会话</title>
    <link href="https://www.hi-linux.com/posts/253.html"/>
    <id>https://www.hi-linux.com/posts/253.html</id>
    <published>2021-05-06T01:00:00.000Z</published>
    <updated>2021-05-06T04:35:34.700Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>使用 <a href="https://github.com/tmux-python/tmuxp" target="_blank" rel="noopener">tmuxp</a> 可以很好的帮助我们来管理 tmux 的会话(session)，解决了平时在使用 tmux 工具时候的痛点。</strong></p></blockquote><h2><span id="1-工具介绍">1. 工具介绍</span></h2><blockquote><p><strong>安装和使用都非常简单</strong></p></blockquote><p>事实上，<code>tmuxp</code> 也是一个构建于 <code>tmux</code> 之上的对象关系映射的 <code>ORM</code> 的 <code>API</code> 工具，就是利用 <code>tmux</code> 工具定义的窗格(pane)、窗口(windows)和会话(session)，以创建关联视图的 <code>Server</code>, <code>Session</code>, <code>Window</code>, <code>Pane</code> 对象。我们在使用的时候，可以使用 <code>YAML</code>, <code>JSON</code> 以及 <code>dict</code> 字配置项来启动我们配置好的窗口和面板。使用时候需要注意的是，只支持 <code>tmux&gt;=1.8</code> 的版本。</p><ul><li>简洁的语法<ul><li>都支持在单独的命令中使用简短标记</li></ul></li><li>加载会话<ul><li>都是根据配置文件中加载 <code>tmux</code> 会话(<code>session</code>)</li></ul></li><li>多种格式支持<ul><li>可以使用 <code>YAML</code>, <code>JSON</code> 以及 <code>dict</code> 字配置项</li></ul></li></ul><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有这一种安装方式</span></span><br><span class="line">$ pip install tmuxp</span><br><span class="line">$ pip install --user tmuxp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置zsh补全(.zshrc)</span></span><br><span class="line">$ <span class="built_in">eval</span> <span class="string">"<span class="variable">$(_TMUXP_COMPLETE=source_zsh tmuxp)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置bash补全(.bashrc)</span></span><br><span class="line">$ <span class="built_in">eval</span> <span class="string">"<span class="variable">$(_TMUXP_COMPLETE=source tmuxp)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果运行命令提示报错则执行如下命令即可</span></span><br><span class="line">$ tmux <span class="built_in">kill</span>-server</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简洁的语法配置</span></span><br><span class="line"><span class="attr">session_name:</span> <span class="string">shorthands</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">long</span> <span class="string">form</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'did you know'</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'you can inline'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span> <span class="string">echo</span> <span class="string">'single commands'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'for panes'</span></span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/learn-tmuxp-tools-1-2021-01-27-aJHxhm.gif" alt></p><h2><span id="2-使用方式">2. 使用方式</span></h2><blockquote><p><strong>只需要记住 load 这个一个命令其实就够了</strong></p></blockquote><p><strong><code>tmuxp</code></strong> 工具将配置文件保存在 <code>~/.tmuxp</code> 中或在项目目录下作为 <code>~/.tmuxp.{yaml，json}</code> 独立出现。当然我们也可以使用其提供的命令，进行会话的相关操作和使用。下来就让我们一起去看看，如何使用吧！</p><ul><li>[1] 加载会话(Load session)<ul><li>Load a tmux workspace from each CONFIG.</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方式</span></span><br><span class="line"><span class="comment"># session_name: 会话(Session)名称</span></span><br><span class="line"><span class="comment"># -h: tmux服务器的地址</span></span><br><span class="line"><span class="comment"># -L: tmux服务器的socket名，与tmux相同</span></span><br><span class="line"><span class="comment"># -S: tmux服务器的socket路径，与tmux相同</span></span><br><span class="line"><span class="comment"># -2: 强迫tmux的终端支持256色</span></span><br><span class="line"><span class="comment"># -8: 与-2类似，但是只支持88色</span></span><br><span class="line"><span class="comment"># --list=False: 列出可用的配置文件</span></span><br><span class="line">$ tmuxp load [-h] [-L socket-name] [-S socket-path] [-2 | -8] [--list] [config]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过配置文件路径加载</span></span><br><span class="line">$ tmuxp load .</span><br><span class="line">$ tmuxp load ./mysession.yaml</span><br><span class="line">$ tmuxp load ~/workspaces/myproject.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过自定义会话名称加载</span></span><br><span class="line">$ tmuxp load mysession</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次加载多个会话</span></span><br><span class="line">$ tmuxp load mysession ./another/project/</span><br></pre></td></tr></table></figure><ul><li>[2] 冻结会话(Freeze sessions)<ul><li>Snapshot a session into a config.</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方式</span></span><br><span class="line"><span class="comment"># session_name: 会话(Session)名称</span></span><br><span class="line"><span class="comment"># -h: tmux服务器的地址</span></span><br><span class="line"><span class="comment"># -L: tmux服务器的socket名，与tmux相同</span></span><br><span class="line"><span class="comment"># -S: tmux服务器的socket路径，与tmux相同</span></span><br><span class="line">$ tmuxp freeze [-h] [-L socket-name] [-S socket-path] session_name [session_name ...]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为tmux布局、窗格路径和窗口/会话名称创建快照</span></span><br><span class="line">$ tmuxp freeze session-name</span><br></pre></td></tr></table></figure><ul><li>[3] 配置转换<ul><li>Convert a tmuxp config between JSON and YAML.</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方式</span></span><br><span class="line"><span class="comment"># config: 配置文件的绝对/相对路径</span></span><br><span class="line">tmuxp convert [-h] config</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以互相转换JSON/YAML格式</span></span><br><span class="line">$ tmuxp convert &lt;filename&gt;</span><br></pre></td></tr></table></figure><ul><li>[4] 配置导入<ul><li>Import a teamocil/tmuxinator config.</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方式</span></span><br><span class="line"><span class="comment"># config: 在 ~/.teamocil 和当前目录下查找yaml文件</span></span><br><span class="line"><span class="comment"># --list=False: 列出 ~/.teamocil 和当前工作目录下的配置文件</span></span><br><span class="line">$ tmuxp import teamocil [-h] (--list | config)</span><br><span class="line">$ tmuxp import tmuxinator [-h] (--list | config)</span><br></pre></td></tr></table></figure><h2><span id="3-面板窗口配置">3. 面板窗口配置</span></h2><blockquote><p><strong>主要介绍 tmux 面板的切分、启动目录、索引设定等操作</strong></p></blockquote><ul><li>[1] 两个窗格(2 split panes)<ul><li>分割出两个窗格</li></ul></li></ul><p><img src="https://img.hi-linux.com/staticfile/learn-tmuxp-tools-2-2021-01-27-c3IkeK.gif" alt></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="number">2</span><span class="string">-pane-vertical</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">my</span> <span class="string">test</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="number">2</span><span class="string">-pane-vertical-long</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cd</span> <span class="string">~</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pwd</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">top</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cd</span> <span class="string">/var/www</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pwd</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">second</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">shell_command_before:</span> <span class="string">cd</span> <span class="string">/var/www</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span> <span class="string">pwd</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pwd</span></span><br></pre></td></tr></table></figure><ul><li><strong>[2] 三个窗格(3 panes)</strong></li></ul><p><img src="https://img.hi-linux.com/staticfile/RA1Cc4-2021-01-27-a7MTrq.jpg" alt></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="number">3</span><span class="string">-panes</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">dev</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-vertical</span></span><br><span class="line">    <span class="attr">shell_command_before:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cd</span> <span class="string">~/</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cd</span> <span class="string">/var/log</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ls</span> <span class="string">-al</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">\.log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hellotmu</span></span><br></pre></td></tr></table></figure><ul><li><strong>[3] 四个窗格(4 panes)</strong></li></ul><p><img src="https://img.hi-linux.com/staticfile/learn-tmuxp-tools-4-2021-01-27-NB729J.gif" alt></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="number">4</span><span class="string">-pane-split</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">dev</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">tiled</span></span><br><span class="line">    <span class="attr">shell_command_before:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cd</span> <span class="string">~/</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cd</span> <span class="string">/var/log</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ls</span> <span class="string">-al</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">\.log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure><ul><li>[4] 空白窗格(Blank panes)<ul><li>直接可以使用 ‘null, ‘blank’, ‘pane’ 中任何一个，即可创建空白窗格</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">Blank</span> <span class="string">pane</span> <span class="string">test</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="comment"># 如果之前没有shell命令将打开一个空白窗格</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">Blank</span> <span class="string">pane</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blank</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">More</span> <span class="string">blank</span> <span class="string">panes</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="literal">null</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span></span><br><span class="line">  <span class="comment"># 空字符串将被视为回车</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">Empty</span> <span class="string">string</span> <span class="string">(return)</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span> <span class="string">""</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">  <span class="comment"># 窗格可以有其他选项但仍然是空的</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">Blank</span> <span class="string">with</span> <span class="string">options</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">start_directory:</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure><ul><li>[5] 启动目录(Start Directory)<ul><li>设置起始目录</li><li>等价于<code>tmux new-window -c &lt;start-directory&gt;</code>命令</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">start</span> <span class="string">directory</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">/var/</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">should</span> <span class="string">be</span> <span class="string">/var/</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"\033c</span></span><br><span class="line"><span class="string">          - it trickles down from session-level"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">should</span> <span class="string">be</span> <span class="string">/var/log</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'\033c</span></span><br><span class="line"><span class="string">          - window start_directory concatenates to session start_directory</span></span><br><span class="line"><span class="string">          - if it is not absolute'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">should</span> <span class="string">be</span> <span class="string">~</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">'echo \\033c ~ has precedence. note: remember to quote ~ in YAML'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">should</span> <span class="string">be</span> <span class="string">/bin</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/bin</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'\033c absolute paths also have precedence.'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">should</span> <span class="string">be</span> <span class="string">config's</span> <span class="string">dir</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'\033c</span></span><br><span class="line"><span class="string">          - ./ is relative to config file location</span></span><br><span class="line"><span class="string">          - ../ will be parent of config file</span></span><br><span class="line"><span class="string">          - ./test will be \"test\" dir inside dir of config file'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'\033c</span></span><br><span class="line"><span class="string">          - This way you can load up workspaces from projects and maintain</span></span><br><span class="line"><span class="string">          - relative paths.'</span></span><br></pre></td></tr></table></figure><ul><li>[6] 窗口索引<ul><li>定义窗口索引，就是我们在使用时候用来切换窗口时使用</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">Window</span> <span class="string">index</span> <span class="string">example</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">zero</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"this window's index will be zero"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">five</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"this window's index will be five"</span></span><br><span class="line">    <span class="attr">window_index:</span> <span class="number">5</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">one</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"this window's index will be one"</span></span><br></pre></td></tr></table></figure><h2><span id="4-面板窗口设置">4. 面板窗口设置</span></h2><blockquote><p><strong>工具系统方法的一些配置</strong></p></blockquote><ul><li>[1] 环境变量<ul><li>在<code>tmuxp</code>中设置会话环境变量</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">Environment</span> <span class="string">variables</span> <span class="string">test</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">EDITOR:</span> <span class="string">/usr/bin/vim</span></span><br><span class="line">  <span class="attr">HOME:</span> <span class="string">/tmp/hm</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="comment"># 如果之前没有shell命令将打开一个空白窗格。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">Blank</span> <span class="string">pane</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span></span><br></pre></td></tr></table></figure><ul><li>[2] 定制主面板高度(Main pane height)<ul><li>根据实际使用情况，设置主面板的高度</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">main-pane-height</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">top</span></span><br><span class="line">        <span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"hey"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"moo"</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">my</span> <span class="string">window</span> <span class="string">name</span></span><br></pre></td></tr></table></figure><ul><li>[3] 终端历史<ul><li>用于配置是否需要记录终端命令历史</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">suppress</span></span><br><span class="line"><span class="attr">suppress_history:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">appended</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">suppress_history:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"window in the history!"</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">suppressed</span></span><br><span class="line">    <span class="attr">suppress_history:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"window not in the history!"</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"session in the history!"</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">mixed</span></span><br><span class="line">    <span class="attr">suppress_history:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"command in the history!"</span></span><br><span class="line">        <span class="attr">suppress_history:</span> <span class="literal">false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"command not in the history!"</span></span><br><span class="line">        <span class="attr">suppress_history:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"window in the history!"</span></span><br></pre></td></tr></table></figure><ul><li>[4] 窗口选项<ul><li>创建窗格后设置窗口选项</li><li>在创建过程中在每个窗格中执行单个命令后，对于“同步窗格”选项很有用</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="number">2</span><span class="string">-pane-synchronized</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">Two</span> <span class="string">synchronized</span> <span class="string">panes</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ssh</span> <span class="string">server1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ssh</span> <span class="string">server2</span></span><br><span class="line">    <span class="attr">options_after:</span></span><br><span class="line">      <span class="attr">synchronize-panes:</span> <span class="string">on</span></span><br></pre></td></tr></table></figure><ul><li>[5] 设置选项<ul><li>设置<code>tmux</code>工具相关的选项，例如全局(服务器范围)选项、会话选项和窗口选项</li><li>包括<code>automatic-rename</code>,<code>default-shell</code>,<code>default-command</code>等相关命令</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">test</span> <span class="string">window</span> <span class="string">options</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line"><span class="attr">global_options:</span></span><br><span class="line">  <span class="attr">default-shell:</span> <span class="string">/bin/sh</span></span><br><span class="line">  <span class="attr">default-command:</span> <span class="string">/bin/sh</span></span><br><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">main-pane-height:</span> <span class="string">$&#123;MAIN_PANE_HEIGHT&#125;</span> <span class="comment"># works with env variables</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">on</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">man</span> <span class="string">echo</span></span><br><span class="line">        <span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"hey"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"moo"</span></span><br></pre></td></tr></table></figure><ul><li>[6] 自动重命名(Automatic Rename)<ul><li>即可以自动命令创建的面板名称</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">test</span> <span class="string">window</span> <span class="string">options</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">on</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">man</span> <span class="string">echo</span></span><br><span class="line">        <span class="attr">start_directory:</span> <span class="string">"~"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"hey"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"moo"</span></span><br></pre></td></tr></table></figure><ul><li>[7] 专注模式<ul><li>在专注模式中，可以确保在加载时附加和选择窗口和窗格</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">focus</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">attached</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'this pane should be selected on load'</span></span><br><span class="line">        <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cd</span> <span class="string">/var/log</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">second</span> <span class="string">window</span></span><br><span class="line">    <span class="attr">shell_command_before:</span> <span class="string">cd</span> <span class="string">/var/log</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'this pane should be focused, when window switched to first time'</span></span><br><span class="line">        <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br></pre></td></tr></table></figure><h2><span id="5-测试开发配置">5. 测试开发配置</span></h2><blockquote><p><strong>主要介绍在我们实际开发和测试当中应该如何使用该工具</strong></p></blockquote><ul><li>[1] 定制高级开发环境<ul><li>作为开发环境时候的相关配置</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">tmuxp</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span> <span class="comment"># 加载相对于配置位置(项目根目录)的会话</span></span><br><span class="line"><span class="attr">before_script:</span> <span class="string">pipenv</span> <span class="string">install</span> <span class="string">--dev</span> <span class="string">--skip-lock</span></span><br><span class="line"><span class="attr">shell_command_before:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"[ -d `pipenv --venv` ] &amp;&amp; source `pipenv --venv`/bin/activate &amp;&amp; reset"</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">tmuxp</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">True</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">watch_test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">docs</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">doc/</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">serve</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">watch</span></span><br></pre></td></tr></table></figure><ul><li>[2] 自动引导<ul><li>新版本<code>1.3.4</code>:在脚本 CWD 进入根(会话)级启动目录之前</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设您的.tmuxp.yaml位于项目的根目录中</span></span><br><span class="line"><span class="comment"># 如果使用pipenv的话，则可以使用如下脚本来确保已安装软件包</span></span><br><span class="line"><span class="attr">session_name:</span> <span class="string">my</span> <span class="string">pipenv</span> <span class="string">project</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">before_script:</span> <span class="string">pipenv</span> <span class="string">install</span> <span class="string">--dev</span> <span class="string">--skip-lock</span> <span class="comment"># 开发环境</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">django</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blank</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pipenv</span> <span class="string">run</span> <span class="string">./manage.py</span> <span class="string">runserver</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设您的.tmuxp.yaml位于项目的根目录中</span></span><br><span class="line"><span class="comment"># 可以使用shell_command_before将自己置身于虚拟环境中</span></span><br><span class="line"><span class="attr">session_name:</span> <span class="string">my</span> <span class="string">pipenv</span> <span class="string">project</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">before_script:</span> <span class="string">pipenv</span> <span class="string">install</span> <span class="string">--dev</span> <span class="string">--skip-lock</span> <span class="comment"># 开发环境</span></span><br><span class="line"><span class="attr">shell_command_before:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"[ -d `pipenv --venv` ] &amp;&amp; source `pipenv --venv`/bin/activate &amp;&amp; reset"</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">django</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blank</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./manage.py</span> <span class="string">runserver</span></span><br></pre></td></tr></table></figure><h2><span id="6-配置示例文件">6. 配置示例文件</span></h2><blockquote><p><strong>这里就是其他人使用该工具的配置文件，可以借鉴和引用</strong></p></blockquote><ul><li><strong>laixintao</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">workspace</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="number">66e3</span><span class="string">,238x57,0,0,14</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/Users/laixintao/Program</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">vim</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="string">a5de,238x57,0,0&#123;119x57,0,0,15,118x57,120,0[118x28,120,0,19,118x28,120,29,20]&#125;</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="attr">shell_command:</span> <span class="string">zsh</span></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/Users/laixintao</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">operation</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="number">66e5</span><span class="string">,238x57,0,0,16</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="attr">shell_command:</span> <span class="string">zsh</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/Users/laixintao</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">shell</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="number">66e6</span><span class="string">,238x57,0,0,17</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="attr">shell_command:</span> <span class="string">zsh</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/Users/laixintao</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">shell</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="number">66e7</span><span class="string">,238x57,0,0,18</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="attr">shell_command:</span> <span class="string">zsh</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">/Users/laixintao</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">shell</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">layout:</span> <span class="string">main-vertical</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="attr">shell_command:</span> <span class="string">clash</span> <span class="string">&gt;</span> <span class="string">/tmp/clash.log</span></span><br><span class="line">    <span class="attr">window_name:</span> <span class="string">&lt;clash&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>vcspull</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">vcspull</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">before_script:</span> <span class="string">pipenv</span> <span class="string">install</span> <span class="string">--dev</span> <span class="string">--skip-lock</span></span><br><span class="line"><span class="attr">shell_command_before:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"[ -d `pipenv --venv` ] &amp;&amp; source `pipenv --venv`/bin/activate &amp;&amp; reset"</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">vcspull</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">True</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">watch_test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">docs</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">doc/</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">serve</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">make</span> <span class="string">watch</span></span><br></pre></td></tr></table></figure><ul><li><strong>dockerfiles</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">dockerfiles</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">6da5,239x56,0,0[239x34,0,0,65,239x21,0,35&#123;119x21,0,35,66,119x21,120,35,67&#125;]</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">vim</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">:e</span> <span class="string">README.rst</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">docs</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">    <span class="attr">shell_command_before:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">virtualenv</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">virtualenv;</span> <span class="string">&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"[ -d .env -a -f .env/bin/activate ] &amp;&amp; source .env/bin/activate || virtualenv .env"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"[ ! -d .env/build ] || rm -rf .env/build"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./doc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">.env/bin/tmuxp</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">requirements.pip;</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">reset</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">vim</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">:Ex</span></span><br><span class="line">        <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pwd</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'docs built to &lt;http://0.0.0.0:8007/_build/html&gt;'</span><span class="string">;</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">SimpleHTTPServer</span> <span class="number">8007</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">watching_testrunner</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">watching_testrunner;</span> <span class="string">&#125;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">watching_testrunner</span> <span class="string">--basepath</span> <span class="string">./</span> <span class="string">--pattern="*.rst"</span> <span class="string">'make html'</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">postgresql</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">6da5,239x56,0,0[239x34,0,0,65,239x21,0,35&#123;119x21,0,35,66,119x21,120,35,67&#125;]</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">automatic-rename:</span> <span class="string">"off"</span></span><br><span class="line">    <span class="attr">start_directory:</span> <span class="string">postgresql</span></span><br><span class="line">    <span class="attr">panes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">vim</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">:e</span> <span class="string">Dockerfile</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pane</span></span><br></pre></td></tr></table></figure><ul><li><strong>sphinxcontrib</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session_name:</span> <span class="string">sphinxcontrib-github</span></span><br><span class="line"><span class="attr">start_directory:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">windows:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">options:</span></span><br><span class="line">    <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">  <span class="attr">panes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">vim</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">  <span class="attr">window_name:</span> <span class="string">sphinxcontrib-github</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">window_name:</span> <span class="string">docs</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">main-horizontal</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">main-pane-height:</span> <span class="number">35</span></span><br><span class="line">  <span class="attr">shell_command_before:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">virtualenv</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">virtualenv;</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'[ -d .env -a -f .env/bin/activate ] &amp;&amp; source .env/bin/activate || virtualenv .env'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'[ ! -d .env/build ] || rm -rf .env/build'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">.env/bin/tmuxp</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-e</span> <span class="string">.;</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./doc</span></span><br><span class="line">  <span class="attr">panes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">reset</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">vim</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">:Ex</span></span><br><span class="line">    <span class="attr">focus:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pane</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'docs built to &lt;http://0.0.0.0:8005/_build/html&gt;'</span><span class="string">;</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">SimpleHTTPServer</span> <span class="number">8005</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">shell_command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">sphinx-quickstart</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">requirements.pip;</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">command</span> <span class="string">-v</span> <span class="string">watching_testrunner</span> <span class="string">&gt;/dev/null</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">||</span> <span class="string">&#123;</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">watching_testrunner;</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">watching_testrunner</span> <span class="string">--basepath</span> <span class="string">./</span> <span class="string">--pattern="*.rst"</span> <span class="string">'make html'</span></span><br><span class="line"><span class="string">Terms</span></span><br></pre></td></tr></table></figure><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/y5zsckzv%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://tinyurl.com/y5zsckzv，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用 &lt;a href=&quot;https://github.com/tmux-python/tmuxp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tmuxp&lt;/a&gt; 可以很好的帮助我们来管理 tmux 的会话(session)，解决了平时在使用 tmux 工具时候的痛点。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-工具介绍&quot;&gt;1. 工具介绍&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;安装和使用都非常简单&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事实上，&lt;code&gt;tmuxp&lt;/code&gt; 也是一个构建于 &lt;code&gt;tmux&lt;/code&gt; 之上的对象关系映射的 &lt;code&gt;ORM&lt;/code&gt; 的 &lt;code&gt;API&lt;/code&gt; 工具，就是利用 &lt;code&gt;tmux&lt;/code&gt; 工具定义的窗格(pane)、窗口(windows)和会话(session)，以创建关联视图的 &lt;code&gt;Server&lt;/code&gt;, &lt;code&gt;Session&lt;/code&gt;, &lt;code&gt;Window&lt;/code&gt;, &lt;code&gt;Pane&lt;/code&gt; 对象。我们在使用的时候，可以使用 &lt;code&gt;YAML&lt;/code&gt;, &lt;code&gt;JSON&lt;/code&gt; 以及 &lt;code&gt;dict&lt;/code&gt; 字配置项来启动我们配置好的窗口和面板。使用时候需要注意的是，只支持 &lt;code&gt;tmux&amp;gt;=1.8&lt;/code&gt; 的版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁的语法
&lt;ul&gt;
&lt;li&gt;都支持在单独的命令中使用简短标记&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加载会话
&lt;ul&gt;
&lt;li&gt;都是根据配置文件中加载 &lt;code&gt;tmux&lt;/code&gt; 会话(&lt;code&gt;session&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多种格式支持
&lt;ul&gt;
&lt;li&gt;可以使用 &lt;code&gt;YAML&lt;/code&gt;, &lt;code&gt;JSON&lt;/code&gt; 以及 &lt;code&gt;dict&lt;/code&gt; 字配置项&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Tmux" scheme="https://www.hi-linux.com/categories/Tmux/"/>
    
    
      <category term="Tmux" scheme="https://www.hi-linux.com/tags/Tmux/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Tmuxp" scheme="https://www.hi-linux.com/tags/Tmuxp/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 之父创造的 Rocky Linux 8.3 发布了！(内附镜像下载地址）</title>
    <link href="https://www.hi-linux.com/posts/16230.html"/>
    <id>https://www.hi-linux.com/posts/16230.html</id>
    <published>2021-05-02T01:00:00.000Z</published>
    <updated>2021-05-03T15:16:25.163Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>去年 12 月份，<code>CentOS</code> 官网正式宣布，将停止维护 <code>CentOS Linux</code>，并将更多资金和人力投入到 <code>CentOS Stream</code> 中。而 <code>Rocky Linux</code> 是红帽宣布放弃 <code>CentOS Linux</code> 后，由 <code>CentOS</code> 联合创始人 <code>Gregory Kurtzer</code> 创建的 <code>CentOS</code> 发行版，旨在继承 <code>CentOS</code> 的社区属性。</p><p><img src="https://img.hi-linux.com/staticfile/sPPw5k-2021-05-03-lHmSRy.jpg" alt></p><p>自去年年底创立该项目以来，<code>Rocky</code> 企业软件基金会一直致力于在今年 3 月和 5 月之间推出一个版本。现在随着五月的到来，Rocky Linux 8.3 的首个候选发行版发布，下载镜像已放出。</p><blockquote><p>Gregory Kurtzer 述：今年最受期待的开源项目发布就在这里！这是 Rocky Linux 8.3 的第一个候选发行版的首次发布！Rocky 是社区企业操作系统，现在 CentOS 已成为 RHEL 的协作开发测试基地。特别感谢所有实现此版本的朋友。言出必行，Rocky Linux 已经准备就绪！</p></blockquote><p>关于 <code>Rocky Linux 8.3 RC1</code> 首发版本的下载和更多细节可以通过 <a href="http://RockyLinux.org" target="_blank" rel="noopener">RockyLinux.org</a> 找到：</p><blockquote><p>链接：<a href="https://forums.rockylinux.org/t/rocky-linux-8-3-rc1-available-now/2393" target="_blank" rel="noopener">https://forums.rockylinux.org/t/rocky-linux-8-3-rc1-available-now/2393</a></p></blockquote><a id="more"></a><p><img src="https://img.hi-linux.com/staticfile/7kEryp-2021-05-03-ViaDUt.jpg" alt></p><p><strong>Rocky Linux 8.3 官方下载地址：</strong></p><ul><li><a href="https://rockylinux.org/download/" target="_blank" rel="noopener">https://rockylinux.org/download/</a></li></ul><p>为方便国内 Rocky Linux 爱好者下载试用，Rocky Linux 中文社区已经提供了多种下载方式，包括：<code>迅雷VIP</code>、<code>BT下载</code>、<code>百度网盘</code>、<code>天翼云盘</code>等（在此感谢社区爱好者），欢迎大家下载试用。</p><p><strong>Rocky Linux 中文社区下载链接：</strong></p><ul><li><a href="https://rockylinux.cn/rocky-linux-mirror-download.html" target="_blank" rel="noopener">https://rockylinux.cn/rocky-linux-mirror-download.html</a></li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年 12 月份，&lt;code&gt;CentOS&lt;/code&gt; 官网正式宣布，将停止维护 &lt;code&gt;CentOS Linux&lt;/code&gt;，并将更多资金和人力投入到 &lt;code&gt;CentOS Stream&lt;/code&gt; 中。而 &lt;code&gt;Rocky Linux&lt;/code&gt; 是红帽宣布放弃 &lt;code&gt;CentOS Linux&lt;/code&gt; 后，由 &lt;code&gt;CentOS&lt;/code&gt; 联合创始人 &lt;code&gt;Gregory Kurtzer&lt;/code&gt; 创建的 &lt;code&gt;CentOS&lt;/code&gt; 发行版，旨在继承 &lt;code&gt;CentOS&lt;/code&gt; 的社区属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/sPPw5k-2021-05-03-lHmSRy.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;自去年年底创立该项目以来，&lt;code&gt;Rocky&lt;/code&gt; 企业软件基金会一直致力于在今年 3 月和 5 月之间推出一个版本。现在随着五月的到来，Rocky Linux 8.3 的首个候选发行版发布，下载镜像已放出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gregory Kurtzer 述：今年最受期待的开源项目发布就在这里！这是 Rocky Linux 8.3 的第一个候选发行版的首次发布！Rocky 是社区企业操作系统，现在 CentOS 已成为 RHEL 的协作开发测试基地。特别感谢所有实现此版本的朋友。言出必行，Rocky Linux 已经准备就绪！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于 &lt;code&gt;Rocky Linux 8.3 RC1&lt;/code&gt; 首发版本的下载和更多细节可以通过 &lt;a href=&quot;http://RockyLinux.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RockyLinux.org&lt;/a&gt; 找到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://forums.rockylinux.org/t/rocky-linux-8-3-rc1-available-now/2393&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://forums.rockylinux.org/t/rocky-linux-8-3-rc1-available-now/2393&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="教程" scheme="https://www.hi-linux.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款在 Kubernetes 中部署 Kubernetes 的神器 Vcluster</title>
    <link href="https://www.hi-linux.com/posts/19025.html"/>
    <id>https://www.hi-linux.com/posts/19025.html</id>
    <published>2021-04-26T01:00:00.000Z</published>
    <updated>2021-04-26T02:06:32.177Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Vcluster</code> 是一个可以在 <code>Kubernetes</code> 集群中快速创建 <code>Kubernetes</code> 虚拟集群的实用工具。</p><blockquote><p>项目地址：<a href="https://github.com/loft-sh/vcluster" target="_blank" rel="noopener">https://github.com/loft-sh/vcluster</a></p></blockquote><h2><span id="什么是虚拟-kubernetes-集群">什么是虚拟 Kubernetes 集群？</span></h2><p>虚拟集群是运行在其它 <code>Kubernetes</code> 集群之上的 <code>Kubernetes</code> 集群。与完全独立的 “真实” 集群相比，虚拟集群没有自己的节点池。相反，它们是在底层集群内调度工作负载，同时拥有自己的控制平面。</p><h3><span id="虚拟-kubernetes-集群的特性">虚拟 Kubernetes 集群的特性</span></h3><ul><li>轻量级和低开销</li></ul><p>它是基于 <code>K3S</code>，捆绑在一个 <code>Pod</code> 中，具有超低的资源消耗。</p><ul><li>无性能损耗</li></ul><p>所有的 Pod 被调度在底层主机集群中，因此它们在运行时不会受到任何性能影响。</p><ul><li>减少主机集群的开销</li></ul><p>将大型多租户集群分割成较小的 <code>Vcluster</code> ，以减少复杂性并提高可扩展性。</p><ul><li>灵活而简单的配置</li></ul><p>你可以通过 <code>Vcluster CLI</code>、<code>Helm</code>、<code>Kubectl</code>、<code>Argo</code> 等任何工具来创建（它基本上只是一个 <code>StatefulSet</code>）。</p><ul><li>不需要管理权限</li></ul><p>如果你能将 <code>Web</code> 应用部署到 <code>Kubernetes</code> 命名空间，你也能部署 <code>Vcluster</code>。</p><ul><li>单一命名空间封装</li></ul><p>每个 <code>Vcluster</code> 及其所有的工作负载都在底层主机集群的单一命名空间内。</p><ul><li>易于清理</li></ul><p>删除主机命名空间，<code>Vcluster</code> 及其所有工作负载将立即被清除。</p><h3><span id="vcluster-架构图">Vcluster 架构图</span></h3><p><img src="https://img.hi-linux.com/staticfile/Vcluster1-2021-04-23-TlW8dG.png" alt="Vcluster 架构图"></p><a id="more"></a><h2><span id="使用-vcluster-创建-kubernetes-虚拟集群">使用 Vcluster 创建 Kubernetes 虚拟集群</span></h2><h3><span id="安装-vcluster-cli">安装 vcluster CLI</span></h3><ol><li>下载并安装 vcluster CLI</li></ol><p><code>vcluster CLI</code> 是使用 <code>Go</code> 语言开发的，只需根据你所使用的平台下载相应软件包并将其放到相应路径即可完成安装。</p><ul><li>Mac (Intel/AMD)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s -L &quot;https:&#x2F;&#x2F;github.com&#x2F;loft-sh&#x2F;vcluster&#x2F;releases&#x2F;latest&quot; | sed -nE &#39;s!.*&quot;([^&quot;]*vcluster-darwin-amd64)&quot;.*!https:&#x2F;&#x2F;github.com\1!p&#39; | xargs -n 1 curl -L -o vcluster &amp;&amp; chmod +x vcluster;</span><br><span class="line">$ sudo mv vcluster &#x2F;usr&#x2F;local&#x2F;bin;</span><br></pre></td></tr></table></figure><ul><li>Mac (Silicon/ARM)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s -L &quot;https:&#x2F;&#x2F;github.com&#x2F;loft-sh&#x2F;vcluster&#x2F;releases&#x2F;latest&quot; | sed -nE &#39;s!.*&quot;([^&quot;]*vcluster-darwin-arm64)&quot;.*!https:&#x2F;&#x2F;github.com\1!p&#39; | xargs -n 1 curl -L -o vcluster &amp;&amp; chmod +x vcluster;</span><br><span class="line">$ sudo mv vcluster &#x2F;usr&#x2F;local&#x2F;bin;</span><br></pre></td></tr></table></figure><ul><li>Linux (AMD)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s -L &quot;https:&#x2F;&#x2F;github.com&#x2F;loft-sh&#x2F;vcluster&#x2F;releases&#x2F;latest&quot; | sed -nE &#39;s!.*&quot;([^&quot;]*vcluster-linux-amd64)&quot;.*!https:&#x2F;&#x2F;github.com\1!p&#39; | xargs -n 1 curl -L -o vcluster &amp;&amp; chmod +x vcluster;</span><br><span class="line">$ sudo mv vcluster &#x2F;usr&#x2F;local&#x2F;bin;</span><br></pre></td></tr></table></figure><ul><li>Linux (ARM)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s -L &quot;https:&#x2F;&#x2F;github.com&#x2F;loft-sh&#x2F;vcluster&#x2F;releases&#x2F;latest&quot; | sed -nE &#39;s!.*&quot;([^&quot;]*vcluster-linux-arm64)&quot;.*!https:&#x2F;&#x2F;github.com\1!p&#39; | xargs -n 1 curl -L -o vcluster &amp;&amp; chmod +x vcluster;</span><br><span class="line">$ sudo mv vcluster &#x2F;usr&#x2F;local&#x2F;bin;</span><br></pre></td></tr></table></figure><ul><li>Windows (Powershell)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ md -Force &quot;$Env:APPDATA\vcluster&quot;; [System.Net.ServicePointManager]::SecurityProtocol &#x3D; [System.Net.SecurityProtocolType]&#39;Tls,Tls11,Tls12&#39;;</span><br><span class="line">$ Invoke-WebRequest -UseBasicParsing ((Invoke-WebRequest -URI &quot;https:&#x2F;&#x2F;github.com&#x2F;loft-sh&#x2F;vcluster&#x2F;releases&#x2F;latest&quot; -UseBasicParsing).Content -replace &quot;(?ms).*&#96;&quot;([^&#96;&quot;]*vcluster-windows-amd64.exe)&#96;&quot;.*&quot;,&quot;https:&#x2F;&#x2F;github.com&#x2F;&#96;$1&quot;) -o $Env:APPDATA\vcluster\vcluster.exe;</span><br><span class="line">$ $env:Path +&#x3D; &quot;;&quot; + $Env:APPDATA + &quot;\vcluster&quot;;</span><br><span class="line">$ [Environment]::SetEnvironmentVariable(&quot;Path&quot;, $env:Path, [System.EnvironmentVariableTarget]::User);</span><br></pre></td></tr></table></figure><blockquote><p>如果你在安装后收到 <code>Windows</code> 找不到 <code>Vcluster</code> 的错误，你将需要重新启动你的计算机，来应用 <code>PATH</code> 变量的修改。</p></blockquote><ol start="2"><li>确认 Vcluster CLI 已正确安装</li></ol><p>要确认 <code>Vcluster CLI</code> 已成功安装，可通过以下方式进行测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vcluster --version</span><br></pre></td></tr></table></figure><h3><span id="创建虚拟集群">创建虚拟集群</span></h3><ol><li>通过 Vcluster CLI 部署虚拟集群</li></ol><p>通过 <code>Vcluster CLI</code> 创建虚拟集群非常的简单，只需一条指定便可完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vcluster create vcluster-1 -n host-namespace-1</span><br></pre></td></tr></table></figure><blockquote><p>注：在使用 <code>Vcluster CLI</code> 前，确定你已经在本地配置好一个可以访问 <code>Kubernetes</code> 集群的环境。（可通过 <code>kubectl</code> 命令获取命名空间进行检查。）</p></blockquote><p>当然如果你不想安装 <code>Vcluster CLI</code>，也可以通过 <code>Helm</code> 和 <code>Kubectl</code> 直接部署虚拟集群。</p><ol start="2"><li>通过 Helm 部署虚拟集群</li></ol><p>首先建立一个部署文件，这里命名为 vcluster.yaml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat vcluster.yaml</span><br><span class="line">vcluster:</span><br><span class="line">  image: rancher&#x2F;k3s:v1.19.5-k3s2    </span><br><span class="line">  extraArgs:</span><br><span class="line">    - --service-cidr&#x3D;10.96.0.0&#x2F;12    </span><br><span class="line">  baseArgs:</span><br><span class="line">    - server</span><br><span class="line">    - --write-kubeconfig&#x3D;&#x2F;k3s-config&#x2F;kube-config.yaml</span><br><span class="line">    - --data-dir&#x3D;&#x2F;data</span><br><span class="line">    - --no-deploy&#x3D;traefik,servicelb,metrics-server,local-storage</span><br><span class="line">    - --disable-network-policy</span><br><span class="line">    - --disable-agent</span><br><span class="line">    - --disable-scheduler</span><br><span class="line">    - --disable-cloud-controller</span><br><span class="line">    - --flannel-backend&#x3D;none</span><br><span class="line">    - --kube-controller-manager-arg&#x3D;controllers&#x3D;*,-nodeipam,-nodelifecycle,-persistentvolume-binder,-attachdetach,-persistentvolume-expander,-cloud-node-lifecycle</span><br><span class="line">storage:</span><br><span class="line">  size: 5Gi</span><br></pre></td></tr></table></figure><p>然后使用 <code>Helm</code> 完成部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ helm upgrade --install vcluster-1 vcluster \</span><br><span class="line">  --values vcluster.yaml \</span><br><span class="line">  --repo https:&#x2F;&#x2F;charts.loft.sh \</span><br><span class="line">  --namespace vcluster-1 \</span><br><span class="line">  --repository-config&#x3D;&#39;&#39;</span><br></pre></td></tr></table></figure><ol start="3"><li>通过 Kubectl 部署虚拟集群</li></ol><p>首先建立一个部署文件，这里命名为 vcluster.yaml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">$ cat vcluster.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: vcluster-1</span><br><span class="line">---</span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  name: vcluster-1</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;configmaps&quot;, &quot;secrets&quot;, &quot;services&quot;, &quot;services&#x2F;proxy&quot;, &quot;pods&quot;, &quot;pods&#x2F;proxy&quot;, &quot;pods&#x2F;attach&quot;, &quot;pods&#x2F;portforward&quot;, &quot;pods&#x2F;exec&quot;, &quot;pods&#x2F;log&quot;, &quot;events&quot;, &quot;endpoints&quot;, &quot;persistentvolumeclaims&quot;]</span><br><span class="line">    verbs: [&quot;*&quot;]</span><br><span class="line">  - apiGroups: [&quot;networking.k8s.io&quot;]</span><br><span class="line">    resources: [&quot;ingresses&quot;]</span><br><span class="line">    verbs: [&quot;*&quot;]</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;namespaces&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">  - apiGroups: [&quot;apps&quot;]</span><br><span class="line">    resources: [&quot;statefulsets&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">---</span><br><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  name: vcluster-1</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: vcluster-1</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: vcluster-1</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: vcluster-1</span><br><span class="line">spec:</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">    - name: https</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app: vcluster-1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: vcluster-1-headless</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: https</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      protocol: TCP</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: vcluster-1</span><br><span class="line">---</span><br><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: vcluster-1</span><br><span class="line">  labels:</span><br><span class="line">    app: vcluster-1</span><br><span class="line">spec:</span><br><span class="line">  serviceName: vcluster-1-headless</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: vcluster-1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: vcluster-1</span><br><span class="line">    spec:</span><br><span class="line">      terminationGracePeriodSeconds: 10</span><br><span class="line">      serviceAccountName: vcluster-1</span><br><span class="line">      containers:</span><br><span class="line">      - image: rancher&#x2F;k3s:v1.19.5-k3s2</span><br><span class="line">        name: virtual-cluster</span><br><span class="line">        command:</span><br><span class="line">          - &quot;&#x2F;bin&#x2F;k3s&quot;</span><br><span class="line">        args:</span><br><span class="line">          - &quot;server&quot;</span><br><span class="line">          - &quot;--write-kubeconfig&#x3D;&#x2F;k3s-config&#x2F;kube-config.yaml&quot;</span><br><span class="line">          - &quot;--data-dir&#x3D;&#x2F;data&quot;</span><br><span class="line">          - &quot;--disable&#x3D;traefik,servicelb,metrics-server,local-storage&quot;</span><br><span class="line">          - &quot;--disable-network-policy&quot;</span><br><span class="line">          - &quot;--disable-agent&quot;</span><br><span class="line">          - &quot;--disable-scheduler&quot;</span><br><span class="line">          - &quot;--disable-cloud-controller&quot;</span><br><span class="line">          - &quot;--flannel-backend&#x3D;none&quot;</span><br><span class="line">          - &quot;--kube-controller-manager-arg&#x3D;controllers&#x3D;*,-nodeipam,-nodelifecycle,-persistentvolume-binder,-attachdetach,-persistentvolume-expander,-cloud-node-lifecycle&quot;  </span><br><span class="line">          - &quot;--service-cidr&#x3D;10.96.0.0&#x2F;12&quot;  </span><br><span class="line">        volumeMounts:</span><br><span class="line">          - mountPath: &#x2F;data</span><br><span class="line">            name: data</span><br><span class="line">      - name: syncer</span><br><span class="line">        image: &quot;loftsh&#x2F;virtual-cluster:0.0.27&quot;</span><br><span class="line">        args:</span><br><span class="line">          - --service-name&#x3D;vcluster-1</span><br><span class="line">          - --suffix&#x3D;vcluster-1</span><br><span class="line">          - --owning-statefulset&#x3D;vcluster-1</span><br><span class="line">          - --out-kube-config-secret&#x3D;vcluster-1</span><br><span class="line">        volumeMounts:</span><br><span class="line">          - mountPath: &#x2F;data</span><br><span class="line">            name: data</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">    - metadata:</span><br><span class="line">        name: data</span><br><span class="line">      spec:</span><br><span class="line">        accessModes: [ &quot;ReadWriteOnce&quot; ]</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            storage: 5Gi</span><br></pre></td></tr></table></figure><p>然后使用 <code>Kubectl</code> 命令完成部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f vcluster.yaml</span><br></pre></td></tr></table></figure><h3><span id="使用虚拟集群">使用虚拟集群</span></h3><p>在使用虚拟集群前，你必须先完成端口转发和 <code>kube-config</code> 文件的配置。你可以通过下面的命令来完成它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vcluster connect vcluster-1 -n host-namespace-1</span><br><span class="line">$ export KUBECONFIG&#x3D;.&#x2F;kubeconfig.yaml</span><br><span class="line"># 或者</span><br><span class="line">$ vcluster connect vcluster-1 -n host-namespace-1 --update-current</span><br></pre></td></tr></table></figure><p>以上配置完成后，你就可以愉快的使用这个 <code>Kubernetes</code> 虚拟集群了，它的使用和正常的 <code>Kubernetes</code> 集群并无区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 通过 Kubectl 管理虚拟集群</span><br><span class="line">$ kubectl get namespace</span><br><span class="line">$ kubectl get pods -n kube-system</span><br><span class="line">$ kubectl create namespace demo-nginx</span><br><span class="line">$ kubectl create deployment nginx-deployment -n demo-nginx --image&#x3D;nginx</span><br><span class="line">$ kubectl get pods -n demo-nginx</span><br></pre></td></tr></table></figure><h3><span id="删除虚拟集群">删除虚拟集群</span></h3><p>通过 <code>Vcluster CLI</code> 删除虚拟集群同样也是非常的简单，只需一条指定便可完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vcluster delete vcluster-1 -n host-namespace-1</span><br></pre></td></tr></table></figure><p>你也可以直接使用 <code>kubectl</code> 命令直接删除相应命名空间。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Vcluster&lt;/code&gt; 是一个可以在 &lt;code&gt;Kubernetes&lt;/code&gt; 集群中快速创建 &lt;code&gt;Kubernetes&lt;/code&gt; 虚拟集群的实用工具。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/loft-sh/vcluster&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/loft-sh/vcluster&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是虚拟-Kubernetes-集群？&quot;&gt;什么是虚拟 Kubernetes 集群？&lt;/h2&gt;
&lt;p&gt;虚拟集群是运行在其它 &lt;code&gt;Kubernetes&lt;/code&gt; 集群之上的 &lt;code&gt;Kubernetes&lt;/code&gt; 集群。与完全独立的 “真实” 集群相比，虚拟集群没有自己的节点池。相反，它们是在底层集群内调度工作负载，同时拥有自己的控制平面。&lt;/p&gt;
&lt;h3 id=&quot;虚拟-Kubernetes-集群的特性&quot;&gt;虚拟 Kubernetes 集群的特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;轻量级和低开销&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它是基于 &lt;code&gt;K3S&lt;/code&gt;，捆绑在一个 &lt;code&gt;Pod&lt;/code&gt; 中，具有超低的资源消耗。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无性能损耗&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的 Pod 被调度在底层主机集群中，因此它们在运行时不会受到任何性能影响。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少主机集群的开销&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将大型多租户集群分割成较小的 &lt;code&gt;Vcluster&lt;/code&gt; ，以减少复杂性并提高可扩展性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;灵活而简单的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以通过 &lt;code&gt;Vcluster CLI&lt;/code&gt;、&lt;code&gt;Helm&lt;/code&gt;、&lt;code&gt;Kubectl&lt;/code&gt;、&lt;code&gt;Argo&lt;/code&gt; 等任何工具来创建（它基本上只是一个 &lt;code&gt;StatefulSet&lt;/code&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要管理权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你能将 &lt;code&gt;Web&lt;/code&gt; 应用部署到 &lt;code&gt;Kubernetes&lt;/code&gt; 命名空间，你也能部署 &lt;code&gt;Vcluster&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一命名空间封装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个 &lt;code&gt;Vcluster&lt;/code&gt; 及其所有的工作负载都在底层主机集群的单一命名空间内。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易于清理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;删除主机命名空间，&lt;code&gt;Vcluster&lt;/code&gt; 及其所有工作负载将立即被清除。&lt;/p&gt;
&lt;h3 id=&quot;Vcluster-架构图&quot;&gt;Vcluster 架构图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/Vcluster1-2021-04-23-TlW8dG.png&quot; alt=&quot;Vcluster 架构图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款 Kubernetes 应用性能分析工具 Kubectl Flame</title>
    <link href="https://www.hi-linux.com/posts/55077.html"/>
    <id>https://www.hi-linux.com/posts/55077.html</id>
    <published>2021-04-22T01:00:00.000Z</published>
    <updated>2021-04-22T01:29:53.539Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="什么是性能分析">什么是性能分析？</span></h2><p>性能分析是分析应用程序性能来改进代码质量的常用方法，最流行的可视化性能分析方法是生成火焰图。</p><p><img src="https://img.hi-linux.com/staticfile/640-2021-03-12-ogeYMt.jpg" alt></p><p>基于 Spring 框架的 Java 应用的火焰图</p><p>y轴是堆栈深度，x轴跨越样本总体。每个矩形都是一个函数，其中宽度显示它出现的频率，从左到右的排序并不重要 (堆栈按字母顺序排序)。</p><h2><span id="kubernetes-上的性能分析">Kubernetes 上的性能分析</span></h2><p>性能分析是一项较为复杂的任务，大多数探查器有两个主要问题：</p><ul><li>需要修改应用程序，通常可以通过将标志添加到执行命令或将一些性能分析库导入代码中来实现。</li><li>由于在分析过程中会严重影响性能，因此通常避免在生产环境中进行性能分析。</li></ul><p>选择正确的探查器可能会解决这些问题，但是这需要仔细去进行研究，并且通常取决于编程语言和操作系统。</p><p>在 Kubernetes 集群中运行的应用程序上执行分析时，会变得更加困难。需要部署一个包含配置文件修改的新容器镜像，而不是当前正在运行的容器。此外，当应用程序重新启动时，某些性能问题可能会消失，这就使得调试变得困难。</p><a id="more"></a><h2><span id="kubectl-flame">Kubectl flame</span></h2><p>Kubectl Flame 是一个 kubectl 插件，可以以较低的开销生成火焰图🔥来分析应用程序性能，无需进行任何应用程序修改或停机。</p><blockquote><p>项目仓库地址：<a href="https://github.com/VerizonMedia/kubectl-flame" target="_blank" rel="noopener">https://github.com/VerizonMedia/kubectl-flame</a></p></blockquote><h3><span id="安装">安装</span></h3><p>可以通过 Krew 来安装 <code>kubectl flame</code> 插件，一旦安装了 Krew，就可以通过如下命令进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl krew install flame</span><br></pre></td></tr></table></figure><h3><span id="使用要求">使用要求</span></h3><ul><li>支持的语言：Go、Java（任何基于JVM的语言）、Python 和 Ruby</li><li>使用 Docker 作为容器运行时的 Kubernetes 集群（已在 GKE，EKS 和 AKS 上测试）</li></ul><h3><span id="运行原理">运行原理</span></h3><p><code>kubectl-flame</code> 通过在与目标容器相同的节点上启动一个探查器来启动性能分析，大多数探查器将与目标容器共享一些资源：比如通过将 <code>hostPID</code> 设置为 true 来启用 PID 命名空间共享，通过挂载 <code>/var/lib/docker</code> 并查询 overlayFS 来启用文件系统共享。</p><p>在后台<code>kubectl-flame</code>使用 async-profiler 来为 Java 应用程序生成火焰图，通过共享<code>/tmp</code>文件夹与目标 JVM 进行交互，Golang 则支持基于 ebpf 分析，Python 支持基于 py-spy 进行分析。</p><p><img src="https://img.hi-linux.com/staticfile/640-20210312141618823-2021-03-12-Tdwboq.jpg" alt></p><p>kubectl flame 概述</p><h3><span id="使用实例">使用实例</span></h3><ol><li>分析 Kubernetes Pod</li></ol><p>分析 Java 应用 mypod 1分钟，并在将火焰图保存到 <code>/tmp/flamegraph.svg</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl flame mypod -t 1m --lang java -f &#x2F;tmp&#x2F;flamegraph.svg</span><br></pre></td></tr></table></figure><ol start="2"><li>分析基于 alpine 的容器</li></ol><p>在基于 alpine 的容器中分析 Java 应用程序需要使用 <code>--alpine</code> 标志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl flame mypod -t 1m -f &#x2F;tmp&#x2F;flamegraph.svg --lang Java --alpine</span><br></pre></td></tr></table></figure><blockquote><p><em>注意</em>：仅 Java 应用程序需要此 <code>--alpine</code> 标志，而 Go 分析则不需要该标志。</p></blockquote><ol start="3"><li>分析 sidecar 容器</li></ol><p>包含多个容器的 Pod 需要将目标容器指定为参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl flame mypod -t 1m --lang go -f &#x2F;tmp&#x2F;flamegraph.svg mycontainer</span><br></pre></td></tr></table></figure><blockquote><p>本文转载自：「 k8s技术圈 」，原文：<a href="http://t.cn/A6t8p02V%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">http://t.cn/A6t8p02V，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是性能分析？&quot;&gt;什么是性能分析？&lt;/h2&gt;
&lt;p&gt;性能分析是分析应用程序性能来改进代码质量的常用方法，最流行的可视化性能分析方法是生成火焰图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/640-2021-03-12-ogeYMt.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;基于 Spring 框架的 Java 应用的火焰图&lt;/p&gt;
&lt;p&gt;y轴是堆栈深度，x轴跨越样本总体。每个矩形都是一个函数，其中宽度显示它出现的频率，从左到右的排序并不重要 (堆栈按字母顺序排序)。&lt;/p&gt;
&lt;h2 id=&quot;Kubernetes-上的性能分析&quot;&gt;Kubernetes 上的性能分析&lt;/h2&gt;
&lt;p&gt;性能分析是一项较为复杂的任务，大多数探查器有两个主要问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要修改应用程序，通常可以通过将标志添加到执行命令或将一些性能分析库导入代码中来实现。&lt;/li&gt;
&lt;li&gt;由于在分析过程中会严重影响性能，因此通常避免在生产环境中进行性能分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择正确的探查器可能会解决这些问题，但是这需要仔细去进行研究，并且通常取决于编程语言和操作系统。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 集群中运行的应用程序上执行分析时，会变得更加困难。需要部署一个包含配置文件修改的新容器镜像，而不是当前正在运行的容器。此外，当应用程序重新启动时，某些性能问题可能会消失，这就使得调试变得困难。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>三种不同场景下的 Kubernetes 服务调试方法</title>
    <link href="https://www.hi-linux.com/posts/21833.html"/>
    <id>https://www.hi-linux.com/posts/21833.html</id>
    <published>2021-04-19T01:00:00.000Z</published>
    <updated>2021-04-19T03:41:05.883Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在开发、调试为生产环境下 K8s service 中的应用程序时，常常需要一些工具或者命令。本文介绍了三种不同场景下对应的解决方案以及工具。</p><blockquote><ul><li>作者：Erkan Erol</li><li>翻译：Bach（才云）</li><li>校对：木子（才云）</li></ul></blockquote><h2><span id="基本设置">基本设置</span></h2><p>以下解释了场景的基本设置：</p><p><img src="https://img.hi-linux.com/staticfile/640-20210317135843521-2021-03-17-e2IA9c.jpg" alt></p><p>我们有 3 个 service，service-front 通过入口暴露给外网。service-front 的后端服务是 service-middle，service-middle 的后端是 service-back。通信是通过 K8s service 完成的。</p><p>以下是安装该设置的必要命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create ns service-debug</span><br><span class="line">$ kubectl -n service-debug run service-back --image&#x3D;erkanerol&#x2F;service-back:v1 --port&#x3D;8080 --expose&#x3D;true --labels&#x3D;&quot;app&#x3D;back&quot;</span><br><span class="line">$ kubectl -n service-debug run service-middle --image&#x3D;erkanerol&#x2F;service-middle:v1 --port&#x3D;8081 --expose&#x3D;true --labels&#x3D;&quot;app&#x3D;middle&quot;</span><br><span class="line">$ kubectl -n service-debug run service-front --image&#x3D;erkanerol&#x2F;service-front:v1 --port&#x3D;8082 --expose&#x3D;true --labels&#x3D;&quot;app&#x3D;front&quot;</span><br></pre></td></tr></table></figure><blockquote><p>这是这些服务的源代码：<a href="https://github.com/erkanerol/service-examples-for-blog" target="_blank" rel="noopener">https://github.com/erkanerol/service-examples-for-blog</a></p></blockquote><a id="more"></a><h2><span id="工具1kubectl-port-forward">工具1：kubectl port-forward</span></h2><h3><span id="场景">场景：</span></h3><p>作为开发人员，我希望 service-back 可以直接发送一些请求，并在不影响其他 service 的情况下查看结果。</p><h3><span id="问题">问题：</span></h3><p>service-back 不会暴露在外网，所以我们不能直接向其发送请求。</p><h3><span id="解决方案">解决方案：</span></h3><p>使用 kubectl port-forward，可以打开从本地计算机到 service-back 集群中的隧道。</p><blockquote><p>可参考：<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#port-forward" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#port-forward</a></p></blockquote><h3><span id="步骤">步骤：</span></h3><p>在终端中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n service-debug port-forward service&#x2F;service-back 8080:8080</span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br></pre></td></tr></table></figure><p>然后在另一个终端中运行以下 curl 命令，以查看是否可以访问 service-back：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080</span><br><span class="line">Timestamp from back:1614508193</span><br></pre></td></tr></table></figure><h3><span id="实现原理">实现原理：</span></h3><p><img src="https://img.hi-linux.com/staticfile/640-20210317134229552-2021-03-17-ENK3sw.jpg" alt></p><p>kubectl 启动一个监听在 localhost:8080 的进程。它监控该端口并建立与 api-server 的连接，该连接将请求转发到 service-back。</p><h2><span id="工具2kubefwd">工具2：kubefwd</span></h2><h3><span id="场景">场景：</span></h3><p>作为开发人员，我希望在本地计算机上运行 service-front，以便在 IDE 中设置断点来调试应用程序。</p><h3><span id="问题">问题：</span></h3><p>service-front 被设计为，在 Kubernetes 中运行并可以通过 K8s service 访问 service-middle。service 名称是硬编码的，或者很难配置的，又或者我们懒得在本地计算机上模拟依赖项。</p><h3><span id="解决方案">解决方案：</span></h3><p>kubefwd 是解决该问题的有用工具。它可以执行批量端口转发并管理本地计算机中的 DNS 记录。</p><blockquote><p>可参考：<a href="https://github.com/txn2/kubefwd" target="_blank" rel="noopener">https://github.com/txn2/kubefwd</a></p></blockquote><h3><span id="步骤">步骤：</span></h3><p>在终端中运行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo KUBECONFIG&#x3D;$KUBECONFIG kubefwd svc -n service-debug -l app&#x3D;middle</span><br></pre></td></tr></table></figure><p>请注意，kubefwd 需要 root 特权，并且必须使用 sudo 运行。事先设置 KUBECONFIG 变量，不需要任何主文件夹引用。</p><p>在另一个终端中，在本地计算机上运行 front 应用程序。注意，我们也可以在调试模式下运行它并设置断点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;tmp</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;erkanerol&#x2F;service-examples-for-blog.git</span><br><span class="line">$ cd service-examples-for-blog&#x2F;front</span><br><span class="line">$ go run main.go</span><br></pre></td></tr></table></figure><p>再在另一个终端中，向 front 应用发送请求，以查看 front 应用在本地提供服务，并且可以在集群中访问 service-middle。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8082</span><br><span class="line">Response from service middle:&#39;Response from service back:&#39;Timestamp from back:1614513901&#39;&#39;</span><br></pre></td></tr></table></figure><h3><span id="实现原理">实现原理：</span></h3><p><img src="https://img.hi-linux.com/staticfile/640-20210317135852855-2021-03-17-VCN08D.jpg" alt></p><p>从 kubefwd 的日志中可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">INFO[14:07:38] &#39;cat &#x2F;etc&#x2F;hosts&#39; to see all host entries.</span><br><span class="line">INFO[14:07:38] Loaded hosts file &#x2F;etc&#x2F;hosts</span><br><span class="line">INFO[14:07:38] HostFile management: Original hosts backup already exists at &#x2F;root&#x2F;hosts.original</span><br><span class="line">...</span><br><span class="line">INFO[14:07:38] Port-Forward: 127.1.27.1 service-middle:8081 to pod service-middle:8081</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>它启动一个进程，监听在 127.1.27.1:8081，并配置了 service-middle 的 /etc/hosts：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;hosts |grep service-middle</span><br><span class="line">127.1.27.1       service-middle.default service-middle.default.svc service-middle.default.svc.cluster.local service-middle.default.minikube service-middle.default.svc.minikube service-middle.default.svc.cluster.minikube service-middle service-middle.service-debug service-middle.service-debug.svc service-middle.service-debug.svc.cluster.local service-middle.service-debug.minikube service-middle.service-debug.svc.minikube service-middle.service-debug.svc.cluster.minikube</span><br></pre></td></tr></table></figure><p>然后，本地 front 应用程序可以像访问 K8s 集群一样访问 service-middle，而无需其他额外的工作。</p><h2><span id="工具3telepresence">工具3：telepresence</span></h2><h3><span id="场景">场景：</span></h3><p>作为开发人员，我希望在本地计算机上运行 service-middle，以便可以在 IDE 中设置断点来调试应用程序。</p><h3><span id="问题">问题：</span></h3><p>service-middle 设计为可在 Kubernetes 中运行，可通过 K8s service 访问 service-back。另外，它的 service-front 正在 K8s 上运行。这些 service 在本地计算机上不可用，而且我们也很难在本地计算机上模拟这些环境。</p><h3><span id="解决方案">解决方案：</span></h3><p>telepresence 是解决此问题的有用工具。</p><blockquote><p>可参考：<a href="https://www.telepresence.io/" target="_blank" rel="noopener">https://www.telepresence.io/</a></p></blockquote><h3><span id="步骤">步骤：</span></h3><p>首先从 K8s 集群中删除 service-middle。我们在本地运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n service-debug delete service service-middle --ignore-not-found&#x3D;true</span><br><span class="line">$ kubectl -n service-debug delete pod service-middle --ignore-not-found&#x3D;true</span><br></pre></td></tr></table></figure><p>为 service-middle 运行 telepresence：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  telepresence --namespace service-debug --new-deployment service-middle --expose 8081</span><br></pre></td></tr></table></figure><p>在另一个终端中，在本地计算机上运行 middle 应用程序。注意，我们也可以在调试模式下运行并设置断点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;tmp</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;erkanerol&#x2F;service-examples-for-blog.git</span><br><span class="line">$ cd service-examples-for-blog&#x2F;middle</span><br><span class="line">$ go run main.go</span><br></pre></td></tr></table></figure><p>再在另一个终端中，运行以下命令以通过集群中的临时 Pod 发送请求至 service-front ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n service-debug run curl -it  --rm&#x3D;true --image&#x3D;curlimages&#x2F;curl --restart&#x3D;Never -- http:&#x2F;&#x2F;service-front:8082Response from service middle:&#39;</span><br><span class="line">Response from service back:&#39;Timestamp from back:1614517363&#39;&#39;pod &quot;curl&quot; deleted</span><br></pre></td></tr></table></figure><p>要注意，这里的请求将转到 K8s 中的 service-front，K8s 将请求发送到本地计算机中的 service-middle，本地计算机再将请求发送到集群中的 service-back。</p><h3><span id="实现原理">实现原理：</span></h3><p><img src="https://img.hi-linux.com/staticfile/640-20210317135905079-2021-03-17-LvNbRd.jpg" alt></p><p>实际上，telepresence 将 proxy、fake agent 部署到集群中，并通过该代理在本地环境和集群之间打开一条双向通道。这样一来，我们便可以在本地计算机上运行 middle service，而无需调整 consumers、dependent service。</p><blockquote><p>telepresence 工作原理的详细说明，详见：<a href="https://www.telepresence.io/discussion/how-it-works" target="_blank" rel="noopener">https://www.telepresence.io/discussion/how-it-works</a></p></blockquote><h2><span id="小结">小结</span></h2><p>如果我们需要在不暴露 service 的情况下访问 service，kubectl port-forward 就足够了。</p><p>如果我们需要在本地运行 service 进行调试，并且 service 需要访问 K8s 上的其他 service ，kubefwd 可以发挥作用。它管理着本地计算机中的 DNS 记录，并为 service 依赖性打开从计算机到集群的单向通道。</p><p>如果我们需要在本地运行 service 进行调试，并且应用程序在集群中有一些使用方，那就使用telepresence。它可以打开双向网络通道，并将请求从集群转发至本地实例。</p><p>原文链接：<a href="https://erkanerol.github.io/post/debugging-k8s-services/" target="_blank" rel="noopener">https://erkanerol.github.io/post/debugging-k8s-services/</a></p><blockquote><p>本文转载自：「 K8sMeetup」，原文：<a href="http://t.cn/A6t1ABFC" target="_blank" rel="noopener">http://t.cn/A6t1ABFC</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发、调试为生产环境下 K8s service 中的应用程序时，常常需要一些工具或者命令。本文介绍了三种不同场景下对应的解决方案以及工具。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;作者：Erkan Erol&lt;/li&gt;
&lt;li&gt;翻译：Bach（才云）&lt;/li&gt;
&lt;li&gt;校对：木子（才云）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本设置&quot;&gt;基本设置&lt;/h2&gt;
&lt;p&gt;以下解释了场景的基本设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/640-20210317135843521-2021-03-17-e2IA9c.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们有 3 个 service，service-front 通过入口暴露给外网。service-front 的后端服务是 service-middle，service-middle 的后端是 service-back。通信是通过 K8s service 完成的。&lt;/p&gt;
&lt;p&gt;以下是安装该设置的必要命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ kubectl create ns service-debug&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ kubectl -n service-debug run service-back --image&amp;#x3D;erkanerol&amp;#x2F;service-back:v1 --port&amp;#x3D;8080 --expose&amp;#x3D;true --labels&amp;#x3D;&amp;quot;app&amp;#x3D;back&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ kubectl -n service-debug run service-middle --image&amp;#x3D;erkanerol&amp;#x2F;service-middle:v1 --port&amp;#x3D;8081 --expose&amp;#x3D;true --labels&amp;#x3D;&amp;quot;app&amp;#x3D;middle&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ kubectl -n service-debug run service-front --image&amp;#x3D;erkanerol&amp;#x2F;service-front:v1 --port&amp;#x3D;8082 --expose&amp;#x3D;true --labels&amp;#x3D;&amp;quot;app&amp;#x3D;front&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;这是这些服务的源代码：&lt;a href=&quot;https://github.com/erkanerol/service-examples-for-blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/erkanerol/service-examples-for-blog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>微软再推 Rust 语言免费中文教程，更香了！</title>
    <link href="https://www.hi-linux.com/posts/42443.html"/>
    <id>https://www.hi-linux.com/posts/42443.html</id>
    <published>2021-04-19T01:00:00.000Z</published>
    <updated>2021-04-20T05:03:32.420Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在过去的几个月，Amazon、Facebook、微软以及谷歌等科技巨头正疯狂吸纳人才市场上的 Rust 语言程序员。 Rust 人才的动向，也标志着该语言社区在发展进程中迎来了新的转折点。</p><p>这场 “抢人大战”，源自各方着力筹备的 Rust 团队组建计划。凭借着出色的内存效率、速度与安全性，Rust 语言近年来的优势地位愈发明显。事实上，Rust 正越来越被视为 Go 以及 C++/C 等传统编程语言的现代替代选项。</p><p>各大厂商开始使用 Rust 语言支持从网站到开发者工具、再到电子游戏的多种应用场景。Facebook 一直在使用 Rust 语言构建 Diem 币（即原 Libra 币），Amazon 则使用 Rust 为其无服务器平台 Lambda（此平台允许开发者在无需管理底层服务器的前提下，轻松运行并扩展开发代码）等产品编写代码。</p><blockquote><p>Rust 语言是一种高效、可靠的通用高级语言。其高效不仅限于开发效率，它的执行效率也是令人称赞的，是一种少有的兼顾开发效率和执行效率的语言。</p><p>Rust 语言由 Mozilla 开发，最早发布于 2014 年 9 月。Rust 的编译器是在 MIT License 和 Apache License 2.0 双重协议声明下的免费开源软件。</p></blockquote><a id="more"></a><p>简而言之，就是一句话，Rust 编程语言越来越受欢迎了，如果你最近也正想学习这门语言，那真是来对地方了，微软最近开放了一个 Rust 教程，最关键的是还有中文版。</p><p><img src="https://img.hi-linux.com/staticfile/image-20210420101730237-2021-04-20-RwaIqE.png" alt="image-20210420101730237"></p><p>通过这份教程， 你将打下使用 Rust 构建快速、高效的程序所需的知识基础。</p><p>在此学习路径下，你将：</p><ul><li><p>安装编写第一批 Rust 代码所需的工具。</p></li><li><p>了解 Rust 中的基本概念。</p></li><li><p>了解如何处理错误。</p></li><li><p>在 Rust 中管理内存。</p></li><li><p>使用泛型类型和特征。</p></li><li><p>为包和箱设置模块。</p></li><li><p>编写并运行自动测试。</p></li><li><p>创建命令行程序。</p></li></ul><p>下面，我们一起来看看部分学习模块：</p><h3><span id="rust-入门">Rust 入门</span></h3><p><img src="https://img.hi-linux.com/staticfile/image-20210420102532317-2021-04-20-IiJ0AY.png" alt="image-20210420102532317"></p><p>在此模块中，了解如何开始使用 Rust - 设置环境、编写程序和使用 Cargo 生成系统。</p><h3><span id="了解-rust-中的常见概念">了解 Rust 中的常见概念</span></h3><p><img src="https://img.hi-linux.com/staticfile/image-20210420103101356-2021-04-20-R9GuUV.png" alt="image-20210420103101356"></p><p>这一模块中你将了解 Rust 的基础知识。 浏览变量、数据类型、结构、枚举、函数、索引、哈希映射和流控制。</p><h3><span id="在-rust-中处理错误">在 Rust 中处理错误</span></h3><p><img src="https://img.hi-linux.com/staticfile/image-20210420103246334-2021-04-20-GtOzn4.png" alt="image-20210420103246334"></p><p>在本模块中，你将了解在 Rust 中处理错误的方法。</p><h3><span id="了解-rust-如何管理内存">了解 Rust 如何管理内存</span></h3><p><img src="https://img.hi-linux.com/staticfile/image-20210420103303241-2021-04-20-6FbjVS.png" alt="image-20210420103303241"></p><p>这一模块了解让 Rust 如此与众不同的特性：所有权和借用。</p><p>看完前几章的介绍，不知道你是否对 Rust 语言感兴趣呢？欲查看完整课程的地址，可在公众号后台回复：「微软Rust」获取 。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在过去的几个月，Amazon、Facebook、微软以及谷歌等科技巨头正疯狂吸纳人才市场上的 Rust 语言程序员。 Rust 人才的动向，也标志着该语言社区在发展进程中迎来了新的转折点。&lt;/p&gt;
&lt;p&gt;这场 “抢人大战”，源自各方着力筹备的 Rust 团队组建计划。凭借着出色的内存效率、速度与安全性，Rust 语言近年来的优势地位愈发明显。事实上，Rust 正越来越被视为 Go 以及 C++/C 等传统编程语言的现代替代选项。&lt;/p&gt;
&lt;p&gt;各大厂商开始使用 Rust 语言支持从网站到开发者工具、再到电子游戏的多种应用场景。Facebook 一直在使用 Rust 语言构建 Diem 币（即原 Libra 币），Amazon 则使用 Rust 为其无服务器平台 Lambda（此平台允许开发者在无需管理底层服务器的前提下，轻松运行并扩展开发代码）等产品编写代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rust 语言是一种高效、可靠的通用高级语言。其高效不仅限于开发效率，它的执行效率也是令人称赞的，是一种少有的兼顾开发效率和执行效率的语言。&lt;/p&gt;
&lt;p&gt;Rust 语言由 Mozilla 开发，最早发布于 2014 年 9 月。Rust 的编译器是在 MIT License 和 Apache License 2.0 双重协议声明下的免费开源软件。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Rust" scheme="https://www.hi-linux.com/categories/Rust/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="微软" scheme="https://www.hi-linux.com/tags/%E5%BE%AE%E8%BD%AF/"/>
    
      <category term="Rust" scheme="https://www.hi-linux.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>巧用 Docker Compose 管理 GPU 资源</title>
    <link href="https://www.hi-linux.com/posts/14919.html"/>
    <id>https://www.hi-linux.com/posts/14919.html</id>
    <published>2021-04-16T01:00:00.000Z</published>
    <updated>2021-04-16T03:17:43.760Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>在容器中使用 GPU 一直是使用 Compose 的一个痛点！</strong></p></blockquote><p>在面向 <code>AI</code> 开发的大趋势下，容器化可以将环境无缝迁移，将配置环境的成本无限降低。但是，在容器中配置 <code>CUDA</code> 并运行 <code>TensorFlow</code> 一段时间内确实是个比较麻烦的时候，所以我们这里就介绍和使用它。</p><ul><li><a href="https://docs.docker.com/compose/gpu-support/" target="_blank" rel="noopener">Enabling GPU access with Compose</a></li><li><a href="https://docs.docker.com/config/containers/resource_constraints/#gpu" target="_blank" rel="noopener">Runtime options with Memory, CPUs, and GPUs</a></li><li><a href="https://github.com/compose-spec/compose-spec/blob/master/spec.md" target="_blank" rel="noopener">The Compose Specification</a></li><li><a href="https://github.com/compose-spec/compose-spec/blob/master/deploy.md#devices" target="_blank" rel="noopener">The Compose Specification - Deployment support</a></li><li><a href="https://github.com/compose-spec/compose-spec/blob/master/build.md" target="_blank" rel="noopener">The Compose Specification - Build support</a></li></ul><p><strong>在 Compose 中使用 GPU 资源</strong></p><ul><li>如果我们部署 <code>Docker</code> 服务的的主机上正确安装并设置了其对应配置，且该主机上恰恰也有对应的 <code>GPU</code> 显卡，那么就可以在 <code>Compose</code> 中来定义和设置这些 <code>GPU</code> 显卡了。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要安装的配置</span></span><br><span class="line">$ apt-get install nvidia-container-runtime</span><br></pre></td></tr></table></figure><ul><li><strong>旧版本 &lt;= 19.03</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># runtime</span></span><br><span class="line">$ docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi</span><br></pre></td></tr></table></figure><ul><li><strong>新版本 &gt;= 19.03</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with --gpus</span></span><br><span class="line">$ docker run -it --rm --gpus all ubuntu nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># use device</span></span><br><span class="line">$ docker run -it --rm --gpus \</span><br><span class="line">    device=GPU-3a23c669-1f69-c64e-cf85-44e9b07e7a2a \</span><br><span class="line">    ubuntu nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># specific gpu</span></span><br><span class="line">$ docker run -it --rm --gpus <span class="string">'"device=0,2"'</span> ubuntu nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># set nvidia capabilities</span></span><br><span class="line">$ docker run --gpus <span class="string">'all,capabilities=utility'</span> --rm ubuntu nvidia-smi</span><br></pre></td></tr></table></figure><ul><li>对应 <code>Compose</code> 工具的老版本(<code>v2.3</code>)配置文件来说的话，想要在部署的服务当中使用 <code>GPU</code> 显卡资源的话，就必须使用 <strong><code>runtime</code></strong> 参数来进行配置才可以。虽然可以作为运行时为容器提供 <code>GPU</code> 的访问和使用，但是在该模式下并不允许对 <code>GPU</code> 设备的特定属性进行控制。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">test:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nvidia/cuda:10.2-base</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">nvidia-smi</span></span><br><span class="line">    <span class="attr">runtime:</span> <span class="string">nvidia</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NVIDIA_VISIBLE_DEVICES=all</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>在 <code>Compose v1.28.0+</code> 的版本中，使用 <code>Compose Specification</code> 的配置文件写法，并提供了一些可以更细粒度的控制 <code>GPU</code> 资源的配置属性可被使用，因此可以在启动的时候来精确表达我们的需求。咳咳咳，那这里我们就一起看看吧！</strong></p></blockquote><ul><li><code>capabilities</code> - 必须字段<ul><li>指定需要支持的功能；可以配置多个不同功能；必须配置的字段</li><li><code>man 7 capabilities</code></li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">reservations:</span></span><br><span class="line">      <span class="attr">devices:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">capabilities:</span> <span class="string">["gpu"]</span></span><br></pre></td></tr></table></figure><ul><li><code>count</code><ul><li>指定需要使用的<code>GPU</code>数量；值为<code>int</code>类型；与<code>device_ids</code>字段二选一</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">reservations:</span></span><br><span class="line">      <span class="attr">devices:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">capabilities:</span> <span class="string">["tpu"]</span></span><br><span class="line">          <span class="attr">count:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li><code>device_ids</code><ul><li>指定使用<code>GPU</code>设备<code>ID</code>值；与<code>count</code>字段二选一</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">reservations:</span></span><br><span class="line">      <span class="attr">devices:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">capabilities:</span> <span class="string">["gpu"]</span></span><br><span class="line">          <span class="attr">device_ids:</span> <span class="string">["0",</span> <span class="string">"3"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">reservations:</span></span><br><span class="line">      <span class="attr">devices:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">capabilities:</span> <span class="string">["gpu"]</span></span><br><span class="line">          <span class="attr">device_ids:</span> <span class="string">["GPU-f123d1c9-26bb-df9b-1c23-4a731f61d8c7"]</span></span><br></pre></td></tr></table></figure><ul><li><code>driver</code><ul><li>指定<code>GPU</code>设备驱动类型</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">reservations:</span></span><br><span class="line">      <span class="attr">devices:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">capabilities:</span> <span class="string">["nvidia-compute"]</span></span><br><span class="line">          <span class="attr">driver:</span> <span class="string">nvidia</span></span><br></pre></td></tr></table></figure><ul><li><code>options</code><ul><li>指定驱动程序的特定选项</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">reservations:</span></span><br><span class="line">      <span class="attr">devices:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">capabilities:</span> <span class="string">["gpu"]</span></span><br><span class="line">          <span class="attr">driver:</span> <span class="string">gpuvendor</span></span><br><span class="line">          <span class="attr">options:</span></span><br><span class="line">            <span class="attr">virtualization:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>咳咳咳，看也看了，说也说了，那我们就简单的编写一个示例文件，让启动的 <code>cuda</code> 容器服务来使用一个 <code>GPU</code> 设备资源，并运行得到如下输出。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">test:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nvidia/cuda:10.2-base</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">nvidia-smi</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br><span class="line">        <span class="attr">window:</span> <span class="string">120s</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">"0.50"</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">50M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">"0.25"</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">20M</span></span><br><span class="line">          <span class="attr">devices:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">driver:</span> <span class="string">nvidia</span></span><br><span class="line">              <span class="attr">count:</span> <span class="number">1</span></span><br><span class="line">              <span class="attr">capabilities:</span> <span class="string">[gpu,</span> <span class="string">utility]</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line">        <span class="attr">order:</span> <span class="string">stop-first</span></span><br></pre></td></tr></table></figure><ul><li>注意这里，如果设置 <code>count: 2</code> 的话，就会下面的输出中看到两块显卡设置的信息。如果，我们这里均未设置 <code>count</code> 或 <code>device_ids</code> 字段的话，则默认情况下将主机上所有 <code>GPU</code> 一同使用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前台直接运行</span></span><br><span class="line">$ docker-compose up</span><br><span class="line">Creating network <span class="string">"gpu_default"</span> with the default driver</span><br><span class="line">Creating gpu_test_1 ... <span class="keyword">done</span></span><br><span class="line">Attaching to gpu_test_1</span><br><span class="line">test_1  | +-----------------------------------------------------------------------------+</span><br><span class="line">test_1  | | NVIDIA-SMI 450.80.02    Driver Version: 450.80.02    CUDA Version: 11.1     |</span><br><span class="line">test_1  | |-------------------------------+----------------------+----------------------+</span><br><span class="line">test_1  | | GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">test_1  | | Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">test_1  | |                               |                      |               MIG M. |</span><br><span class="line">test_1  | |===============================+======================+======================|</span><br><span class="line">test_1  | |   0  Tesla T4            On   | 00000000:00:1E.0 Off |                    0 |</span><br><span class="line">test_1  | | N/A   23C    P8     9W /  70W |      0MiB / 15109MiB |      0%      Default |</span><br><span class="line">test_1  | |                               |                      |                  N/A |</span><br><span class="line">test_1  | +-------------------------------+----------------------+----------------------+</span><br><span class="line">test_1  |</span><br><span class="line">test_1  | +-----------------------------------------------------------------------------+</span><br><span class="line">test_1  | | Processes:                                                                  |</span><br><span class="line">test_1  | |  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">test_1  | |        ID   ID                                                   Usage      |</span><br><span class="line">test_1  | |=============================================================================|</span><br><span class="line">test_1  | |  No running processes found                                                 |</span><br><span class="line">test_1  | +-----------------------------------------------------------------------------+</span><br><span class="line">gpu_test_1 exited with code 0</span><br></pre></td></tr></table></figure><ul><li>当然，如果设置了 <code>count</code> 或 <code>device_ids</code> 字段的话，就可以在容器里面的程序中使用多块显卡资源了。可以通过以下部署配置文件来进行验证和使用。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">test:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tensorflow/tensorflow:latest-gpu</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">python</span> <span class="string">-c</span> <span class="string">"import tensorflow as tf;tf.test.gpu_device_name()"</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">devices:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">driver:</span> <span class="string">nvidia</span></span><br><span class="line">              <span class="attr">device_ids:</span> <span class="string">["0",</span> <span class="string">"3"</span><span class="string">]</span></span><br><span class="line">              <span class="attr">capabilities:</span> <span class="string">[gpu]</span></span><br></pre></td></tr></table></figure><ul><li>运行结果，如下所示，我们可以看到两块显卡均可以被使用到。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前台直接运行</span></span><br><span class="line">$ docker-compose up</span><br><span class="line">...</span><br><span class="line">Created TensorFlow device (/device:GPU:0 with 13970 MB memory -&gt; physical GPU (device: 0, name: Tesla T4, pci bus id: 0000:00:1b.0, compute capability: 7.5)</span><br><span class="line">...</span><br><span class="line">Created TensorFlow device (/device:GPU:1 with 13970 MB memory) -&gt; physical GPU (device: 1, name: Tesla T4, pci bus id: 0000:00:1e.0, compute capability: 7.5)</span><br><span class="line">...</span><br><span class="line">gpu_test_1 exited with code 0</span><br></pre></td></tr></table></figure><blockquote><p>本文转载自：「 Ecsape 的博客 」，原文：<a href="http://t.cn/A6c6d4l1" target="_blank" rel="noopener">http://t.cn/A6c6d4l1</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;div id=&quot;vip-container&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在容器中使用 GPU 一直是使用 Compose 的一个痛点！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在面向 &lt;code&gt;AI&lt;/code&gt;
        
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>重磅 | AWS 免费开源增强版 Elasticsearch 分支 OpenSearch</title>
    <link href="https://www.hi-linux.com/posts/50892.html"/>
    <id>https://www.hi-linux.com/posts/50892.html</id>
    <published>2021-04-15T01:00:00.000Z</published>
    <updated>2021-04-15T01:36:05.433Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>今年 1 月，开发 Elasticsearch 和 Kibana 的公司 Elastic 宣布更改许可证，新版本将不再使用 Apache 2.0 许可证，而是使用 Elastic 许可证和服务器端公共许可证（SSPL），此举是为了禁止类似亚马逊等云服务商使用它的软件作为一种服务提供给客户。但同时，新的许可证不再符合开源许可证的定义，意味着 Elasticsearch 和 Kibana 不再是开源软件了。</p><p>然后，亚马逊宣布要创建它的 Elasticsearch 分支 OpenSearch 和 Kibana 分支 OpenSearch Dashboards。</p><p>近日 AWS 宣布创建 “真正” 开源的 Elasticsearch 分支有了下文。 OpenSearch 的源代码托管在 GitHub 上。亚马逊表示以后所有的更新将通过 OpenSearch 项目发布。包括红帽、SAP、Capital One 和 <a href="http://Logz.io" target="_blank" rel="noopener">Logz.io</a> 等在内的多个组织对 AWS 创建 OpenSearch 项目表示了支持。</p><blockquote><p>OpenSearch 项目由 OpenSearch (fork Elasticsearch 7.10.2) 和 OpenSearch Dashboards (fork Kibana 7.10.2) 组成，包括企业安全、告警、机器学习、SQL、索引状态管理等功能。OpenSearch 项目中的所有软件均采用了 Apache License 2.0 开源许可协议。</p></blockquote><p><strong>OpenSearch 项目仓库地址</strong></p><ol><li>OpenSearch</li></ol><p>项目地址：<a href="https://github.com/opensearch-project/OpenSearch" target="_blank" rel="noopener">https://github.com/opensearch-project/OpenSearch</a></p><ol start="2"><li>OpenSearch Dashboards</li></ol><p>项目地址：<a href="https://github.com/opensearch-project/OpenSearch-Dashboards" target="_blank" rel="noopener">https://github.com/opensearch-project/OpenSearch-Dashboards</a></p><p>AWS 介绍称，他们推出的 OpenSearch 删除了 Elasticsearch 中受 Elastic 商业许可证限制的功能、代码和商标，以兼容 Apache License 2.0，自称这是每个人都可以构建和创新的基础，任何人无需签署 CLA (Contributor License Agreement) 即可为项目贡献代码。</p><p>此外，AWS 现有的 Amazon Elasticsearch Service 被重命名为 Amazon OpenSearch Service，AWS 表示更名不会影响正在运营的业务，Amazon OpenSearch Service 会提供一系列可供部署和运行的开源引擎，包括当前可用的 19 个版本的 Elasticsearch（7.9 和更早版本、近期推出的 7.10）以及新版本的 OpenSearch。</p><p>AWS 还说到会继续通过安全性和错误修复来支持和维护采用 Apache License 2.0 的 Elasticsearch，并将通过 OpenSearch 和 OpenSearch Dashboards 提供所有新功能。Amazon OpenSearch Service API 将与现有服务 API 向后兼容。此外，AWS 会提供从现有 Elasticsearch 6.x 和 7.x 托管集群迁移至 OpenSearch 的无缝升级路径。</p><p>AWS 表示，当前版本的代码尚处于 Alpha 阶段，未经彻底测试并且不适合用于生产环境。他们计划在接下来的几周内发布 Beta 版本，有望在 2021 年中期发布稳定版并投入生产环境使用。</p><blockquote><p>本文转载自：「 开源中国 」，原文：<a href="http://t.cn/A6cxOsxg" target="_blank" rel="noopener">http://t.cn/A6cxOsxg</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;div id=&quot;vip-container&quot;&gt;&lt;p&gt;今年 1 月，开发 Elasticsearch 和 Kibana 的公司 Elastic 宣布更改许可证，新版本将不再使用 Apache 2.0 许可证，而是使用 Elastic
        
      
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="https://www.hi-linux.com/categories/Elasticsearch/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="快迅" scheme="https://www.hi-linux.com/tags/%E5%BF%AB%E8%BF%85/"/>
    
      <category term="Elasticsearch" scheme="https://www.hi-linux.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>全链路分布式跟踪系统 Apache SkyWalking 入门教程</title>
    <link href="https://www.hi-linux.com/posts/13634.html"/>
    <id>https://www.hi-linux.com/posts/13634.html</id>
    <published>2021-04-09T01:00:00.000Z</published>
    <updated>2021-04-09T03:40:18.073Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="先决条件">先决条件</span></h2><p>确保有一套运行正常的 Kubernetes 集群，本文默认为使用 Elasticsearch7 作为后端存储；**如果想把 ES 放到 Kubernetes 集群里那么还得确保集群配置了正确的存储，譬如默认的 StorageClass 可用等。**本文为了方便起见(其实就是穷)采用外部 ES 存储且使用 docker-compose 单节点部署，所以不需要集群的分布式存储；最后确保你本地的 <code>kubectl</code> 能够正常运行。</p><h2><span id="基本架构">基本架构</span></h2><p>Skywalking 在大体上(不准确)分为四大部分:</p><ul><li>oap-server: 无状态服务后端，主要负责处理核心逻辑，可以简单理解为一个标准 java web 项目。</li><li>skywalking-ui: UI 前端，通过 graphql 连接 oap-server 提供用户查询等 UI 展示。</li><li>agent: 各种语言实现的 agent 负责抓取应用运行数据并上报给 oap-server，核心的指标上报来源。</li><li>DB: 各种数据库，负责存储 Skywalking 的指标数据，生产环境推荐 ES、TiDB、MySQL。</li></ul><a id="more"></a><h2><span id="部署-skywalking">部署 Skywalking</span></h2><h3><span id="31-部署-elasticsearch">3.1、部署 Elasticsearch</span></h3><p>Elasticsearch 当前使用 7.9.2 版本，由于只是初次尝试还处于测试阶段所以直接 docker-compose 启动一个单点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 如果有需要可以进入 es 容器使用以下命令设置密码</span><br><span class="line"># elasticsearch-setup-passwords interactive</span><br><span class="line">version: &#39;3.8&#39;</span><br><span class="line">services:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    container_name: elasticsearch</span><br><span class="line">    image: docker.elastic.co&#x2F;elasticsearch&#x2F;elasticsearch:7.9.2</span><br><span class="line">    restart: always</span><br><span class="line">    network_mode: &quot;host&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - data:&#x2F;data&#x2F;elasticsearch</span><br><span class="line">    environment:</span><br><span class="line">      - http.host&#x3D;172.16.11.43</span><br><span class="line">      - http.port&#x3D;9200</span><br><span class="line">      - transport.tcp.port&#x3D;172.16.11.43</span><br><span class="line">      - transport.tcp.port&#x3D;9300</span><br><span class="line">      - cluster.name&#x3D;skyes</span><br><span class="line">      - node.name&#x3D;skyes</span><br><span class="line">      - discovery.type&#x3D;single-node</span><br><span class="line">      - xpack.security.enabled&#x3D;true</span><br><span class="line">      - xpack.monitoring.enabled&#x3D;true</span><br><span class="line">      - &quot;ES_JAVA_OPTS&#x3D;-Xms4096m -Xmx7168m&quot;</span><br><span class="line">volumes:</span><br><span class="line">  data:</span><br></pre></td></tr></table></figure><h3><span id="32-安装-helm">3.2、安装 Helm</span></h3><p>由于 Skywalking 官方给出的 Kubernetes 安装方式为 Helm 安装，所以需要本地先安装 Helm；Helm 安装方式非常简单，根据官方文档<strong>在网络没问题的情况下</strong>直接执行以下命令即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;helm&#x2F;helm&#x2F;master&#x2F;scripts&#x2F;get-helm-3 | bash</span><br></pre></td></tr></table></figure><p>如果网络不是那么 OK 的情况下请参考<a href="https://helm.sh/docs/intro/install/" target="_blank" rel="noopener">官方文档</a>的包管理器方式安装或直接下载二进制文件安装。</p><h3><span id="33-克隆仓库初始化-helm">3.3、克隆仓库初始化 Helm</span></h3><p>Helm 部署之前按照<a href="https://github.com/apache/skywalking-kubernetes" target="_blank" rel="noopener">官方文档</a>提示需要先初始化 Helm 仓库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># clone helm 仓库</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;skywalking-kubernetes</span><br><span class="line">cd skywalking-kubernetes&#x2F;chart</span><br><span class="line"></span><br><span class="line"># 即使使用外部 ES 也要添加这个 repo，否则会导致依赖错误</span><br><span class="line">helm repo add elastic https:&#x2F;&#x2F;helm.elastic.co</span><br><span class="line">helm dep up skywalking</span><br><span class="line"></span><br><span class="line"># change the release name according to your scenario</span><br><span class="line">export SKYWALKING_RELEASE_NAME&#x3D;skywalking</span><br><span class="line"># 如果修改了 NAMESPACE，后续部署则需要先通过 kuebctl 创建该 NAMESPACE</span><br><span class="line"># change the namespace according to your scenario</span><br><span class="line">export SKYWALKING_RELEASE_NAMESPACE&#x3D;default</span><br></pre></td></tr></table></figure><h3><span id="34-安装-skywalking">3.4、安装 Skywalking</span></h3><p>Helm 初始化完成后需要自行调整配置文件，配置 oap-server 使用外部 ES</p><p><strong>values-my-es.yaml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">oap:</span><br><span class="line">  image:</span><br><span class="line">    tag: 8.1.0-es7      # Set the right tag according to the existing Elasticsearch version</span><br><span class="line">  storageType: elasticsearch7</span><br><span class="line"></span><br><span class="line">ui:</span><br><span class="line">  image:</span><br><span class="line">    tag: 8.1.0</span><br><span class="line"></span><br><span class="line">elasticsearch:</span><br><span class="line">  enabled: false</span><br><span class="line">  config:               # For users of an existing elasticsearch cluster,takes effect when &#96;elasticsearch.enabled&#96; is false</span><br><span class="line">    host: 172.16.11.43</span><br><span class="line">    port:</span><br><span class="line">      http: 9200</span><br><span class="line">    user: &quot;elastic&quot;</span><br><span class="line">    password: &quot;elastic&quot;</span><br></pre></td></tr></table></figure><p>调整好配置后只需要使用 Helm 安装即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm install &quot;$&#123;SKYWALKING_RELEASE_NAME&#125;&quot; skywalking -n &quot;$&#123;SKYWALKING_RELEASE_NAMESPACE&#125;&quot; \</span><br><span class="line">  -f .&#x2F;skywalking&#x2F;values-my-es.yaml --set oap.image.tag&#x3D;8.2.0-es7 --set ui.image.tag&#x3D;8.2.0</span><br></pre></td></tr></table></figure><p>如果安装出错或者其他问题可以使用以下命令进行卸载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm uninstall &quot;$&#123;SKYWALKING_RELEASE_NAME&#125;&quot; skywalking -n &quot;$&#123;SKYWALKING_RELEASE_NAMESPACE&#125;&quot;</span><br></pre></td></tr></table></figure><p>安装成功后应该在 <code>${SKYWALKING_RELEASE_NAMESPACE}</code> 下看到相关 Pod:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k8s21 ➜  ~ kubectl get pod -o wide -n skywalking</span><br><span class="line">NAME                              READY   STATUS      RESTARTS   AGE   IP             NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">skywalking-es-init-xw6tx          0&#x2F;1     Completed   0          32h   10.30.0.62     k8s21   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">skywalking-oap-64c65cc6bb-lnq82   1&#x2F;1     Running     0          32h   10.30.0.61     k8s21   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">skywalking-oap-64c65cc6bb-q7zj8   1&#x2F;1     Running     0          32h   10.30.32.103   k8s22   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">skywalking-ui-695ff9d69d-wqcm8    1&#x2F;1     Running     0          32h   10.30.161.42   k8s25   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>在确认 Pod 都运行正常后可以通过 <code>kubectl port-forward</code> 命令来查看 UI 界面:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行以下命令，访问 127.0.0.1:8080 即可访问到 skywalking-ui</span><br><span class="line">kubectl port-forward -n $&#123;SKYWALKING_RELEASE_NAMESPACE&#125; service&#x2F;skywalking-ui 8080:80</span><br></pre></td></tr></table></figure><p><strong>在生产环境可能需要配置正确的 Ingress 或者 NodePort 等方式暴露 skywalking-ui 服务，具体取决于生产集群服务暴露方式，请自行调整。</strong></p><h2><span id="agent-配置">Agent 配置</span></h2><blockquote><p>由于目前仅在 Java 项目上测试，所以以下 Agent 配置仅仅对 Java 项目有效。</p></blockquote><p>Skywalking 在简单使用时不需要侵入代码，对于 jar 包启动的项目只需要在启动时增加 <code>-javaagent</code> 选项即可。</p><h3><span id="41-agent-获取">4.1、Agent 获取</span></h3><p><code>javaagent</code> 可以通过下载对应的 skywalking release 安装包获取，将此 <code>agent</code> 目录解压到任意位置，稍后将添加到 java 启动参数。</p><p><a href="https://cdn.oss.link/markdown/y1q3k.png" target="_blank" rel="noopener"><img src="https://img.hi-linux.com/staticfile/y1q3k-2021-01-10-frobUo.png" alt="agent_dir"></a></p><p><a href="https://cdn.oss.link/markdown/y1q3k.png" target="_blank" rel="noopener">agent_dir</a></p><h3><span id="42-agent-配置">4.2、Agent 配置</span></h3><p>Agent 主配置文件存放在 <code>config/agent.config</code> 配置文件中，配置文件内支持环境变量读取，可以自行添加其他配置和引用其他变量；通常这个配置文件在容器化时有两种选择，**一种是创建 ConfigMap，然后通过 ConfigMap 挂载到容器里进行覆盖；另一种是在默认配置里引用各种变量，在容器启动时通过环境变量注入。**这里暂时使用环境变量注入的方式:</p><p><strong>agent.config</strong></p><p><a href="https://cdn.oss.link/markdown/4t67x.png" target="_blank" rel="noopener"><img src="https://img.hi-linux.com/staticfile/4t67x-2021-01-10-3Y4bcU.png" alt="agent.config"></a></p><p><a href="https://cdn.oss.link/markdown/4t67x.png" target="_blank" rel="noopener">agent.config</a></p><p><strong>deployment.yml</strong></p><p><a href="https://cdn.oss.link/markdown/q0uw7.png" target="_blank" rel="noopener"><img src="https://img.hi-linux.com/staticfile/q0uw7-2021-01-10-o1GxOG.png" alt="deployment.yml"></a></p><p><a href="https://cdn.oss.link/markdown/q0uw7.png" target="_blank" rel="noopener">deployment.yml</a></p><p>调整完成后，应用运行一段时间后应该能在 UI 中看到数据</p><p><a href="https://cdn.oss.link/markdown/86vmo.png" target="_blank" rel="noopener"><img src="https://img.hi-linux.com/staticfile/86vmo-2021-01-10-2BmbMj.png" alt="skwalking-ui"></a></p><p><a href="https://cdn.oss.link/markdown/86vmo.png" target="_blank" rel="noopener">skwalking-ui</a></p><h2><span id="注意事项">注意事项</span></h2><ul><li><strong>默认情况下 Helm 相关命令执行缓慢，可能需要设置 <code>http(s)_proxy</code> <code>...( ＿ ＿)ノ｜壁</code>(自行体会这个表情)</strong></li><li><strong>Skywalking 镜像一般比较大，下载缓慢，推荐预先拉取好然后 load 到每个节点</strong></li><li><strong>ES 如果设置了密码，不要忘记在 Helm 安装时调整好密码配置</strong></li><li><strong>jar 包启动时 <code>-javaagent</code> 不能放在 <code>-jar</code> 选项之后，否则可能不生效</strong></li><li><strong>集群内连接 oap-server 推荐通过 <code>skywalking-oap.skywalking.svc.cluster.local</code> 域名服务发现方式寻址</strong></li></ul><blockquote><p>本文转载自：「 Bleem 」，原文：<a href="https://tinyurl.com/y4uwbmmb" target="_blank" rel="noopener">https://tinyurl.com/y4uwbmmb</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先决条件&quot;&gt;先决条件&lt;/h2&gt;
&lt;p&gt;确保有一套运行正常的 Kubernetes 集群，本文默认为使用 Elasticsearch7 作为后端存储；**如果想把 ES 放到 Kubernetes 集群里那么还得确保集群配置了正确的存储，譬如默认的 StorageClass 可用等。**本文为了方便起见(其实就是穷)采用外部 ES 存储且使用 docker-compose 单节点部署，所以不需要集群的分布式存储；最后确保你本地的 &lt;code&gt;kubectl&lt;/code&gt; 能够正常运行。&lt;/p&gt;
&lt;h2 id=&quot;基本架构&quot;&gt;基本架构&lt;/h2&gt;
&lt;p&gt;Skywalking 在大体上(不准确)分为四大部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;oap-server: 无状态服务后端，主要负责处理核心逻辑，可以简单理解为一个标准 java web 项目。&lt;/li&gt;
&lt;li&gt;skywalking-ui: UI 前端，通过 graphql 连接 oap-server 提供用户查询等 UI 展示。&lt;/li&gt;
&lt;li&gt;agent: 各种语言实现的 agent 负责抓取应用运行数据并上报给 oap-server，核心的指标上报来源。&lt;/li&gt;
&lt;li&gt;DB: 各种数据库，负责存储 Skywalking 的指标数据，生产环境推荐 ES、TiDB、MySQL。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="SkyWalking" scheme="https://www.hi-linux.com/categories/SkyWalking/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="SkyWalking" scheme="https://www.hi-linux.com/tags/SkyWalking/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下自动化工具 Parallel SSH 中文使用指南</title>
    <link href="https://www.hi-linux.com/posts/53648.html"/>
    <id>https://www.hi-linux.com/posts/53648.html</id>
    <published>2021-03-31T01:00:00.000Z</published>
    <updated>2021-03-31T04:42:44.961Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>parallel-ssh 是为小规模自动化而设计的异步并行的 SSH 库!</strong></p></blockquote><p><strong><code>parallel-ssh</code></strong> 是为小规模自动化而设计的异步并行的 <code>SSH</code> 库，包括 <code>pssh</code>、<code>pscp</code>、<code>prsync</code>、<code>pslurp</code> 和 <code>pnuke</code>工具，其源代码使用 <code>Python</code>语言编写开发的。该项目最初位于<code>Google Code</code>上，是由<code>Brent N.Chun</code>编写和维护的，但是由于工作繁忙，<code>Brent</code>于<code>2009</code>年<code>10</code>月将维护工作移交给了<code>Andrew McNabb</code>管理。到了 <code>2012</code>年的时候，由于<code>Google Code</code>的已关闭，该项目一度被废弃，现在也只能在 <code>Google Code</code> 的归档中找到当时的版本了。</p><p>但是需要注意的是，之前的版本是不支持 <code>Python3</code> 的，但是 <code>Github</code> 上面有人 <code>Fork</code> 了一份，自己进行了改造使其支持 <code>Python3</code> 以上的版本了。与此同时，还有一个组织专门针对 <code>parallel-ssh</code> 进行了开发和维护，今天看了下很久都没有更新了。有需要的，自己可以自行查阅。</p><ul><li><p><a href="https://github.com/lilydjwg/pssh" target="_blank" rel="noopener">lilydjwg/pssh - supported on Python 3.5 and later</a></p></li><li><p><a href="https://github.com/ParallelSSH/parallel-ssh" target="_blank" rel="noopener">ParallelSSH/parallel-ssh - asynchronous parallel SSH client library</a></p></li><li><p>可扩展性</p><ul><li>支持扩展到百台，甚至上千台主机使用</li></ul></li><li><p>易于使用</p><ul><li>只需两行代码，即可在任意数量的主机上运行命令</li></ul></li><li><p>执行高效</p><ul><li>号称是最快的 <code>Python SSH</code> 库可用</li></ul></li><li><p>资源使用</p><ul><li>相比于其他 <code>Python SSH</code> 库，其消耗资源最少</li></ul></li></ul><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mac系统安装</span></span><br><span class="line">$ brew install pssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS系统安装</span></span><br><span class="line">$ yum install pssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu系统安装</span></span><br><span class="line">$ apt install pssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># PIP安装</span></span><br><span class="line">$ pip insall pssh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源代码编译安装(2.3.1)</span></span><br><span class="line"><span class="comment"># 官方地址: https://code.google.com/archive/p/parallel-ssh/source/default/source</span></span><br><span class="line">$ tar zxvf pssh-2.3.1.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> pssh-2.3.1</span><br><span class="line">$ python setup.py install</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/learn-pssh-command-1-2021-01-27-TVMY3S.png" alt="ParallelSSH在Google上面的版本"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工具对应的子命令子命令</span></span><br><span class="line">$ ls -lh /usr/<span class="built_in">local</span>/Cellar/pssh/2.3.1_1/bin/</span><br><span class="line">pnuke -&gt; ../libexec/bin/pnuke</span><br><span class="line">prsync -&gt; ../libexec/bin/prsync</span><br><span class="line">pscp -&gt; ../libexec/bin/pscp</span><br><span class="line">pslurp -&gt; ../libexec/bin/pslurp</span><br><span class="line">pssh -&gt; ../libexec/bin/pssh</span><br><span class="line">pssh-askpass -&gt; ../libexec/bin/pssh-askpass</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">子命令</th><th style="text-align:left">对应功能解释</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong><code>pssh</code></strong></td><td style="text-align:left">通过 ssh 协议在多台主机上并行地运行命令</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong><code>pscp</code></strong></td><td style="text-align:left">通过 ssh 协议把文件并行地复制到多台主机上</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong><code>rsync</code></strong></td><td style="text-align:left">通过 rsync 协议把文件高效地并行复制到多台主机上</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong><code>slurp</code></strong></td><td style="text-align:left">通过 ssh 协议把文件并行地从多个远程主机复制到中心主机上</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong><code>pnuke</code></strong></td><td style="text-align:left">通过 ssh 协议并行地在多个远程主机上杀死进程</td></tr></tbody></table><h2><span id="1-pssh">1. pssh</span></h2><blockquote><p><strong>通过 ssh 协议在多台主机上并行地运行命令</strong></p></blockquote><ul><li><strong>命令参数使用</strong></li></ul><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">参数选项</th><th style="text-align:left">对应参数解释</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><code>-h HOST_FILE</code></td><td style="text-align:left">指定主机文件列表文件；内容格式为”[user@]host[:port]”</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><code>-H HOST_STRING</code></td><td style="text-align:left">指定主机字符串地址；内容格式为”[user@]host[:port]”</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><code>-l USER</code></td><td style="text-align:left">指定登录使用的用户名</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>-p PAR</code></td><td style="text-align:left">设置并发的线程数(可选)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>-o OUTDIR</code></td><td style="text-align:left">标准正常输出的文件目录(可选)</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><code>-e ERRDIR</code></td><td style="text-align:left">标准错误输出的文件目录(可选)</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><code>-t TIMEOUT</code></td><td style="text-align:left">超时时间设置，其中 0 表示无限制(可选)</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>-O OPTION</code></td><td style="text-align:left">设置 SSH 的选项</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><code>-x ARGS</code></td><td style="text-align:left">额外的命令行参数使用空白符号、引号、反斜线处理</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>-X ARG</code></td><td style="text-align:left">额外的命令行参数，单个参数模式，同-x 参数</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><code>-A</code></td><td style="text-align:left">手动输入密码模式</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>-i</code></td><td style="text-align:left">每个服务器内部处理信息输出</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><code>-P</code></td><td style="text-align:left">打印出服务器返回信息</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">查看帮助，即此信息</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><code>--version</code></td><td style="text-align:left">显示程序版本号</td></tr></tbody></table><ul><li><strong>适用范例</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Usage: pssh [OPTIONS] command [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在两个主机上运行命令并在每个服务器上打印其输出</span></span><br><span class="line">$ pssh -i -H <span class="string">"host1 host2"</span> hostname -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令并将输出保存到单独的文件中</span></span><br><span class="line">$ pssh -H host1 -H host2 -o path/to/output_dir hostname -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在多个主机上运行命令并在新行分隔的文件中指定</span></span><br><span class="line">$ pssh -i -h path/to/hosts_file hostname -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以root运行命令(要求输入root用户密码)</span></span><br><span class="line">$ pssh -i -h path/to/hosts_file -A -l root_username hostname -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行带有额外SSH参数的命令</span></span><br><span class="line">$ pssh -i -h path/to/hosts_file -x <span class="string">"-O VisualHostKey=yes"</span> hostname -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行并行连接数量限制为10的命令</span></span><br><span class="line">$ pssh -i -h path/to/hosts_file -p 10 <span class="string">'cd dir; ./script.sh; exit'</span></span><br></pre></td></tr></table></figure><h2><span id="2-pscp">2. pscp</span></h2><blockquote><p><strong>通过 ssh 协议把文件并行地复制到多台主机上</strong></p></blockquote><ul><li><strong>命令参数使用</strong></li></ul><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">参数选项</th><th style="text-align:left">对应参数解释</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><code>-h HOST_FILE</code></td><td style="text-align:left">指定主机文件列表文件；内容格式为”[user@]host[:port]”</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><code>-H HOST_STRING</code></td><td style="text-align:left">指定主机字符串地址；内容格式为”[user@]host[:port]”</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><code>-l USER</code></td><td style="text-align:left">指定登录使用的用户名</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>-p PAR</code></td><td style="text-align:left">设置并发的线程数(可选)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>-o OUTDIR</code></td><td style="text-align:left">标准正常输出的文件目录(可选)</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><code>-e ERRDIR</code></td><td style="text-align:left">标准错误输出的文件目录(可选)</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><code>-t TIMEOUT</code></td><td style="text-align:left">超时时间设置，其中 0 表示无限制(可选)</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>-O OPTION</code></td><td style="text-align:left">设置 SSH 的选项</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><code>-x ARGS</code></td><td style="text-align:left">额外的命令行参数使用空白符号、引号、反斜线处理</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>-X ARG</code></td><td style="text-align:left">额外的命令行参数，单个参数模式，同-x 参数</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><code>-A</code></td><td style="text-align:left">手动输入密码模式</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>-r</code></td><td style="text-align:left">用于递归的复制目录(可选)</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">查看帮助，即此信息</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><code>--version</code></td><td style="text-align:left">显示程序版本号</td></tr></tbody></table><ul><li><strong>适用范例</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Usage: pscp [OPTIONS] local remote</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地文件复制到远程机器上</span></span><br><span class="line">$ pscp -h hosts.txt -l root foo.txt /home/irb2/foo.txt</span><br><span class="line">[1] 23:00:08 [SUCCESS] 172.18.10.25</span><br><span class="line">[2] 09:52:28 [SUCCESS] 172.18.10.24</span><br></pre></td></tr></table></figure><h2><span id="3-prsync">3. prsync</span></h2><blockquote><p><strong>通过 rsync 协议把文件高效地并行复制到多台主机上</strong></p></blockquote><ul><li><strong>命令参数使用</strong></li></ul><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">参数选项</th><th style="text-align:left">对应参数解释</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><code>-h HOST_FILE</code></td><td style="text-align:left">指定主机文件列表文件；内容格式为”[user@]host[:port]”</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><code>-H HOST_STRING</code></td><td style="text-align:left">指定主机字符串地址；内容格式为”[user@]host[:port]”</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><code>-l USER</code></td><td style="text-align:left">指定登录使用的用户名</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>-p PAR</code></td><td style="text-align:left">设置并发的线程数(可选)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>-o OUTDIR</code></td><td style="text-align:left">标准正常输出的文件目录(可选)</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><code>-e ERRDIR</code></td><td style="text-align:left">标准错误输出的文件目录(可选)</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><code>-t TIMEOUT</code></td><td style="text-align:left">超时时间设置，其中 0 表示无限制(可选)</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>-O OPTION</code></td><td style="text-align:left">设置 SSH 的选项</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><code>-x ARGS</code></td><td style="text-align:left">额外的命令行参数使用空白符号、引号、反斜线处理</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>-X ARG</code></td><td style="text-align:left">额外的命令行参数，单个参数模式，同-x 参数</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><code>-A</code></td><td style="text-align:left">手动输入密码模式</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>-r</code></td><td style="text-align:left">用于递归的复制目录(可选)</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>-a</code></td><td style="text-align:left">使用 rsync 的归档模式(可选)</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>-z</code></td><td style="text-align:left">使用 rsync 的压缩方式(可选</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>-S ARGS</code></td><td style="text-align:left">设置 ssh 协议的扩展参数(可选)</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">查看帮助，即此信息</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><code>--version</code></td><td style="text-align:left">显示程序版本号</td></tr></tbody></table><ul><li><strong>适用范例</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Usage: prsync [OPTIONS] local remote</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用rsync协议进行本地文件复制操作</span></span><br><span class="line">$ prsync -r -h hosts.txt -l root foo /home/irb2/foo</span><br></pre></td></tr></table></figure><h2><span id="4-pslurp">4. pslurp</span></h2><blockquote><p><strong>通过 ssh 协议把文件并行地从多个远程主机复制到中心主机上</strong></p></blockquote><ul><li><strong>命令参数使用</strong></li></ul><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">参数选项</th><th style="text-align:left">对应参数解释</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><code>-h HOST_FILE</code></td><td style="text-align:left">指定主机文件列表文件；内容格式为”[user@]host[:port]”</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><code>-H HOST_STRING</code></td><td style="text-align:left">指定主机字符串地址；内容格式为”[user@]host[:port]”</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><code>-l USER</code></td><td style="text-align:left">指定登录使用的用户名</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>-p PAR</code></td><td style="text-align:left">设置并发的线程数(可选)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>-o OUTDIR</code></td><td style="text-align:left">标准正常输出的文件目录(可选)</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><code>-e ERRDIR</code></td><td style="text-align:left">标准错误输出的文件目录(可选)</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><code>-t TIMEOUT</code></td><td style="text-align:left">超时时间设置，其中 0 表示无限制(可选)</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>-O OPTION</code></td><td style="text-align:left">设置 SSH 的选项</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><code>-x ARGS</code></td><td style="text-align:left">额外的命令行参数使用空白符号、引号、反斜线处理</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>-X ARG</code></td><td style="text-align:left">额外的命令行参数，单个参数模式，同-x 参数</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><code>-A</code></td><td style="text-align:left">手动输入密码模式</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>-r</code></td><td style="text-align:left">用于递归的复制目录(可选)</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><code>-L LOCALDIR</code></td><td style="text-align:left">指定本地存放文件的目录</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">查看帮助，即此信息</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><code>--version</code></td><td style="text-align:left">显示程序版本号</td></tr></tbody></table><ul><li><strong>适用范例</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Usage: pslurp [OPTIONS] remote local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程主机上面的文件复制到本地</span></span><br><span class="line">$ pslurp -h hosts.txt -l root -L /tmp/outdir /home/irb2/foo.txt foo.txt</span><br></pre></td></tr></table></figure><h2><span id="5-pnuke">5. pnuke</span></h2><blockquote><p><strong>通过 ssh 协议并行地在多个远程主机上杀死进程</strong></p></blockquote><ul><li><strong>命令参数使用</strong></li></ul><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">参数选项</th><th style="text-align:left">对应参数解释</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><code>-h HOST_FILE</code></td><td style="text-align:left">指定主机文件列表文件；内容格式为”[user@]host[:port]”</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><code>-H HOST_STRING</code></td><td style="text-align:left">指定主机字符串地址；内容格式为”[user@]host[:port]”</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><code>-l USER</code></td><td style="text-align:left">指定登录使用的用户名</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>-p PAR</code></td><td style="text-align:left">设置并发的线程数(可选)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>-o OUTDIR</code></td><td style="text-align:left">标准正常输出的文件目录(可选)</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><code>-e ERRDIR</code></td><td style="text-align:left">标准错误输出的文件目录(可选)</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><code>-t TIMEOUT</code></td><td style="text-align:left">超时时间设置，其中 0 表示无限制(可选)</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>-O OPTION</code></td><td style="text-align:left">设置 SSH 的选项</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><code>-x ARGS</code></td><td style="text-align:left">额外的命令行参数使用空白符号、引号、反斜线处理</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>-X ARG</code></td><td style="text-align:left">额外的命令行参数，单个参数模式，同-x 参数</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><code>-A</code></td><td style="text-align:left">手动输入密码模式</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">查看帮助，即此信息</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><code>--version</code></td><td style="text-align:left">显示程序版本号</td></tr></tbody></table><ul><li><strong>适用范例</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Usage: pnuke [OPTIONS] pattern</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束远程主机上面的进程任务</span></span><br><span class="line">$ pnuke -h hosts.txt -l root java</span><br></pre></td></tr></table></figure><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/y2zucscu%EF%BC%8C%E7%89%88%E6%9D%83%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF%EF%BC%8C%E6%8A%95%E7%A8%BF%E9%82%AE%E7%AE%B1:" target="_blank" rel="noopener">https://tinyurl.com/y2zucscu，版权归原作者所有。欢迎投稿，投稿邮箱:</a> <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;parallel-ssh 是为小规模自动化而设计的异步并行的 SSH 库!&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;parallel-ssh&lt;/code&gt;&lt;/strong&gt; 是为小规模自动化而设计的异步并行的 &lt;code&gt;SSH&lt;/code&gt; 库，包括 &lt;code&gt;pssh&lt;/code&gt;、&lt;code&gt;pscp&lt;/code&gt;、&lt;code&gt;prsync&lt;/code&gt;、&lt;code&gt;pslurp&lt;/code&gt; 和 &lt;code&gt;pnuke&lt;/code&gt;工具，其源代码使用 &lt;code&gt;Python&lt;/code&gt;语言编写开发的。该项目最初位于&lt;code&gt;Google Code&lt;/code&gt;上，是由&lt;code&gt;Brent N.Chun&lt;/code&gt;编写和维护的，但是由于工作繁忙，&lt;code&gt;Brent&lt;/code&gt;于&lt;code&gt;2009&lt;/code&gt;年&lt;code&gt;10&lt;/code&gt;月将维护工作移交给了&lt;code&gt;Andrew McNabb&lt;/code&gt;管理。到了 &lt;code&gt;2012&lt;/code&gt;年的时候，由于&lt;code&gt;Google Code&lt;/code&gt;的已关闭，该项目一度被废弃，现在也只能在 &lt;code&gt;Google Code&lt;/code&gt; 的归档中找到当时的版本了。&lt;/p&gt;
&lt;p&gt;但是需要注意的是，之前的版本是不支持 &lt;code&gt;Python3&lt;/code&gt; 的，但是 &lt;code&gt;Github&lt;/code&gt; 上面有人 &lt;code&gt;Fork&lt;/code&gt; 了一份，自己进行了改造使其支持 &lt;code&gt;Python3&lt;/code&gt; 以上的版本了。与此同时，还有一个组织专门针对 &lt;code&gt;parallel-ssh&lt;/code&gt; 进行了开发和维护，今天看了下很久都没有更新了。有需要的，自己可以自行查阅。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lilydjwg/pssh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lilydjwg/pssh - supported on Python 3.5 and later&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ParallelSSH/parallel-ssh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ParallelSSH/parallel-ssh - asynchronous parallel SSH client library&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可扩展性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持扩展到百台，甚至上千台主机使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;易于使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只需两行代码，即可在任意数量的主机上运行命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行高效&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;号称是最快的 &lt;code&gt;Python SSH&lt;/code&gt; 库可用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相比于其他 &lt;code&gt;Python SSH&lt;/code&gt; 库，其消耗资源最少&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="SSH" scheme="https://www.hi-linux.com/tags/SSH/"/>
    
  </entry>
  
</feed>
