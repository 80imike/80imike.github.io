<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇妙的 Linux 世界</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2022-03-25T06:54:36.838Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何在命令行快速获取公网动态 IP 地址</title>
    <link href="https://www.hi-linux.com/posts/39230.html"/>
    <id>https://www.hi-linux.com/posts/39230.html</id>
    <published>2022-03-04T01:00:00.000Z</published>
    <updated>2022-03-25T06:54:36.838Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>如何确定公网IP地址是一个让很多家用宽带朋友们经常遇到的问题，毕竟固定IP地址总是价格不菲因而不适用于家庭宽带，而我们的电信宽带运营商（ISP）往往给我们分配的是动态IP地址，之所以称作为动态IP地址，是因为每次拨号得到的IP地址可能会不一样，还有更骚的操作就是有的运营商每天或不定期在某个时间刷新IP地址池，这样已经获得的IP地址将会被强制释放并分配新的IP地址。</p><p>这对于我们一些运行在家用带宽下的服务带来了影响——需要重新设置服务端 IP 地址，比如监控、网络存储等等，这时候 DDNS 就发挥作用的，现在大部分路由器内置了 DDNS 客户端，比如花生壳等服务客户端，但是这些客户端存在收费、不稳定以及刷新间隔小等问题，对于自己有域名的朋友可以使用 DNS 服务商的 API 自己实现 IP 更新操作，比如阿里云（Aliyun）、Cloudflare 均可以实现。</p><p>对于 DDNS 如何使用 API 更新不在本文叙述范围内，但调用 API 有个关键参数那就是公网IP地址，如何获取当前运营商分配的公网 IP地址呢？除了问路由器外（打开路由器管理界面找到 WAN 口信息）我们还可以通过一些网络服务进行检测。</p><a id="more"></a><h2><span id="使用-shell-命令获取公网-ip-地址">使用 Shell 命令获取公网 IP 地址</span></h2><h3><span id="浏览器方式">浏览器方式</span></h3><p>如果我们使用浏览器打开这个地址<a href="https://checkip.amazonaws.com/" target="_blank" rel="noopener">checkip.amazonaws.com</a>你就会发现你的公网IP地址赫然在目，互联网上的服务器总是能够知道是什么 IP地址的客户端发起了连接，当然就可以通过这种方式获取公网 IP，同样功能的网站有很多，这里列举部分我收集到的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;checkip.amazonaws.com</span><br><span class="line">https:&#x2F;&#x2F;api.ipify.org</span><br><span class="line">https:&#x2F;&#x2F;ifconfig.me&#x2F;ip</span><br><span class="line">https:&#x2F;&#x2F;icanhazip.com</span><br><span class="line">https:&#x2F;&#x2F;ipinfo.io&#x2F;ip</span><br><span class="line">https:&#x2F;&#x2F;ipecho.net&#x2F;plain</span><br><span class="line">https:&#x2F;&#x2F;checkipv4.dedyn.io</span><br></pre></td></tr></table></figure><h3><span id="curl-方式">cURL 方式</span></h3><p>在命令行下我们当然不能为这点小事随便启动浏览器，我们可以请出另外一个功能强大的工具，那就是<a href="https://curl.se/" target="_blank" rel="noopener">curl</a>，cURL 是一个利用URL语法在命令行下工作的文件传输工具，关于cURL的快速用法可以参考阮一峰的网络日志<a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">《curl 的用法指南》</a>，这里不再详述，最简单的用法就是<code>curl 你要请求的网址</code>，比如<code>curl checkip.amazonaws.com</code>。</p><h3><span id="使用-dig-命令">使用 dig 命令</span></h3><p>首次在别人脚本中看到这个方式获取公网IP觉得比较新奇，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +short myip.opendns.com @resolver1.opendns.com</span><br></pre></td></tr></table></figure><p>这个是由OpenDNS提供的服务，如果你的主机上没有安装dig命令，对于Debian系列系统可以通过<code>apt-get install dnsutils</code>安装，这个命令的原理是指定<code>resolver1.opendns.com</code>为域名<code>myip.opendns.com</code>的解析服务器，为什么要指定，主要是避免 DNS 下游服务器缓存，另外这个指定的解析服务器被 OpenDNS 进行了特殊配置，其始终将域名<code>myip.opendns.com</code>解析为发起 DNS 请求的客户端 IP 地址，这样也就实现了查找公网 IP的功能。</p><p>这个和 cURL 方式比有什么优势呢？当然是数据量更小传输更快，毕竟使用 cURL 发起 HTTP 请求必然会导致协议头等无关信息的交换，如果启用了 HTTPS/TLS 那么还要进行加密协商，效率会比较低，当然这种方式的缺点就是 DNS 查询容易被运营商审计和过滤，稳定性略差，不过我测试下来除了偶尔查询失败外其余情况是完全 OK 的。</p><h2><span id="使用-shell-脚本获取公网-ip-地址">使用 Shell 脚本获取公网 IP 地址</span></h2><p>至此我有个新的主意，那就是首先采用 dig 命令快速检索公网 IP 地址，如果失败则切换到 cURL 的方式，为了避免 cURL 单一服务器失败，采用轮询或者随机的方式，尽可能提高成功率。</p><p>使用 Bash Shell 脚本 do it，比如获取公网 IPv4 的脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This script try to ensure gets the current IP address (as assigned by the ISP) from</span></span><br><span class="line"><span class="comment"># OpenDNS and other online services as fallbacks</span></span><br><span class="line"></span><br><span class="line">hosts=(<span class="string">"checkip.amazonaws.com"</span> <span class="string">"api.ipify.org"</span> <span class="string">"ifconfig.me/ip"</span> <span class="string">"icanhazip.com"</span> <span class="string">"ipinfo.io/ip"</span> <span class="string">"ipecho.net/plain"</span> <span class="string">"checkipv4.dedyn.io"</span>)</span><br><span class="line"></span><br><span class="line">CURL=`<span class="built_in">which</span> curl`</span><br><span class="line">DIG=`<span class="built_in">which</span> dig`</span><br><span class="line"></span><br><span class="line">check=$(<span class="variable">$DIG</span> +short myip.opendns.com @resolver1.opendns.com A) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! $? -eq 0 ] || [ -z <span class="string">"<span class="variable">$check</span>"</span> ] || [[ ! <span class="variable">$check</span> =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Unable to get your public IP address by OpenDNS service, try to another way."</span></span><br><span class="line">    count=<span class="variable">$&#123;#hosts[@]&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> [ -z <span class="string">"<span class="variable">$check</span>"</span> ] &amp;&amp; [[ <span class="variable">$count</span> -ne 0 ]]; <span class="keyword">do</span></span><br><span class="line">        selectedhost=<span class="variable">$&#123;hosts[ $RANDOM % $&#123;#hosts[@]&#125;</span> ]&#125;</span><br><span class="line">        check=$(<span class="variable">$CURL</span> -4s https://<span class="variable">$selectedhost</span> | grep <span class="string">'[^[:blank:]]'</span>) &amp;&amp; &#123;</span><br><span class="line">            <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$check</span>"</span> ] &amp;&amp; [[ <span class="variable">$check</span> =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                check=<span class="string">""</span></span><br><span class="line">                count=$(expr <span class="variable">$count</span> - 1)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"The host <span class="variable">$selectedhost</span> returned an invalid IP address."</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        &#125; || &#123;</span><br><span class="line">            check=<span class="string">""</span></span><br><span class="line">            count=$(expr <span class="variable">$count</span> - 1)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"The host <span class="variable">$selectedhost</span> did not respond."</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$check</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Unable to get your public IP address. Please check your internet connection."</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Your public IP address is <span class="variable">$check</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>上述脚本可以看出首先我使用 dig 方式查询 OpenDNS，如果查询失败或者返回为空或者不是 IP 地址，那么进入cURL模式，这里将可用服务器添加到 hosts 列表，并且随机抽取一个进行cURL，这里使用了<code>curl -4s</code>参数<code>-4s</code>分别表示仅使用 IPv4 方式连接（确保获取 IPv4 地址）和抑制进度条和错误信息，如果抽取的服务发生错误，那么进入循环再抽取一个，直到循环满最大 hosts 数停止。</p><h2><span id="总结">总结</span></h2><p>大部分脚本甚至一些程序仅使用了一种方式获取公网 IP，但是互联网上这些服务往往是不可靠的，如果你所选用的服务出现故障，那么将会影响到你后续业务的开展，所以本文的核心思想还是多个备份，另外对于 cURL 方式采用随机确保所谓的“负载平衡”，避免 fallback 时过度请求某个服务导致 IP 被 Ban。</p><blockquote><p>本文转载自：「 王晔的博客 」，原文：<a href="https://tinyurl.com/2p95wpue" target="_blank" rel="noopener">https://tinyurl.com/2p95wpue</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何确定公网IP地址是一个让很多家用宽带朋友们经常遇到的问题，毕竟固定IP地址总是价格不菲因而不适用于家庭宽带，而我们的电信宽带运营商（ISP）往往给我们分配的是动态IP地址，之所以称作为动态IP地址，是因为每次拨号得到的IP地址可能会不一样，还有更骚的操作就是有的运营商每天或不定期在某个时间刷新IP地址池，这样已经获得的IP地址将会被强制释放并分配新的IP地址。&lt;/p&gt;
&lt;p&gt;这对于我们一些运行在家用带宽下的服务带来了影响——需要重新设置服务端 IP 地址，比如监控、网络存储等等，这时候 DDNS 就发挥作用的，现在大部分路由器内置了 DDNS 客户端，比如花生壳等服务客户端，但是这些客户端存在收费、不稳定以及刷新间隔小等问题，对于自己有域名的朋友可以使用 DNS 服务商的 API 自己实现 IP 更新操作，比如阿里云（Aliyun）、Cloudflare 均可以实现。&lt;/p&gt;
&lt;p&gt;对于 DDNS 如何使用 API 更新不在本文叙述范围内，但调用 API 有个关键参数那就是公网IP地址，如何获取当前运营商分配的公网 IP地址呢？除了问路由器外（打开路由器管理界面找到 WAN 口信息）我们还可以通过一些网络服务进行检测。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Shell" scheme="https://www.hi-linux.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>如何让一个创业公司优雅的进行云原生之旅</title>
    <link href="https://www.hi-linux.com/posts/7852.html"/>
    <id>https://www.hi-linux.com/posts/7852.html</id>
    <published>2022-02-27T01:00:00.000Z</published>
    <updated>2022-03-25T06:55:56.614Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="前言">前言</span></h2><p>IT是一座道场！</p><p><img src="https://img.hi-linux.com/staticfile/1617155792725-55dca530-a3c3-4d4a-9ae6-3fad2df5755e-2021-09-26-eAvwbl.png" alt></p><p>2020年5月中旬本科毕业后，进入严格意义上的第一家公司。当时带我的是阿里云的MVP，也是公司的CTO，跟着他(石老大)学到了很多很多，带领我经过了入道(机会，不是人人都有，请感恩，给你机会和帮助的人）。三个月后他离职了，感谢石老大，正是他的离职给了我独自闯道的机会。</p><p>2020年9月开始进入了闯道(孤独，痛苦和煎熬会时常与你共舞)、修道(别忘了，给风雨中的自己一个鼓励)、悟道(认知和思想，是拉开人与人之间的重要差距)阶段。可以说自石老大走后，我的任务都是自我安排，技术都是自我驱动实现的。</p><p>2019年7月离开学校时，告诉自己：我的路是一条追逐云原生的路。自2018年8月接触Kubernetes时就深深爱上了这条路。</p><p>2020年6月初进入公司后，实实在在感受到了创业公司的集群环境之乱(只有前端业务Kubernetes化且测试和生产通过namespace区分、生产Kubernetes资源特别低且服务副本数只有2个、gitlab代码仓库是部署在Kubernetes环境上的、权限混乱等)。提出了一些自己的解决方案：<a href="https://www.cnblogs.com/zisefeizhu/p/13692782.html" target="_blank" rel="noopener">https://www.cnblogs.com/zisefeizhu/p/13692782.html</a></p><a id="more"></a><p>2020年6月构建以ELFK为技术核心的日志系统(只收集网关日志即nginx-ingress日志为唯一收集源)。</p><p>2020年7月围绕业务全面Kubernetes化展开，主导了业务从一到零再到一的过程。</p><p>2020年8月和9月忙于集群和CI|CD重构。新增了测试环境、预发环境，将网关由nginx-ingress改为kong-ingress，将gitlab从Kubernetes环境中剥离出来，借助cert-manager实现证书的自动申请和续签，增加堡垒机更正权限混乱问题，使用gitlab-runner实现多Kubernetes集群的自动化部署等。</p><p>2020年10月专攻于&quot;监控预警系统&quot;，实现三个纬度的监控，期间第一次参与并主导私有化项目的部署。</p><p>2020年11月以&quot;ISTIO服务治理&quot;为重心，在测试环境验证了连接、安全、流控、可视，期间开发了envoyfilter插件对接鉴权服务。</p><p>2020年12月和1月围绕&quot;kubernetes下微服务的日志系统&quot;展开，实现了多Kubernetes集群服务和裸机服务的日志统一到一个管理平台。</p><p>2021年1月和2月实现了将预发环境的kong-ingress过度到istio。并对接了证书服务、监控预警系统和日志系统。</p><p>2021年3月忙于私有化部署和istio准备上生产环境的验证。</p><p>2021年4月忙于旧服务器治理、私有化部署、聚石塔方面的有关工作。</p><p>2021年5月忙于istio生产启用、聚石塔和私有化部署的工作。</p><p>在公司近1年中创建了13个代码仓库，写了130余篇技术文档，</p><p>2020年6月初经过规划了一张&quot;基于KUBERNETES的企业级集群架构&quot;，经过和CTO及向有关人员的阐述，准备实施此架构</p><p><img src="https://img.hi-linux.com/staticfile/1617176613827-8f78dfb2-78b9-411e-9879-6461df0a20f7-2021-09-26-Yqe8Vf.png" alt></p><p>此架构规划了三个集群环境：生产环境、预发环境、测试环境</p><p>此架构除业务和项目外还增加了边界服务：统一日志管理平台、监控预警系统、链路追踪、统一管理平台、证书自动续签、流控等，下面将重点围绕此展开</p><h2><span id="基于-kubernetes-的企业级集群架构重点部分浅解">基于 KUBERNETES 的企业级集群架构重点部分浅解</span></h2><h3><span id="重构集群架构-业务全面容器化">重构集群架构、业务全面容器化</span></h3><p>这是一个从一到零再到一的过程，刚毕业即接触此类项目，实属幸运</p><p>大致重构步骤如下：</p><blockquote><ul><li>根据原有业务设计容器化架构方案；</li><li>新增堡垒机Jumpserver；</li><li>制作前后端业务镜像；</li><li>新增测试环境Kubernetes集群、预发环境Kubernetes集群、改造原生产环境Kubernetes集群；</li><li>借助Gitlab-Runner、Gitlab、Kustomize等实现多集群的CI|CD；</li><li>和有关同事一起定义前后端日志字段和输出形式；</li><li>协助后端团队微调原裸机业务源码；</li><li>借助Rancher实现对多Kubernetes集群的统一管理；</li><li>用Cert-Manager实现域名证书的自动申请和续期；</li><li>写Shell脚本对Gitlab备份进行检查、裸机服务备份进行检查、对域名有效期进行检查。</li></ul></blockquote><h3><span id="统一日志管理平台">统一日志管理平台</span></h3><p>此项目应是我近一年的最大收获了，思想上。</p><p>大致实现思路：多kubernetes集群的namespace绝对不能重复，elasticsearch、kibana、logstash、kafka独立于集群环境外且共用一套，filebeat、metricbeat、kube-state-metrics需要在每个kubernetes集群中都存在一套、metricbeat和tag需要标准清晰明了、日志以json格式输出且不允许多行日志出现</p><p>一提之举在：</p><blockquote><ul><li>实现了多集群、多环境日志的统一化管理</li></ul></blockquote><h3><span id="cicd">CI|CD</span></h3><p>基于我司目前的研发现状，选择的自动化部署工具为<code>gitlab-runner</code>。代码仓库创建规范可以参考：<a href="https://www.cnblogs.com/zisefeizhu/p/13621797.html%E3%80%82" target="_blank" rel="noopener">https://www.cnblogs.com/zisefeizhu/p/13621797.html。</a></p><p>大致实现思路：研发提交代码代码到特定分支(分支区分环境，生产分支需要项目总监merge) --&gt; 镜像打包(由预发Kubernetes集群的一台特定节点执行) --&gt; 根据<code>.gitlab-ci.yml</code> 规则进行业务pod化。</p><p>一提之举在：</p><blockquote><ul><li>通过分支区分环境</li><li>镜像打包只在一台预发环境的特定节点执行，减少因打包镜像而对生产环境带来的波动，且可以存在镜像利用</li><li>大量借助内置变量通过提前写的脚本提高Kubernetes 部署部分的资源清单的重复可用性</li></ul></blockquote><h3><span id="监控预警系统">监控预警系统</span></h3><p>实现三个纬度(业务监控、应用监控、操作系统)的监控预警系统。</p><p>其中业务监控主要是研发提供一些业务指标、业务数据。对其增上率、错误率等进行告警或展示，需要提前定义规范甚至埋点。</p><p>应用程序的监控主要有探针和内省。其中探针主要是从外部探测应用程序的特征，比如监听端口是否有响应。内省主要是查看应用程序内部的内容，应用程序通过检测并返回其内部的状态、内部的组件，事务和性能等度量，它可以直接将事件、日志和指标直接发送给监控工具。</p><p>操作系统主要是监控主要组件的使用率、饱和度以及错误，比如CPU的使用率、CPU的负载等。</p><p>一提之举在：</p><blockquote><ul><li>三个纬度</li><li>裸机也进行监控</li><li>windows也进行监控</li></ul></blockquote><h3><span id="服务治理">服务治理</span></h3><p>随着业务的不断微服务化、对于服务的运行的失控感越来越强、且对东西向流量的管理成为了急需解决的痛点、而Kong网关的ab test是付费版的开箱即用功能，而我司恰恰开始需要此功能。基于上服务治理开始进行视野。</p><p>我司对于服务治理的使用应算中度依赖，主要使用到如下点：</p><blockquote><ul><li>负载均衡：基础服务使用最少连接策略，业务层服务使用一致性哈希负载均衡。</li><li>健康检测：输出健康检测具体配置方案。（如：基础移出时间30秒，10秒内出现3次错误移出，检测时间间隔为10秒…）</li><li>连接池：创建连接池，每个实例最大处理请求数为10，每个连接处理2个请求后关闭，重试次数为3次，连接超时时间为500ms。</li><li>熔断策略：根据健康检测和连接池策略实现熔断策略</li><li>重试策略：最多重试3次，每次调用超时为2秒。</li><li>限流策略：后期用户数提高后再实行。</li><li>链路追踪</li></ul></blockquote><p>一提之举在：</p><blockquote><ul><li>基于envoyfilter 和lua开发对接鉴权服务和istio</li></ul></blockquote><h3><span id="私有化部署">私有化部署</span></h3><p>因我司主打产品为3D编辑器，数据保密性要求极高，大型企业更在意数据由自己掌握，所以在这近一年中做了好几个私有化部署项目。</p><p>在做私有化部署项目中学到了很多：</p><blockquote><ul><li>业务：需要知道客户需求牵扯到的服务有那些，作出路由规划表。</li><li>集群：根据客户的需求，估算出资源需求。</li><li>沟通：需要和客户(基本是非技术类)、我司运营等人于啊进行技术上的沟通，需要将繁琐的技术通俗化。</li><li>时间：根据客户的规定时间和我司的实际现状规划出准备、部署、测试、交付的时间段，考验项目时间把握度。</li><li>协调：在项目部署中难免会出现一些配置类的问题，需要后端人员介入。</li></ul></blockquote><p>一提之举在：</p><blockquote><ul><li>私有化部署严重考验对业务、集群的熟悉度，是考验一个运维人员的技能修养的。</li></ul></blockquote><h2><span id="总结">总结</span></h2><p>始终认为IT是一座道场，修道，修道，修一座自己的道场。在毕业的近1年中，经历了入道、闯道、修道阶段，到目前的悟道阶段。</p><p>需要提升和掌握的知识还有很多，技术没有止境，依然在路上。云原生是一条充满机遇的路，坚持与不断追求才能翻过一座又一座高山。</p><h2><span id="展望">展望</span></h2><p>悟道(认知和思想，是拉开人与人之间的重要差距)</p><p>试道(出道下山、世界这么大)</p><p>围绕 Kubernetes 展开云原生的涉猎，更快的参与二开和社区。</p><p>过手如登山，一步一重天</p><blockquote><p>本文转载自：「 博客园 」，原文：<a href="https://tinyurl.com/hc9vn8hf" target="_blank" rel="noopener">https://tinyurl.com/hc9vn8hf</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;IT是一座道场！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/1617155792725-55dca530-a3c3-4d4a-9ae6-3fad2df5755e-2021-09-26-eAvwbl.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2020年5月中旬本科毕业后，进入严格意义上的第一家公司。当时带我的是阿里云的MVP，也是公司的CTO，跟着他(石老大)学到了很多很多，带领我经过了入道(机会，不是人人都有，请感恩，给你机会和帮助的人）。三个月后他离职了，感谢石老大，正是他的离职给了我独自闯道的机会。&lt;/p&gt;
&lt;p&gt;2020年9月开始进入了闯道(孤独，痛苦和煎熬会时常与你共舞)、修道(别忘了，给风雨中的自己一个鼓励)、悟道(认知和思想，是拉开人与人之间的重要差距)阶段。可以说自石老大走后，我的任务都是自我安排，技术都是自我驱动实现的。&lt;/p&gt;
&lt;p&gt;2019年7月离开学校时，告诉自己：我的路是一条追逐云原生的路。自2018年8月接触Kubernetes时就深深爱上了这条路。&lt;/p&gt;
&lt;p&gt;2020年6月初进入公司后，实实在在感受到了创业公司的集群环境之乱(只有前端业务Kubernetes化且测试和生产通过namespace区分、生产Kubernetes资源特别低且服务副本数只有2个、gitlab代码仓库是部署在Kubernetes环境上的、权限混乱等)。提出了一些自己的解决方案：&lt;a href=&quot;https://www.cnblogs.com/zisefeizhu/p/13692782.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/zisefeizhu/p/13692782.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="云原生" scheme="https://www.hi-linux.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>使用 Nginx 三方扩展 ngx_waf 快速实现一个高性能的 Web 应用防火墙</title>
    <link href="https://www.hi-linux.com/posts/36520.html"/>
    <id>https://www.hi-linux.com/posts/36520.html</id>
    <published>2022-02-23T01:00:00.000Z</published>
    <updated>2022-02-23T05:13:47.620Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>ngx_waf：方便且高性能的 Nginx 防火墙模块</strong></p></blockquote><p>缓存策略为 <code>LRU</code>，<code>IP</code> 检查和 <code>CC</code> 防御花费常数时间，其它的检查花费 <code>O(nm)</code> 的时间，其中 <code>n</code> 是相关规则的条数，<code>m</code> 为执行正则匹配的时间复杂度，但是每次检查过后会自动缓存本次检查的结果，下次检查相同的目标时就可以使用缓存而不是检查全部的规则。不会缓存 <code>POST</code> 请求体的检查结果。</p><a id="more"></a><h2><span id="工具特点">工具特点</span></h2><blockquote><p><strong>介绍了该工具的主要特点以及核心功能！</strong></p></blockquote><p>该 <code>Nginx</code> 的第三方扩展工具，可以防御 <code>CC</code> 攻击(超出限制后自动拉黑对应 <code>IP</code> 一段时间或者使用验证码做人机识别)，可以支持多种黑白名单(<code>IP</code>/<code>POST</code>/<code>URL</code>/<code>UA</code>等等)，还可以提供防护 <code>SQL</code> 注入和 <code>XSS</code> 工具。</p><ul><li>使用简单<ul><li>配置文件和规则文件书写简单，可读性强</li></ul></li><li>基础防护<ul><li>如 <code>IP</code> 或 <code>IP</code> 网段的黑白名单、<code>URI</code> 黑白名单和请求体黑名单等</li></ul></li><li>高性能<ul><li>使用高效的 <code>IP</code> 检查算法和缓存机制，支持 <code>IPV4</code> 和 <code>IPV6</code></li></ul></li><li>高级防护<ul><li>兼容 <a href="https://github.com/SpiderLabs/ModSecurity" target="_blank" rel="noopener"><code>ModSecurity</code></a> 的规则，你可以使用 <code>OWASP</code> 的核心规则库</li></ul></li><li>友好爬虫验证<ul><li>支持验证 <code>Google</code>、<code>Bing</code>、<code>Baidu</code> 和 <code>Yandex</code> 的爬虫并自动放行，避免错误拦截，主要是基于 <code>User-Agent</code> 和 <code>IP</code> 的识别规则</li></ul></li><li>验证码<ul><li>支持三种验证码：<code>hCaptcha</code>、<code>reCAPTCHAv2</code> 和 <code>reCAPTCHAv3</code></li></ul></li></ul><h2><span id="模块安装">模块安装</span></h2><blockquote><p><strong>第三方模块我们应该怎么安装呢？</strong></p></blockquote><p><code>Nginx</code> 提供两种安装模块的方式，即「静态链接」和「动态加载」，通过两种方式安装的模块也分别称为「静态模块」和「动态模块」，可以通过运行脚本 <code>assets/guide.sh</code> 来选择使用静态模块还是动态模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行如下命令</span></span><br><span class="line">$ sh assets/guide.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果输出下面这行，则建议使用动态模块</span></span><br><span class="line"><span class="comment"># It is recommended that you use dynamic modules.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果输出下面这行，则建议使用静态模块</span></span><br><span class="line"><span class="comment"># It is recommended that you use static modules.</span></span><br></pre></td></tr></table></figure><ul><li><strong>[1] 静态模块</strong></li></ul><p>编译安装一个新的模块需要知道当前的 <code>Nginx</code> 的 <code>configure</code> 脚本的参数，您可以通过运行 <code>nginx -V</code> 来获取，务必记住 <code>configure arguments:</code> 后面的内容。安装静态模块需要重新编译整个 <code>Nginx</code>，花费的时间相对于安装动态模块比较长。如果不想在替换二进制文件时，关闭 <code>Nginx</code> 服务的话，可以参考<a href="https://nginx.org/en/docs/control.html" target="_blank" rel="noopener">官方文档的热部署方案</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载对应的Nginx版本</span></span><br><span class="line"><span class="comment"># http://nginx.org/en/download.html</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">$ wget https://nginx.org/download/nginx-1.20.1.tar.gz</span><br><span class="line">$ tar -zxf nginx-1.20.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用稳定版的源码</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">$ git <span class="built_in">clone</span> -b lts https://github.com/ADD-SP/ngx_waf.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行配置脚本</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/nginx-1.20.1</span><br><span class="line">$ ./configure ARG --add-module=/usr/<span class="built_in">local</span>/src/ngx_waf</span><br><span class="line">$ sed -i <span class="string">'s/^\(CFLAGS.*\)/\1 \</span></span><br><span class="line"><span class="string">    -fstack-protector-strong -Wno-sign-compare/'</span> \</span><br><span class="line">    objs/Makefile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译(非并行/并行)</span></span><br><span class="line">$ make</span><br><span class="line">$ make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换Nginx二进制文件(假设已经安装过)</span></span><br><span class="line">$ cp objs/nginx /usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><ul><li><strong>[2] 动态模块 - 下载预构建的模块</strong></li></ul><p>通过执行脚本 <code>assets/download.sh</code> 来下载动态模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于nginx-1.20.1的LTS版的模块</span></span><br><span class="line">$ sh assets/download.sh 1.20.1 lts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于nginx-1.20.1的最新版的模块</span></span><br><span class="line">$ sh assets/download.sh 1.20.1 current</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行成功后会有如下输出</span></span><br><span class="line">checking <span class="keyword">for</span> <span class="built_in">command</span> ... yes</span><br><span class="line">checking <span class="keyword">for</span> libc implementation ... yes</span><br><span class="line"> + GNU C libary</span><br><span class="line">Pulling remote image addsp/ngx_waf-prebuild:ngx-1.20.1-module-beta-glibc</span><br><span class="line">......</span><br><span class="line">Download complete!</span><br></pre></td></tr></table></figure><p>如果看到 <code>Download complete!</code> 的话，则说明下载成功，模块会被保存在当前目录下。你可以将其拷贝到一个目录下，然后在 <code>nginx.conf</code> 的顶部添加一行。然后关闭 <code>Nginx</code> 服务并运行 <code>nginx -t</code>。如果没有出错则说明模块被正常加载，反之则说明您的 <code>Nginx</code> 不支持预构建的模块，请编译安装模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_module &quot;&#x2F;path&#x2F;to&#x2F;ngx_http_waf_module.so&quot;;</span><br></pre></td></tr></table></figure><ul><li><strong>[3] 动态模块 - 编译动态模块</strong></li></ul><p>编译安装动态模块并不需要重新编译整个 <code>Nginx</code>，只需要重新编译所有的模块，所以速度相对静态模块快一些，这也是本文档推荐的方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载对应的Nginx版本</span></span><br><span class="line"><span class="comment"># http://nginx.org/en/download.html</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">$ wget https://nginx.org/download/nginx-1.20.1.tar.gz</span><br><span class="line">$ tar -zxf nginx-1.20.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用稳定版的源码</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">$ git <span class="built_in">clone</span> -b lts https://github.com/ADD-SP/ngx_waf.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行配置脚本</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/nginx-1.20.1</span><br><span class="line">$ ./configure --add-dynamic-module=/usr/<span class="built_in">local</span>/src/ngx_waf --with-compat</span><br><span class="line">$ sed -i <span class="string">'s/^\(CFLAGS.*\)/\1 \</span></span><br><span class="line"><span class="string">    -fstack-protector-strong -Wno-sign-compare/'</span> \</span><br><span class="line">    objs/Makefile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始编译动态模块</span></span><br><span class="line">$ make modules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将动态模块拷贝到模块目录(关闭服务)</span></span><br><span class="line">$ cp objs/*.so /usr/<span class="built_in">local</span>/nginx/modules</span><br></pre></td></tr></table></figure><p>最后，在 <code>Nginx</code> 的配置文件顶部添加一行，表示加载这个编译好的模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_module &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;modules&#x2F;ngx_http_waf_module.so&quot;;</span><br></pre></td></tr></table></figure><h2><span id="模块使用">模块使用</span></h2><blockquote><p><strong>第三方模块我们应该怎么使用呢？更多参数参考 <a href="https://docs.addesp.com/ngx_waf/zh-cn/advance/directive.html" target="_blank" rel="noopener">配置语法</a></strong></p></blockquote><p>现在就可以在 <code>nginx.conf</code> 内的一个 <code>server</code> 块中添加配置来开启 <code>ngx_waf</code> 模块来配置服务的防火墙了，下面是一个例子。</p><ul><li><strong>[1] LTS 版本</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">        # on&#x2F;off 表示启用和关闭</span><br><span class="line">        waf on;</span><br><span class="line"></span><br><span class="line">        # 规则文件所在目录的绝对路径，必须以&#x2F;结尾</span><br><span class="line">        waf_rule_path &#x2F;usr&#x2F;local&#x2F;src&#x2F;ngx_waf&#x2F;assets&#x2F;rules&#x2F;;</span><br><span class="line"></span><br><span class="line">        # 防火墙工作模式，STD表示标准模式</span><br><span class="line">        waf_mode STD;</span><br><span class="line"></span><br><span class="line">        # CC防御参数</span><br><span class="line">        # 1000表示每分钟请求次数上限，超出上限后封禁对应ip地址60分钟</span><br><span class="line">        waf_cc_deny rate&#x3D;1000r&#x2F;m duration&#x3D;60m;</span><br><span class="line"></span><br><span class="line">        # 最多缓存50个检测目标的检测结果</span><br><span class="line">        # 对除了IP黑白名单检测、CC防护和POST检测以外的所有检测生效</span><br><span class="line">        waf_cache capacity&#x3D;50;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>[2] Current 版本</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 声明一块共享内存</span><br><span class="line">    waf_zone name&#x3D;waf size&#x3D;20m;</span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">        # on&#x2F;off 表示启用和关闭</span><br><span class="line">        waf on;</span><br><span class="line"></span><br><span class="line">        # 规则文件所在目录的绝对路径，必须以&#x2F;结尾</span><br><span class="line">        waf_rule_path &#x2F;usr&#x2F;local&#x2F;src&#x2F;ngx_waf&#x2F;assets&#x2F;rules&#x2F;;</span><br><span class="line"></span><br><span class="line">        # 防火墙工作模式，STD表示标准模式</span><br><span class="line">        waf_mode STD;</span><br><span class="line"></span><br><span class="line">        # CC防御参数</span><br><span class="line">        # 1000表示每分钟请求次数上限，超出上限后封禁对应ip地址60分钟</span><br><span class="line">        waf_cc_deny on rate&#x3D;1000r&#x2F;m duration&#x3D;60m zone&#x3D;waf:cc;</span><br><span class="line"></span><br><span class="line">        # 对除了IP黑白名单检测、CC防护和POST检测以外的所有检测生效</span><br><span class="line">        waf_cache on capacity&#x3D;50;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="常用设置">常用设置</span></h2><blockquote><p><strong>列出一些 <a href="https://docs.addesp.com/ngx_waf/zh-cn/practice/overview.html" target="_blank" rel="noopener">常用的设置</a>，拿来直接就可以使用！</strong></p></blockquote><p>因为模块的配置比较复杂，为了降低使用难度，在这里列出了一些常见用法。</p><ul><li><strong>[1] 针对路径或文件限流</strong></li></ul><p>有时你可能想要限制不同的路径或文件的请求速率，比如静态资源和动态资源使用不同的速率限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># LTS</span><br><span class="line"></span><br><span class="line"># 将静态资源的请求速率限制到10,000次&#x2F;分钟</span><br><span class="line">location &#x2F;static&#x2F; &#123;</span><br><span class="line">    waf_cc_deny rate&#x3D;10000r&#x2F;m duration&#x3D;1h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 将动态资源的请求速率限制到2,000次&#x2F;分钟</span><br><span class="line">location &#x2F;dynamic&#x2F; &#123;</span><br><span class="line">    waf_cc_deny rate&#x3D;2000r&#x2F;m duration&#x3D;1h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Current</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    waf_zone name&#x3D;waf size&#x3D;20m;</span><br><span class="line">    server &#123;</span><br><span class="line">        # 将静态资源的请求速率限制到10,000次&#x2F;分钟</span><br><span class="line">        location &#x2F;static&#x2F; &#123;</span><br><span class="line">            waf_cc_deny rate&#x3D;10000r&#x2F;m duration&#x3D;1h zone&#x3D;waf:cc_static;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 将动态资源的请求速率限制到2,000次&#x2F;分钟</span><br><span class="line">        location &#x2F;dynamic&#x2F; &#123;</span><br><span class="line">            waf_cc_deny rate&#x3D;2000r&#x2F;m duration&#x3D;1h zone&#x3D;waf:cc_dynamic;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>[2] 开启验证码<ul><li><a href="https://www.hcaptcha.com/" target="_blank" rel="noopener">hCaptcha</a></li><li><a href="https://developers.google.com/recaptcha" target="_blank" rel="noopener">reCAPTCHAv2</a></li><li><a href="https://developers.google.com/recaptcha" target="_blank" rel="noopener">reCAPTCHAv3</a></li></ul></li></ul><p>当你的站点受到 <code>CC</code> 攻击时开启验证码是不错的选择，因为验证码可以帮助你进行人机识别。本模块目前支持三种验证码，你应该选择一个并从其网站上申请到 <code>Sitekey</code> 和 <code>Secret</code>。配置完成之后，重启 <code>nginx</code> 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 整个站点开启验证码</span><br><span class="line">server &#123;</span><br><span class="line">    waf_captcha on prov&#x3D;hCaptcha secret&#x3D;your_secret sitekey&#x3D;your_sitekey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 为某个路径开启验证码</span><br><span class="line">location &#123;</span><br><span class="line">    waf_captcha on prov&#x3D;hCaptcha secret&#x3D;your_secret sitekey&#x3D;your_sitekey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 当访问频率过高时开启验证码</span><br><span class="line">http &#123;</span><br><span class="line">    waf_zone name&#x3D;waf size&#x3D;20m;</span><br><span class="line">    server &#123;</span><br><span class="line">        waf_cc_deny on rate&#x3D;1000r&#x2F;m duration&#x3D;1h zone&#x3D;waf:cc;</span><br><span class="line">        waf_captcha off prov&#x3D;hCaptcha secret&#x3D;your_secret sitekey&#x3D;your_sitekey;</span><br><span class="line">        waf_action cc_deny&#x3D;CAPTCHA zone&#x3D;waf:action;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>[3] 拦截请求时启用验证码</strong></li></ul><p>如今，许多攻击者都会使用自动工具攻击服务器，这些自动工具会尝试每一个漏洞，有的会被安全措施所拦截，有的则可以躲避检测。 如果攻击者觉得你的价值比较高，可能会手动攻击你的服务。我们并不能完美地防御这些攻击，但却能很简单地提高攻击的成本。</p><p>当一个请求被拦截时，<code>ngx_waf</code> 会对该 <code>IP</code> 启用验证码，此时该 <code>IP</code> 想要继续访问就必须完成验证码。这基本可以废掉多数的自动攻击工具，因为这些工具会尝试每一个漏洞，而我们总能识别一些明显的攻击请求并启用验证码，而自动工具时难以通过验证的。对于手动攻击者，这也能提高他们的时间成本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    waf_zone name&#x3D;waf size&#x3D;20m;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        waf_captcha off prov&#x3D;xxx sitekey&#x3D;xxx secret&#x3D;xxx;</span><br><span class="line">        waf_action blacklist&#x3D;CAPTCHA zone&#x3D;waf:action;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>[4] 被攻击时降低带宽占用</strong></li></ul><p>当你受到 <code>CC</code> 攻击时，攻击者的 <code>IP</code> 已经被 <code>CC</code> 防护拉黑，但是你的上下行带宽依然很高， 这是因为 <code>CC</code> 防护会返回一个 <code>503</code> 状态码，因此占用了你的带宽，你可以使用下面的配置来降低带宽占用。</p><p><code>444</code> 状态码是 <code>nginx </code>定义的一个非标准的 <code>HTTP</code> 状态码，其作用就是直接关闭连接，不再发送任何数据。如果你使用了 <code>444</code> 状态码，那么在用户看来你的网站就像是不存在一样。这是因为网站出错一般都会有 <code>HTTP</code> 状态码用来提示错误， 如果访问一个网站连错误提示都没有，那么大概率是这个网站不存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># LTS</span><br><span class="line">waf_http_status cc_deny&#x3D;444;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Current</span><br><span class="line">waf_action cc_deny&#x3D;444;</span><br></pre></td></tr></table></figure><ul><li><strong>[5] 抵御分布式 CC 攻击</strong></li></ul><p><code>CC</code> 攻击(<code>HTTP</code> 洪水)是指发送大量的 <code>HTTP</code> 请求来耗尽服务器的资源。如果攻击者使用的 <code>IP</code> 较少则防御较为简单，因为只需要限制 <code>IP</code> 的请求频率，但是如果攻击者使用大量的 <code>IP</code> 进行攻击，仅仅限制 <code>IP</code> 的请求频率是无济于事的。这种使用大量 <code>IP</code> 进行 <code>CC</code> 攻击的方式称为分布式 <code>CC</code> 攻击或分布式 <code>HTTP</code> 洪水。</p><p>本模块提供了一些缓解方式，第一种开启验证码来缓解，第二种使用降低带宽占用，第三种使用五秒盾来缓解。你可能听说过 <code>Cloudflare</code> 的五秒盾，本模块的五秒盾和 <code>Cloudflare</code> 的完全不同。它的功能是检测客户端是否能够正确地支持 <code>Cookie</code>，比如发送 <code>Cookie</code> 和正确地处理 <code>Set-Cookie</code> 响应头。你可以从本项目的 <code>assets/</code> 目录下找到 <code>under-attack.html</code> 并将其拷贝到某个路径下，然后通过修改 <code>nginx</code> 的配置文件来开启五秒盾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># LTS</span><br><span class="line"></span><br><span class="line"># 为整个网站开启五秒盾</span><br><span class="line">server &#123;</span><br><span class="line">    waf_under_attack on file&#x3D;&#x2F;path&#x2F;to&#x2F;under_attack.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 为某个路径开启五秒盾</span><br><span class="line">location &#x2F;path &#123;</span><br><span class="line">    waf_under_attack on file&#x3D;&#x2F;path&#x2F;to&#x2F;under_attack.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Current</span><br><span class="line"></span><br><span class="line"># 为整个网站开启五秒盾</span><br><span class="line">server &#123;</span><br><span class="line">    waf_under_attack on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 为某个路径开启五秒盾</span><br><span class="line">location &#x2F;path &#123;</span><br><span class="line">    waf_under_attack on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="效果测试">效果测试</span></h2><blockquote><p><strong>如需更多帮助，可以参考 <a href="https://docs.addesp.com/ngx_waf/zh-cn/guide/test.html#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">如何测试</a>！</strong></p></blockquote><p>当我们部署和配置服务完成之后，需要测试下防火墙是否正常起作用了，可以通过如下方式进行简单的测试来判断规则是否正常运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 测试时的配置</span><br><span class="line">master_process on;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        access_log off;</span><br><span class="line"></span><br><span class="line">        waf on;</span><br><span class="line">        waf_mode DYNAMIC !CC !POST;</span><br><span class="line">        waf_rule_path &#x2F;usr&#x2F;local&#x2F;src&#x2F;ngx_waf&#x2F;rules&#x2F;;</span><br><span class="line">        waf_cache capacity&#x3D;6000 interval&#x3D;1h percent&#x3D;50;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            default_type text&#x2F;html;</span><br><span class="line">            return 200 &#39;hello&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>[1] 简易测试<ul><li>运行下列命令，如果输出 <code>403</code> 则表示模块正常工作</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -I -o /dev/null --user-agent bench \</span><br><span class="line">    -s -w <span class="string">"%&#123;http_code&#125;\\n"</span> https://example.com</span><br></pre></td></tr></table></figure><ul><li>[2] 自动测试<ul><li>项目附带了许多测试用例，你可以通过下面的指令来运行全部的用例</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这行命令的执行时间比较长</span></span><br><span class="line">$ cpan Test::Nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果目录已经存在则会先删除再创建</span></span><br><span class="line">$ <span class="built_in">export</span> MODULE_TEST_PATH=/path/to/temp/dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你安装了动态模块则需要指定动态模块的绝对路径，反之则无需执行这行命令</span></span><br><span class="line">$ <span class="built_in">export</span> MODULE_PATH=/path/to/ngx_http_waf_module.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动化测试</span></span><br><span class="line">$ <span class="built_in">cd</span> ./<span class="built_in">test</span>/<span class="built_in">test</span>-nginx</span><br><span class="line">$ sh ./init.sh</span><br><span class="line">$ sh ./start.sh ./t/*.t</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用WRK工具测试</span></span><br><span class="line">$ wrk -c 100 -d 30m -t 1 -s <span class="built_in">test</span>/wrk/rand.lua --latency \</span><br><span class="line">    http://localhost/ -- /path/to/rand-str.txt</span><br></pre></td></tr></table></figure><h2><span id="注意事项">注意事项</span></h2><blockquote><p><strong>如需更多帮助，可以参考 <a href="https://docs.addesp.com/ngx_waf/zh-cn/guide/faq.html" target="_blank" rel="noopener">常见问题与解答</a>！</strong></p></blockquote><p>本模块只保证对 <code>nginx-1.18.0</code> 或更新的版本的兼容性，且不保证与 <code>Linux</code> 以外的操作系统的兼容性。这里需要注意的是，模块与 <a href="https://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a> 存在兼容性问题。</p><ul><li>当 <code>return</code> 指令生效时，该模块不会生效</li><li>当 <code>rewrite</code> 指令造成了返回(如 <code>302</code> 重定向)时，该模块不会生效</li><li>所以可以使用 <a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#try_files" target="_blank" rel="noopener"><code>try_files</code></a> 代替 <a href="https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite" target="_blank" rel="noopener"><code>rewrite</code></a> 指令，避免上述问题的出现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># rewrite</span><br><span class="line">if (!-e $request_filename) &#123;</span><br><span class="line">    rewrite (.*) &#x2F;index.php</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># try_files</span><br><span class="line">try_files $uri $uri&#x2F; &#x2F;index.php;</span><br></pre></td></tr></table></figure><h2><span id="参考链接">参考链接</span></h2><ul><li><a href="https://github.com/ADD-SP/ngx_waf" target="_blank" rel="noopener">Github 代码仓库</a></li><li><a href="https://docs.addesp.com/ngx_waf/zh-cn/advance/rule.html" target="_blank" rel="noopener">黑白名单规则说明</a></li><li><a href="https://docs.addesp.com/ngx_waf/zh-cn/advance/priority.html" target="_blank" rel="noopener">检测项目规则优先级</a></li><li><a href="https://docs.addesp.com/ngx_waf/zh-cn/advance/variable.html" target="_blank" rel="noopener">模块的内置变量</a></li><li><a href="https://docs.addesp.com/ngx_waf/zh-cn/advance/log.html" target="_blank" rel="noopener">日志相关的配置说明</a></li></ul><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/2p979waj" target="_blank" rel="noopener">https://tinyurl.com/2p979waj</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ngx_waf：方便且高性能的 Nginx 防火墙模块&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;缓存策略为 &lt;code&gt;LRU&lt;/code&gt;，&lt;code&gt;IP&lt;/code&gt; 检查和 &lt;code&gt;CC&lt;/code&gt; 防御花费常数时间，其它的检查花费 &lt;code&gt;O(nm)&lt;/code&gt; 的时间，其中 &lt;code&gt;n&lt;/code&gt; 是相关规则的条数，&lt;code&gt;m&lt;/code&gt; 为执行正则匹配的时间复杂度，但是每次检查过后会自动缓存本次检查的结果，下次检查相同的目标时就可以使用缓存而不是检查全部的规则。不会缓存 &lt;code&gt;POST&lt;/code&gt; 请求体的检查结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="https://www.hi-linux.com/categories/nginx/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
      <category term="安全" scheme="https://www.hi-linux.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>超给力，100+ 互联网大厂产品开源代码合集！</title>
    <link href="https://www.hi-linux.com/posts/56314.html"/>
    <id>https://www.hi-linux.com/posts/56314.html</id>
    <published>2022-01-28T01:00:00.000Z</published>
    <updated>2022-02-09T03:03:37.728Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>学习互联网大厂产品的源码是非常好提高自身技术水平的方法，但是问题来了，源码不一定开源啊，想学也没办法。但是就是有这样一些技术大牛，通过研究大厂的产品，开源出来了各种克隆的实现。</p><p>今天要推荐的开源项目是 <code>Clone-Wars</code>，收集了 100+ 互联网大厂产品的开源实现，包括 <code>Airbnb</code>、<code>Amazon</code>、<code>Instagram</code>、<code>Netflix</code>、<code>Tiktok</code>、<code>Spotify</code>、<code>Whatsapp</code>、<code>Youtube</code> 等非常多，其中内容包含了源码、Demo 链接、技术栈介绍等。有一说一，这个真的太全了，部分产品还自带教学视频。</p><p><img src="https://img.hi-linux.com/staticfile/og-2021-07-15-3ikq76.png" alt></p><a id="more"></a><p>以下是部分比较著名的网站实现：</p><p><img src="https://img.hi-linux.com/staticfile/image-20210715160217277-2021-07-15-rSLbMK.png" alt></p><p>很多产品还不只一个开源的克隆实现呢。</p><p><img src="https://img.hi-linux.com/staticfile/image-20210715160423005-2021-07-15-OqJHWD.png" alt></p><p>我们来看下其中一个 HackerNews 的开源克隆实现，作者还做了部分的重新设计，看上去要比原版视觉效果要好一点。</p><p><img src="https://img.hi-linux.com/staticfile/image-20210715160536681-2021-07-15-js5y1j.png" alt></p><p>更多项目详情请查看项目地址：<a href="https://github.com/GorvGoyl/Clone-Wars" target="_blank" rel="noopener">https://github.com/GorvGoyl/Clone-Wars</a></p><blockquote><p>本文转载自：「 GitHub 精选 」，原文：<a href="https://tinyurl.com/4f7crwf4" target="_blank" rel="noopener">https://tinyurl.com/4f7crwf4</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习互联网大厂产品的源码是非常好提高自身技术水平的方法，但是问题来了，源码不一定开源啊，想学也没办法。但是就是有这样一些技术大牛，通过研究大厂的产品，开源出来了各种克隆的实现。&lt;/p&gt;
&lt;p&gt;今天要推荐的开源项目是 &lt;code&gt;Clone-Wars&lt;/code&gt;，收集了 100+ 互联网大厂产品的开源实现，包括 &lt;code&gt;Airbnb&lt;/code&gt;、&lt;code&gt;Amazon&lt;/code&gt;、&lt;code&gt;Instagram&lt;/code&gt;、&lt;code&gt;Netflix&lt;/code&gt;、&lt;code&gt;Tiktok&lt;/code&gt;、&lt;code&gt;Spotify&lt;/code&gt;、&lt;code&gt;Whatsapp&lt;/code&gt;、&lt;code&gt;Youtube&lt;/code&gt; 等非常多，其中内容包含了源码、Demo 链接、技术栈介绍等。有一说一，这个真的太全了，部分产品还自带教学视频。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/og-2021-07-15-3ikq76.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="开源" scheme="https://www.hi-linux.com/categories/%E5%BC%80%E6%BA%90/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="开源" scheme="https://www.hi-linux.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="程序员" scheme="https://www.hi-linux.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>WireGuard 中文教程：使用 Netmaker 快速组建 WireGuard 全互联 (Full Mesh) 网络</title>
    <link href="https://www.hi-linux.com/posts/40657.html"/>
    <id>https://www.hi-linux.com/posts/40657.html</id>
    <published>2022-01-14T01:00:00.000Z</published>
    <updated>2022-01-14T01:27:32.617Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="什么是-netmaker">什么是 Netmaker</span></h2><p><a href="https://github.com/gravitl/netmaker" target="_blank" rel="noopener">Netmaker</a> 是一个开源的、基于 [[WireGuard]] 的网络（overlay network) 控制工具，可以非常快速的用来组建 WireGuard 网络。</p><p>如果你有两台连接互联网的设备，那么 Netmaker 可以组建一个安全的网络，并打通一个安全的隧道提供给两台机器通信。而如果你有数千台机器分布在不同的地区，不同的数据中心，不同的网络中，那么 Netmaker 也可以组建一个网络来提供给这些不同的节点通信。</p><p>如果熟悉 AWS，那么 Netmaker 就像 VPC 一样，不过 Netmaker 可以应用在任意的机器中。从 Netmaker 网络中的机器来看，同一个网络中的机器尽管在世界各地，但其相互通信就像是在同一个局域网中一样。</p><a id="more"></a><p>Netmaker 和其他一些产品非常相似，比如 [[Tailscale]], [[ZeroTier]]，[[Nebula]] 但不同于这些产品的是，Netmaker 连接更快，更加灵活。Netmaker 使用 [[WireGuard]] 所以更快，Netmaker 中的节点不管是服务端还是Agent都完全可配置，所以提供了更大的灵活性。</p><p>Netmaker 优于 [[Tailscale]] 的地方还在于 ，Netmaker 不需要 Google, Microsoft 或者 GitHub 账号。Netmaker 可以认为是一个可以自行托管的 Tailscale。</p><h2><span id="netmaker-工作原理">Netmaker 工作原理</span></h2><p>Netmaker 依赖于 WireGuard 来在机器间创建隧道（tunnel), Netmaker 通过管理不同机器的 WireGuard 来创建网络。简单来说，Netmaker 实现 Client/Server 架构：</p><ul><li>the admin server 管理端，称为 Netmaker，管理网络的界面</li><li>the agent，客户端，称为 Netclient，客户端通过 gRPC 与服务端通信</li></ul><p>作为 Network 管理端，你可以通过管理端来创建网络，管理连接的设备。服务端会保存所有网络和设备的配置信息，这些信息会被 netclient (agent) 来获取使用。</p><p>客户端（netclient) 是一个二进制文件，netclient 会在节点被添加到网络中的时候安装到不同的机器中，netclient 可以在大多数系统中运行，不管是虚拟机，物理机，或者 IoT 设备都可以运行 netclient。netclient 会连接服务端，通过服务端的配置来自动管理 WireGuard，动态更新 Peers。通过不断向网络中添加节点的方式，可以创建一个动态的，完全可以配置的虚拟网络。</p><p>Netmaker server 不会路由网络流量，否则这个网络就变成了一个中心辐射模型（hub-and-spoke model），这会使得中心服务器变成瓶颈，并且拖慢网络。相反，Network 会告诉网络中的节点他们之间可以相互直接通信，这被称为 full mesh network（网状网络），这会让节点和节点的连接更快。即使管理端宕机，只要现存的节点没有变化，那么这个网络依然可以正常工作。</p><h2><span id="应用场景-use-cases">应用场景 Use Cases</span></h2><p>Netmaker 有非常多的应用场景，事实上，现在可能就已经在使用了。</p><p>用例：</p><ul><li>自动创建 WireGuard mesh network</li><li>在云环境和数据中心之间创建 flat, secure 网络</li><li>给 IoT 设备提供更安全的网络访问</li><li>增强家庭，或办公网络的安全性</li><li>在现存网络上增加一层加密</li><li>安全的 site-to-site 连接</li><li>管理 cryptocurrency proof-of-stake 机器</li><li>创建动态的安全的 Kubernetes underlay network</li></ul><p>更多的用例也可以参考<a href="https://docs.netmaker.org/usage.html" target="_blank" rel="noopener">官网</a>。</p><h2><span id="架构">架构</span></h2><p><img src="https://img.hi-linux.com/staticfile/netmaker-architecture-20211212101049-2022-01-13-uWAKsc.png" alt="Netmaker 的架构图"></p><h2><span id="概念">概念</span></h2><p>熟悉一下 Netmaker 中常常被提到的概念，有助于理解。</p><h3><span id="wireguard">WireGuard</span></h3><p>[[WireGuard]] 相对比较新，但非常强大，WireGuard 被加入到了 Linux kernel。WireGuard 可以非常简单快速地在设备之间创建加密通道。从 <a href="https://www.wireguard.com/" target="_blank" rel="noopener">WireGuard</a> 官网的介绍中可以看到，“WireGuard 可以被认为是工业界最安全，最方便使用，最简单的 VPN 解决方案”。</p><p>之前的解决方案，比如 OpenVPN，或者 IPSec 都被认为又重又复杂，并且性能也不是很好。所有现存的 VPN tunneling 方案都会导致网络延迟增大。WireGuard 是第一个实现了几乎接近有线连接网络速度的 VPN，可以看到 WireGuard 对现有网络连接几乎没有影响。随着 WireGuard 的发布，没有任何理由去使用其他隧道加密技术了。</p><h3><span id="mesh-network">Mesh Network</span></h3><p>当提到 mesh network （网状网络）的时候通常也会说 「full mesh」。一个 full <a href="https://www.bbc.co.uk/bitesize/guides/zr3yb82/revision/2" target="_blank" rel="noopener">mesh network</a> 指的是网络中的任何节点都可以相互直接连接。</p><p><img src="https://img.hi-linux.com/staticfile/full-mesh-network-20211212102133-2022-01-13-2gL9FB.png" alt></p><p>比如在路由器后面的家庭网络，所有的电脑都会通过私有局域网地址相互连接。</p><p>Mesh network 通常会和 hub-and-spoke (中心辐射) 网络放到一起对比，中心辐射的网络中，一个节点必须通过 relay server 才能和另外一个节点进行通信。</p><p>在一些场景中，你可以需要部分的 mesh network，网络中只有部分设备需要相互直接通信，而其他设备都需要将流量转发给一个 relay/gateway 。Netmaker 在某些时候也可以实现这类模型。在第一张图片中，这个设置就是一个部分的 mesh network，因为节点A-D 是网状网络，而其他的客户端通过 gateway 连接。</p><p>Mesh networks 通常比其他拓扑的网络更快，但通常设置也会更加复杂。WireGuard 提供了在设备之间创建加密隧道的方法，但是它不提供设置完整网络的方法。这是 Netmaker 诞生的理由。</p><h3><span id="netmaker">Netmaker</span></h3><p>Netmaker 是一个建立在 WireGuard 上的平台，允许用户在设备之间构建 mesh networks。Netmaker 可以根据需要创建完全的、或部分的 mesh network。</p><p>当我们提及 Netmaker 整体的时候，通常指的是 Netmaker 以及 netclient, 以及其他辅助的服务，比如 CoreDNS，rqlite 和 UI 服务。</p><p>从终端用户来看，通常会和 Netmaker UI 交互，或会直接在终端节点中直接运行脚本。而其他部分都会在后台默默地执行。</p><p>Netmaker 做了非常多的配置相关的工作，简化了用户的配置。包括了 WireGuard 的端口，endpoints( 终端) , public IPs（公网IP），keys(密钥) 和 peers(节点)。Netmaker 尽可能多地抽象了网络管理，只需简单的在界面点击创建网络，然后点击将计算机添加到网络。也就是说，每一个机器都是不同的，可能需要不同的配置。这就是为什么，Netmaker 使用一套默认设置，则网格内的所有内容都是完全可配置的。</p><h3><span id="systemd">SystemD</span></h3><p>SystemD 是一个被 Linux 广泛使用的系统服务器管理器。尽管没有被所有发行版采用，但是不管如何，它已经成为了 Linux 世界的事实标准。非 Linux 可能没有 systemd，而 Linux/Unix 发行版有可代替的 system service managers。</p><p>Netmaker 的 netclient (客户端) 会控制节点上的网络，可以通过命令行运行，或者通过作为 system 守护进程（daemon），在 Linux 上会默认以 daemon 运行（依赖于 systemd)。</p><p>从 0.8 版本开始，支持了 macOS 和 Windows，在这些操作系统中，netclient 使用 LaunchD 来启动 netclient 守护进程。</p><h3><span id="ingress-gateways">Ingress Gateways</span></h3><p>在 Netmaker 网络中的任何节点都可以成为 Ingress Gateway，Ingress Gateway 可以接受 Netmaker（WireGuard）网络外部的流量。</p><h3><span id="egress-gateways">Egress Gateways</span></h3><p>Egress Gateway 出口网关，允许将内部网络流量转发到外部指定 IP。</p><h2><span id="netmaker-安装">Netmaker 安装</span></h2><h3><span id="硬件要求">硬件要求</span></h3><p>服务器：</p><ul><li>一台可用的 VPS（最好比较干净，没有占用端口，否则需要根据自己的需要自行调整）。</li><li>公开的 IP 地址</li><li>至少 1GB RAM，1CPU（4GB RAM，2 CPU 生产环境）</li><li>2GB+ 存储</li><li>Ubuntu 20.04</li></ul><h3><span id="软件要求">软件要求</span></h3><p>域名：</p><ul><li>一个可用的域名（可选）</li><li>可以操作管理 DNS 服务(53端口)</li><li>保证 443(tcp)， 53(tcp udp), 51821-518XX(udp) 端口可用<ul><li>443 端口，Dashboard，REST API 和 gRPC</li><li>53 端口，CoreDNS</li><li>51821-518XX，WireGuard，每一个网络需要一个端口，起始端口会使用 51821，可以根据自己的网络端数量需要设定端口范围</li><li>允许防火墙 <code>sudo ufw allow proto tcp from any to any port 443 &amp;&amp; sudo ufw allow 53/udp &amp;&amp; sudo ufw allow 53/tcp &amp;&amp; sudo ufw allow 51821:51830/udp</code></li></ul></li></ul><h3><span id="一键安装">一键安装</span></h3><p>如果想使用自己的域名，比如 <code>dashboard.netmaker.example.com</code> 这样，可以参考<a href="https://docs.netmaker.org/quick-start.html" target="_blank" rel="noopener">官网</a>。这里为了演示方便，就使用一键脚本。</p><p>Netmaker 官方已经提供了一个 Docker 镜像，并且也提供了安装脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo wget -qO - https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;gravitl&#x2F;netmaker&#x2F;master&#x2F;scripts&#x2F;nm-quick.sh | bash</span><br></pre></td></tr></table></figure><p>如果没有使用自己的域名，一键脚本会使用一个 <a href="http://nip.io" target="_blank" rel="noopener">nip.io</a> 的泛域名解析映射工具根据 IP 自动获取一个域名，用来访问后台地址。</p><p>首次登录后台会要求设定用户名和密码。登录后台之后，左侧的 Networks、 Nodes、 Access Keys 是比较重要的菜单。</p><p><img src="https://img.hi-linux.com/staticfile/netmaker-dashboard-20211212154245-2022-01-13-E1wl5F.png" alt></p><p>在 Network 选项中选择创建 Network，设定 IP 段范围，然后在其他机器上依次安装客户端，添加节点到网络中即可。</p><p>在添加到之后网络之后，可以运行 <code>sudo wg show</code> 查看信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo wg show</span><br><span class="line">interface: nm-k3s</span><br><span class="line">  public key: PGeGQKOlJt4zZJX2axf15dRsWvs6QaFRF&#x2F;j&#x2F;fJUfnjw&#x3D;</span><br><span class="line">  private key: (hidden)</span><br><span class="line">  listening port: 51821</span><br><span class="line"></span><br><span class="line">peer: Cjbp&#x2F;IeTEFgPEJpOldjkaleUvlNjqg+y75hiI&#x2F;Sq61Q&#x3D;</span><br><span class="line">  endpoint: 140.XXX.XXX.XXX:51821</span><br><span class="line">  allowed ips: 10.10.11.8&#x2F;32</span><br><span class="line">  latest handshake: 2 seconds ago</span><br><span class="line">  transfer: 6.74 KiB received, 1.88 KiB sent</span><br><span class="line">  persistent keepalive: every 20 seconds</span><br></pre></td></tr></table></figure><p>通常会看到 interface 和 peer 信息。</p><h3><span id="手动安装">手动安装</span></h3><p>如果需要手动安装，也不是特别麻烦，从官网下载 docker-compose.yml 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O docker-compose.yml https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;gravitl&#x2F;netmaker&#x2F;master&#x2F;compose&#x2F;docker-compose.contained.yml</span><br><span class="line">$ sed -i &#39;s&#x2F;NETMAKER_BASE_DOMAIN&#x2F;&lt;your base domain&gt;&#x2F;g&#39; docker-compose.yml</span><br><span class="line">$ sed -i &#39;s&#x2F;SERVER_PUBLIC_IP&#x2F;&lt;your server ip&gt;&#x2F;g&#39; docker-compose.yml</span><br><span class="line">$ sed -i &#39;s&#x2F;COREDNS_IP&#x2F;&lt;default interface ip&gt;&#x2F;g&#39; docker-compose.yml</span><br></pre></td></tr></table></figure><ul><li>生成唯一的 master key:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tr -dc A-Za-z0-9 &lt;&#x2F;dev&#x2F;urandom | head -c 30 ; echo &#39;&#39;</span><br><span class="line">$ sed -i &#39;s&#x2F;REPLACE_MASTER_KEY&#x2F;&lt;your generated key&gt;&#x2F;g&#39; docker-compose.yml</span><br></pre></td></tr></table></figure><ul><li>配置 Caddy</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O &#x2F;root&#x2F;Caddyfile https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;gravitl&#x2F;netmaker&#x2F;master&#x2F;docker&#x2F;Caddyfile</span><br><span class="line">$ sed -i &#39;s&#x2F;NETMAKER_BASE_DOMAIN&#x2F;&lt;your base domain&gt;&#x2F;g&#39; &#x2F;root&#x2F;Caddyfile</span><br><span class="line">$ sed -i &#39;s&#x2F;YOUR_EMAIL&#x2F;&lt;your email&gt;&#x2F;g&#39; &#x2F;root&#x2F;Caddyfile</span><br></pre></td></tr></table></figure><ul><li>然后启动：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose up -d</span><br></pre></td></tr></table></figure><p>然后可以访问 <code>dashboard.nm.example.com</code> 后台。</p><p>需要注意的是，如果使用自己的域名需要添加一个泛域名 A 记录（wildcard A record)，比如想要后台访问地址是 <code>dashboard.nm.example.com</code> 那么需要添加 <code>*.nm.example.com</code>。</p><p>Caddy 会创建三个子域名：</p><ul><li><a href="http://dashboard.nm.example.com" target="_blank" rel="noopener">dashboard.nm.example.com</a></li><li><a href="http://api.nm.example.com" target="_blank" rel="noopener">api.nm.example.com</a></li><li><a href="http://grpc.nm.example.com" target="_blank" rel="noopener">grpc.nm.example.com</a></li></ul><h2><span id="netclient-使用">netclient 使用</span></h2><p><code>netclient</code> 是一个简单的 CLI，用于创建 WireGuard 配置和接口。netclient 可以管理任意私有网络。</p><h3><span id="安装-netclient-依赖">安装 netclient 依赖</span></h3><p>以 macOS 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install wireguard-tools</span><br></pre></td></tr></table></figure><h3><span id="安装-netclient">安装 netclient</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;gravitl&#x2F;netmaker&#x2F;releases&#x2F;download&#x2F;v0.9.3&#x2F;netclient-darwin</span><br><span class="line">$ mv netclient-darwin netclient</span><br><span class="line">$ chmod +x netclient</span><br></pre></td></tr></table></figure><h3><span id="使用-netclient-将节点加入网络">使用 netclient 将节点加入网络</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;netclient join --dnson no --name &lt;HOSTNAME&gt; --network demo --apiserver &lt;Netmaker_IP&gt;:8081 --grpcserver &lt;Netmaker_IP&gt;:50051</span><br></pre></td></tr></table></figure><h2><span id="外延">外延</span></h2><p>Nebula 是另外一个选择，同样基于 WireGuard。</p><p>更多资料可以查看 Gravitl 官网：<a href="https://gravitl.com/resources" target="_blank" rel="noopener">https://gravitl.com/resources</a></p><h2><span id="reference">reference</span></h2><ul><li><a href="https://docs.netmaker.org/" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://afeiszli.medium.com/how-to-enable-secure-access-to-your-hosted-services-using-netmaker-and-wireguard-1b3282d4b7aa" target="_blank" rel="noopener">使用 Netmaker 和 WireGuard 访问内网服务</a></li><li><a href="https://netmaker.readthedocs.io/en/master/getting-started.html" target="_blank" rel="noopener">Netmaker Getting Started</a></li><li><a href="https://itnext.io/getting-started-with-netmaker-a-wireguard-virtual-networking-platform-3d563fbd87f0" target="_blank" rel="noopener">Getting started with netmaker</a></li></ul><blockquote><p>本文转载自：「 Verne in GitHub 」，原文：<a href="https://tinyurl.com/5yuj4xbu" target="_blank" rel="noopener">https://tinyurl.com/5yuj4xbu</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Netmaker&quot;&gt;什么是 Netmaker&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gravitl/netmaker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Netmaker&lt;/a&gt; 是一个开源的、基于 [[WireGuard]] 的网络（overlay network) 控制工具，可以非常快速的用来组建 WireGuard 网络。&lt;/p&gt;
&lt;p&gt;如果你有两台连接互联网的设备，那么 Netmaker 可以组建一个安全的网络，并打通一个安全的隧道提供给两台机器通信。而如果你有数千台机器分布在不同的地区，不同的数据中心，不同的网络中，那么 Netmaker 也可以组建一个网络来提供给这些不同的节点通信。&lt;/p&gt;
&lt;p&gt;如果熟悉 AWS，那么 Netmaker 就像 VPC 一样，不过 Netmaker 可以应用在任意的机器中。从 Netmaker 网络中的机器来看，同一个网络中的机器尽管在世界各地，但其相互通信就像是在同一个局域网中一样。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="WireGuard" scheme="https://www.hi-linux.com/tags/WireGuard/"/>
    
      <category term="Netmaker" scheme="https://www.hi-linux.com/tags/Netmaker/"/>
    
  </entry>
  
  <entry>
    <title>世界是 Container 的，也是 Microservice 的，但最终还是 Serverless 的</title>
    <link href="https://www.hi-linux.com/posts/32279.html"/>
    <id>https://www.hi-linux.com/posts/32279.html</id>
    <published>2022-01-03T01:00:00.000Z</published>
    <updated>2022-01-13T05:34:07.912Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>世界上有两种基础设施，一种是拿来主义，另一种是自主可控。</p><p>原谅我也蹭个已经被浇灭的、没怎么火起来的热点。不过我们喜欢的是拿来主义，<strong>够用就行，不想也不需要过多的控制，也不想惹过多的麻烦</strong>，也就是 fully managed。</p><p>之所以想到写这篇文章，源于前几天看到的这篇来自微软 Azure 的博客内容： <a href="https://thenewstack.io/the-future-of-Kubernetes-is-serverless/" target="_blank" rel="noopener">The Future of Kubernetes Is Serverless</a> ，然后又顺手温习了一遍 AWS CTO 所撰写的 <a href="https://www.allthingsdistributed.com/2018/04/changing-calculus-containers-cloud.html" target="_blank" rel="noopener">Changing the calculus of containers in the cloud</a> 这篇文章。这两篇文章你觉得有可能有广告的嫌疑，都是在推销自家的共有云服务，但是仔细品味每一句话，我却觉得几乎没有几句废话，都很说到点子上，你可以点击进去看下原文。</p><p>有个前提需要说明的是，这里的 Serverless 指的是 Serverless infrastructure，而不是我们常听到的 AWS Lambda，Microsoft Azure Functions 或 Google Cloud Functions 等函数（功能）即服务（FaaS）技术，为了便于区分，我们将这些 FaaS 称为无服务器计算，和我们本文要介绍的无服务器基础设施还是不一样的。</p><a id="more"></a><h2><span id="iaas变革的开始">IaaS：变革的开始</span></h2><p>说到基础设施，首先来介绍下最先出现的 IaaS，即基础设施即服务。IaaS 免除了大部分硬件的 provision 工作，没人再关心机架、电源和服务器问题，使得运维工作更快捷，更轻松，感觉解放了很多人，让大家走上了富裕之路。</p><p>当然这一代的云计算服务，可不只是可以几分钟启动一台虚拟机那么简单。</p><p>除了 VM 之外， IaaS 厂商还提供了很多其他基础设施和中间件服务，这些组件被称为 building block ，比如网络和防火墙、数据库、缓存等老三样，最近还出现了非常多非常多的业务场景服务，大数据、机器学习和算法，以及IoT等，看起来就像个百货商店，使用云计算就像购物，架构设计就是购物清单，架构里的组件都可以在商店里买到。</p><p>基础设施则使用 IaaS 服务商所提供的各种服务，编写应用程序可以更专注于业务。这能带来很多好处：</p><ul><li>将精力集中投入到核心业务</li><li>加快上线速度</li><li>提高可用性</li><li>快速扩缩容</li><li>不必关心中间件的底层基础设施</li><li>免去繁杂的安装、配置、备份和安全管理等运维工作</li></ul><p>在 AWS 成为业界标准之后，各大软件公司，不管是新兴的还是老牌的，都开始着手打造自己的云，国外有微软、谷歌、IBM等，国内的 BAT 也都有自己的云，以及京东和美团这样的电商类公司也有自己的云产品，独立的厂商类似 UCloud 和青云等公司也发展的不错，甚至有开饭馆的也要出来凑热闹。而开源软件 OpenStack 和基于 OS 的创业公司和产品也层出不穷。</p><p>全民皆云。</p><h2><span id="容器云计算的深入人心">容器：云计算的深入人心</span></h2><p>之后在 2013 年，容器技术开始面向大众普及了。在 LXC 之前，容器对普通开发人员甚至 IT 业者来说几乎不是同一个维度的术语，那是些专业人员才能掌控的晦涩的术语和繁杂的命令集，大部分人都没有用过容器技术；但是随着 Docker 的出现，容器技术的门槛降低，也在软件行业变得普及。随着几年的发展，基本可以说容器技术已经非常成熟，已成为了开发的标配。</p><p>随着容器技术的成熟和普及，应用程序架构也出现了新的变化，可以说软件和基础设施的进化相辅相成。人们越来越多的认识到对技术栈的分层和解耦更加重要，不同层之间的技术和责任、所有权等界限清晰明了，这也和软件设计中的模块松耦合原则很相像。</p><p>在有了责权明晰的分层结构之后，每个人可以更容易集中在自己所关注的重点上。开发人员更关注应用程序本身了，在 Docker 火了的同时，也出现了 app-centric 的概念。甚至 CoreOS 还将自己对抗 OCI/runc 的标准称为 appc 。当然现在的 Docker 也不是原来的 Docker ，也是一个组件化的东西，很多组件，尤其是 runtime ，都可以替换为其他运行时。</p><p>和以应用程序为重心相对应的是传统的以基础设施为中心，即先有基础设施，围绕基础设施做架构设计和开发、部署，受基础设施的限制较多。而随着 IaaS 等服务的兴起，基础设施越来越简单，越来越多容易入手，而且还提供了编程化的接口，开发人员也可以非常方便的对基础设施进行管理，可以说云计算的出现也使得开发人员抢了一部分运维人员的饭碗（遗憾的是这种趋势太 high 了停不下来。。。）。</p><p>当然，现在以应用为中心这一概念也已经深入人心。特别是进化到极致的 FaaS ，自己只需要写几行代码，其他平台全给搞定了。</p><h2><span id="编排兵家必争之地">编排：兵家必争之地</span></h2><p>容器解决了代码的可移植性的问题，也使得在云计算中出现新的基础设施应用模式成为可能。使用一个一致的、不可变的部署制品，比如镜像，可以让我们从复杂的服务器部署中解脱出来，也可以非常方便的部署到不同的运行环境中（可移植性）。</p><p>但是容器的出现也增加了新的工作内容，要想使用容器运行我们的代码，就需要一套容器管理系统，在我们编写完代码，打包到容器之后，需要选择合适的运行环境，设置好正确的扩容配置，相关的网络连接，安全策略和访问控制，以及监控、日志和分布式追踪系统。</p><p>之所以出现编排系统，就是因为一台机器已经不够用了，我们要准备很多机器，在上面跑容器，而且我不关心容器跑在哪台机器上，这个交给调度系统就行了。可以说，从一定层面上，编排系统逐渐淡化了主机这一概念，我们面对的是一个资源池，是一组机器，有多少个 CPU 和多少的内存等计算资源可用。</p><p>rkt vs Docker 的战争从开始其实就可以预料到结局，但在编排系统/集群管理上，这场“战争”则有着更多的不确定性。</p><p>Mesos（DC/OS）出来的最早，还有 Twitter 等公司做案例，也是早期容器调度系统的标配；Swarm 借助其根正苗红以及简单性、和 Docker 的亲和性，也要争一分地盘；不过现在看来赢家应该是 K8s，K8s 有 Google 做靠山，有 Google 多年调度的经验，加上 RedHat/CoreOS 这些反 Docker 公司的站队，社区又做得红红火火，总之是赢了。</p><p>据说今年在哥本哈根举办的 Kubecon 有 4300 人参加。不过当初 Dockercon 也是这声势，而现在影响力已经没那么大了，有种昨日黄花、人老色衰的感觉，不知道几年之后的 Kubernetes 将来会如何，是否会出现新的产品或服务来撼动 Kubernetes 现在的地位？虽然不一定，但是我们期待啊。</p><h2><span id="serverless-infrastructure进化的结果">Serverless infrastructure：进化的结果</span></h2><p>但是呢，淡化主机的存在性也只是淡化而已，并没有完全消除主机的概念，只是我们直接面向主机的机会降低了，不再直接面向主机进行部署，也不会为某些部门分配独占的主机等。主机出了问题还得重启，资源不够了还得添加新的主机，管理工作并没有完全消失。</p><p>但是管理一套集群带来了很大的复杂性，这也和使用云计算的初衷相反，更称不上云原生。</p><p>从用户的角度再次审视一下，可以发现一个长时间被我们忽略的问题：为什么只是想运行容器，非得先买一台 VM 装好 Docker，或者自己搭建一套 Kubernetes 集群，或者使用类似 EKS 这样的服务，乐此不疲的进行各种配置和调试，不仅花费固定的资产费，还增加了很多并没有任何价值的运维管理工作。</p><p>既然我们嫌弃手动在多台主机中部署容器过于麻烦，将其交给集群管理和调度系统去做，那么维护调度系统同样繁杂的工作，是不是也可以交给别人来做，外包出去呢？</p><p>按照精益思想，这些和核心业务目标无关，不能带来任何用户价值的过程，都属于浪费行为，都需要提出。</p><p>这时候，出现了 Serverless infrastructure 服务，最早的比如国内的 <a href="https://hyper.sh/" target="_blank" rel="noopener">hyper.sh</a> （2016.8 GA），以及去年发布的 AWS 的 Fargate（2017.12），微软的 ACI（Azure Container Instance，2017.7） 等。</p><p>以 <a href="http://hyper.sh" target="_blank" rel="noopener">hyper.sh</a> 为例，使用起来和 Docker 非常类似，可以将本地的 Docker 体验原封不动的搬到云端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ brew install hyper  </span><br><span class="line">$ hyper pull mysql  </span><br><span class="line">$ hyper run mysql  </span><br><span class="line">MySQL is running...  </span><br><span class="line">$ hyper run --link mysql wordpress  </span><br><span class="line">WordPress is running...  </span><br><span class="line">$ hyper fip attach 22.33.44.55 wordpress  </span><br><span class="line">22.33.44.55 </span><br><span class="line">$ open 22.33.44.55</span><br></pre></td></tr></table></figure><p>大部分命令从 <code>docker</code> 换成 <code>hyper</code> 就可以了，体验如同使用 Docker 一模一样，第一次看到这样的应用给人的新奇感，并不亚于当初的 Docker 。</p><p>使用 Serverless infrastructure，我们可以再不必为如下事情烦恼：</p><ul><li>不必再去费心选择 VM 实例的类型，需要多少 CPU 和内存</li><li>不必再担心使用什么版本的 Docker 和集群管理软件</li><li>不必担心 VM 内中间件的安全漏洞</li><li>不必担心集群资源利用率太低</li><li>从为资源池付费变为为运行中的容器付费</li><li>完全不可变基础设施</li><li>不用因为 ps 时看到各种无聊的 agent 而心理膈应</li></ul><p>我们需要做的就是安心写自己的业务应用，构建自己的镜像，选择合适的容器大小，付钱给 cloud 厂商，让他们把系统做好，股票涨高高。</p><h2><span id="fargate此处也可以换做-aci-大厂表态">Fargate（此处也可以换做 ACI ）：大厂表态</span></h2><p>尽管 AWS 不像 GCP 那样“热衷”于容器，但是 AWS 也还是早就提供了 ECS（Elastic Container Service）服务。</p><p>去年发布的 AWS Fargate 则是个无服务器的容器服务，Fargate 是为了实现 AWS 的容器服务，比如 ECS（Elastic Container Service） 和 EKS（Elastic Kubernetes Service） 等，将容器运行所需要的基础设施进行抽象化的技术，并且现在 ECS 已经可以直接使用 Fargate。</p><p>和提供虚拟机的 EC2 不同，Fargate 提供的是容器运行实例，用户以容器作为基本的运算单位，而不必担心底层主机实例的管理，用户只需建立容器镜像，指定所需要的 CPU 和内存大小，设置相应的网络和IAM（身分管理）策略即可。</p><p>对于前面我们的疑问，AWS 的答案是基础设施的坑我们来填，你们只需要专心写好自己的应用程序就行了，你不必担心启动多少资源，我们来帮你进行容量管理，你只需要为你的使用付费就行了。</p><p>可以说 Fargate 和 Lambda 等产品都诞生于此哲学之下。</p><p>终于可以专心编写自己最擅长的 CRUD 了，happy，happy。</p><h2><span id="serverless-infrastructure-vs-serverless-compute">Serverless infrastructure vs Serverless compute</span></h2><p>再多说几句，主要是为了帮助大家辨别两种不同的无服务器架构：无服务器计算和无服务器基础设施。</p><p>说实话一下子从 EC2 迁移到 Lambda ，这步子确实有点大。</p><p>Lambda 等 FaaS 产品虽然更加简单，但是存在有如下很多缺点：</p><ul><li>使用场景：Lambda 更适合用户操作或事件驱动，不适合做守护服务、批处理等业务</li><li>灵活性：固定的内核、AMI等，无法定制</li><li>资源限制：文件系统、内存、进程线程数、请求 body 大小以及执行时间等很多限制</li><li>编程语言限制</li><li>很难做服务治理</li><li>不方便调试和测试</li></ul><p>Lambda 和容器相比最大的优势就是运维工作更少，基本没有，而且计费更精确，不需要为浪费的计算资源买单，而且 Lambda 响应更快，扩容效率会高一些。</p><p>可以认为 Fargate 等容器实例，就是结合了 EC2 实例和 Lambda 优点的产品，既像 Lambda 一样轻量，更关注核心的应用程序，还能像 EC2 一样带来很大的灵活性和可控性。</p><p>云原生会给用户更多的控制，但是需要用户更少的投入和负担。</p><p>Serverless infrastructure 可以让容器更加 cloud native。</p><h2><span id="fully-managed大势所趋">fully managed：大势所趋</span></h2><p>所谓的 fully managed，可以理解为用户花费很少的成本，就可以获得想要的产品、服务并可以进行相应的控制。</p><p>这两天，阿里云发布了 Serverless Kubernetes ，Serverless Kubernetes 与原生的 Kubernetes 完全兼容，可以采用标准的 API、CLI 来部署和管理应用，还可以继续使用各种传统资产，并且还能获得企业级的高可用和安全性保障。难道以后我们连 Kubernetes 也不用自己装了，大部分人只需要掌握 kubectl 命令就好了。</p><p>IaaS 的出现，让我们丢弃了各种 provision 工具，同时，各种 configuration management 工具如雨后春笋般的出现和普及；容器的出现，又让我们扔掉了刚买还没看几页的各种 Chef/Puppet 入门/圣经，匆忙学起 Kubernetes；有了 Serverless infrastructure，也差不多可以和各种编排工具说拜拜了。</p><p>不管你们是在单体转微服务，还是在传统上云、转容器，估计大家都会喜欢上 fully managed 的服务，人人都做 Ops，很多运维工作都可以共同分担。当然，也会有一部分运维工程师掩面而逃。</p><blockquote><p>本文转载自：「 人间指南 」，原文：<a href="https://tinyurl.com/exvzu9tb" target="_blank" rel="noopener">https://tinyurl.com/exvzu9tb</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;世界上有两种基础设施，一种是拿来主义，另一种是自主可控。&lt;/p&gt;
&lt;p&gt;原谅我也蹭个已经被浇灭的、没怎么火起来的热点。不过我们喜欢的是拿来主义，&lt;strong&gt;够用就行，不想也不需要过多的控制，也不想惹过多的麻烦&lt;/strong&gt;，也就是 fully managed。&lt;/p&gt;
&lt;p&gt;之所以想到写这篇文章，源于前几天看到的这篇来自微软 Azure 的博客内容： &lt;a href=&quot;https://thenewstack.io/the-future-of-Kubernetes-is-serverless/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Future of Kubernetes Is Serverless&lt;/a&gt; ，然后又顺手温习了一遍 AWS CTO 所撰写的 &lt;a href=&quot;https://www.allthingsdistributed.com/2018/04/changing-calculus-containers-cloud.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Changing the calculus of containers in the cloud&lt;/a&gt; 这篇文章。这两篇文章你觉得有可能有广告的嫌疑，都是在推销自家的共有云服务，但是仔细品味每一句话，我却觉得几乎没有几句废话，都很说到点子上，你可以点击进去看下原文。&lt;/p&gt;
&lt;p&gt;有个前提需要说明的是，这里的 Serverless 指的是 Serverless infrastructure，而不是我们常听到的 AWS Lambda，Microsoft Azure Functions 或 Google Cloud Functions 等函数（功能）即服务（FaaS）技术，为了便于区分，我们将这些 FaaS 称为无服务器计算，和我们本文要介绍的无服务器基础设施还是不一样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="https://www.hi-linux.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="微服务" scheme="https://www.hi-linux.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 星标 2.1 K，可能是最简单好用的纯文本流程图制作工具</title>
    <link href="https://www.hi-linux.com/posts/16328.html"/>
    <id>https://www.hi-linux.com/posts/16328.html</id>
    <published>2022-01-02T01:00:00.000Z</published>
    <updated>2022-01-13T05:34:07.910Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>今天要推荐一个可能是最简单的流程图制作工具了，小编第一次使用就有点上头，爱不释手，必须要推荐给大家。</p><p>这款工具叫 <code>flowchart-fun</code>，绝对是我见过最简单的流程图制作工具，任何人都可以简单的上手。我们看一下操作界面如下：</p><p><img src="https://img.hi-linux.com/staticfile/image-20210813122631680-2021-08-13-Xxy5KF.png" alt></p><a id="more"></a><p>流程图的制作原理很简单，图表依次从左到右画，每一行为一个方块，缩进就代表向右移动，同时会带有方向的箭头。所以使用的规则很简单，就跟正常写作一样，缩进即可。这个工具不管是用来做思维导图，或者是做流程图都很简单，对于我这种不喜欢去拖拽方块的人来说，简直就是神器。</p><p>文字描述使用方式可能比较苍白，我们来看下示例，毕竟流程图一般是一些指向性的结构。</p><p><img src="https://img.hi-linux.com/staticfile/image-20210813123002512-2021-08-13-OPu5Bf.png" alt></p><p>以上示例是不是还挺简单的。</p><p>另外一个好处，用文字表示流程图的话，可以很方便的追溯更改的历史。同时只要按规则也可以很方便自动去生成对应的文字表示。</p><blockquote><p>试用网址：<a href="https://flowchart.fun/" target="_blank" rel="noopener">https://flowchart.fun/</a></p></blockquote><p>更多项目详情请查看开源项目地址：<a href="https://github.com/tone-row/flowchart-fun" target="_blank" rel="noopener">https://github.com/tone-row/flowchart-fun</a></p><blockquote><p>本文转载自：「 GitHub精选 」，原文：<a href="https://tinyurl.com/25htjd93" target="_blank" rel="noopener">https://tinyurl.com/25htjd93</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天要推荐一个可能是最简单的流程图制作工具了，小编第一次使用就有点上头，爱不释手，必须要推荐给大家。&lt;/p&gt;
&lt;p&gt;这款工具叫 &lt;code&gt;flowchart-fun&lt;/code&gt;，绝对是我见过最简单的流程图制作工具，任何人都可以简单的上手。我们看一下操作界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/image-20210813122631680-2021-08-13-Xxy5KF.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="开源" scheme="https://www.hi-linux.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款 GitHub 星标 15.6K 的神器，可一键将 MySQL、PostgreSQL、SQL Server 等数据库转换为智能电子表格！</title>
    <link href="https://www.hi-linux.com/posts/15719.html"/>
    <id>https://www.hi-linux.com/posts/15719.html</id>
    <published>2022-01-02T01:00:00.000Z</published>
    <updated>2022-01-13T05:34:07.914Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>不知道大家了解 Airtable 么？Airtable 是海外大名鼎鼎的在线表格应用工具，Airtable 建立在这样一个信念上：软件不应该决定你的工作方式，而应该由你决定软件的工作方式。我们的使命是使任何人都能构建出满足自己需求的工具，从而使软件充分个性化。</p><a id="more"></a><p>今天推荐一个对标 Airtable 的开源产品 NocoDB，目前支持将 MySQL、PostgreSQL、SQL Server、SQLite 和 MariaDB 转换为一个智能的在线电子表格。它不仅可以把数据库和图片等数据转化成表格的方式展现，还提供了团队协作、工作流接入以及更加开放 API 服务。让团队在数据上工作，数据就在手边 “即视即用”。</p><p><img src="https://img.hi-linux.com/staticfile/OpenSourceAirtableAlternative-2021-07-30-9Ag2f4.png" alt></p><p>NocoDB 目前支持丰富的电子表格接口，简单易用。比如搜索、排序、创建/分享视图等功能都支持。</p><p><img src="https://img.hi-linux.com/staticfile/image-20210730154904436-2021-07-30-4i4Q9Q.png" alt></p><p>另外还支持与其他的第三方应用进行自动化的流程联动，比如聊天软件、邮件等。同时支持丰富的 API 用于与你现有的系统对接，以此也能看出 NocoDB 是完全以开放的生态来建设的。</p><p><img src="https://img.hi-linux.com/staticfile/image-20210730154959452-2021-07-30-XACrDF.png" alt></p><p>下图是 NocoDB 为什么开发以及作者希望达成的愿景。大概意思是现在使用电子表格的用户太多了，每天有超过 10 亿，但是个人电脑安装的电子表格计算能力有限，而这些人并不会使用像数据库一样的工具，而现状一些 SaaS 工具在使用体验上并不是很友好。nocodb 希望提供一个开放的无代码的平台，以在线电子表格的易操作为基础，帮助这些在商业上有类似数据计算需求的用户，人人都可使用。</p><p><img src="https://img.hi-linux.com/staticfile/image-20210730155031980-2021-07-30-cpjuKB.png" alt></p><p>更多项目详情请查看项目地址：<a href="https://github.com/nocodb/nocodb" target="_blank" rel="noopener">https://github.com/nocodb/nocodb</a></p><blockquote><p>本文转载自：「 GitHub精选 」，原文：<a href="https://tinyurl.com/2h4t5sn3" target="_blank" rel="noopener">https://tinyurl.com/2h4t5sn3</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道大家了解 Airtable 么？Airtable 是海外大名鼎鼎的在线表格应用工具，Airtable 建立在这样一个信念上：软件不应该决定你的工作方式，而应该由你决定软件的工作方式。我们的使命是使任何人都能构建出满足自己需求的工具，从而使软件充分个性化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="开源" scheme="https://www.hi-linux.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="NocoDB" scheme="https://www.hi-linux.com/tags/NocoDB/"/>
    
  </entry>
  
  <entry>
    <title>15 个实用的 Kubernetes 集群资源清理命令</title>
    <link href="https://www.hi-linux.com/posts/2396.html"/>
    <id>https://www.hi-linux.com/posts/2396.html</id>
    <published>2021-12-20T01:00:00.000Z</published>
    <updated>2021-12-20T06:21:52.466Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>长时间运行的集群，常会面临各种资源耗尽的问题，另外磁盘不足时 Kubelet 还会主动清理镜像增加不确定因素，本文提供了一些命令片段用于清理工作。</p></blockquote><h2><span id="kubernetes-基础对象清理">Kubernetes 基础对象清理</span></h2><ul><li>清理 Evicted 状态的 Pod</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --all-namespaces -o wide | grep Evicted | awk &#39;&#123;print $1,$2&#125;&#39; | xargs -L1 kubectl delete pod -n</span><br></pre></td></tr></table></figure><ul><li>清理 Error 状态的 Pod</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --all-namespaces -o wide | grep Error | awk &#39;&#123;print $1,$2&#125;&#39; | xargs -L1 kubectl delete pod -n</span><br></pre></td></tr></table></figure><ul><li>清理 Completed 状态的 Pod</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --all-namespaces -o wide | grep Completed | awk &#39;&#123;print $1,$2&#125;&#39; | xargs -L1 kubectl delete pod -n</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>清理没有被使用的 PV</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe -A pvc | grep -E &quot;^Name:.*$|^Namespace:.*$|^Used By:.*$&quot; | grep -B 2 &quot;&lt;none&gt;&quot; | grep -E &quot;^Name:.*$|^Namespace:.*$&quot; | cut -f2 -d: | paste -d &quot; &quot; - - | xargs -n2 bash -c &#39;kubectl -n $&#123;1&#125; delete pvc $&#123;0&#125;&#39;</span><br></pre></td></tr></table></figure><ul><li>清理没有被绑定的 PVC</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc --all-namespaces | tail -n +2 | grep -v Bound | awk &#39;&#123;print $1,$2&#125;&#39; | xargs -L1 kubectl delete pvc -n</span><br></pre></td></tr></table></figure><ul><li>清理没有被绑定的 PV</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv | tail -n +2 | grep -v Bound | awk &#39;&#123;print $1&#125;&#39; | xargs -L1 kubectl delete pv</span><br></pre></td></tr></table></figure><h2><span id="linux-清理">Linux 清理</span></h2><ul><li>查看磁盘全部空间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ df -hl &#x2F;</span><br><span class="line"></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;sda2       100G   47G   54G  47% &#x2F;</span><br></pre></td></tr></table></figure><ul><li>查看指定目录占用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ du -sh .</span><br><span class="line"></span><br><span class="line">24G.</span><br></pre></td></tr></table></figure><ul><li>删除指定前缀的文件夹</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;nfsdata</span><br><span class="line">$ ls | grep archived- |xargs -L1 rm -r</span><br></pre></td></tr></table></figure><ul><li>清理僵尸进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -A -ostat,ppid | grep -e &#39;^[Zz]&#39; | awk &#39;&#123;print &#125;&#39; | xargs kill -HUP &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2><span id="docker-清理">Docker 清理</span></h2><ul><li>查看磁盘使用情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker system df</span><br><span class="line"></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              361                 23                  178.5GB             173.8GB (97%)</span><br><span class="line">Containers          29                  9                   6.682GB             6.212GB (92%)</span><br><span class="line">Local Volumes       4                   0                   3.139MB             3.139MB (100%)</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure><ul><li>清理 none 镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | grep none | awk &#39;&#123;print $3&#125;&#39; | xargs docker rmi</span><br></pre></td></tr></table></figure><ul><li>清理不再使用的数据卷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm $(docker volume ls -q)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure><ul><li>清理缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker builder prune</span><br></pre></td></tr></table></figure><ul><li>全面清理</li></ul><p>删除关闭的容器、无用的存储卷、无用的网络、dangling 镜像（无 tag 镜像）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker system prune -f</span><br></pre></td></tr></table></figure><ul><li>清理正则匹配上的镜像</li></ul><p>这里清理的是 <code>master-8bcf8d7-20211206-111155163</code> 格式的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images |grep -E &quot;([0-9a-z]*[-])&#123;3,&#125;[0-9]&#123;9&#125;&quot; |awk &#39;&#123;print $3&#125;&#39; | xargs docker rmi</span><br></pre></td></tr></table></figure><h2><span id="设置定时">设置定时</span></h2><ul><li>查看定时任务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br></pre></td></tr></table></figure><ul><li>设置定时任务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure><p>文本新增定时任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*&#x2F;35 *&#x2F;6 * * *  docker images | grep none | awk &#39;&#123;print $3&#125;&#39; | xargs docker rmi</span><br><span class="line">45 1 * * * docker system prune -f</span><br></pre></td></tr></table></figure><p>这里第一个任务是每隔六个小时的第 35 分钟执行，第二个任务每天的 1 时 45 分执行。</p><ul><li>定时任务的格式</li></ul><p>设置定时格式: <code>* * * * * shell</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一个星号，minute，分钟，值为 0-59</span><br><span class="line">第二个星号，hour，小时，值从 0-23</span><br><span class="line">第三个星号，day，天，值为从 1-31</span><br><span class="line">第四个星号，month，月，值为从 1-12 月，或者简写的英文，比如 Nov、Feb 等</span><br><span class="line">第五个星号，week 周，值为从 0-6 或者简写的英文，Wen、Tur 等，代表周几，其中 0 代表周末</span><br></pre></td></tr></table></figure><blockquote><p>本文转载自：「 陈少文的网站 」，原文：<a href="https://tinyurl.com/yckjyedn" target="_blank" rel="noopener">https://tinyurl.com/yckjyedn</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;长时间运行的集群，常会面临各种资源耗尽的问题，另外磁盘不足时 Kubelet 还会主动清理镜像增加不确定因素，本文提供了一些命令片段用于清理工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Kubernetes-基础对象清理&quot;&gt;Kubernetes 基础对象清理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;清理 Evicted 状态的 Pod&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ kubectl get pods --all-namespaces -o wide | grep Evicted | awk &amp;#39;&amp;#123;print $1,$2&amp;#125;&amp;#39; | xargs -L1 kubectl delete pod -n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;清理 Error 状态的 Pod&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ kubectl get pods --all-namespaces -o wide | grep Error | awk &amp;#39;&amp;#123;print $1,$2&amp;#125;&amp;#39; | xargs -L1 kubectl delete pod -n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;清理 Completed 状态的 Pod&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ kubectl get pods --all-namespaces -o wide | grep Completed | awk &amp;#39;&amp;#123;print $1,$2&amp;#125;&amp;#39; | xargs -L1 kubectl delete pod -n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="https://www.hi-linux.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>云原生分布式文件存储 MinIO 保姆级中文教程</title>
    <link href="https://www.hi-linux.com/posts/43710.html"/>
    <id>https://www.hi-linux.com/posts/43710.html</id>
    <published>2021-12-07T01:00:00.000Z</published>
    <updated>2021-12-08T03:11:30.366Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>MinIO - 构建高性能的云原生数据的多云对象存储</strong></p></blockquote><p><code>MinIO</code> 提供开源、高性能、兼容 <code>s3</code> 的对象存储，为每个公共云、每个 <code>Kubernetes</code> 发行版、私有云和边缘云中无缝运行，使其成为混合云和多云对象存储的领导者。</p><ul><li><a href="https://min.io/" target="_blank" rel="noopener">MinIO 英文官网地址</a></li><li><a href="http://www.minio.org.cn/" target="_blank" rel="noopener">MinIO 中文官网地址</a></li></ul><h2><span id="1-minio-的应用场景">1. MinIO 的应用场景</span></h2><blockquote><p><strong>MinIO 是一个非常轻量的服务，可以很简单的和其他应用的结合。</strong></p></blockquote><p><code>MinIO</code> 是一个基于 <code>Apache License v2.0</code> 开源协议的对象存储服务。它兼容亚马逊 <code>S3</code> 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从 <code>KB</code> 到最大 <code>TB</code> 不等。</p><ul><li>网盘 : 海量文件</li><li>社交网站：海量图片</li><li>电商网站：海量商品图片</li><li>视频网站：海量视频文件</li></ul><p>对于中小型企业，如果不选择存储上云，那么 <code>MinIO</code> 是个不错的选择，麻雀虽小，五脏俱全。当然 <code>MinIO</code> 除了直接作为对象存储使用，还可以作为云上对象存储服务的网关层，无缝对接到 <code>Amazon S3</code> 等。</p><a id="more"></a><h2><span id="2-minio-的系统特点">2. MinIO 的系统特点</span></h2><blockquote><p><strong>介绍 MinIO 服务的主要特点和特性</strong></p></blockquote><ul><li>[1] 高性能<ul><li><code>MinIO</code> 是全球领先的对象存储先锋，在标准硬件上，读/写速度上高达 <code>183GB/s</code> 和<code> 171GB/s</code>，已经成为 <code>Hadoop HDFS</code> 的替代品。</li><li><code>MinIO</code> 用作云原生应用程序的主要存储，与传统对象存储相比，云原生应用程序需要更高的吞吐量和更低的延迟。而这些都是 <code>MinIO</code> 能够达成的性能指标。</li></ul></li></ul><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-01-2021-12-06-g5KIqw.png" alt="MinIO分布式文件存储 - 高性能"></p><ul><li>[2] 可扩展性<ul><li><code>MinIO</code> 一直秉承着 “简单可扩展” 的理念，为对象存储带来了一个简单的缩放模型。借助在此基础之上，可以实现 <code>MinIO</code> 从单个群集到其他 <code>MinIO</code> 群集联合使用的情况，并且在需要时可以跨越多个不同的数据中心。</li></ul></li></ul><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-02-2021-12-06-SDx7Q3.png" alt="MinIO分布式文件存储 - 可扩展性"></p><ul><li>[3] 开放全部源代码 + 企业级支持<ul><li><code>MinIO</code> 基于 <code>Apache V2 license</code> 的 <code>100%</code> 开放源代码的产品。</li><li>客户能够自动的、无限制、自由免费使用和集成 MinIO、自由的创新和创造、 自由的去修改、自由的再次发行新的版本和软件。其部署的多样性使软件变得更加坚固，这是专有软件无法提供的。</li></ul></li></ul><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-03-20211206173811532-2021-12-06-kKFztU.png" alt="MinIO分布式文件存储 - 开放全部源代码+企业级支持"></p><ul><li>[4] 混合云和多云<ul><li>亚马逊云的 <code>S3 API</code> 是在全球范围内达到共识的对象存储的协议。</li><li>当添加到数以百万计的私有云实例和广泛的边缘部署时，MinIO 是混合云的领导者。</li></ul></li></ul><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-04-2021-12-06-Z6G0QE.png" alt="MinIO分布式文件存储 - 混合云和多云"></p><p><strong>MinIO分布式文件存储 - 混合云和多云</strong></p><ul><li>[5] 简单而强大<ul><li>极简主义是 <code>MinIO</code> 的指导性设计原则。简单性减少了出错的机会，提高了正常运行时间，提供了可靠性，同时简单性又是性能的基础。</li><li>只需下载一个二进制文件然后执行，即可在几分钟内安装和配置 <code>MinIO</code>。<code>MinIO</code> 升级是通过一个简单命令完成的，这个命令可以无中断的完成 <code>MinIO</code> 的升级，并且不需要停机即可完成升级操作。</li></ul></li></ul><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-05-20211206173756926-2021-12-06-dKfVuA.gif" alt="MinIO分布式文件存储 - 简单而强大"></p><h2><span id="3-minio-的基础概念">3. MinIO 的基础概念</span></h2><blockquote><p><strong>了解如下基础概念，可以方便的理解其使用方式。</strong></p></blockquote><ul><li>存储相关的概念<ul><li>一个对象存储在一个 <code>Set</code></li><li>一个集群划分为多个 <code>Set</code></li><li>一个 <code>Set</code> 中的 <code>Drive</code> 尽可能分布在不同的节点上</li><li>一个 <code>Set</code> 包含的 <code>Drive</code> 数量是固定的，默认由系统根据集群规模自动计算</li></ul></li></ul><table><thead><tr><th style="text-align:left">概念名称</th><th style="text-align:left">对应含义解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>Object</code></td><td style="text-align:left">存储的基本对象；比如文件、图片等等</td></tr><tr><td style="text-align:left"><code>Bucket</code></td><td style="text-align:left">用于存储 <code>Object</code> 的逻辑空间；相互之间互相隔离；类似于系统中的顶层文件夹</td></tr><tr><td style="text-align:left"><code>Drive</code></td><td style="text-align:left">即存储数据的磁盘；所有的对象数据都会存储在 <code>Drive</code> 里面</td></tr><tr><td style="text-align:left"><code>Set</code></td><td style="text-align:left">即一组 <code>Drive</code> 的集合；分布式部署根据集群规模自动划分一个或多个 <code>Set</code></td></tr></tbody></table><ul><li><strong>纠删码 - EC - Erasure Code</strong></li></ul><p><code>MinIO</code> 使用 <strong>纠删码和校验和</strong> 机制来保证高可靠性，即便丢失一半数量(<code>N/2</code>)的硬盘，仍然可以恢复数据。纠删码是一种恢复丢失和损坏数据的数学算法，<code>MinIO</code> 采用 <code>Reed-Solomon code</code> 将对象拆分成 <code>N/2</code> 数据和 <code>N/2</code> 奇偶校验块。这就意味着如果是 <code>12</code> 块盘，一个对象会被分成 <code>6</code> 个数据块、<code>6</code> 个奇偶校验块，你可以丢失任意 <code>6</code> 块盘，仍可以从剩下的盘中的数据进行恢复。</p><p>纠删码的工作原理和 <code>RAID</code> 或者复制不同，像 <code>RAID6</code> 可以在损失两块盘的情况下不丢数据，而 <code>MinIO</code> 纠删码可以在丢失一半的盘的情况下，仍可以保证数据安全。而且 <code>MinIO</code> 纠删码是作用在对象级别，可以一次恢复一个对象，而 <code>RAID</code> 是作用在卷级别，数据恢复时间很长。<code>MinIO</code> 对每个对象单独编码，存储服务一经部署，通常情况下是不需要更换硬盘或者修复。<code>MinIO</code> 纠删码的设计目标是为了性能和尽可能的使用硬件加速。</p><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-06-2021-12-06-ytxrnO.jpg" alt="MinIO分布式文件存储 - 对象的存储形式"></p><ul><li><strong>对象的存储形式</strong></li></ul><p>文件对象上传到 <code>MinIO</code> 上面，会在对应的磁盘当中，以 <code>Bucket</code> 名称为目录，文件名称为下一级目录，文件名下是 <code>part.1</code> 和 <code>xl.meta</code>，前者是编码数据块及检验块，后者是元数据文件。</p><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-07-20211206173827530-2021-12-06-p2Otij.png" alt="MinIO分布式文件存储 - 对象的存储形式(网络采集的图片)"></p><ul><li><strong>常见的使用方案</strong></li></ul><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-08-2021-12-06-QGpa3P.png" alt="MinIO分布式文件存储 - 常见的使用方案(网络采集的图片)"></p><h2><span id="4-minio-的安装部署-单机">4. MinIO 的安装部署 - 单机</span></h2><blockquote><p><strong>建议使用容器化安装和部署方式 - 简单和好用</strong></p></blockquote><p>需要注意的是，单机版本无法使用，版本控制、对象锁定和存储桶复制等功能。如果需要使用，是需要部署 <strong>带有纠删码的分布式 MinIO</strong>。</p><ul><li>单机版 - 容器安装 - 没有纠错码版本<ul><li><code>9000</code> 端口为自带的 <code>Web</code> 网页入库</li><li><code>9001</code> 端口为使用 <code>API</code> 和客户端的连接口</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 内嵌了一个MinIO的对象服务</span><br><span class="line"># http:&#x2F;&#x2F;127.0.0.1:9000 (minioadmin:minioadmin)</span><br><span class="line">$ docker run --name&#x3D;minio-test \</span><br><span class="line">    -p 9000:9000 -p 9001:9001 \</span><br><span class="line">    quay.io&#x2F;minio&#x2F;minio server &#x2F;data --console-address &quot;:9001&quot;</span><br><span class="line"></span><br><span class="line"># 启动时自定义用户和密码</span><br><span class="line">$ docker run --name&#x3D;minio-test \</span><br><span class="line">    -p 9000:9000 -p 9001:9001 \</span><br><span class="line">    -e &quot;MINIO_ROOT_USER&#x3D;admin&quot; \</span><br><span class="line">    -e &quot;MINIO_ROOT_PASSWORD&#x3D;123456&quot; \</span><br><span class="line">    quay.io&#x2F;minio&#x2F;minio server &#x2F;data --console-address &quot;:9001&quot;</span><br><span class="line"></span><br><span class="line"># Windows系统启动</span><br><span class="line">$ docker run --name&#x3D;minio-test \</span><br><span class="line">    -p 9000:9000 -p 9001:9001 \</span><br><span class="line">    -v D:\data:&#x2F;data \</span><br><span class="line">    -e &quot;MINIO_ROOT_USER&#x3D;admin&quot; \</span><br><span class="line">    -e &quot;MINIO_ROOT_PASSWORD&#x3D;123456&quot; \</span><br><span class="line">    quay.io&#x2F;minio&#x2F;minio server &#x2F;data --console-address &quot;:9001&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 设置安全秘钥启动</span><br><span class="line">$ echo &quot;admin&quot; | docker secret create access_key -</span><br><span class="line">$ echo &quot;123456&quot; | docker secret create secret_key -</span><br><span class="line"></span><br><span class="line"># 使用docker-service的安全秘钥启动</span><br><span class="line">$ docker service create --name&#x3D;&quot;minio-service&quot; \</span><br><span class="line">    --secret&#x3D;&quot;access_key&quot; --secret&#x3D;&quot;secret_key&quot; \</span><br><span class="line">    --env&#x3D;&quot;MINIO_ROOT_USER_FILE&#x3D;my_access_key&quot; \</span><br><span class="line">    --env&#x3D;&quot;MINIO_ROOT_PASSWORD_FILE&#x3D;my_secret_key&quot; \</span><br><span class="line">    quay.io&#x2F;minio&#x2F;minio server &#x2F;data</span><br></pre></td></tr></table></figure><ul><li>单机版 - 容器安装 - 带有纠错码版本<ul><li><code>9000</code> 端口为自带的 <code>Web</code> 网页入库</li><li><code>9001</code> 端口为使用 <code>API</code> 和客户端的连接口</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 命令行启动</span><br><span class="line">$ minio server \</span><br><span class="line">    &#x2F;data1 &#x2F;data2 &#x2F;data3 &#x2F;data4 \</span><br><span class="line">    &#x2F;data5 &#x2F;data6 &#x2F;data7 &#x2F;data8</span><br><span class="line"></span><br><span class="line"># 容器启动</span><br><span class="line">$ docker run --name&#x3D;minio-test \</span><br><span class="line">  -p 9000:9000 -p 9001:9001 \</span><br><span class="line">  -v &#x2F;mnt&#x2F;data1:&#x2F;data1 \</span><br><span class="line">  -v &#x2F;mnt&#x2F;data2:&#x2F;data2 \</span><br><span class="line">  -v &#x2F;mnt&#x2F;data3:&#x2F;data3 \</span><br><span class="line">  -v &#x2F;mnt&#x2F;data4:&#x2F;data4 \</span><br><span class="line">  -v &#x2F;mnt&#x2F;data5:&#x2F;data5 \</span><br><span class="line">  -v &#x2F;mnt&#x2F;data6:&#x2F;data6 \</span><br><span class="line">  -v &#x2F;mnt&#x2F;data7:&#x2F;data7 \</span><br><span class="line">  -v &#x2F;mnt&#x2F;data8:&#x2F;data8 \</span><br><span class="line">  quay.io&#x2F;minio&#x2F;minio server &#x2F;data&#123;1...8&#125; --console-address &quot;:9001&quot;</span><br></pre></td></tr></table></figure><ul><li>单机版 - 命令安装<ul><li><code>9000</code> 端口为自带的 <code>Web</code> 网页入库</li><li><code>9001</code> 端口为使用 <code>API</code> 和客户端的连接口</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># MacOS</span><br><span class="line">$ brew install minio&#x2F;stable&#x2F;minio</span><br><span class="line">$ minio server &#x2F;data</span><br><span class="line"></span><br><span class="line"># linux</span><br><span class="line">$ apt install minio</span><br><span class="line">$ minio server &#x2F;data</span><br></pre></td></tr></table></figure><ul><li>单机版 - 二进制安装<ul><li><code>9000</code> 端口为自带的 <code>Web</code> 网页入库</li><li><code>9001</code> 端口为使用 <code>API</code> 和客户端的连接口</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># MacOS</span><br><span class="line">$ wget https:&#x2F;&#x2F;dl.min.io&#x2F;server&#x2F;minio&#x2F;release&#x2F;darwin-amd64&#x2F;minio</span><br><span class="line">$ chmod +x minio</span><br><span class="line">$ .&#x2F;minio server &#x2F;data</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">$ wget https:&#x2F;&#x2F;dl.min.io&#x2F;server&#x2F;minio&#x2F;release&#x2F;windows-amd64&#x2F;minio.exe</span><br><span class="line">$ minio.exe server D:\</span><br><span class="line"></span><br><span class="line"># Linux</span><br><span class="line">$ wget https:&#x2F;&#x2F;dl.min.io&#x2F;server&#x2F;minio&#x2F;release&#x2F;linux-amd64&#x2F;minio</span><br><span class="line">$ chmod +x minio</span><br><span class="line">$ .&#x2F;minio server &#x2F;data</span><br><span class="line"></span><br><span class="line">$ ufw allow 9000:9010&#x2F;tcp</span><br><span class="line">$ firewall-cmd --get-active-zones</span><br><span class="line">$ firewall-cmd --zone&#x3D;public --add-port&#x3D;9000&#x2F;tcp --permanent</span><br><span class="line">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2><span id="5-minio-的安装部署-分布式">5. MinIO 的安装部署 - 分布式</span></h2><blockquote><p><strong>建议使用容器化安装和部署方式 - 简单和好用</strong></p></blockquote><p>在大数据领域，通常的设计理念都是无中心和分布式。<code>MinIO</code> 也提供了分布式部署的方式，其好处在于，可以提供一个高可用的对象存储服务，确保数据不会丢失和一致。<code>MinIO</code> 在分布式和单机模式下，所有读写操作都严格遵守 <code>read-after-write</code> 一致性模型。</p><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-09-2021-12-06-WIfj1H.png" alt="MinIO分布式文件存储 - 分布式架构图"></p><ul><li><strong>命令行方式启动 - client</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 设置变量</span><br><span class="line">$ export MINIO_ROOT_USER&#x3D;&lt;ACCESS_KEY&gt;</span><br><span class="line">$ export MINIO_ROOT_PASSWORD&#x3D;&lt;SECRET_KEY&gt;</span><br><span class="line"></span><br><span class="line"># 命令行启动方式格式</span><br><span class="line">$ minio server http:&#x2F;&#x2F;host&#123;1...n&#125;&#x2F;export&#123;1...m&#125;</span><br><span class="line">$ minio server http:&#x2F;&#x2F;host&#123;1...n&#125;&#x2F;export&#123;1...m&#125; http:&#x2F;&#x2F;host&#123;o...z&#125;&#x2F;export&#123;1...m&#125;</span><br><span class="line"></span><br><span class="line"># 命令行启动方式示例</span><br><span class="line">minio server http:&#x2F;&#x2F;192.168.1.11&#x2F;export1 http:&#x2F;&#x2F;192.168.1.12&#x2F;export2 \</span><br><span class="line">             http:&#x2F;&#x2F;192.168.1.13&#x2F;export3 http:&#x2F;&#x2F;192.168.1.14&#x2F;export4 \</span><br><span class="line">             http:&#x2F;&#x2F;192.168.1.15&#x2F;export5 http:&#x2F;&#x2F;192.168.1.16&#x2F;export6 \</span><br><span class="line">             http:&#x2F;&#x2F;192.168.1.17&#x2F;export7 http:&#x2F;&#x2F;192.168.1.18&#x2F;export8</span><br></pre></td></tr></table></figure><ul><li><strong>容器方式启动 - docker</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;3.7&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  minio:</span><br><span class="line">    restart: on-failure</span><br><span class="line">    container_name: app_minio</span><br><span class="line">    image: quay.io&#x2F;minio&#x2F;minio:RELEASE.2021-11-09T03-21-45Z</span><br><span class="line">    command: server &#x2F;data --console-address &quot;:9001&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:9000&quot;</span><br><span class="line">      - &quot;81:9001&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;app_minio&#x2F;data:&#x2F;data&quot;</span><br><span class="line">    environment:</span><br><span class="line">      MINIO_ROOT_USER: admin</span><br><span class="line">      MINIO_ROOT_PASSWORD: 123456</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost:9000&#x2F;minio&#x2F;health&#x2F;live&quot;]</span><br><span class="line">      interval: 30s</span><br><span class="line">      timeout: 20s</span><br><span class="line">      retries: 3</span><br><span class="line">    networks:</span><br><span class="line">      - app_minio_network</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  app_minio_network:</span><br></pre></td></tr></table></figure><ul><li>容器方式启动 - kubernetes<ul><li><a href="https://github.com/minio/charts" target="_blank" rel="noopener">helm minio charts</a></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 安装MinIO的chart</span><br><span class="line">$ helm install stable&#x2F;minio</span><br><span class="line"></span><br><span class="line"># 容器平台上面启动服务 - 单机</span><br><span class="line">$ helm install --name minio-release \</span><br><span class="line">    --namespace minio</span><br><span class="line">    --set rootUser&#x3D;rootuser,rootPassword&#x3D;rootpass123</span><br><span class="line">    --set persistence.size&#x3D;100Gi \</span><br><span class="line">    stable&#x2F;minio</span><br><span class="line"></span><br><span class="line">#  容器平台上面启动服务 - 分布式</span><br><span class="line">$ helm install --set mode&#x3D;distributed stable&#x2F;minio</span><br><span class="line">$ helm install --set mode&#x3D;distributed,numberOfNodes&#x3D;8 stable&#x2F;minio</span><br><span class="line">$ helm install --set mode&#x3D;shared,numberOfNodes&#x3D;8 stable&#x2F;minio</span><br><span class="line">$ helm install --set persistence.enabled&#x3D;false stable&#x2F;minio</span><br></pre></td></tr></table></figure><h2><span id="6-minio-的安装部署-多租户">6. MinIO 的安装部署 - 多租户</span></h2><blockquote><p><strong>建议使用容器化安装和部署方式 - 简单和好用</strong></p></blockquote><ul><li><strong>[1] 单主机 + 单磁盘</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ minio server --address :9001 &#x2F;data&#x2F;tenant1</span><br><span class="line">$ minio server --address :9002 &#x2F;data&#x2F;tenant2</span><br><span class="line">$ minio server --address :9003 &#x2F;data&#x2F;tenant3</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-10-2021-12-06-qGORMY.jpg" alt="MinIO分布式文件存储 - 多租户"></p><ul><li><strong>[2] 单主机 + 块磁盘 (有纠错码)</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ minio server --address :9001 &#x2F;disk&#123;1...4&#125;&#x2F;data&#x2F;tenant1</span><br><span class="line">$ minio server --address :9002 &#x2F;disk&#123;1...4&#125;&#x2F;data&#x2F;tenant2</span><br><span class="line">$ minio server --address :9003 &#x2F;disk&#123;1...4&#125;&#x2F;data&#x2F;tenant3</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-11-2021-12-06-j2cFg2.jpg" alt="MinIO分布式文件存储 - 多租户"></p><ul><li><strong>[3] 多主机 + 多块磁盘 (分布式+纠错码)</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ export MINIO_ROOT_USER&#x3D;&lt;TENANT1_ACCESS_KEY&gt;</span><br><span class="line">$ export MINIO_ROOT_PASSWORD&#x3D;&lt;TENANT1_SECRET_KEY&gt;</span><br><span class="line">$ minio server --address :9001 http:&#x2F;&#x2F;192.168.10.1&#123;1...4&#125;&#x2F;data&#x2F;tenant1</span><br><span class="line"></span><br><span class="line">$ export MINIO_ROOT_USER&#x3D;&lt;TENANT2_ACCESS_KEY&gt;</span><br><span class="line">$ export MINIO_ROOT_PASSWORD&#x3D;&lt;TENANT2_SECRET_KEY&gt;</span><br><span class="line">$ minio server --address :9002 http:&#x2F;&#x2F;192.168.10.1&#123;1...4&#125;&#x2F;data&#x2F;tenant2</span><br><span class="line"></span><br><span class="line">$ export MINIO_ROOT_USER&#x3D;&lt;TENANT3_ACCESS_KEY&gt;</span><br><span class="line">$ export MINIO_ROOT_PASSWORD&#x3D;&lt;TENANT3_SECRET_KEY&gt;</span><br><span class="line">$ minio server --address :9003 http:&#x2F;&#x2F;192.168.10.1&#123;1...4&#125;&#x2F;data&#x2F;tenant3</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-12-20211206174412358-2021-12-06-0zVHNj.jpg" alt="MinIO分布式文件存储 - 多租户"></p><h2><span id="7-minio-的网页使用">7. MinIO 的网页使用</span></h2><blockquote><p><strong>安装部署完成之后，建议使用界面操作，简单好用！</strong></p></blockquote><ul><li>[1] 运行服务 - docker-compose<ul><li><a href="https://raw.githubusercontent.com/minio/minio/master/docs/orchestration/docker-compose/docker-compose.yaml" target="_blank" rel="noopener"><code>docker-compose.yaml</code></a></li><li><a href="https://raw.githubusercontent.com/minio/minio/master/docs/orchestration/docker-compose/nginx.conf" target="_blank" rel="noopener"><code>nginx.conf</code></a></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line"></span><br><span class="line">x-minio-common: &amp;minio-common</span><br><span class="line">  image: quay.io&#x2F;minio&#x2F;minio:RELEASE.2021-11-24T23-19-33Z</span><br><span class="line">  command: server --console-address &quot;:9001&quot; http:&#x2F;&#x2F;minio&#123;1...4&#125;&#x2F;data&#123;1...2&#125;</span><br><span class="line">  expose:</span><br><span class="line">    - &quot;9000&quot;</span><br><span class="line">    - &quot;9001&quot;</span><br><span class="line">  environment:</span><br><span class="line">    MINIO_ROOT_USER: minio</span><br><span class="line">    MINIO_ROOT_PASSWORD: minio123</span><br><span class="line">  healthcheck:</span><br><span class="line">    test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost:9000&#x2F;minio&#x2F;health&#x2F;live&quot;]</span><br><span class="line">    interval: 30s</span><br><span class="line">    timeout: 20s</span><br><span class="line">    retries: 3</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  minio1:</span><br><span class="line">    &lt;&lt;: *minio-common</span><br><span class="line">    hostname: minio1</span><br><span class="line">    volumes:</span><br><span class="line">      - data1-1:&#x2F;data1</span><br><span class="line">      - data1-2:&#x2F;data2</span><br><span class="line"></span><br><span class="line">  minio2:</span><br><span class="line">    &lt;&lt;: *minio-common</span><br><span class="line">    hostname: minio2</span><br><span class="line">    volumes:</span><br><span class="line">      - data2-1:&#x2F;data1</span><br><span class="line">      - data2-2:&#x2F;data2</span><br><span class="line"></span><br><span class="line">  minio3:</span><br><span class="line">    &lt;&lt;: *minio-common</span><br><span class="line">    hostname: minio3</span><br><span class="line">    volumes:</span><br><span class="line">      - data3-1:&#x2F;data1</span><br><span class="line">      - data3-2:&#x2F;data2</span><br><span class="line"></span><br><span class="line">  minio4:</span><br><span class="line">    &lt;&lt;: *minio-common</span><br><span class="line">    hostname: minio4</span><br><span class="line">    volumes:</span><br><span class="line">      - data4-1:&#x2F;data1</span><br><span class="line">      - data4-2:&#x2F;data2</span><br><span class="line"></span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx:1.19.2-alpine</span><br><span class="line">    hostname: nginx</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf:ro</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9000:9000&quot;</span><br><span class="line">      - &quot;9001:9001&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - minio1</span><br><span class="line">      - minio2</span><br><span class="line">      - minio3</span><br><span class="line">      - minio4</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  data1-1:</span><br><span class="line">  data1-2:</span><br><span class="line">  data2-1:</span><br><span class="line">  data2-2:</span><br><span class="line">  data3-1:</span><br><span class="line">  data3-2:</span><br><span class="line">  data4-1:</span><br><span class="line">  data4-2:</span><br></pre></td></tr></table></figure><ul><li><strong>[2] 启动服务</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker-compose</span><br><span class="line">$ docker stack deploy --compose-file docker-compose.yaml minio</span><br></pre></td></tr></table></figure><ul><li><strong>[3] 界面登录</strong></li></ul><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-13-20211206174432974-2021-12-06-k00IiE.png" alt="MinIO分布式文件存储 - 网页地址"></p><p><img src="https://img.hi-linux.com/staticfile/minio-file-storage-14-2021-12-06-2dPHBS.png" alt="MinIO分布式文件存储 - 网页地址"></p><h2><span id="8-minio-客户端使用">8. MinIO 客户端使用</span></h2><blockquote><p><strong>MinIO Client (mc) provides a modern alternative to UNIX commands</strong></p></blockquote><ul><li><strong>[1] MC 命令行工具安装</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 容器安装</span><br><span class="line">$ docker pull minio&#x2F;mc</span><br><span class="line">$ docker run minio&#x2F;mc ls play</span><br><span class="line">$ docker run -it --entrypoint&#x3D;&#x2F;bin&#x2F;sh minio&#x2F;mc</span><br><span class="line"></span><br><span class="line"># MacOS</span><br><span class="line">brew install minio&#x2F;stable&#x2F;mc</span><br><span class="line"></span><br><span class="line"># Linux</span><br><span class="line">$ wget http:&#x2F;&#x2F;dl.minio.org.cn&#x2F;client&#x2F;mc&#x2F;release&#x2F;linux-amd64&#x2F;mc</span><br><span class="line">chmod +x mc</span><br><span class="line"></span><br><span class="line"># 自动补全</span><br><span class="line">mc --autocompletion</span><br></pre></td></tr></table></figure><ul><li>[2] MC 命令行参数介绍<ul><li><code>mc xxx</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">alias        设置&#x2F;移除&#x2F;列出自定义的别名</span><br><span class="line">ls           列出文件和文件夹</span><br><span class="line">mb           创建一个存储桶或一个文件夹</span><br><span class="line">rb           移除一个桶</span><br><span class="line">cp           拷贝文件和对象</span><br><span class="line">mirror       给存储桶和文件夹做镜像</span><br><span class="line">cat          显示文件和对象内容</span><br><span class="line">head         显示对象的第n行</span><br><span class="line">pipe         将一个STDIN重定向到一个对象或者文件或者STDOUT</span><br><span class="line">share        生成用于共享的URL</span><br><span class="line">find         基于参数查找文件</span><br><span class="line">sql          在对象上运行SQL查询</span><br><span class="line">stat         显示对象元信息</span><br><span class="line">mv           移动文件和对象</span><br><span class="line">tree         以树的格式列出桶和对象</span><br><span class="line">du           统计磁盘使用情况</span><br><span class="line">retention    设置对象和桶的保留</span><br><span class="line">legalhold    设置对象的合法持有</span><br><span class="line">diff         对两个文件夹或者存储桶比较差异</span><br><span class="line">rm           删除文件和对象</span><br><span class="line">encrypt      管理桶加密配置</span><br><span class="line">events       管理对象通知</span><br><span class="line">watch        监听文件和对象的事件</span><br><span class="line">undo         取消PUT&#x2F;DELETE操作</span><br><span class="line">policy       管理访问策略</span><br><span class="line">tag          管理桶和对象的标签</span><br><span class="line">ilm          管理桶的生命周期</span><br><span class="line">version      输出版本信息</span><br><span class="line">replicate    配置服务器端桶复制</span><br><span class="line">admin        管理Minio服务器</span><br><span class="line">update       检查软件更新</span><br></pre></td></tr></table></figure><ul><li>[3] MC 服务端命令参数<ul><li><code>mc admin xxx</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service     服务重启并停止所有MinIO服务器</span><br><span class="line">update      更新更新所有MinIO服务器</span><br><span class="line">info        信息显示MinIO服务器信息</span><br><span class="line">user        管理用户</span><br><span class="line">group       管理小组</span><br><span class="line">policy      MinIO服务器中定义的策略管理策略</span><br><span class="line">config      配置管理MinIO服务器配置</span><br><span class="line">heal        修复MinIO服务器上的磁盘，存储桶和对象</span><br><span class="line">profile     概要文件生成概要文件数据以进行调试</span><br><span class="line">top         顶部提供MinIO的顶部统计信息</span><br><span class="line">trace       跟踪显示MinIO服务器的http跟踪</span><br><span class="line">console     控制台显示MinIO服务器的控制台日志</span><br><span class="line">prometheus  Prometheus管理Prometheus配置</span><br><span class="line">kms         kms执行KMS管理操作</span><br><span class="line">bucket      管理MinIO服务器中定义的存储桶</span><br></pre></td></tr></table></figure><ul><li><strong>[4] 示例演示</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># MinIO云存储配置</span><br><span class="line">mc alias set minio http:&#x2F;&#x2F;192.168.1.51 admin 123456</span><br><span class="line">mc alias set s3 https:&#x2F;&#x2F;s3.amazonaws.com admin 123456</span><br><span class="line">mc alias set gcs  https:&#x2F;&#x2F;storage.googleapis.com admin 123456</span><br><span class="line"></span><br><span class="line"># 开始操作云存储 - 列出所有存储桶</span><br><span class="line">mc ls play</span><br><span class="line"></span><br><span class="line"># 创建一个桶</span><br><span class="line">mc mb play&#x2F;mybucket</span><br><span class="line"></span><br><span class="line"># 上传东西</span><br><span class="line">mc cp myobject.txt play&#x2F;mybucket</span><br></pre></td></tr></table></figure><h2><span id="9-minio-python-sdk">9. MinIO Python SDK</span></h2><blockquote><p><strong>Python 代码操作 MinIO 服务</strong></p></blockquote><ul><li><a href="https://docs.min.io/docs/python-client-quickstart-guide.html" target="_blank" rel="noopener">MinIO Python SDK for Amazon S3 Compatible Cloud Storage Slack</a></li><li><a href="https://docs.min.io/docs/python-client-api-reference" target="_blank" rel="noopener">Python Client API Reference</a></li><li><a href="https://github.com/minio/minio-py/tree/release/examples" target="_blank" rel="noopener">MinIO Python SDK Examples</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装pip包</span><br><span class="line">pip3 install minio</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># file_uploader.py</span><br><span class="line">from minio import Minio</span><br><span class="line">from minio.error import S3Error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # Create a client with the MinIO server playground, its access key</span><br><span class="line">    # and secret key.</span><br><span class="line">    client &#x3D; Minio(</span><br><span class="line">        &quot;play.min.io&quot;,</span><br><span class="line">        access_key&#x3D;&quot;Q3AM3UQ867SPQQA43P2F&quot;,</span><br><span class="line">        secret_key&#x3D;&quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # Make &#39;asiatrip&#39; bucket if not exist.</span><br><span class="line">    found &#x3D; client.bucket_exists(&quot;asiatrip&quot;)</span><br><span class="line">    if not found:</span><br><span class="line">        client.make_bucket(&quot;asiatrip&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;Bucket &#39;asiatrip&#39; already exists&quot;)</span><br><span class="line">    </span><br><span class="line">    # Upload &#39;&#x2F;home&#x2F;user&#x2F;Photos&#x2F;asiaphotos.zip&#39; as object name</span><br><span class="line">    # &#39;asiaphotos-2015.zip&#39; to bucket &#39;asiatrip&#39;.</span><br><span class="line">    client.fput_object(</span><br><span class="line">        &quot;asiatrip&quot;, &quot;asiaphotos-2015.zip&quot;, &quot;&#x2F;home&#x2F;user&#x2F;Photos&#x2F;asiaphotos.zip&quot;,</span><br><span class="line">    )</span><br><span class="line">    print(</span><br><span class="line">        &quot;&#39;&#x2F;home&#x2F;user&#x2F;Photos&#x2F;asiaphotos.zip&#39; is successfully uploaded as &quot;</span><br><span class="line">        &quot;object &#39;asiaphotos-2015.zip&#39; to bucket &#39;asiatrip&#39;.&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    try:</span><br><span class="line">        main()</span><br><span class="line">    except S3Error as exc:</span><br><span class="line">        print(&quot;error occurred.&quot;, exc)</span><br></pre></td></tr></table></figure><blockquote><p>本文转载自：「 Escape 」，原文：<a href="https://tinyurl.com/yc3edfec" target="_blank" rel="noopener">https://tinyurl.com/yc3edfec</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MinIO - 构建高性能的云原生数据的多云对象存储&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;MinIO&lt;/code&gt; 提供开源、高性能、兼容 &lt;code&gt;s3&lt;/code&gt; 的对象存储，为每个公共云、每个 &lt;code&gt;Kubernetes&lt;/code&gt; 发行版、私有云和边缘云中无缝运行，使其成为混合云和多云对象存储的领导者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://min.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MinIO 英文官网地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.minio.org.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MinIO 中文官网地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-MinIO-的应用场景&quot;&gt;1. MinIO 的应用场景&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MinIO 是一个非常轻量的服务，可以很简单的和其他应用的结合。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;MinIO&lt;/code&gt; 是一个基于 &lt;code&gt;Apache License v2.0&lt;/code&gt; 开源协议的对象存储服务。它兼容亚马逊 &lt;code&gt;S3&lt;/code&gt; 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从 &lt;code&gt;KB&lt;/code&gt; 到最大 &lt;code&gt;TB&lt;/code&gt; 不等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网盘 : 海量文件&lt;/li&gt;
&lt;li&gt;社交网站：海量图片&lt;/li&gt;
&lt;li&gt;电商网站：海量商品图片&lt;/li&gt;
&lt;li&gt;视频网站：海量视频文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于中小型企业，如果不选择存储上云，那么 &lt;code&gt;MinIO&lt;/code&gt; 是个不错的选择，麻雀虽小，五脏俱全。当然 &lt;code&gt;MinIO&lt;/code&gt; 除了直接作为对象存储使用，还可以作为云上对象存储服务的网关层，无缝对接到 &lt;code&gt;Amazon S3&lt;/code&gt; 等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="教程" scheme="https://www.hi-linux.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="MinIO" scheme="https://www.hi-linux.com/tags/MinIO/"/>
    
  </entry>
  
  <entry>
    <title>关于 Kubernetes 的 Secret 并不安全这件事</title>
    <link href="https://www.hi-linux.com/posts/45918.html"/>
    <id>https://www.hi-linux.com/posts/45918.html</id>
    <published>2021-11-25T01:00:00.000Z</published>
    <updated>2021-12-18T08:41:42.651Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>K8s 提供了 Secret 资源供我们来保存、设置一些敏感信息，比如 API endpoint 地址，各种用户密码或 token 之类的信息。在没有使用 K8s 的时候，这些信息可能是通过配置文件或者环境变量在部署的时候设置的。</p><p>不过，Secret 其实并不安全，稍微用 kubectl 查看过 Secret 的人都知道，我们可以非常方便的看到 Secret 的原文，只要有相关的权限即可，尽管它的内容是 base64 编码的，这基本上等同于明文。</p><p>所以说，K8s 原生的 Secret 是非常简单的，不是特别适合在大型公司里直接使用，对 RBAC 的挑战也比较大，很多不该看到明文信息的人可能都能看到。</p><p>尤其是现在很多公司采用了所谓的 GitOps 理念，很多东西都需要放到 VCS，比如 git 中，这一问题就更日益突出，因为 VCS 也得需要设置必要的权限。</p><a id="more"></a><h2><span id="问题">问题</span></h2><p>简单来说，大概有几个地方都可以让不应该看到 Secret 内容的人获得 Secret 内容：</p><ul><li>etcd 存储</li><li>通过 API server</li><li>在 node 上直接查看文件</li></ul><p>这里我们以这个例子来看一下 Secret 在 K8s 中的使用情况。</p><p>Secret 定义， 用户名和密码分别为 <code>admin</code> 和 <code>hello-secret</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecret</span><br><span class="line">type: Opaque</span><br><span class="line">data:</span><br><span class="line">  username: YWRtaW4&#x3D;</span><br><span class="line">  password: aGVsbG8tc2VjcmV0Cg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>Pod 定义，这里我们将 Secret 作为 volume mount 到容器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: mypod</span><br><span class="line">    image: docker.io&#x2F;containerstack&#x2F;alpine-stress</span><br><span class="line">    command:</span><br><span class="line">      - top</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: foo</span><br><span class="line">      mountPath: &quot;&#x2F;etc&#x2F;foo&quot;</span><br><span class="line">      readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">  - name: foo</span><br><span class="line">    secret:</span><br><span class="line">      secretName: mysecret</span><br></pre></td></tr></table></figure><p>Pod 启动后，我们可以到容器中来查看 Secret 作为 volume mount 到容器后的文件内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl exec -it mypod sh</span><br><span class="line">&#x2F; # cd &#x2F;etc&#x2F;foo&#x2F;</span><br><span class="line">&#x2F;etc&#x2F;foo # ls -tal</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x    1 root     root          4096 Apr 14 08:55 ..</span><br><span class="line">drwxrwxrwt    3 root     root           120 Apr 14 08:55 .</span><br><span class="line">drwxr-xr-x    2 root     root            80 Apr 14 08:55 ..2021_04_14_08_55_54.401661151</span><br><span class="line">lrwxrwxrwx    1 root     root            31 Apr 14 08:55 ..data -&gt; ..2021_04_14_08_55_54.401661151</span><br><span class="line">lrwxrwxrwx    1 root     root            15 Apr 14 08:55 password -&gt; ..data&#x2F;password</span><br><span class="line">lrwxrwxrwx    1 root     root            15 Apr 14 08:55 username -&gt; ..data&#x2F;username</span><br><span class="line">&#x2F;etc&#x2F;foo # ls -tal ..2021_04_14_08_55_54.401661151</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x    2 root     root            80 Apr 14 08:55 .</span><br><span class="line">drwxrwxrwt    3 root     root           120 Apr 14 08:55 ..</span><br><span class="line">-rw-r--r--    1 root     root            13 Apr 14 08:55 password</span><br><span class="line">-rw-r--r--    1 root     root             5 Apr 14 08:55 username</span><br><span class="line">&#x2F;etc&#x2F;foo # cat password</span><br><span class="line">hello-secret</span><br><span class="line">&#x2F;etc&#x2F;foo #</span><br></pre></td></tr></table></figure><h3><span id="etcd-存储">etcd 存储</span></h3><p>API server 中的资源都保存在 etcd 中，我们可以直接从文件看到相关内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># hexdump -C &#x2F;var&#x2F;lib&#x2F;etcd&#x2F;member&#x2F;snap&#x2F;db | grep -A 5 -B 5 hello</span><br><span class="line">00043640  12 00 1a 07 64 65 66 61  75 6c 74 22 00 2a 24 32  |....default&quot;.*$2|</span><br><span class="line">00043650  35 66 37 35 38 30 38 2d  37 33 31 33 2d 34 38 64  |5f75808-7313-48d|</span><br><span class="line">00043660  39 2d 39 61 38 65 2d 38  61 35 66 66 32 32 63 64  |9-9a8e-8a5ff22cd|</span><br><span class="line">00043670  64 35 39 32 00 38 00 42  08 08 98 dc da 83 06 10  |d592.8.B........|</span><br><span class="line">00043680  00 7a 00 12 19 0a 08 70  61 73 73 77 6f 72 64 12  |.z.....password.|</span><br><span class="line">00043690  0d 68 65 6c 6c 6f 2d 73  65 63 72 65 74 0a 12 11  |.hello-secret...|</span><br><span class="line">000436a0  0a 08 75 73 65 72 6e 61  6d 65 12 05 61 64 6d 69  |..username..admi|</span><br><span class="line">000436b0  6e 1a 06 4f 70 61 71 75  65 1a 00 22 00 00 00 00  |n..Opaque..&quot;....|</span><br><span class="line">000436c0  00 00 00 08 95 5f 00 00  00 00 00 00 00 00 0a 37  |....._.........7|</span><br><span class="line">000436d0  2f 72 65 67 69 73 74 72  79 2f 73 65 72 76 69 63  |&#x2F;registry&#x2F;servic|</span><br><span class="line">000436e0  65 73 2f 65 6e 64 70 6f  69 6e 74 73 2f 6b 75 62  |es&#x2F;endpoints&#x2F;kub|</span><br></pre></td></tr></table></figure><p>可以看到，基本 yaml 中的内容都是明文存放的，而且是进行 base64 解码之后的内容。</p><p>使用下面的命令也可以获得类似的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ETCDCTL_API&#x3D;3 etcdctl get --prefix &#x2F;registry&#x2F;secrets&#x2F;default&#x2F;mysecret | hexdump -C</span><br></pre></td></tr></table></figure><p>etcd 本来存储的是明文数据，这个好像已经从 1.7 开始支持 <a href="https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/" target="_blank" rel="noopener">加密存储</a> 了，而且直接访问 etcd 从物理上来说也不是那么容易。</p><h3><span id="api-server">API server</span></h3><p>通过 API server 则简单的多，只要有权限就可以从任何节点上通过访问 API server 来得到 secret 的明文内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get secret mysecret -o yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  password: aGVsbG8tc2VjcmV0Cg&#x3D;&#x3D;</span><br><span class="line">  username: YWRtaW4&#x3D;</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2021-04-14T08:55:52Z&quot;</span><br><span class="line">  name: mysecret</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;2196&quot;</span><br><span class="line">  selfLink: &#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;secrets&#x2F;mysecret</span><br><span class="line">  uid: 25f75808-7313-48d9-9a8e-8a5ff22cdd59</span><br><span class="line">type: Opaque</span><br></pre></td></tr></table></figure><h3><span id="节点上">节点上</span></h3><p>在节点上也可以看到 Secret 文件的内容。</p><p>查找 foo volume 的挂载点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount | grep foo </span><br><span class="line">tmpfs on &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;280451e8-512b-489c-b5dd-df2b1a3c9b29&#x2F;volumes&#x2F;kubernetes.io~secret&#x2F;foo type tmpfs (rw,relatime)</span><br></pre></td></tr></table></figure><p>查看这个 volume 下面的文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ls -tal &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;280451e8-512b-489c-b5dd-df2b1a3c9b29&#x2F;volumes&#x2F;kubernetes.io~secret&#x2F;foo</span><br><span class="line">total 4</span><br><span class="line">drwxrwxrwt 3 root root  120 4月  14 16:55 .</span><br><span class="line">drwxr-xr-x 2 root root   80 4月  14 16:55 ..2021_04_14_08_55_54.401661151</span><br><span class="line">lrwxrwxrwx 1 root root   31 4月  14 16:55 ..data -&gt; ..2021_04_14_08_55_54.401661151</span><br><span class="line">lrwxrwxrwx 1 root root   15 4月  14 16:55 password -&gt; ..data&#x2F;password</span><br><span class="line">lrwxrwxrwx 1 root root   15 4月  14 16:55 username -&gt; ..data&#x2F;username</span><br><span class="line">drwxr-xr-x 4 root root 4096 4月  14 16:55 ..</span><br><span class="line"></span><br><span class="line"># cat &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;280451e8-512b-489c-b5dd-df2b1a3c9b29&#x2F;volumes&#x2F;kubernetes.io~secret&#x2F;foo&#x2F;password</span><br><span class="line">hello-secret</span><br></pre></td></tr></table></figure><h2><span id="第三方方案">第三方方案</span></h2><p>针对上面提到的可能泄露 Secret 的几点，大概解决方案不难想到如下几种：</p><ul><li>etcd 加密</li><li>API server 严格进行权限设计</li><li>强化 node 节点用户权限管理和系统安全</li></ul><p>不过，要相关确保 Secret 的绝对安全，上面这几种方案都是必须，缺一不可，缺少了那一个都相当于在墙上留了一个洞。</p><p>社区和公有云提供商都有一些产品和方案，我们可以参考一下。</p><ul><li><a href="https://github.com/shyiko/kubesec" target="_blank" rel="noopener">shyiko/kubesec</a>: Secure Secret management for Kubernetes (with gpg, Google Cloud KMS and AWS KMS backends)</li><li><a href="https://github.com/bitnami-labs/sealed-secrets" target="_blank" rel="noopener">bitnami-labs/sealed-secrets</a>: A Kubernetes controller and tool for one-way encrypted Secrets</li><li><a href="https://www.vaultproject.io/docs/platform/k8s" target="_blank" rel="noopener">Vault by HashiCorp</a></li><li><a href="https://github.com/mozilla/sops" target="_blank" rel="noopener">mozilla/sops</a></li><li><a href="https://github.com/external-secrets/kubernetes-external-secrets" target="_blank" rel="noopener">Kubernetes External Secrets</a></li><li><a href="https://github.com/Soluto/kamus" target="_blank" rel="noopener">Kamus</a></li></ul><h3><span id="shyikokubesec">shyiko/kubesec</span></h3><p>kubesec 只对 Secret 中数据进行加密/解密，支持如下 key 管理服务或软件：</p><ul><li>AWS Key Management Service</li><li>Google Cloud KMS</li><li>GnuPG</li></ul><h3><span id="bitnami-labssealed-secrets">bitnami-labs/sealed-secrets</span></h3><p>Bitnami 在 K8s 领域也是一家人人知晓的公司，输出了很多技术和最佳实践。</p><p><img src="https://img.hi-linux.com/staticfile/sealed-secrets-20210520174450379-2021-05-20-foc4mT.png" alt></p><p><em>本图来自 <a href="https://engineering.bitnami.com/articles/sealed-secrets.html" target="_blank" rel="noopener">Sealed Secrets: Protecting your passwords before they reach Kubernetes</a></em></p><p>SealeSecret 将 secret 资源整个加密保存为 <code>SealedSecret</code> 资源，而解密只能由该集群中的 controller 进行。</p><p>SealeSecret 提供了一个 kubeseal 工具来对 secret 资源进行加密，这个过程需要一个公开 key（公钥），这个公开 key 就是从 SealeSecret controller 拿到的。</p><p>不过，只从从说明文档来看， SealeSecret controller 加密解密所依赖的 key，也是通过普通的 Secret 来保存的，这难道不是一个问题？同时也增加了 SealeSecret controller 的运维成本。</p><h3><span id="mozillasops">mozilla/sops</span></h3><p>严格来说， sops 跟 K8s 并没有什么必然关系，它只是一个支持 YAML/JSON/ENV/INI 等文件格式的加密文件编辑器，它支持 AWS KMS, GCP KMS, Azure Key Vault, age, 和 PGP 等服务与应用。</p><p>如果有有兴趣可以看它的<a href="https://github.com/mozilla/sops" target="_blank" rel="noopener">主页</a>。</p><h3><span id="kubernetes-external-secrets">Kubernetes External Secrets</span></h3><p>Kubernetes External Secrets 是知名域名服务提供商 godaddy 开发的开源软件，它可以直接将保存在外部 KMS 中的机密信息传给 K8s 。目前支持的 KSM 包括：</p><ul><li>AWS Secrets Manager</li><li>AWS System Manager</li><li>Hashicorp Vault</li><li>Azure Key Vault</li><li>GCP Secret Manager</li><li>Alibaba Cloud KMS Secret Manager</li></ul><p>它通过自定义 controller 和 CRD 来实现，具体架构图如下：</p><p><img src="https://img.hi-linux.com/staticfile/kubernetes-external-secrets-architecture-2021-05-20-iCQv1L.png" alt="img"></p><p>具体来说用户需要创建一个 ExternalSecret 类型的资源，来将外部 KMS 的数据映射到 K8s 的 Secret 上。</p><p>不过，这种方式大概只有两点好处：</p><ul><li>统一 key 的管理，或者沿用既有 key 资产</li><li>key 信息不想放到 VCS 等</li></ul><p>对于防止 Sercet 信息泄露，作用不大，因为其明文资源还是可以在 API server/etcd 上看到。</p><p>或者说，External Secrets 真正做的事情，也就是从外部 KMS 中的 key ，映射成 K8s 中的 Secret 资源而已，对保证在 K8s 集群中数据的安全性用处不大。</p><h3><span id="kamus">Kamus</span></h3><p>Kamus 同样提供了加密 key 的方法（一个命令行工具），同时只有通过 K8s 中的 controller 才能对这个 key 进行解密。不过它 保存在 K8s 中的 Secret 是加密的状态，用户不能像 External Secrets 那样直接获得 Secret 的明文内容。</p><p>Kamus 由 3 个组件组成，分别是：</p><ul><li>Encrypt API</li><li>Decrypt API</li><li>Key Management System (KMS)</li></ul><p>KMS 是一个外部加密服务的封装，目前支持如下服务： - AES - AWS KMS - Azure KeyVault - Google Cloud KMS</p><p>Kamus 以 service account 为单位对 secret 进行加密，之后 Pod 会通过 service account 来请求 Kamus 的解密服务来对该 secret 进行解密。</p><p>对 K8s 来说，解密 secret 可以通过 init container 来实现：定义一个 基于内存的 emptyDir ，业务容器和 init 容器使用同一个 volume， init 容器解密后，将数据存放到该 volume 下，之后业务容器就可以使用解密后的 secret 数据了。</p><p><img src="https://img.hi-linux.com/staticfile/kamus-pod-2021-05-20-5Z6xjw.png" alt="img"></p><h3><span id="vault-by-hashicorp">Vault by HashiCorp</span></h3><p>HashiCorp 公司就不多说，在云计算/DevOps领域也算是数一数二的公司了。</p><p>Vault 本身就是一个 KMS 类似的服务，用于管理机密数据。对于 K8s 的原生 secret ，大概提供了如下两种方式的支持：</p><ul><li><a href="https://www.vaultproject.io/docs/platform/k8s/injector" target="_blank" rel="noopener">Agent Sidecar Injector/vault-k8s</a></li><li><a href="https://www.vaultproject.io/docs/platform/k8s/csi" target="_blank" rel="noopener">Vault CSI Provider</a></li></ul><h4><span id="agent-sidecar-injector">Agent Sidecar Injector</span></h4><p>这种方式和上面的 Kamus 类似，也是需要两个组件：</p><ul><li>Mutation webhook：负责修改 pod 定义，注入init/sidecar</li><li>agent-sidecar：负责获取和解密数据，将数据保存到指定的 volume/路径下</li></ul><p>Vault agent sidecar injector 不仅提供了 init container 来初始化 secret ，还通过 sidecar 来定期更新 secret ，这样就非常接近原生 secret 的实现了。</p><p>应用程序则只需要在文件系统上读取指定的文件就可以了，而不必关系如何从外部获取加密信息。</p><p>这是官方 blog 中的一个示例：</p><p>Pod 信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      annotations:</span><br><span class="line">        vault.hashicorp.com&#x2F;agent-inject: &quot;true&quot;</span><br><span class="line">        vault.hashicorp.com&#x2F;agent-inject-secret-helloworld: &quot;secrets&#x2F;helloworld&quot;</span><br><span class="line">        vault.hashicorp.com&#x2F;role: &quot;myapp&quot;</span><br></pre></td></tr></table></figure><p>这个定义中，<code>vault-k8s</code> 会对该 pod 注入 <code>vault agent</code>，并使用 <code>secrets/helloworld</code> 来初始化。Pod 运行后，可以在 <code>/vault/secrets</code> 下找到一个名为 <code>helloworld</code> 的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl exec -ti app-XXXXXXXXX -c app -- cat &#x2F;vault&#x2F;secrets&#x2F;helloworld</span><br><span class="line">data: map[password:foobarbazpass username:foobaruser]</span><br><span class="line">metadata: map[created_time:2019-12-16T01:01:58.869828167Z deletion_time: destroyed:false version:1]</span><br></pre></td></tr></table></figure><p>当然这个数据是raw data，没有经过格式化。如果想指定输出到文件中的格式，可以使用 vault 的模板功能。</p><h4><span id="vault-csi-provider">Vault CSI Provider</span></h4><p>这部分可以参考下面的社区方案部分。</p><h2><span id="社区方案">社区方案</span></h2><p>当然，社区没有理由意识不到原生 secret 的问题，因此社区也有 <a href="https://github.com/kubernetes-sigs/secrets-store-csi-driver" target="_blank" rel="noopener">Kubernetes Secrets Store CSI Driver</a> ，一种通过 CSI 接口将 Secret 集成到 K8s 的方案。</p><p>Secrets Store CSI driver（<code>secrets-store.csi.k8s.io</code>）可以让 K8s mount 多个 secret 以 volume 的形式，从外部 KMS mount 到 Pod 里。</p><p>要想使用 Secrets Store CSI Driver ，大致过程如下:</p><ul><li>定义 SecretProviderClass</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: secrets-store.csi.x-k8s.io&#x2F;v1alpha1</span><br><span class="line">kind: SecretProviderClass</span><br><span class="line">metadata:</span><br><span class="line">  name: my-provider</span><br><span class="line">spec:</span><br><span class="line">  provider: vault   # accepted provider options: azure or vault or gcp</span><br><span class="line">  parameters:       # provider-specific parameters</span><br></pre></td></tr></table></figure><ul><li>为 Pod 配置 Volume</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">kind: Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: secrets-store-inline</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: k8s.gcr.io&#x2F;e2e-test-images&#x2F;busybox:1.29</span><br><span class="line">    name: busybox</span><br><span class="line">    command:</span><br><span class="line">    - &quot;&#x2F;bin&#x2F;sleep&quot;</span><br><span class="line">    - &quot;10000&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: secrets-store-inline</span><br><span class="line">      mountPath: &quot;&#x2F;mnt&#x2F;secrets-store&quot;</span><br><span class="line">      readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">    - name: secrets-store-inline</span><br><span class="line">      csi:</span><br><span class="line">        driver: secrets-store.csi.k8s.io</span><br><span class="line">        readOnly: true</span><br><span class="line">        volumeAttributes:</span><br><span class="line">          secretProviderClass: &quot;my-provider&quot;</span><br></pre></td></tr></table></figure><p>Pod 启动之后，就可以确认解密后的数据了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl exec secrets-store-inline -- ls &#x2F;mnt&#x2F;secrets-store&#x2F;</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>上面的总结都是基于互联网公开的资料而来，并没有经过亲身体验，因此有些地方可能理解有误，要想深入了解还需要自己亲手确认最好。</p><p>不过总体来说，社区这种方案可能最简单，部署也不是很麻烦，只是这就和原生的 secret 基本没什么关系了。。。</p><p>Vault 方案也很成熟，值得关注。</p><blockquote><p>本文转载自：「 人间指南 」，原文：<a href="https://tinyurl.com/y9warvpa" target="_blank" rel="noopener">https://tinyurl.com/y9warvpa</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;K8s 提供了 Secret 资源供我们来保存、设置一些敏感信息，比如 API endpoint 地址，各种用户密码或 token 之类的信息。在没有使用 K8s 的时候，这些信息可能是通过配置文件或者环境变量在部署的时候设置的。&lt;/p&gt;
&lt;p&gt;不过，Secret 其实并不安全，稍微用 kubectl 查看过 Secret 的人都知道，我们可以非常方便的看到 Secret 的原文，只要有相关的权限即可，尽管它的内容是 base64 编码的，这基本上等同于明文。&lt;/p&gt;
&lt;p&gt;所以说，K8s 原生的 Secret 是非常简单的，不是特别适合在大型公司里直接使用，对 RBAC 的挑战也比较大，很多不该看到明文信息的人可能都能看到。&lt;/p&gt;
&lt;p&gt;尤其是现在很多公司采用了所谓的 GitOps 理念，很多东西都需要放到 VCS，比如 git 中，这一问题就更日益突出，因为 VCS 也得需要设置必要的权限。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="https://www.hi-linux.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="微服务" scheme="https://www.hi-linux.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Linux 运维工程师必须知道的 6 类好习惯和 23 个教训</title>
    <link href="https://www.hi-linux.com/posts/17487.html"/>
    <id>https://www.hi-linux.com/posts/17487.html</id>
    <published>2021-11-19T01:00:00.000Z</published>
    <updated>2021-12-18T08:41:42.656Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>从事运维三年半，遇到过各式各样的问题，数据丢失，网站挂马，误删数据库文件，黑客攻击等各类问题。</p><p>今天简单整理一下，分享给各位小伙伴。</p><h2><span id="线上操作规范">线上操作规范</span></h2><p><strong>1、测试使用</strong></p><p>当初学习 Linux 的使用，从基础到服务到集群，都是在虚拟机做的，虽然老师告诉我们跟真机没有什么差别，可是对真实环境的渴望日渐上升，不过虚拟机的各种快照却让我们养成了各种手贱的习惯，以致于拿到服务器操作权限时候，就迫不及待的想去试试，记得上班第一天，老大把 root 密码交给我，由于只能使用 putty，我就想使用 xshell，于是悄悄登录服务器尝试改为 Xshell+密钥登录，因为没有测试，也没有留一个 SSH 连接，所有重启 SSHD 服务器之后，自己就被挡在服务器之外了，幸好当时我备份了 sshd_config 文件，后来让机房人员 cp 过去就可以了，幸亏这是一家小公司，不然直接就被干了……庆幸当年运气比较好。</p><p>第二个例子是关于文件同步的，大家都知道 sync 同步很快，可是他删除文件的速度大大超过了 rm -rf，在 rsync 中有一个命令是，以某目录为准同步某文件（如果第一个目录是空的，那么结果可想而知），源目录（有数据的）就会被删除，当初我就是因为误操作，以及缺乏测试，就目录写反了，关键是没有备份……生产环境数据被删了。</p><p>没备份，大家自己想后果吧，其重要性不言而喻。</p><a id="more"></a><p><strong>2、Enter 前再三确认</strong></p><p>关于 <code>rm -rf / var</code> 这种错误，我相信手快的人，或者网速比较慢的时候，出现的几率相当大，当你发现执行完之后，你的心至少是凉了半截。</p><p>大家可能会说，我按了这么多次都没出过错，不用怕，我只想说当出现一次你就明白了，不要以为那些运维事故都是在别人身上，如果你不注意，下一个就是你。</p><p><strong>3、切忌多人操作</strong></p><p>我在的上一家公司，运维管理相当混乱，举一个最典型的例子吧，离职好几任的运维都有服务器 root 密码。</p><p>通常我们运维接到任务，都会进行简单查看如果无法解决，就请求他人帮忙，可是当问题焦头烂额的时候，客服主管（懂点 Linux），网管，你上司一起调试一个服务器，当你各种百度,各种对照，完了发现，你的服务器配置文件，跟上次你修改不一样了，然后再改回来，然后再谷歌，兴冲冲发现问题，解决了，别人却告诉你，他也解决了，修改的是不同的参数……这个，我就真不知道哪个是问题真正的原因了，当然这还是好的，问题解决了，皆大欢喜，可是你遇到过你刚修改的文件，测试无效，再去修改发现文件又被修改的时候呢？真的很恼火，切忌多人操作。</p><p><strong>4、先备份后操作</strong></p><p>养成一个习惯，要修改数据时，先备份，比如 <code>.conf</code> 的配置文件。另外，修改配置文件时，建议注释原选项，然后再复制，修改。</p><p>再者说，如果第一个例子中，有数据库备份，那 rsync 的误操作不久没事了吧。所以说丢数据库非一朝一夕，随便备份一个就不用那么惨。</p><h2><span id="涉及数据">涉及数据</span></h2><p><strong>5、慎用rm -rf</strong></p><p>网上的例子很多，各种 <code>rm -rf /</code>，各种删除主数据库，各种运维事故……</p><p>一点小失误就会造成很大的损失。如果真需要删除，一定要谨慎。</p><p><strong>6、备份大于一切</strong></p><p>本来上面都有各种关于备份，但是我想把它划分在数据类再次强调，备份非常之重要哇。</p><p>我记得我的老师说过一句话，涉及到数据何种的谨慎都不为过。我就职的公司有做第三方支付网站和网贷平台的，第三方支付是每两个小时完全备份一次，网贷平台是每 20 分钟备份一次。</p><p>我不多说了，大家自己斟酌吧。</p><p><strong>7、稳定大于一切</strong></p><p>其实不止是数据，在整个服务器环境，都是稳定大于一切，不求最快，但求最稳定，求可用性，所以未经测试，不要在服务器使用新的软件，比如 Nginx+PHP-FPM，生产环境中 PHP 各种挂啊。</p><p>重启下就好了，或者换 apache 就好了。</p><p><strong>8、保密大于一切</strong></p><p>现在各种艳照门漫天飞，各种路由器后门，所以说，涉及到数据，不保密是不行的。</p><h2><span id="涉及安全">涉及安全</span></h2><p><strong>9、SSH</strong></p><ul><li>更改默认端口（当然如果专业要黑你，扫描下就出来了）</li><li>禁止 root 登录</li><li>使用普通用户+key认证+sudo规则+IP地址+用户限制</li><li>使用 hostdeny 类似的防爆里破解软件（超过几次尝试直接拉黑）</li></ul><p>筛选 <code>/etc/passwd</code> 中 login 的用户。</p><p><strong>10、防火墙</strong></p><p>防火墙生产环境一定要开，并且要遵循最小原则，drop所有，然后放行需要的服务端口。</p><p><strong>11、精细权限和控制粒度</strong></p><p>能使用普通用户启动的服务坚决不使用root，把各种服务权限控制到最低，控制粒度要精细。</p><p><strong>12、入侵检测和日志监控</strong></p><p>使用第三方软件，时刻检测系统关键文件以及各种服务配置文件的改动，比如：<code>/etc/passwd</code>，<code>/etc/my.cnf</code>，<code>/etc/httpd/con/httpd.conf</code>等。</p><p>使用集中化的日志监控体系，监控 <code>/var/log/secure</code>，<code>/etc/log/message</code>，ftp 上传下载文件等报警错误日志。</p><p>另外针对端口扫描，也可以使用一些第三方软件，发现被扫描就直接拉入 host.deny。这些信息对于系统被入侵后排错很有帮助。</p><p>有人说过，一个公司在安全投入的成本跟他被安全攻击损失的成本成正比，安全是一个很大的话题，也是一个很基础的工作，把基础做好了，就能相当的提高系统安全性，其他的就是安全高手做的了。</p><h2><span id="日常监控">日常监控</span></h2><p><strong>13、系统运行监控</strong></p><p>好多人踏入运维都是从监控做起，大的公司一般都有专业 24 小时监控运维。系统运行监控一般包括硬件占用率，常见的有，内存，硬盘，CPU，网卡，OS包括登录监控，系统关键文件监控。</p><p>定期的监控可以预测出硬件损坏的概率，并且给调优带来很实用的功能。</p><p><strong>14、服务运行监控</strong></p><p>服务监控一般就是各种应用，Web，DB，LVS等，这一般都是监控一些指标。</p><p>在系统出现性能瓶颈的时候就能很快发现并解决。</p><p><strong>15、日志监控</strong></p><p>这里的日志监控跟安全的日志监控类似，但这里一般都是硬件，OS，应用程序的报错和警报信息。</p><p>监控在系统稳定运行的时候确实没啥用，但是一旦出现问题，你又没做监控，就会很被动了。</p><h2><span id="性能调优">性能调优</span></h2><p><strong>16、深入了解运行机制</strong></p><p>其实按一年多的运维经验来说，谈调优根本就是纸上谈兵，但是我只是想简单总结下，如果有更深入的了解，我会更新。在对软件进行优化之前，比如要深入了解一个软件的运行机制，比如 Nginx 和 Apache，大家都说 Nginx 快，那就必须知道 Nginx 为什么快，利用什么原理，处理请求比 Apache，并且要能跟别人用浅显易懂的话说出来，必要的时候还要能看懂源代码，否则一切以参数为调优对象的文档都是瞎谈。</p><p><strong>17、调优框架以及先后</strong></p><p>熟悉了底层运行机制，就要有调优的框架和先后顺序，比如数据库出现瓶颈，好多人直接就去更改数据库的配置文件，我的建议是，先根据瓶颈去分析，查看日志，写出来调优方向，然后再入手，并且数据库服务器调优应该是最后一步，最先的应该是硬件和操作系统，现在的数据库服务器都是在各种测试之后才会发布的</p><p>适用于所有操作系统，不应该先从他入手。</p><p><strong>18、每次只调一个参数</strong></p><p>每次只调一个参数，这个相比大家都了解，调的多了，你就自己就迷糊了。</p><p><strong>19、基准测试</strong></p><p>判断调优是否有用，和测试一个新版本软件的稳定性和性能等方面，就必须要基准测试了，测试要涉及很多因素。</p><p>测试是否接近业务真实需求这要看测试人的经验了，相关资料大家可以参考《高性能MySQL》第三版相当的好。</p><p>我的老师曾说过，没有放之四海皆准的参数，任何参数更改任何调优都必须符合业务场景，所以不要再谷歌什么什么调优了，对你的提升和业务环境的改善没有长久作用。</p><h2><span id="运维心态">运维心态</span></h2><p><strong>20、控制心态</strong></p><p>很多 <code>rm -rf /data</code> 都在下班的前几分钟，都在烦躁的高峰，那么你还不打算控制下你的心态么？</p><p>有人说了，烦躁也要上班，可是你可以在烦躁的时候尽量避免处理关键数据环境，越是有压力，越要冷静，不然会损失更多。</p><p>大多人都有 <code>rm -rf /data/mysql</code> 的经历，发现删除之后，那种心情你可以想象一下，可是如果没有备份，你急又有什么用，一般这种情况下，你就要冷静想下最坏打算了，对于 MySQL 来说，删除了物理文件，一部分表还会存在内存中，所以断开业务，但是不要关闭MySQL数据库，这对恢复很有帮助，并使用dd复制硬盘，然后你再进行恢复。</p><p>当然了大多时候你就只能找数据恢复公司了。</p><p>试想一下，数据被删了，你各种操作，关闭数据库，然后修复，不但有可能覆盖文件，还找不到内存中的表了。</p><p><strong>21、对数据负责</strong></p><p>生产环境不是儿戏，数据库也不是儿戏，一定要对数据负责。不备份的后果是非常严重的。</p><p><strong>22、追根究底</strong></p><p>很多运维人员比较忙，遇到问题解决就不会再管了，记得去年一个客户的网站老是打不开，经过 PHP 代码报错，发现是 session 和 whos_online 损坏，前任运维是通过 repair 修复的，我就也这样修复了，但是过了几个小时，又出现了。反复三四次之后，我就去谷歌数据库表莫名损坏原因：一是 myisam 的 bug，二是 mysqlbug，三是 MySQL 在写入过程中被 kill，最后发现是内存不够用，导致 OOM kill 了 mysqld 进程，并且没有 swap 分区，后台监控内存是够用的，最后升级物理内存解决。</p><p><strong>23、测试和生产环境</strong></p><p>在重要操作之前一定要看自己所在的机器，尽量避免多开窗口。</p><blockquote><p>本文转载自：「 博客园 」，原文：<a href="https://tinyurl.com/jrh7nr2x" target="_blank" rel="noopener">https://tinyurl.com/jrh7nr2x</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从事运维三年半，遇到过各式各样的问题，数据丢失，网站挂马，误删数据库文件，黑客攻击等各类问题。&lt;/p&gt;
&lt;p&gt;今天简单整理一下，分享给各位小伙伴。&lt;/p&gt;
&lt;h2 id=&quot;线上操作规范&quot;&gt;线上操作规范&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、测试使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当初学习 Linux 的使用，从基础到服务到集群，都是在虚拟机做的，虽然老师告诉我们跟真机没有什么差别，可是对真实环境的渴望日渐上升，不过虚拟机的各种快照却让我们养成了各种手贱的习惯，以致于拿到服务器操作权限时候，就迫不及待的想去试试，记得上班第一天，老大把 root 密码交给我，由于只能使用 putty，我就想使用 xshell，于是悄悄登录服务器尝试改为 Xshell+密钥登录，因为没有测试，也没有留一个 SSH 连接，所有重启 SSHD 服务器之后，自己就被挡在服务器之外了，幸好当时我备份了 sshd_config 文件，后来让机房人员 cp 过去就可以了，幸亏这是一家小公司，不然直接就被干了……庆幸当年运气比较好。&lt;/p&gt;
&lt;p&gt;第二个例子是关于文件同步的，大家都知道 sync 同步很快，可是他删除文件的速度大大超过了 rm -rf，在 rsync 中有一个命令是，以某目录为准同步某文件（如果第一个目录是空的，那么结果可想而知），源目录（有数据的）就会被删除，当初我就是因为误操作，以及缺乏测试，就目录写反了，关键是没有备份……生产环境数据被删了。&lt;/p&gt;
&lt;p&gt;没备份，大家自己想后果吧，其重要性不言而喻。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="开源" scheme="https://www.hi-linux.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>阿里云发布全新开源操作系统『龙蜥』，支持 X86 64 和 ARM 64 架构及飞腾、海光、兆芯、鲲鹏等芯片</title>
    <link href="https://www.hi-linux.com/posts/20754.html"/>
    <id>https://www.hi-linux.com/posts/20754.html</id>
    <published>2021-10-19T01:00:00.000Z</published>
    <updated>2021-12-18T08:41:42.654Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>近日，2021 云栖大会上，阿里云发布了全新操作系统 <strong>“龙蜥”(Anolis OS)</strong>，并宣布开源。</p><p>据了解，龙蜥操作系统 <strong>定位于服务器市场</strong>，支持 x86、ARM 等多种硬件架构和计算场景。</p><p><strong>它特别针对云原生应用开发做了多重优化，云上典型场景的综合性能可提升 40％，同时故障率可降低 50％，还兼容 CentOS 生态，支持一键迁移，并提供全栈国密能力。</strong></p><p>龙蜥操作系统 <strong>完全开源</strong>，通过开源社区和操作系统厂商等形式提供服务，<strong>技术支持至少 10 年。</strong></p><a id="more"></a><p>未来，<strong>阿里云计划为龙蜥系统投入 20 亿元的专项资金</strong>，并联合 100 家生态合作伙伴推动生态建设。</p><p>事实上，龙蜥操作系统并非新鲜事物，只是首次对外公布而已，<strong>它已经在阿里巴巴内部打磨了 10 年之久，特别是有效支撑了历年来的天猫双 11 活动</strong>，性能和稳定性都经受住了严苛的考验。</p><p>另外，<strong>阿里达摩院操作系统实验室</strong> 同步宣告成立，未来将专注于操作系统的研发、推广。</p><blockquote><p>龙蜥操作系统(Anolis OS) 8.4 版本依然秉承与国际主流 Linux 厂商发行版 100% 兼容的原则，且提供配套的迁移工具，助力用户完美平滑地迁移至龙蜥操作系统(Anolis OS)，满足 CentOS 停服后的各领域、各行业用户的使用习惯和需求。在硬件生态方面通过和 Intel 及国内芯片厂商的合作，支持 Intel、海光、兆芯、飞腾、鲲鹏等一系列芯片平台，进行软、硬一体的优化，充分发挥硬件平台的性能。</p></blockquote><p>在基本库、应用生态上融入了适合云场景新组件，各组件经过云计算场景超大规模部署的打磨和完善，可满足各个行业领域对于不同生产环境下不同方案的实际需求。</p><h2><span id="亮点">亮点</span></h2><ul><li>100% 兼容<strong>国际主流 Linux</strong> 厂商发行版；</li><li>支持 x86_64 和 aarch64 架构及飞腾、海光、兆芯、鲲鹏等芯片，适配 x86 及 arm64 <strong>主流服务器</strong>硬件；</li><li>支持 Linux Kernel <strong>4.19 LTS</strong> 版本并同步上游社区<strong>最新成果</strong>，帮助用户及时获得开源社区创新红利；</li><li>支持开源分布式关系数据库<strong>OceanBase</strong>；</li><li>支持安全容器<strong>Kata Containers</strong>；</li><li>支持开源云原生关系型数据库<strong>PolarDB for PostgreSQL</strong>；</li><li><strong>基础应用组件</strong>升级；<br>Python 3.9/SWIG 4.0/Subversion 1.14/Redis 6/PostgreSQL 13/MariaDB 10.5；</li><li><strong>工具链</strong>升级；<br>GCC Toolset 10/LLVM Toolset 11.0.0/Rust Toolset 1.49.0/Go Toolset 1.15.7；</li><li>提供 CentOS 系统到 Anolis OS 迁移工具，帮助系统及应用的<strong>顺滑迁移</strong>；</li></ul><h2><span id="硬件支撑">硬件支撑</span></h2><h3><span id="支持架构">支持架构</span></h3><p>x86_64 和 aarch64</p><h3><span id="cloud-kernel-平台兼容性">Cloud Kernel 平台兼容性</span></h3><p>Cloud Kernel 内核 <strong>已验证支持的服务器</strong> 如下，后续将逐步增加对其他服务器的支持，也欢迎广大合作伙伴/开发者参与贡献和验证。</p><table><thead><tr><th>名称</th><th>架构</th><th>CPU</th></tr></thead><tbody><tr><td>飞腾</td><td>aarch64</td><td>Phytium FT-2000+/64,Phytium S2500/64</td></tr><tr><td>海光</td><td>x86_64</td><td>Hygon C86 7185 32-core Process</td></tr><tr><td>兆芯</td><td>x86_64</td><td>Zhaoxin KH-37800D</td></tr><tr><td>鲲鹏</td><td>aarch64</td><td>Kunpeng-920</td></tr></tbody></table><h2><span id="发布内容">发布内容</span></h2><p>目前龙蜥最新的稳定版是 7 月份发布的 Anolis OS 8.4，发布内容包括 <strong>ISO、虚拟机镜像和 REPO 源</strong>。</p><h3><span id="iso-列表">ISO 列表</span></h3><table><thead><tr><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>AnolisOS-8.4-x86_64-dvd.iso</td><td>x86_64架构的安装 ISO</td></tr><tr><td>AnolisOS-8.4-aarch64-dvd.iso</td><td>aarch64架构的安装 ISO</td></tr><tr><td>AnolisOS-8.4-src-dvd.iso</td><td>source 包ISO</td></tr></tbody></table><h3><span id="虚拟机镜像列表">虚拟机镜像列表</span></h3><table><thead><tr><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>AnolisOS-8.4-GA-x86_64-ANCK.qcow2</td><td>x86_64架构虚拟机镜像搭配ANCK内核</td></tr><tr><td>AnolisOS-8.4-GA-x86_64-RHCK.qcow2</td><td>x86_64架构虚拟机镜像搭配RHCK内核[注1]</td></tr><tr><td>AnolisOS-8.4-GA-aarch64-ANCK.qcow2</td><td>aarch64架构虚拟机镜像搭配ANCK内核</td></tr><tr><td>AnolisOS-8.4-GA-aarch64-RHCK.qcow2</td><td>aarch64架构虚拟机镜像搭配RHCK内核</td></tr></tbody></table><blockquote><p>注1：RHCK 内核兼容 CentOS 8.4 的内核，当前版本是 kernel-4.18.0-305.an8</p><p>注2：镜像缺省 sudo 用户 anuser，对应登录密码是 anolisos。</p></blockquote><h3><span id="repo-源列表">REPO 源列表</span></h3><table><thead><tr><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>BaseOS</td><td>BaseOS 软件包源，该源目的是提供安装基础的所有核心包。</td></tr><tr><td>AppStream</td><td>AppStream 软件包源，该源提供额外的多场景，多用途的用户态程序，数据库等。该部分引入了额外的 RPM Module 形态。</td></tr><tr><td>PowerTools</td><td>PowerTools 软件包源， 该源提供开发者需要的额外包。</td></tr><tr><td>Plus</td><td>Plus 软件包源，该源提供 OpenAnolis SIG 组专门研发包，如 ANCK 内核，Dragonwell8 JDK等。</td></tr><tr><td>DDE</td><td>DDE 桌面主包以及依赖包</td></tr></tbody></table><h3><span id="下载地址">下载地址</span></h3><ul><li>社区网站</li></ul><p><a href="https://mirrors.openanolis.cn/anolis/8.4/isos/" target="_blank" rel="noopener">https://mirrors.openanolis.cn/anolis/8.4/isos/</a></p><ul><li>阿里云镜像</li></ul><p><a href="https://mirrors.aliyun.com/anolis/8.4/" target="_blank" rel="noopener">https://mirrors.aliyun.com/anolis/8.4/</a></p><h2><span id="参考文档">参考文档</span></h2><ol><li><a href="https://news.mydrivers.com/1/790/790382.htm" target="_blank" rel="noopener">https://news.mydrivers.com/1/790/790382.htm</a></li><li><a href="https://segmentfault.com/a/1190000040419582" target="_blank" rel="noopener">https://segmentfault.com/a/1190000040419582</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日，2021 云栖大会上，阿里云发布了全新操作系统 &lt;strong&gt;“龙蜥”(Anolis OS)&lt;/strong&gt;，并宣布开源。&lt;/p&gt;
&lt;p&gt;据了解，龙蜥操作系统 &lt;strong&gt;定位于服务器市场&lt;/strong&gt;，支持 x86、ARM 等多种硬件架构和计算场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它特别针对云原生应用开发做了多重优化，云上典型场景的综合性能可提升 40％，同时故障率可降低 50％，还兼容 CentOS 生态，支持一键迁移，并提供全栈国密能力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;龙蜥操作系统 &lt;strong&gt;完全开源&lt;/strong&gt;，通过开源社区和操作系统厂商等形式提供服务，&lt;strong&gt;技术支持至少 10 年。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="开源" scheme="https://www.hi-linux.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="阿里云" scheme="https://www.hi-linux.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 应用包管理器 Helm 保姆级中文简明教程</title>
    <link href="https://www.hi-linux.com/posts/23277.html"/>
    <id>https://www.hi-linux.com/posts/23277.html</id>
    <published>2021-09-30T01:00:00.000Z</published>
    <updated>2021-09-30T05:02:30.282Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>Helm 是查找、分享和使用软件构建 Kubernetes 的最优方式！</strong></p></blockquote><p><code>Helm</code> 帮助您管理 <code>Kubernetes</code> 应用 —— <code>Helm</code> 图表，即使是最复杂的 <code>Kubernetes</code> 应用程序，都可以帮助您定义，安装和升级。图表 <code>Chart</code> 易于创建、发版、分享和发布，所以停止复制粘贴，开始使用 <code>Helm</code> 吧。</p><ul><li><code>Helm</code> 是什么?</li><li><code>Kubernetes</code> 包管理器，可以简单理解为 <code>apt</code> 或 <code>yml</code> 工具。</li></ul><h2><span id="工具特性">工具特性</span></h2><blockquote><p><strong>Helm 是 CNCF 的毕业项目，由 Helm 社区维护。</strong></p></blockquote><ul><li><strong>复杂性管理</strong></li></ul><p>即使是最复杂的应用，图表 <code>Charts</code> 依然可以描述， 提供使用单点授权的可重复安装应用程序。</p><ul><li><strong>易于升级</strong></li></ul><p>随时随地升级和自定义的钩子消除您升级的痛苦。</p><ul><li><strong>分发简单</strong></li></ul><p>图表 <code>Charts</code> 很容易在公共或私有化服务器上发版，分发和部署站点。</p><ul><li><strong>回滚</strong></li></ul><p>使用 <code>helm rollback</code> 可以轻松回滚到之前的发布版本。</p><a id="more"></a><h2><span id="安装使用">安装使用</span></h2><blockquote><p><strong>工具安装提供多种安装方式</strong></p></blockquote><p><a href="https://helm.sh/zh/docs/topics/plugins/" target="_blank" rel="noopener">https://helm.sh/zh/docs/topics/plugins/</a></p><ul><li>[1] 获取 Helm 工具 - 包管理器安装<ul><li>安装完成后，解压二进制包并添加到 <code>PATH</code>，就可以使用了！</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># homebrew(macOS)</span></span><br><span class="line">$ brew install helm</span><br><span class="line"></span><br><span class="line"><span class="comment"># Chocolatey(Windows)</span></span><br><span class="line">$ choco install kubernetes-helm</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apt(Debian/Ubuntu)</span></span><br><span class="line">$ curl https://baltocdn.com/helm/signing.asc | sudo apt-key add -</span><br><span class="line">$ sudo apt-get install apt-transport-https --yes</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"deb https://baltocdn.com/helm/stable/debian/ all main"</span> | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install helm</span><br></pre></td></tr></table></figure><ul><li>[2] 获取 Helm 工具 - 使用脚本安装<ul><li><code>Helm</code> 现在有个安装脚本可以自动拉取最新的 <code>Helm</code> 版本并在本地安装！</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接执行安装</span></span><br><span class="line">$ curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash</span><br></pre></td></tr></table></figure><ul><li>[3] 获取 Helm 工具 - 二进制版本安装<ul><li>每个 <code>Helm</code> 版本都提供了各种操作系统的二进制版本！</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载需要的版本</span></span><br><span class="line">$ https://github.com/helm/helm/releases</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压压缩包</span></span><br><span class="line">$ tar -zxvf helm-v3.0.0-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动到需要的目录中</span></span><br><span class="line">$ mv linux-amd64/helm /usr/<span class="built_in">local</span>/bin/helm</span><br></pre></td></tr></table></figure><ul><li>[4] 获取 Charts 图表<ul><li>访问 <a href="https://artifacthub.io/" target="_blank" rel="noopener">Helm 应用中心</a> 浏览公共库大量的图表！</li></ul></li></ul><p><img src="https://img.hi-linux.com/staticfile/kubernetes-new-helm-tool-01-2021-09-28-Tr63vR.jpg" alt="Artifacthub"></p><ul><li>[5] 简单上手使用<ul><li>安装好了 <code>Helm</code> 之后，可以添加一个 <code>chart</code> 仓库！</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加:有效的Helm-chart仓库</span></span><br><span class="line"><span class="comment"># 更新:确定可以拿到最新的charts列表</span></span><br><span class="line">$ helm repo add bitnami https://charts.bitnami.com/bitnami</span><br><span class="line">$ helm repo add brigade https://brigadecore.github.io/charts</span><br><span class="line">$ helm repo update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后就可以查找相关的charts列表</span></span><br><span class="line">$ $ helm search repo bitnami</span><br><span class="line">NAME                      CHART VERSION      APP VERSION      DESCRIPTION</span><br><span class="line">bitnami/bitnami-common    0.0.9              0.0.9            ...</span><br><span class="line">bitnami/airflow           8.0.2              2.0.0            ...</span><br><span class="line">bitnami/apache            8.2.3              2.4.46        ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 了解到这个chart的基本信息</span></span><br><span class="line">$ helm show chart bitnami/mysql</span><br><span class="line"><span class="comment"># 获取关于该chart的所有信息</span></span><br><span class="line">$ helm show all bitnami/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装对应版本服务</span></span><br><span class="line">$ helm install bitnami/mysql --generate-name</span><br><span class="line">NAME: mysql-1612624192</span><br><span class="line">LAST DEPLOYED: Sat Feb  6 16:09:56 2021</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES: ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有可被部署的版本</span></span><br><span class="line">$ helm list</span><br><span class="line">NAME                NAMESPACE    REVISION    STATUS      CHART          APP VERSION</span><br><span class="line">mysql-1612624192    default      1           deployed    mysql-8.3.0    8.0.23</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载一个版本</span></span><br><span class="line">$ helm uninstall mysql-1612624192</span><br><span class="line">release <span class="string">"mysql-1612624192"</span> uninstalled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看帮助信息</span></span><br><span class="line">$ helm get -h</span><br></pre></td></tr></table></figure><h2><span id="三大概念">三大概念</span></h2><p><code>Helm</code> 安装 <code>charts</code> 到 <code>Kubernetes</code> 集群中，每次安装都会创建一个新的 <code>release</code>。</p><ul><li>Chart<ul><li><code>Chart</code> 代表着 <code>Helm</code> 包。</li><li>你可以把它看作是 <code>Apt</code> 或 <code>Yum</code> 在 <code>Kubernetes</code> 中的等价物。</li><li>它包含在 <code>Kubernetes</code> 集群内部运行应用程序，工具或服务所需的所有资源定义。</li></ul></li><li>Repository<ul><li><code>Repository</code>(仓库)是用来存放和共享 <code>charts</code> 的地方。</li><li>它就像 <code>Fedora</code> 的软件包仓库，只不过它是供 <code>Kubernetes</code> 包所使用的。</li></ul></li><li>Release<ul><li><code>Release</code> 是运行在 <code>Kubernetes</code> 集群中的 <code>chart</code> 的实例。</li><li>一个 <code>chart</code> 通常可以在同一个集群中安装多次，每一次安装都会创建一个新的 <code>release</code>。</li></ul></li></ul><p><code>Helm</code> 按照以下顺序安装资源(这里列出主要的一些)：</p><ul><li>Namespace</li><li>NetworkPolicy</li><li>ResourceQuota</li><li>LimitRange</li><li>ServiceAccount</li><li>Secret</li><li>SecretList</li><li>ConfigMap</li><li>StorageClass</li><li>PersistentVolume</li><li>PersistentVolumeClaim</li><li>Role</li><li>RoleList</li><li>RoleBinding</li><li>RoleBindingList</li><li>Service</li><li>DaemonSet</li><li>Pod</li><li>ReplicationController</li><li>ReplicaSet</li><li>Deployment</li><li>HorizontalPodAutoscaler</li><li>StatefulSet</li><li>Job</li><li>CronJob</li><li>Ingress</li><li>APIService</li></ul><h2><span id="组织架构">组织架构</span></h2><blockquote><ol><li><a href="https://helm.sh/zh/docs/topics/architecture/" target="_blank" rel="noopener">https://helm.sh/zh/docs/topics/architecture/</a></li></ol></blockquote><h2><span id="常用操作">常用操作</span></h2><blockquote><ol><li><a href="https://helm.sh/zh/docs/helm/helm/" target="_blank" rel="noopener">https://helm.sh/zh/docs/helm/helm/</a></li></ol></blockquote><table><thead><tr><th style="text-align:left">命令实例</th><th style="text-align:left">对应功能介绍</th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>helm repo add bitnami https://charts.bitnami.com/bitnami</code></strong></td><td style="text-align:left">添加有效的 Helm-chart 仓库</td></tr><tr><td style="text-align:left"><strong><code>helm repo list</code></strong></td><td style="text-align:left">查看配置的 chart 仓库</td></tr><tr><td style="text-align:left"><strong><code>helm search repo wordpress</code></strong></td><td style="text-align:left">从添加的仓库中查找 chart 的名字</td></tr><tr><td style="text-align:left"><strong><code>helm install happy-panda bitnami/wordpress</code></strong></td><td style="text-align:left">安装一个新的 helm 包</td></tr><tr><td style="text-align:left"><strong><code>helm status happy-panda</code></strong></td><td style="text-align:left">来追踪展示 release 的当前状态</td></tr><tr><td style="text-align:left"><strong><code>helm show values bitnami/wordpress</code></strong></td><td style="text-align:left">查看 chart 中的可配置选项</td></tr><tr><td style="text-align:left"><strong><code>helm uninstall happy-panda</code></strong></td><td style="text-align:left">从集群中卸载一个 release</td></tr><tr><td style="text-align:left"><strong><code>helm list</code></strong></td><td style="text-align:left">看到当前部署的所有 release</td></tr><tr><td style="text-align:left"><strong><code>helm pull bitnami/wordpress</code></strong></td><td style="text-align:left">下载和查看一个发布的 chart</td></tr><tr><td style="text-align:left"><strong><code>helm upgrade</code></strong></td><td style="text-align:left">升级 release 版本</td></tr><tr><td style="text-align:left"><strong><code>helm rollback</code></strong></td><td style="text-align:left">恢复 release 版本</td></tr></tbody></table><h2><span id="值传递方式">值传递方式</span></h2><h3><span id="安装前自定义-chart">安装前自定义 chart</span></h3><blockquote><ol><li><p><a href="https://helm.sh/zh/docs/chart_best_practices/conventions/" target="_blank" rel="noopener">https://helm.sh/zh/docs/chart_best_practices/conventions/</a></p></li><li><p><a href="https://helm.sh/zh/docs/chart_best_practices/values/" target="_blank" rel="noopener">https://helm.sh/zh/docs/chart_best_practices/values/</a></p></li></ol></blockquote><p>上述安装方式只会使用 chart 的默认配置选项。很多时候，我们需要自定义 chart 来指定我们想要的配置。</p><p>使用 <code>helm show values</code> 可以查看 chart 中的可配置选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ helm show values bitnami/wordpress</span><br><span class="line"></span><br><span class="line">image:</span><br><span class="line">  registry: docker.io</span><br><span class="line">  repository: bitnami/wordpress</span><br><span class="line">  tag: 5.6.0-debian-10-r35</span><br><span class="line">  [..]</span><br></pre></td></tr></table></figure><p>然后，你可以使用 YAML 格式的文件覆盖上述任意配置项，并在安装过程中使用该文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'&#123;mariadb.auth.database: user0db, mariadb.auth.username: user0&#125;'</span> &gt; values.yaml</span><br><span class="line">$ helm install -f values.yaml bitnami/wordpress --generate-name</span><br></pre></td></tr></table></figure><p>上述命令将为 MariaDB 创建一个名称为  <code>user0</code> 的默认用户，并且授予该用户访问新建的  <code>user0db</code> 数据库的权限。chart 中的其他默认配置保持不变。</p><p>安装过程中有两种方式传递配置数据：</p><ul><li><code>--values</code> (或  <code>-f</code>)：使用 YAML 文件覆盖配置。可以指定多次，优先使用最右边的文件。</li><li><code>--set</code>：通过命令行的方式对指定项进行覆盖。</li></ul><p>如果同时使用两种方式，则  <code>--set</code> 中的值会被合并到  <code>--values</code> 中，但是  <code>--set</code> 中的值优先级更高。在<code>--set</code> 中覆盖的内容会被被保存在 ConfigMap 中。可以通过  <code>helm get values &lt;release-name&gt;</code> 来查看指定 release 中  <code>--set</code> 设置的值。也可以通过运行  <code>helm upgrade</code> 并指定  <code>--reset-values</code> 字段来清除  <code>--set</code> 中设置的值。</p><h3><span id="-set-的格式和限制"><code>--set</code> 的格式和限制</span></h3><p><code>--set</code> 选项使用 0 或多个 name/value 对。最简单的用法类似于：<code>--set name=value</code>，等价于如下 YAML 格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: value</span><br></pre></td></tr></table></figure><p>多个值使用逗号分割，因此  <code>--set a=b,c=d</code> 的 YAML 表示是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a: b</span><br><span class="line">c: d</span><br></pre></td></tr></table></figure><p>支持更复杂的表达式。例如，<code>--set outer.inner=value</code>被转换成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outer:</span><br><span class="line">  inner: value</span><br></pre></td></tr></table></figure><p>列表使用花括号（<code>{}</code>）来表示。例如，<code>--set name={a, b, c}</code> 被转换成了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">a</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">b</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">c</span></span><br></pre></td></tr></table></figure><p>从 2.5.0 版本开始，可以使用数组下标的语法来访问列表中的元素。例如  <code>--set servers[0].port=80</code> 就变成了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>多个值也可以通过这种方式来设置。<code>--set servers[0].port=80,servers[0].host=example</code> 变成了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">example</span></span><br></pre></td></tr></table></figure><p>如果需要在  <code>--set</code> 中使用特殊字符，你可以使用反斜线来进行转义；<code>--set name=value1\,value2</code> 就变成了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">"value1,value2"</span></span><br></pre></td></tr></table></figure><p>类似的，你也可以转义点  序列（英文句号）。这可能会在 chart 使用  <code>toYaml</code> 函数来解析 annotations，labels，和 node selectors 时派上用场。<code>--set nodeSelector.&quot;kubernetes\.io/role&quot;=master</code> 语法就变成了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="attr">kubernetes.io/role:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>深层嵌套的数据结构可能会很难用  <code>--set</code> 表达。我们希望 Chart 的设计者们在设计  <code>values.yaml</code> 文件的格式时，考虑到  <code>--set</code> 的使用。（更多内容请查看  <a href="https://helm.sh/docs/chart_template_guide/values_files/" target="_blank" rel="noopener">Values 文件</a>）</p><h2><span id="模板的使用">模板的使用</span></h2><blockquote><ol><li><p><a href="https://helm.sh/zh/docs/howto/charts_tips_and_tricks/" target="_blank" rel="noopener">https://helm.sh/zh/docs/howto/charts_tips_and_tricks/</a></p></li><li><p><a href="https://helm.sh/zh/docs/chart_best_practices/templates/" target="_blank" rel="noopener">https://helm.sh/zh/docs/chart_best_practices/templates/</a></p></li></ol></blockquote><h2><span id="自定义开发">自定义开发</span></h2><blockquote><ol><li><p><a href="https://helm.sh/zh/docs/topics/charts/" target="_blank" rel="noopener">https://helm.sh/zh/docs/topics/charts/</a></p></li><li><p><a href="https://helm.sh/zh/docs/chart_best_practices/pods/" target="_blank" rel="noopener">https://helm.sh/zh/docs/chart_best_practices/pods/</a></p></li><li><p><a href="https://helm.sh/zh/docs/chart_template_guide/getting_started/" target="_blank" rel="noopener">https://helm.sh/zh/docs/chart_template_guide/getting_started/</a></p></li></ol></blockquote><p><a href="https://helm.sh/zh/docs/topics/charts" target="_blank" rel="noopener">chart 开发指南</a> 介绍了如何开发你自己的 chart。 但是你也可以通过使用  <code>helm create</code> 命令来快速开始：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm create deis-workflow</span><br><span class="line">Creating deis-workflow</span><br></pre></td></tr></table></figure><p>现在，<code>./deis-workflow</code> 目录下已经有一个 chart 了。你可以编辑它并创建你自己的模版。</p><p>在编辑 chart 时，可以通过  <code>helm lint</code> 验证格式是否正确。</p><p>当准备将 chart 打包分发时，你可以运行  <code>helm package</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm package deis-workflow</span><br><span class="line">deis-workflow-0.1.0.tgz</span><br></pre></td></tr></table></figure><p>然后这个 chart 就可以很轻松的通过  <code>helm install</code> 命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm install deis-workflow ./deis-workflow-0.1.0.tgz</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>打包好的 chart 可以上传到 chart 仓库中。查看  <a href="https://helm.sh/zh/docs/topics/chart_repository" target="_blank" rel="noopener">Helm chart 仓库</a>获取更多信息。</p><h2><span id="钩子的使用">钩子的使用</span></h2><blockquote><ol><li><a href="https://helm.sh/zh/docs/topics/charts_hooks/" target="_blank" rel="noopener">https://helm.sh/zh/docs/topics/charts_hooks/</a></li></ol></blockquote><h2><span id="仓库的创建">仓库的创建</span></h2><blockquote><ol><li><a href="https://helm.sh/zh/docs/topics/chart_repository/" target="_blank" rel="noopener">https://helm.sh/zh/docs/topics/chart_repository/</a></li><li><a href="https://helm.sh/zh/docs/topics/registries/" target="_blank" rel="noopener">https://helm.sh/zh/docs/topics/registries/</a></li></ol></blockquote><h2><span id="自动化发布">自动化发布</span></h2><blockquote><p>Chart 发布操作用以自动化 GitHub 的页面 Chart</p></blockquote><h2><span id="新版本变化">新版本变化</span></h2><blockquote><ol><li><a href="https://helm.sh/zh/docs/topics/v2_v3_migration/" target="_blank" rel="noopener">https://helm.sh/zh/docs/topics/v2_v3_migration/</a></li></ol></blockquote><h2><span id="参考链接">参考链接</span></h2><ul><li><a href="https://helm.sh/zh/" target="_blank" rel="noopener">Helm 官方中文文档</a></li></ul><blockquote><p>本文转载自：「 Escapelife 的博客 」，原文：<a href="https://tinyurl.com/53hjshe2" target="_blank" rel="noopener">https://tinyurl.com/53hjshe2</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Helm 是查找、分享和使用软件构建 Kubernetes 的最优方式！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Helm&lt;/code&gt; 帮助您管理 &lt;code&gt;Kubernetes&lt;/code&gt; 应用 —— &lt;code&gt;Helm&lt;/code&gt; 图表，即使是最复杂的 &lt;code&gt;Kubernetes&lt;/code&gt; 应用程序，都可以帮助您定义，安装和升级。图表 &lt;code&gt;Chart&lt;/code&gt; 易于创建、发版、分享和发布，所以停止复制粘贴，开始使用 &lt;code&gt;Helm&lt;/code&gt; 吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Helm&lt;/code&gt; 是什么?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Kubernetes&lt;/code&gt; 包管理器，可以简单理解为 &lt;code&gt;apt&lt;/code&gt; 或 &lt;code&gt;yml&lt;/code&gt; 工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;工具特性&quot;&gt;工具特性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Helm 是 CNCF 的毕业项目，由 Helm 社区维护。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;复杂性管理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即使是最复杂的应用，图表 &lt;code&gt;Charts&lt;/code&gt; 依然可以描述， 提供使用单点授权的可重复安装应用程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;易于升级&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随时随地升级和自定义的钩子消除您升级的痛苦。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分发简单&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图表 &lt;code&gt;Charts&lt;/code&gt; 很容易在公共或私有化服务器上发版，分发和部署站点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;回滚&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 &lt;code&gt;helm rollback&lt;/code&gt; 可以轻松回滚到之前的发布版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="Helm" scheme="https://www.hi-linux.com/tags/Helm/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的使用 Nginx 缓存机制将网站访问速度提高 10 倍</title>
    <link href="https://www.hi-linux.com/posts/64107.html"/>
    <id>https://www.hi-linux.com/posts/64107.html</id>
    <published>2021-09-28T01:00:00.000Z</published>
    <updated>2021-09-28T01:23:29.122Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>Nginx</code> 缓存作为性能优化的一个重要手段，可以极大减轻后端服务器的负载。下面我们将介绍 <code>Nginx</code> 缓存配置的相关指令以及 <code>http</code> 缓存机制，以及 <code>Nginx</code> 缓存实践案例分析。</p><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-90-2021-09-14-CeSSM9.jpg" alt="Nginx缓存机制详解 - 缓存示意图"></p><h2><span id="nginx-缓存示例">Nginx 缓存示例</span></h2><blockquote><p><strong>实例演示，缓存是怎么出现的，怎么查看！</strong></p></blockquote><p>当我们代开某个网站，如 <code>baidu.com</code>，我们可以看到 <code>size</code> 这一列有一些 <code>js</code> 标识为 <code>disk cache</code>，这里就是应用到了缓存。</p><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-91-2021-09-14-yYaa6H.png" alt="Nginx缓存机制详解 - 缓存截图"></p><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-92-2021-09-14-N6MxNz.png" alt="Nginx缓存机制详解 - 缓存截图"></p><a id="more"></a><h2><span id="http-缓存机制">HTTP 缓存机制</span></h2><blockquote><p><strong>HTTP 的缓存流程如下图所示</strong></p></blockquote><ul><li>缓存，可以分为强制缓存和对比缓存。</li></ul><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-93-2021-09-14-p0P9RY.png" alt="Nginx缓存机制详解 - 浏览器缓存处理流程图"></p><h2><span id="nginx-强制缓存">Nginx 强制缓存</span></h2><blockquote><p><strong>介绍强制缓存是什么？以及可能造成这个原因的配置参数！</strong></p></blockquote><p>浏览器不会向服务器发送任何请求，直接从本地缓存中读取缓存数据并返回 <code>200</code> 状态码，如下图所示。如果缓存过期再找服务器，其过程如下：</p><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-94-2021-09-14-wF4Kp5.png" alt="Nginx缓存机制详解 - 强制缓存示意图"></p><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-95-2021-09-14-QAm42h.png" alt="Nginx缓存机制详解 - 缓存截图"></p><p>可以造成强制缓存的字段，有如下几个：</p><ul><li>Expires<ul><li>位置: <code>HTTP Response Header</code></li><li>说明: <code>Expires</code> 是服务端返回的到期时间。如果下一次请求如果小于服务端返回的过期时间，则直接使用缓存数据。<code>Expires</code> 是 <code>HTTP1.0</code> 的东西，现在浏览器默认都是使用 <code>HTTP1.1</code>。而且由于该值是有服务端生成，而客户端的时间和服务端的时间有可能不一致，导致存在一定误差。所以 <code>HTTP1.1</code> 使用 <code>Cache-Control</code> 替代。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">Expires: Mon, 22 Jul 2019 11:08:59 GMT</span><br></pre></td></tr></table></figure><ul><li>Cache-Control<ul><li>位置: <code>HTTP Response Header</code></li><li>说明: 缓存策略定义</li><li><code>max-age</code>: 标识资源能够被缓存的最大时间</li><li><code>public</code>: 表示该响应任何中间人，包括客户端和代理服务器都可以缓存</li><li><code>private</code>: 表示该响应只能用于浏览器私有缓存中，中间人（代理服务器）不能缓存此响应</li><li><code>no-cache</code>: 需要使用对比缓存（<code>Last-Modified/If-Modified-Since/Etag/If-None-Match</code>）来验证缓存数据</li><li><code>no-store</code>: 所有内容都不会缓存，强制缓存和对比缓存都不会触发</li></ul></li></ul><h2><span id="nginx-对比缓存">Nginx 对比缓存</span></h2><blockquote><p><strong>介绍使用缓存和不使用缓存的区别和对比！</strong></p></blockquote><p>浏览器在第一次请求数据时，服务器会将缓存的标识与数据一起返回给浏览器，浏览器将这两个缓存到本地缓存数据库中。</p><p>再次请求数据时，就会在请求 <code>header</code> 中带上缓存的标识发送给服务器，服务器根据缓存标识对比，如果发生变化，则返回 <code>200</code> 状态码，返回完整的响应数据给浏览器，如果未发生更新，则返回 <code>304</code> 状态码告诉浏览器继续使用缓存数据。</p><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-96-2021-09-14-xaQuoZ.png" alt="Nginx缓存机制详解 - 对比缓存示意图"></p><p>如下图比较所示，在第一次请求时，没有使用缓存。而在第二次使用缓存时，可以明显看到两者请求的时间不一样，后者时间少很多。这是因为服务端如果进行缓存比较后发现未更新，只返回 <code>header</code> 部分，并返回 <code>304</code> 状态码通知客户端使用本地缓存，没有将报文的 <code>body</code> 部分返回给浏览器，所以请求时间和报文大小才明显优化。别小看这几十毫秒，当访问量很大时，这里就优化了很多时间、减少了很多服务器压力。</p><ul><li>第一次访问，未使用缓存：</li></ul><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-97-2021-09-14-5rMVz9.png" alt="Nginx缓存机制详解 - 使用缓存前时间和大小"></p><ul><li>第二次访问，使用缓存：</li></ul><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-98-2021-09-14-LTXTz4.png" alt="Nginx缓存机制详解 - 使用缓存后示意图"></p><ul><li>HTTP 请求和响应报文结构如下图所示：</li></ul><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-99-2021-09-14-USdFeo.png" alt="Nginx缓存机制详解 - http请求和响应报文结构"></p><p>会造成对比缓存的字段如下：</p><ul><li>Last-Modified<ul><li>位置: <code>HTTP Response Header</code></li><li>说明: 第一次请求时，服务器会在响应头里设置该参数，告诉浏览器该资源的最后修改时间。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br></pre></td></tr></table></figure><ul><li>If-Modified-Since<ul><li>位置: <code>HTTP Request Header</code></li><li>说明: 再次（注意不是第一次）请求服务器时，客户端浏览器通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。服务器收到请求后，发现 <code>header</code> 中有 <code>If-Modified-Since</code> 字段，则与被请求资源的最后修改时间进行对比。若资源的最后修改时间大于 <code>If-Modified-Since</code>，则说明资源被修改过，则响应返回完整的内容，返回状态码 <code>200</code>。 若资源的最后修改时间小于或等于 <code>If-Modified-Since</code>，则说明资源未修改，则返回 <code>304</code> 状态码，告诉浏览器继续使用所保存的缓存数据。</li></ul></li><li>Etag<ul><li>位置: HTTP Response Header</li><li>说明: 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（由服务端生成）。</li><li>优先级: 高于 Last-Modified 与 If-Modified-Since</li></ul></li></ul><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-100-2021-09-14-tVc0UC.png" alt="Nginx缓存机制详解 - Etag"></p><ul><li>If-None-Match<ul><li>位置: <code>HTTP Request Header</code></li><li>说明: 再次请求服务器时，通过此字段通知服务器客户端缓存的资源的唯一标识。服务器收到请求 <code>header</code> 周发现有 <code>If-None-Match</code> 字段，则与被请求资源的唯一标识进行对比。 如果不一样，说明资源被修改过，则返回完整的响应，状态码 <code>200</code>。 如果一样，说明资源未被修改过，则返回 <code>304</code> 状态码，告诉浏览器继续使用缓存的数据。</li></ul></li></ul><h2><span id="nginx-缓存实践">Nginx 缓存实践</span></h2><blockquote><p><strong>实际配置和演示一下，使用缓存的效果！</strong></p></blockquote><ul><li><strong>配置文件的内容，如下所示：</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">2048</span>;</span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">error_log</span>  /data/log/nginx-<span class="number">1</span>.<span class="number">0</span>/error.log  <span class="literal">error</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_cache_path</span> /data/nginx-<span class="number">1</span>.<span class="number">0</span>/cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=cache_zone:<span class="number">10m</span> inactive=<span class="number">60m</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="attribute">root</span> /usr/local/services/nginx-<span class="number">1</span>.<span class="number">0</span>/html/;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> ~.*\.(gif|jpg|png|css|js)(.*) &#123;</span><br><span class="line">            <span class="attribute">proxy_cache</span> cache_zone;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">302</span> <span class="number">24h</span>;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">1d</span>;</span><br><span class="line">            <span class="attribute">add_header</span> X-Proxy-Cache <span class="variable">$upstream_cache_status</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>实际的测试情况，如下所示：</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_16_4_centos conf]<span class="comment"># curl -I http://localhost/test.js</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.14.0</span><br><span class="line">Date: Sun, 21 Jul 2019 12:35:06 GMT</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 12</span><br><span class="line">Last-Modified: Sun, 21 Jul 2019 12:33:32 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: <span class="string">"5d345b9c-c"</span></span><br><span class="line">Expires: Mon, 22 Jul 2019 12:35:06 GMT</span><br><span class="line">Cache-Control: max-age=86400</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><ul><li>我们再以图片为例，当我们第一次请求 <code>http://localhost/google_logo.jpg</code>，服务端返回了该资源的唯一标识 <code>Etag</code> 给我们。</li></ul><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-101-20210914125805020-2021-09-14-aMfHFo.png" alt="Nginx缓存机制详解"></p><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-102-2021-09-14-lMBLXI.png" alt="Nginx缓存机制详解"></p><ul><li>我们第二次请求时，可以发现 http 报文的体积和响应实践大大缩减，说明我们的缓存发回了作用。</li></ul><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-103-2021-09-14-ZYgfzM.png" alt="Nginx缓存机制详解"></p><p><img src="https://img.hi-linux.com/staticfile/linux-nginx-server-104-2021-09-14-oM8eQF.png" alt="Nginx缓存机制详解"></p><h2><span id="相关的参考链接">相关的参考链接</span></h2><blockquote><p><strong>送人玫瑰，手有余香！</strong></p></blockquote><ul><li><a href="https://shuwoom.com/?p=4311#comment-3660" target="_blank" rel="noopener">NGINX 缓存机制详解</a></li></ul><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/erzmh7uv" target="_blank" rel="noopener">https://tinyurl.com/erzmh7uv</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Nginx&lt;/code&gt; 缓存作为性能优化的一个重要手段，可以极大减轻后端服务器的负载。下面我们将介绍 &lt;code&gt;Nginx&lt;/code&gt; 缓存配置的相关指令以及 &lt;code&gt;http&lt;/code&gt; 缓存机制，以及 &lt;code&gt;Nginx&lt;/code&gt; 缓存实践案例分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/linux-nginx-server-90-2021-09-14-CeSSM9.jpg&quot; alt=&quot;Nginx缓存机制详解 - 缓存示意图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Nginx-缓存示例&quot;&gt;Nginx 缓存示例&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;实例演示，缓存是怎么出现的，怎么查看！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我们代开某个网站，如 &lt;code&gt;baidu.com&lt;/code&gt;，我们可以看到 &lt;code&gt;size&lt;/code&gt; 这一列有一些 &lt;code&gt;js&lt;/code&gt; 标识为 &lt;code&gt;disk cache&lt;/code&gt;，这里就是应用到了缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/linux-nginx-server-91-2021-09-14-yYaa6H.png&quot; alt=&quot;Nginx缓存机制详解 - 缓存截图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/linux-nginx-server-92-2021-09-14-N6MxNz.png&quot; alt=&quot;Nginx缓存机制详解 - 缓存截图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="https://www.hi-linux.com/categories/nginx/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的通过 ApiServer 远程访问 Kubernetes 集群</title>
    <link href="https://www.hi-linux.com/posts/60537.html"/>
    <id>https://www.hi-linux.com/posts/60537.html</id>
    <published>2021-09-27T01:00:00.000Z</published>
    <updated>2021-09-27T01:51:42.085Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在研发时，需要直接连接远端 Kubernetes 集群。通常的做法是，将 <code>/etc/kubernetes/admin.conf</code> 拷贝到本地 <code>~/.kube/kubeconfig</code>。</p><p>但是 kubeconfig 的 server 地址是 <code>kubernetes.default.svc</code>。因此，我们需要配置一个 hosts:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.1.1.1 kubernetes.default.svc</span><br></pre></td></tr></table></figure><p>如果需要在不同集群之间切换，不仅需要更换 kubeconfig，还需要修改 hosts。下面介绍一种方法，可以直接将远程访问地址，添加到集群的证书中，节省修改 hosts 的步骤，同时还能让人更容易的区分不同集群。</p><h2><span id="查看-apiserver-证书包含哪些地址">查看 Apiserver 证书包含哪些地址</span></h2><ol><li>进入证书目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;kubernetes&#x2F;pki</span><br></pre></td></tr></table></figure><a id="more"></a><ol start="2"><li>查看证书</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -in apiserver.crt -noout -text|grep -A  2 &#39;Alternative&#39;</span><br><span class="line"></span><br><span class="line">X509v3 Subject Alternative Name:</span><br><span class="line">                DNS:1-1-1-1, DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, DNS:lb-apiserver.kubernetes.local, DNS:localhost, IP Address:1.1.1.1</span><br></pre></td></tr></table></figure><p>这里如果只允许通过 1.1.1.1 访问集群的 Apiserver。如果需要使用域名，<code>kubernetes、kubernetes.default、kubernetes.default.svc</code> 等，则需要配置 hosts 将其指向 1.1.1.1 。</p><h2><span id="添加新的域名或-ip-到证书">添加新的域名或 IP 到证书</span></h2><ol><li>备份证书</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;etc&#x2F;kubernetes&#x2F;pki</span><br><span class="line">$ mv apiserver.crt apiserver.crt.bak</span><br><span class="line">$ mv apiserver.key apiserver.key.bak</span><br></pre></td></tr></table></figure><ol start="2"><li>修改 <code>/etc/kubernetes/kubeadm-config.yaml</code></li></ol><p>在 ClusterConfiguration 的 apiServer 字段下，找到 certSANs。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">...</span><br><span class="line">  certSANs:</span><br><span class="line">    - kubernetes</span><br><span class="line">    - kubernetes.default</span><br><span class="line">    - kubernetes.default.svc</span><br><span class="line">    - kubernetes.default.svc.cluster.local</span><br><span class="line">    - 10.233.0.1</span><br></pre></td></tr></table></figure><p>在 certSANs 中添加远程访问的域名或 IP 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">certSANs:</span><br><span class="line">  - remote.doamin.com</span><br><span class="line">  - 1.2.3.4</span><br><span class="line">  - kubernetes</span><br><span class="line">  - kubernetes.default</span><br><span class="line">  - kubernetes.default.svc</span><br><span class="line">  - kubernetes.default.svc.cluster.local</span><br><span class="line">  - 10.233.0.1</span><br></pre></td></tr></table></figure><p>如果你在 <code>/etc/kubernetes/</code> 目录中没有找到 kubeadm-config.yaml 文件，不要紧张，你可以使用下面的方式生成一个当前集群的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get cm kubeadm-config  -n kube-system -o yaml &gt; &#x2F;etc&#x2F;kubernetes&#x2F;kubeadm-config.yaml</span><br><span class="line">或者</span><br><span class="line">$ kubeadm config view | tee &#x2F;etc&#x2F;kubernetes&#x2F;kubeadm-config.yaml</span><br></pre></td></tr></table></figure><p>当然你的集群的配置文件中可能没有 <code>certSANs</code> 配置段，你可以直接加在类似下面的位置处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiServer:</span><br><span class="line">  certSANs:</span><br><span class="line">    - remote.doamin.com</span><br><span class="line">    - 1.2.3.4</span><br><span class="line">    - kubernetes</span><br><span class="line">    - kubernetes.default</span><br><span class="line">    - kubernetes.default.svc</span><br><span class="line">    - kubernetes.default.svc.cluster.local</span><br><span class="line">    - 10.233.0.1</span><br><span class="line">  extraArgs:</span><br><span class="line">    authorization-mode: Node,RBAC</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">....</span><br></pre></td></tr></table></figure><ol start="3"><li>重新生成证书</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init phase certs apiserver --config &#x2F;etc&#x2F;kubernetes&#x2F;kubeadm-config.yaml</span><br></pre></td></tr></table></figure><ol start="4"><li>再次查看证书</li></ol><p>检查输出的结果中，是否包含前面增加的公网 IP，如有则证明操作成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -in pki&#x2F;apiserver.crt -noout -text | grep 1.2.3.4</span><br><span class="line">                IP Address:192.168.0.8, IP Address: 1.2.3.4</span><br></pre></td></tr></table></figure><ol start="5"><li>重启 kube-apiserver</li></ol><ul><li>如果是高可用集群</li></ul><p>直接杀死当前节点的 kube-apiserver 进程，等待 kubelet 拉起 kube-apiserver 即可。需要在三个节点执行步骤 1 到步骤 4，逐一更新。</p><ul><li>如果是非高可用集群</li></ul><p>杀死 kube-apiserver 可能会导致服务有中断，需要在业务低峰的时候操作。</p><p>进入 <code>/etc/kubernetes/manifests</code> 目录下，移动 kube-apiserver.yaml 文件至其它位置，然后又移回来即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mv &#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;kube-apiserver.yaml &#x2F;root&#x2F;</span><br><span class="line">$ mv &#x2F;root&#x2F;kube-apiserver.yaml &#x2F;etc&#x2F;kubernetes&#x2F;manifests</span><br></pre></td></tr></table></figure><ol start="6"><li>修改 kubeconfig 中的 server ip</li></ol><p>最后，你只需要将 <code>kubeconfig</code> 文件中 <code>server</code> 地址修改为 <code>1.2.3.4</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">...</span><br><span class="line">    server: https:&#x2F;&#x2F;1.2.3.4:6443</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>保存之后，就可以直接通过公网 IP 访问 Kubernetes 集群。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get node</span><br></pre></td></tr></table></figure><h2><span id="参考">参考</span></h2><ol><li><a href="https://www.chenshaowen.com/blog/how-to-add-entrance-to-kubernetes-apiserver.html" target="_blank" rel="noopener">https://www.chenshaowen.com/blog/how-to-add-entrance-to-kubernetes-apiserver.html</a></li><li><a href="https://kubesphereio.com/post/add-public-ip-to-kubernetes-apiserver-operation-guide/" target="_blank" rel="noopener">https://kubesphereio.com/post/add-public-ip-to-kubernetes-apiserver-operation-guide/</a></li><li><a href="https://stackoverflow.com/questions/61023319/where-i-can-find-kubeadm-config-yaml-on-my-kubernetes-cluster" target="_blank" rel="noopener">https://stackoverflow.com/questions/61023319/where-i-can-find-kubeadm-config-yaml-on-my-kubernetes-cluster</a></li><li><a href="https://help.hcltechsw.com/connections/v6/admin/install/cp_prereqs_upgrade_latest_implementation.html" target="_blank" rel="noopener">https://help.hcltechsw.com/connections/v6/admin/install/cp_prereqs_upgrade_latest_implementation.html</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在研发时，需要直接连接远端 Kubernetes 集群。通常的做法是，将 &lt;code&gt;/etc/kubernetes/admin.conf&lt;/code&gt; 拷贝到本地 &lt;code&gt;~/.kube/kubeconfig&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是 kubeconfig 的 server 地址是 &lt;code&gt;kubernetes.default.svc&lt;/code&gt;。因此，我们需要配置一个 hosts:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.1.1.1 kubernetes.default.svc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果需要在不同集群之间切换，不仅需要更换 kubeconfig，还需要修改 hosts。下面介绍一种方法，可以直接将远程访问地址，添加到集群的证书中，节省修改 hosts 的步骤，同时还能让人更容易的区分不同集群。&lt;/p&gt;
&lt;h2 id=&quot;查看-Apiserver-证书包含哪些地址&quot;&gt;查看 Apiserver 证书包含哪些地址&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;进入证书目录&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd &amp;#x2F;etc&amp;#x2F;kubernetes&amp;#x2F;pki&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款超实用的查看容器系统资源真实使用情况的工具 topic</title>
    <link href="https://www.hi-linux.com/posts/36129.html"/>
    <id>https://www.hi-linux.com/posts/36129.html</id>
    <published>2021-09-23T01:00:00.000Z</published>
    <updated>2021-09-23T01:22:23.907Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>容器通过 cgroups 和 namespace 实现了资源的轻量级隔离和限制，但容器中的 /proc 文件实际上是宿主机的，因此在执行 top 命令查看容器运行信息时，部分指标显示不正确，例如启动时间、用户数、平均负载、cpu 使用率、内存使用率。</p><p>目前比较通用的解决方案是通过 lxcfs，将容器中相应的文件通过 fuse 劫持 read 调用，在打开时显示为容器信息，从而统一解决各种系统状态诊断工具的问题。</p><a id="more"></a><p>考虑到部署 lxcfs 有一定的成本，topic(top in container) 的思路则是改造 top 命令，去适配容器，读取容器中反映真实运行情况的系统文件，从而展示正确的容器运行信息，对于用户而言成本更低。</p><p>如下，在一个 1C 和 1Gi 的容器中运行 <code>stress --cpu 2</code>，通过 topic 和 top 查看容器的运行状态：</p><p><img src="https://img.hi-linux.com/staticfile/topic-2021-09-16-xCY4pd.png" alt="topic"></p><p><img src="https://img.hi-linux.com/staticfile/top-2021-09-16-5XrCD7.png" alt="top"></p><p>可以看到，topic 比较好的解决了容器运行信息的问题：</p><ul><li>topic 查看到的 CPU 使用率，其 us 为 99.8%，而 top 查看到的是 13.2%（实为宿主机的 us 信息）</li><li>topic 查看到的 Mem 是 1Gi，而 top 查看到的是 16Gi（实为宿主机的内存信息）</li><li>topic 查看到的 user 数是 11，而 top 查看到的 user 数是 1（实为宿主机的当前登录用户数）</li><li>topic 查看到的容器运行时间为 2days 10:35，而 top 查看到的是 20days 1:57（实为宿主机的运行时间）</li><li>topic 和 top 的进程相关信息显示基本一致。</li></ul><p>如果你需要使用，可以通过下面地址下载 topic 到容器中运行（记得加上执行权限）。</p><ol><li><p>下载地址：<a href="https://silenceshell-1255345740.cos.ap-shanghai.myqcloud.com/topic/topic" target="_blank" rel="noopener">https://silenceshell-1255345740.cos.ap-shanghai.myqcloud.com/topic/topic</a></p></li><li><p>项目地址：<a href="https://github.com/silenceshell/topic" target="_blank" rel="noopener">https://github.com/silenceshell/topic</a></p></li></ol><blockquote><p>本文转载自：「 Zlatan Eevee 」，原文：<a href="https://tinyurl.com/rxdb5n72" target="_blank" rel="noopener">https://tinyurl.com/rxdb5n72</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器通过 cgroups 和 namespace 实现了资源的轻量级隔离和限制，但容器中的 /proc 文件实际上是宿主机的，因此在执行 top 命令查看容器运行信息时，部分指标显示不正确，例如启动时间、用户数、平均负载、cpu 使用率、内存使用率。&lt;/p&gt;
&lt;p&gt;目前比较通用的解决方案是通过 lxcfs，将容器中相应的文件通过 fuse 劫持 read 调用，在打开时显示为容器信息，从而统一解决各种系统状态诊断工具的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>5 个冷门但非常实用的 Kubectl 使用技巧，99% 的人都不知道</title>
    <link href="https://www.hi-linux.com/posts/11484.html"/>
    <id>https://www.hi-linux.com/posts/11484.html</id>
    <published>2021-09-13T01:00:00.000Z</published>
    <updated>2021-09-13T01:39:57.930Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>kubectl 是 K8s 官方附带的命令行工具, 可以方便的操作 K8s 集群. 这篇文章主要介绍一些 kubectl 的别样用法, 希望读者有一定基础的 K8s 使用经验.</p><p>有一篇文章也介绍了一些技巧, 写博客的时候正好搜到了, 正好也分享出来吧.</p><ul><li><a href="https://blog.flant.com/ready-to-use-commands-and-tips-for-kubectl/" target="_blank" rel="noopener">Ready-to-use commands and tips for kubectl</a></li></ul><h2><span id="打印当前使用的api">打印当前使用的API</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl 的主要作用就是与 ApiServer 进行交互, 而交互的过程, 我们可以通过下面的方式来打印, </span><br><span class="line"># 这个命令尤其适合调试自己的api接口时使用.</span><br><span class="line">$ kubectl get ns -v&#x3D;9</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/20210816195205-2021-08-23-FOJY7v.png" alt></p><a id="more"></a><h2><span id="按状态筛选容器以及删除">按状态筛选容器以及删除</span></h2><p>这是我在这里学到的命令: <a href="https://computingforgeeks.com/force-delete-evicted-terminated-pods-in-kubernetes/" target="_blank" rel="noopener">Force Delete Evicted / Terminated Pods in Kubernetes</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --all-namespaces --field-selector status.phase&#x3D;Pending -o json | \</span><br><span class="line">  jq &#39;.items[] | &quot;kubectl delete pods \(.metadata.name) -n \(.metadata.namespace)&quot;&#39; | \</span><br><span class="line">  xargs -n 1 bash -c</span><br><span class="line"></span><br><span class="line"># 这个命令要拆开来看</span><br><span class="line"># 首先, 获取所有 ns 中状态为 Pending 的 pods, 并以 json 形式输出</span><br><span class="line"># 这个语句其实由很多变体, 比如,我想查找 Failed 的状态, 或是某个 deployment</span><br><span class="line"></span><br><span class="line">kubectl get pods --all-namespaces --field-selector status.phase&#x3D;Pending -o json </span><br><span class="line"></span><br><span class="line"># 针对 json 变量进行处理, 生成可用的脚本</span><br><span class="line"># 这里是我想介绍的重点, 利用jq以及kubectl的输出, 构建出可用的命令</span><br><span class="line">jq &#39;.items[] | &quot;kubectl delete pods \(.metadata.name) -n \(.metadata.namespace)&quot;&#39;</span><br><span class="line"></span><br><span class="line"># 执行每一条命令</span><br><span class="line"># 注意, 这种命令一定要好好调试, 删掉预期之外的pod就不好了.</span><br><span class="line">xargs -n 1 bash -c</span><br><span class="line"></span><br><span class="line"># 例如, 下面的语句可以找到所有的Pods并打印可以执行的语句</span><br><span class="line">$ kubectl get pods --all-namespaces --field-selector status.phase&#x3D;Running -o json | \</span><br><span class="line">  jq &#39;.items[] | &quot;kubectl get pods \(.metadata.name) -o wide -n \(.metadata.namespace)&quot;&#39;</span><br><span class="line"></span><br><span class="line">&quot;kubectl get pods metrics-server-6d684c7b5-gtd6q -o wide -n kube-system&quot;</span><br><span class="line">&quot;kubectl get pods local-path-provisioner-58fb86bdfd-98frc -o wide -n kube-system&quot;</span><br><span class="line">&quot;kubectl get pods nginx-deployment-574b87c764-xppmx -o wide -n default&quot;</span><br><span class="line"></span><br><span class="line"># 当然, 如果只是删除单个NS下面的一些pods, 我会选择下面的方法, 但是它操作多个NS就很不方便了.</span><br><span class="line">$ kubectl -n default get pods  | grep Completed | awk &#39;&#123;print $1&#125;&#39; | xargs kubectl -n default delete pods</span><br></pre></td></tr></table></figure><h2><span id="统计具体某台机器上运行的所有pod">统计具体某台机器上运行的所有pod</span></h2><blockquote><p>kubectl 可以使用两种选择器, 一种是 label, 一种是 field, 可以看官网的介绍:</p><ul><li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" target="_blank" rel="noopener">Labels and Selectors</a></li><li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/" target="_blank" rel="noopener">Field Selectors</a></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 它是一种选择器, 可以与上面的 awk 或者 xargs 配合使用.</span><br><span class="line"># 我个人平时都不喜欢用这个, 直接 get 全部 pods, 然后 grep 查找感觉更快</span><br><span class="line">$ kubectl get pods --all-namespaces -o wide --field-selector spec.nodeName&#x3D;pve-node1</span><br></pre></td></tr></table></figure><h2><span id="统计-pod-在不同机器的具体数量分布">统计 Pod 在不同机器的具体数量分布</span></h2><p>不知道有读者看过我的这篇文章: <a href="https://corvo.myseu.cn/2021/04/30/2021-04-30-%E5%9F%BA%E4%BA%8Ekubernetes%E7%9A%84PaaS%E5%B9%B3%E5%8F%B0%E4%B8%AD%E7%BB%86%E5%8A%9B%E5%BA%A6%E6%8E%A7%E5%88%B6pod/" target="_blank" rel="noopener">基于 Kubernetes 的 PaaS 平台中细力度控制 pods 方案的实现</a>. 均衡分布的工作前提是得知pod在各个机器的分布情况. 最好的办法就是我们得到pod信息之后进行简单的统计, 这个工作可以使用<code>awk</code>实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n default get pods -o wide -l app&#x3D;&quot;nginx&quot; | awk &#39;&#123;print $7&#125;&#39;|\</span><br><span class="line"> awk &#39;&#123; count[$0]++  &#125; </span><br><span class="line"> END &#123; </span><br><span class="line">   printf(&quot;%-35s: %s\n&quot;,&quot;Word&quot;,&quot;Count&quot;);</span><br><span class="line">   for(ind in count)&#123;</span><br><span class="line">    printf(&quot;%-35s: %d\n&quot;,ind,count[ind]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;&#39;</span><br><span class="line"></span><br><span class="line"># 执行结果如下</span><br><span class="line">Word                               : Count</span><br><span class="line">NODE                               : 1</span><br><span class="line">pve-node1                          : 1</span><br><span class="line">pve-node2                          : 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># awk 的语法我没深入了解, 有兴趣的读者可以研究看看, 这里我就不求甚解了.</span><br></pre></td></tr></table></figure><h2><span id="kubectl-proxy-的使用">kubectl Proxy 的使用</span></h2><p>你可以理解为这个命令为 K8s 的 ApiServer 做了一层代理, 使用该代理, 你可以直接调用 API 而不需要经过鉴权. 启动之后, 甚至可以实现 <code>kubectl</code> 套娃, 下面是一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 当你没有设置 kubeconfig 而直接调用 kubectl 时</span><br><span class="line">$ kubectl get ns -v&#x3D;9</span><br><span class="line"># 可以打印出下面类似的错误</span><br><span class="line">$ curl -k -v -XGET  -H &quot;Accept: application&#x2F;json, *&#x2F;*&quot; -H &quot;User-Agent: kubectl&#x2F;v1.21.3 (linux&#x2F;amd64) kubernetes&#x2F;ca643a4&quot; &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;api?timeout&#x3D;32s&#39;</span><br><span class="line">skipped caching discovery info due to Get &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;api?timeout&#x3D;32s&quot;: dial tcp 127.0.0.1:8080: connect: connection refused                     </span><br><span class="line"># 也就是说当你不指定kubeconfig文件时, kubectl会默认访问本机的8080端口</span><br><span class="line"># 那么我们先启动一个kubectl proxy, 然后指定监听8080, 再使用kubectl直接访问, 是不是就可行了呢, </span><br><span class="line"># 事实证明, 安全与预想一致.</span><br><span class="line">$ KUBECONFIG&#x3D;~&#x2F;.kube&#x2F;config-symv3 kubectl proxy  -p 8080</span><br><span class="line">$ kubectl get ns</span><br><span class="line">NAME                           STATUS   AGE</span><br><span class="line">default                        Active   127d</span><br></pre></td></tr></table></figure><blockquote><p>默认启动的 Proxy 是屏蔽了某些 API  的, 并且有一些限制, 例如无法使用 exec 进入 pod 之中 可以使用 <code>kubectl proxy --help</code> 来看, 例如</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 仅允许本机访问</span><br><span class="line">--accept-hosts&#x3D;&#39;^localhost$,^127\.0\.0\.1$,^\[::1\]$&#39;: Regular expression for hosts that the proxy should accept.</span><br><span class="line"># 不允许访问下面的api, 也就是说默认没法exec进入容器</span><br><span class="line">--reject-paths&#x3D;&#39;^&#x2F;api&#x2F;.*&#x2F;pods&#x2F;.*&#x2F;exec,^&#x2F;api&#x2F;.*&#x2F;pods&#x2F;.*&#x2F;attach&#39;: Regular expression for paths that the proxy should reject. Paths specified here will be rejected even accepted by --accept-paths.</span><br><span class="line"></span><br><span class="line"># 想跳过 exec 的限制也很简单, 把 reject-paths 去掉就可以了</span><br><span class="line">$ kubectl proxy -p 8080 --keepalive 3600s --reject-paths&#x3D;&#39;&#39; -v&#x3D;9</span><br></pre></td></tr></table></figure><p>有人说这个 <code>kubectl proxy</code> 可能没什么作用, 那可能仅仅是你还没有实际的应用场景. 例如当我想要调试 <code>K8s Dashboard</code> 代码的时候. 如果直接使用 kubeconfig 文件, 我没法看到具体的请求过程, 如果你加上一层 Proxy 转发, 并且设置 <code>-v=9</code> 的时候, 你就自动获得了一个日志记录工具, 在调试时相当有用.</p><h2><span id="总结">总结</span></h2><p>kubectl 是一个强大的命令行工具, 上面我只是介绍了我工作中对其用法的一点探索, 也并不鼓励大家非要记住这些命令, 只是希望当读者需要的时候, 能够想起来 kubectl 可以有类似的功能, 就不需要针对几个临时需求去研读client-api 了.</p><blockquote><p>本文转载自：「 我的小米粥分你一半 」，原文：<a href="https://tinyurl.com/364wh2rk" target="_blank" rel="noopener">https://tinyurl.com/364wh2rk</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kubectl 是 K8s 官方附带的命令行工具, 可以方便的操作 K8s 集群. 这篇文章主要介绍一些 kubectl 的别样用法, 希望读者有一定基础的 K8s 使用经验.&lt;/p&gt;
&lt;p&gt;有一篇文章也介绍了一些技巧, 写博客的时候正好搜到了, 正好也分享出来吧.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.flant.com/ready-to-use-commands-and-tips-for-kubectl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ready-to-use commands and tips for kubectl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;打印当前使用的API&quot;&gt;打印当前使用的API&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# kubectl 的主要作用就是与 ApiServer 进行交互, 而交互的过程, 我们可以通过下面的方式来打印, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 这个命令尤其适合调试自己的api接口时使用.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ kubectl get ns -v&amp;#x3D;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/20210816195205-2021-08-23-FOJY7v.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/categories/kubernetes/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款 GitHub 星标 11.5K 的命令行文件传输神器 transfer.sh（开源免费，支持 10GB 大文件）</title>
    <link href="https://www.hi-linux.com/posts/62383.html"/>
    <id>https://www.hi-linux.com/posts/62383.html</id>
    <published>2021-09-10T01:00:00.000Z</published>
    <updated>2021-09-11T11:02:08.100Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>互联网行业跳槽指南公布，你认可这个顺序吗？</strong></p></blockquote><p>在工作和生活中，我们经常需要在不同设备之间传输文件，但往往会遇到需要安装第三方软件、文件大小限制、传输速度慢等问题。安装第三方软件还好，但是限制传输速度和文件大小就非常恶心了，用着用着就得逼得你充值付费了。不然紧急需要传输一个东西，就非常花费时间和精力了。</p><h2><span id="软件介绍">软件介绍</span></h2><blockquote><p><strong>Easy and fast file sharing from the command-line.</strong></p></blockquote><p>当然，我们可以也使用，老牌的 <strong>百度云盘</strong>(非会员限速)、<strong>Dropbox</strong>(速度非常之慢)和 <strong>Google Drive</strong>(需要科学上网)，新进的 <strong>阿里云盘</strong>(虽然不限速但上传不能加速)、<strong>奶牛快传</strong>(有文件大小总量限制)。但是这里我们要介绍的是一个基于命令行的文件传输工具 —— <a href="https://github.com/dutchcoders/transfer.sh" target="_blank" rel="noopener"><strong><code>transfer.sh</code></strong></a>。</p><ul><li>Made for use with shell</li><li>Share files with a URL</li><li>For free</li><li>Upload up to 10 GB</li><li>Files stored for 14 days</li><li>Encrypt your files</li><li>Maximize amount of downloads</li></ul><h2><span id="使用方式">使用方式</span></h2><blockquote><p><strong>Sample use cases</strong></p></blockquote><ul><li><strong>[1] 命令行使用</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 将shell函数添加到.bashrc或.zshrc文件中</span><br><span class="line">transfer() &#123;</span><br><span class="line">  if [ $# -eq 0 ]; then</span><br><span class="line">    echo &quot;No arguments specified.&quot;</span><br><span class="line">    echo &quot;Usage: &quot;</span><br><span class="line">    echo &quot;  transfer &lt;file|directory&gt; ... | transfer &lt;file_name&gt;&quot;</span><br><span class="line">    return 1</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if tty -s; then</span><br><span class="line">    file&#x3D;&quot;$1&quot;</span><br><span class="line">    file_name&#x3D;$(basename &quot;$file&quot;)</span><br><span class="line"></span><br><span class="line">    if [ ! -e &quot;$file&quot; ]; then</span><br><span class="line">      echo &quot;$file: No such file or directory&quot;</span><br><span class="line">      return 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if [ -d &quot;$file&quot; ]; then</span><br><span class="line">      file_name&#x3D;&quot;$file_name.zip&quot;</span><br><span class="line">      (cd &quot;$file&quot; &amp;&amp; zip -r -q - .) | curl --progress-bar --upload-file &quot;-&quot; &quot;https:&#x2F;&#x2F;transfer.sh&#x2F;$file_name&quot; | tee &#x2F;dev&#x2F;null</span><br><span class="line">    else</span><br><span class="line">      cat &quot;$file&quot; | curl --progress-bar --upload-file &quot;-&quot; &quot;https:&#x2F;&#x2F;transfer.sh&#x2F;$file_name&quot; | tee &#x2F;dev&#x2F;null</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line">    file_name&#x3D;&quot;$1&quot;</span><br><span class="line">    curl --progress-bar --upload-file &quot;-&quot; &quot;https:&#x2F;&#x2F;transfer.sh&#x2F;$file_name&quot;|tee &#x2F;dev&#x2F;null</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 现在可以使用函数来上传文件</span><br><span class="line">$ transfer hello.txt</span><br></pre></td></tr></table></figure><ul><li><strong>[2] 简单上传文件</strong> - <a href="https://transfer.sh/#" target="_blank" rel="noopener">官方支持界面上传</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 使用curl命令上传文件</span><br><span class="line">$ curl --upload-file .&#x2F;hello.txt https:&#x2F;&#x2F;transfer.sh&#x2F;hello.txt</span><br><span class="line">https:&#x2F;&#x2F;transfer.sh&#x2F;66nb8&#x2F;hello.txt</span><br><span class="line"></span><br><span class="line"># 上传文件设定最大下载次数和过期时间</span><br><span class="line">$ curl -H &quot;Max-Downloads: 1&quot; -H &quot;Max-Days: 5&quot; --upload-file .&#x2F;hello.txt https:&#x2F;&#x2F;transfer.sh&#x2F;hello.txt</span><br><span class="line">https:&#x2F;&#x2F;transfer.sh&#x2F;66nb8&#x2F;hello.txt</span><br><span class="line"></span><br><span class="line"># 下载文件</span><br><span class="line">$ curl https:&#x2F;&#x2F;transfer.sh&#x2F;66nb8&#x2F;hello.txt -o hello.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 还支持wget上传文件</span><br><span class="line">$ wget --method PUT --body-file&#x3D;&#x2F;tmp&#x2F;file.tar https:&#x2F;&#x2F;transfer.sh&#x2F;file.tar -O - -nv</span><br><span class="line"></span><br><span class="line"># 还支持HTTPie上传文件</span><br><span class="line">$ http https:&#x2F;&#x2F;transfer.sh&#x2F; -vv &lt; &#x2F;tmp&#x2F;test.log</span><br><span class="line"></span><br><span class="line"># 还支持PowerShell上传文件</span><br><span class="line">PS H:\&gt; invoke-webrequest -method put -infile .\file.txt https:&#x2F;&#x2F;transfer.sh&#x2F;file.txt</span><br></pre></td></tr></table></figure><ul><li><strong>[3] 一次上传多个文件</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用filedata执行文件地址</span><br><span class="line">$ curl -i -F filedata&#x3D;@&#x2F;tmp&#x2F;hello.txt -F filedata&#x3D;@&#x2F;tmp&#x2F;hello2.txt https:&#x2F;&#x2F;transfer.sh&#x2F;</span><br><span class="line"></span><br><span class="line"># 将下载合并为zip或tar存档</span><br><span class="line">$ curl https:&#x2F;&#x2F;transfer.sh&#x2F;(15HKz&#x2F;hello.txt,15HKz&#x2F;hello.txt).tar.gz</span><br><span class="line">$ curl https:&#x2F;&#x2F;transfer.sh&#x2F;(15HKz&#x2F;hello.txt,15HKz&#x2F;hello.txt).zip</span><br></pre></td></tr></table></figure><ul><li><strong>[4] 传输前使用加密您的文件</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用gpg加密文件</span><br><span class="line">$ cat &#x2F;tmp&#x2F;hello.txt | gpg -ac -o- | curl -X PUT --upload-file &quot;-&quot; https:&#x2F;&#x2F;transfer.sh&#x2F;test.txt</span><br><span class="line"></span><br><span class="line"># 下载并解密</span><br><span class="line">$ curl https:&#x2F;&#x2F;transfer.sh&#x2F;1lDau&#x2F;test.txt | gpg -o- &gt; &#x2F;tmp&#x2F;hello.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用openssl加密文件</span><br><span class="line">$ cat &#x2F;tmp&#x2F;hello.txt | openssl aes-256-cbc -pbkdf2 -e | curl -X PUT --upload-file &quot;-&quot; https:&#x2F;&#x2F;transfer.sh&#x2F;test.txt</span><br><span class="line"></span><br><span class="line"># 下载并解密</span><br><span class="line">$ curl https:&#x2F;&#x2F;transfer.sh&#x2F;1lDau&#x2F;test.txt | openssl aes-256-cbc -pbkdf2 -d &gt; &#x2F;tmp&#x2F;hello.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 从keybase导入key</span><br><span class="line">$ keybase track [them]</span><br><span class="line"></span><br><span class="line"># 加密文件</span><br><span class="line">$ cat somebackupfile.tar.gz | keybase encrypt [them] | curl --upload-file &#39;-&#39; https:&#x2F;&#x2F;transfer.sh&#x2F;test.txt</span><br><span class="line"></span><br><span class="line"># 解密下载</span><br><span class="line">$ curl https:&#x2F;&#x2F;transfer.sh&#x2F;sqUFi&#x2F;test.md | keybase decrypt</span><br></pre></td></tr></table></figure><ul><li><strong>[5] 扫描恶意软件</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用Clamav扫描恶意软件或病毒</span><br><span class="line">$ wget http:&#x2F;&#x2F;www.eicar.org&#x2F;download&#x2F;eicar.com</span><br><span class="line">$ curl -X PUT --upload-file .&#x2F;eicar.com https:&#x2F;&#x2F;transfer.sh&#x2F;eicar.com&#x2F;scan</span><br><span class="line"></span><br><span class="line"># 上传恶意软件到VirusTotal并获得永久链接</span><br><span class="line">$ curl -X PUT --upload-file nhgbhhj https:&#x2F;&#x2F;transfer.sh&#x2F;test.txt&#x2F;virustotal</span><br></pre></td></tr></table></figure><ul><li><strong>[6] 加密传输备份 mysql 数据库</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 备份+加密+传输</span><br><span class="line">$ mysqldump --all-databases | gzip | gpg -ac -o- | curl -X PUT --upload-file &quot;-&quot; https:&#x2F;&#x2F;transfer.sh&#x2F;test.txt</span><br></pre></td></tr></table></figure><ul><li><strong>[7] 发送带有传输链接的电子邮件</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 传输和发送带有链接的电子邮件</span><br><span class="line">$ transfer &#x2F;tmp&#x2F;hello.txt | mail -s &quot;Hello World&quot; user@yourmaildomain.com</span><br></pre></td></tr></table></figure><ul><li><strong>[8] 传输日志文件</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># grep syslog for pound and transfer</span><br><span class="line">$ cat &#x2F;var&#x2F;log&#x2F;syslog | grep pound | curl --upload-file - https:&#x2F;&#x2F;transfer.sh&#x2F;pound.log</span><br></pre></td></tr></table></figure><h2><span id="参考链接">参考链接</span></h2><ul><li><a href="https://transfer.sh/#" target="_blank" rel="noopener">transfer.sh 官方网站</a></li><li><a href="https://github.com/dutchcoders/transfer.sh" target="_blank" rel="noopener">transfer.sh 的 Github 仓库地址</a></li></ul><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://tinyurl.com/5chzpk9w" target="_blank" rel="noopener">https://tinyurl.com/5chzpk9w</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;div
        
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.hi-linux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="终端" scheme="https://www.hi-linux.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Docker Desktop 突然宣告收费，是时候弃用了？</title>
    <link href="https://www.hi-linux.com/posts/20003.html"/>
    <id>https://www.hi-linux.com/posts/20003.html</id>
    <published>2021-09-09T01:00:00.000Z</published>
    <updated>2021-09-30T04:54:17.581Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在容器引擎 Docker 诞生的 8 年间，其与开源的容器编排 Kubernetes 共同推动容器技术在云计算领域的应用，也让自身在全球范围内受到了广泛的关注。可以说，做过云计算开发的程序员，十有八有学过 Docker 技术。</p><p>不过，近日 Docker 宣布对其产品的订阅方案进行了更新，更新内容包括使用 “Docker Personal” 订阅来代替此前的 “Docker Free” 订阅，以及增加新的订阅方案——“Docker Business”。</p><p>因此，Docker 目前总共有 4 种订阅方案，分别是：<strong>Personal, Pro, Team 和 Business</strong>。虽然新增的 “Docker Business” 订阅方案收费比较昂贵，不过 Docker 表示，这对于大多数人来说并没有影响，他们仍然可以继续免费使用。</p><a id="more"></a><p>之所以推出收费更高的订阅方案，是为了探索出一种可持续的商业模式。Docker CEO Scott Johnston 表示，Docker 已成为企业标准，他们希望解决软件供应链存在的安全挑战，于是有了更昂贵且提供更安全服务的 Docker Business 订阅方案。</p><p><img src="https://img.hi-linux.com/staticfile/640-2021-09-07-Ytdr8l.jpg" alt></p><p><em>本次调整对 Docker Engine 以及上游 Docker 和 Moby 开源项目没有进行任何改动。</em></p><p>事实上，此次订阅方案的调整主要是对 Docker Desktop 的使用条款进行了更改：</p><ul><li><p>对于小型企业（少于 250 名员工且年收入少于 1000 万美元）、个人、教育和非商业开源项目，Docker Desktop 仍然会免费提供</p></li><li><p>中大型企业使用 Docker Desktop 需要付费订阅，可选择 Pro, Team 和 Business 三种方案的任意一种，收费是每位用户每月 5 美元起。这几种方案的主要区别是提供了不同的功能。例如 Docker Business 提供了集中管理和单点登录等增强安全性的功能</p></li></ul><p>Docker Desktop 是一个 GUI 工具，用于管理各种 Docker 组件和功能，包括容器、镜像、卷（附加到容器的存储）、本地 Kubernetes、容器内的开发环境等。虽然大多数 Docker 组件都可用于 Windows、Mac 和 Linux，但 Docker Desktop 不支持在 Linux 上运行，仅适用于 Windows 和 Mac。</p><p>据悉，这些条款的生效日期是 2021 年 8 月 31 日，不过，对于需要付费订阅才能使用 Docker Desktop 的用户，Docker 官方也提供了一个宽限期，供用户过渡，具体时间是截止到 2022 年 1 月 31 日。那么这对用户的影响究竟有多大？</p><p>据 Docker 官方报道，全球有 55% 的专业开发者正在使用 Docker 技术，其中个人开发者及小型企业占据其中的一半，这也意味着大多数 Docker 用户仍然可以以免费的方式使用它。不过，Scott Johnston 也透露此前订阅用户仍然不到 Docker 总体使用量的 10%。</p><p>因此时下的这一调整，也会对不少企业带来一定的影响。对于这样的改变，不少网友也纷纷有种被劝退之感：</p><ul><li><p>我非常期待有开源替代品出现，并将 Docker 取而代之；</p></li><li><p>这极有可能会杀死 Docker；</p></li><li><p>再见 Docker Desktop，我认为接下来会有很多超过 250 名员工的企业会做出同样的事情；</p></li><li><p>…</p></li></ul><p>最后给大家推荐一个 Docker for Mac 下的替代品 <code>Lima+Containerd+nerdctl</code>。</p><blockquote><p><strong>什么是 Lima？</strong></p><p>Lima（Linux MAchines）可以启动具有自动文件共享、端口转发和使用 containerd 的 Linux 虚拟机。</p><p><strong>什么是 Containerd？</strong></p><p>Containerd 是一个开源的容器运行时，被很多项目所使用，包括 Docker，和很多云厂商默认配置的 Kubernetes 集群，例如 AKS， EKS 和 GKE。</p><p><strong>什么是 nerdctl？</strong></p><p>nerdctl 是一个与 Docker Cli 风格兼容的 Containerd 客户端工具，而且直接兼容 Docker Compose 的语法的，这就大大提高了直接将 containerd 作为本地开发、测试或者单机容器部署使用的效率。</p></blockquote><p>更多详细使用方法可参考：『<a href="https://mp.weixin.qq.com/s/TreV41cxXL5RXuFiLpg6Mw" target="_blank" rel="noopener">Lima：Docker Desktop for Mac 的免费开源且自由的替代品</a>』一文</p><p><strong>参考文档</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/rbNSX03rbIb5-gTrEkdRrw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rbNSX03rbIb5-gTrEkdRrw</a></li><li><a href="https://mp.weixin.qq.com/s/TreV41cxXL5RXuFiLpg6Mw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/TreV41cxXL5RXuFiLpg6Mw</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在容器引擎 Docker 诞生的 8 年间，其与开源的容器编排 Kubernetes 共同推动容器技术在云计算领域的应用，也让自身在全球范围内受到了广泛的关注。可以说，做过云计算开发的程序员，十有八有学过 Docker 技术。&lt;/p&gt;
&lt;p&gt;不过，近日 Docker 宣布对其产品的订阅方案进行了更新，更新内容包括使用 “Docker Personal” 订阅来代替此前的 “Docker Free” 订阅，以及增加新的订阅方案——“Docker Business”。&lt;/p&gt;
&lt;p&gt;因此，Docker 目前总共有 4 种订阅方案，分别是：&lt;strong&gt;Personal, Pro, Team 和 Business&lt;/strong&gt;。虽然新增的 “Docker Business” 订阅方案收费比较昂贵，不过 Docker 表示，这对于大多数人来说并没有影响，他们仍然可以继续免费使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/categories/docker/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
</feed>
