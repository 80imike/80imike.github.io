<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇妙的 Linux 世界</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2024-06-03T09:31:47.869Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『极客视界』一站式科技达人综合资讯指南和神秘宝箱，等你来开启</title>
    <link href="https://www.hi-linux.com/posts/22000.html"/>
    <id>https://www.hi-linux.com/posts/22000.html</id>
    <published>2050-06-18T01:00:00.000Z</published>
    <updated>2024-06-03T09:31:47.869Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="️-极客视界科技达人的综合资讯指南">🛠️ 『极客视界』科技达人的综合资讯指南</span></h2><p>你是否常常为寻找最新的技术资讯、工具和资源而感到困扰？或者每次开发时都需要开启无数个标签页，才能找到所需的工具和信息？</p><p>别担心，让我为你介绍一个好地方『极客视界』，这是每位科技达人的福音、必备的综合资讯指南。</p><p>『极客视界』提供了一站式的服务，它包罗万象、功能丰富，直接满足你从资讯获取到开发辅助的全部需求。</p><p>从 GitHub 热榜到 PDF 工具箱，从实时新闻资讯、技术文章到虚拟临时邮箱，样样俱全！</p><a id="more"></a><h3><span id="极客视界">🤓 极客视界</span></h3><p>『极客视界』是一个综合科技资讯的枢纽。如果你喜欢紧跟最新的科技动态、追踪热门项目，或是希望时刻了解技术动向，那这个板块绝对不容错过。</p><h4><span id="github-热榜">🏆 Github 热榜</span></h4><p>每天都有成千上万的项目在 GitHub 上更新，又如何挑选出最热门、最有趣的项目呢？</p><p>别担心，『极客视界』已经为你做了筛选。我们提供的每日更新的 GitHub 热门项目榜单，每天看看就知道哪些项目正火热。</p><p>实时获取最新最火的开源项目，助你快速了解哪些项目正在迅速蹿红，也可以看看有多少大牛在关注同样的项目，再也不用费力翻找。</p><h4><span id="最新-it-新闻和技术文章">📰 最新 IT 新闻和技术文章</span></h4><p>获取行业动态和最新资讯是每个极客的日常标配。在『极客视界』，你能找到最新的 IT 新闻和技术文章。</p><p>我们涵盖了从前沿技术到开发实战，从行业大事件到新兴趋势的一切内容。</p><p>不仅内容丰富，还有专业的编辑团队为你推荐精选文章，让你在最短时间内掌握最有价值的信息。</p><h4><span id="黑客新闻">🧑‍💻 黑客新闻</span></h4><p>这里提供最新、最全的黑客新闻，覆盖广泛的领域。无论是安全漏洞、趋势分析，还是开发者的门道，这里都有。</p><h4><span id="github-热门仓库状态跟踪">📈 Github 热门仓库状态跟踪</span></h4><p>对你关注的热门仓库进行状态跟踪，实时获取更新信息。再也无须手动查询，每天都能知道自己心仪的仓库发生了哪些变化。</p><h4><span id="服务监控">💚 服务监控</span></h4><p>对各种网络服务进行监控，只需轻松设置，关键数据一目了然。实时掌握各种关注服务的状态，确保系统平稳运行。</p><h3><span id="极客秘境">🗞 极客秘境</span></h3><p>这里是技术人的宝藏，包括最新的 IT 新闻、技术文章和深度分析，兼具广度和深度。</p><h4><span id="ai-新世界">🤖 AI 新世界</span></h4><p>这里聚焦人工智能领域的最新资讯和技术动态，想知道 AI 的新突破、新应用，或者最新的研究成果，这里一站搞定。</p><h4><span id="科技周刊汇">📅 科技周刊汇</span></h4><p>每周汇总最具价值的科技新闻，如果你是一周一更新的节奏党，这里绝对不会让你错过任何重要信息。</p><h4><span id="数码潮流">💻 数码潮流</span></h4><p>最新数码产品的资讯和评测，从手机到电脑再到各种智能设备。让你在购买之前就对产品有全面的了解，做个不踩雷的科技买手。</p><h4><span id="知乎热榜">🌐 知乎热榜</span></h4><p>集成知乎的科技热榜，看看大家都在讨论些什么热门话题。知乎神仙们的回答一定会让你豁然开朗。</p><h4><span id="it-之家热榜">🏠 IT 之家热榜</span></h4><p>再也不会错过 IT 之家发布的有趣新闻和深度文章，适合 IT 人必读的榜单，全方位提升知识水平。</p><h4><span id="稀土掘金文章榜">💡 稀土掘金文章榜</span></h4><p>聚集稀土掘金平台的热门技术文章，无论是新工具、新技术，还是各种开发干货，这里都值得一看。</p><h4><span id="hellogithub-热门仓库">🚀 HelloGithub 热门仓库</span></h4><p>专业团队挑选和介绍的 Github 热门仓库，涵盖广泛的编程语言和框架。每期精选，你一定能找到自己感兴趣的项目。</p><h3><span id="it-人必备工具箱">🧰 IT 人必备工具箱</span></h3><p>『IT 人必备工具箱』 是每一位 IT 人都不可或缺的资源宝库，里面收纳着各种专注于技术领域的优质资源和实用工具。</p><p>它如同一座巨大的数字图书馆，为 IT 从业者提供了丰富的资讯和工具。</p><p>让他们在数字世界中驰骋自如，无论是编程开发、网络安全、数据分析还是人工智能。</p><p>这个工具箱都汇聚了各种经典和前沿的资源，为 IT 人士解决难题、提升技能提供了强大的支持。</p><p>无论是初学者还是资深技术大牛，都可以从中汲取灵感，探索未知，不断成长。</p><h3><span id="开发工具箱">🧑‍💻 开发工具箱</span></h3><p>作为开发者，你一定会喜欢我们的开发工具箱。</p><p>这里囊括了各种实用的开发小工具，涵盖了从代码编辑、JSON 解析器、网络调试工具、正则表达式测试器等的一切，应有尽有。</p><p>所有的工具都经过精心挑选和测试，确保能在关键时刻帮到你。减少你在开发过程中寻找工具的时间，提升工作效率。</p><h3><span id="代码图美化">🎨 代码图美化</span></h3><p>代码不仅要运行得好，还要看得美。我们的代码图美化工具，可以将你的一段代码精美地呈现出来。</p><p>它可以帮助你将代码片段转化成美观的图片，它支持高度定制，照顾到每一个细节，让你的代码更具表现力。</p><p>不论是分享给团队成员，还是展示在个人博客上，漂亮的代码图总能让你的工作成果更上一层楼。</p><h3><span id="ip-工具箱">🌍 IP 工具箱</span></h3><p>无论是开发还是运维，IP 信息总是绕不开的问题。『极客视界』为你准备了全面的 IP 工具箱，涵盖从 IP 查找、IP 段查询到地理位置转换等多种功能，让你轻松搞定所有与 IP 相关的难题。</p><p>对于网络管理员和开发者来说，这些功能在日常工作中非常实用。</p><h3><span id="pdf-工具箱">📄 PDF 工具箱</span></h3><p>处理 PDF 文件常常让人头疼，但在『极客视界』这一切都不是问题。我们提供了全方位的 PDF 工具箱，包括 PDF 转换、合并、拆分、压缩等多种功能。</p><p>不管你的需求是什么，这里都有合适的工具帮你搞定，一站解决所有需求，让你轻松应对各种文档格式的转换问题。</p><h3><span id="今日热榜">🔥 今日热榜</span></h3><p>想知道今天哪些内容最火爆？来看看我们的今日热榜吧！这里汇集了各大平台的热门内容，如微博、知乎、抖音等。</p><p>无论是新闻、帖子、视频还是其他内容，最受关注的总能在这里找到。不用再费力刷各大社交媒体，只需一站尽知天下热点，轻松做个潮流达人。</p><h3><span id="虚拟临时邮箱">📫 虚拟临时邮箱</span></h3><p>注册各种网站服务时，常常会担心邮箱被垃圾信息淹没？</p><p>使用我们的虚拟临时邮箱功能吧！它能生成临时邮件地址，帮你保护真实邮箱免受打扰。使用简单方便，一键生成，特别适合短期注册需求。</p><h3><span id="️-手绘画板">🖌️ 手绘画板</span></h3><p>需要临时记录灵感或进行手绘创作？『极客视界』的手绘画板功能正是为你准备的。</p><p>无需下载任何应用，在线即可进行手绘，支持多种笔刷和颜色选择，无论是画草图还是进行简单设计，这里都能得心应手。</p><h3><span id="视频下载">📥 视频下载</span></h3><p>在线遇到好视频想下载，却苦于找不到合适的工具？</p><p>我们提供的在线视频下载工具可以帮你解决这个问题。支持多种视频平台，下载速度快，操作简便，让你轻松保存喜欢的视频内容。</p><h3><span id="️-超级终端">🖥️ 超级终端</span></h3><p>如果你经常需要在的终端工作，这个超级终端你一定会爱不释手。它支持各种命令输出，让你看上去很酷而忙碌，是极客必备的利器。</p><h2><span id="为什么选择极客视界">🤔 为什么选择『极客视界』？</span></h2><h3><span id="集成化一站式服务">🌅 集成化，一站式服务</span></h3><p>无需再奔波于各个网站寻找工具和资讯，『极客视界』将所有常用的开发工具和最新资讯集成在一个平台上，一站式解决你的所有需求。</p><h3><span id="实用性强">📝 实用性强</span></h3><p>我们精心挑选每一项功能和工具，确保它们在实际工作中有用且好用，节省你的时间，提升工作效率。</p><h3><span id="持续更新">📈 持续更新</span></h3><p>科技的发展日新月异，我们的团队时刻关注行业动态，不断更新功能和内容，确保你在『极客视界』获取到最新、最热的资讯和工具。</p><h2><span id="如何开始">🚀 如何开始？</span></h2><p>体验所有这些功能只需一个简单的步骤：访问 <a href="https://bestgeek.org" target="_blank" rel="noopener">https://bestgeek.org</a> 开始你的极客之旅吧！</p><p>然后根据你的需求选择相应的分类开始探索吧！无论你是开发者、设计师还是普通的科技爱好者，『极客视界』都能为你提供你需要的一切。</p><h2><span id="结语">🎉 结语</span></h2><p>上述功能仅仅是『极客视界』的一部分，我们致力于为每一个热爱科技的朋友提供全面的资讯与工具支持。</p><p>『极客视界』不仅是功能齐全的工具和资讯平台，更是每个极客共同的家园。</p><p>在这里，你可以找到志同道合的伙伴，获取最新的技术资讯和最实用的开发工具。让我们一起在这个充满科技乐趣的视界里遨游吧！</p><p>赶快收藏 <a href="https://bestgeek.org" target="_blank" rel="noopener">极客视界</a>，开启你的科技之旅吧！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;🛠️-『极客视界』科技达人的综合资讯指南&quot;&gt;🛠️ 『极客视界』科技达人的综合资讯指南&lt;/h2&gt;
&lt;p&gt;你是否常常为寻找最新的技术资讯、工具和资源而感到困扰？或者每次开发时都需要开启无数个标签页，才能找到所需的工具和信息？&lt;/p&gt;
&lt;p&gt;别担心，让我为你介绍一个好地方『极客视界』，这是每位科技达人的福音、必备的综合资讯指南。&lt;/p&gt;
&lt;p&gt;『极客视界』提供了一站式的服务，它包罗万象、功能丰富，直接满足你从资讯获取到开发辅助的全部需求。&lt;/p&gt;
&lt;p&gt;从 GitHub 热榜到 PDF 工具箱，从实时新闻资讯、技术文章到虚拟临时邮箱，样样俱全！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="IT" scheme="https://www.hi-linux.com/tags/IT/"/>
    
      <category term="程序员" scheme="https://www.hi-linux.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>『IT 人员必备工具箱』：一个专注于 IT 人的优质资源分享导航站</title>
    <link href="https://www.hi-linux.com/posts/53504.html"/>
    <id>https://www.hi-linux.com/posts/53504.html</id>
    <published>2050-03-18T01:00:00.000Z</published>
    <updated>2024-03-14T03:05:50.391Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』是一个专注于 IT 人优质资源分享的导航站，包含大量好玩又实用的 AI、翻译、编程、设计、Linux、网络、云原生、安全等多款应用。</p><p>🏷️  网站地址：<a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a></p><p><img src="https://img.hi-linux.com/staticfile/Tweelet00-2024-03-14-n0S5jR.webp" alt="全站预览图"></p><p>我们的目标是帮助更多 IT 人发现有价值的优质资源，让更多人受益。</p><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』也可以推荐你喜欢的软件和网站呢！如果你有什么好玩有趣又实用的酷软趣站，快『<a href="https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz" target="_blank" rel="noopener">推荐</a>』给我们吧！</p><p>🏷️  趣站酷软推荐收集表: <a href="https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz" target="_blank" rel="noopener">https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz</a></p><a id="more"></a><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』部分截图展示：</p><p><img src="https://img.hi-linux.com/staticfile/Tweelet01-2024-03-14-9hHDLK.png" alt="实用工具"><br><img src="https://img.hi-linux.com/staticfile/Tweelet02-2024-03-14-ejfZrm.png" alt="奇妙的 Linux 世界 + 搜索引擎 + 新闻资讯"><br><img src="https://img.hi-linux.com/staticfile/Tweelet03-2024-03-14-ZkjPxQ.png" alt="电子邮件 + 出行服务 + AI 翻译利器"><br><img src="https://img.hi-linux.com/staticfile/Tweelet04-2024-03-14-NbfprZ.png" alt="AI 新世界 + 云服务"><br><img src="https://img.hi-linux.com/staticfile/Tweelet05-2024-03-14-xTbQV6.png" alt="编程开发"><br><img src="https://img.hi-linux.com/staticfile/Tweelet06-2024-03-14-OvFNBk.png" alt="GitHub 热榜 + 网络调试"><br><img src="https://img.hi-linux.com/staticfile/Tweelet07-2024-03-14-bluwgD.png" alt="绘图设计 + 镜像加速"><br><img src="https://img.hi-linux.com/staticfile/Tweelet08-2024-03-14-G4HEGV.png" alt="云原生容器化 + 安全相关 + 玩转 NixOS + 博客网摘"><br><img src="https://img.hi-linux.com/staticfile/Tweelet09-2024-03-14-FjDHJs.png" alt="职来职往 + 光影时刻 + 音乐之声"><br><img src="https://img.hi-linux.com/staticfile/Tweelet10-2024-03-14-3W7reF.png" alt="趣站酷软"></p><p>📕 关注『<a href="https://mp.weixin.qq.com/s/8iRVr_IN3jB3MnmAdgAOoQ" target="_blank" rel="noopener">奇妙的 Linux 世界</a>』公众号，带你开启有趣新生活！更多好用好玩的软件资源，可访问 <a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a> 免费获取。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IT 人员必备工具箱&lt;/a&gt;』是一个专注于 IT 人优质资源分享的导航站，包含大量好玩又实用的 AI、翻译、编程、设计、Linux、网络、云原生、安全等多款应用。&lt;/p&gt;
&lt;p&gt;🏷️  网站地址：&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://666666.dev&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/Tweelet00-2024-03-14-n0S5jR.webp&quot; alt=&quot;全站预览图&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们的目标是帮助更多 IT 人发现有价值的优质资源，让更多人受益。&lt;/p&gt;
&lt;p&gt;『&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IT 人员必备工具箱&lt;/a&gt;』也可以推荐你喜欢的软件和网站呢！如果你有什么好玩有趣又实用的酷软趣站，快『&lt;a href=&quot;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;推荐&lt;/a&gt;』给我们吧！&lt;/p&gt;
&lt;p&gt;🏷️  趣站酷软推荐收集表: &lt;a href=&quot;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>一键测速、24 小时实时监控，MySpeed 让你成为网络管理专家</title>
    <link href="https://www.hi-linux.com/posts/55534.html"/>
    <id>https://www.hi-linux.com/posts/55534.html</id>
    <published>2024-07-30T01:00:00.000Z</published>
    <updated>2024-07-30T01:27:41.450Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>你是否曾经遇到过网速突然变慢，但又不知道如何查找原因的情况？或者你想长期监控你的网络性能，但找不到合适的工具？</p><p>别担心，<code>MySpeed</code> 来啦！这个强大而简单的工具可以帮助你轻松测试和监控网络速度。今天，让我们一起深入了解 <code>MySpeed</code>，看看它如何成为你的网络管家!</p><h2><span id="什么是-myspeed">什么是 MySpeed？</span></h2><p><code>MySpeed</code> 是一个开源的网络速度测试和监控工具。它不仅可以测试你的当前网速，还能持续监控网络性能，并以图表形式展示结果。无论你是网络达人还是普通用户，<code>MySpeed</code> 都能满足你的需求。</p><p><code>MySpeed</code> 支持 <code>Ookla</code>、<code>LibreSpeed</code> 和 <code>Cloudflare</code> 多种速度测试服务器。你可以根据自身需求，在它们之间进行任意选择。</p><ul><li>MySpeed 官方地址</li></ul><p><a href="https://myspeed.dev/" target="_blank" rel="noopener">https://myspeed.dev/</a></p><ul><li>MySpeed Github 地址</li></ul><p><a href="https://github.com/gnmyt/myspeed" target="_blank" rel="noopener">https://github.com/gnmyt/myspeed</a></p><a id="more"></a><p>⭐ MySpeed 具有以下特性</p><p>📊 <code>MySpeed</code> 可生成清晰的速度、<code>Ping</code> 等统计数据<br>⏰ <code>MySpeed</code> 可自动进行速度测试，并允许您使用 <code>Cron</code> 表达式设置测试之间的时间间隔<br>🗄️ 直接向 <code>MySpeed</code> 实例添加多个服务器<br>🩺 配置健康检查，以便在出现错误或停机时通过电子邮件、Signal、WhatsApp 或 Telegram 通知您<br>📆 测试结果可存储长达 30 天<br>🔥 支持 <code>Prometheus</code> 和 <code>Grafana</code><br>🗳️ 在 <code>Ookla</code>、<code>LibreSpeed</code> 和 <code>Cloudflare</code> 速度测试服务器之间进行选择</p><h2><span id="为什么选择-myspeed">为什么选择 MySpeed?</span></h2><ol><li><strong>开源免费</strong>: 作为一个开源项目，<code>MySpeed</code> 完全免费使用，你还可以根据需要自定义功能。</li><li><strong>功能强大</strong>: 支持速度测试、长期监控、数据可视化等多种功能。</li><li><strong>使用简单</strong>: 界面友好，操作直观，即使是技术小白也能轻松上手。</li><li><strong>隐私保护</strong>: 所有数据都存储在你的本地设备上，无需担心隐私泄露。</li></ol><p>好了，话不多说，让我们开始 <code>MySpeed</code> 的奇妙之旅吧!</p><h2><span id="安装-myspeed">安装 MySpeed</span></h2><p><code>MySpeed</code> 使用 <code>Node.js</code> 开发，因此你需要先安装 <code>Node.js</code> 和 <code>NPM</code> 包管理器。</p><p>好消息！<code>MySpeed</code> 现在支持 <code>Docker</code> 安装,这意味着你可以在几分钟内就完成安装,而不需要担心复杂的依赖问题。让我们一起来看看如何通过 <code>Docker</code> 轻松部署 <code>MySpeed</code>。</p><h3><span id="准备工作">准备工作</span></h3><p>在开始之前,请确保你的系统已经安装了 <code>Docker</code>。如果还没有安装,可以访问 <code>Docker</code> 官网下载并安装适合你系统的版本。</p><ol><li>步骤 1: 拉取 MySpeed 镜像</li></ol><p>打开你的终端，输入以下命令来拉取 <code>MySpeed</code> 的 <code>Docker</code> 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull germannewsmaker/myspeed:latest</span><br></pre></td></tr></table></figure><p>这个命令会从 <code>Docker</code> 容器仓库下载最新版本的 <code>MySpeed</code> 最新镜像。</p><ol start="2"><li>步骤 2: 运行 MySpeed 容器</li></ol><p>现在，让我们启动 <code>MySpeed</code> 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5216:5216 -v myspeed:/myspeed/data --restart=unless-stopped --name MySpeed germannewsmaker/myspeed</span><br></pre></td></tr></table></figure><p>这个命令做了以下几件事：</p><ul><li><code>-d</code>: 在后台运行容器</li><li><code>-p 5216:5216</code>: 将容器的 5216 端口映射到主机的 5216 端口</li><li><code>-v myspeed_data:/myspeed/data</code>: 创建一个名为 <code>myspeed_data</code> 的卷,用于持久化存储数据</li><li><code>--name myspeed</code>: 给容器取名为 “myspeed”</li></ul><ol start="3"><li>步骤 3: 验证安装</li></ol><p>打开你喜欢的浏览器,访问 <code>http://localhost:5216</code>。如果你看到 <code>MySpeed</code> 的界面，恭喜你，安装成功了！</p><ol start="4"><li>额外提示：更新 MySpeed</li></ol><p>当有新版本发布时，更新 <code>MySpeed</code> 也非常简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5216:5216 --pull always -v myspeed:/myspeed/data --restart=unless-stopped --name MySpeed germannewsmaker/myspeed</span><br></pre></td></tr></table></figure><p>加入的 <code>--pull always</code> 参数的作用是告诉 <code>Docker</code> 始终尝试更新镜像。</p><h2><span id="使用-myspeed">使用 MySpeed</span></h2><h3><span id="访问-web-界面">访问 Web 界面</span></h3><p>打开你喜欢的浏览器，输入<code>http://localhost:3000</code> 。欢迎来到 <code>MySpeed</code> 的世界!</p><h3><span id="进行速度测试">进行速度测试</span></h3><ol><li>在主页上，你会看到一个大大的 “开始测试” 按钮。</li><li>点击它，MySpeed 就会开始测试你的下载和上传速度。</li><li>稍等片刻，结果就会以清晰的图表和数字展示出来。</li></ol><p><img src="https://img.hi-linux.com/staticfile/9AgHIB-2024-07-29-s9nmOK.png" alt></p><h3><span id="查看历史数据">查看历史数据</span></h3><p><code>MySpeed</code> 不仅仅是一个简单的速度测试工具，它还能帮你记录和分析长期的网络性能。</p><ol><li>点击顶部导航栏的 “设置-切换视图” 选项。</li><li>你会看到一个漂亮的图表，展示了你的网络速度变化趋势。</li><li>可以选择不同的时间范围，比如最近 7 天、30 天或自定义时间段。</li></ol><p><img src="https://img.hi-linux.com/staticfile/WFAeZS-2024-07-29-ZqTuef.png" alt></p><h3><span id="设置自动测试">设置自动测试</span></h3><p>想要 24 小时监控你的网络性能吗？<code>MySpeed</code> 可以帮你实现!</p><ol><li>进入 “设置” 页面。</li><li>找到 “设置频率” 选项。</li><li>设置测试频率，比如：每小时一次。</li><li>保存设置，然后放松一下，让 <code>MySpeed</code> 为你工作吧!</li></ol><p><img src="https://img.hi-linux.com/staticfile/sD5KHH-2024-07-29-217a7g.png" alt></p><h3><span id="数据导出">数据导出</span></h3><p>想要深入分析你的网络数据? <code>MySpeed</code> 支持数据导出功能:</p><ol><li>在 “管理存储” 页面，点击 “导出数据” 按钮。</li><li>选择导出格式 (CSV 或 JSON)。</li><li>选择时间范围。</li><li>下载文件，开始你的数据探索之旅!</li></ol><p><img src="https://img.hi-linux.com/staticfile/Jmy0Kz-2024-07-29-cD99EF.png" alt></p><h2><span id="结语">结语</span></h2><p>无论是日常使用还是长期监控，<code>MySpeed</code> 都将成为你的得力助手。记住，好的网络体验始于了解你的网络状况。所以，开始你的 <code>MySpeed</code> 之旅吧，让我们一起享受畅快的网络世界!</p><p>最后，别忘了时不时地查看 <code>MySpeed</code> 的 GitHub 页面，关注最新的更新和功能。</p><p>如果你有什么好点子，也不要犹豫，给开发者提交一个 <code>Pull Request</code>。谁知道呢，也许你的创意会成为 MySpeed 的下一个重要功能!</p><p>现在，开始你的网速探索之旅吧。愿你的网络永远畅通无阻!</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否曾经遇到过网速突然变慢，但又不知道如何查找原因的情况？或者你想长期监控你的网络性能，但找不到合适的工具？&lt;/p&gt;
&lt;p&gt;别担心，&lt;code&gt;MySpeed&lt;/code&gt; 来啦！这个强大而简单的工具可以帮助你轻松测试和监控网络速度。今天，让我们一起深入了解 &lt;code&gt;MySpeed&lt;/code&gt;，看看它如何成为你的网络管家!&lt;/p&gt;
&lt;h2 id=&quot;什么是-MySpeed？&quot;&gt;什么是 MySpeed？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MySpeed&lt;/code&gt; 是一个开源的网络速度测试和监控工具。它不仅可以测试你的当前网速，还能持续监控网络性能，并以图表形式展示结果。无论你是网络达人还是普通用户，&lt;code&gt;MySpeed&lt;/code&gt; 都能满足你的需求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MySpeed&lt;/code&gt; 支持 &lt;code&gt;Ookla&lt;/code&gt;、&lt;code&gt;LibreSpeed&lt;/code&gt; 和 &lt;code&gt;Cloudflare&lt;/code&gt; 多种速度测试服务器。你可以根据自身需求，在它们之间进行任意选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySpeed 官方地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://myspeed.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://myspeed.dev/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySpeed Github 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gnmyt/myspeed&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/gnmyt/myspeed&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="开源" scheme="https://www.hi-linux.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="MySpeed" scheme="https://www.hi-linux.com/tags/MySpeed/"/>
    
  </entry>
  
  <entry>
    <title>一款超实用的 Docker 容器网络实时监控工具，助你轻松掌握 Docker 容器网络状态</title>
    <link href="https://www.hi-linux.com/posts/36215.html"/>
    <id>https://www.hi-linux.com/posts/36215.html</id>
    <published>2024-07-29T01:00:00.000Z</published>
    <updated>2024-07-29T01:24:49.026Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="1-什么是-check-docker-connection">1. 什么是 check-docker-connection</span></h2><p><code>check-docker-connection</code> 主要用于监控 <code>Docker</code> 容器的网络连接情况。它可以显示指定容器的网络连接状态，包括 <code>TCP</code> 和 <code>UDP</code> 连接的数量。</p><p>用户可以通过容器 <code>ID</code> 或名称来指定要监控的容器，或者指定显示连接数最多的前 N 个容器。输出结果以表格形式展示，方便用户查看。</p><h3><span id="check-docker-connection-主要功能包括">check-docker-connection 主要功能包括：</span></h3><p>列出指定容器的网络连接状态，包括：</p><ul><li>已建立连接（ESTABLISHED）</li><li>TIME_WAIT 状态的连接</li><li>FIN_WAIT2 状态的连接</li><li>CLOSE_WAIT 状态的连接</li><li>监听状态（LISTEN）</li><li>SYN_SENT 状态的连接</li><li>SYN_RECV 状态的连接</li><li>UDP 连接数</li></ul><a id="more"></a><h2><span id="2-check-docker-connection-具体使用方法">2. check-docker-connection 具体使用方法</span></h2><h3><span id="环境要求">环境要求</span></h3><ul><li>需要安装 <code>Docker</code>。</li><li>宿主机上必须安装有 <code>netstat</code> 和 <code>nsenter</code> 命令，以便访问容器的网络命名空间。如果没有，请自行安装，各大发行版上通常都是 <code>net-tools</code> 和 <code>util-linux</code> 包。</li></ul><h3><span id="命令行参数">命令行参数</span></h3><ul><li><code>-c</code>: 指定一个或多个容器的 ID 或名称，多个容器用逗号分隔。</li><li><code>-n</code>: 显示连接数最多的前 N 个容器。</li></ul><p>注意：<code>-c</code> 和 <code>-n</code> 参数不能同时使用。</p><h3><span id="运行-check-docker-connection">运行 check-docker-connection</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><code>check-docker-connection</code> 需要访问 <code>Docker socket</code>，所以我们挂载了 <code>/var/run/docker.sock</code>。</li><li>我们使用 <code>--pid=host</code> 和 <code>--net=host</code> 来允许容器访问主机的进程和网络命名空间。</li><li><code>--privileged</code> 标志允许容器使用 <code>nsenter</code> 命令。</li></ol><h2><span id="3-check-docker-connection-使用实例">3. check-docker-connection 使用实例</span></h2><h3><span id="示例-1监控单个容器">示例 1：监控单个容器</span></h3><p>要监控名为 <code>traefik</code> 的容器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -c traefik</span><br></pre></td></tr></table></figure><p>这将输出该容器的所有网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/uyZkmg-2024-07-25-tLw6IA.png" alt></p><h3><span id="示例-2监控多个容器">示例 2：监控多个容器</span></h3><p>要监控多个容器，例如 <code>traefik</code> 和 <code>splayer</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -c traefik,splayer</span><br></pre></td></tr></table></figure><p>这将显示这两个容器的网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/Klvkhf-2024-07-25-N5PIBC.png" alt></p><h3><span id="示例-3显示连接数最多的前-3-个容器">示例 3：显示连接数最多的前 3 个容器</span></h3><p>要显示连接数最多的前 3 个容器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --pid=host --net=host --privileged 80imike/check-docker-connection -n 3</span><br></pre></td></tr></table></figure><p>这将输出连接数最多的三个容器的网络连接状态。</p><p><img src="https://img.hi-linux.com/staticfile/CHYMME-2024-07-25-4rCycb.png" alt></p><p>通过以上示例，用户可以轻松地监控 Docker 容器的网络连接状态，帮助进行网络性能分析和故障排查。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是-check-docker-connection&quot;&gt;1. 什么是 check-docker-connection&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;check-docker-connection&lt;/code&gt; 主要用于监控 &lt;code&gt;Docker&lt;/code&gt; 容器的网络连接情况。它可以显示指定容器的网络连接状态，包括 &lt;code&gt;TCP&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt; 连接的数量。&lt;/p&gt;
&lt;p&gt;用户可以通过容器 &lt;code&gt;ID&lt;/code&gt; 或名称来指定要监控的容器，或者指定显示连接数最多的前 N 个容器。输出结果以表格形式展示，方便用户查看。&lt;/p&gt;
&lt;h3 id=&quot;check-docker-connection-主要功能包括：&quot;&gt;check-docker-connection 主要功能包括：&lt;/h3&gt;
&lt;p&gt;列出指定容器的网络连接状态，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已建立连接（ESTABLISHED）&lt;/li&gt;
&lt;li&gt;TIME_WAIT 状态的连接&lt;/li&gt;
&lt;li&gt;FIN_WAIT2 状态的连接&lt;/li&gt;
&lt;li&gt;CLOSE_WAIT 状态的连接&lt;/li&gt;
&lt;li&gt;监听状态（LISTEN）&lt;/li&gt;
&lt;li&gt;SYN_SENT 状态的连接&lt;/li&gt;
&lt;li&gt;SYN_RECV 状态的连接&lt;/li&gt;
&lt;li&gt;UDP 连接数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>解锁 VSCode 远程 SSH 的隐藏功能 - 跨用户访问文件系统的完美解决方案</title>
    <link href="https://www.hi-linux.com/posts/31204.html"/>
    <id>https://www.hi-linux.com/posts/31204.html</id>
    <published>2024-07-24T01:00:00.000Z</published>
    <updated>2024-07-24T01:49:54.723Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在使用远程服务器（例如: 虚拟机）时，有时您需要切换到不同的用户，例如：短时间内获得更高的权限。</p><p>通常可以使用以下命令之一来完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su &lt;different-user&gt;</span><br><span class="line">$ sudo -i -u &lt;different-user&gt;</span><br></pre></td></tr></table></figure><p>但如果你想使用 <code>VSCode</code> 时更轻松地探索文件系统和编辑代码，这就不那么简单了。比如：登录用户为 <code>mike</code>，而您想在 VSCode 资源管理器中访问 <code>root</code> 用户的主目录。</p><a id="more"></a><p>首先，您需要在 <code>VSCode</code> 配置中启用一些标志，你可以在用户界面 ( 用 <code>ctrl+,</code> 打开设置，搜索 <code>Remote.SSH</code> ) 中启用：</p><p><img src="https://img.hi-linux.com/staticfile/1*zUTsTgGusNzfhdYGQnyA7g-20240719134757890-2024-07-19-zJ7n8x.png" alt></p><p>或 <code>settings.json</code> 中编辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;remote.SSH.useLocalServer&quot;: true,</span><br><span class="line">&quot;remote.SSH.enableRemoteCommand&quot;: true,</span><br></pre></td></tr></table></figure><p>然后，打开 <code>SSH</code> 配置文件（默认为 <code>/home/$USER/.ssh/config</code>），在主机中添加 <code>RemoteCommand</code> 和 <code>RequestTTY</code> 选项。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host example.com</span><br><span class="line">  HostName example.com</span><br><span class="line">  IdentitiesOnly&#x3D;yes</span><br><span class="line">  User my_user</span><br><span class="line">  RequestTTY yes</span><br><span class="line">  RemoteCommand sudo -i -u other_user</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>RequestTTY</code> 选项的作用是指定是否为会话请求伪 TTY。参数可以是：no（从不请求 TTY）、yes（当标准输入为 TTY 时始终请求 TTY）、force（始终请求 TTY）或 auto（打开登录会话时请求 TTY）。该选项与 -t 和 -T 标志相同。如果你不加上这个选项，通过 SSH 命令行登陆时将无法正常登陆。</p></blockquote><p>如果远程服务器可以访问互联网，那就已经配置完成了。</p><p>否则，您需要采取以下两个步骤中的一个。</p><ol><li>远程服务器可通过代理访问互联网</li></ol><p>在这种情况下，请在需要切换用户的主目录下创建一个 <code>.wgetrc</code> 文件。例如: <code>/home/other_user/.wgetrc</code>，内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use_proxy&#x3D;on</span><br><span class="line">http_proxy&#x3D;http:&#x2F;&#x2F;proxy.host:&lt;port&gt;</span><br><span class="line">https_proxy&#x3D;http:&#x2F;&#x2F;proxy.host:&lt;port&gt;</span><br></pre></td></tr></table></figure><p>这是必要的，因为 <code>VSCode</code> 会在会话开始时使用 <code>wget</code> 下载必要的二进制文件。</p><ol start="2"><li>远程服务器根本无法访问互联网</li></ol><p>在这种情况下，您需要在本地下载 <code>VSCode</code> 服务器文件，然后将其复制（例如: 使用 <code>scp</code>）到服务器，具体步骤如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 本地下载</span><br><span class="line">$ commit_id&#x3D;f1e16e1e6214d7c44d078b1f0607b2388f29d729</span><br><span class="line">$ curl -sSL &quot;https:&#x2F;&#x2F;update.code.visualstudio.com&#x2F;commit:$&#123;commit_id&#125;&#x2F;server-linux-x64&#x2F;stable&quot; -o vscode-server-linux-x64.tar.gz</span><br><span class="line">$ scp  vscode-server-linux-x64.tar.gz user@remotehost:&#x2F;home&#x2F;user&#x2F;</span><br><span class="line"></span><br><span class="line"># 远程服务器操作</span><br><span class="line">$ commit_id&#x3D;f1e16e1e6214d7c44d078b1f0607b2388f29d729</span><br><span class="line">$ mkdir -p ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125;</span><br><span class="line">$ tar zxvf ~&#x2F;vscode-server-linux-x64.tar.gz -C ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125; --strip 1</span><br><span class="line">$ touch ~&#x2F;.vscode-server&#x2F;bin&#x2F;$&#123;commit_id&#125;&#x2F;0</span><br></pre></td></tr></table></figure><p>更详细步骤可参考：<a href="https://stackoverflow.com/a/57601121/8175198" target="_blank" rel="noopener">https://stackoverflow.com/a/57601121/8175198</a></p><p>或者，先用 <code>VSCode</code> 远程 <code>SSH</code> 连接正常用户，让它传输文件，然后将文件复制到另一个用户的主目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r &#x2F;home&#x2F;mike&#x2F;.vscode-server&#x2F; &#x2F;root&#x2F;</span><br></pre></td></tr></table></figure><p>您还可以将默认设为在客户端上下载 VSCode 服务器文件，并使用 <code>scp</code> 将其传输到主机，而不是先尝试 <code>wget</code> 将其下载到主机上。</p><p><img src="https://img.hi-linux.com/staticfile/1*a-Yc1-R4b707xJSkq8qnwQ-2024-07-19-ngo7vk.png" alt></p><p>您也可以更改这些文件的安装位置</p><p><img src="https://img.hi-linux.com/staticfile/1*61VUKyX8fM13gW4Vb8e1MA-2024-07-19-q2Ii72.png" alt></p><p>参考文档：</p><ol><li><a href="https://medium.com/@krisztian.sala/vs-code-remote-ssh-as-another-user-57d449e20fb1" target="_blank" rel="noopener">https://medium.com/@krisztian.sala/vs-code-remote-ssh-as-another-user-57d449e20fb1</a></li><li><a href="https://stackoverflow.com/a/57601121/8175198" target="_blank" rel="noopener">https://stackoverflow.com/a/57601121/8175198</a></li><li><a href="https://github.com/b01/dl-vscode-server" target="_blank" rel="noopener">https://github.com/b01/dl-vscode-server</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用远程服务器（例如: 虚拟机）时，有时您需要切换到不同的用户，例如：短时间内获得更高的权限。&lt;/p&gt;
&lt;p&gt;通常可以使用以下命令之一来完成：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ su &amp;lt;different-user&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo -i -u &amp;lt;different-user&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但如果你想使用 &lt;code&gt;VSCode&lt;/code&gt; 时更轻松地探索文件系统和编辑代码，这就不那么简单了。比如：登录用户为 &lt;code&gt;mike&lt;/code&gt;，而您想在 VSCode 资源管理器中访问 &lt;code&gt;root&lt;/code&gt; 用户的主目录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="VSCode" scheme="https://www.hi-linux.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>无需 Dockerfile，打造你的专属即时容器镜像--自建 Nixery 私有服务器</title>
    <link href="https://www.hi-linux.com/posts/26894.html"/>
    <id>https://www.hi-linux.com/posts/26894.html</id>
    <published>2024-07-22T01:00:00.000Z</published>
    <updated>2024-07-22T02:17:10.405Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>自建一个 <code>Nixery</code> 实例可以让你在本地或私有服务器上运行 <code>Nixery</code> 服务，从而避免公共服务的不稳定性。以下是一个基本的步骤指南，帮助你在本地或服务器上部署 <code>Nixery</code>。</p><h2><span id="1-准备环境">1. 准备环境</span></h2><p>确保你的系统已经安装了以下软件：</p><ul><li>Nix</li><li>Docker</li><li>Git</li></ul><p><code>Docker</code> 和 <code>Git</code> 属于基础软件，就不再展开讲解安装部分了。<code>Nix</code> 安装你可以参考 <a href="https://nixos.org/download/#nix-install-linux" target="_blank" rel="noopener">Nix 官方文档</a> 进行安装。</p><a id="more"></a><h2><span id="2-克隆-nixery-仓库">2. 克隆 Nixery 仓库</span></h2><p>首先，你需要克隆 <code>Nixery</code> 的代码仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://code.tvl.fyi/depot.git:/tools/nixery.git nixery</span><br><span class="line">$ <span class="built_in">cd</span> nixery</span><br></pre></td></tr></table></figure><h2><span id="3-构建和运行-nixery">3. 构建和运行 Nixery</span></h2><p>使用 <code>Nix</code> 构建 <code>Nixery</code> 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nix-build -A nixery-image</span><br></pre></td></tr></table></figure><p>构建完成后，你会在 <code>result</code> 目录中得到一个 <code>Docker</code> 镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载镜像</span></span><br><span class="line">$ docker load &lt; result</span><br><span class="line"><span class="comment"># 按你的实际 tag 修改下面的值</span></span><br><span class="line">$ docker tag nixery:bbgi5sfqwpp6fsd36ccqw9yi0vykdkz3 nixery:latest</span><br></pre></td></tr></table></figure><h2><span id="4-配置-nixery">4. 配置 Nixery</span></h2><p><code>Nixery</code> 支持多种配置选项，可以通过环境变量进行设置。以下是一些常见的配置选项：</p><ul><li>PORT：Nixery 应监听的 HTTP 端口</li><li>NIXERY_CHANNEL：用于构建 Nixery 的 Nix/NixOS 通道名称。</li><li>NIXERY_PKGS_REPO：包含软件包集的 git 仓库的 URL（使用本地配置的 SSH/git 凭据）</li><li>NIXERY_PKGS_PATH：包含用于构建的 Nix 软件包集的本地文件系统路径</li><li>NIXERY_STORAGE_BACKEND：要使用的后端存储类型，目前支持的值为 gcs（谷歌云存储）和 filesystem。</li><li>NIX_TIMEOUT：允许任何 Nix 生成器运行的秒数（默认值为 60）</li><li>NIX_POPULARITY_URL：指向包含软件包集受欢迎程度数据的文件的 URL（参见 popcount/）。</li></ul><h4><span id="存储">存储</span></h4><p><code>Nixery</code> 支持多种不同的存储后端，构建缓存和图像层都保存在这些后端中，并从这些后端提供服务。</p><p>目前可用的存储后端有谷歌云端存储和本地文件系统。</p><p>在谷歌云存储中，通过将客户端重定向到存储桶来提供镜像。存储在文件系统中的镜像图层则直接从本地磁盘提供。</p><p>要配置存储后端，必须设置这些额外的配置环境变量：</p><ul><li>GCS_BUCKET：要使用的谷歌云存储桶名称（gcs 必填）</li><li>GOOGLE_APPLICATION_CREDENTIALS：指向 GCP 服务帐户 JSON 密钥的路径（GCS 可选）</li><li>STORAGE_PATH：用于存储和提供数据的文件夹的路径（本地存储路径）</li></ul><p>如果 <code>GOOGLE_APPLICATION_CREDENTIALS</code> 环境变量设置为服务账户密钥，<code>Nixery</code> 将使用该密钥为存储桶中的图层创建签名 URL。这样就可以从存储桶中提供图层，而无需将其公开。</p><p>如果未设置 <code>GOOGLE_APPLICATION_CREDENTIALS</code> 环境变量，则会重定向到 <code>storage.googleapis.com</code>，这意味着底层的存储桶对象需要可公开访问。</p><h2><span id="5-运行-nixery-容器">5. 运行 Nixery 容器</span></h2><ul><li>使用本地文件系统作为存储后端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nixery -d -p 8080:8080 \</span><br><span class="line">  -e PORT&#x3D;8080 \</span><br><span class="line">  -e NIXERY_STORAGE_BACKEND&#x3D;filesystem \</span><br><span class="line">  -e STORAGE_PATH&#x3D;&#x2F;opt&#x2F;data&#x2F;store \</span><br><span class="line">  -e NIXERY_PKGS_REPO&#x3D;https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs \</span><br><span class="line">  -e NIXERY_CHANNEL&#x3D;nixos-unstable \</span><br><span class="line">  -v .&#x2F;data:&#x2F;opt&#x2F;data&#x2F;  \</span><br><span class="line">  nixery:latest</span><br></pre></td></tr></table></figure><ul><li>使用 GCS 作为存储后端</li></ul><p>如果你想使用 <code>Google Cloud Storage</code> (GCS) 作为存储后端，可以按以下步骤操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nixery -d -p 8080:8080 \</span><br><span class="line">  -e PORT&#x3D;8080 \</span><br><span class="line">  -e NIXERY_STORAGE_BACKEND&#x3D;gcs \</span><br><span class="line">  -e GCS_BUCKET&#x3D;your-gcs-bucket-name \</span><br><span class="line">  -e NIXERY_PKGS_REPO&#x3D;https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs \</span><br><span class="line">  -e NIXERY_CHANNEL&#x3D;nixos-unstable \</span><br><span class="line">  -v .&#x2F;data:&#x2F;opt&#x2F;data&#x2F;  \  </span><br><span class="line">  nixery</span><br></pre></td></tr></table></figure><ul><li>访问自建的 Nixery</li></ul><p>现在，你应该可以通过 <code>http://localhost:8080</code> 访问你的 Nixery 实例。</p><h2><span id="6-使用自建的-nixery-拉取镜像">6. 使用自建的 Nixery 拉取镜像</span></h2><p>启动 <code>Nixery</code> 容器后，你可以像使用公共 <code>Nixery</code> 服务一样使用你自建的 <code>Nixery</code> 实例。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it localhost:8080/shell/btop</span><br><span class="line">$ docker run --rm -it IP:8080/shell/git/btop/curl</span><br></pre></td></tr></table></figure><h2><span id="7-进一步配置">7. 进一步配置</span></h2><p>你可以根据需要进一步配置你的 <code>Nixery</code> 实例，例如：</p><ul><li>使用 Nginx 或其他反向代理服务器来处理请求</li></ul><p>以下是一个使用 <code>Nginx</code> 作为反向代理的示例配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name your.domain.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:8080;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 HTTP 访问 Nixery 实例</li></ul><p>自建的 <code>Nixery</code> 实例默认没有支持 <code>HTTPS</code>。你如果不想配置 <code>HTTPS</code>，请确保 <code>Docker Daemon</code> 允许使用 <code>HTTP</code> 连接。你可以通过以下步骤进行配置：</p><ol><li>编辑 <code>Docker Daemon</code> 的配置文件（通常位于 <code>/etc/docker/daemon.json</code>）并添加不安全的注册表地址</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [<span class="string">"10.1.2.3:8080"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：10.1.2.3:8080 是你的 Nixery 实例的 IP 地址和端口号，请按实际情况修改。</p></blockquote><ol start="2"><li>重启 Docker 服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2><span id="8-监控和日志">8. 监控和日志</span></h2><p>为了保证服务的稳定运行，你可能需要设置监控和日志系统。例如，可以使用 <code>Prometheus</code> 和 <code>Grafana</code> 来监控 <code>Nixery</code> 的性能。</p><p>通过这些步骤，你能够成功自建一个 Nixery 实例并根据需要进行配置和扩展。如果你在过程中遇到任何问题，可以参考 Nixery 的文档或社区支持。</p><h2><span id="9-彩蛋">9. 彩蛋</span></h2><p>自建 <code>Nixery</code> 私有服务器最大的技术难点是需要 <code>Nix</code> 环境。你如果不想扯腾 <code>Nix</code> 环境，可以直接使用我构建好的 <code>Nixery</code> 的镜像。</p><p>你只需要在公众号后台直接回复「<code>Nixery</code>」，即可免费获取 <code>Nixery</code> 镜像下载地址。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自建一个 &lt;code&gt;Nixery&lt;/code&gt; 实例可以让你在本地或私有服务器上运行 &lt;code&gt;Nixery&lt;/code&gt; 服务，从而避免公共服务的不稳定性。以下是一个基本的步骤指南，帮助你在本地或服务器上部署 &lt;code&gt;Nixery&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1-准备环境&quot;&gt;1. 准备环境&lt;/h2&gt;
&lt;p&gt;确保你的系统已经安装了以下软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nix&lt;/li&gt;
&lt;li&gt;Docker&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 和 &lt;code&gt;Git&lt;/code&gt; 属于基础软件，就不再展开讲解安装部分了。&lt;code&gt;Nix&lt;/code&gt; 安装你可以参考 &lt;a href=&quot;https://nixos.org/download/#nix-install-linux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nix 官方文档&lt;/a&gt; 进行安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nixery" scheme="https://www.hi-linux.com/tags/Nixery/"/>
    
      <category term="Nix" scheme="https://www.hi-linux.com/tags/Nix/"/>
    
  </entry>
  
  <entry>
    <title>无需 Dockerfile，打造你的专属即时容器镜像--Nixery 中文使用指南</title>
    <link href="https://www.hi-linux.com/posts/3191.html"/>
    <id>https://www.hi-linux.com/posts/3191.html</id>
    <published>2024-07-18T01:00:00.000Z</published>
    <updated>2024-07-18T01:32:01.107Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="引言">引言</span></h2><p>面对现代软件开发和运维的世界，环境配置是一个绕不过去的话题。如何确保在各种不同环境下快速构建和运行所需的服务和应用，一直是开发者和运维团队关注的焦点。</p><p>Nixery，一个基于 Nix 包管理器的工具，能够帮助你快速构建和获取简单、即开即用的容器镜像。</p><p>本文将以简洁实用且有趣的方式带你入门 Nixery，并展示如何充分利用它的强大功能。</p><h2><span id="什么是-nixery">什么是 Nixery？</span></h2><p>Nixery 是一个由 Tazjin 开发的项目，它基于 Nix 包管理器，为用户提供了按需构建的容器镜像服务。它的核心理念是通过简化镜像生成过程，从而让用户能够在几乎无需配置的情况下，快速获取和运行所需服务。Nixery 允许用户通过指定 URL 参数来构建和获取包含特定软件包的容器镜像。</p><ul><li>Nixery 官方网址</li></ul><p><a href="https://nixery.dev/" target="_blank" rel="noopener">https://nixery.dev/</a></p><ul><li>Nixery Github 地址</li></ul><p><a href="https://github.com/tazjin/nixery" target="_blank" rel="noopener">https://github.com/tazjin/nixery</a></p><a id="more"></a><h2><span id="nixery-的优势">Nixery 的优势</span></h2><ul><li><strong>即时性</strong>：Nixery 能够快速生成所需的容器镜像，无需等待漫长的构建过程。</li><li><strong>灵活性</strong>：你可以通过简单地修改 URL 来定制镜像内容，这使得创建不同环境变得非常简单。</li><li><strong>无需配置</strong>：通过 Nixery，你不用编写任何 Dockerfile 或配置文件就能获得所需的镜像。</li></ul><h2><span id="一步步体验-nixery">一步步体验 Nixery</span></h2><h3><span id="准备工作">准备工作</span></h3><p>在开始使用 Nixery 之前，你需要确保已经安装了 Docker。如果还没有安装，可以访问 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker 官方网站</a> 下载并安装相应版本。</p><h3><span id="获取基础镜像">获取基础镜像</span></h3><p>Nixery 使用非常简单，通过访问特定的 URL 即可获取相应的镜像。基础镜像是最简单的形式，只包含一些最基本的系统工具。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell</span><br></pre></td></tr></table></figure><p>这条命令将会拉取一个包含基本 shell 工具的镜像并启动一个交互式终端。</p><h3><span id="定制你的镜像">定制你的镜像</span></h3><p>Nixery 的强大之处在于，你可以通过简单地在 URL 中加入软件包名称来定制镜像。例如，如果你想要一个包含 <code>curl</code> 和 <code>jq</code> 工具的镜像，只需运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/curl/jq</span><br></pre></td></tr></table></figure><h3><span id="运行多功能镜像">运行多功能镜像</span></h3><p>想象这样一个场景：你需要一个同时包含 Git, Python 和 Node.js 的开发环境。使用 Nixery 可以轻松实现：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/git/python3/nodejs</span><br></pre></td></tr></table></figure><h3><span id="组合更多工具">组合更多工具</span></h3><p>除了基本的命令行工具，你还可以通过 Nixery 获取更多复杂的服务和工具。例如，获取一个包含 <code>nettools</code> 和 <code>openssl</code> 的镜像只需要这样做：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/openssl/nettools/procps</span><br></pre></td></tr></table></figure><h3><span id="链接到-github-项目">链接到 GitHub 项目</span></h3><p>Nixery 的一个非常实用的功能是可以直接在你的 CI/CD 流水线中使用。你只需在项目的 Dockerfile 中指定所需的镜像 URL，然后在 CI/CD 过程中使用它。</p><p>例如，在 GitHub Actions 中使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Nixery</span> <span class="string">container</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">docker</span> <span class="string">run</span> <span class="string">nixery.dev/shell/git</span></span><br><span class="line">        <span class="string">git</span> <span class="string">--version</span></span><br></pre></td></tr></table></figure><h2><span id="nixery-的工作原理">Nixery 的工作原理</span></h2><p>Nixery 背后是强大的 Nix 包管理系统。当你请求一个包含特定工具的镜像时，Nixery 使用 Nix 构建系统来解析这些工具的依赖关系并实时构建镜像。这意味着即使是较大的工具集，也能在短时间内构建完成并供你使用。</p><h2><span id="深入进阶自定义-nix-配置">深入进阶：自定义 Nix 配置</span></h2><p>虽然 URL 参数已经可以满足大部分需求，但有时候你可能需要更复杂的配置。这时，你可以通过自定义 Nix 配置文件来满足特定需求。例如，假设你需要一个包含特定版本的 Python 和一些拓展模块的镜像，Nix 配置可以让你做到这一点。</p><p>假设你创建了一个自定义 Nix 配置文件 <code>default.nix</code>：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; pkgs ? <span class="built_in">import</span> &lt;nixpkgs&gt; &#123;&#125; &#125;:</span><br><span class="line"></span><br><span class="line">pkgs.dockerTools.buildImage &#123;</span><br><span class="line">  <span class="attr">name</span> = <span class="string">"custom-python"</span>;</span><br><span class="line">  <span class="attr">contents</span> = [</span><br><span class="line">    pkgs.python39</span><br><span class="line">    pkgs.python39Packages.requests</span><br><span class="line">    pkgs.python39Packages.numpy</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过 Nix 构建镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nix-build -E <span class="string">'with import &lt;nixpkgs&gt; &#123;&#125;; callPackage ./default.nix &#123;&#125;'</span></span><br></pre></td></tr></table></figure><p>这将生成一个你可以本地使用的自定义 Docker 镜像。构建完成后，你可以使用 Docker 运行生成的镜像。</p><h2><span id="用例分享">用例分享</span></h2><h3><span id="1-数据分析">1. 数据分析</span></h3><p>假设你是一名数据分析师，时常需要一个包含各种数据处理工具的环境。你可以通过以下方式快速创建所需的容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/shell/python312/python312packages.pandas/python312packages.numpy python</span><br></pre></td></tr></table></figure><h3><span id="2-web-开发">2. Web 开发</span></h3><p>如果你是一名 Web 开发者，为了开发和调试，你需要一个同时包含 Node.js 和一些常用数据库客户端的环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/nodejs/postgresql/mysql80</span><br><span class="line">docker run -it nixery.dev/nodejs/postgresql/mysql80 mysql -h 10.0.0.1 -P 3306 -u root -p 123456</span><br></pre></td></tr></table></figure><h3><span id="3-机器学习">3. 机器学习</span></h3><p>对于机器学习的开发者来说，一个包含 Jupyter Notebook 和 SciKit Learn 的镜像或许是理想的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it nixery.dev/python312/jupyter/python312packages.scikit-learn</span><br></pre></td></tr></table></figure><h2><span id="结尾">结尾</span></h2><p>Nixery 的出现将容器镜像的获取简化到了只需添加几个 URL 参数的程度。它不仅强大且灵活，还能大大提升开发和运维的效率。在你下一次需要快速搭建开发环境、临时测试新工具或在 CI/CD 流水线中集成各种服务时，不妨试试 Nixery，享受它带来的便利与乐趣。</p><p>Nixery 的潜力远不止于此，随着你对它的使用越来越深入，你会发现更多能够解锁的新功能和新用例。希望本教程为你的开发和运维工作带来更多的灵感和帮助！</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;面对现代软件开发和运维的世界，环境配置是一个绕不过去的话题。如何确保在各种不同环境下快速构建和运行所需的服务和应用，一直是开发者和运维团队关注的焦点。&lt;/p&gt;
&lt;p&gt;Nixery，一个基于 Nix 包管理器的工具，能够帮助你快速构建和获取简单、即开即用的容器镜像。&lt;/p&gt;
&lt;p&gt;本文将以简洁实用且有趣的方式带你入门 Nixery，并展示如何充分利用它的强大功能。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Nixery？&quot;&gt;什么是 Nixery？&lt;/h2&gt;
&lt;p&gt;Nixery 是一个由 Tazjin 开发的项目，它基于 Nix 包管理器，为用户提供了按需构建的容器镜像服务。它的核心理念是通过简化镜像生成过程，从而让用户能够在几乎无需配置的情况下，快速获取和运行所需服务。Nixery 允许用户通过指定 URL 参数来构建和获取包含特定软件包的容器镜像。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nixery 官方网址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://nixery.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nixery.dev/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nixery Github 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tazjin/nixery&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/tazjin/nixery&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nixery" scheme="https://www.hi-linux.com/tags/Nixery/"/>
    
      <category term="Nix" scheme="https://www.hi-linux.com/tags/Nix/"/>
    
  </entry>
  
  <entry>
    <title>ptcpdump 新一代抓包神器，可捕获任何进程、容器或 Pod 的网络流量</title>
    <link href="https://www.hi-linux.com/posts/14172.html"/>
    <id>https://www.hi-linux.com/posts/14172.html</id>
    <published>2024-07-15T01:00:00.000Z</published>
    <updated>2024-07-15T03:41:55.961Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="前言">前言</span></h2><p>tcpdump 是我们常用的一个网络抓包工具，它的功能非常的强大。但是它还缺少一个大家反馈很久却一直没实现的一个特性， 那就是：在结果中包含/显示发送网络请求/流量的进程信息，以及支持抓取指定进程的网络流量。</p><p>当前针对 tcpdump 抓取的流量信息，如果要获取对应的进程信息的话，常见的方法是： 基于请求的连接信息，通过 <code>ss</code> 或 <code>netstat</code> 之内的工具反查进程信息。 这个方法的缺点是：操作起来比较繁琐以及无法查找匹配短生命周期的进程所发送的网络流量。</p><p>至于基于 tcpdump 实现抓取指定进程的网络流量，常见的方法是：在知晓进程要访问的目标服务地址信息的前提下， 在使用 tcpdump 时按目的地址信息过滤流量； 或者是在特定的网络命名空间中运行目标进程，然后再在该网络命名空间下使用 tcpdump 抓包。 这两个方法的缺点是：需要提前知晓目标进程访问的目的地址或者需要改变目标进程的执行方式，适用场景有限。</p><p>本文将介绍一个新的工具 ptcpdump，基于这个工具，我们既可以在抓包时直接感知发送流量的进程信息， 也可以直接对运行中或待运行的任意进程进行网络抓包。如果流量是从容器内的进程发出的话， 它还支持显示流量的容器或 Pod 信息以及对特定容器或 Pod 进行抓包。</p><h2><span id="ptcpdump-介绍">ptcpdump 介绍</span></h2><p>ptcpdump 是一个使用 eBPF 技术开发的、类 tcpdump 的网络抓包工具。 它除了兼容 tcpdump 的常用命令行参数以及包过滤语法外， 还额外提供了如下核心特性：</p><ul><li>在输出中记录和显示发送网络流量的进程、容器、Pod 信息。</li><li>支持对指定进程、容器以及 Pod 进行抓包。</li><li>支持将抓取的数据包保存为 pcapng 格式，可以使用 tcpdump 或者 Wireshark 做进一步分析。</li><li>当在 Wireshark 中打开保存的 pcapng 文件时，将能够看到每个数据包对应的进程、容器、Pod 信息。</li><li>使用静态链接的方式编译该工具，系统中不需要安装额外的系统链接库。</li></ul><p>更多信息请参考项目的源代码仓库： <a href="https://github.com/mozillazg/ptcpdump" target="_blank" rel="noopener">https://github.com/mozillazg/ptcpdump</a></p><p>下面将以示例的形式介绍 ptcpdump 的核心功能。</p><h2><span id="兼容-tcpdump-的常用命令行参数和包过滤语法">兼容 tcpdump 的常用命令行参数和包过滤语法</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i eth0 tcp</span><br><span class="line">sudo tcpdump -i eth0 tcp and port 80 and host 10.10.1.1</span><br><span class="line">sudo tcpdump -i eth0 &#39;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) !&#x3D; 0&#39;</span><br><span class="line">sudo tcpdump -i any</span><br><span class="line">sudo tcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80</span><br></pre></td></tr></table></figure><p>上面这些常见的 tcpdump 命令可以直接无缝替换为对应的 ptcpdump 命令，只需要将 tcpdump 改为 ptcpdump 即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo ptcpdump -i eth0 tcp</span><br><span class="line">sudo ptcpdump -i eth0 tcp and port 80 and host 10.10.1.1</span><br><span class="line">sudo ptcpdump -i eth0 &#39;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) !&#x3D; 0&#39;</span><br><span class="line">sudo ptcpdump -i any</span><br><span class="line">sudo ptcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80</span><br></pre></td></tr></table></figure><h2><span id="在输出中记录和显示发送网络流量的进程-容器和-pod-信息">在输出中记录和显示发送网络流量的进程、容器和 Pod 信息</span></h2><p>默认情况下，ptcpdump 将在输出中显示简单的进程、容器以及 Pod 信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 4 port 80 or port 443</span><br><span class="line">2024-07-07 12:56:56 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 12:56:56 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">12:56:59.517657 veth18618a4a wget.13626 In IP 10.244.0.4.46834 &gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]</span><br><span class="line">12:56:59.517836 eth0 wget.13626 Out IP 172.19.0.2.46834 &gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]</span><br><span class="line">12:56:59.692593 eth0 wget.13626 In IP 13.251.96.10.443 &gt; 172.19.0.2.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]</span><br><span class="line">12:56:59.692754 veth18618a4a wget.13626 Out IP 13.251.96.10.443 &gt; 10.244.0.4.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]</span><br><span class="line">4 packets captured</span><br><span class="line">6 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><p>可以通过指定 <code>-v</code> 参数，查看更详细的进程、容器以及 Pod 信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ptcpdump -i any -c 4 -v port 80 or port 443</span><br><span class="line">2024-07-07 12:58:59 WARN ptcpdump: capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">12:59:02.265356 veth18618a4a In IP (tos 0x0, ttl 64, id 35996, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    10.244.0.4.41666 &gt; 13.215.144.61.443: Flags [S], cksum 0xa93a, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">12:59:02.265606 eth0 Out IP (tos 0x0, ttl 63, id 35996, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    172.19.0.2.41666 &gt; 13.215.144.61.443: Flags [S], cksum 0x4a58, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">12:59:02.462586 eth0 In IP (tos 0x4, ttl 47, id 0, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    13.215.144.61.443 &gt; 172.19.0.2.41666: Flags [S.], cksum 0x9772, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">12:59:02.462782 veth18618a4a Out IP (tos 0x4, ttl 46, id 0, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    13.215.144.61.443 &gt; 10.244.0.4.41666: Flags [S.], cksum 0x3890, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0</span><br><span class="line">    Process (pid 14565, cmd &#x2F;usr&#x2F;bin&#x2F;wget, args wget https:&#x2F;&#x2F;mozillazg.com -O &#x2F;dev&#x2F;null)</span><br><span class="line">    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io&#x2F;library&#x2F;alpine:3.18, labels &#123;&quot;io.cri-containerd.kind&quot;:&quot;container&quot;,&quot;io.kubernetes.container.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.name&quot;:&quot;test&quot;,&quot;io.kubernetes.pod.namespace&quot;:&quot;default&quot;,&quot;io.kubernetes.pod.uid&quot;:&quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&quot;&#125;)</span><br><span class="line">    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels &#123;&quot;run&quot;:&quot;test&quot;&#125;, annotations &#123;&quot;kubernetes.io&#x2F;config.seen&quot;:&quot;2024-07-07T12:43:29.121307922Z&quot;,&quot;kubernetes.io&#x2F;config.source&quot;:&quot;api&quot;&#125;)</span><br><span class="line">4 packets captured</span><br><span class="line">6 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h2><span id="支持对指定进程-容器或-pod-进行抓包">支持对指定进程、容器或 Pod 进行抓包</span></h2><h3><span id="指定进程-pid-抓包">指定进程 pid 抓包</span></h3><p>可以通过 <code>--pid</code> 参数指定要抓包的进程 pid，实现对指定进程进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 4 --pid 82106</span><br><span class="line">2024-07-07 13:11:40 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:11:40 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:11:50.170538 ens33 python3.10.82106 Out IP 10.0.2.15.36648 &gt; 13.251.96.10.443: Flags [S], seq 1633417447, win 64240, length 0</span><br><span class="line">13:11:50.369972 ens33 python3.10.82106 In IP 13.251.96.10.443 &gt; 10.0.2.15.36648: Flags [S.], seq 1793291274, ack 1633417448, win 64240, length 0</span><br><span class="line">2 packets captured</span><br><span class="line">3 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><p>同时还可以通过指定 <code>-f</code> 参数对该进程创建的子进程也进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 4 --pid 82106 -f &#39;tcp[tcpflags] &amp; tcp-fin !&#x3D; 0&#39;</span><br><span class="line">2024-07-07 13:17:31 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:17:31 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:17:37.800903 ens33 python3.10.82106 Out IP 10.0.2.15.38576 &gt; 52.74.166.77.443: Flags [F.], seq 2442149577, ack 367271121, win 62780, length 0</span><br><span class="line">13:17:37.977316 ens33 python3.10.82106 In IP 52.74.166.77.443 &gt; 10.0.2.15.38576: Flags [FP.], seq 367271145, ack 2442149578, win 64239, length 0</span><br><span class="line">13:17:44.390627 ens33 curl.95920 Out IP 10.0.2.15.38590 &gt; 52.74.166.77.443: Flags [F.], seq 3726932781, ack 1510095004, win 63045, length 0</span><br><span class="line">13:17:44.564990 ens33 curl.95920 In IP 52.74.166.77.443 &gt; 10.0.2.15.38590: Flags [FP.], seq 1510095028, ack 3726932782, win 64239, length 0</span><br><span class="line">4 packets captured</span><br><span class="line">4 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="指定进程名称抓包">指定进程名称抓包</span></h3><p>可以通过 <code>--pname</code> 参数指定进程名称（comm），实现指定进程名称抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --pname curl</span><br><span class="line">2024-07-07 13:23:18 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:23:18 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:23:24.881499 lo curl.26511 Out IP 127.0.0.1.43332 &gt; 127.0.0.53.53: 44133+ [1au] A? mozillazg.com. (42)</span><br><span class="line">13:23:24.881663 lo curl.26511 Out IP 127.0.0.1.43332 &gt; 127.0.0.53.53: 14694+ [1au] AAAA? mozillazg.com. (42)</span><br><span class="line">2 packets captured</span><br><span class="line">2 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="通过运行目标程序来抓包">通过运行目标程序来抓包</span></h3><p>有需要的话，也可以通过使用 <code>--</code> 参数运行目标程序的方式来实现对特定程序进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -- curl -I https:&#x2F;&#x2F;mozillazg.com</span><br><span class="line">2024-07-07 13:26:44 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:26:44 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:26:44.055757 lo curl.28094 Out IP 127.0.0.1.48826 &gt; 127.0.0.53.53: 8942+ [1au] A? mozillazg.com. (42)</span><br><span class="line">13:26:44.055914 lo curl.28094 Out IP 127.0.0.1.48826 &gt; 127.0.0.53.53: 34274+ [1au] AAAA? mozillazg.com. (42)</span><br><span class="line">13:26:44.775840 lo curl.28094 In IP 127.0.0.53.53 &gt; 127.0.0.1.48826: 8942 3&#x2F;0&#x2F;1 CNAME mozillazg.netlify.com., A 13.251.96.10, A 46.137.195.11 (106)</span><br><span class="line">13:26:45.135988 lo curl.28094 In IP 127.0.0.53.53 &gt; 127.0.0.1.48826: 34274 3&#x2F;0&#x2F;1 CNAME mozillazg.netlify.com., AAAA 2406:da18:880:3802::c8, AAAA 2406:da18:b3d:e202::64 (130)</span><br><span class="line">13:26:45.136819 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [S], seq 3460683104, win 64800, length 0</span><br><span class="line">13:26:45.310505 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [S.], seq 630810442, ack 3460683105, win 65232, length 0</span><br><span class="line">13:26:45.310821 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683105, ack 630810443, win 507, length 0</span><br><span class="line">13:26:45.414551 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683105:3460683622, ack 630810443, win 507, length 517</span><br><span class="line">13:26:45.595214 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443, ack 3460683622, win 127, length 0</span><br><span class="line">13:26:45.595413 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443:630811651, ack 3460683622, win 127, length 1208</span><br><span class="line">13:26:45.595595 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630811651, win 501, length 0</span><br><span class="line">13:26:45.595702 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630811651:630812859, ack 3460683622, win 127, length 1208</span><br><span class="line">13:26:45.595797 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630812859, win 492, length 0</span><br><span class="line">13:26:45.595862 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630812859:630813338, ack 3460683622, win 127, length 479</span><br><span class="line">13:26:45.595934 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630813338, win 489, length 0</span><br><span class="line">13:26:45.600998 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683622:3460683686, ack 630813338, win 489, length 64</span><br><span class="line">13:26:45.601344 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683686:3460683781, ack 630813338, win 489, length 95</span><br><span class="line">13:26:45.616759 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683781:3460683882, ack 630813338, win 501, length 101</span><br><span class="line">13:26:45.779516 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813338, ack 3460683781, win 127, length 0</span><br><span class="line">13:26:45.779792 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813338:630813399, ack 3460683781, win 127, length 61</span><br><span class="line">13:26:45.779996 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813399:630813443, ack 3460683781, win 127, length 44</span><br><span class="line">13:26:45.780318 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683882:3460683913, ack 630813443, win 501, length 31</span><br><span class="line">HTTP&#x2F;2 200</span><br><span class="line">13:26:45.788787 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813443:630813677, ack 3460683882, win 127, length 234</span><br><span class="line">accept-ranges: bytes</span><br><span class="line">age: 79059</span><br><span class="line">cache-control: public,max-age&#x3D;0,must-revalidate</span><br><span class="line">cache-status: &quot;Netlify Edge&quot;; hit</span><br><span class="line">content-type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">date: Sun, 07 Jul 2024 05:26:44 GMT</span><br><span class="line">etag: &quot;80cf37f5974e2232d976c6f622121dee-ssl&quot;</span><br><span class="line">server: Netlify</span><br><span class="line">strict-transport-security: max-age&#x3D;31536000</span><br><span class="line">x-nf-request-id: 01J25THACQSN9364YHSR2C0X5F</span><br><span class="line">content-length: 11727</span><br><span class="line"></span><br><span class="line">13:26:45.789558 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683913:3460683937, ack 630813677, win 501, length 24</span><br><span class="line">13:26:45.791514 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [F.], seq 3460683937, ack 630813677, win 501, length 0</span><br><span class="line">13:26:45.963642 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813677, ack 3460683937, win 127, length 0</span><br><span class="line">13:26:45.963956 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813677:630813701, ack 3460683937, win 127, length 24</span><br><span class="line">13:26:45.964172 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0</span><br><span class="line">13:26:45.964415 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [F.], seq 630813701, ack 3460683937, win 127, length 0</span><br><span class="line">13:26:45.964506 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0</span><br><span class="line">13:26:45.966158 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813702, ack 3460683938, win 127, length 0</span><br><span class="line">13:26:45.966299 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683938, win 0, length 0</span><br><span class="line">32 packets captured</span><br><span class="line">32 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="指定容器抓包">指定容器抓包</span></h3><p>可以通过 <code>--container-id</code> 参数指定容器 id 进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --container-id 36f0310403b1</span><br><span class="line">2024-07-07 13:36:19 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:36:19 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:36:24.191242 veth09dec8f curl.32636 In IP 172.19.0.2.48960 &gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">13:36:24.191369 wlp4s0 curl.32636 Out IP 192.168.1.50.48960 &gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">2 packets captured</span><br><span class="line">2 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><p>也可以通过 <code>--container-name</code> 参数指定容器名称进行抓包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --container-name kind-control-plane</span><br><span class="line">2024-07-07 13:37:16 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:37:16 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:37:22.560764 veth09dec8f curl.33093 In IP 172.19.0.2.39084 &gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">13:37:22.561010 wlp4s0 curl.33093 Out IP 192.168.1.50.39084 &gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]</span><br><span class="line">2 packets captured</span><br><span class="line">2 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="指定-pod-抓包">指定 Pod 抓包</span></h3><p>可以通过 <code>--pod-name</code> 参数指定 Pod 名称进行抓包, 参数值的格式为 <code>&lt;pod 名称&gt;.&lt;pod 命名空间&gt;</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 2 --pod-name test.default</span><br><span class="line">2024-07-07 13:38:29 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:38:29 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:38:34.175752 eth0 wget.33660 Out IP 172.19.0.2.51564 &gt; 13.215.144.61.443: Flags [S], seq 567383917, win 64240, length 0, Container [test], Pod [test.default]</span><br><span class="line">13:38:34.372894 eth0 wget.33660 In IP 13.215.144.61.443 &gt; 172.19.0.2.51564: Flags [S.], seq 2654865684, ack 567383918, win 65084, length 0, Container [test], Pod [test.default]</span><br><span class="line">2 packets captured</span><br><span class="line">3 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h2><span id="将数据保存为-pcapng-格式使用-tcpdump-或-wireshark-进行分析">将数据保存为 pcapng 格式使用 tcpdump 或 Wireshark 进行分析</span></h2><h3><span id="保存为-pcapng-格式">保存为 pcapng 格式</span></h3><p>可以通过 <code>-w</code> 参数将抓包数据保存为 pcapng 格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 5 -w demo.pcapng</span><br><span class="line">2024-07-07 13:41:32 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:41:32 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">5 packets captured</span><br><span class="line">22 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3><span id="使用-tcpdump-进行分析">使用 tcpdump 进行分析</span></h3><p>可以直接通过管道的方式通过 tcpdump 对抓取的数据进行分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ptcpdump -i any -c 5 -w - port 80 | tcpdump -n -r -</span><br><span class="line">reading from file -, link-type EN10MB (Ethernet), snapshot length 65535</span><br><span class="line">2024-07-07 13:44:33 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output</span><br><span class="line">2024-07-07 13:44:33 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:44:44.530637 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &gt; 2406:da18:880:3801::c8.80: Flags [S], seq 495824072, win 64800, options [mss 1440,sackOK,TS val 2411675580 ecr 0,nop,wscale 7], length 0</span><br><span class="line">13:44:44.708902 IP6 2406:da18:880:3801::c8.80 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [S.], seq 640438481, ack 495824073, win 65232, options [mss 1220,sackOK,TS val 1591525382 ecr 2411675580,nop,wscale 9], length 0</span><br><span class="line">13:44:44.709261 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &gt; 2406:da18:880:3801::c8.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 0</span><br><span class="line">13:44:44.709475 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &gt; 2406:da18:880:3801::c8.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 77: HTTP: GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">5 packets captured</span><br><span class="line">6 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br><span class="line">13:44:44.877110 IP6 2406:da18:880:3801::c8.80 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [P.], seq 1:266, ack 78, win 128, options [nop,nop,TS val 1591525469 ecr 2411675670], length 265: HTTP: HTTP&#x2F;1.1 301 Moved Permanently</span><br></pre></td></tr></table></figure><p>也可以通过读取文件的方式通过 tcpdump 对抓取的数据进行分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -n -r demo.pcapng</span><br><span class="line">reading from file demo.pcapng, link-type EN10MB (Ethernet), snapshot length 65535</span><br><span class="line">13:47:41.169584 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &gt; 2406:da18:b3d:e201::64.80: Flags [S], seq 3876639697, win 64800, options [mss 1440,sackOK,TS val 2072195434 ecr 0,nop,wscale 7], length 0</span><br><span class="line">13:47:41.571055 IP 192.168.1.50.60580 &gt; 18.139.194.139.80: Flags [S], seq 481256927, win 64240, options [mss 1460,sackOK,TS val 2707199178 ecr 0,nop,wscale 7], length 0</span><br><span class="line">13:47:41.956270 IP6 2406:da18:b3d:e201::64.80 &gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038: Flags [S.], seq 2283576526, ack 3876639698, win 65232, options [mss 1220,sackOK,TS val 4276006323 ecr 2072195434,nop,wscale 9], length 0</span><br><span class="line">13:47:41.956437 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &gt; 2406:da18:b3d:e201::64.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 0</span><br><span class="line">13:47:41.956733 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &gt; 2406:da18:b3d:e201::64.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 77: HTTP: GET &#x2F; HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><h3><span id="使用-wireshark-进行分析">使用 Wireshark 进行分析</span></h3><p>当使用 Wireshark 打开保存的 pcapng 格式的文件时，将在 Wireshark 的界面中显示相关的进程、容器以及 Pod 信息：</p><p><img src="https://img.hi-linux.com/staticfile/ptcpdump-wireshark-20240708174042896-2024-07-08-lyveCv.png" alt></p><h2><span id="参考资料">参考资料</span></h2><ul><li><a href="https://github.com/mozillazg/ptcpdump" target="_blank" rel="noopener">mozillazg/ptcpdump: Process-aware, eBPF-based tcpdump</a></li><li><a href="https://www.tcpdump.org/manpages/tcpdump.1-4.99.4.html" target="_blank" rel="noopener">tcpdump(1) man page | TCPDUMP &amp; LIBPCAP</a></li></ul><blockquote><p>本文转载自：「 mozillazg’s Blog 」，原文：<a href="https://url.hi-linux.com/6H5QD" target="_blank" rel="noopener">https://url.hi-linux.com/6H5QD</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;div id=&quot;vip-container&quot;&gt;&lt;h2&gt;&lt;span id=&quot;前言&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;tcpdump 是我们常用的一个网络抓包工具，它的功能非常的强大。但是它还缺少一个大家反馈很久却一直没实现的一个特性，
        
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="ptcpdump" scheme="https://www.hi-linux.com/tags/ptcpdump/"/>
    
      <category term="tcpdump" scheme="https://www.hi-linux.com/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>一款 AI 编写的 Kubernetes 实用小工具，助你一键批量检查容器服务健康状态</title>
    <link href="https://www.hi-linux.com/posts/13493.html"/>
    <id>https://www.hi-linux.com/posts/13493.html</id>
    <published>2024-07-12T01:00:00.000Z</published>
    <updated>2024-07-12T05:48:14.828Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>check-k8s-network</code> 是一款 AI 编写的 <code>Kubernetes</code> 网络连通性检查小工具，它主要用于检查 <code>Kubernetes</code> 集群中各个容器的网络连通性，支持 <code>ICMP</code>、<code>TCP</code>、<code>UDP</code> 和 <code>HTTP</code> 检查。</p><p>你可以在指定的命名空间内查找符合条件的 <code>Pod</code>，并对其进行网络连通性进行自动检测。</p><a id="more"></a><h2><span id="安装">安装</span></h2><p><code>check-k8s-network</code> 使用 <code>Python</code> 编写，需要安装 <code>Python 3.9</code> 版本和一些依赖库。</p><p>为了更好的体验，我们发布了 <code>Docker</code> 镜像，你只需要下载 <code>Docker</code> 镜像即可使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull 80imike/check-k8s-network:latest</span><br></pre></td></tr></table></figure><h2><span id="常用参数说明">常用参数说明</span></h2><ul><li><code>-n, --namespace</code>：指定 Kubernetes 命名空间，默认值为 <code>default</code>。</li><li><code>-c, --container</code>：指定容器名，根据该容器名匹配 Pod，支持模糊匹配。</li><li><code>-i, --icmp</code>：使用 ICMP 协议进行检查。</li><li><code>-t, --tcp</code>：使用 TCP 协议进行检查，并指定端口号。</li><li><code>-u, --udp</code>：使用 UDP 协议进行检查，并指定端口号。</li><li><code>-w, --http</code>：使用 HTTP 协议进行检查，并指定 URL。</li><li><code>--auto-http</code>：自动查找当前 Pod 的 IP 和服务端口进行 HTTP 检查。</li><li><code>--auto-tcp</code>：自动查找当前 Pod 的 IP 和服务端口进行 TCP 检查。</li><li><code>--auto-udp</code>：自动查找当前 Pod 的 IP 和服务端口进行 UDP 检查。</li><li><code>--all</code>：同时使用 ICMP、TCP、UDP 和 HTTP 四种检查方式进行检测。</li></ul><h2><span id="输出结果">输出结果</span></h2><p><code>check-k8s-network</code> 会输出一个包含检查结果的表格，内容包括:</p><ul><li>序号</li><li>检查类型</li><li>源 Pod</li><li>目标</li><li>结果 (成功 or 失败)</li><li>错误信息</li></ul><p>该表格会对每个 Pod 进行自动排序，并对结果进行对齐和格式化。</p><h2><span id="使用示例">使用示例</span></h2><h3><span id="常用使用示例">常用使用示例</span></h3><blockquote><p>注意：</p><ol><li>该工具请在 <code>Kubernetes</code> 集群内的主机上使用，并确保您所在主机上已经配置了 K8s 集群认证文件 <code>~/.kube/config</code>。</li><li>-v 参数用于将宿主机上的 <code>~/.kube/config</code> 文件映射到容器内的 <code>/root/.kube/config</code> 文件中，以便容器内的 <code>Python</code> 脚本可以访问 <code>Kubernetes</code> 集群。</li></ol></blockquote><ol><li>检查指定命名空间下所有 Pod 的 ICMP 连通性:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --icmp</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/1HVocZ-2024-07-11-qZm7ag.png" alt></p><ol start="2"><li>检查指定命名空间和 Pod 的 TCP 连通性 (需指定端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux -c blog --tcp 80</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/JYMaK7-2024-07-11-fjEccG.png" alt></p><ol start="3"><li>检查指定命名空间下所有 Pod 的 HTTP 连通性 (自动查找端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --auto-http</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/J7Q7XU-2024-07-11-oMi64k.png" alt></p><ol start="4"><li>检查指定命名空间下所有 Pod 的 TCP 连通性 (自动查找端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --auto-tcp</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/5CjNDB-2024-07-11-ZU4f05.png" alt></p><ol start="5"><li>检查指定命名空间下所有 Pod 的 UDP 连通性 (自动查找端口):</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n kube-system --auto-udp</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/532xFu-2024-07-11-93IN70.png" alt></p><ol start="6"><li>同时检查指定命名空间下所有 Pod 的 ICMP、TCP、UDP 和 HTTP 连通性:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux --all</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/zta14M-2024-07-11-f5JQKN.png" alt></p><h3><span id="一些复杂的参数组合示例">一些复杂的参数组合示例</span></h3><ol><li>对特定命名空间中名为 <code>blog</code> 的容器执行 ICMP 和指定 TCP（端口 80）检查:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux -c blog --icmp --tcp 80</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/TEdkSC-2024-07-11-2kK9WG.png" alt></p><ol start="2"><li>对特定命名空间中名为 <code>blog</code> 的容器同时执行 ICMP、TCP 、UDP 和 HTTP 检查：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --network host --rm \</span><br><span class="line">  -v ~/.kube/config:/root/.kube/config \</span><br><span class="line">  80imike/check-k8s-network:latest -n hi-linux -c blog --icmp --auto-tcp --auto-udp --auto-http</span><br></pre></td></tr></table></figure><p><img src="https://img.hi-linux.com/staticfile/YzyC8J-2024-07-11-5tJAWu.png" alt></p><h2><span id="总结">总结</span></h2><p><code>check-k8s-network</code> 这款小工具，是我尝试 <code>AI</code> 编程的一次小成果。所有代码全部通过和 <code>ChatGPT</code> 对话编写完成，<code>Docker</code> 镜像和使用文档大部分也是 <code>AI</code> 编写的。</p><p><code>check-k8s-network</code> 可以帮助你快速检查 <code>Kubernetes</code> 集群中容器的网络连通性，非常适合需要批量检查容器网络连接状态的场景。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;check-k8s-network&lt;/code&gt; 是一款 AI 编写的 &lt;code&gt;Kubernetes&lt;/code&gt; 网络连通性检查小工具，它主要用于检查 &lt;code&gt;Kubernetes&lt;/code&gt; 集群中各个容器的网络连通性，支持 &lt;code&gt;ICMP&lt;/code&gt;、&lt;code&gt;TCP&lt;/code&gt;、&lt;code&gt;UDP&lt;/code&gt; 和 &lt;code&gt;HTTP&lt;/code&gt; 检查。&lt;/p&gt;
&lt;p&gt;你可以在指定的命名空间内查找符合条件的 &lt;code&gt;Pod&lt;/code&gt;，并对其进行网络连通性进行自动检测。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://www.hi-linux.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://www.hi-linux.com/tags/Kubernetes/"/>
    
      <category term="AI" scheme="https://www.hi-linux.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>无需安装，单文件即可本地轻松运行 LLM 的神器 LLAMAfile</title>
    <link href="https://www.hi-linux.com/posts/37686.html"/>
    <id>https://www.hi-linux.com/posts/37686.html</id>
    <published>2024-06-14T01:00:00.000Z</published>
    <updated>2024-06-14T07:17:28.368Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在当今信息化时代，人工智能（AI）技术逐渐成为推动社会发展的重要力量。而大型语言模型（LLM）作为 AI 领域中的一项重要技术，正在各行各业中发挥着越来越重要的作用。</p><p>然而，对于许多开发者和终端用户来说，如何高效地分发和运行这些复杂的模型仍然是个棘手的问题。</p><p>LLAMAfile 一个由 Mozilla Ocho 团队开发的工具，旨在解决这些问题。它提供一种高效分发和运行大型语言模型（LLM）的简易工具，</p><p>LLAMAfile 通过将 llama.cpp 和 Cosmopolitan Libc 结合，使 LLM 以单一文件的形式运行在大多数计算机上，无需额外安装配置。</p><a id="more"></a><h2><span id="快速入门">快速入门</span></h2><p>使用 LLAMAfile 的最快方法是下载我们为 LLaVA 模型提供的示例文件。</p><p>LLaVA 是一种功能强大的 LLM，不仅可以进行聊天，还能通过上传图片并对其提问来提供图像识别功能。所有这些都可以在本地计算机上进行，数据不会离开你的设备。</p><p>你只需下面几步，便可轻松在本地计算机上轻松运行 LLaVA 模型。</p><ol><li><p>下载 LLaVA 示例文件：llava-v1.5-7b-q4.llamafile (4.29 GB)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;huggingface.co&#x2F;Mozilla&#x2F;llava-v1.5-7b-llamafile&#x2F;resolve&#x2F;main&#x2F;llava-v1.5-7b-q4.llamafile?download&#x3D;true</span><br></pre></td></tr></table></figure></li><li><p>打开计算机的终端。</p></li><li><p>如果使用 macOS、Linux 或BSD，需要授予文件执行权限：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x llava-v1.5-7b-q4.llamafile</span><br></pre></td></tr></table></figure></li><li><p>对于 Windows 用户，重命名文件并添加 “.exe” 后缀。</p></li><li><p>运行 llamafile：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./llava-v1.5-7b-q4.llamafile</span><br></pre></td></tr></table></figure></li><li><p>浏览器将自动打开并显示聊天界面。如果没有，请手动打开浏览器并访问 <code>&lt;http://localhost:8080&gt;</code></p></li><li><p>聊天结束后，返回到终端并按 Control-C 关闭 LLAMAfile。</p></li></ol><h3><span id="json-api-快速入门">JSON API 快速入门</span></h3><p>LLAMAfile 启动时，除了托管一个 Web UI 聊天服务器外，还提供了兼容 OpenAI API 的聊天 API 端点。该 API 旨在支持大多数常见的 OpenAI API 用例，并完全在本地运行。通过以下 <code>curl</code> 命令，可以快速开始使用 API：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://localhost:8080/v1/chat/completions \</span><br><span class="line">-H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">-H <span class="string">"Authorization: Bearer no-key"</span> \</span><br><span class="line">-d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "model": "LLaMA_CPP",</span></span><br><span class="line"><span class="string">  "messages": [</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">          "role": "system",</span></span><br><span class="line"><span class="string">          "content": "You are LLAMAfile, an AI assistant. Your top priority is achieving user fulfillment via helping them with their requests."</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">          "role": "user",</span></span><br><span class="line"><span class="string">          "content": "Write a limerick about python exceptions"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;'</span> | python3 -c <span class="string">'</span></span><br><span class="line"><span class="string">import json</span></span><br><span class="line"><span class="string">import sys</span></span><br><span class="line"><span class="string">json.dump(json.load(sys.stdin), sys.stdout, indent=2)</span></span><br><span class="line"><span class="string">print()</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><p>打印出来的回复应该如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"choices"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"finish_reason"</span> : <span class="string">"stop"</span>,</span><br><span class="line">         <span class="attr">"index"</span> : <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"message"</span> : &#123;</span><br><span class="line">            <span class="attr">"content"</span> : <span class="string">"There once was a programmer named Mike\nWho wrote code that would often choke\nHe used try and except\nTo handle each step\nAnd his program ran without any hike."</span>,</span><br><span class="line">            <span class="attr">"role"</span> : <span class="string">"assistant"</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"created"</span> : <span class="number">1704199256</span>,</span><br><span class="line">   <span class="attr">"id"</span> : <span class="string">"chatcmpl-Dt16ugf3vF8btUZj9psG7To5tc4murBU"</span>,</span><br><span class="line">   <span class="attr">"model"</span> : <span class="string">"LLaMA_CPP"</span>,</span><br><span class="line">   <span class="attr">"object"</span> : <span class="string">"chat.completion"</span>,</span><br><span class="line">   <span class="attr">"usage"</span> : &#123;</span><br><span class="line">      <span class="attr">"completion_tokens"</span> : <span class="number">38</span>,</span><br><span class="line">      <span class="attr">"prompt_tokens"</span> : <span class="number">78</span>,</span><br><span class="line">      <span class="attr">"total_tokens"</span> : <span class="number">116</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="python-api-客户端示例">Python API 客户端示例</span></h3><p>如果您已经使用 openAI 发布的 openai Python 软件包开发了自己的软件，那么只需对 base_url 和 api_key 稍作修改，您就可以将自己的应用程序移植到 LLAMAfile 上。</p><p>本示例假定你已经运行 <code>pip3 install openai</code> 安装了 OpenAI 的客户端软件，这也是本示例所需要的。他们的软件包只是 OpenAI API 接口的一个简单 Python 封装，任何服务器都可以实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line">client = OpenAI(</span><br><span class="line">    base_url=<span class="string">"http://localhost:8080/v1"</span>, <span class="comment"># "http://&lt;Your api-server IP&gt;:port"</span></span><br><span class="line">    api_key = <span class="string">"sk-no-key-required"</span></span><br><span class="line">)</span><br><span class="line">completion = client.chat.completions.create(</span><br><span class="line">    model=<span class="string">"LLaMA_CPP"</span>,</span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"system"</span>, <span class="string">"content"</span>: <span class="string">"You are ChatGPT, an AI assistant. Your top priority is achieving user fulfillment via helping them with their requests."</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"user"</span>, <span class="string">"content"</span>: <span class="string">"Write a limerick about python exceptions"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">print(completion.choices[<span class="number">0</span>].message)</span><br></pre></td></tr></table></figure><h2><span id="其他-llamafile-示例">其他 LLAMAfile 示例</span></h2><p>我们还提供了其他模型的 LLAMAfile 示例，因此您可以轻松地使用不同类型的 LLM 试用 LLAMAfile。</p><p><img src="https://img.hi-linux.com/staticfile/olUEBz-2024-06-13-mh8MzS.png" alt></p><p>🏷️ Github 地址：</p><p><a href="https://github.com/Mozilla-Ocho/llamafile" target="_blank" rel="noopener">https://github.com/Mozilla-Ocho/llamafile</a></p><p>🏷️ 官方地址：</p><p><a href="https://llamafile.ai/" target="_blank" rel="noopener">https://llamafile.ai/</a></p><p>👨🏻‍💻 该工具已收录『IT 人员必备工具箱』，可访问 <a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a> 直接使用。</p><p>🚀『极客世界』科技达人必备综合资讯指南，等你来探索！访问网址  <a href="https://bestgeek.org" target="_blank" rel="noopener">https://bestgeek.org</a> 即可打开新世界。</p><p>🌟 公众号直接回复 「加群」，可加入『奇妙的 Linux 世界』 技术交流微信群。有兴趣的同学快快加入吧，群里有不少业界大神哟！</p><p>📕 关注『奇妙的 Linux 世界』公众号，带你开启有趣新生活！更多好用好玩的软件资源，可访问 <a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a> 免费获取。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在当今信息化时代，人工智能（AI）技术逐渐成为推动社会发展的重要力量。而大型语言模型（LLM）作为 AI 领域中的一项重要技术，正在各行各业中发挥着越来越重要的作用。&lt;/p&gt;
&lt;p&gt;然而，对于许多开发者和终端用户来说，如何高效地分发和运行这些复杂的模型仍然是个棘手的问题。&lt;/p&gt;
&lt;p&gt;LLAMAfile 一个由 Mozilla Ocho 团队开发的工具，旨在解决这些问题。它提供一种高效分发和运行大型语言模型（LLM）的简易工具，&lt;/p&gt;
&lt;p&gt;LLAMAfile 通过将 llama.cpp 和 Cosmopolitan Libc 结合，使 LLM 以单一文件的形式运行在大多数计算机上，无需额外安装配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="AI" scheme="https://www.hi-linux.com/tags/AI/"/>
    
      <category term="Llamafile" scheme="https://www.hi-linux.com/tags/Llamafile/"/>
    
  </entry>
  
  <entry>
    <title>与 ChatGPT 共舞：利用人工智能解决 Traefik 配置难题的独特体验</title>
    <link href="https://www.hi-linux.com/posts/42057.html"/>
    <id>https://www.hi-linux.com/posts/42057.html</id>
    <published>2024-05-06T01:00:00.000Z</published>
    <updated>2024-05-06T08:15:18.576Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最近在探索 Traefik 这一强大的服务代理和负载均衡器时遇到了一些挑战。然而，这次解决问题的过程并不寻常，因为找到了一位特别的助手 —— ChatGPT。</p><p>在这篇分享中，将带领大家走进一次独特体验，讲述我是如何借助 AI 的力量成功解决了 Traefik 配置中的若干问题，并从中获得了一些实用的小技巧。</p><h2><span id="一场技术与智能的邂逅">一场技术与智能的邂逅</span></h2><p>Traefik，以其动态配置和自动化路由的优势深受开发者喜爱，但在初次尝试配置其规则和服务时，即使是经验丰富的工程师也可能遭遇困惑。</p><p>在我深入研究 Traefik 的过程中，也碰到了一些棘手的问题，包括容器服务的自动发现、HTTPS 证书管理以及复杂路由规则的编写等。</p><a id="more"></a><h2><span id="与-chatgpt-的协同工作">与 ChatGPT 的协同工作</span></h2><p>在面对这些难题时，我转向了一种非传统的解决方案途径 —— 与 OpenAI 的自然语言处理模型 ChatGPT 对话。</p><p>ChatGPT 以其深厚的知识库和理解能力，对提出的每一个 Traefik 相关问题进行了详尽解答，从基础概念到具体配置案例，一一细致解读。</p><p>首先，对于 Traefik 中的服务自动发现，ChatGPT 梳理了 Kubernetes 和 Docker 环境下 Traefik 如何依据标签进行服务发现的原理，并提供了清晰的示例配置文件片段。通过 AI 的引导，我不再对复杂的自动生成路由规则感到迷茫。</p><p>其次，在 HTTPS 证书管理方面，ChatGPT 教会了我如何使用 Let’s Encrypt 与 Traefik 集成，实现自动化的 SSL 证书申请与续签，从而简化了安全通信的配置流程。</p><p>此外，针对面临的特定场景下的复杂路由规则设计，ChatGPT 更是凭借其强大的逻辑推理能力，帮助我构建了一个既能满足业务需求又简洁高效的 Traefik 中间件和路由规则组合。</p><h2><span id="几个小案例解决分享">几个小案例解决分享</span></h2><ol><li>自定义访问日志</li></ol><p><img src="https://img.hi-linux.com/staticfile/t1-2024-04-30-fi7hPt.png" alt></p><ol start="2"><li>反向代理到外部服务</li></ol><p><img src="https://img.hi-linux.com/staticfile/t2-2024-04-30-EiJvJ5.png" alt></p><ol start="3"><li>解决分应用单独记录访问日志</li></ol><p><img src="https://img.hi-linux.com/staticfile/t3-2024-04-30-9XORO0.png" alt></p><h2><span id="收获与感悟">收获与感悟</span></h2><p>这次经历，让我深刻感受到了人工智能在解决实际技术问题时的强大作用。ChatGPT 不仅能够快速给出精准的答案，还能基于上下文进行深度解释和扩展教学。</p><p>通过这次互动，不仅顺利地解决了 Traefik 配置难题，还积累了一些平时不易察觉的实践小技巧：</p><ul><li><strong>技巧一</strong>：利用 Traefik 的动态配置特性，可以根据运行时环境变化灵活调整路由策略。</li><li><strong>技巧二</strong>：借助 Traefik 中间件，可以方便地添加身份验证、重写 URL 等高级功能，进一步增强系统的安全性与可用性。</li><li><strong>技巧三</strong>：结合 Let’s Encrypt 的 ACME 协议，可以让 Traefik 自动处理 SSL/TLS 证书的生命周期管理，省去手动更新证书的烦恼。</li></ul><p>总结起来，通过与 ChatGPT 的交互，得以在较短时间内攻克了 Traefik 配置难关，同时也领略到了 AI 技术在技术支持和学习过程中的无限潜力。这场人与机器智慧交融的旅程，无疑为我的技术探索之旅增添了新的篇章，也为未来利用 AI 工具解决更多复杂问题树立了信心。</p><p>你想知道我用的是什么黑魔法 Traefik 专属提示词吗？公众号直接回复『ai-traefik』即可免费获取。</p><p>最后，你猜猜这篇文案是谁写的？</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在探索 Traefik 这一强大的服务代理和负载均衡器时遇到了一些挑战。然而，这次解决问题的过程并不寻常，因为找到了一位特别的助手 —— ChatGPT。&lt;/p&gt;
&lt;p&gt;在这篇分享中，将带领大家走进一次独特体验，讲述我是如何借助 AI 的力量成功解决了 Traefik 配置中的若干问题，并从中获得了一些实用的小技巧。&lt;/p&gt;
&lt;h2 id=&quot;一场技术与智能的邂逅&quot;&gt;一场技术与智能的邂逅&lt;/h2&gt;
&lt;p&gt;Traefik，以其动态配置和自动化路由的优势深受开发者喜爱，但在初次尝试配置其规则和服务时，即使是经验丰富的工程师也可能遭遇困惑。&lt;/p&gt;
&lt;p&gt;在我深入研究 Traefik 的过程中，也碰到了一些棘手的问题，包括容器服务的自动发现、HTTPS 证书管理以及复杂路由规则的编写等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Traefik" scheme="https://www.hi-linux.com/tags/Traefik/"/>
    
  </entry>
  
  <entry>
    <title>『奇妙的 Linux 世界』公众号 8 周年记</title>
    <link href="https://www.hi-linux.com/posts/19136.html"/>
    <id>https://www.hi-linux.com/posts/19136.html</id>
    <published>2024-04-18T01:00:00.000Z</published>
    <updated>2024-04-22T07:32:43.591Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="奇妙的-linux-世界公众号-8-周年记">🎉🎈 『奇妙的 Linux 世界』公众号 8 周年记 🎉🎈</span></h2><p>嘿，亲爱的『奇妙的 Linux 世界』读者们 👋</p><p>时光荏苒，转眼间 『奇妙的 Linux 世界』已经陪伴大家度过了 8 个年头。🍃</p><p>在这 8 年的岁月里，我们一起探索了 Linux 的无尽奥秘，分享了无数硬核干货和新奇内容。🐧</p><p>从一开始的探索者到现在的硬核粉丝，每一步都离不开大家的支持与热爱。🎊</p><p>在这个特别的日子里，让我们一起回顾这 8 年来的精彩旅程：🧳</p><a id="more"></a><h3><span id="硬核干货无处不在">🌟 硬核干货，无处不在</span></h3><p>在这 8 年里，『奇妙的 Linux 世界』一直秉承着开源精神，为广大 Linux 爱好者们奉上了无数优质的内容和实用的技巧。💡</p><p>从最初的几篇文章到如今的大量丰富内容库，我们始终坚持用心创作，用知识和经验为大家解惑，助力大家在 Linux 的世界里游刃有余。🚀</p><p>在每一次技术更新和发展的浪潮中，我们都紧跟时代的步伐，分享最新、最前沿的资讯和技术。让大家足不出户，也能领略 Linux 的奇妙之处！🌊</p><p>无论是关于 Linux 服务器的优化配置，还是关于 Nginx、MySQL、Docker、Kubernetes 等热门技术的深入解析，我们都在第一时间为大家呈现。📚</p><p>通过我们的分享，让更多人了解、学习和掌握 Linux 技术，并成为技术领域的佼佼者！🧙‍♂️</p><h3><span id="小技巧大收获分享即赢">🔥 小技巧大收获，分享即赢</span></h3><p>在『奇妙的 Linux 世界』，我们不仅关注大家熟知的技术领域，还特别关注各种实用小技巧的分享。🔍</p><p>这些小技巧或许只是一行命令、一个小工具，但却能带来意想不到的收获和便利。🛠️</p><p>我们相信，分享小技巧不仅可以提高大家的工作效率，还能增进社区的交流和共享。🔄</p><h3><span id="开源精神与时俱进">👨‍💻 开源精神，与时俱进</span></h3><p>在『奇妙的 Linux 世界』，我们坚信开源精神的力量，并将其贯穿于我们的每一篇文章和每一个推荐之中。💡</p><p>我们关注并推荐各种优秀的开源软件，鼓励大家积极参与开源社区，贡献自己的一份力量。💫</p><p>无论是在代码贡献、文档维护还是社区支持上，每个人都可以成为开源世界的一部分！💪</p><h3><span id="感谢与展望">🌐 感谢与展望</span></h3><p>在此刻，让我们一起庆祝这段旅程的每一个里程碑，也期待未来能有更多创新和突破。🌟</p><p>在过去的 8 年里，『奇妙的 Linux 世界』始终坚持初心，秉承着分享、学习、成长的理念，与大家一同探索 Linux 世界的无限可能。🌈</p><p>8 年的旅程，我们一起经历了无数的挑战和成长，感谢大家一直以来的支持和陪伴！🤔</p><p>在未来的岁月里将继续为大家带来更多优质内容和精彩体验。让我们一起加油，探索更广阔的技术领域，共同书写属于我们的 Linux 传奇！🎉</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;🎉🎈-『奇妙的-Linux-世界』公众号-8-周年记-🎉🎈&quot;&gt;🎉🎈 『奇妙的 Linux 世界』公众号 8 周年记 🎉🎈&lt;/h2&gt;
&lt;p&gt;嘿，亲爱的『奇妙的 Linux 世界』读者们 👋&lt;/p&gt;
&lt;p&gt;时光荏苒，转眼间 『奇妙的 Linux 世界』已经陪伴大家度过了 8 个年头。🍃&lt;/p&gt;
&lt;p&gt;在这 8 年的岁月里，我们一起探索了 Linux 的无尽奥秘，分享了无数硬核干货和新奇内容。🐧&lt;/p&gt;
&lt;p&gt;从一开始的探索者到现在的硬核粉丝，每一步都离不开大家的支持与热爱。🎊&lt;/p&gt;
&lt;p&gt;在这个特别的日子里，让我们一起回顾这 8 年来的精彩旅程：🧳&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>给「打工人」的维权指南：聊聊我的职场维权实战经验</title>
    <link href="https://www.hi-linux.com/posts/59972.html"/>
    <id>https://www.hi-linux.com/posts/59972.html</id>
    <published>2024-03-04T01:00:00.000Z</published>
    <updated>2024-03-04T08:01:44.699Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这是我第一次尝试写个人年度总结。</p><p>我的 2023 年与 2022 年不可分割，一直走在维权的路上。</p><p>早在 2022 年初，我的职业生涯发生重大转变，公司在未与我协商的情况下，单方面将我待岗，降低工资，移交工作。我从熟悉的工作环境被迫成为了一个「半自由职业者」。我之所以自认为是半自由，是因为公司未与我解除劳动合同，所以劳动关系还在原公司。法律规定劳动者只能和一家用人单位签订劳动合同，所以我在与公司存在劳动争议的情况下，无法入职下家公司。</p><p>除此之外，公司隔几个月后停发我的工资，切断了我唯一的经济来源。我开始尝试学习《劳动法》及相关法律知识，查阅和自己案件类似的裁判文书，整理书面材料，为的是跟公司对簿公堂，讨回做为劳动者的尊严和权益。</p><p>在劳资关系中，公司具有优势地位，而劳动者处于弱势的一方。尤其是面对老板、人事、法务组成的流氓团伙时，会更加被动、愤怒、迷茫、无助。希望大家在面对公司的恶意时可以更加从容，是我写下这些文字的初衷。</p><a id="more"></a><h2><span id="在职仲裁-or-离职仲裁">在职仲裁 or 离职仲裁</span></h2><p>以前一直以为遇到劳动争议问题，要离职后才能提起仲裁，但后来从网络了解到我的案件情况更适合在职仲裁，在职期间可以随时申请，所以我**尝试提起在职仲裁。**仲裁期间可以正常上班，自己也有机会尽可能地多搜集一些证据。因为公司取消了我的办公权限，我目前已经不需要去公司打卡了。</p><p>相比在职仲裁，选择<strong>离职仲裁是最为常见的情况</strong>，可固定和搜集的证据空间有限，适合情况简单的案子。需要注意，离职仲裁有时效性，期限为一年。也就是说发生劳动争议后，需在劳动关系终止之日（离职当天）起一年内提出。否则既不能仲裁也不能诉讼。</p><p><img src="https://img.hi-linux.com/staticfile/1-2024-03-04-hL5ZpT.jpeg" alt>劳动人事争议仲裁流程图（<a href="http://www.bjchy.gov.cn/affair/ldwq/tjzc/8a24fe9767393e2d01673f3dbdc70a21.html" target="_blank" rel="noopener">图源</a>：附件材料）</p><h3><span id="员工不能提供离职证明的解决办法">员工不能提供离职证明的解决办法</span></h3><p>如果已经和公司解除劳动合同， 但公司不配合，我们无法在入职新公司时提供证明该怎么办？</p><h4><span id="正常的法律渠道">正常的法律渠道</span></h4><p>依照法律规定，用人单位有义务在解除劳动合同时出具离职证明。所以我们可以打电话向当地劳动监察大队投诉，或者通过劳动仲裁要求公司出具离职证明并赔偿由此带来的损失。但这么做要花费一定的时间成本。</p><h4><span id="相对简单的解决办法">相对简单的解决办法</span></h4><p>虽然我们不能提供离职证明，但若是在客观事实中，与上一家用人单位的劳动合同已经解除或终止，则公司录用我们时已无法律障碍。我们可以提供与原公司劳动合同解除或终止的相关证明，例如：向原公司提出的《离职申请》、《工作交接记录》、《社保减员证明》等。</p><p>我们还可以向将要入职的公司，出具《承诺函》：<br>本人 A，身份证号：xxx，向 B 公司郑重承诺，本人已经与 C 公司劳动合同解除，若因本人做虚假承诺，给 B 公司造成任何不利后果，都由本人承担。落款：承诺人（签名），x 年 x 月 x 日。</p><h3><span id="提起劳动仲裁前需要注意什么">提起劳动仲裁前需要注意什么</span></h3><p>分享一个我在仲裁前，来自律师的建议：在准备《仲裁申请书》的请求事项中，可以把能想到的都写上（未休年假、加班费、绩效提成等），每项要写清楚详细的计算方式，然后对应去搜集证据，围绕诉求中的主张和证据，阐述事实和理由。</p><p>仲裁委不一定支持当事人的全部主张，但没写在请求事项中的内容一定不会得到支持。</p><p>我将注意事项的重点内容，简单做了如下总结：</p><ol><li>确认本人与用人单位签署了正式劳动合同，排除劳务合同、劳务派遣合同等，并确认自己是否保留了入职以来的全部合同原件。</li><li>如签订劳动合同、请确认合同中是否明确约定了薪酬情况、薪酬构成、工作岗位名称、工作内容、入职时间、工作地点。</li><li>完整保存了与公司沟通协商的往来邮件、微信聊天记录。</li><li>整理好手中现有的证据，列出清单。</li><li>劳动仲裁是必经前置流程，不可直接去法院起诉。</li></ol><h4><span id="提高法律意识留心法律风险">提高法律意识，留心法律风险</span></h4><p>在遇到突发性岗位变动或工作安排，如：调岗、转岗、待岗等，一定要留心这当中的法律风险，不要在任何书面材料上签字，劳动者有权拒绝公司任何不合理不合法的行为。如果跟公司有协商和谈判空间，**可以尝试为自己争取一个不低于心理预期的好结果。**但如果公司想裁员，话HR 找你谈话，连 N 都没有，要诚意没诚意，还不好好说，想套路你，故意搞你心态。别犹豫，拿起法律武器吧。</p><p>法律是每个公民都可以用来保护自己的权利，做为一名普通劳动者，我觉得维权最重要的除了证据和诉讼策略，更重要的是<strong>维权的勇气和决心</strong>。</p><h4><span id="经济补偿金n与-经济赔偿金2n的区别">经济补偿金（N）与 经济赔偿金（2N）的区别</span></h4><p>经常遇到这样一个问题：「员工被公司辞退了，应该赔偿 2N 还是 N+1」？</p><p><strong>经济补偿金</strong>：就是我们大家口中常说的「 N 」，「 N 」是工作年限，用来指代劳动合同法中的经济补偿，计算方式是：经济补偿金= 工作年限 x 月工资。<br>「工作年限」也叫司龄，是补偿金和赔偿金的基数。工作满 1 年支付 1 个月工资。不满 6 个月的，支付 0.5 个月的经济补偿；满 6 个月以上但不满 1 年的，按 1 年支付。<br>「月工资」是指劳动者在劳动合同解除或终止前 12 个月的平均工资（包含奖金、绩效、年终奖等应得收入）。</p><p><strong>经济赔偿金</strong>：公司「违法解除」劳动合同产生的惩罚性赔偿，计算方式是经济补偿金中「N」的 2 倍，也就是「2N 」。如果存在违法解除的情况，</p><p>据我了解，包括大厂在内的绝大多数公司都不守规矩，并不会按照法律标准去执行。有基础法律意识的公司想要裁员时，会尽量规避「违法解除」劳动合同，所以一般来说，「2N」的案子会越来越难打，员工三期（孕期、产期、哺乳期）内遭到公司违法解除劳动合同的情况能相对简单一些。公司会更倾向在「协商解除」的法律框架内做文章。</p><p>《劳动合同法》只规定了「协商解除」的最低标准是「 N 」，另外就是「N +1 」， 1 是指额外支付的 1 个月工资代通知金（即时解除）。除此之外，「N + 2 」 还是「 N + 3 」都没有法律依据。在 N 的基础上，公司想额外支付多少都没有法律限制， 只要双方协商一致，「N + 任何数字」都可以。</p><p>举个例子，公司想裁员找你协商，但你不同意，若公司一意孤行就要裁你，说你绩效不达标，单方面解除了劳动合同，此时就是违法解除，最低是「 2N 」。当然，劳资关系很复杂，公司可以找很多解除劳动合同的理由。如果想打「 2N 」，你需要提供充分的证据证明公司的行为违法，才有可能拿到「2N 」 。</p><p><strong>以下是我整理的关于「2N」的常见情形：</strong></p><table><thead><tr><th style="text-align:center">用人单位解除劳动合同情形</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">情形</td><td style="text-align:center">性质</td><td style="text-align:center">赔偿金</td></tr><tr><td style="text-align:center">劳动者被依法追究刑事责任，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者在试用期间被证明不符合录用条件，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者严重违反用人单位的规章制度，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者严重失职，营私舞弊，给用人单位造成重大损害，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者同时与其他用人单位建立劳动关系，对完成本单位的工作任务造成严重影响，或者经用人单位提出，拒不改正，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者以欺诈、胁迫的手段，或者趁人之危，使对方在违背真实意思表示的情况下订立或者变更劳动合同的情形，致使劳动合同无效，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者处于法定保护期（如孕期、产期、哺乳期），用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">未经劳动者同意，用人单位滥用解除权（如：试用期解除权），擅自解除合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">在本单位连续工作满 15 年，且距法定退休年龄不足 5 年，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">在本单位患职业病或因工负伤并被确认丧失或者部分丧失劳动能力，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">从事接触职业病危害作业的劳动者未进行离岗前职业健康检查，或者疑似职业病，病人在诊断或者医学观察期间，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">患病或者非因工负伤，在规定的医疗期内，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">连续签订 2 次固定期限劳动合同，并且劳动者没有严重过错、没有「不胜任岗位」「不能从事原岗位工作」的情况，合同期满，用人单位不同意不续签。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr></tbody></table><h3><span id="劳动法的有效学习工具">《劳动法》的有效学习工具</span></h3><h4><span id="中国裁判文书网">中国裁判文书网</span></h4><p>中国裁判文书网（简称“<a href="https://wenshu.court.gov.cn/" target="_blank" rel="noopener">裁判文书网</a>”）是由最高人民法院主办的官方网站，主要目的是公开全国各级法院生效裁判文书，以促进司法公正和透明度。</p><p>这是我日常使用频率最高的工具之一，是非常实用的司法实践参考。这个网站提供了丰富的研究素材和数据，可以检索到全国各地法院各类案件的一审、二审或再审判决书，细分选项特别多。</p><p>虽然劳动仲裁裁决书不公开，只允许当事人及其代理人查阅。但我们依然可以从公开的他人判决书中看到一些仲裁信息，如当事人的主张及理由。</p><p>我们可以通过裁判文书网查询和研究先前的判例，了解当地法律趋势，解析审判口径。例如：劳动者和公司双方的争议点是什么，哪些主张和证据被法院支持，为什么会支持，为什么会驳回。以及在结案陈词中法官是如何看待问题的。</p><p><img src="https://img.hi-linux.com/staticfile/1-2024-03-04-K48oE2.png" alt></p><h4><span id="小红书">小红书</span></h4><p>因为小红书有很多人将自己劳动仲裁的相关经历经验以笔记的形式分享，也有很多律师在平台上分享一些办案经验和法律知识，所以我觉得将它非常适合搜索高质量的信息，提前做好功课，多方验证信息，也可以让自己少走些弯路。</p><h4><span id="中国法律快查手册">中国法律快查手册</span></h4><p><a href="https://github.com/RanKKI/LawRefBook" target="_blank" rel="noopener">中国法律快查手册</a>是一个 Github 上的开源项目，内容来源于国家法律法规数据库，这个项目的作者将数据库做了整合和搜索等功能，排版简洁，使用起来简单方便，非常适合平时查询和学习。作者仅提供了手机版（ iOS、iPadOS）和网页版，并未提供电脑端版本，但我在 M1 MacBook Pro 也可以通过 App Store 应用商店安装使用。</p><p>劳动争议的话，建议主要关注《中华人民共和国劳动法》《中华人民共和国劳动合同法》这两个法规。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805474-2024-03-04-SwEcjk.png" alt><a href="https://github.com/RanKKI/LawRefBook?tab=readme-ov-file" target="_blank" rel="noopener">图源</a> / GitHub</p><h2><span id="靠谱律师怎么找">靠谱律师怎么找</span></h2><p>通过研究司法案例以及本地近期公开的劳动争议相关判决书，我学到了一些劳动法基础知识，开始尝试梳理自己的案件情况，并希望可以得到律师的一些专业建议。先说说找律师来代理案子的 2 个常见误区</p><h4><span id="误区-1-律所越大越好名气越高越好">误区 1 ：律所越大越好，名气越高越好。</span></h4><p>名气高的大律所，服务的对象一般是大公司，因为劳动者的案子都是标的金额低的小案子，不赚钱。</p><p>术业有专供，不是所有律师都擅长打劳动仲裁的案子。所以正确的方式是找主要做劳动争议案件的律所，或是主要代理劳动争议的律师。<br>可以是通过熟人（如：朋友、同事、家人）推荐，这样有一定的信任基础，也可以在小红书搜索，看看其他人选择的律师是否口碑好案例多。</p><p>如果在律师的履历介绍中，可以看到他擅长的领域很多，那不一定是好事。我们需要的是履历介绍中更多和劳动争议相关的律师。</p><h4><span id="误区-2-花了钱请律师代理就可交由律师全权负责">误区 2 ：花了钱请律师代理，就可交由律师全权负责</span></h4><p>我们的劳动争议案件虽然标的小且不赚钱，但不妨碍它很复杂。需要投入大量时间研究，准备和开庭，跑仲裁或法院。</p><p>律师也是如此。律师作为法律工作者，是提供专业的法律帮助，而不是代替处理相关全部事项。关于案件中的取证、和有关部门交涉都需要自己来完成，律师只是在这个过程中提供指导。律师可以帮忙争取最好的结果，但不能避免所有的风险。</p><p>作为当事人，我们对公司和自身情况最为了解，庭审时法官会围绕每个细节进行详细询问，这也是为什么自己要重视开庭并亲自参加庭审的原因。为了降低诉讼中存在的风险，我们需要多和律师交流讨论，自己要先厘清思路，整理好证据，做好充足准备，在开庭时才能自如应答，不会因为紧张而遗漏重点。</p><p>通过以上 2 个误区，我们可以对这部分做个小总结：</p><ol><li>专业领域的重要性：我们需要考虑自己的案子类型和律师的专业领域是否匹配</li><li>选择合适的律所和律师：选择有良好声誉和口碑的律师</li><li>律师的角色：请律师并不意味着可以完全放手，律师的角色是指导和争取最佳结果，而不是替代自己处理所有事物。</li><li>当事人的参与：我们做为当事人应对自己的案件有深入了解，并积极参与庭审准备，与律师充分沟通，整理证据，清晰思路，尽可能降低诉讼风险。</li></ol><h3><span id="找律师途径之一中国法律服务网12348-中国法网">找律师途径之一：中国法律服务网（12348 中国法网）</span></h3><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805551-2024-03-04-ac3x5W.png" alt></p><p>这个由司法部建设的网站，是于2018 年 5 月20 日正式上线运行。网站整合并收录了全国范围内的「法律服务机构」和「法律人员数据」。是</p><p>我们可以在里面选择律所或律师，也可以通过网站查询从其他渠道了解到的某家律所，或某位律师（可查询律师执业证号）。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145839669-2024-03-04-Ev0UoP.png" alt></p><h3><span id="为找律师我做了哪些尝试">为找律师我做了哪些尝试</span></h3><p>算下来，我前后共咨询了 3 位律师（不包含法律援助）。我寻求律师帮助的路径是：在线咨询律师 A（付费）—— 线下咨询律师 B （付费）—— 线下咨询律师 C （付费）</p><h4><span id="在线咨询律师-a">在线咨询律师 A</span></h4><p>最开始我先尝试了在网上找律师付费咨询，<br>虽然付费价格（支付 168 元）比线下咨询律师便宜很多，但是与价格相对等的是提问有次数、字数、时间限制（只能文字沟通不能语音），如果在律师不了解相关背景情况下进行提问，这将导致律师因无法判断案情而无法提供合理化建议。</p><p>于是我尝试尽量精简文字表述，将提问内容分为：事件背景（时间线）、我的现状、核心问题，制作成一张图片发送给律师。律师对我提问的内容一一做了解答，但是我结合自身情况，判断出律师提出的解决方案存在的风险比较高，所以我没有采纳。</p><h4><span id="线下咨询律师-b">线下咨询律师 B</span></h4><p>在律师朋友的介绍下，我联系上了一位主要代理劳动争议案件的律师，律所离我也不算远，约了时间线下面谈。这次收获蛮大的，之前担心的问题基本都得到了解决，心里也更踏实了，只不过我的情况比较被动，需要看公司下一步的动作。</p><h4><span id="线下咨询律师-c">线下咨询律师 C</span></h4><p>律师 C 是同事推荐，对于劳动仲裁案件的经验非常丰富。也是我综合考量后，选择了律师 C 委托代理我的一审案子。</p><p>关于律师咨询费。北京这边 200 - 3000 元 / 小时不等，我在线下咨询律师 B 两次，每次都是 500 元 / 小时。</p><p>关于律师代理费。根据案子标的额的百分比收取，不同审判阶段（仲裁、一审、二审），费用也不同。</p><h2><span id="少走弯路准备证据和录音技巧">少走弯路：准备证据和录音技巧</span></h2><h3><span id="准备证据">准备证据</span></h3><h4><span id="一键下载仲裁所需的全部材料">一键下载仲裁所需的全部材料</span></h4><p>包含劳动仲裁立案申请、证据交换、出庭使用的材料模板，可以通过<a href="http://www.bjchy.gov.cn/affair/ldwq/tjzc/8a24fe9767393e2d01673f3dbdc70a21.html" target="_blank" rel="noopener">北京市朝阳区人民政府官网</a>页面底部的「点击此处下载相关附件」获取。文档中还有相关办理流程、注意事项，内容非常全面，可以仔细查阅。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805703-2024-03-04-nYvF2T.png" alt></p><h4><span id="自助打印银行工资流水凭证">自助打印银行工资流水凭证</span></h4><p><strong>本人带上身份证原件直接去附近银行营业厅的自助机上打印</strong>，可自行在机器上操作，省去拿号排队去窗口的过程，在使用银行自助机的过程中，有任何问题都可以找身边的银行经理帮忙解决，非常高效。<strong>建议在打印前了解相关费用标准并做好准备</strong>，有的银行会限制每月免费打印次数，超过则按张收取费用。我的工资是由公司通过 3 家银行（北京、交通、招商）发放，所以我需要去 3 家银行分别打印流水，北京银行和交通银行的自助机没有对流水单设立打印限制，但招商银行的打印限制我记得是 4 张 / 月，超过按 20 元 / 张收费。</p><p>在银行自助机操作时，我总结了 3 个重点：选择时间范围、筛选交易类型、包含银行盖章。</p><p><strong>选择时间范围</strong>：依据劳动争议涉及的时间来选择流水打印范围，需按年选择，不可跨年。</p><p><strong>筛选交易类型</strong>：要在筛选栏勾选交易类型（工资），指定筛选条件的目的，是为了方便自己和他人在查看银行流水单时，让工资发放情况一目了然，我们只需要工资流水的相关证明，不需要其他交易记录。</p><p><strong>包含银行公章</strong>：银行自助机打印的工资明细一般默认包含公章，但也有个别银行需要在打印前勾选相关选项后，才可打印出盖了章的流水单。公章名称一般叫「回单专用章」或「会计业务章」。打印前后一定要留意打印的流水单是否包含银行的公章，如果没有公章则证据无效。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145849891-2024-03-04-4TsJZE.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805946-2024-03-04-Opd8Qi.png" alt></p><p>我的银行流水单盖章（左：北京银行 ；右：交通银行）</p><h4><span id="利用-iphone-备忘录扫描劳动合同复印件">利用 iPhone 备忘录扫描《劳动合同》复印件</span></h4><p>因为打印出来的纸张是黑白效果，如果直接使用手机将《劳动合同》拍照、，会导致部分信息模糊不清，这里有个便捷好用的小技巧：利用 iPhone 备忘录中的「扫描」功能，逐页将《劳动合同》扫描成 PDF 文件后再打印（相比直接打印效果更清晰，相比复印更省事）。可以避免因提交材料不合格导致返工的情况（不要重蹈我的覆辙）。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145806016-2024-03-04-FtagF1.png" alt>iPhone 备忘录中的「扫描文稿」功能</p><h4><span id="打工人必备app-权利卫士">打工人必备App —— 权利卫士</span></h4><p>这是一款由国家知识产权局推出，具有法律效率的<a href="https://www.tsa.cn/" target="_blank" rel="noopener">电子取证工具</a>（仅支持 iOS、Android ），被法律工作者广泛使用。可生成不可篡改的带有时间戳的电子证据。取证范围包含：拍照、录像、录音、录屏、网页。在 App 中实名认证就可正常使用。</p><p>如果有些证据比较重要，可以选择这个工具。例如：在公司对我的办公软件停用前，我就使用了权利卫士的录屏功能，对组织架构、个人信息等情况进行了证据固定。法律规定谁主张谁举证的原则，在提起仲裁或诉讼时，我就有了通过权利卫士保存的电子版基础证据。</p><p>权利卫士可以很大程度上代替传统的公正取证方式。正确使用权利卫士，可以在价格低廉的同时，让取证变得更快捷。但它终归只是一个取证工具，证据的真实性没问题，但是否会被采纳，能发挥多大作用，是需要深度思考的问题。如果拿不准可以在律师的指导下使用，毕竟每次取证都需要付费。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145806077-2024-03-04-UkvPbG.png" alt>权利卫士官网</p><h3><span id="录音技巧">录音技巧</span></h3><ol><li>时间：录音证据宜早不宜晚</li><li>设备：无论面谈与否，要全程录音，能清晰听清双方谈话内容的设备皆可。如果是电话沟通，并且是苹果手机，没有通话录音功能，可以向朋友借一台手机用来录音。</li><li>操作：手机可以开启飞行模式，防止突然来电导致录音中断</li></ol><h4><span id="注意事项">注意事项</span></h4><p>录音证据大多情况都不能被仲裁庭采纳，主要原因是录音中的谈话内容，缺少适格主体等关键信息，例如：公司法人张三、人力资源负责人李四。录音属于锦上添花，能有更好，如果获取不到有用信息也没有关系。</p><p>录音的目的是通过谈话，问清事实情况，便于进一步固定证据。不能威胁恐吓对方（态度友好），否则证据无效。值得一提的是，录音证据的目的是为了佐证其他关联证据，形成证据链，不能单独使用。</p><p>谈话中不仅<strong>问题要清晰明确</strong>，还需要做到谈话人身份明确，内容清晰，具有客观真实和连贯性。可以先理清思路，再写成书面材料，通话前尝试练习几遍。</p><h4><span id="提交录音">提交录音</span></h4><p>需要注意的是，录音做为证据时，要做两件事：一是要将未被剪接或者伪造，内容未被改变，无疑点的<strong>完整音频文件刻录成光盘</strong>，二是要将全部<strong>对话内容整理成文字版书面材料。</strong></p><p>**录音内容文字版：**建议写明这些信息：时间、地点、设备、时长、当事人信息（本人名字、公司负责人职称和名字）。最后，在《证据目录》中标记好录音文件的位置，将录音光盘、文字版随其他证据一起提交。</p><p>另外，录音原视文件和载体（如手机）要保留好，用于庭审时查验。</p><h4><span id="我的录音沟通提纲">我的录音沟通提纲</span></h4><ol><li>确认双方主体和身份</li><li>确认相关的事实</li><li>履行友好协商的态度，明确提出自己的主张</li></ol><h4><span id="我的通话前录音内容">我的通话前录音内容</span></h4><ol><li>对着录音自我介绍并陈述事实：我是 xxx，身份证号 xxx，自 x 年 x 月 x 日在 x 公司，x 部门，担任 x 职位。<br>x 年 x 月 x 日起，公司 xx（简短陈述事实内容），我现在要给公司人力资源部总监 xx （全名）拨打电话，协商解决方案。Ta 的电话是 xxx。</li></ol><p><img src="https://img.hi-linux.com/staticfile/1-20240304145904400-2024-03-04-LCFi9Y.jpeg" alt>证据材料清单样表（<a href="http://www.bjchy.gov.cn/affair/ldwq/tjzc/8a24fe9767393e2d01673f3dbdc70a21.html" target="_blank" rel="noopener">图源</a>：附件材料)</p><h3><span id="寻求免费的法律援助">寻求免费的法律援助</span></h3><p>法律援助更像是针对「特殊群体」设立的专项服务，主要服务于农民工或年纪较大的人。</p><p>朝阳劳动仲裁委员会也设立了法律援助咨询窗口，在服务总台领号排队，与仲裁立案窗口同在一个大厅。或许是我的案子具有复杂性，也可能窗口的工作人员并没太多时间帮我深度分析，我将手里的证据给到对方，尝试了解对于我这种情况的政策和裁判口径，但我并未收获到有用的信息和指导性建议。</p><p>所以，大家可以尝试性去咨询，但不要对法援抱有太大期望。也不要轻信仲裁委门口主动发卡片的律师咨询，我从没见过有执业证的律师需要揽客，这些卡片上的律师，很可能就不是律师，十有八九不靠谱，有很多被人被骗。</p><h3><span id="我的完整仲裁流程">我的完整仲裁流程</span></h3><p>在仲裁阶段，我选择的是自己走完全流程，委托律师代理的是一审诉讼。<br>一是因为北漂多年，有过仲裁经历。<br>二是因为之前外籍二房东不退押金，并大放厥词可以去法院告他。于是我就听了他的建议，自己写诉状去法院起诉，所以有一些民事诉讼的经验。</p><p>劳动仲裁的立案、交换证据流程和法院诉讼在某些方面有相似之处，。所以我觉得仲裁相比诉讼来说在准备充分的情况下要简单很多，我的劳动争议案子偏复杂，需要经过法院审理。</p><p>以北京朝阳区为例，可以在北京人社局官网提前预约，预约后会短信告知线下提交立案材料的时间。疫情时官网预约后需要等 1 个月以上，现在要等的时间不好说。</p><p>也可以选择可以直接去线下领号立案（更推荐这种方式，更高效）。建议准备好材料，在 8 点前到门口排队， 10点前拿到号。否则可能会由于人多无法当天立案。我在<strong>疫情时和疫情后</strong>分别成功立案 2 次，是针对劳动争议中的不同时间段的仲裁请求。现在疫情已经过去，流程也简化了不少，相对来说更省事儿了。</p><h4><span id="仲裁地点">仲裁地点</span></h4><p>北京市朝阳区劳动人事争议仲裁院<br>电 话：010-87983310<br>地 址：北京市朝阳区将台路5号院15号楼B座、C座</p><h4><span id="准备材料">准备材料</span></h4><ul><li>身份证原件</li><li>身份证复印件 x 3</li><li>申请书 x 3</li><li>地址确认书 x 1</li></ul><p>建议检查好相关材料，并将电子版备份到 U 盘，最好是带上笔记本电脑，若书面材料不符合立案窗口要求，可以即时用自己电脑修改，若有漏打材料，也可在服务台旁边的打印区付费打印。</p><h4><span id="立案流程">立案流程</span></h4><ol><li>去总服务台领取地址确认书填好，领取初审号码（可以提前打印好，直接领A 开头初审号码）</li><li>初审后收到 B 开头立案号码，等待叫号。</li><li>立案窗口工作人员可能会让填一个劳动调解表。（这步可以直接放弃调解，直接走程序省时间，因为开庭前仲裁员还会再次调解）</li></ol><h4><span id="完成立案">完成立案</span></h4><p>成功立案后，窗口会现场出具举证通知等书面材料，立案后有 30 天的调解时间，期间会有工作人员打电话给当事人（公司、劳动者）双方，询问是否同意调解。接下来会收到朝阳仲裁委关于交换证据的通知邮件，以及短信提醒。</p><h4><span id="交换证据">交换证据</span></h4><p>需要注意，自己和公司方的交换时间是一样的，务必要按照规定时间内到达指定窗口，办理举证及证据交换，必须是本人，否则过时不候。提交完成并签字确认后就可以离场了，如果在现场遇到公司的人也必理会。</p><h4><span id="等待庭审">等待庭审</span></h4><p>接下来，等待开庭通知就好。开庭时要携带身份证原件、证据原件。需要注意开庭时间， **如果开庭当天本人迟到，会被视为撤诉。**仲裁开庭也比较简单，不会法院审理案件那样细致。主要是仲裁员通过问询双方当事人，录入双方确认的一些信息，如争议时间、质证理由、社保状态、薪资情况等。<br>仲裁案件都是随机分别仲裁员，我是2022 年底立案， 2023 年初开庭，直到 2023 年 10 月才收到裁决书。大家可以多联系自己案件的仲裁员，催问进度。</p><h4><span id="仲裁结果">仲裁结果</span></h4><p>身边总有朋友认为，收到的劳动仲裁裁决书上支持了相关请求事项，就是胜利的信号，但仲裁是以调解为主，并不能最大限度维护劳动者自身权益。例如：法律规定协商解除劳动合同的最低标准是 N ，假设 N 是 10 个月，仲裁员会和公司、劳动者分别协商，讨价还价后，最终 N 可能是 6 或者 4，甚至更低，看似减少了劳动者维权的时间成本，实际最大受益者却是公司一方，公司试图用远低于法律规定的标准，带有恶意性、针对性、侮辱性的手段，低成本实现裁员目的。</p><p>所以劳动仲裁对劳动者来说只是维权之路的起点，还要经历一审诉讼、二审诉讼，即使最终赢了官司，还可能面临向法院申请强制执行的情况。</p><h2><span id="写在最后">写在最后</span></h2><p>遇见过一些 HR ，千方百计地学习裁员套路和话术。一个员工为企业服务这么多年，非但不感谢员工多年的辛苦付出，反而为了达成裁员目的搞手段，扣帽子。想法设法压榨剥削打工人，员工不和你死磕跟谁磕？员工就是一个个普普通通的人，不止看重钱，还很在乎你怎么对他。</p><p>这个世界很奇妙。代理我案子的律师最近就遇见了一个离谱案件，将这个真实案例用一句话概括就是：职场当中套路虽多，但涉及底线的东西并不适用于套路。谁也说不准，后面被搞心态以及被裁的，会不会是自己。</p><blockquote><p>本文转载自：「 少数派 」，原文：<a href="https://url.hi-linux.com/jpw6C" target="_blank" rel="noopener">https://url.hi-linux.com/jpw6C</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我第一次尝试写个人年度总结。&lt;/p&gt;
&lt;p&gt;我的 2023 年与 2022 年不可分割，一直走在维权的路上。&lt;/p&gt;
&lt;p&gt;早在 2022 年初，我的职业生涯发生重大转变，公司在未与我协商的情况下，单方面将我待岗，降低工资，移交工作。我从熟悉的工作环境被迫成为了一个「半自由职业者」。我之所以自认为是半自由，是因为公司未与我解除劳动合同，所以劳动关系还在原公司。法律规定劳动者只能和一家用人单位签订劳动合同，所以我在与公司存在劳动争议的情况下，无法入职下家公司。&lt;/p&gt;
&lt;p&gt;除此之外，公司隔几个月后停发我的工资，切断了我唯一的经济来源。我开始尝试学习《劳动法》及相关法律知识，查阅和自己案件类似的裁判文书，整理书面材料，为的是跟公司对簿公堂，讨回做为劳动者的尊严和权益。&lt;/p&gt;
&lt;p&gt;在劳资关系中，公司具有优势地位，而劳动者处于弱势的一方。尤其是面对老板、人事、法务组成的流氓团伙时，会更加被动、愤怒、迷茫、无助。希望大家在面对公司的恶意时可以更加从容，是我写下这些文字的初衷。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="教程" scheme="https://www.hi-linux.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="职场" scheme="https://www.hi-linux.com/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>简单一招，轻松把 Nginx 服务器性能提升 50 倍</title>
    <link href="https://www.hi-linux.com/posts/52460.html"/>
    <id>https://www.hi-linux.com/posts/52460.html</id>
    <published>2024-02-05T01:00:00.000Z</published>
    <updated>2024-02-05T08:27:29.121Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="用-nginx-gzip-进行静态加速">用 Nginx Gzip 进行静态加速</span></h2><p>这绝对是你应该做的事情。<br>并不是特别麻烦，而且效果也很突出。</p><p>这里解释了 <a href="https://nginx.p2hp.com/" target="_blank" rel="noopener">Nginx</a> 中的 gzip_static。</p><h3><span id="1不使用-gzip-static-时的-gzip-处理">1.不使用 gzip static 时的 gzip 处理</span></h3><p><img src="https://img.hi-linux.com/staticfile/N56H1Z-2024-02-05-yyBwlC.png" alt="Nginx 不使用 gzip_static 时 gzip 处理的说明"></p><p><strong>如果你不使用 gzip_static 而只是 “gzip on”，它每次都会被压缩并发送。</strong></p><p>虽然它实际上可能缓存在内存中，但传统观点是 “每次都会执行压缩处理，因此 CPU 负载很大。”</p><p>因此，我每次都想停止处理它。</p><p>“gzip_static” 可以实现这一点。</p><a id="more"></a><h3><span id="2使用-gzip-static-时的-gzip-处理">2.使用 gzip static 时的 gzip 处理</span></h3><p><img src="https://img.hi-linux.com/staticfile/g3KBwu-2024-02-05-TfefNK.png" alt="Nginx 中开启 gzip_static 时 gzip 处理的说明"></p><p><strong>它将搜索 “gz” 文件并为您使用！</strong></p><p>如果是 “style.css”，它将自动搜索文件 “style.css.gz”。<br>如果找到，则返回它；如果没有，则照常压缩 “style.css”。<br>因此，如果提前创建压缩文件，就不会产生 CPU 负载，处理速度也会更快。</p><p>更好的是压缩级别。</p><h3><span id="3使用-gzip-static-的优点">3.使用 gzip static 的优点</span></h3><p><img src="https://img.hi-linux.com/staticfile/WXg4zd-2024-02-05-j5SCrt.png" alt="将 gzip_static 与 Nginx 一起使用的最大优点是可以将压缩级别设置为 9。"></p><p><strong>它可以以最大压缩率保存。</strong></p><p>通常情况下，不可能使用最高压缩设置，因为它会给 CPU 带来沉重的负载，但<br>由于你可以提前慢慢创建它，所以我通常将其保存在最高压缩级别（级别9）。<br>文件大小肯定会减小。</p><h3><span id="4-需要一个模块才能在-nginx-中使用-gzip-static">4. 需要一个模块才能在 Nginx 中使用 gzip static</span></h3><p><strong>ngx_http_gzip_static_module 是必需的。</strong></p><p>请使用以下命令检查是否已安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V 2&gt;&amp;1 | tr <span class="string">' '</span> <span class="string">'n'</span>|egrep _module | sed -e <span class="string">'s/--with-//g'</span></span><br></pre></td></tr></table></figure><p>如果未安装，系统会要求您重新安装 Nginx（可能）。<br>您必须使用 “–with-http_gzip_static_module” 安装它。<br>但是，当我从存储库安装时，所有内容都已包含在内，而无需执行任何操作。</p><p>请先检查一下。</p><h3><span id="5如何在-nginx-上配置-gzip-静态">5.如何在 Nginx 上配置 gzip 静态</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gzip_static on;</span><br><span class="line">gzip on;</span><br><span class="line">gzip_comp_level 1;</span><br><span class="line">gzip_min_length 1024;</span><br><span class="line">gzip_vary on;</span><br><span class="line">gzip_proxied any;</span><br><span class="line">gzip_types text&#x2F;plain text&#x2F;css text&#x2F;javascript application&#x2F;javascript application&#x2F;x-javascript application&#x2F;json application&#x2F;ld json text&#x2F;xml application&#x2F;xml application&#x2F;xhtml xml application&#x2F;atom xml application&#x2F;xml rss application&#x2F;rss xml image&#x2F;x-icon image&#x2F;svg xml image&#x2F;bmp;</span><br></pre></td></tr></table></figure><p><strong>只需在常规内容中添加 “gzip_static on” 即可。</strong></p><p>这就是启用它所需要做的全部工作，所以很简单。</p><p>我建议你只设置这个。</p><p>如果你用谷歌搜索，你会看到很多人指定 “gzip_static always”，<br>这意味着在任何情况下都使用 gz 文件。<br>假设所有目标文件都被压缩并保存（理想情况）。</p><p>在这种情况下，将不会显示不支持的用户，因此您还需要指定 “gunzip on;”。<br>如果客户端不支持 gzip，文件会在服务器端解压后发送。</p><p>详情请参阅以下页面。</p><p><a href="http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html" target="_blank" rel="noopener">官方解释：ngx_http_gzip_static_module 模块</a></p><h3><span id="6-如何使用-gzip-压缩">6. 如何使用 gzip 压缩</span></h3><p>&lt;对于 PHP&gt;</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzencode(<span class="variable">$file</span>, 9)</span><br></pre></td></tr></table></figure><p>&lt;对于 ubuntu（Linux）&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -9 -k style.css</span><br></pre></td></tr></table></figure><p>每次更新时我都会自动使用 PHP 创建它。</p><h3><span id="7-需要压缩的文件">7. 需要压缩的文件</span></h3><p><strong>一般文本文件如 css、js、xml 等</strong></p><p>可以将其视为图像之外的其他内容。</p><p>基本上，它将是 “gzip_types” 指定的文件。</p><p>但是，如果将压缩级别设置为 9，图像通常会变小。<br>如果你比较讲究的话，请用各种方式压缩一下看看。</p><p>这是 Nginx中 gzip static 的解释。</p><p>它非常有效，所以请尝试一下。</p><p>原文链接 <a href="https://doudonn.com/saba/2331/" target="_blank" rel="noopener">https://doudonn.com/saba/2331/</a></p><blockquote><p>本文转载自：「 Lenix Blog 」，原文：<a href="https://url.hi-linux.com/o1BAZ" target="_blank" rel="noopener">https://url.hi-linux.com/o1BAZ</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;用-Nginx-Gzip-进行静态加速&quot;&gt;用 Nginx Gzip 进行静态加速&lt;/h2&gt;
&lt;p&gt;这绝对是你应该做的事情。&lt;br&gt;
并不是特别麻烦，而且效果也很突出。&lt;/p&gt;
&lt;p&gt;这里解释了 &lt;a href=&quot;https://nginx.p2hp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nginx&lt;/a&gt; 中的 gzip_static。&lt;/p&gt;
&lt;h3 id=&quot;1-不使用-gzip-static-时的-gzip-处理&quot;&gt;1.不使用 gzip static 时的 gzip 处理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/N56H1Z-2024-02-05-yyBwlC.png&quot; alt=&quot;Nginx 不使用 gzip_static 时 gzip 处理的说明&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你不使用 gzip_static 而只是 “gzip on”，它每次都会被压缩并发送。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然它实际上可能缓存在内存中，但传统观点是 “每次都会执行压缩处理，因此 CPU 负载很大。”&lt;/p&gt;
&lt;p&gt;因此，我每次都想停止处理它。&lt;/p&gt;
&lt;p&gt;“gzip_static” 可以实现这一点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>史上最全 SSH 暗黑技巧详解</title>
    <link href="https://www.hi-linux.com/posts/60266.html"/>
    <id>https://www.hi-linux.com/posts/60266.html</id>
    <published>2024-01-23T01:00:00.000Z</published>
    <updated>2024-01-23T02:11:04.393Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>我见过太多的老鸟、新手对 SSH 基本只限于 SSH 到远程机器，实际这个命令我们一天要用很多次，但是对它的了解太少了，他的强大远远超出你的想象。当于你也许会说够用就够了，确实没错，但是你考虑过效率没有，或者还有哪些脑洞大开的功能会让你爱死他，这些功能又仅仅是一行命令就够了。</p><p>疫情期间一行 SSH 命令让我节省了 70% 的出差时间，来，让我们一起走一遍，看看会不会让你大开眼界。</p><a id="more"></a><h2><span id="本文试图解决的问题">本文试图解决的问题</span></h2><ul><li>如何通过 SSH 命令正确上网</li><li>Docker 镜像、Golang 仓库总是被墙怎么办</li><li>公司跳板机要输入动态 Token，太麻烦了，如何省略掉这个 Token；</li><li>比如多机房总是要走跳板机，如何 <code>绕过</code> 跳板机直连；</li><li>我的开发测试机器如何免打通、免密码、直达；</li><li>如何访问隔离环境中( K8s )的 Web 服务 – 将隔离环境中的web端口映射到本地</li><li>如何让隔离环境的机器用上 Yum、APT</li><li>如何将服务器的图形界面映射到本地(类似 VNC 的作用)</li><li>SSH 如何调试诊断，这才是终极技能……</li></ul><h2><span id="注意事项">注意事项</span></h2><ul><li>SSH 是指的 openSSH 命令工具</li><li>本文适用于各种 Linux、macOS 下命令行操作，Windows 的话各种可视化工具都可以复制 Session、配置 Tunnel 来实现类似功能。</li><li>如果文章中提到的文件、文件夹不存在可以直接创建出来。</li><li>所有配置都是在你的笔记本上（相当于 SSH Client上）</li></ul><h2><span id="正确上网">正确上网</span></h2><p>有时候正确上网还得靠自己，一行 SSH 命令来正确上网:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ssh -qTfnN -D 127.0.0.1:38080 root@1.1.1.1 &quot;vmstat 10&quot; 2&gt;&amp;1 &gt;&#x2F;dev&#x2F;null &amp;</span><br></pre></td></tr></table></figure><p>上面的 1.1.1.1 是你在境外的一台服务器，已经做好了免密登陆（免密见后面，要不你还得输一下密码），这句话的意思就是在本地启动一个 38080 的端口，上面收到的任何东西都会转发给 1.1.1.1:22（做了 SSH 加密），1.1.1.1:22 会解密收到的东西，然后把他们转发给 Google 之类的网站（比如你要访问的是 Google），结果依然通过原路返回</p><p>127.0.0.1:38080  就是要填入到你的浏览器中的 Socks5 代理服务器，什么都不需要装，非常简单。</p><p><img src="https://img.hi-linux.com/staticfile/n3mrq5-2024-01-22-7OPIZB.png" alt></p><p>原理图如下(灰色矩形框就是你本地 SSH 命令，SSH 线就是在穿墙， 国外服务器就是命令中的 1.1.1.1)：</p><p><img src="https://img.hi-linux.com/staticfile/Wqm4wS-2024-01-22-UmMYjx.png" alt></p><h3><span id="正确上网之-http-特殊代理-利用-ssh-本地转发是-http-协议">正确上网之 HTTP 特殊代理 – 利用 SSH 本地转发是 HTTP 协议</span></h3><p>前面所说的代理是 Socks5 代理，一般浏览器都有插件支持，但是比如你的 Docker（或者其他程序）需要通过 HTTP 去拉取镜像就会出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon 8.704 kB</span><br><span class="line">Step 1 : FROM k8s.gcr.io&#x2F;kube-cross:v1.10.1-1</span><br><span class="line">Get https:&#x2F;&#x2F;k8s.gcr.io&#x2F;v1&#x2F;_ping: dial tcp 108.177.125.82:443: i&#x2F;o timeout</span><br></pre></td></tr></table></figure><p><a href="https://www.atatech.org/articles/102153" target="_blank" rel="noopener">如果是 Git 这样的应用内部可以配置 Socks5 和 HTTP 代理服务器，请参考另外一篇文章</a>，但是有些应用就不能配置了，当然最终通过 SSH 大法还是可以解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssh -L 443:108.177.125.82:443 root@1.1.1.1 &#x2F;&#x2F; 在本地监听 443，转发给远程 108.177.125.82 的 443 端口</span><br></pre></td></tr></table></figure><p>然后再在 <code>/etc/hosts</code> 中将域名 <a href="http://k8s.gcr.io" target="_blank" rel="noopener">k8s.gcr.io</a> 指向 127.0.0.1， 那么本来要访问 <a href="http://k8s.gcr.io:443" target="_blank" rel="noopener">k8s.gcr.io:443</a> 的，变成了访问本地 127.0.0.1:443 而 127.0.0.1:443 又通过 SSH 重定向到了 108.177.125.82:443 这样就实现了 HTTP 代理或者说这种特殊情况下的正确上网。这个方案不需要装任何东西，但是每个访问目标都要这样处理，好在这种情况不多。</p><h2><span id="内部堡垒机-跳板机都需要密码动态码太复杂了怎么解">内部堡垒机、跳板机都需要密码+动态码，太复杂了，怎么解？</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/config </span></span><br><span class="line"><span class="meta">#</span><span class="bash">reuse the same connection --关键配置</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~/tmp/ssh_mux_%h_%p_%r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查了下 ControlPersist 是在 OpenSSH5.6 加入的，5.3还不支持</span></span><br><span class="line"><span class="meta">#</span><span class="bash">不支持的话直接把这行删了，不影响功能</span></span><br><span class="line"><span class="meta">#</span><span class="bash">keep one connection <span class="keyword">in</span> 72hour</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ControlPersist 72h</span></span><br><span class="line"><span class="meta">#</span><span class="bash">复用连接的配置到这里，后面的配置与复用无关</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">其它也很有用的配置</span></span><br><span class="line">GSSAPIAuthentication=no</span><br><span class="line"><span class="meta">#</span><span class="bash">这个配置在公网因为安全原因请谨慎关闭</span></span><br><span class="line">StrictHostKeyChecking=no</span><br><span class="line">TCPKeepAlive=yes</span><br><span class="line">CheckHostIP=no</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"ServerAliveInterval [seconds]"</span> configuration <span class="keyword">in</span> the SSH configuration so that your ssh client sends a <span class="string">"dummy packet"</span> on a regular interval so that the router thinks that the connection is active even <span class="keyword">if</span> it<span class="string">'s particularly quiet</span></span></span><br><span class="line">ServerAliveInterval=15</span><br><span class="line"><span class="meta">#</span><span class="bash">ServerAliveCountMax=6</span></span><br><span class="line">ForwardAgent=yes</span><br><span class="line"></span><br><span class="line">UserKnownHostsFile /dev/null</span><br></pre></td></tr></table></figure><p>在你的 SSH 配置文件增加上述参数，意味着 72 小时内登录同一台跳板机只有第一次需要输入密码，以后都是重用之前的连接，所以也就不再需要输入密码了。</p><p>加了如上参数后的登录过程就有这样的东东(默认没有，这是 Debug 信息)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">debug1: setting up multiplex master socket</span><br><span class="line">debug3: muxserver_listen: temporary control path   &#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.**_22_corp.86g3C34vy36tvCtn</span><br><span class="line">debug2: fd 3 setting O_NONBLOCK</span><br><span class="line">debug3: fd 3 is O_NONBLOCK</span><br><span class="line">debug3: fd 3 is O_NONBLOCK</span><br><span class="line">debug1: channel 0: new [&#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.*.*_22_corp]</span><br><span class="line">debug3: muxserver_listen: mux listener channel 0 fd 3</span><br><span class="line">debug1: control_persist_detach: backgrounding master process</span><br><span class="line">debug2: control_persist_detach: background process is 15154</span><br><span class="line">debug2: fd 3 setting O_NONBLOCK</span><br><span class="line">debug1: forking to background</span><br><span class="line">debug1: Entering interactive session.</span><br><span class="line">debug2: set_control_persist_exit_time: schedule exit in 259200 seconds</span><br><span class="line">debug1: multiplexing control connection</span><br></pre></td></tr></table></figure><p><code>/home/ren/tmp/ssh_mux_10.16.*.*_22_corp</code> 这个就是保存好的 Socket，下次可以重用，免密码。 in 259200 seconds 对应 72小时</p><h2><span id="我有很多不同机房或者说不同客户的机器都需要跳板机来登录能一次直接-ssh-上去吗">我有很多不同机房（或者说不同客户）的机器都需要跳板机来登录，能一次直接 SSH 上去吗？</span></h2><p>比如有一批客户机房的机器 IP 都是 192.168.<em>.</em>, 然后需要走跳板机 100.10.1.2 才能访问到，那么我希望以后<strong>在笔记本上直接 ssh 192.168.1.5 就能直接连上</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;ssh&#x2F;ssh_config</span><br><span class="line"></span><br><span class="line">Host 192.168.*.*</span><br><span class="line">ProxyCommand ssh -l ali-renxijun 100.10.1.2 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br></pre></td></tr></table></figure><p>上面配置的意思是执行 <code>ssh 192.168.1.5</code> 的时候命中规则 <code>Host 192.168.*.*</code> 所以执行 <code>ProxyCommand</code> 先连上跳板机再通过跳板机连向 192.168.1.5 。这样在你的笔记本上就跟 192.168.<em>.</em> 的机器仿佛在一起，SSH 可以上去，但是 ping 不通这个 192.168.1.5 的 IP</p><p><strong>划重点：公司的线上跳板机做了特殊限制，限制了这个技能。日常环境跳板机支持这个功能</strong></p><p>比如我的跳板配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#到美国的机器用美国的跳板机速度更快</span><br><span class="line">Host 10.74.*</span><br><span class="line">ProxyCommand ssh -l user us.jump exec &#x2F;bin&#x2F;nc %h %p 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">#到中国的机器用中国的跳板机速度更快</span><br><span class="line">Host 10.70.*</span><br><span class="line">ProxyCommand ssh -l user cn.jump exec &#x2F;bin&#x2F;nc %h %p 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">   </span><br><span class="line">Host 192.168.0.*</span><br><span class="line">ProxyCommand ssh -l user 1.1.1.1 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br></pre></td></tr></table></figure><p>其实我的配置文件里面还有很多规则，懒得一个个隐藏 IP 了，这些规则是可以重复匹配的</p><p>来看一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ren@ren-VirtualBox:&#x2F;$ ping -c 1 10.16.1.*</span><br><span class="line">        PING 10.16.1.* (10.16.1.*) 56(84) bytes of data.^C</span><br><span class="line">    --- 10.16.1.* ping statistics ---</span><br><span class="line">    1 packets transmitted, 0 received, 100% packet loss, time 0ms</span><br><span class="line">    </span><br><span class="line">ren@ren-VirtualBox:~$ ssh -l corp 10.16.1.* -vvv</span><br><span class="line">OpenSSH_6.7p1 Ubuntu-5ubuntu1, OpenSSL 1.0.1f 6 Jan 2014</span><br><span class="line">debug1: Reading configuration data &#x2F;home&#x2F;ren&#x2F;.ssh&#x2F;config</span><br><span class="line">debug1: Reading configuration data &#x2F;etc&#x2F;ssh&#x2F;ssh_config</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 28: Applying options for *</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 44: Applying options for 10.16.*.*</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 68: Applying options for *</span><br><span class="line">debug1: auto-mux: Trying existing master</span><br><span class="line">debug1: Control socket &quot;&#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.1.*_22_corp&quot; does not exist</span><br><span class="line">debug1: Executing proxy command: exec ssh -l corp 139.*.*.* exec &#x2F;usr&#x2F;bin&#x2F;nc 10.16.1* 22</span><br></pre></td></tr></table></figure><p>本来我的笔记本跟 10.16.1.* 是不通的(ping 不通），但是 SSH 可以直接连上，实际 SSH 登录过程中自动走跳板机 139.<em>.</em>.* 就连上了</p><p><code>-vvv</code> 参数是 debug，把 SSH 登录过程的日志全部打印出来。</p><h2><span id="将隔离环境中的-web-端口映射到本地本地代理">将隔离环境中的 Web 端口映射到本地（本地代理）</span></h2><p>远程机器部署了 Web Server（端口 8083），需要通过浏览器来访问这个 WEB 服务，但是 server 在隔离环境中，只能通过 SSH 访问到。一般来说会在隔离环境中部署一个 Windows 机器，通过这个 Windows 机器来访问到这个 Web Server。能不能省掉这个 Windows 机器呢？</p><p>现在我们试着用 SSH 来实现本地浏览器直接访问到这个隔离环境中的 Web Server。</p><p>假设 Web Server 是：10.1.1.123:8083， SSH 账号是：user</p><p>先配置好本地直接 <code>ssh user@10.1.1.123</code> （参考前面的 <code>ProxyCommand</code> 配置过程，最好是免密也配置好），然后在你的笔记本上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CNfL 0.0.0.0:8088:10.1.1.123:8083 user@10.1.1.123</span><br></pre></td></tr></table></figure><p>或者：(<a href="mailto:root@100.1.2.3">root@100.1.2.3</a> -p 54900 是可达10.1.1.123的代理服务器)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CNfL 0.0.0.0:8089:10.1.1.123:8083 root@100.1.2.3 -p 54900</span><br></pre></td></tr></table></figure><p>这表示在本地启动一个 8088 的端口，将这个 8088 端口映射到 10.1.1.123 的 8083 端口上，用的 SSH 账号是 user</p><p>然后在笔记本上的浏览器中输入：127.0.0.1:8088 就看到了如下界面：</p><p><img src="https://img.hi-linux.com/staticfile/bOUSWh-2024-01-22-CPWM1b.png" alt></p><p>反过来，<strong>也可以让隔离环境机器通过代理上网，比如安装 yum</strong></p><h2><span id="为什么有时候-ssh-比较慢比如总是需要-30-秒钟后才能正常登录">为什么有时候 SSH 比较慢，比如总是需要 30 秒钟后才能正常登录</span></h2><p>先了解如下知识点，在 ~/.ssh/config 配置文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GSSAPIAuthentication&#x3D;no</span><br></pre></td></tr></table></figure><p>禁掉 GSSAPI 认证，GSSAPIAuthentication 是个什么鬼东西请自行 Google (多一次没必要的授权认证过程，然后等待超时)。 这里要理解 SSH 登录的时候有很多种认证方式（公钥、密码等等），具体怎么调试请记住强大的命令参数 <code>ssh -vvv</code> 上面讲到的技巧都能通过 <code>-vvv</code> 看到具体过程。</p><p>比如我第一次碰到 ssh 比较慢总是需要 30 秒后才登录，不能忍受，于是登录的时候加上 -vvv 明显看到控制台停在了：GSSAPIAuthentication 然后 Google 了一下，禁掉就好了</p><p>当然还有去掉每次 SSH 都需要先输入 Yes</p><h2><span id="批量打通所有机器之间的-ssh-登录免密码">批量打通所有机器之间的 SSH 登录免密码</span></h2><p><strong>Expect 在有些公司是被禁止的</strong></p><p>SSH 免密码的原理是将本机的 Pubkey 复制到目标机器的 <code>~/.ssh/authorized_keys</code> 里面。可以手工复制粘贴，也可以 ssh-copy-id 等。</p><p>如果有 100 台机器，互相两两打通还是比较费事（大概需要100*99次 copy key）。 下面通过 expect 来解决输入密码，然后配合 Shell 脚本来批量解决这个问题。</p><p><img src="https://img.hi-linux.com/staticfile/OkaCp5-2024-01-22-dxXOti.png" alt></p><p>这个脚本需要四个参数：目标IP、用户名、密码、Home 目录，也就是 SSH 到一台机器的时候帮我们自动填上 yes，和密码，这样就不需要人肉一个个输入了。</p><p>再在外面写一个循环对每个 IP 执行如下操作：</p><p><img src="https://img.hi-linux.com/staticfile/S3qQYl-2024-01-22-BqCQTy.png" alt></p><p>if 代码部分检查本机 ~/.ssh/ 下有没有 id_rsa.pub，也就是是否以前生成过密钥对，没生成的话就帮忙生成一次。</p><p>for 循环部分一次把生成的密钥对和 authorized_keys 复制到所有机器上，这样所有机器之间都不需要输入密码就能互相登陆了（当然本机也不需要输入密码登录所有机器）</p><p>最后一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh $user@$n &quot;hostname -i&quot;</span><br></pre></td></tr></table></figure><p>验证一下没有输密码是否能成功 SSH 上去。</p><p><strong>思考一下，为什么这么做就可以打通两两之间的免密码登录，这里没有把所有机器的 PubKey 复制到其他所有机器上去啊</strong></p><blockquote><p>答案：其实这个脚本做了一个取巧投机的事，那就是让所有机器共享一套公钥、私钥。<br>有时候我也会把我的 Windows 笔记本和我专用的某台虚拟机共享一套秘钥，这样任何新申请的机器打通一次账号就可以在两台机器上随便登录。请保护好自己的私钥</p></blockquote><p>如果免密写入 authorized_keys 成功，但是通过 SSH Pubkey 认证的时候还是有可能失败，这是因为 Pubkey 认证要求：</p><ul><li>authorized_keys  文件权限要对</li><li>.ssh 文件夹权限要对</li><li>/home/user 文件夹权限要对 ----这个容易忽视掉</li></ul><h2><span id="留个作业第一次-ssh-某台机器的时候总是出来一个警告需要-yes-确认才能往下走怎么干掉他">留个作业：第一次 SSH 某台机器的时候总是出来一个警告，需要 Yes 确认才能往下走，怎么干掉他？</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; StrictHostKeyChecking&#x3D;no</span><br><span class="line">&gt; UserKnownHostsFile&#x3D;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p><strong>这里只是帮大家入门了解 SSH ，掌握好这些配置文件和 -vvv 后有好多好玩的可以去挖掘，同时也请在留言中说出你的黑技能</strong></p><h2><span id="~sshconfig-参考配置">~/.ssh/config 参考配置</span></h2><p>下面是我个人常用的 SSH Config 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat ~/.ssh/config</span></span><br><span class="line"><span class="meta">#</span><span class="bash">GSSAPIAuthentication=no</span></span><br><span class="line">StrictHostKeyChecking=no</span><br><span class="line"><span class="meta">#</span><span class="bash">TCPKeepAlive=yes</span></span><br><span class="line">CheckHostIP=no</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"ServerAliveInterval [seconds]"</span> configuration <span class="keyword">in</span> the SSH configuration so that your ssh client sends a <span class="string">"dummy packet"</span> on a regular interval so that the router thinks that the connection is active even <span class="keyword">if</span> it<span class="string">'s particularly quiet</span></span></span><br><span class="line">ServerAliveInterval=15</span><br><span class="line"><span class="meta">#</span><span class="bash">ServerAliveCountMax=6</span></span><br><span class="line">ForwardAgent=yes</span><br><span class="line"></span><br><span class="line">UserKnownHostsFile /dev/null</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">reuse the same connection</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath /tmp/ssh_mux_%h_%p_%r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">keep one connection <span class="keyword">in</span> 72hour</span></span><br><span class="line">ControlPersist 72h</span><br><span class="line"></span><br><span class="line">Host 192.168.1.*</span><br><span class="line">ProxyCommand ssh user@us.jump exec /usr/bin/nc %h %p 2&gt;/dev/null</span><br><span class="line">Host 192.168.2.*</span><br><span class="line">ProxyCommand ssh user@cn.jump exec /usr/bin/nc %h %p 2&gt;/dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash">ProxyCommand /bin/nc -x localhost:12346 %h %p</span></span><br><span class="line"></span><br><span class="line">Host 172</span><br><span class="line">    HostName 10.172.1.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump root@1.2.3.4:12345</span><br><span class="line"></span><br><span class="line">Host 176</span><br><span class="line">    HostName 10.176.1.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump admin@1.2.3.4:12346</span><br><span class="line">    </span><br><span class="line">Host 10.5.*.*, 10.*.*.*</span><br><span class="line">    port 22</span><br><span class="line">user root</span><br><span class="line">ProxyJump plantegg@1.2.3.4:12347</span><br></pre></td></tr></table></figure><p>ProxyJump 完全可以取代 ProxyCommand，比如 ProxyJump 不再依赖 nc、也更灵活一些。</p><h2><span id="etcsshssh_config-参考配置">/etc/ssh/ssh_config 参考配置</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">Protocol 2</span><br><span class="line">ServerAliveInterval 30</span><br><span class="line">User admin</span><br><span class="line"></span><br><span class="line">host 10.10.55.*</span><br><span class="line">ProxyCommand ssh -l admin admin.jump  exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line"># uos is a hostname</span><br><span class="line">Host 10.10.1.13* 192.168.2.133 uos</span><br><span class="line">ProxyCommand ssh -l root -p 54900 1.1.1.1 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line">#debug for git proxy</span><br><span class="line">Host github.com</span><br><span class="line">#    LogLevel DEBUG3</span><br><span class="line">#    ProxyCommand ssh  -l root gfw.jump exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line">#    ProxyCommand ssh -oProxyCommand&#x3D;&#39;ssh -l admin gfw.jump:22&#39; -l root gfw.jump2 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ForwardAgent yes</span><br><span class="line">ForwardX11 yes</span><br><span class="line">ForwardX11Trusted yes</span><br><span class="line"></span><br><span class="line">    SendEnv LANG LC_*</span><br><span class="line">    HashKnownHosts yes</span><br><span class="line">    GSSAPIAuthentication no</span><br><span class="line">    GSSAPIDelegateCredentials no</span><br><span class="line">    Compression yes</span><br></pre></td></tr></table></figure><h2><span id="其他知识点">其他知识点</span></h2><p>参数的优先级是：<strong>命令行配置选项 &gt; ~/.ssh/config &gt; /etc/ssh/ssh_config</strong></p><p>在 SSH 的 <strong>身份验证阶段，SSH只支持服务端保留公钥，客户端保留私钥的方式</strong>，所以方式只有两种：客户端生成密钥对，将公钥分发给服务端；服务端生成密钥对，将私钥分发给客户端。只不过出于安全性和便利性，一般都是客户端生成密钥对并分发公钥（阿里云服务器秘钥对–服务器将一对密钥中的公钥放在 authorized_keys, 私钥给client登陆用）</p><p>服务器上的 <code>/etc/ssh/ssh_host*</code> 是用来验证服务器身份的秘钥对（对应 Client的 Known_hosts), <strong>在主机验证阶段，服务端持有的是私钥，客户端保存的是来自于服务端的公钥。注意，这和身份验证阶段密钥的持有方是相反的。</strong></p><p>SSH 支持多种身份验证机制，<strong>它们的验证顺序如下：gssapi-with-mic,hostbased,publickey,keyboard-interactive,password</strong>，但常见的是密码认证机制 (password) 和公钥认证机制 (public key). 当公钥认证机制未通过时，再进行密码认证机制的验证。这些认证顺序可以通过 SSH 配置文件(注意，不是sshd 的配置文件)中的指令 PreferredAuthentications 改变。</p><h3><span id="永久隧道">永久隧道</span></h3><p>大多时候隧道会失效，或者断开，我们需要有重连机制，一般可以通过 autossh（需要单独安装）搞定自动重连，再配合 Systemd 或者 Crond 搞定永久自动重连</p><p>比如以下代码在 gf 开启 2 个远程转发端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">remote_port&#x3D;(30081 30082)</span><br><span class="line">for port in &quot;$&#123;remote_port[@]&#125;&quot;</span><br><span class="line">do</span><br><span class="line">    line&#x3D;&#96;ps aux |grep ssh |grep $port | wc -l&#96;</span><br><span class="line">    if [[ &quot;$line&quot; -lt 1 ]]; then</span><br><span class="line">        autossh -M 0 -fNR gf:$port:127.0.0.1:22 root@gf</span><br><span class="line">    fi;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">line&#x3D;&#96;ps aux |grep ssh |grep 13129 | wc -l&#96;</span><br><span class="line">if [[ &quot;$line&quot; -lt 1 ]]; then</span><br><span class="line">    nohup ssh -fNR gf:13129:172.16.1.2:3129 root@gf</span><br><span class="line">fi;</span><br><span class="line"></span><br><span class="line">#cat &#x2F;etc&#x2F;cron.d&#x2F;jump</span><br><span class="line">#* * * * * root sh &#x2F;root&#x2F;drds_private_cloud&#x2F;jump.sh</span><br></pre></td></tr></table></figure><p>或者另外创建一个 Service 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;AutoSSH tunnel on 31081 to gf server</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment&#x3D;&quot;AUTOSSH_GATETIME&#x3D;0&quot;</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;autossh -M 0 -q -N -o &quot;ServerAliveInterval 60&quot; -o &quot;ServerAliveCountMax 3&quot; -NR gf:31081:172.16.1.2:22 -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa root@gf</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><h3><span id="调试-ssh终极大招">调试 SSH–终极大招</span></h3><p>好多问题我都是 Debug 发现的</p><ul><li>客户端增加参数 -vvv 会把所有流程在控制台显示出来。卡在哪个环节；密码不对还是 Key 不对一看就知道</li><li>server 端还可以：<code>/usr/sbin/sshd -ddd -p 2222</code> 在 2222 端口对 sshd 进行 Debug，看输出信息验证为什么 pubkey 不能 Login 等. 一般都是权限不对，/root 以及 /root/.ssh 文件夹的权限和owner都要对，更不要说 /root/.ssh/authorized_keys 了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;sshd -ddd -p 2222</span><br></pre></td></tr></table></figure><h3><span id="ssh-提示信息"></span></h3><p>可以用一下脚本生成一个彩色文件，放到 /etc/motd 中就行</p><p>Basic colors are numbered:</p><ul><li>1 – Red</li><li>2 – Green</li><li>3 – Yellow</li><li>4 – Blue</li><li>5 – Magenta</li><li>6 – Cyan</li><li>7 – White</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">export TERM=xterm-256color</span><br><span class="line"></span><br><span class="line">read one five fifteen rest &lt; /proc/loadavg</span><br><span class="line">echo "$(tput setaf 2)</span><br><span class="line">Kernel: `uname -v | awk -v OFS=' ' '&#123;print $4, $5&#125;'`</span><br><span class="line">                                                                                                                                   </span><br><span class="line">        \\   ^__^</span><br><span class="line">         \\  (oo)\\_______</span><br><span class="line">            (__)\\       )\\\/\\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br><span class="line"></span><br><span class="line">本机器为长稳测试环境, 千万不要kill进程, 不要跑负载过重的任务</span><br><span class="line"></span><br><span class="line">有任何需要请联系 ** 多谢!</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput setaf 4)Load Averages......: <span class="variable">$&#123;one&#125;</span>, <span class="variable">$&#123;five&#125;</span>, <span class="variable">$&#123;fifteen&#125;</span> (1, 5, 15 min)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput setaf 5)</span></span><br><span class="line"> ______________</span><br><span class="line">本机器为长稳测试环境, 千万不要kill进程, 不要跑负载过重的任务</span><br><span class="line"></span><br><span class="line">有任何需要请联系 ** 多谢!</span><br><span class="line"> --------------</span><br><span class="line">        \\   ^__^</span><br><span class="line">         \\  (oo)\\_______</span><br><span class="line">            (__)\\       )\\\/\\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput sgr0)<span class="string">"</span></span></span><br></pre></td></tr></table></figure><p>以上脚本运行结果</p><p><img src="https://img.hi-linux.com/staticfile/8Hcheo-2024-01-22-Cpn0tg.png" alt></p><h3><span id="sshd-banner">SSHD Banner</span></h3><p><code>Banner</code>指定用户登录后，sshd 向其展示的信息文件（<code>Banner /usr/local/etc/warning.txt</code>），默认不展示任何内容。</p><p>或者配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"># no default banner path</span><br><span class="line">#Banner none</span><br><span class="line">#在配置文件末尾添加Banner &#x2F;etc&#x2F;ssh&#x2F;my_banner这一行内容：</span><br><span class="line">Banner &#x2F;etc&#x2F;ssh&#x2F;my_banner</span><br></pre></td></tr></table></figure><p><code>/etc/ssh/my_banner</code> 中可以放置提示内容。</p><h3><span id="验证秘钥对">验证秘钥对</span></h3><p><strong>-y</strong> Read a private OpenSSH format file and print an OpenSSH public key to stdout.</p><blockquote><p>cd ~/.ssh/ ; ssh-keygen -y -f id_rsa | cut -d’ ’ -f 2  ;  cut -d’ ’ -f 2 id_rsa.pub</p></blockquote><p><code>ssh-keygen -y -e -f &lt;private key&gt;</code>获取一个私钥并打印相应的公钥，该公钥可以直接与您可用的公钥进行比较</p><h3><span id="github-上你的公钥">Github 上你的公钥</span></h3><p>Github 可以取到你的公钥，如果别人让你查看他的服务器，直接给 <a href="https://github.com/plantegg.keys" target="_blank" rel="noopener">https://github.com/plantegg.keys</a> 这个链接，让他把下载的 Key 加到 ~/.ssh/authorized_keys 里面就行了。</p><h3><span id="通过-ssh-keygen-生成公钥">通过 ssh-keygen 生成公钥</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &lt;&lt;&lt;y</span><br><span class="line">ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &lt;&lt;&lt;y &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">//修改 Passphrase</span><br><span class="line">ssh-keygen -p -P "12345" -N "abcde" -f .ssh/id_rsa</span><br><span class="line">//ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]</span><br><span class="line">//或者直接通过提示一步步修改：</span><br><span class="line">ssh-keygen -p</span><br></pre></td></tr></table></figure><p>删除或者修改 Passphrase</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; run &#96;ssh-keygen -p&#96; in a terminal. It will then prompt you for a keyfile (defaulted to the correct file for me, &#96;~&#x2F;.ssh&#x2F;id_rsa&#96;), the old passphrase (enter what you have now) and the new passphrase (enter nothing). </span><br><span class="line"></span><br><span class="line">[要注意 OpenSSH 不同版本使用的不同 format](https:&#x2F;&#x2F;www.ibm.com&#x2F;support&#x2F;pages&#x2F;openssl-wont-understand-rsa-keys-rfc4716-format)，用 OpenSSH 8.0 默认用 &quot;RFC4716&quot; 格式，老的 4.0 默认是 PKCS8 格式</span><br><span class="line"></span><br><span class="line">去修改 DSA 密钥后 Openssh 4.0 不认。 </span><br><span class="line"></span><br><span class="line">&gt; -m key_format</span><br><span class="line">&gt;         Specify a key format for the -i (import) or -e (export) conversion options.  The sup‐</span><br><span class="line">&gt;         ported key formats are: “RFC4716” (RFC 4716&#x2F;SSH2 public or private key), “PKCS8” (PEM</span><br><span class="line">&gt;         PKCS8 public key) or “PEM” (PEM public key).  The default conversion format is</span><br><span class="line">&gt;         “RFC4716”.</span><br></pre></td></tr></table></figure><p>如果用 8.0 去修改 PKCS8 格式的 key 可以指定格式参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p  -m &quot;PKCS8&quot; -f .&#x2F;id_dsa</span><br></pre></td></tr></table></figure><h3><span id="ssh-agent">SSH-Agent</span></h3><p>私钥设置了密码以后，每次使用都必须输入密码，有时让人感觉非常麻烦。比如，连续使用<code>scp</code>命令远程拷贝文件时，每次都要求输入密码。</p><p><code>ssh-agent</code>命令就是为了解决这个问题而设计的，它让用户在整个 Bash 对话（session）之中，只在第一次使用 SSH 命令时输入密码，然后将私钥保存在内存中，后面都不需要再输入私钥的密码了。</p><p>第一步，使用下面的命令新建一次命令行对话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval &#96;ssh-agent&#96;</span><br></pre></td></tr></table></figure><p>上面命令中，<code>ssh-agent</code> 会先自动在后台运行，并将需要设置的环境变量输出在屏幕上，类似下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent</span><br><span class="line">SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-barrett&#x2F;ssh-22841-agent; export SSH_AUTH_SOCK;</span><br><span class="line">SSH_AGENT_PID&#x3D;22842; export SSH_AGENT_PID;</span><br><span class="line">echo Agent pid 22842;</span><br></pre></td></tr></table></figure><p><code>eval</code>命令的作用，就是运行上面的 <code>ssh-agent</code> 命令的输出，设置环境变量。</p><p>第二步，在新建的 Shell 对话里面，使用 <code>ssh-add</code> 命令添加默认的私钥（比如<code>~/.ssh/id_rsa</code>，或<code>~/.ssh/id_dsa</code>，或<code>~/.ssh/id_ecdsa</code>，或<code>~/.ssh/id_ed25519</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add</span><br><span class="line">Enter passphrase for &#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa: ********</span><br><span class="line">Identity added: &#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa (&#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa)</span><br></pre></td></tr></table></figure><p>上面例子中，添加私钥时，会要求输入密码。以后，在这个对话里面再使用密钥时，就不需要输入私钥的密码了，因为私钥已经加载到内存里面了。</p><p>如果添加的不是默认私钥，<code>ssh-add</code>命令需要显式指定私钥文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add my-other-key-file</span><br></pre></td></tr></table></figure><p>上面的命令中，<code>my-other-key-file</code>就是用户指定的私钥文件。</p><p>SSH agent 程序能够将您的已解密的私钥缓存起来，在需要的时候用它来解密key chanllge返回给 SSHD  <a href="https://webcache.googleusercontent.com/search?q=cache:7OfvSBFki10J:https://www.ibm.com/developerworks/cn/linux/security/openssh/part2/+&amp;cd=7&amp;hl=en&amp;ct=clnk&amp;gl=hk" target="_blank" rel="noopener">https://webcache.googleusercontent.com/search?q=cache:7OfvSBFki10J:https://www.ibm.com/developerworks/cn/linux/security/openssh/part2/+&amp;cd=7&amp;hl=en&amp;ct=clnk&amp;gl=hk</a> keychain介绍</p><h3><span id="安装-sshd-和-debug">安装 sshd 和 debug</span></h3><p>sshd 有自己的一对或多对密钥。它使用密钥向客户端证明自己的身份。所有密钥都是公钥和私钥成对出现，公钥的文件名一般是私钥文件名加上后缀<code>.pub</code>。</p><p>DSA 格式的密钥文件默认为 <code>/etc/ssh/ssh_host_dsa_key</code>（公钥为<code>ssh_host_dsa_key.pub</code>），RSA 格式的密钥为 <code>/etc/ssh/ssh_host_rsa_key</code>（公钥为 <code>ssh_host_rsa_key.pub</code>）。如果需要支持 SSH 1 协议，则必须有密钥<code>/etc/ssh/ssh_host_key</code>。</p><p>如果密钥不是默认文件，那么可以通过配置文件 <code>sshd_config</code> 的 <code>HostKey</code> 配置项指定。默认密钥的 <code>HostKey</code> 设置如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># HostKey for protocol version 1</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_key</span><br><span class="line"></span><br><span class="line"># HostKeys for protocol version 2</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_key</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_dsa_ke</span><br></pre></td></tr></table></figure><p>注意，如果重装 sshd，<code>/etc/ssh</code>下的密钥都会重新生成（这些密钥对用于验证Server的身份），导致客户端重新 ssh 连接服务器时，会跳出警告，拒绝连接。为了避免这种情况，可以在重装 sshd 时，先备份<code>/etc/ssh</code>目录，重装后再恢复这个目录。</p><blockquote><p>调试：非后台(-D)和debug(-d)模式启动sshd，同时监听2222和3333端口</p><p>sshd -D -d -p 2222 -p 3333</p></blockquote><p>sshd config 配置多端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line">Port 22022</span><br><span class="line">Port 22</span><br><span class="line">#AddressFamily any</span><br><span class="line">#ListenAddress 0.0.0.0</span><br></pre></td></tr></table></figure><h3><span id="scp-设置-socks-代理">Scp 设置 socks 代理</span></h3><blockquote><p>scp -o “ProxyCommand=nc -X 5 -x <strong>[SOCKS_HOST]</strong>:<strong>[SOCKS_PORT]</strong> %h %p” <strong>[LOCAL/FILE/PATH]</strong> <strong>[REMOTE_USER]</strong>@<strong>[REMOTE_HOST]</strong>:<strong>[REMOTE/FILE/PATH]</strong></p></blockquote><p>其中[SOCKS_HOST]和[SOCKS_PORT]是 Socks 代理的 LOCAL_ADDRESS 和 LOCAL_PORT。[LOCAL/FILE/PATH]、[REMOTE_USER]、[REMOTE_HOST]和[REMOTE/FILE/PATH] 分别是要复制文件的本地路径、要复制到的远端主机的用户名、要复制到的远端主机名、要复制文件的远端路径，这些参数与不使用代理时一样。“ProxyCommand=nc” 表示当前运行命令的主机上需要有 nc 命令。</p><h3><span id="proxycommand">ProxyCommand</span></h3><blockquote><p>Specifies the proxy command for the connection. This command is launched prior to making the connection to Hostname. %h is replaced with the host defined in HostName and %p is replaced with 22 or is overridden by a Port directive.</p></blockquote><p>在 SSH 连接目标主机前先执行 ProxyCommand 中的命令，比如 <code>.ssh/config</code> 中有如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">host remote-host</span><br><span class="line">ProxyCommand ssh -l root -p 52146 1.2.3.4 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以上配置等价下面的命令</span><br><span class="line">ssh -o ProxyCommand&#x3D;&quot;ssh -l root -p 52146 1.2.3.4 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p&quot; remote-host</span><br><span class="line">&#x2F;&#x2F;or 等价</span><br><span class="line">ssh -o ProxyCommand&#x3D;&quot;ssh -l root -p 52146 -W %h:%p 1.2.3.4 &quot; remote-host</span><br><span class="line">&#x2F;&#x2F;or 等价 debug1: Setting implicit ProxyCommand from ProxyJump: ssh -l root -p 52146 -vvv -W &#39;[%h]:%p&#39; 1.2.3.4</span><br><span class="line">ssh -J root@1.2.3.4:52146 remote-host</span><br></pre></td></tr></table></figure><p>如上配置指的是，如果执行ssh remote-host 命中host规则，那么先执行命令 ssh -l root -p 52146 1.2.3.4 exec /usr/bin/nc 同时把remote-host和端口(默认22)传给nc</p><p>ProxyCommand 和 ProxyJump 很类似，ProxyJump 使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ssh到centos8机器上，走的是gf这台跳板机，本地一般和centos8不通</span><br><span class="line">ssh -J gf:22 centos8</span><br></pre></td></tr></table></figure><h3><span id="proxyjump">ProxyJump</span></h3><p>需要 <code>OpenSSH 7.3</code> 以上版本才可以使用 <code>ProxyJump</code>, 相对 ProxyCommand 更简洁方便些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ssh 116 就可以通过 jumpserver:50023 连上 root@1.116.2.1:22</span><br><span class="line">Host 116</span><br><span class="line">    HostName 1.116.2.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump admin@jumpserver:50023</span><br><span class="line"></span><br><span class="line">#ssh 1.112.任意ip 都会默认走 jumpserver 跳转过去</span><br><span class="line">Host 1.112.*.*</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump root@jumpserver</span><br></pre></td></tr></table></figure><h3><span id="加密算法"></span></h3><p>列出本地所支持默认的加密算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#ssh -Q key                                                            </span><br><span class="line">ssh-ed25519</span><br><span class="line">ssh-ed25519-cert-v01@openssh.com</span><br><span class="line">ssh-rsa</span><br><span class="line">ssh-dss</span><br><span class="line">ecdsa-sha2-nistp256</span><br><span class="line">ecdsa-sha2-nistp384</span><br><span class="line">ecdsa-sha2-nistp521</span><br><span class="line">ssh-rsa-cert-v01@openssh.com</span><br><span class="line">ssh-dss-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp256-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp384-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp521-cert-v01@openssh.com</span><br><span class="line"></span><br><span class="line">ssh -Q cipher       # List supported ciphers</span><br><span class="line">ssh -Q mac          # List supported MACs</span><br><span class="line">ssh -Q key          # List supported public key types</span><br><span class="line">ssh -Q kex          # List supported key exchange algorithms</span><br></pre></td></tr></table></figure><p>比如连服务器报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug1: kex: algorithm: (no match)</span><br><span class="line">Unable to negotiate with server port 22: no matching key exchange method found. Their offer: diffie-hellman-group1-sha1,diffie-hellman-group14-sha1</span><br></pre></td></tr></table></figure><p>表示服务端支持 diffie-hellman-group1-sha1,diffie-hellman-group14-sha1 加密，但是client端不支持，那么可以指定算法来强制client端使用某种和server一致的加密方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh  -oKexAlgorithms&#x3D;+diffie-hellman-group14-sha1 -l user</span><br><span class="line"></span><br><span class="line">或者config中配置：</span><br><span class="line">host server_ip</span><br><span class="line">KexAlgorithms +diffie-hellman-group1-sha1</span><br></pre></td></tr></table></figure><p>如果仍然报以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debug2: first_kex_follows 0</span><br><span class="line">debug2: reserved 0</span><br><span class="line">debug1: kex: algorithm: diffie-hellman-group14-sha1</span><br><span class="line">debug1: kex: host key algorithm: (no match)</span><br><span class="line">Unable to negotiate with server_ip port 22: no matching host key type found. Their offer: ssh-rsa</span><br></pre></td></tr></table></figure><p>那么可以配置来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">    HostKeyAlgorithms +ssh-rsa</span><br><span class="line">    PubkeyAcceptedKeyTypes +ssh-rsa</span><br></pre></td></tr></table></figure><p>When an SSH client connects to a server, each side offers lists of connection parameters to the other. These are, with the corresponding <a href="https://man.openbsd.org/ssh_config.5" target="_blank" rel="noopener">ssh_config</a> keyword:</p><ul><li><code>KexAlgorithms</code>: the key exchange methods that are used to generate per-connection keys</li><li><code>HostkeyAlgorithms</code>: the public key algorithms accepted for an SSH server to authenticate itself to an SSH client</li><li><code>Ciphers</code>: the ciphers to encrypt the connection</li><li><code>MACs</code>: the message authentication codes used to detect traffic modification</li></ul><h2><span id="无所不能的-ssh-三大转发模式">无所不能的 SSH 三大转发模式</span></h2><p>了解完前面的一些小知识，再来看看无所不能的三大杀招。上面的各种代理基本都是由这三种转发模式实现的。</p><p>SSH 能够做动态转发、本地转发、远程转发。先简要概述下他们的特点和使用场景</p><p><strong><a href="https://www.skywind.me/blog/archives/2546" target="_blank" rel="noopener">三个转发模式的比较</a>：</strong></p><ul><li>动态转发完全可以代替本地转发，只是动态转发是 <code>socks5协议</code>，当正确上网用，本地转发是 TCP 协议</li><li>本地转发完全是把动态转发特例化到访问某个固定目标的转发，类似 Iptable 的 Port Forwarding</li><li>远程转发是启动转端口的机器同时连上两端的两个机器，把本来不连通的两端拼接起来，中间显得多了个节点。</li><li>三个转发模式可以串联使用</li></ul><p>动态转发常用来正确上网，本地转发用来打洞，这两种转发启动的端口都是在本地；远程转发也是打洞的一种，只不过启用的端口在远程机器上。</p><p><img src="https://img.hi-linux.com/staticfile/sKbEgK-2024-01-22-mnPbqn.png" alt></p><h3><span id="动态转发-d-socks5-协议">动态转发 (-D)  SOCKS5 协议</span></h3><p>动态转发指的是，本机与 SSH 服务器之间创建了一个加密连接，然后本机内部针对某个端口的通信，都通过这个加密连接转发。它的一个使用场景就是，访问所有外部网站，都通过 SSH 转发。</p><p>动态转发需要把本地端口绑定到 SSH 服务器。<strong>至于 SSH 服务器要去访问哪一个网站，完全是动态的，取决于原始通信，所以叫做动态转发</strong>。</p><p>动态的意思就是：需要访问的目标、端口还不确定。后面要讲的本地转发、远程转发都是针对具体 IP、Port 的转发。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -D 4444 ssh-server -N</span></span><br><span class="line">//或者如下方式：</span><br><span class="line">nohup ssh -qTfnN -D *:13658 root@jump vmstat 10  &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>注意，这种转发采用了 SOCKS5 协议。访问外部网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。<code>-N</code>参数表示，这个 SSH 连接不能执行远程命令，只能充当隧道。</p><p><img src="https://img.hi-linux.com/staticfile/8wIxNP-2024-01-22-qJOasK.png" alt></p><p>下面是 SSH  隧道建立后的一个<strong>使用实例</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -x socks5://localhost:4444 http://www.example.com</span><br><span class="line">or</span><br><span class="line">curl --socks5-hostname localhost:4444 https://www.twitter.com</span><br></pre></td></tr></table></figure><p>上面命令中，curl 的 <code>-x</code> 参数指定代理服务器，即通过 SOCKS5 协议的本地<code>3000</code>端口，访问<code>http://www.example.com</code>。</p><p>官方文档关于 <code>-D</code> 的介绍</p><blockquote><p>-D [bind_address:]port<br>Specifies a local “dynamic” application-level port forwarding.  This works by allocat‐<br>ing a socket to listen to port on the local side, optionally bound to the specified<br>bind_address.  Whenever a connection is made to this port, the connection is forwarded<br>over the secure channel, and the application protocol is then used to determine where<br>to connect to from the remote machine.  Currently the SOCKS4 and SOCKS5 protocols are<br>supported, and ssh will act as a SOCKS server.  Only root can forward privileged ports.<br>Dynamic port forwardings can also be specified in the configuration file.</p></blockquote><p>特别注意，如果 <code>ssh -D</code> 要启动的本地 Port 已经被占用了是不会报错的，但是实际 Socks 代理会没启动成功。</p><h3><span id="本地转发-l">本地转发 (-L)</span></h3><p>本地转发（Local Forwarding）指的是，SSH 服务器作为中介的跳板机，建立本地计算机与特定<code>目标网站</code>之间的加密连接。本地转发是在本地计算机的 SSH 客户端建立的转发规则。</p><p>典型使用场景就是，打洞，经过跳板机访问无法直接连通的服务。</p><p>它会指定一个本地端口（Local-Port），所有发向那个端口的请求，都会转发到 SSH 跳板机（ssh-server），然后 SSH 跳板机作为中介，将收到的请求发到目标服务器（target-host）的目标端口（target-port）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -L :<span class="built_in">local</span>-port:target-host:target-port ssh-server  //target-host是ssh-server的target-host, target-host 域名解析、路由都是由 ssh-server 完成</span></span><br></pre></td></tr></table></figure><p>上面命令中，<code>-L</code>参数表示本地转发，<code>local-port</code>是本地端口，<code>target-host</code>是你想要访问的目标服务器，<code>target-port</code>是目标服务器的端口，<code>ssh-server</code> 是 SSH 跳板机。当你访问 localhost:local-port 的时候会通过 ssh-server 把请求转给 target-host:target-port</p><p><img src="https://img.hi-linux.com/staticfile/INjeHZ-2024-01-22-EWAI33.png" alt></p><p>上图对应的命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 53682:remote-server:53682 ssh-server</span><br></pre></td></tr></table></figure><p>然后，访问本机的 53682 端口，就是访问 <code>remote-server</code> 的 53682 端口.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;localhost:53682</span><br></pre></td></tr></table></figure><p>注意，<strong>本地端口转发采用 HTTP 协议，不用转成 SOCKS5 协议</strong>。如果需要 HTTP 的动态代理，可以先起 Socks5 动态代理，然后再起一个本地转发给动态代理的 Socks5 端口，这样就有一个 HTTP 代理了，能给 Yum、Docker 之类的使用。</p><p>这个命令最好加上<code>-N</code>参数，表示不在 SSH 跳板机执行远程命令，让 SSH 只充当隧道。另外还有一个<code>-f</code>参数表示 SSH 连接在后台运行。</p><p>如果经常使用本地转发，可以将设置写入 SSH 客户端的用户个人配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host test.example.com</span><br><span class="line">LocalForward client-IP:client-port server-IP:server-port</span><br></pre></td></tr></table></figure><h3><span id="远程转发-r">远程转发(-R)</span></h3><p>远程端口指的是在远程 SSH 服务器建立的转发规则。主要是执行 SSH 转发的机器别人连不上，所以需要一台 Client 能连上的机器当远程转发端口，要不就是本地转发了。</p><p>由于本机无法访问内网 SSH 跳板机，就无法从外网发起 SSH 隧道，建立端口转发。必须反过来，从 SSH 跳板机发起隧道，建立端口转发，这时就形成了远程端口转发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -fNR 30.1.2.3:30081:166.100.64.1:3128 root@30.1.2.3 -p 2728</span><br></pre></td></tr></table></figure><p>上面的命令，首先需要注意，<strong>不是在 30.1.2.3 或者 166.100.64.1 上执行的，而是找一台能联通 30.1.2.3 和 166.100.64.1 的机器来执行</strong>，在执行前 Remote Clients 能连上 30.1.2.3 但是 30.1.2.3 和 166.100.64.1 不通，所以需要一个中介将 30.1.2.3 和166.100.64.1打通，这个中介就是下图中的MobaXterm所在的机器，命令在 MobaXterm 机器上执行</p><p><img src="https://img.hi-linux.com/staticfile/PER8yY-2024-01-22-IvkyqB.png" alt></p><p>执行上面的命令以后，跳板机 30.1.2.3 到 166.100.64.1 的隧道已经建立了，这个隧道是依赖两边都能连通的 MobaXterm 机器。然后，就可以从 Remote Client 访问目标服务器了，即在 Remote Client 上执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;30.1.2.3:30081</span><br></pre></td></tr></table></figure><p>执行上面的命令以后，命令就会输出服务器 166.100.64.1 的3128端口返回的内容。</p><p>如果经常执行远程端口转发，可以将设置写入 SSH 客户端的用户个人配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host test.example.com</span><br><span class="line">RemoteForward local-IP:local-port target-ip:target-port</span><br></pre></td></tr></table></figure><p>注意远程转发需要：</p><blockquote><ol><li>sshd_config 里要打开 <code>AllowTcpForwarding</code> 选项，否则 <code>-R</code> 远程端口转发会失败。</li><li>默认转发到远程主机上的端口绑定的是 <code>127.0.0.1</code>，<a href="https://serverfault.com/questions/997124/ssh-r-binds-to-127-0-0-1-only-on-remote" target="_blank" rel="noopener">如要绑定 <code>0.0.0.0</code> 需要打开 sshd_config 里的 <code>GatewayPorts</code> 选项(然后ssh -R 后加上 *:port )</a>。这个选项如果由于权限没法打开也有办法，可配合 <code>ssh -L</code> 将端口绑定到 <code>0.0.0.0</code>。</li></ol></blockquote><p>开通远程转发后，如果需要动态代理（比如访问所有 Web 服务），那么可以在 30081 端口机器上(30.1.2.3)执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ssh -qTfnN -D *:13658 root@127.0.0.1 -p 30081 vmstat 10  &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>表示在 30081 机器上(30.1.2.3)启动了一个 Socks5 动态代理服务</p><h2><span id="调试转发-代理是否能联通">调试转发、代理是否能联通</span></h2><h3><span id="通过-curl-调试"></span></h3><blockquote><p>curl -I --socks5-hostname localhost:13659 <a href="http://twitter.com" target="_blank" rel="noopener">twitter.com</a></p><p>curl -x socks5://localhost:13659 <a href="http://twitter.com" target="_blank" rel="noopener">twitter.com</a></p></blockquote><p>Suppose you have a socks5 proxy running on localhost:13659 .</p><p><a href="https://blog.emacsos.com/use-socks5-proxy-in-curl.html" target="_blank" rel="noopener">In curl &gt;= 7.21.7, you can use</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -x socks5h://localhost:13659 http://www.google.com/</span><br></pre></td></tr></table></figure><blockquote><p>In a proxy string, socks5h:// and socks4a:// mean that the hostname is<br>resolved by the SOCKS server. socks5:// and socks4:// mean that the<br>hostname is resolved locally. socks4a:// means to use SOCKS4a, which is<br>an extension of SOCKS4. Let’s make urllib3 honor it.</p></blockquote><p>In curl &gt;= 7.18.0, you can use</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --socks5-hostname localhost:13659 http://www.google.com/</span><br></pre></td></tr></table></figure><p><code>--proxy</code> 参数含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The --socks5 option is basically considered obsolete since curl 7.21.7. This is because starting in that release, you can now specify the proxy protocol directly in the string that you specify the proxy host name and port number with already. The server you specify with --proxy. If you use a socks5:&#x2F;&#x2F; scheme, curl will go with SOCKS5 with local name resolve but if you instead use socks5h:&#x2F;&#x2F; it will pick SOCKS5 with proxy-resolved host name.</span><br></pre></td></tr></table></figure><h3><span id="wget">wget</span></h3><p><strong>指定命令行参数</strong>,通过命令行指定 HTTP 代理服务器的方式如下：</p><blockquote><p>wget -Y on -e “http_proxy=http://<strong>[HTTP_HOST]</strong>:<strong>[HTTP_PORT]</strong>” <a href="http://facebook.com/" target="_blank" rel="noopener">http://facebook.com/</a></p></blockquote><p>其中：[HTTP_HOST]和[HTTP_PORT]是 HTTP Proxy 的 ADDRESS 和 PORT。</p><ul><li>-Y 表示是否使用代理，on表示使用代理。</li><li>-e 执行后面跟的命令，相当于在.wgetrc配置文件中添加了一条命令，将 http_proxy 设置为需要使用的代理服务器。</li><li>–limit-rate=2.5k 限制下载速度，进行测试</li></ul><h2><span id="pki-public-key-infrastructure证书">PKI (Public Key Infrastructure)证书</span></h2><p>X.509 只是一种常用的证书格式，一般以PEM编码，PEM 编码的证书通常以 <strong><code>.pem</code>、<code>.crt</code> 或 <code>.cer</code></strong> 为后缀。再次提醒，这只是“通常”情况，实际上某些工具可能并不遵循这些惯例。通过pem证书可以访问需要认证的 HTTPS 服务(比如Etcd、Apiserver 等)</p><ul><li><strong>ASN.1 用于定义数据类型</strong>，例如证书（certificate）和秘钥（key）——就像用 JSON 定义一个 request body —— X.509 用 ASN.1 定义。</li><li>DER 是一组将 ASN.1 编码成二进制（比特和字节）的编码规则（encoding rules）。</li><li>PKCS#7 and PKCS#12 是比 X.509 更大的数据结构（封装格式），也用 ASN.1 定义，其中能包含除了证书之外的其他东西。二者分别在 Java 和 Microsoft 产品中使用较多。</li><li>DER 编码之后是二进制数据，不方便复制粘贴，因此大部分证书都是用 PEM 编码的，它用 base64 对 DER 进行编码，然后再加上自己的 label。</li><li>私钥通常用是 PEM 编码的 PKCS#8 对象，但有时也会用密码来加密。</li></ul><p>通过命令 <code>cat /etc/kubernetes/pki/ca.crt | openssl x509 -text</code> 也可以得到下图信息</p><p><img src="https://img.hi-linux.com/staticfile/6ET22D-2024-01-22-hjfjim.png" alt></p><h3><span id="公钥-私钥常见扩展名">公钥、私钥常见扩展名</span></h3><ul><li>公钥：<code>.pub</code> or <code>.pem</code>，<code>ca.crt</code></li><li>私钥：<code>.prv,</code> <code>.key</code>, or <code>.pem</code> , <code>ca.key</code>。</li></ul><h3><span id="证书生成过程演示">证书生成过程演示</span></h3><p>并不是所有的场景都需要向这些大型的 CA 机构申请公钥证书，在任何一个企业，组织或是团体内都可以自己形这样的“小王国”，也就是说，你可以自行生成这样的证书，只需要你自己保证自己的生成证书的私钥的安全，以及不需要扩散到整个互联网。下面，我们用 <code>openssl</code>命令来演示这个过程。</p><ol><li>生成 CA 机构的证书（公钥） <code>ca.crt</code> 和私钥 <code>ca.key</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 \</span><br><span class="line">    -new -nodes -x509 \</span><br><span class="line">    -days 365 \</span><br><span class="line">    -out ca.crt \</span><br><span class="line">    -keyout ca.key \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;SO&#x2F;ST&#x3D;Earth&#x2F;L&#x3D;Mountain&#x2F;O&#x3D;CoolShell&#x2F;OU&#x3D;HQ&#x2F;CN&#x3D;localhost&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>生成 alice 的私钥</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out alice.key 2048</span><br></pre></td></tr></table></figure><ol start="3"><li>生成 Alice 的 CSR – Certificate Signing Request</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key alice.key -days 365 -out alice.csr \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;CN&#x2F;ST&#x3D;Beijing&#x2F;L&#x3D;Haidian&#x2F;O&#x3D;CoolShell&#x2F;OU&#x3D;Test&#x2F;CN&#x3D;localhost.alice&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 CA 给 Alice 签名证书</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl x509  -req -in alice.csr \</span><br><span class="line">    -extfile &lt;(printf &quot;subjectAltName&#x3D;DNS:localhost.alice&quot;) \ </span><br><span class="line">    -CA ca.crt -CAkey ca.key  \</span><br><span class="line">    -days 365 -sha256 -CAcreateserial \</span><br><span class="line">    -out alice.crt</span><br></pre></td></tr></table></figure><h2><span id="参考资料">参考资料：</span></h2><ul><li><a href="http://docs.corp-inc.com/pages/editpage.action?pageId=203555361" target="_blank" rel="noopener">http://docs.corp-inc.com/pages/editpage.action?pageId=203555361</a></li><li><a href="https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/SSH_keys_(简体中文)</a></li><li><a href="https://wangdoc.com/ssh/key.html" target="_blank" rel="noopener">https://wangdoc.com/ssh/key.html</a></li><li><a href="https://robotmoon.com/ssh-tunnels/" target="_blank" rel="noopener">https://robotmoon.com/ssh-tunnels/</a></li><li><a href="https://blog.gwlab.page/vpn-over-ssh-the-socks-proxy-8a8d7bdc7028" target="_blank" rel="noopener">通过SSH动态转发来建立Socks代以及各种场景应用案例</a></li><li><a href="https://daniel.haxx.se/blog/2020/05/26/curl-ootw-socks5/" target="_blank" rel="noopener">https://daniel.haxx.se/blog/2020/05/26/curl-ootw-socks5/</a></li><li><a href="http://www.allanjude.com/bsd/AsiaBSDCon2017_-_SSH_Performance.pdf" target="_blank" rel="noopener">SSH Performance</a></li><li><a href="https://stackoverflow.com/questions/8849240/why-when-i-transfer-a-file-through-sftp-it-takes-longer-than-ftp" target="_blank" rel="noopener">Why when I transfer a file through SFTP, it takes longer than FTP?</a></li><li><a href="https://zhuanlan.zhihu.com/p/413732839" target="_blank" rel="noopener">一行代码解决scp在Internet传输慢的问题</a></li><li><a href="https://www.cnxct.com/everything-about-pki-zh/" target="_blank" rel="noopener">关于证书（certificate）和公钥基础设施（PKI）的一切</a></li><li><a href="https://coolshell.cn/articles/21708.html" target="_blank" rel="noopener">网络数字身份认证术</a></li></ul><blockquote><p>本文转载自：「 plantegg 的博客 」，原文：<a href="http://tinyurl.com/25py66n3" target="_blank" rel="noopener">http://tinyurl.com/25py66n3</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我见过太多的老鸟、新手对 SSH 基本只限于 SSH 到远程机器，实际这个命令我们一天要用很多次，但是对它的了解太少了，他的强大远远超出你的想象。当于你也许会说够用就够了，确实没错，但是你考虑过效率没有，或者还有哪些脑洞大开的功能会让你爱死他，这些功能又仅仅是一行命令就够了。&lt;/p&gt;
&lt;p&gt;疫情期间一行 SSH 命令让我节省了 70% 的出差时间，来，让我们一起走一遍，看看会不会让你大开眼界。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="https://www.hi-linux.com/categories/SSH/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="SSH" scheme="https://www.hi-linux.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>国内外公共/加密 DNS 服务器列表</title>
    <link href="https://www.hi-linux.com/posts/19661.html"/>
    <id>https://www.hi-linux.com/posts/19661.html</id>
    <published>2024-01-18T01:00:00.000Z</published>
    <updated>2024-01-18T09:01:06.242Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>国内外公共 DNS，加密 DNS 汇总，可用作各种 DNS 服务器的上游服务器，在下面的列表中 <strong>选择 2-3 个为宜</strong>。选得多并不是最优解，望周知。</p><p>作为上游服务器列表时，因为 UDP 传输时间短，公共 DNS 统一选择 <code>udp</code>，而<strong>加密 DNS</strong> 统一选择：<code>https</code>，当然<code>tls</code>也可以。</p><h2><span id="国内-dns-列表">国内 DNS 列表:</span></h2><h3><span id="1-国内公共-dns-列表">1. 国内公共 DNS 列表</span></h3><h4><span id="阿里公共-dns">阿里公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">223.5.5.5</span><br><span class="line">223.6.6.6</span><br></pre></td></tr></table></figure><h4><span id="腾讯公共-dns">腾讯公共 DNS:</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">119.29.29.29</span><br></pre></td></tr></table></figure><a id="more"></a><h4><span id="百度公共-dns">百度公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">180.76.76.76</span><br></pre></td></tr></table></figure><h4><span id="360-公共-dns">360 公共 DNS</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">电信、移动、铁通：</span><br><span class="line">101.226.4.6</span><br><span class="line">218.30.118.6</span><br><span class="line">联通：</span><br><span class="line">123.125.81.6</span><br><span class="line">140.207.198.6</span><br></pre></td></tr></table></figure><h4><span id="114-公共-dns">114 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">114.114.114.114</span><br><span class="line">114.114.115.115</span><br></pre></td></tr></table></figure><h3><span id="2国内加密-dns-列表">2.国内加密 DNS 列表：</span></h3><h4><span id="阿里加密-dns">阿里加密 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alidns_ip&#x2F;dns-query</span><br><span class="line">dns.alidns.com&#x2F;dns-query</span><br></pre></td></tr></table></figure><h4><span id="腾讯加密-dns">腾讯加密 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doh.pub&#x2F;dns-query</span><br><span class="line">sm2.doh.pub&#x2F;dns-query</span><br></pre></td></tr></table></figure><h2><span id="国外-dns-列表">国外 DNS 列表：</span></h2><h3><span id="1-国外公共-dns-列表">1. 国外公共 DNS 列表</span></h3><h4><span id="cloudflare-公共-dns">Cloudflare 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.1.1.1</span><br></pre></td></tr></table></figure><h4><span id="google-公共-dns">Google 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8</span><br><span class="line">8.8.4.4</span><br></pre></td></tr></table></figure><h4><span id="norton-公共-dns">Norton 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">199.85.126.10    </span><br><span class="line">199.85.127.10</span><br></pre></td></tr></table></figure><h4><span id="威瑞信-公共-dns">威瑞信 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">64.6.64.6</span><br><span class="line">64.6.65.6</span><br></pre></td></tr></table></figure><h4><span id="comodo-公共-dns">Comodo 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.26.56.2  </span><br><span class="line">68.20.247.2</span><br></pre></td></tr></table></figure><h4><span id="dns-watch-公共-dns">DNS Watch 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">84.200.69.80</span><br><span class="line">84.200.70.40</span><br></pre></td></tr></table></figure><h4><span id="opendns-公共-dns">OpenDNS 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">208.67.222.222</span><br></pre></td></tr></table></figure><h3><span id="2-国外加密-dns-列表">2. 国外加密 DNS 列表</span></h3><h4><span id="google-加密-dns">Google 加密 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dns.google&#x2F;dns-query   类型选择：https</span><br><span class="line">dns.google   类型选择：tls</span><br></pre></td></tr></table></figure><h4><span id="cloudflare-加密-dns">Cloudflare 加密 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.1.1.1&#x2F;dns-query   类型选择：tls</span><br></pre></td></tr></table></figure><h4><span id="quda9-加密-dns">Quda9 加密 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns11.quad9.net&#x2F;dns-query 类型选择：https</span><br></pre></td></tr></table></figure><h4><span id="opendns-加密dns">OpenDNS 加密DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doh.opendns.com&#x2F;dns-query</span><br></pre></td></tr></table></figure><h2><span id="国内外公共-dns-列表合集">国内外公共 DNS 列表合集</span></h2><h3><span id="1-公用-dns-服务器">1. 公用 DNS 服务器</span></h3><table><thead><tr><th>名称</th><th>DNS 服务器 IP 地址</th><th></th></tr></thead><tbody><tr><td><strong>114 DNS</strong></td><td>114.114.114.114</td><td>114.114.115.115</td></tr><tr><td><strong>阿里 AliDNS</strong></td><td>223.5.5.5</td><td>223.6.6.6</td></tr><tr><td><strong>百度 BaiduDNS</strong></td><td>180.76.76.76</td><td></td></tr><tr><td><strong>DNSPod DNS+</strong></td><td>119.29.29.29</td><td>182.254.116.116</td></tr><tr><td><strong>CNNIC SDNS</strong></td><td>1.2.4.8</td><td>210.2.4.8</td></tr><tr><td><strong>oneDNS</strong></td><td>117.50.11.11</td><td>117.50.22.22</td></tr><tr><td><strong>DNS 派电信/移动/铁通</strong></td><td>101.226.4.6</td><td>218.30.118.6</td></tr><tr><td><strong>DNS 派 联通</strong></td><td>123.125.81.6</td><td>140.207.198.6</td></tr><tr><td><strong>Google DNS</strong></td><td>8.8.8.8</td><td>8.8.4.4</td></tr><tr><td><strong>Google IPv6 DNS</strong></td><td>2001:4860:4860::8888</td><td>2001:4860:4860::8844</td></tr><tr><td><strong>IBM Quad9</strong></td><td>9.9.9.9</td><td></td></tr><tr><td><strong>OpenDNS</strong></td><td>208.67.222.222</td><td>208.67.220.220</td></tr><tr><td><strong>V2EX DNS</strong></td><td>199.91.73.222</td><td>178.79.131.110</td></tr><tr><td><strong>Verizon DNS</strong></td><td>4.2.2.1</td><td>4.2.2.2</td></tr><tr><td><strong>中国台湾中华电信 HiNet DNS</strong></td><td>168.95.192.1</td><td>168.95.1.1</td></tr><tr><td><strong>中科大DNS</strong></td><td>202.141.162.123（中国电信）</td><td>202.38.93.153 （教育网）</td></tr><tr><td></td><td>202.141.176.93 （中国移动）</td><td></td></tr><tr><td><strong>韩国KT DNS</strong></td><td>168.126.63.1</td><td>168.126.63.2</td></tr></tbody></table><h3><span id="2-去广告-dns-服务器列表">2. 去广告 DNS 服务器列表</span></h3><table><thead><tr><th>名称</th><th>DNS 服务器 IP 地址</th><th></th></tr></thead><tbody><tr><td><strong>FUN DNS</strong></td><td>119.23.248.241</td><td></td></tr><tr><td><strong>Pure DNS</strong></td><td>123.207.137.88</td><td>115.159.220.214</td></tr><tr><td><strong>CuteDns</strong></td><td>120.77.212.84(南方)</td><td>101.236.28.23（北方）</td></tr><tr><td><strong>aixyz DNS</strong></td><td>115.159.146.99(南方)</td><td>123.206.21.48（北方）</td></tr><tr><td><strong>BAI DNS</strong></td><td>106.14.152.170</td><td></td></tr><tr><td><strong>不知名DNS</strong></td><td>180.97.235.30</td><td>115.159.96.69</td></tr><tr><td></td><td>123.206.21.48</td><td>123.207.137.88</td></tr></tbody></table><h3><span id="3-各地电信-dns-列表">3. 各地电信 DNS 列表</span></h3><table><thead><tr><th>名称</th><th>DNS 服务器 IP 地址</th><th></th></tr></thead><tbody><tr><td><strong>安徽电信 DNS</strong></td><td>61.132.163.68</td><td>202.102.213.68</td></tr><tr><td><strong>北京电信 DNS</strong></td><td>219.141.136.10</td><td>219.141.140.10</td></tr><tr><td><strong>重庆电信 DNS</strong></td><td>61.128.192.68</td><td>61.128.128.68</td></tr><tr><td><strong>福建电信 DNS</strong></td><td>218.85.152.99</td><td>218.85.157.99</td></tr><tr><td><strong>甘肃电信 DNS</strong></td><td>202.100.64.68</td><td>61.178.0.93</td></tr><tr><td><strong>广东电信 DNS</strong></td><td>202.96.128.86</td><td>202.96.128.166</td></tr><tr><td></td><td>202.96.128.68</td><td>202.96.134.33</td></tr><tr><td><strong>广西电信 DNS</strong></td><td>202.103.225.68</td><td>202.103.224.68</td></tr><tr><td><strong>贵州电信 DNS</strong></td><td>202.98.192.67</td><td>202.98.198.167</td></tr><tr><td><strong>河南电信 DNS</strong></td><td>222.88.88.88</td><td>222.85.85.85</td></tr><tr><td><strong>黑龙江电信</strong></td><td>219.147.198.230</td><td>219.147.198.242</td></tr><tr><td><strong>湖北电信 DNS</strong></td><td>202.103.24.68</td><td>202.103.0.68</td></tr><tr><td><strong>湖南电信 DNS</strong></td><td>222.246.129.80</td><td>59.51.78.211</td></tr><tr><td><strong>江苏电信 DNS</strong></td><td>218.2.2.2</td><td>218.4.4.4</td></tr><tr><td></td><td>218.2.135.1</td><td>61.147.37.1</td></tr><tr><td><strong>江西电信 DNS</strong></td><td>202.101.224.69</td><td>202.101.226.68</td></tr><tr><td><strong>内蒙古电信</strong></td><td>219.148.162.31</td><td>222.74.39.50</td></tr><tr><td><strong>山东电信 DNS</strong></td><td>219.146.1.66</td><td>219.147.1.66</td></tr><tr><td><strong>陕西电信 DNS</strong></td><td>218.30.19.40</td><td>61.134.1.4</td></tr><tr><td><strong>上海电信 DNS</strong></td><td>202.96.209.133</td><td>116.228.111.118</td></tr><tr><td></td><td>108.168.255.118</td><td>202.96.209.5</td></tr><tr><td><strong>四川电信 DNS</strong></td><td>61.139.2.69</td><td>218.6.200.139</td></tr><tr><td><strong>天津电信 DNS</strong></td><td>219.150.32.132</td><td>219.146.0.132</td></tr><tr><td><strong>云南电信 DNS</strong></td><td>222.172.200.68</td><td>61.166.150.123</td></tr><tr><td><strong>浙江电信 DNS</strong></td><td>202.101.172.35</td><td>61.153.177.196</td></tr><tr><td></td><td>60.191.244.5</td><td>61.153.81.75</td></tr></tbody></table><h3><span id="4-联通-dns-服务器列表">4. 联通 DNS 服务器列表</span></h3><table><thead><tr><th>名称</th><th>DNS 服务器 IP 地址</th><th></th></tr></thead><tbody><tr><td><strong>北京联通 DNS</strong></td><td>123.123.123.123</td><td>123.123.123.124</td></tr><tr><td></td><td>202.106.195.68</td><td>202.106.0.20</td></tr><tr><td><strong>重庆联通 DNS</strong></td><td>221.5.203.98</td><td>221.7.92.98</td></tr><tr><td><strong>广东联通 DNS</strong></td><td>210.21.196.6</td><td>221.5.88.88</td></tr><tr><td><strong>河北联通 DNS</strong></td><td>202.99.160.68</td><td>202.99.166.4</td></tr><tr><td><strong>河南联通 DNS</strong></td><td>202.102.224.68</td><td>202.102.227.68</td></tr><tr><td><strong>黑龙江联通DNS</strong></td><td>202.97.224.69</td><td>202.97.224.68</td></tr><tr><td><strong>吉林联通 DNS</strong></td><td>202.98.0.68</td><td>202.98.5.68</td></tr><tr><td><strong>江苏联通 DNS</strong></td><td>221.6.4.66</td><td>221.6.4.67</td></tr><tr><td><strong>内蒙古联通 DNS</strong></td><td>202.99.224.68</td><td>202.99.224.8</td></tr><tr><td><strong>山东联通 DNS</strong></td><td>202.102.128.68</td><td>202.102.152.3</td></tr><tr><td></td><td>202.102.154.3</td><td>202.102.134.68</td></tr><tr><td><strong>山西联通 DNS</strong></td><td>202.99.192.66</td><td>202.99.192.68</td></tr><tr><td><strong>陕西联通 DNS</strong></td><td>221.11.1.67</td><td>221.11.1.68</td></tr><tr><td><strong>上海联通 DNS</strong></td><td>210.22.70.3</td><td>210.22.84.3</td></tr><tr><td><strong>四川联通 DNS</strong></td><td>119.6.6.6</td><td>124.161.87.155</td></tr><tr><td><strong>天津联通 DNS</strong></td><td>202.99.104.68</td><td>202.99.96.68</td></tr><tr><td><strong>浙江联通 DNS</strong></td><td>221.12.1.227</td><td>221.12.33.227</td></tr><tr><td><strong>辽宁联通 DNS</strong></td><td>202.96.69.38</td><td>202.96.64.68</td></tr></tbody></table><h3><span id="5-移动-dns-服务器列表">5. 移动 DNS 服务器列表</span></h3><table><thead><tr><th>名称</th><th>DNS 服务器 IP 地址</th><th></th></tr></thead><tbody><tr><td><strong>江苏移动 DNS</strong></td><td>221.131.143.69</td><td>112.4.0.55</td></tr><tr><td><strong>安徽移动 DNS</strong></td><td>211.138.180.2</td><td>211.138.180.3</td></tr><tr><td><strong>山东移动 DNS</strong></td><td>218.201.96.130</td><td>211.137.191.26</td></tr><tr><td><strong>四川移动 DNS</strong></td><td>223.87.238.22</td><td></td></tr></tbody></table><blockquote><p>本文转载自：「再从头的博客 」，原文：<a href="https://url.hi-linux.com/pWijO" target="_blank" rel="noopener">https://url.hi-linux.com/pWijO</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国内外公共 DNS，加密 DNS 汇总，可用作各种 DNS 服务器的上游服务器，在下面的列表中 &lt;strong&gt;选择 2-3 个为宜&lt;/strong&gt;。选得多并不是最优解，望周知。&lt;/p&gt;
&lt;p&gt;作为上游服务器列表时，因为 UDP 传输时间短，公共 DNS 统一选择 &lt;code&gt;udp&lt;/code&gt;，而&lt;strong&gt;加密 DNS&lt;/strong&gt; 统一选择：&lt;code&gt;https&lt;/code&gt;，当然&lt;code&gt;tls&lt;/code&gt;也可以。&lt;/p&gt;
&lt;h2 id=&quot;国内-DNS-列表&quot;&gt;国内 DNS 列表:&lt;/h2&gt;
&lt;h3 id=&quot;1-国内公共-DNS-列表&quot;&gt;1. 国内公共 DNS 列表&lt;/h3&gt;
&lt;h4 id=&quot;阿里公共-DNS：&quot;&gt;阿里公共 DNS：&lt;/h4&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;223.5.5.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;223.6.6.6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;腾讯公共-DNS&quot;&gt;腾讯公共 DNS:&lt;/h4&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;119.29.29.29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>一篇超级实用的裁员劳动仲裁指南</title>
    <link href="https://www.hi-linux.com/posts/60168.html"/>
    <id>https://www.hi-linux.com/posts/60168.html</id>
    <published>2023-12-12T01:00:00.000Z</published>
    <updated>2023-12-11T08:49:19.501Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>其实本来另一篇文章已经写好了，但考虑到临近年底，劳动仲裁指南的实用性可能会更大，于是便有了这篇文章。作为劳动仲裁曾经的亲历者，reizhi 希望能够借这篇文章把劳动仲裁这件事给说明白。虽然希望各位都用不上，但多了解一些总是好的。</p><p>在劳动合同签立的过程中，用人单位往往处于极其强势的地位。对应的，劳动者毫无疑问属于弱势的一方。在双方就劳动合同的履行产生争议时，依靠友好协商有时并不能达成让人满意的结果，于是便有了劳动争议仲裁委员会。无论劳动者是否有与用人单位进行协商，只要产生劳动争议，均可以提交劳动仲裁申请。本文接下来将专注于因裁员导致产生劳动仲裁的情形。</p><a id="more"></a><h2><span id="1公司可以合法解除劳动合同的情形">1.公司可以合法解除劳动合同的情形</span></h2><p>除开试用期外，以下情形公司可以单方面解除劳动合同，不需要支付补偿金或者赔偿金（过失类）：</p><ol><li>劳动者严重违反用人单位的规章制度</li><li>劳动者严重失职，营私舞弊，给用人单位造成重大损害</li><li>劳动者同时与其他用人单位建立劳动关系，对完成本单位的工作任务造成严重影响，或者经用人单位提出，拒不改正</li><li>具有以欺诈、胁迫的手段或者乘人之危，使对方在违背真实意思的情况下订立或者变更劳动合同的情形致使劳动合同无效</li><li>劳动者被依法追究刑事责任</li></ol><p>以上这些情形相信大家应该不太能够遇到，同时如果提出过失类解除需要用人单位进行举证，这里便不展开介绍了。</p><h2><span id="2公司需要支付补偿金才能解除劳动合同的情形">2.公司需要支付补偿金才能解除劳动合同的情形</span></h2><p>以下这些情形是大家常说的 N 或者 N+1 补偿的情形：</p><ol><li>双方协商一致，解除劳动合同（由公司提出）</li><li>劳动者患病或者非因工负伤，医疗期满后，不能从事原工作也不能从事由用人单位另行安排的工作</li><li>劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作</li><li>劳动合同订立时所依据的客观情况发生重大变化，致使原劳动合同无法履行，经当事人协商不能就变更劳动合同达成协议</li><li>用人单位濒临破产进行法定整顿期间或者生产经营状况发生严重困难，确需裁减人员的，应当提前三十日向工会或者全体职工说明情况，听取工会或者职工的意见，经向劳动行政部门报告后，可以裁减人员</li></ol><p>其中，适用第二、三、四条进行劳动关系解除时，用人单位需要提前30日书面告知劳动者，否则需要支付额外的一个月工资，即 N+1 。其他情形需要支付 N 补偿，具体如何计算后面还会讲到。</p><p>看到这里可能有人已经开始打退堂鼓了，是否只要公司提出劳动者不能胜任工作，并以绩效完成情况作为证明就能适用 N 或 N+1 辞退呢？其实并不是，如果需要适用第三条的不能胜任工作，公司需要首先进行培训或者调整工作岗位，且能够提供对应的证明材料。其次公司需要提供的证明材料较多，包括：首次不能胜任的相关证明，进行了合理的培训或者调整岗位的证明，再次不能胜任的相关证明。</p><p>故虽然此点可能作为人事的托词，但实际举证难度较大，且绩效考核标准的订立可操作空间大，在实际仲裁乃至诉讼过程中，用人单位被判定为不利的概率极高。一旦此点认定失败，将直接被认定为非法解除劳动合同，从而致使补偿金 N+1 升级为赔偿金 2N 。</p><p>其中的第四条客观情况发生重大变化，也比较喜欢被某些人事加以利用。需要明确的是此点包含两条重要约束，即客观和重大变化。即变化所产生的原因并非用人单位所能主观决定和控制，而非单纯的因为组织架构调整就能够引用此条予以辞退。另外，在解除劳动合同前也需要与劳动者进行协商，提供相近或类似的工作岗位，并且待遇不能低于原岗位。在劳动者拒绝的情况下，才能适用本条。</p><p>最后，对于调岗的情形，需明确调岗后的职级、工作内容与原岗位相近，且待遇不低于原岗位，新岗位不存在任何歧视性、侮辱性。用人单位行使法定调岗权，应对调岗的合理依据承担举证责任。</p><h2><span id="3违法解除劳动合同的情形">3.违法解除劳动合同的情形</span></h2><p>所有不适用以上情形的情况，由公司提出解除劳动合同的情形，均属于违法解除。如果公司方面主张因为以上情形解除劳动关系，则需要由公司进行举证。在公司无法拿出充分证据予以证明的情况下，同样会被认定为违法解除。</p><p>所有的违法解除劳动合同的情形，赔偿金为 2N 。</p><h2><span id="4补偿金或赔偿金如何计算">4.补偿金或赔偿金如何计算</span></h2><p>补偿金 = 在职年限（N）x 工资基数</p><p>赔偿金 = 2 x 在职年限（N）x 工资基数</p><p>无论是第二节中提到的补偿金，还是第三节中提到的赔偿金，其金额基数均为劳动合同解除或者终止前十二个月的平均工资，含奖金、津贴和补贴。如工作不满十二个月，按照实际工作的月数计算平均工资。</p><p>其中的在职年限，除去整年部分后，满六个月以上的计一年，不满六个月的计半年。例：一年三个月按照1.5年计算，两年十个月按照3年计算。</p><p>对于第二节中有提到需提前30日书面告知劳动者的情形，如有进行告知则无需再额外补偿一个月工资。如未告知则需补偿 N+1 。</p><p>综上，对于法定范围内的补偿金或赔偿金，仅有：N, N+1, 2N 三种情形。在递交劳动仲裁申请时，务必按照对应的情形计算可能的最大补偿（或赔偿）金额。具体金额在仲裁审理时会进行重新计算，但不会超过仲裁申请时所提交的金额。</p><h2><span id="5申请劳动仲裁需要提交哪些材料">5.申请劳动仲裁需要提交哪些材料</span></h2><p>如果我们已经确定要提交劳动仲裁申请，必然要先知道所需材料。各地对于劳动仲裁申请所需的材料略有出入，但大体上包含以下这些：</p><ul><li>身份证复印件</li><li>工作证明复印件（如劳动合同）</li><li>离职证明</li><li>公司工商信息</li><li>劳动仲裁申请表</li><li>相关证明材料</li><li>工资条，工资流水</li></ul><p>具体的要求可以在网上搜索当地地名加劳动仲裁，或直接前往劳动仲裁庭咨询了解。其中的公司工商信息可在当地的“企业信用信息公示系统”网站按照企业名称搜索并打印即可，劳动仲裁申请表一般在当地政府政务网站或仲裁机构的网站上可以下载。</p><p>对于裁员请求经济补偿或赔偿的情况，离职证明属于必要材料，需由公司开具。如公司推脱或者拒绝开具，一般可以向当地劳动监察大队举报。</p><p>劳动仲裁申请的部分，可参照参考信息中的链接二，也可以在网上搜索当地地名加劳动仲裁指南。</p><p>多数情况下工作证明即劳动合同，如未有签订劳动合同也可以提交其他证明材料如社保缴纳记录，工资条，打卡考勤记录等。</p><p>其他可能用得上的证明材料如：培训记录、调岗记录、绩效考核标准、绩效考核邮件、其他内部邮件、沟通记录截图等均可以提交。</p><h2><span id="6后续流程">6.后续流程</span></h2><p>在材料递交后，仲裁庭首先会告知是否受理，以及受理后的开庭时间。劳动者本人只需按时出庭即可，用人单位是否出席不影响裁定。这里我并没有实操经验，但大家只需要据实应对，争取合法权益即可。正因为我们之前一直有提到劳动者在合同关系中处于弱势方，仲裁庭基本上还是会尽量出于维护劳动者权益的角度进行裁定。</p><p>另外一方面，在劳动仲裁中用人单位方掌握并且控制了大量的信息，所以相关法条也有进行规定：与争议事项有关的证据属于用人单位掌握管理的，用人单位应当提供；用人单位不提供的，应当承担不利后果。</p><p>既然大家已经选择了进行劳动仲裁，就应该充分信任仲裁庭能够给予公正客观的裁定结果。毕竟设立劳动仲裁庭的目的就是为了保护劳动者的合法权益，总不会有哪个用人单位去申请仲裁吧？</p><p>裁定结果出来后，如果对于我们的主张诉求予以支持，直接找公司要钱即可。如公司拒绝，在超过限定时间后可以向法院申请强制执行。这些后续细节裁定书中应该会有说明，不用太担心。</p><p>任意一方对于裁定结果不服，都可以提起诉讼。涉及到打官司已经超出本文的科普范围了，建议咨询律师。</p><p>在实际操作过程中可能存在仲裁开庭前公司注销的情况发生，reizhi 对此类问题没有操作经验，同样建议咨询律师，有可能需要通过诉讼解决。</p><h2><span id="7协商">7.协商</span></h2><p>上面这些信息对于人事来说都是必知必会，但对方有可能利用信息差在协商中占据优势。在我们了解全部的相关知识后，便可以从容的与人事展开协商谈判了。如果你已经做好了劳动仲裁的决心，以下是一些常见托词的应对逻辑：</p><p><strong>无法胜任</strong>：需由公司举证，且举证难度大；需先调岗或培训；绩效考核存在主观性，可操作空间大，置信度低</p><p><strong>客观情况发生重大变化</strong>：需要是客观的不可抗力；重大变化足以影响公司经营或合同执行；需提供调岗机会</p><p><strong>时间周期长，结果不确定</strong>：仲裁庭的本质是劳动者保护组织；公司举证责任多、难度大；劳动仲裁记录在企查查等网站均可查到，无论结果对于公司都没有好处</p><p>如果公司方已经斩钉截铁的表示无法给到应有的标准，但可以适当降低进行补偿，则是否接受需要取决于自身。</p><h2><span id="8参考信息">8.参考信息</span></h2><blockquote><p><a href="https://www.gov.cn/banshi/2005-05/25/content_905.htm" target="_blank" rel="noopener">https://www.gov.cn/banshi/2005-05/25/content_905.htm</a></p><p><a href="https://www.moj.gov.cn/pub/sfbgw/jgsz/jgszzsdw/zsdwflyzzx/flyzzxgzpt/gzptwlpx/202007/t20200702_190436.html" target="_blank" rel="noopener">https://www.moj.gov.cn/pub/sfbgw/jgsz/jgszzsdw/zsdwflyzzx/flyzzxgzpt/gzptwlpx/202007/t20200702_190436.html</a></p><p><a href="https://rlsbt.zj.gov.cn/art/2020/11/19/art_1450623_58919888.html" target="_blank" rel="noopener">https://rlsbt.zj.gov.cn/art/2020/11/19/art_1450623_58919888.html</a></p><p><a href="https://www.dehenglaw.com/CN/tansuocontent/0008/029228/7.aspx?AID=&amp;BID=00000000000000001988&amp;MID=0902" target="_blank" rel="noopener">https://www.dehenglaw.com/CN/tansuocontent/0008/029228/7.aspx?AID=&amp;BID=00000000000000001988&amp;MID=0902</a></p><p><a href="https://www.yiyang.gov.cn/rsj/4509/4516/5735/content_305410.html" target="_blank" rel="noopener">https://www.yiyang.gov.cn/rsj/4509/4516/5735/content_305410.html</a></p><p><a href="https://gchzfy.hncourt.gov.cn/public/detail.php?id=3294" target="_blank" rel="noopener">https://gchzfy.hncourt.gov.cn/public/detail.php?id=3294</a></p><p><a href="https://www.gov.cn/flfg/2007-12/29/content_847310.htm" target="_blank" rel="noopener">https://www.gov.cn/flfg/2007-12/29/content_847310.htm</a></p></blockquote><blockquote><p>本文转载自：「 reizhi 的博客 」，原文：<a href="https://url.hi-linux.com/KXvBv" target="_blank" rel="noopener">https://url.hi-linux.com/KXvBv</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实本来另一篇文章已经写好了，但考虑到临近年底，劳动仲裁指南的实用性可能会更大，于是便有了这篇文章。作为劳动仲裁曾经的亲历者，reizhi 希望能够借这篇文章把劳动仲裁这件事给说明白。虽然希望各位都用不上，但多了解一些总是好的。&lt;/p&gt;
&lt;p&gt;在劳动合同签立的过程中，用人单位往往处于极其强势的地位。对应的，劳动者毫无疑问属于弱势的一方。在双方就劳动合同的履行产生争议时，依靠友好协商有时并不能达成让人满意的结果，于是便有了劳动争议仲裁委员会。无论劳动者是否有与用人单位进行协商，只要产生劳动争议，均可以提交劳动仲裁申请。本文接下来将专注于因裁员导致产生劳动仲裁的情形。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="职场" scheme="https://www.hi-linux.com/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>一份超实用的 Nginx Location 配置详解</title>
    <link href="https://www.hi-linux.com/posts/51752.html"/>
    <id>https://www.hi-linux.com/posts/51752.html</id>
    <published>2023-12-11T01:00:00.000Z</published>
    <updated>2023-12-11T03:42:28.101Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="前言">前言</span></h2><p>Location 是 Nginx 中一个非常核心的配置，这篇重点讲解一下 Location 的配置问题以及一些注意事项。</p><h2><span id="语法">语法</span></h2><p>关于 Location，举个简单的配置例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123; </span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">      <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.yayujs.com;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">          <span class="attribute">root</span> /home/www/ts/;</span><br><span class="line">          <span class="attribute">index</span> index.html;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>大致的意思是，当你访问 <code>www.yayujs.com</code> 的 <code>80</code> 端口的时候，返回 <code>/home/www/ts/index.html</code> 文件。</p><p>我们看下 Location 的具体语法：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">[ = | ~ | ~* | ^~ ] uri</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>重点看方括号中的 <code>[ = | ~ | ~* | ^~ ]</code>，其中 <code>|</code> 分隔的内容表示你可能会用到的语法，其中：</p><ul><li><code>=</code> 表示精确匹配，比如：</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">= /test</span> &#123;</span><br><span class="line">  return <span class="number">200</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /test ok</span></span><br><span class="line"><span class="comment"># /test/ not ok</span></span><br><span class="line"><span class="comment"># /test2 not ok</span></span><br><span class="line"><span class="comment"># /test/2 not ok</span></span><br></pre></td></tr></table></figure><ul><li><code>~</code> 表示区分大小写的正则匹配，比如：</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">~ ^/test</span>$ &#123;</span><br><span class="line">  [ configuration ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /test ok</span></span><br><span class="line"><span class="comment"># /Test not ok</span></span><br><span class="line"><span class="comment"># /test/ not ok</span></span><br><span class="line"><span class="comment"># /test2 not ok</span></span><br></pre></td></tr></table></figure><ul><li><code>~*</code> 表示不区分大小写的正则匹配</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">~* ^/test</span>$ &#123;     </span><br><span class="line">    [ configuration ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /test ok</span></span><br><span class="line"><span class="comment"># /Test ok</span></span><br><span class="line"><span class="comment"># /test/ not ok</span></span><br><span class="line"><span class="comment"># /test2 not ok</span></span><br></pre></td></tr></table></figure><ul><li><code>^~</code> 表示 uri 以某个字符串开头</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">^~ /images</span>/ &#123;    </span><br><span class="line">    [ configuration ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /images/1.gif ok</span></span><br></pre></td></tr></table></figure><p>而当你不使用这些语法的时候，只写 uri 的时候：</p><p><code>/</code> 表示通用匹配：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">/ &#123;     </span></span><br><span class="line"><span class="title">    [ configuration</span> ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /index.html ok</span></span><br><span class="line"><span class="keyword">location</span> <span class="title">/test</span> &#123;</span><br><span class="line">    [ configuration ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /test ok</span></span><br><span class="line"><span class="comment"># /test2 ok</span></span><br><span class="line"><span class="comment"># /test/ ok</span></span><br></pre></td></tr></table></figure><h2><span id="匹配顺序">匹配顺序</span></h2><p>当存在多个 location 的时候，他们的匹配顺序引用 <a href="https://link.segmentfault.com/?enc=sah%2Br0st4OoDSH53K0i1lA%3D%3D.IeNU1hnVBfLtvwt4TWcSRag6FLaayC8NDRbkNSiZVvpwANmQuEigx0kLfgTlKJhRuaFlCOH38WFatOeN8H0E4t0rzJimS%2BW8CHUTzh5P%2B7s%3D" target="_blank" rel="noopener">Nginx 官方文档</a>就是：</p><blockquote><p>A location can either be defined by a prefix string, or by a regular expression. Regular expressions are specified with the preceding “~*” modifier (for case-insensitive matching), or the “~” modifier (for case-sensitive matching). To find location matching a given request, nginx first checks locations defined using the prefix strings (prefix locations). Among them, the location with the longest matching prefix is selected and remembered. Then regular expressions are checked, in the order of their appearance in the configuration file. The search of regular expressions terminates on the first match, and the corresponding configuration is used. If no match with a regular expression is found then the configuration of the prefix location remembered earlier is used.</p><p>If the longest matching prefix location has the “^~” modifier then regular expressions are not checked.</p><p>Also, using the “=” modifier it is possible to define an exact match of URI and location. If an exact match is found, the search terminates. For example, if a “/” request happens frequently, defining “location = /” will speed up the processing of these requests, as search terminates right after the first comparison. Such a location cannot obviously contain nested locations.</p></blockquote><p>翻译整理后就是：</p><p>location 的定义分为两种：</p><ul><li>前缀字符串（prefix string）</li><li>正则表达式（regular expression），具体为前面带 <code>~*</code> 和 <code>~</code> 修饰符的</li></ul><p>而匹配 location 的顺序为：</p><ol><li>检查使用前缀字符串的 locations，在使用前缀字符串的 locations 中选择最长匹配的，并将结果进行储存</li><li>如果符合带有 <code>=</code> 修饰符的 URI，则立刻停止匹配</li><li>如果符合带有 <code>^~</code> 修饰符的 URI，则也立刻停止匹配。</li><li>然后按照定义文件的顺序，检查正则表达式，匹配到就停止</li><li>当正则表达式匹配不到的时候，使用之前储存的前缀字符串</li></ol><p>再总结一下就是：</p><p>在顺序上，前缀字符串顺序不重要，按照匹配长度来确定，正则表达式则按照定义顺序。</p><p>在优先级上，<code>=</code> 修饰符最高，<code>^~</code> 次之，再者是正则，最后是前缀字符串匹配。</p><p>我们举几个简单的例子复习下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location &#x2F;doc &#123;</span><br><span class="line">        [ configuration A ] </span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F;docu &#123;</span><br><span class="line">        [ configuration B ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 请求 &#x2F;document 使用 configuration B</span><br><span class="line"># 虽然 &#x2F;doc 也能匹配到，但在顺序上，前缀字符串顺序不重要，按照匹配长度来确定</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location ~ ^&#x2F;doc &#123;</span><br><span class="line">        [ configuration A ] </span><br><span class="line">    &#125;</span><br><span class="line">    location ~ ^&#x2F;docu &#123;</span><br><span class="line">        [ configuration B ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 请求 &#x2F;document 使用 configuration A</span><br><span class="line"># 虽然 ~ ^&#x2F;docu 也能匹配到，但正则表达式则按照定义顺序</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location ^~ &#x2F;doc &#123;</span><br><span class="line">        [ configuration A ] </span><br><span class="line">    &#125;</span><br><span class="line">    location ~ ^&#x2F;docu &#123;</span><br><span class="line">        [ configuration B ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 请求 &#x2F;document 使用 configuration A</span><br><span class="line"># 虽然 ~ ^&#x2F;docu 也能匹配到，但 ^~ 的优先级更高</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location &#x2F;document &#123;</span><br><span class="line">        [ configuration A ] </span><br><span class="line">    &#125;</span><br><span class="line">    location ~ ^&#x2F;docu &#123;</span><br><span class="line">        [ configuration B ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 请求 &#x2F;document 使用 configuration B</span><br><span class="line"># 虽然 &#x2F;document 也能匹配到，但正则的优先级更高</span><br></pre></td></tr></table></figure><h2><span id="root-与-alias-的区别">root 与 alias 的区别</span></h2><p>当我们这样设置 <code>root</code> 的时候：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location <span class="regexp">/i/</span> &#123;</span><br><span class="line">    root <span class="regexp">/data/</span>w3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求 <code>/i/top.gif</code> ，<code>/data/w3/i/top.gif</code> 会被返回。</p><p>当我们这样设置 <code>alias</code> 的时候：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location <span class="regexp">/i/</span> &#123;</span><br><span class="line">    alias <span class="regexp">/data/</span>w3<span class="regexp">/images/</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求 <code>/i/top.gif</code> ，<code>/data/w3/images/top.gif</code> 会被返回。</p><p>乍一看两者很像，但细一看，就能看出两者的区别，root 是直接拼接 <code>root</code> + <code>location</code> 而 alias 是用 <code>alias</code> 替换 <code>location</code>，所以 root 中最后的路径里有 <code>/i/</code>，而 alias 中最后的路径里没有 <code>/i/</code> 。</p><p>所以如果你这样使用 allias 定义一个路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location <span class="regexp">/images/</span> &#123;</span><br><span class="line">    alias <span class="regexp">/data/</span>w3<span class="regexp">/images/</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实使用 root 会更好：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location <span class="regexp">/images/</span> &#123;</span><br><span class="line">    root <span class="regexp">/data/</span>w3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="server-和-location-中的-root">server 和 location 中的 root</span></h2><p>server 和 location 中都可以使用 root，举个例子：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http &#123; </span><br><span class="line">  server &#123;</span><br><span class="line">      listen <span class="number">80</span>;</span><br><span class="line">        server_name www.yayujs.com;</span><br><span class="line">        root <span class="regexp">/home/</span>www<span class="regexp">/website/</span>;</span><br><span class="line">        location <span class="regexp">/ &#123;</span></span><br><span class="line"><span class="regexp">          root /</span>home<span class="regexp">/www/</span>ts<span class="regexp">/;</span></span><br><span class="line"><span class="regexp">          index index.html;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>如果两者都出现，是怎样的优先级呢？</p><p>简单的来说，就是就近原则，如果 location 中能匹配到，就是用 location 中的 root 配置，忽略 server 中的 root，当 location 中匹配不到的时候，则使用 server 中的 root 配置。</p><blockquote><p>本文转载自：「 冴羽的JavaScript博客 」，原文：<a href="https://url.hi-linux.com/e0P8z" target="_blank" rel="noopener">https://url.hi-linux.com/e0P8z</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Location 是 Nginx 中一个非常核心的配置，这篇重点讲解一下 Location 的配置问题以及一些注意事项。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;语法&lt;/h2&gt;
&lt;p&gt;关于 Location，举个简单的配置例子：&lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;http&lt;/span&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;section&quot;&gt;server&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attribute&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;server_name&lt;/span&gt; www.yayujs.com;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;location&lt;/span&gt; / &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;root&lt;/span&gt; /home/www/ts/;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;index&lt;/span&gt; index.html;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>一文带你搞懂旁路由的原理与配置</title>
    <link href="https://www.hi-linux.com/posts/38236.html"/>
    <id>https://www.hi-linux.com/posts/38236.html</id>
    <published>2023-10-17T01:00:00.000Z</published>
    <updated>2023-10-17T09:28:18.953Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最早听到旁路由这个词是在 2020 年折腾 N1 的时候，这台单网口的小盒子只能用网上所说的旁路由方案接入局域网来实现期望的功能。现在回想起来，旁路由这个词有可能就是在那个发烧友大量折腾斐讯 N1/P1/T1 的时期被发明出来的。</p><p>你没办法在发烧友圈子外的互联网及各种学术材料中找到对旁路由的描述和定义，当然也找不到合适的英文翻译（导致这篇文章的 slug 定义困难）；从拓扑上看，旁路由更像是杂糅了二级路由和透明网关的概念，除了实体确实多接了根网线放在主路由旁边，其本身并没有真正地开启一条旁路，做的事情也基本可以和网关的定义对齐。</p><p>不过，由于这个说法主要集中于网友的交流讨论之中，而且几年来在有相关需求的广大用户中被广为接受，所以只要这个词不变为一个学术概念，那我倒也不觉得有什么不妥。下文也仍然会用「旁路由」一词来指代在此类拓扑结构中担任代理网关角色的路由器。</p><p>此外，本文对于原理的解释偏多且为新手向，对于已经熟知相关概念的读者则可以将本文作为 cheat sheet 食用。</p><a id="more"></a><h2><span id="旁路由的适用场景">旁路由的适用场景</span></h2><p>有人认为旁路由的加入（手动指定方式）不会在其出现问题时影响整个网络的可用性，所以应该把非路由功能都交给旁路由来实现。但实际上如果仅仅是为了达成这个目标，那在主路由上直接分流会是个更好的方案，因为这样不仅会大量减少疑难杂症的出现，而且还可以通过设置 fallback 的方式进一步提升网络的可用性。</p><p>所以我认为旁路由实际上只适用于一个场景，那就是出于某种考虑，主路由不能被替换或被大量修改，而主路由的固件又不能满足功能诉求，这时候旁路由便是一个可选的解决方案。</p><h2><span id="旁路由的原理">旁路由的原理</span></h2><p>网上关于旁路由的配置教程多如牛毛，其中大部分是基于 F 大的 N1 OpenWrt 固件使用教程来写的，也有很多是结合了自己的踩坑经验的细化版本。由于版本太多、完整的说明太少，而且大部分没有讲清楚教程的环境上下文和原理，导致按照这些教程来配置的用户往往不得不一遍遍地折腾重试，甚至会遇到逐步配置最终却断网、访问不了部分网站等令人头疼的问题。</p><p>授之以鱼不如授之以渔，为了能彻底讲清楚旁路由该如何配置，我们暂且不谈具体步骤，而是先搞明白旁路由的运作原理。</p><h3><span id="名词解释">名词解释</span></h3><p>由于计算机网络的术语在不同时期、不同环境下，对于细节的含义其实有比较大的差异，故首先我们先定义好下文中将使用到的各类专有名词的含义，以免出现信息不对称的情况。同时为了方便理解，我们也尽量和 OpenWrt 的名词对齐，并尝试与现实生活场景进行类比。</p><ol><li><strong>路由</strong>：将数据从源地址传输到目的地址的行为。可以看出，这个行为抽象涵盖了两个动作，一是找到地址、二是转发数据。可以类比为网购时快递公司将商品从卖家发送给买家的过程。</li><li><strong>路由表</strong>：可以简单理解为路由过程中的地址关联信息的合集，也就是现实中发货地址和收货地址的映射关系。</li><li><strong>路由器</strong>：本文中指家用的、具备路由功能的实体网络设备，其本身并不一定需要真的承担或只承担路由功能，可以抽象理解为就是一台普通的电脑或服务器。当然，它也可以是一个容器实例、一个虚拟机。对应到现实中就是快递公司。</li><li><strong>接口</strong>：这里特指网络接口，指两个网络设备或协议层的连接点。现实中连接路由器时，wan/lan 不同的网线插槽其实就可以理解为接口。只不过接口并不一定是物理实体，所以我们才会在 OpenWrt 的接口设置里看到甚至新增许多物理设备上所没有的接口。</li><li><strong>网关</strong>：这里特指网络中的网关，负责执行数据转发的某个抽象设备。这里可能容易与路由器的功能混淆，毕竟路由器如果用来做路由似乎也是在做转发的工作。实际上这是由于术语的历史使用缺少规范导致的边界不够清晰，可以粗略理解为承担路由功能的路由器就是网关，但网关不一定是只能由路由器担任。</li><li><strong>IP</strong>：本身指 IP 协议，本文为方便也可能将其作为 IP 地址的简称，且默认为 IPv4 。本节所有的名词其实都是基于 IP 协议运作的，而 IP 地址即上文各类「地址」的实际值。可以理解为你用于发送和接收快递的门牌号。</li><li><strong>DHCP</strong>：IP 地址的管理和分配协议，本文中不单单指协议本身，还指负责执行该协议的设备。可以理解为给你分配门牌号的物业，只不过这个门牌号是动态变化的。</li><li><strong>DNS</strong>：上文说到数据的传输需要源地址和目的地址，而这个地址就是 IP 地址。但由于 IP 地址难以记忆，所以才会有了可以作为 IP 地址别名的域名，而 DNS 就是负责进行域名和 IP 地址映射转换的系统。本文中 DNS 也指代负责运行该系统的设备。</li><li><strong>NAT</strong>：出于各种考虑，局域网与因特网的 IP 地址是隔离的，NAT 可以理解为内外网 IP 地址转换的流程。类比网购，相当于快递公司把快递送到附近快递站，快递站的快递员再把货物送到你家门口的流程。</li><li><strong>SNAT</strong>：NAT 的一种，本质上是在修改网络包的源地址，目的是可以强制网络包返回时经过期望的地址。可以理解为支付宝的作用，即钱虽然表面上是点对点转账的，但经过支付宝后，支付宝就要求相关转账信息的回执必须由它中转一次再告知转账发起人。</li></ol><h3><span id="网络拓扑">网络拓扑</span></h3><p><img src="https://img.hi-linux.com/staticfile/ee0724cd54a8e17f32a0971e2f4969fc-20231017155659529-2023-10-17-FjrDYN.png" alt="旁路由架构的网络拓扑图"></p><p>可以看到，无论如何配置，我们都需要保证数据按图中的拓扑进行流转，才能实现我们所希望的只在旁路由增加功能而不修改主路由的目的。由于流量（至少上行流量）总会流经旁路由，所以旁路由实质上就是一层透明代理。</p><h3><span id="工作原理">工作原理</span></h3><p>那么我们该怎么实现这样的网络拓扑呢？让我们先来看下数据在网络的更底层是如何流转的。</p><p><img src="https://img.hi-linux.com/staticfile/d247c8b3d92cd3990245b622d5e7aa56-2023-10-17-axxUVL.png" alt="旁路由架构的数据流转示意图"></p><p>从图中可以看到，当我们从手机等终端设备发出一个数据包时，数据包总是由我们的终端设备经由网关路由至目的地址，目的地址返回数据时也是相同的路径。这是因为终端设备本身通常是不具备路由功能的，单单一个路由表终端设备就搞不定。</p><p>既然数据必然经过网关，那么我们只要强制把旁路由作为终端设备对外数据交互的第一层网关即可。至此旁路由的工作原理其实就已经解释清楚了，即在另一台路由器上实现的基于网关的透明代理。而网上各式各样的教程其实都是在教我们解决如何配置网关的问题。</p><p>在这一章节还需要说明的是为什么各个教程都要求我们把旁路由的 IP 配置在和主路由相同的 IP 网段。所谓的 IP 网段实际上就是子网，同一子网下的主机（设备）可以直接通信，跨子网则需要通过某种形式转换后才能通信，而这些转换虽然可行但比较复杂，在旁路由这个场景下显然是没有必要的。本着不改变原有网络拓扑的原则，旁路由自然也要配置在和主路由及其他设备相同的子网才行。</p><h2><span id="旁路由的配置">旁路由的配置</span></h2><p>那么我们该如何配置网关以让数据按上文的工作原理进行流转呢？</p><h3><span id="一旁路由的网关设置">（一）旁路由的网关设置</span></h3><p>首先我们先来解决旁路由的网关问题。在上文的拓扑图中我们可以看到，旁路由虽然挂着路由器的名字，但它本质上也是网络链路中的一个节点，因此它也需要请求上层网关才能完成数据流转。而主路由是这个网络拓扑的出口，所以旁路由的网关自然要配置为主路由的 IP 地址。这一项配置是必须且不会随终端网关配置方式的变化而改变的，无论如何指定网关请求旁路由，旁路由本身都要依赖此配置才能完成正常的流量转发。</p><p>此外，还有子网掩码需要进行配置。前面有提到，在同一子网内的主机之间才能直接通信，而 IP 和子网掩码相组合便能确定设备当前所在的子网。旁路由并不改变网络拓扑，所以需要和主路由在同一子网内。因此将旁路由的子网掩码配置设置为主路由的子网掩码即可。同理，下文的所有子网掩码配置也均需要与主路由的保持一致。</p><h3><span id="二旁路由的dhcp配置">（二）旁路由的DHCP配置</span></h3><p>虽然配置了网关后数据流转图中的左半边已经成型，但如果不对旁路由的 DHCP 进行配置，实际上会导致各种各样的疑难杂症或直接无法联网。</p><p>原因在于 DHCP 使用了 UDP 协议，UDP 是没有连接的，如果主路由和旁路由同时开启 DHCP，则任意一个 DHCP 服务器都可能会应答终端的申请，进而导致 IP 下发和路由表的混乱造成各种无法连接的疑难杂症。当然，我们可以将两个 DHCP 的子网网段拆分开来解决共存问题，但这个行为在旁路由场景下并没有实际意义。</p><p>因此我们需要保证网络中只有一个设备承担 DHCP 功能，出于不改变原网络拓扑和避免无意义 NAT 的考虑，我们通常选择关闭旁路由的 DHCP 功能（对应到 OpenWrt 则选择「忽略此接口」）。</p><h3><span id="三终端网关配置">（三）终端网关配置</span></h3><p>对于手机、电脑等终端，我们的目标是将其网关配置为旁路由的 IP 。实现方案很多，成本较低的主要为以下两种。</p><h4><span id="手动指定">手动指定</span></h4><p>顾名思义，只需要在终端设备的网络设置中将网关手动配置为旁路由即可。以 iOS 系统为例：</p><p><img src="https://img.hi-linux.com/staticfile/3f58fee3de6f48c714173df4f26aac2e-20231017155712142-2023-10-17-r8gGV8.jpg" alt="iOS 网络配置界面"></p><p>手动填写一个网络上未被占用的 IP 地址，而子网掩码以主路由为准，网关则填写旁路由的 IP 地址。</p><p>手动指定的好处在于完全不影响原网络的使用，设备按需配置是否使用旁路由作为网关以实现特定功能。当旁路由故障时，未手动指定的设备仍能正常上网。</p><p>缺点在于操作烦琐。手机、电脑还好，但电视或根本没有屏幕的设备设置起来就会很麻烦。</p><h4><span id="依赖dhcp指定">依赖DHCP指定</span></h4><p>DHCP 除了可以管理 IP 的分配，还会下发网关和 DNS 服务器信息，因此我们还可以借助 DHCP 的这一机制来为所有终端统一设置网关，而不再需要逐个手动修改。</p><p>前面提到，我们关闭了旁路由的 DHCP 功能，因此这个统一下发的工作就要交给主路由来完成。只需要在主路由的 DHCP 配置中将网关配置为旁路由的 IP 地址即可。</p><p><img src="https://img.hi-linux.com/staticfile/fc7f640460453d3eb1b6aa3d5c849c5c-2023-10-17-J0Xb4B.png" alt="OpenWrt 的 DHCP 配置界面"></p><p>以 OpenWrt 为例，将主路由 DHCP 下发的网关配置为旁路由 IP 地址即可（3 表示网关，6 表示 DNS 服务器地址）。</p><p>不过有些路由器的默认固件没有开放该配置项，对于这些设备，除非可以 SSH 连接后手动改配置，不然无法使用此种指定方式。</p><p>这种方式的好处显而易见，一次配置全家受用；缺点在于当旁路由出现故障时，所有连接的设备都会无法上网。</p><h3><span id="四dns的配置">（四）DNS的配置</span></h3><p>细心的读者可能发现了上文只提到了网关的配置，但未提到很多教程中的 DNS 配置。实际上单单就旁路由本身来说，网关配置完成后整个网络拓扑就已经搭建完毕了。但对于一些特定诉求，比如依赖旁路由进行统一的 DNS 劫持（很多功能的底层都依赖于此），则需要将对应位置的 DNS 也配置为旁路由的 IP 以将域名解析工作也完全交由旁路由处理。</p><h2><span id="配置步骤总结">配置步骤总结</span></h2><h3><span id="手动指定方案">手动指定方案</span></h3><ol><li>为旁路由配置和主路由同网段的静态 IP 地址，同时将旁路由的网关和 DNS 指向主路由，子网掩码与主路由保持一致。</li><li>旁路由关闭 DHCP 服务。</li><li>在主路由防火墙开启 SYN-flood 防御的情况下，关闭旁路由防火墙的 SYN-flood 防御（可选）。</li><li>在需要接入旁路由的终端设备中，将网关和 DNS 配置为旁路由 IP 地址，配置同网段的 IP 地址和与主路由相同的子网掩码。</li></ol><h3><span id="dhcp下发方案">DHCP下发方案</span></h3><ol><li>为旁路由配置和主路由同网段的静态 IP 地址，同时将旁路由的网关和 DNS 指向主路由，子网掩码与主路由保持一致。</li><li>旁路由关闭 DHCP 服务。</li><li>在主路由防火墙开启 SYN-flood 防御的情况下，关闭旁路由防火墙的 SYN-flood 防御（可选）。</li><li>在主路由的 DHCP 配置中，将其下发的网关和 DNS 配置为旁路由的 IP 地址。</li></ol><h2><span id="疑难杂症的解决">疑难杂症的解决</span></h2><p>虽然配置步骤看上去很简单，但很多人在实际使用中都会遇到逐步配置却上不了网或网络慢的问题，这里挑几个典型案例来解析。</p><h3><span id="一该不该设置iptables的masquerade">（一）该不该设置iptables的MASQUERADE</span></h3><p>这可能是争议最大的一条，有人说这条规则加上后影响性能而且没意义，但也有很多人表示不配这条就是连不上网（大多为连接不上国内网络）。</p><p>这条规则的作用本质上是在旁路由上做 SNAT，只不过修改的地址不需要指定而是动态获取旁路由对应接口网卡的 IP 地址，在 OpenWrt 里被称为「IP 伪装」。</p><p><img src="https://img.hi-linux.com/staticfile/2d0c6641e3f951044153129b3176ab66-20231017155721745-2023-10-17-FI1Wzy.png" alt="配置 MASQUERADE 后的数据流转示意图"></p><p>单从旁路由的网络拓扑来说，这条规则确实没意义，因为主路由作为对外出口必做 NAT，但旁路由本身就在局域网内且只是链路上的一环，没有必要再对内网 IP 进行耗费性能的 NAT 操作。</p><p>但不要忘了，理论和现实是两回事，物理网络拓扑中的不同设备、不同固件都有可能产生各种奇怪的兼容问题。我自己倒是没有遇到过该问题，但检索网友们的各种帖子，大概可以分为以下几种原因：</p><ol><li><strong>主路由固件数据包处理问题</strong>：部分路由器（似乎主要为国产品牌）的无线网在桥接和 iptables 处理过程中，当旁路由将国内流量重新转发回主路由时，主路由根据流中的首个数据包的状态做判断导致后续数据包未进行 NAT 就直接访问了互联网。<a href="https://blog.csdn.net/qq1337715208/article/details/122271608" target="_blank" rel="noopener">这篇文章</a>对此有比较详细的讲解（CSDN 也是有很多好文章的）。</li><li><strong>主路由 NAT 硬件加速导致的问题</strong>：可能是由于硬件加速流程对数据包的处理出现了类似于原因 1 的问题导致无法正确完成数据交互。由于硬件加速本质上是在运行特殊驱动，而各家厂商的该驱动几乎都是闭源的，所以网上也没见到有探究深层原因的资料。这种情况下把硬件加速关闭即可（会一定程度牺牲主路由 NAT 性能）。</li><li><strong>IP 和 MAC 校验机制导致包被丢弃的推论</strong>：由旁路由的网络拓扑可知，配置网关后上行流量必然经过旁路由，但在旁路由不进行 NAT 时数据包中的 IP 仍然是终端设备的，所以理论上下行数据并不会经过旁路由而是由主路由直接转发至终端。显然，由于旁路由的存在，IP 地址和 MAC 地址在某个环节会有不匹配的情况，如果主路由对此有校验，那数据包就会被丢弃掉。但这也只是个推论没有证据佐证，同时由于网络可能的复杂性，主路由通常也不会主动做这种校验。</li></ol><p>MASQUERADE 配置其实并没有定向地去解决上面这些具体问题，而是通过 NAT 来隐藏终端设备、只向主路由暴露旁路由 IP 的方式，一刀切地避免了上述原因导致的问题。但由于上下行流量都会经过旁路由，所有流量都会被二次 NAT 和二次转发，网络的吞吐会有不小的下降，直观感受就是下载速度变慢了。</p><p><strong>所以比较理想的策略是，先不加 MASQUERADE 规则观察是否有问题（尤其是国内流量），如果确实有问题，在权衡可以接受性能的损失后再配上该规则。</strong></p><h3><span id="二lan和wan是否需要绑定">（二）LAN和WAN是否需要绑定</span></h3><p>具体操作是取消桥接，再设置 WAN 和 LAN 共用同一个网卡（如 eth0 ）。这个操作其实和 MASQUERADE 规则的效果类似，因为绑定后经过 WAN 的流量必然会被 SNAT 。<strong>适用于确实遇到了疑难杂症且能接受性能损失场景下的备选方案。</strong></p><h3><span id="三是否需要关闭旁路由桥接">（三）是否需要关闭旁路由桥接</span></h3><p>在许多教程里，这个操作和添加 MASQUERADE 规则是配套的。但桥接与否实际上并不会影响整体的网络拓扑，这看上去又是一项没有意义的配置。我猜测可能是网上流传的添加 MASQUERADE 规则的方式是下面这条固定命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>也就是要求 SNAT 时从 eth0 网卡动态获取 IP 。而在桥接模式下，MASQUERADE 时是需要从 br-lan （常见的桥接后的默认网卡名称，也可能是其他名称，要视实际情况而定）获取 IP 的，直接复制粘贴上面的命令会导致 IP 伪装失败。<strong>所以只要把 -o 参数的值改为 br-lan 即可：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -I POSTROUTING -o br-lan -j MASQUERADE</span><br></pre></td></tr></table></figure><p>但似乎确实有网友不取消桥接就无法联网，这种情况大概率是旁路由固件对桥接模式的处理有问题（多见于 ARM 架构的固件，这类固件通常要做很多的魔改适配），<strong>如果真的遇到这种情况的话则确实可以取消桥接尝试下</strong>，毕竟大多数情况下旁路由内部的桥接也没什么实际意义，去掉后由于少了流量判断流程可能还会有非常微小的性能提升。</p><p>至于 N1 这种自带无线功能但实际上没人用的设备，在关掉无线后，确实可以顺便取消掉没有意义的桥接。只是在 OpenWrt 取消桥接保存配置时，要确定选中了有线网卡对应的接口比如 LAN/eth0 ，不然如果后台的前端存在体验问题自动选择了 wlan ，那保存后路由器可就直接失联了。</p><h3><span id="四是否需要设置dhcp强制">（四）是否需要设置DHCP强制</span></h3><p>如果我想通过 DHCP 下发网关但又不想改变主路由的原配置该怎么办呢？在 OpenWrt 的接口 DHCP 配置中有一个选项叫做「强制」，勾选后，此设备会忽略网络上已经存在的 DHCP 服务，强制启动本机的 DHCP 服务，所以似乎我们只需要在旁路由上配置此选项，并在旁路由 DHCP 中配置好网关，主路由不做任何变更，即可实现本段开头的诉求。</p><p>但上文提到同一子网中只能有一个用于分配指定网段的 DHCP 服务，因此旁路由强制开启 DHCP 后，还需要主路由具备主动判断网络情况停止提供 DHCP 服务的能力，这个流程才能真正运转起来。<strong>但并不是所有的路由器和固件都支持这个能力，目前来看 OpenWrt 作为主路由固件时可以正确检测并停用 DHCP ，其他固件则需要在使用时做下兼容性测试。从工程角度上讲，由于这样的操作过于依赖外部能力，属于和外部组件产生了强耦合，不利于未来维护，故不太推荐此种方案。</strong></p><h3><span id="五旁路由的某些功能无法使用">（五）旁路由的某些功能无法使用</span></h3><p>各种组件内部实现大不相同，如果某个组件的代码对网络结构做了强限定（如上文所说的校验 IP 和 MAC 的匹配关系），那旁路由的加入可能就会打破组件预期的网络结构导致其无法运行。这种情况在组件本身不做适配时基本无解，只能尝试下开启 MASQUERADE 等配置，<strong>看看多加一层 NAT 后的网络拓扑是否能符合组件要求，但代价同样是会牺牲性能。</strong></p><h3><span id="六是否应该关闭旁路由防火墙的syn-flood防御">（六）是否应该关闭旁路由防火墙的SYN-flood防御</span></h3><p>SYN-flood 是一种常见的攻击方式，SYN 指 TCP 建连三次握手中的第一步报文，flood 指大量发起该步骤的报文。由于 TCP 的实现原理要求服务端接收到 SYN 报文后回复客户端 SYN+ACK 报文表明请求被接受，并在一段时间内等待客户端回复最终的 ACK 报文，那么大量的 SYN 报文就会导致服务端出现大量等待最终资源耗尽挂掉，而攻击者并不需要真的完成建连，只要持续发送 ACK 包即可。</p><p>那路由器的防火墙又是如何作防御的呢？以 OpenWrt 为例，虽然 OpenWrt 的防火墙配置已经迁移到了 fw3 ，但翻看代码历史我们就会看到当时 OpenWrt 直接基于 iptables 的早期实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$IPTABLES -N syn_flood</span><br><span class="line">$IPTABLES -A syn_flood -p tcp --syn -m limit --limit $rate&#x2F;second --limit-burst $burst -j RETURN</span><br><span class="line">$IPTABLES -A syn_flood -j DROP</span><br><span class="line">$IPTABLES -A INPUT -p tcp --syn -j syn_flood</span><br></pre></td></tr></table></figure><p>即借助 iptables 的 SYN 限流能力进行防御，同时此配置位于 default 配置中，会在 NAT 等具体网络操作之前执行。</p><p>对应到主路由，wan 口接收到攻击流量后便会进行限流，攻击者无法直接向后攻击到内网主机，那么同样为内网主机的旁路由自然理论上也就不会被攻击到。</p><p>但对于旁路由来说，理论上网络中的所有上行流量都会通过它来转发，那当流量超过防火墙的限流阈值时便会触发拦截，进而在终端上表现为网络时断时续。<strong>所以在主路由已开启 SYN-flood 防御的情况下，旁路由关闭该配置可以避免出现可能的网络不稳定问题。</strong></p><h2><span id="旁路由与ipv6">旁路由与IPv6</span></h2><p>IPv6 在家用网络中通常默认是没有 NAT 转换流程的，同时其动态地址配置方案比 IPv4 要复杂得多，比如 SLAAC 和之前的 DHCP 可以说完全不是一套机制，而 DHCPv6 又分有状态和无状态两类。而前面提到，我们实现旁路由网络拓扑的过程，其实就是在指定一个具备透明代理功能的网关的过程，但 SLAAC/DHCPv6 都没有提供网关下发能力，终端设备总是会以其所交互的主机作为网关，同时大多也不支持直接修改网关。此外，运营商不支持 DHCPv6-PD 、IPv6 子网限定范围等情况，<strong>都使得旁路由支持 IPv6 非常困难，在不同场景、不同网络下要面临不同的配置，甚至无方案可配置。</strong></p><p>网上比较流行的旁路由 IPv6 实现是个曲线救国的折中方案，即先开启主路由的内网的 IPv6 地址分配进而让旁路由获得内网 IPv6 地址，随后再通过在旁路由开启一个 DHCPv6-Client 的方式获取到公网的 IPv6 地址，这样便可以将主路由的 DHCPv6 下发的 DNSv6 配置为旁路由的 IPv6 地址。此时除了 DNSv6 的解析是在旁路由进行，其他流程仍按原链路直连。而在需要分流的场景中，OpenWrt 的相关组件可以选择在解析域名时放过不需要处理的 IPv6 流量让其正常解析出 AAAA 记录，而对域名名单中的流量强制解析为 A 记录以继续走 IPv4 协议，从而实现和此前的类似的旁路由功能。</p><p>当然，这种解析实际上依赖于组件的能力。如果组件并不支持，那通过各种方式强制定义 IPv6 的路由表保证相关 IPv6 流量必然经过旁路由也是一种解决方案。<strong>不过无论哪种实现，由于不借助网关配置，其实都已经和本文的旁路由不相关了。</strong></p><p>此外，还有种方案是通过 radvd 等支持配置路由单播和优先级的工具，用更高的优先级来指定终端的 IPv6 路由（可以简单理解为 IPv4 的网关），这样就替代了 IPv4 下手动配置或 DHCP 下发网关对应的功能，完美满足本文所说的旁路由网络拓扑，同时对 IPv6 动态地址配置方案的要求很低，但要求终端设备支持路由优先级配置。</p><h2><span id="总结">总结</span></h2><p>旁路由实际上是运行透明代理功能的网关，有人认为这个概念很民科，但我并不认同，毕竟它只是在通过已有的能力来解决特定场景的问题，和我们写代码、做产品没有本质区别，而「旁路由」这个名词也不过是个约定俗成的叫法而已，不应该被批判。</p><p>另一方面，由于旁路由在不同设备、不同网络环境有可能遇到很多奇怪问题，其实对于非专业用户来说付出的时间成本很有可能会远大于直接替换主路由的成本。但生命不息，折腾不止，如果是为了收获折腾的快乐、学习到新的知识，那又有何不可呢？</p><blockquote><p>本文转载自：「 Eason Yang’s Blog 」，原文：<a href="https://url.hi-linux.com/1jwRt" target="_blank" rel="noopener">https://url.hi-linux.com/1jwRt</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最早听到旁路由这个词是在 2020 年折腾 N1 的时候，这台单网口的小盒子只能用网上所说的旁路由方案接入局域网来实现期望的功能。现在回想起来，旁路由这个词有可能就是在那个发烧友大量折腾斐讯 N1/P1/T1 的时期被发明出来的。&lt;/p&gt;
&lt;p&gt;你没办法在发烧友圈子外的互联网及各种学术材料中找到对旁路由的描述和定义，当然也找不到合适的英文翻译（导致这篇文章的 slug 定义困难）；从拓扑上看，旁路由更像是杂糅了二级路由和透明网关的概念，除了实体确实多接了根网线放在主路由旁边，其本身并没有真正地开启一条旁路，做的事情也基本可以和网关的定义对齐。&lt;/p&gt;
&lt;p&gt;不过，由于这个说法主要集中于网友的交流讨论之中，而且几年来在有相关需求的广大用户中被广为接受，所以只要这个词不变为一个学术概念，那我倒也不觉得有什么不妥。下文也仍然会用「旁路由」一词来指代在此类拓扑结构中担任代理网关角色的路由器。&lt;/p&gt;
&lt;p&gt;此外，本文对于原理的解释偏多且为新手向，对于已经熟知相关概念的读者则可以将本文作为 cheat sheet 食用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="网络" scheme="https://www.hi-linux.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="路由" scheme="https://www.hi-linux.com/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>SRE 生产环境上线操作指南</title>
    <link href="https://www.hi-linux.com/posts/20428.html"/>
    <id>https://www.hi-linux.com/posts/20428.html</id>
    <published>2023-10-13T01:00:00.000Z</published>
    <updated>2023-10-13T05:43:26.125Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>我们每天要进行大量的线上变更操作。怎么保证这些操作安全，不会导致故障，是我每天都在思考的问题。</p><p>这篇文章从工作经历总结一些原则和想法，希望能有帮助。</p><p>线上操作有几点基本的要求：</p><ul><li>操作需要是可以<strong>灰度的</strong> (Canary)：即能够在一小部分范围内生效，如果没有问题，可以继续操作更多的部分；</li><li>操作必须是可以验证和监控的：要知道自己操作的结果，是否符合预期；</li><li>操作必须是可以回滚的：如果发现自己的操作不符合预期，那么有办法能够回到之前的状态；</li></ul><p>逻辑很简答：假设我一开始做操作范围很小，可以灰度，做完之后我可以监控是否符合预期，如果不符合预期就回滚，那么，操作就是安全的。</p><p>这三步中的每一步看似很简单，但是实际做起来很难。</p><a id="more"></a><h2><span id="灰度">灰度</span></h2><p>发布过程是最简单的一种灰度场景，现在有蓝绿发布模式：</p><ol><li>分成两组，将所有的流量切换到绿组；</li><li>先发布蓝组，此时是没有流量的，发布完成之后，将流量逐渐切换到蓝组；清空绿组；</li><li>然后发布绿组，发布完成之后将流量切换到平均到两组</li></ol><p>还有滚动发布，对于每一个实例：让 Load Balancer 不再发给它新的流量，然后升级，然后开始接收流量，如果没有问题，继续以此处理其他的实例。</p><p>几乎每个人都可以理解灰度的必要性，但是不是每一种操作都是可以灰度的。</p><p>比如说数据库 DDL 的变更，很难灰度，提交到数据库，数据库就开始应用了；还有一些动态配置系统，一些全局配置，如果修改，就对所有的应用同时生效的；一般都是这样一些数据源类型的变更，很容易出现不支持灰度的情况。不可以灰度的情况也是最容易导致问题的。</p><p>一个替代方案是，搭建一套一模一样的环境，在这个环境先应用变更，测试一下是否符合预期。但是在今天分布式环境下，很难模拟出来一模一样的环境，可能规模小了，可能测试环境没有一些用户的使用场景，等等。总之，模拟的环境没有问题，不能代表生产的环境就没有问题。</p><p>最好的解决办法，还是在软件和架构，从设计上就能支持灰度。</p><h2><span id="验证与监控">验证与监控</span></h2><p>所有的操作，一定要知道自己在做什么，效果是什么。做完之后进行验证。听起来很简单，但是实际上，很多人做事像是闭着眼睛，不知道自己在做什么，做完之后有什么效果也不管。</p><h3><span id="验证操作的结果">验证操作的结果</span></h3><p>举一个例子，比如目前网关遇到了什么问题，经过查询，发现和 Nginx 的一个参数有关，然后根据网上的内容修改了这个参数，回头去看问题解决了没有。如果没有，继续在网上查资料，看和什么参数有关。</p><p>上述操作，一个潜在的问题是，当问题真正修复了之后，我们不知道自己做了啥才修复问题的。也有一些时候，相同的配置变了名字，实际上这个修改这个参数是可以解决问题的，只不过我们用了从网上得到的过时的参数名字，所以不生效。</p><p>所以，对于每一个操作，推荐直接去验证目前的操作结果。比如改了一个 log 参数，那么直接去看这个参数是否生效，是否符合预期，然后再去看其他的问题是否得到解决。</p><p>做操作要一步一步来，做一步验证一步。</p><p>另外，最好去验证操作的副作用，而不是验证操作本身。比如，修改了一个配置，不是去 <code>cat</code> 一下配置文件确认就可以了，而是要去看自己修改的配置是否真的生效了。比如路由器设备，我们执行了一些命令 <code>ip route ...</code> ，验证的方法并不是 <code>show running-config</code> 去看配置是否有这一条，而是要去看 <code>show ip route</code> 确定配置是否生效。</p><h3><span id="验证核心的业务指标">验证核心的业务指标</span></h3><p>除了验证操作结果之外，也要关注业务指标是否还正常。</p><p>如果业务指标不正常了，而恰好和自己的操作时间吻合，那么就应该立即回滚。</p><p>听起来很合理？但是实际上，很多人（我也是）第一反应都会是，我的操作不可能引起这个问题，让我先看看日志，到底发生什么了。</p><p>当发生问题的时候，时间很宝贵，正确的做法是第一时间在群组里面宣布自己的操作（事实上，操作之前就宣布了，但是消息太多，没有问题的时候没有人会认真看操作历史），然后开始进行回滚。可惜的是，我发现这么做的人很少，大部分都是想去排查，直到确定是自己的操作导致的，才开始回滚。</p><h2><span id="回滚">回滚</span></h2><p>同上，不是所有的操作都可以回滚的。一些可以补偿的方案有，操作上尽量设计成可以回滚的（有些废话）。比如，<a href="https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321" target="_blank" rel="noopener">DDIA</a> 这本书就介绍了数据上如何做向前兼容和向后兼容的方法。</p><p>举个例子，比如软件新版本的一个配置要从名字 A 改成 B，不要直接改，而是添加一个配置 B，代码里面可以读 B，如果没有的话，尝试读 A。等升级完成之后，在下一个新版本中，去掉 A 的逻辑。这样，每两个版本之间都是兼容的。</p><p>除此之外，还有一些我认为非常重要的东西。</p><h2><span id="操作计划和操作记录">操作计划和操作记录</span></h2><p>一些复杂的操作，比如修改 DNS，配置网关，配置其他东西，可能是联动的。而且显示中也不是所有的东西都适合自动化的。这些复杂的操作，推荐在操作之前就写好操作计划，然后对着一步一步操作，贴上必要的验证结果和操作时间。万一出现什么异常，就可以将异常出现的时间和自己的操作记录对照，很有用的。操作计划也可以相互 review，如果是 gitops 的话，就更好了。</p><h2><span id="效率">效率</span></h2><p>这是 <strong>Last but not least!</strong> 操作的效率至关重要。</p><p>我认为运维平台要设计成简洁，没有歧义，流程清晰的，非必要不审批。这可能跟直觉相反，尤其是领导的直觉。</p><p>领导（不知为何）觉得审批流程越多越好，出了事故就开始思考在哪一个阶段可以加上一个审批流程，来避免类似的问题发生。但其实，我觉得流程越多，出问题的概率不减反增。</p><p>程序员天生就不喜欢繁重的流程，如果流程太重，就会出现其他的问题，比如，人们会想办法绕过不必要的流程；会想办法“搭车发布”（意思就是将多个操作合并成一个，这也是违反原则的，一次应该只做一个操作）；对于明显出现异常苗头的时候，因为不想重新走审批而铤而走险。</p><p>但是出现这种情况，领导不会觉得流程有问题，领导会觉得你小子不按照流程办事，开除。</p><p>最后导致 SRE 的幸福感很低，事情还是要那么多，完成工作不得不铤而走险，还得责任自负。</p><p>事实上，真正能保证安全的是架构设计简单，做事的人知道自己在做什么，操作按照如上灰度、验证，出问题回滚，而不是靠流程。SRE 之间 Review 是有价值的，审批是没有价值的，大部分的审批仅仅是请示一下领导而已，领导可能看不懂操作的后果是什么。</p><p>所以，流程是有代价的。</p><blockquote><p>本文转载自：「卡瓦邦噶」，原文：<a href="https://url.hi-linux.com/0LB3T" target="_blank" rel="noopener">https://url.hi-linux.com/0LB3T</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们每天要进行大量的线上变更操作。怎么保证这些操作安全，不会导致故障，是我每天都在思考的问题。&lt;/p&gt;
&lt;p&gt;这篇文章从工作经历总结一些原则和想法，希望能有帮助。&lt;/p&gt;
&lt;p&gt;线上操作有几点基本的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作需要是可以&lt;strong&gt;灰度的&lt;/strong&gt; (Canary)：即能够在一小部分范围内生效，如果没有问题，可以继续操作更多的部分；&lt;/li&gt;
&lt;li&gt;操作必须是可以验证和监控的：要知道自己操作的结果，是否符合预期；&lt;/li&gt;
&lt;li&gt;操作必须是可以回滚的：如果发现自己的操作不符合预期，那么有办法能够回到之前的状态；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;逻辑很简答：假设我一开始做操作范围很小，可以灰度，做完之后我可以监控是否符合预期，如果不符合预期就回滚，那么，操作就是安全的。&lt;/p&gt;
&lt;p&gt;这三步中的每一步看似很简单，但是实际做起来很难。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DevOps" scheme="https://www.hi-linux.com/tags/DevOps/"/>
    
  </entry>
  
</feed>
