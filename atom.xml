<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇妙的 Linux 世界</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hi-linux.com/"/>
  <updated>2024-03-14T03:05:50.391Z</updated>
  <id>https://www.hi-linux.com/</id>
  
  <author>
    <name>Mike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『IT 人员必备工具箱』：一个专注于 IT 人的优质资源分享导航站</title>
    <link href="https://www.hi-linux.com/posts/53504.html"/>
    <id>https://www.hi-linux.com/posts/53504.html</id>
    <published>2050-03-18T01:00:00.000Z</published>
    <updated>2024-03-14T03:05:50.391Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』是一个专注于 IT 人优质资源分享的导航站，包含大量好玩又实用的 AI、翻译、编程、设计、Linux、网络、云原生、安全等多款应用。</p><p>🏷️  网站地址：<a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a></p><p><img src="https://img.hi-linux.com/staticfile/Tweelet00-2024-03-14-n0S5jR.webp" alt="全站预览图"></p><p>我们的目标是帮助更多 IT 人发现有价值的优质资源，让更多人受益。</p><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』也可以推荐你喜欢的软件和网站呢！如果你有什么好玩有趣又实用的酷软趣站，快『<a href="https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz" target="_blank" rel="noopener">推荐</a>』给我们吧！</p><p>🏷️  趣站酷软推荐收集表: <a href="https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz" target="_blank" rel="noopener">https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz</a></p><a id="more"></a><p>『<a href="https://666666.dev" target="_blank" rel="noopener">IT 人员必备工具箱</a>』部分截图展示：</p><p><img src="https://img.hi-linux.com/staticfile/Tweelet01-2024-03-14-9hHDLK.png" alt="实用工具"><br><img src="https://img.hi-linux.com/staticfile/Tweelet02-2024-03-14-ejfZrm.png" alt="奇妙的 Linux 世界 + 搜索引擎 + 新闻资讯"><br><img src="https://img.hi-linux.com/staticfile/Tweelet03-2024-03-14-ZkjPxQ.png" alt="电子邮件 + 出行服务 + AI 翻译利器"><br><img src="https://img.hi-linux.com/staticfile/Tweelet04-2024-03-14-NbfprZ.png" alt="AI 新世界 + 云服务"><br><img src="https://img.hi-linux.com/staticfile/Tweelet05-2024-03-14-xTbQV6.png" alt="编程开发"><br><img src="https://img.hi-linux.com/staticfile/Tweelet06-2024-03-14-OvFNBk.png" alt="GitHub 热榜 + 网络调试"><br><img src="https://img.hi-linux.com/staticfile/Tweelet07-2024-03-14-bluwgD.png" alt="绘图设计 + 镜像加速"><br><img src="https://img.hi-linux.com/staticfile/Tweelet08-2024-03-14-G4HEGV.png" alt="云原生容器化 + 安全相关 + 玩转 NixOS + 博客网摘"><br><img src="https://img.hi-linux.com/staticfile/Tweelet09-2024-03-14-FjDHJs.png" alt="职来职往 + 光影时刻 + 音乐之声"><br><img src="https://img.hi-linux.com/staticfile/Tweelet10-2024-03-14-3W7reF.png" alt="趣站酷软"></p><p>📕 关注『<a href="https://mp.weixin.qq.com/s/8iRVr_IN3jB3MnmAdgAOoQ" target="_blank" rel="noopener">奇妙的 Linux 世界</a>』公众号，带你开启有趣新生活！更多好用好玩的软件资源，可访问 <a href="https://666666.dev" target="_blank" rel="noopener">https://666666.dev</a> 免费获取。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IT 人员必备工具箱&lt;/a&gt;』是一个专注于 IT 人优质资源分享的导航站，包含大量好玩又实用的 AI、翻译、编程、设计、Linux、网络、云原生、安全等多款应用。&lt;/p&gt;
&lt;p&gt;🏷️  网站地址：&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://666666.dev&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/Tweelet00-2024-03-14-n0S5jR.webp&quot; alt=&quot;全站预览图&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们的目标是帮助更多 IT 人发现有价值的优质资源，让更多人受益。&lt;/p&gt;
&lt;p&gt;『&lt;a href=&quot;https://666666.dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IT 人员必备工具箱&lt;/a&gt;』也可以推荐你喜欢的软件和网站呢！如果你有什么好玩有趣又实用的酷软趣站，快『&lt;a href=&quot;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;推荐&lt;/a&gt;』给我们吧！&lt;/p&gt;
&lt;p&gt;🏷️  趣站酷软推荐收集表: &lt;a href=&quot;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.qq.com/form/page/DQm1UVEJJV0ZPUXlz&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>给「打工人」的维权指南：聊聊我的职场维权实战经验</title>
    <link href="https://www.hi-linux.com/posts/59972.html"/>
    <id>https://www.hi-linux.com/posts/59972.html</id>
    <published>2024-03-04T01:00:00.000Z</published>
    <updated>2024-03-04T08:01:44.699Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>这是我第一次尝试写个人年度总结。</p><p>我的 2023 年与 2022 年不可分割，一直走在维权的路上。</p><p>早在 2022 年初，我的职业生涯发生重大转变，公司在未与我协商的情况下，单方面将我待岗，降低工资，移交工作。我从熟悉的工作环境被迫成为了一个「半自由职业者」。我之所以自认为是半自由，是因为公司未与我解除劳动合同，所以劳动关系还在原公司。法律规定劳动者只能和一家用人单位签订劳动合同，所以我在与公司存在劳动争议的情况下，无法入职下家公司。</p><p>除此之外，公司隔几个月后停发我的工资，切断了我唯一的经济来源。我开始尝试学习《劳动法》及相关法律知识，查阅和自己案件类似的裁判文书，整理书面材料，为的是跟公司对簿公堂，讨回做为劳动者的尊严和权益。</p><p>在劳资关系中，公司具有优势地位，而劳动者处于弱势的一方。尤其是面对老板、人事、法务组成的流氓团伙时，会更加被动、愤怒、迷茫、无助。希望大家在面对公司的恶意时可以更加从容，是我写下这些文字的初衷。</p><a id="more"></a><h2><span id="在职仲裁-or-离职仲裁">在职仲裁 or 离职仲裁</span></h2><p>以前一直以为遇到劳动争议问题，要离职后才能提起仲裁，但后来从网络了解到我的案件情况更适合在职仲裁，在职期间可以随时申请，所以我**尝试提起在职仲裁。**仲裁期间可以正常上班，自己也有机会尽可能地多搜集一些证据。因为公司取消了我的办公权限，我目前已经不需要去公司打卡了。</p><p>相比在职仲裁，选择<strong>离职仲裁是最为常见的情况</strong>，可固定和搜集的证据空间有限，适合情况简单的案子。需要注意，离职仲裁有时效性，期限为一年。也就是说发生劳动争议后，需在劳动关系终止之日（离职当天）起一年内提出。否则既不能仲裁也不能诉讼。</p><p><img src="https://img.hi-linux.com/staticfile/1-2024-03-04-hL5ZpT.jpeg" alt>劳动人事争议仲裁流程图（<a href="http://www.bjchy.gov.cn/affair/ldwq/tjzc/8a24fe9767393e2d01673f3dbdc70a21.html" target="_blank" rel="noopener">图源</a>：附件材料）</p><h3><span id="员工不能提供离职证明的解决办法">员工不能提供离职证明的解决办法</span></h3><p>如果已经和公司解除劳动合同， 但公司不配合，我们无法在入职新公司时提供证明该怎么办？</p><h4><span id="正常的法律渠道">正常的法律渠道</span></h4><p>依照法律规定，用人单位有义务在解除劳动合同时出具离职证明。所以我们可以打电话向当地劳动监察大队投诉，或者通过劳动仲裁要求公司出具离职证明并赔偿由此带来的损失。但这么做要花费一定的时间成本。</p><h4><span id="相对简单的解决办法">相对简单的解决办法</span></h4><p>虽然我们不能提供离职证明，但若是在客观事实中，与上一家用人单位的劳动合同已经解除或终止，则公司录用我们时已无法律障碍。我们可以提供与原公司劳动合同解除或终止的相关证明，例如：向原公司提出的《离职申请》、《工作交接记录》、《社保减员证明》等。</p><p>我们还可以向将要入职的公司，出具《承诺函》：<br>本人 A，身份证号：xxx，向 B 公司郑重承诺，本人已经与 C 公司劳动合同解除，若因本人做虚假承诺，给 B 公司造成任何不利后果，都由本人承担。落款：承诺人（签名），x 年 x 月 x 日。</p><h3><span id="提起劳动仲裁前需要注意什么">提起劳动仲裁前需要注意什么</span></h3><p>分享一个我在仲裁前，来自律师的建议：在准备《仲裁申请书》的请求事项中，可以把能想到的都写上（未休年假、加班费、绩效提成等），每项要写清楚详细的计算方式，然后对应去搜集证据，围绕诉求中的主张和证据，阐述事实和理由。</p><p>仲裁委不一定支持当事人的全部主张，但没写在请求事项中的内容一定不会得到支持。</p><p>我将注意事项的重点内容，简单做了如下总结：</p><ol><li>确认本人与用人单位签署了正式劳动合同，排除劳务合同、劳务派遣合同等，并确认自己是否保留了入职以来的全部合同原件。</li><li>如签订劳动合同、请确认合同中是否明确约定了薪酬情况、薪酬构成、工作岗位名称、工作内容、入职时间、工作地点。</li><li>完整保存了与公司沟通协商的往来邮件、微信聊天记录。</li><li>整理好手中现有的证据，列出清单。</li><li>劳动仲裁是必经前置流程，不可直接去法院起诉。</li></ol><h4><span id="提高法律意识留心法律风险">提高法律意识，留心法律风险</span></h4><p>在遇到突发性岗位变动或工作安排，如：调岗、转岗、待岗等，一定要留心这当中的法律风险，不要在任何书面材料上签字，劳动者有权拒绝公司任何不合理不合法的行为。如果跟公司有协商和谈判空间，**可以尝试为自己争取一个不低于心理预期的好结果。**但如果公司想裁员，话HR 找你谈话，连 N 都没有，要诚意没诚意，还不好好说，想套路你，故意搞你心态。别犹豫，拿起法律武器吧。</p><p>法律是每个公民都可以用来保护自己的权利，做为一名普通劳动者，我觉得维权最重要的除了证据和诉讼策略，更重要的是<strong>维权的勇气和决心</strong>。</p><h4><span id="经济补偿金n与-经济赔偿金2n的区别">经济补偿金（N）与 经济赔偿金（2N）的区别</span></h4><p>经常遇到这样一个问题：「员工被公司辞退了，应该赔偿 2N 还是 N+1」？</p><p><strong>经济补偿金</strong>：就是我们大家口中常说的「 N 」，「 N 」是工作年限，用来指代劳动合同法中的经济补偿，计算方式是：经济补偿金= 工作年限 x 月工资。<br>「工作年限」也叫司龄，是补偿金和赔偿金的基数。工作满 1 年支付 1 个月工资。不满 6 个月的，支付 0.5 个月的经济补偿；满 6 个月以上但不满 1 年的，按 1 年支付。<br>「月工资」是指劳动者在劳动合同解除或终止前 12 个月的平均工资（包含奖金、绩效、年终奖等应得收入）。</p><p><strong>经济赔偿金</strong>：公司「违法解除」劳动合同产生的惩罚性赔偿，计算方式是经济补偿金中「N」的 2 倍，也就是「2N 」。如果存在违法解除的情况，</p><p>据我了解，包括大厂在内的绝大多数公司都不守规矩，并不会按照法律标准去执行。有基础法律意识的公司想要裁员时，会尽量规避「违法解除」劳动合同，所以一般来说，「2N」的案子会越来越难打，员工三期（孕期、产期、哺乳期）内遭到公司违法解除劳动合同的情况能相对简单一些。公司会更倾向在「协商解除」的法律框架内做文章。</p><p>《劳动合同法》只规定了「协商解除」的最低标准是「 N 」，另外就是「N +1 」， 1 是指额外支付的 1 个月工资代通知金（即时解除）。除此之外，「N + 2 」 还是「 N + 3 」都没有法律依据。在 N 的基础上，公司想额外支付多少都没有法律限制， 只要双方协商一致，「N + 任何数字」都可以。</p><p>举个例子，公司想裁员找你协商，但你不同意，若公司一意孤行就要裁你，说你绩效不达标，单方面解除了劳动合同，此时就是违法解除，最低是「 2N 」。当然，劳资关系很复杂，公司可以找很多解除劳动合同的理由。如果想打「 2N 」，你需要提供充分的证据证明公司的行为违法，才有可能拿到「2N 」 。</p><p><strong>以下是我整理的关于「2N」的常见情形：</strong></p><table><thead><tr><th style="text-align:center">用人单位解除劳动合同情形</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">情形</td><td style="text-align:center">性质</td><td style="text-align:center">赔偿金</td></tr><tr><td style="text-align:center">劳动者被依法追究刑事责任，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者在试用期间被证明不符合录用条件，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者严重违反用人单位的规章制度，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者严重失职，营私舞弊，给用人单位造成重大损害，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者同时与其他用人单位建立劳动关系，对完成本单位的工作任务造成严重影响，或者经用人单位提出，拒不改正，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者以欺诈、胁迫的手段，或者趁人之危，使对方在违背真实意思表示的情况下订立或者变更劳动合同的情形，致使劳动合同无效，用人单位解除劳动合同。</td><td style="text-align:center">合法解除</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">劳动者处于法定保护期（如孕期、产期、哺乳期），用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">未经劳动者同意，用人单位滥用解除权（如：试用期解除权），擅自解除合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">在本单位连续工作满 15 年，且距法定退休年龄不足 5 年，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">在本单位患职业病或因工负伤并被确认丧失或者部分丧失劳动能力，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">从事接触职业病危害作业的劳动者未进行离岗前职业健康检查，或者疑似职业病，病人在诊断或者医学观察期间，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">患病或者非因工负伤，在规定的医疗期内，用人单位解除劳动合同。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr><tr><td style="text-align:center">连续签订 2 次固定期限劳动合同，并且劳动者没有严重过错、没有「不胜任岗位」「不能从事原岗位工作」的情况，合同期满，用人单位不同意不续签。</td><td style="text-align:center">违法解除</td><td style="text-align:center">2N</td></tr></tbody></table><h3><span id="劳动法的有效学习工具">《劳动法》的有效学习工具</span></h3><h4><span id="中国裁判文书网">中国裁判文书网</span></h4><p>中国裁判文书网（简称“<a href="https://wenshu.court.gov.cn/" target="_blank" rel="noopener">裁判文书网</a>”）是由最高人民法院主办的官方网站，主要目的是公开全国各级法院生效裁判文书，以促进司法公正和透明度。</p><p>这是我日常使用频率最高的工具之一，是非常实用的司法实践参考。这个网站提供了丰富的研究素材和数据，可以检索到全国各地法院各类案件的一审、二审或再审判决书，细分选项特别多。</p><p>虽然劳动仲裁裁决书不公开，只允许当事人及其代理人查阅。但我们依然可以从公开的他人判决书中看到一些仲裁信息，如当事人的主张及理由。</p><p>我们可以通过裁判文书网查询和研究先前的判例，了解当地法律趋势，解析审判口径。例如：劳动者和公司双方的争议点是什么，哪些主张和证据被法院支持，为什么会支持，为什么会驳回。以及在结案陈词中法官是如何看待问题的。</p><p><img src="https://img.hi-linux.com/staticfile/1-2024-03-04-K48oE2.png" alt></p><h4><span id="小红书">小红书</span></h4><p>因为小红书有很多人将自己劳动仲裁的相关经历经验以笔记的形式分享，也有很多律师在平台上分享一些办案经验和法律知识，所以我觉得将它非常适合搜索高质量的信息，提前做好功课，多方验证信息，也可以让自己少走些弯路。</p><h4><span id="中国法律快查手册">中国法律快查手册</span></h4><p><a href="https://github.com/RanKKI/LawRefBook" target="_blank" rel="noopener">中国法律快查手册</a>是一个 Github 上的开源项目，内容来源于国家法律法规数据库，这个项目的作者将数据库做了整合和搜索等功能，排版简洁，使用起来简单方便，非常适合平时查询和学习。作者仅提供了手机版（ iOS、iPadOS）和网页版，并未提供电脑端版本，但我在 M1 MacBook Pro 也可以通过 App Store 应用商店安装使用。</p><p>劳动争议的话，建议主要关注《中华人民共和国劳动法》《中华人民共和国劳动合同法》这两个法规。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805474-2024-03-04-SwEcjk.png" alt><a href="https://github.com/RanKKI/LawRefBook?tab=readme-ov-file" target="_blank" rel="noopener">图源</a> / GitHub</p><h2><span id="靠谱律师怎么找">靠谱律师怎么找</span></h2><p>通过研究司法案例以及本地近期公开的劳动争议相关判决书，我学到了一些劳动法基础知识，开始尝试梳理自己的案件情况，并希望可以得到律师的一些专业建议。先说说找律师来代理案子的 2 个常见误区</p><h4><span id="误区-1-律所越大越好名气越高越好">误区 1 ：律所越大越好，名气越高越好。</span></h4><p>名气高的大律所，服务的对象一般是大公司，因为劳动者的案子都是标的金额低的小案子，不赚钱。</p><p>术业有专供，不是所有律师都擅长打劳动仲裁的案子。所以正确的方式是找主要做劳动争议案件的律所，或是主要代理劳动争议的律师。<br>可以是通过熟人（如：朋友、同事、家人）推荐，这样有一定的信任基础，也可以在小红书搜索，看看其他人选择的律师是否口碑好案例多。</p><p>如果在律师的履历介绍中，可以看到他擅长的领域很多，那不一定是好事。我们需要的是履历介绍中更多和劳动争议相关的律师。</p><h4><span id="误区-2-花了钱请律师代理就可交由律师全权负责">误区 2 ：花了钱请律师代理，就可交由律师全权负责</span></h4><p>我们的劳动争议案件虽然标的小且不赚钱，但不妨碍它很复杂。需要投入大量时间研究，准备和开庭，跑仲裁或法院。</p><p>律师也是如此。律师作为法律工作者，是提供专业的法律帮助，而不是代替处理相关全部事项。关于案件中的取证、和有关部门交涉都需要自己来完成，律师只是在这个过程中提供指导。律师可以帮忙争取最好的结果，但不能避免所有的风险。</p><p>作为当事人，我们对公司和自身情况最为了解，庭审时法官会围绕每个细节进行详细询问，这也是为什么自己要重视开庭并亲自参加庭审的原因。为了降低诉讼中存在的风险，我们需要多和律师交流讨论，自己要先厘清思路，整理好证据，做好充足准备，在开庭时才能自如应答，不会因为紧张而遗漏重点。</p><p>通过以上 2 个误区，我们可以对这部分做个小总结：</p><ol><li>专业领域的重要性：我们需要考虑自己的案子类型和律师的专业领域是否匹配</li><li>选择合适的律所和律师：选择有良好声誉和口碑的律师</li><li>律师的角色：请律师并不意味着可以完全放手，律师的角色是指导和争取最佳结果，而不是替代自己处理所有事物。</li><li>当事人的参与：我们做为当事人应对自己的案件有深入了解，并积极参与庭审准备，与律师充分沟通，整理证据，清晰思路，尽可能降低诉讼风险。</li></ol><h3><span id="找律师途径之一中国法律服务网12348-中国法网">找律师途径之一：中国法律服务网（12348 中国法网）</span></h3><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805551-2024-03-04-ac3x5W.png" alt></p><p>这个由司法部建设的网站，是于2018 年 5 月20 日正式上线运行。网站整合并收录了全国范围内的「法律服务机构」和「法律人员数据」。是</p><p>我们可以在里面选择律所或律师，也可以通过网站查询从其他渠道了解到的某家律所，或某位律师（可查询律师执业证号）。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145839669-2024-03-04-Ev0UoP.png" alt></p><h3><span id="为找律师我做了哪些尝试">为找律师我做了哪些尝试</span></h3><p>算下来，我前后共咨询了 3 位律师（不包含法律援助）。我寻求律师帮助的路径是：在线咨询律师 A（付费）—— 线下咨询律师 B （付费）—— 线下咨询律师 C （付费）</p><h4><span id="在线咨询律师-a">在线咨询律师 A</span></h4><p>最开始我先尝试了在网上找律师付费咨询，<br>虽然付费价格（支付 168 元）比线下咨询律师便宜很多，但是与价格相对等的是提问有次数、字数、时间限制（只能文字沟通不能语音），如果在律师不了解相关背景情况下进行提问，这将导致律师因无法判断案情而无法提供合理化建议。</p><p>于是我尝试尽量精简文字表述，将提问内容分为：事件背景（时间线）、我的现状、核心问题，制作成一张图片发送给律师。律师对我提问的内容一一做了解答，但是我结合自身情况，判断出律师提出的解决方案存在的风险比较高，所以我没有采纳。</p><h4><span id="线下咨询律师-b">线下咨询律师 B</span></h4><p>在律师朋友的介绍下，我联系上了一位主要代理劳动争议案件的律师，律所离我也不算远，约了时间线下面谈。这次收获蛮大的，之前担心的问题基本都得到了解决，心里也更踏实了，只不过我的情况比较被动，需要看公司下一步的动作。</p><h4><span id="线下咨询律师-c">线下咨询律师 C</span></h4><p>律师 C 是同事推荐，对于劳动仲裁案件的经验非常丰富。也是我综合考量后，选择了律师 C 委托代理我的一审案子。</p><p>关于律师咨询费。北京这边 200 - 3000 元 / 小时不等，我在线下咨询律师 B 两次，每次都是 500 元 / 小时。</p><p>关于律师代理费。根据案子标的额的百分比收取，不同审判阶段（仲裁、一审、二审），费用也不同。</p><h2><span id="少走弯路准备证据和录音技巧">少走弯路：准备证据和录音技巧</span></h2><h3><span id="准备证据">准备证据</span></h3><h4><span id="一键下载仲裁所需的全部材料">一键下载仲裁所需的全部材料</span></h4><p>包含劳动仲裁立案申请、证据交换、出庭使用的材料模板，可以通过<a href="http://www.bjchy.gov.cn/affair/ldwq/tjzc/8a24fe9767393e2d01673f3dbdc70a21.html" target="_blank" rel="noopener">北京市朝阳区人民政府官网</a>页面底部的「点击此处下载相关附件」获取。文档中还有相关办理流程、注意事项，内容非常全面，可以仔细查阅。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805703-2024-03-04-nYvF2T.png" alt></p><h4><span id="自助打印银行工资流水凭证">自助打印银行工资流水凭证</span></h4><p><strong>本人带上身份证原件直接去附近银行营业厅的自助机上打印</strong>，可自行在机器上操作，省去拿号排队去窗口的过程，在使用银行自助机的过程中，有任何问题都可以找身边的银行经理帮忙解决，非常高效。<strong>建议在打印前了解相关费用标准并做好准备</strong>，有的银行会限制每月免费打印次数，超过则按张收取费用。我的工资是由公司通过 3 家银行（北京、交通、招商）发放，所以我需要去 3 家银行分别打印流水，北京银行和交通银行的自助机没有对流水单设立打印限制，但招商银行的打印限制我记得是 4 张 / 月，超过按 20 元 / 张收费。</p><p>在银行自助机操作时，我总结了 3 个重点：选择时间范围、筛选交易类型、包含银行盖章。</p><p><strong>选择时间范围</strong>：依据劳动争议涉及的时间来选择流水打印范围，需按年选择，不可跨年。</p><p><strong>筛选交易类型</strong>：要在筛选栏勾选交易类型（工资），指定筛选条件的目的，是为了方便自己和他人在查看银行流水单时，让工资发放情况一目了然，我们只需要工资流水的相关证明，不需要其他交易记录。</p><p><strong>包含银行公章</strong>：银行自助机打印的工资明细一般默认包含公章，但也有个别银行需要在打印前勾选相关选项后，才可打印出盖了章的流水单。公章名称一般叫「回单专用章」或「会计业务章」。打印前后一定要留意打印的流水单是否包含银行的公章，如果没有公章则证据无效。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145849891-2024-03-04-4TsJZE.png" alt></p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145805946-2024-03-04-Opd8Qi.png" alt></p><p>我的银行流水单盖章（左：北京银行 ；右：交通银行）</p><h4><span id="利用-iphone-备忘录扫描劳动合同复印件">利用 iPhone 备忘录扫描《劳动合同》复印件</span></h4><p>因为打印出来的纸张是黑白效果，如果直接使用手机将《劳动合同》拍照、，会导致部分信息模糊不清，这里有个便捷好用的小技巧：利用 iPhone 备忘录中的「扫描」功能，逐页将《劳动合同》扫描成 PDF 文件后再打印（相比直接打印效果更清晰，相比复印更省事）。可以避免因提交材料不合格导致返工的情况（不要重蹈我的覆辙）。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145806016-2024-03-04-FtagF1.png" alt>iPhone 备忘录中的「扫描文稿」功能</p><h4><span id="打工人必备app-权利卫士">打工人必备App —— 权利卫士</span></h4><p>这是一款由国家知识产权局推出，具有法律效率的<a href="https://www.tsa.cn/" target="_blank" rel="noopener">电子取证工具</a>（仅支持 iOS、Android ），被法律工作者广泛使用。可生成不可篡改的带有时间戳的电子证据。取证范围包含：拍照、录像、录音、录屏、网页。在 App 中实名认证就可正常使用。</p><p>如果有些证据比较重要，可以选择这个工具。例如：在公司对我的办公软件停用前，我就使用了权利卫士的录屏功能，对组织架构、个人信息等情况进行了证据固定。法律规定谁主张谁举证的原则，在提起仲裁或诉讼时，我就有了通过权利卫士保存的电子版基础证据。</p><p>权利卫士可以很大程度上代替传统的公正取证方式。正确使用权利卫士，可以在价格低廉的同时，让取证变得更快捷。但它终归只是一个取证工具，证据的真实性没问题，但是否会被采纳，能发挥多大作用，是需要深度思考的问题。如果拿不准可以在律师的指导下使用，毕竟每次取证都需要付费。</p><p><img src="https://img.hi-linux.com/staticfile/1-20240304145806077-2024-03-04-UkvPbG.png" alt>权利卫士官网</p><h3><span id="录音技巧">录音技巧</span></h3><ol><li>时间：录音证据宜早不宜晚</li><li>设备：无论面谈与否，要全程录音，能清晰听清双方谈话内容的设备皆可。如果是电话沟通，并且是苹果手机，没有通话录音功能，可以向朋友借一台手机用来录音。</li><li>操作：手机可以开启飞行模式，防止突然来电导致录音中断</li></ol><h4><span id="注意事项">注意事项</span></h4><p>录音证据大多情况都不能被仲裁庭采纳，主要原因是录音中的谈话内容，缺少适格主体等关键信息，例如：公司法人张三、人力资源负责人李四。录音属于锦上添花，能有更好，如果获取不到有用信息也没有关系。</p><p>录音的目的是通过谈话，问清事实情况，便于进一步固定证据。不能威胁恐吓对方（态度友好），否则证据无效。值得一提的是，录音证据的目的是为了佐证其他关联证据，形成证据链，不能单独使用。</p><p>谈话中不仅<strong>问题要清晰明确</strong>，还需要做到谈话人身份明确，内容清晰，具有客观真实和连贯性。可以先理清思路，再写成书面材料，通话前尝试练习几遍。</p><h4><span id="提交录音">提交录音</span></h4><p>需要注意的是，录音做为证据时，要做两件事：一是要将未被剪接或者伪造，内容未被改变，无疑点的<strong>完整音频文件刻录成光盘</strong>，二是要将全部<strong>对话内容整理成文字版书面材料。</strong></p><p>**录音内容文字版：**建议写明这些信息：时间、地点、设备、时长、当事人信息（本人名字、公司负责人职称和名字）。最后，在《证据目录》中标记好录音文件的位置，将录音光盘、文字版随其他证据一起提交。</p><p>另外，录音原视文件和载体（如手机）要保留好，用于庭审时查验。</p><h4><span id="我的录音沟通提纲">我的录音沟通提纲</span></h4><ol><li>确认双方主体和身份</li><li>确认相关的事实</li><li>履行友好协商的态度，明确提出自己的主张</li></ol><h4><span id="我的通话前录音内容">我的通话前录音内容</span></h4><ol><li>对着录音自我介绍并陈述事实：我是 xxx，身份证号 xxx，自 x 年 x 月 x 日在 x 公司，x 部门，担任 x 职位。<br>x 年 x 月 x 日起，公司 xx（简短陈述事实内容），我现在要给公司人力资源部总监 xx （全名）拨打电话，协商解决方案。Ta 的电话是 xxx。</li></ol><p><img src="https://img.hi-linux.com/staticfile/1-20240304145904400-2024-03-04-LCFi9Y.jpeg" alt>证据材料清单样表（<a href="http://www.bjchy.gov.cn/affair/ldwq/tjzc/8a24fe9767393e2d01673f3dbdc70a21.html" target="_blank" rel="noopener">图源</a>：附件材料)</p><h3><span id="寻求免费的法律援助">寻求免费的法律援助</span></h3><p>法律援助更像是针对「特殊群体」设立的专项服务，主要服务于农民工或年纪较大的人。</p><p>朝阳劳动仲裁委员会也设立了法律援助咨询窗口，在服务总台领号排队，与仲裁立案窗口同在一个大厅。或许是我的案子具有复杂性，也可能窗口的工作人员并没太多时间帮我深度分析，我将手里的证据给到对方，尝试了解对于我这种情况的政策和裁判口径，但我并未收获到有用的信息和指导性建议。</p><p>所以，大家可以尝试性去咨询，但不要对法援抱有太大期望。也不要轻信仲裁委门口主动发卡片的律师咨询，我从没见过有执业证的律师需要揽客，这些卡片上的律师，很可能就不是律师，十有八九不靠谱，有很多被人被骗。</p><h3><span id="我的完整仲裁流程">我的完整仲裁流程</span></h3><p>在仲裁阶段，我选择的是自己走完全流程，委托律师代理的是一审诉讼。<br>一是因为北漂多年，有过仲裁经历。<br>二是因为之前外籍二房东不退押金，并大放厥词可以去法院告他。于是我就听了他的建议，自己写诉状去法院起诉，所以有一些民事诉讼的经验。</p><p>劳动仲裁的立案、交换证据流程和法院诉讼在某些方面有相似之处，。所以我觉得仲裁相比诉讼来说在准备充分的情况下要简单很多，我的劳动争议案子偏复杂，需要经过法院审理。</p><p>以北京朝阳区为例，可以在北京人社局官网提前预约，预约后会短信告知线下提交立案材料的时间。疫情时官网预约后需要等 1 个月以上，现在要等的时间不好说。</p><p>也可以选择可以直接去线下领号立案（更推荐这种方式，更高效）。建议准备好材料，在 8 点前到门口排队， 10点前拿到号。否则可能会由于人多无法当天立案。我在<strong>疫情时和疫情后</strong>分别成功立案 2 次，是针对劳动争议中的不同时间段的仲裁请求。现在疫情已经过去，流程也简化了不少，相对来说更省事儿了。</p><h4><span id="仲裁地点">仲裁地点</span></h4><p>北京市朝阳区劳动人事争议仲裁院<br>电 话：010-87983310<br>地 址：北京市朝阳区将台路5号院15号楼B座、C座</p><h4><span id="准备材料">准备材料</span></h4><ul><li>身份证原件</li><li>身份证复印件 x 3</li><li>申请书 x 3</li><li>地址确认书 x 1</li></ul><p>建议检查好相关材料，并将电子版备份到 U 盘，最好是带上笔记本电脑，若书面材料不符合立案窗口要求，可以即时用自己电脑修改，若有漏打材料，也可在服务台旁边的打印区付费打印。</p><h4><span id="立案流程">立案流程</span></h4><ol><li>去总服务台领取地址确认书填好，领取初审号码（可以提前打印好，直接领A 开头初审号码）</li><li>初审后收到 B 开头立案号码，等待叫号。</li><li>立案窗口工作人员可能会让填一个劳动调解表。（这步可以直接放弃调解，直接走程序省时间，因为开庭前仲裁员还会再次调解）</li></ol><h4><span id="完成立案">完成立案</span></h4><p>成功立案后，窗口会现场出具举证通知等书面材料，立案后有 30 天的调解时间，期间会有工作人员打电话给当事人（公司、劳动者）双方，询问是否同意调解。接下来会收到朝阳仲裁委关于交换证据的通知邮件，以及短信提醒。</p><h4><span id="交换证据">交换证据</span></h4><p>需要注意，自己和公司方的交换时间是一样的，务必要按照规定时间内到达指定窗口，办理举证及证据交换，必须是本人，否则过时不候。提交完成并签字确认后就可以离场了，如果在现场遇到公司的人也必理会。</p><h4><span id="等待庭审">等待庭审</span></h4><p>接下来，等待开庭通知就好。开庭时要携带身份证原件、证据原件。需要注意开庭时间， **如果开庭当天本人迟到，会被视为撤诉。**仲裁开庭也比较简单，不会法院审理案件那样细致。主要是仲裁员通过问询双方当事人，录入双方确认的一些信息，如争议时间、质证理由、社保状态、薪资情况等。<br>仲裁案件都是随机分别仲裁员，我是2022 年底立案， 2023 年初开庭，直到 2023 年 10 月才收到裁决书。大家可以多联系自己案件的仲裁员，催问进度。</p><h4><span id="仲裁结果">仲裁结果</span></h4><p>身边总有朋友认为，收到的劳动仲裁裁决书上支持了相关请求事项，就是胜利的信号，但仲裁是以调解为主，并不能最大限度维护劳动者自身权益。例如：法律规定协商解除劳动合同的最低标准是 N ，假设 N 是 10 个月，仲裁员会和公司、劳动者分别协商，讨价还价后，最终 N 可能是 6 或者 4，甚至更低，看似减少了劳动者维权的时间成本，实际最大受益者却是公司一方，公司试图用远低于法律规定的标准，带有恶意性、针对性、侮辱性的手段，低成本实现裁员目的。</p><p>所以劳动仲裁对劳动者来说只是维权之路的起点，还要经历一审诉讼、二审诉讼，即使最终赢了官司，还可能面临向法院申请强制执行的情况。</p><h2><span id="写在最后">写在最后</span></h2><p>遇见过一些 HR ，千方百计地学习裁员套路和话术。一个员工为企业服务这么多年，非但不感谢员工多年的辛苦付出，反而为了达成裁员目的搞手段，扣帽子。想法设法压榨剥削打工人，员工不和你死磕跟谁磕？员工就是一个个普普通通的人，不止看重钱，还很在乎你怎么对他。</p><p>这个世界很奇妙。代理我案子的律师最近就遇见了一个离谱案件，将这个真实案例用一句话概括就是：职场当中套路虽多，但涉及底线的东西并不适用于套路。谁也说不准，后面被搞心态以及被裁的，会不会是自己。</p><blockquote><p>本文转载自：「 少数派 」，原文：<a href="https://url.hi-linux.com/jpw6C" target="_blank" rel="noopener">https://url.hi-linux.com/jpw6C</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我第一次尝试写个人年度总结。&lt;/p&gt;
&lt;p&gt;我的 2023 年与 2022 年不可分割，一直走在维权的路上。&lt;/p&gt;
&lt;p&gt;早在 2022 年初，我的职业生涯发生重大转变，公司在未与我协商的情况下，单方面将我待岗，降低工资，移交工作。我从熟悉的工作环境被迫成为了一个「半自由职业者」。我之所以自认为是半自由，是因为公司未与我解除劳动合同，所以劳动关系还在原公司。法律规定劳动者只能和一家用人单位签订劳动合同，所以我在与公司存在劳动争议的情况下，无法入职下家公司。&lt;/p&gt;
&lt;p&gt;除此之外，公司隔几个月后停发我的工资，切断了我唯一的经济来源。我开始尝试学习《劳动法》及相关法律知识，查阅和自己案件类似的裁判文书，整理书面材料，为的是跟公司对簿公堂，讨回做为劳动者的尊严和权益。&lt;/p&gt;
&lt;p&gt;在劳资关系中，公司具有优势地位，而劳动者处于弱势的一方。尤其是面对老板、人事、法务组成的流氓团伙时，会更加被动、愤怒、迷茫、无助。希望大家在面对公司的恶意时可以更加从容，是我写下这些文字的初衷。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="教程" scheme="https://www.hi-linux.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="职场" scheme="https://www.hi-linux.com/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>简单一招，轻松把 Nginx 服务器性能提升 50 倍</title>
    <link href="https://www.hi-linux.com/posts/52460.html"/>
    <id>https://www.hi-linux.com/posts/52460.html</id>
    <published>2024-02-05T01:00:00.000Z</published>
    <updated>2024-02-05T08:27:29.121Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="用-nginx-gzip-进行静态加速">用 Nginx Gzip 进行静态加速</span></h2><p>这绝对是你应该做的事情。<br>并不是特别麻烦，而且效果也很突出。</p><p>这里解释了 <a href="https://nginx.p2hp.com/" target="_blank" rel="noopener">Nginx</a> 中的 gzip_static。</p><h3><span id="1不使用-gzip-static-时的-gzip-处理">1.不使用 gzip static 时的 gzip 处理</span></h3><p><img src="https://img.hi-linux.com/staticfile/N56H1Z-2024-02-05-yyBwlC.png" alt="Nginx 不使用 gzip_static 时 gzip 处理的说明"></p><p><strong>如果你不使用 gzip_static 而只是 “gzip on”，它每次都会被压缩并发送。</strong></p><p>虽然它实际上可能缓存在内存中，但传统观点是 “每次都会执行压缩处理，因此 CPU 负载很大。”</p><p>因此，我每次都想停止处理它。</p><p>“gzip_static” 可以实现这一点。</p><a id="more"></a><h3><span id="2使用-gzip-static-时的-gzip-处理">2.使用 gzip static 时的 gzip 处理</span></h3><p><img src="https://img.hi-linux.com/staticfile/g3KBwu-2024-02-05-TfefNK.png" alt="Nginx 中开启 gzip_static 时 gzip 处理的说明"></p><p><strong>它将搜索 “gz” 文件并为您使用！</strong></p><p>如果是 “style.css”，它将自动搜索文件 “style.css.gz”。<br>如果找到，则返回它；如果没有，则照常压缩 “style.css”。<br>因此，如果提前创建压缩文件，就不会产生 CPU 负载，处理速度也会更快。</p><p>更好的是压缩级别。</p><h3><span id="3使用-gzip-static-的优点">3.使用 gzip static 的优点</span></h3><p><img src="https://img.hi-linux.com/staticfile/WXg4zd-2024-02-05-j5SCrt.png" alt="将 gzip_static 与 Nginx 一起使用的最大优点是可以将压缩级别设置为 9。"></p><p><strong>它可以以最大压缩率保存。</strong></p><p>通常情况下，不可能使用最高压缩设置，因为它会给 CPU 带来沉重的负载，但<br>由于你可以提前慢慢创建它，所以我通常将其保存在最高压缩级别（级别9）。<br>文件大小肯定会减小。</p><h3><span id="4-需要一个模块才能在-nginx-中使用-gzip-static">4. 需要一个模块才能在 Nginx 中使用 gzip static</span></h3><p><strong>ngx_http_gzip_static_module 是必需的。</strong></p><p>请使用以下命令检查是否已安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V 2&gt;&amp;1 | tr <span class="string">' '</span> <span class="string">'n'</span>|egrep _module | sed -e <span class="string">'s/--with-//g'</span></span><br></pre></td></tr></table></figure><p>如果未安装，系统会要求您重新安装 Nginx（可能）。<br>您必须使用 “–with-http_gzip_static_module” 安装它。<br>但是，当我从存储库安装时，所有内容都已包含在内，而无需执行任何操作。</p><p>请先检查一下。</p><h3><span id="5如何在-nginx-上配置-gzip-静态">5.如何在 Nginx 上配置 gzip 静态</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gzip_static on;</span><br><span class="line">gzip on;</span><br><span class="line">gzip_comp_level 1;</span><br><span class="line">gzip_min_length 1024;</span><br><span class="line">gzip_vary on;</span><br><span class="line">gzip_proxied any;</span><br><span class="line">gzip_types text&#x2F;plain text&#x2F;css text&#x2F;javascript application&#x2F;javascript application&#x2F;x-javascript application&#x2F;json application&#x2F;ld json text&#x2F;xml application&#x2F;xml application&#x2F;xhtml xml application&#x2F;atom xml application&#x2F;xml rss application&#x2F;rss xml image&#x2F;x-icon image&#x2F;svg xml image&#x2F;bmp;</span><br></pre></td></tr></table></figure><p><strong>只需在常规内容中添加 “gzip_static on” 即可。</strong></p><p>这就是启用它所需要做的全部工作，所以很简单。</p><p>我建议你只设置这个。</p><p>如果你用谷歌搜索，你会看到很多人指定 “gzip_static always”，<br>这意味着在任何情况下都使用 gz 文件。<br>假设所有目标文件都被压缩并保存（理想情况）。</p><p>在这种情况下，将不会显示不支持的用户，因此您还需要指定 “gunzip on;”。<br>如果客户端不支持 gzip，文件会在服务器端解压后发送。</p><p>详情请参阅以下页面。</p><p><a href="http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html" target="_blank" rel="noopener">官方解释：ngx_http_gzip_static_module 模块</a></p><h3><span id="6-如何使用-gzip-压缩">6. 如何使用 gzip 压缩</span></h3><p>&lt;对于 PHP&gt;</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzencode(<span class="variable">$file</span>, 9)</span><br></pre></td></tr></table></figure><p>&lt;对于 ubuntu（Linux）&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -9 -k style.css</span><br></pre></td></tr></table></figure><p>每次更新时我都会自动使用 PHP 创建它。</p><h3><span id="7-需要压缩的文件">7. 需要压缩的文件</span></h3><p><strong>一般文本文件如 css、js、xml 等</strong></p><p>可以将其视为图像之外的其他内容。</p><p>基本上，它将是 “gzip_types” 指定的文件。</p><p>但是，如果将压缩级别设置为 9，图像通常会变小。<br>如果你比较讲究的话，请用各种方式压缩一下看看。</p><p>这是 Nginx中 gzip static 的解释。</p><p>它非常有效，所以请尝试一下。</p><p>原文链接 <a href="https://doudonn.com/saba/2331/" target="_blank" rel="noopener">https://doudonn.com/saba/2331/</a></p><blockquote><p>本文转载自：「 Lenix Blog 」，原文：<a href="https://url.hi-linux.com/o1BAZ" target="_blank" rel="noopener">https://url.hi-linux.com/o1BAZ</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;用-Nginx-Gzip-进行静态加速&quot;&gt;用 Nginx Gzip 进行静态加速&lt;/h2&gt;
&lt;p&gt;这绝对是你应该做的事情。&lt;br&gt;
并不是特别麻烦，而且效果也很突出。&lt;/p&gt;
&lt;p&gt;这里解释了 &lt;a href=&quot;https://nginx.p2hp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nginx&lt;/a&gt; 中的 gzip_static。&lt;/p&gt;
&lt;h3 id=&quot;1-不使用-gzip-static-时的-gzip-处理&quot;&gt;1.不使用 gzip static 时的 gzip 处理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hi-linux.com/staticfile/N56H1Z-2024-02-05-yyBwlC.png&quot; alt=&quot;Nginx 不使用 gzip_static 时 gzip 处理的说明&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你不使用 gzip_static 而只是 “gzip on”，它每次都会被压缩并发送。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然它实际上可能缓存在内存中，但传统观点是 “每次都会执行压缩处理，因此 CPU 负载很大。”&lt;/p&gt;
&lt;p&gt;因此，我每次都想停止处理它。&lt;/p&gt;
&lt;p&gt;“gzip_static” 可以实现这一点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>史上最全 SSH 暗黑技巧详解</title>
    <link href="https://www.hi-linux.com/posts/60266.html"/>
    <id>https://www.hi-linux.com/posts/60266.html</id>
    <published>2024-01-23T01:00:00.000Z</published>
    <updated>2024-01-23T02:11:04.393Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>我见过太多的老鸟、新手对 SSH 基本只限于 SSH 到远程机器，实际这个命令我们一天要用很多次，但是对它的了解太少了，他的强大远远超出你的想象。当于你也许会说够用就够了，确实没错，但是你考虑过效率没有，或者还有哪些脑洞大开的功能会让你爱死他，这些功能又仅仅是一行命令就够了。</p><p>疫情期间一行 SSH 命令让我节省了 70% 的出差时间，来，让我们一起走一遍，看看会不会让你大开眼界。</p><a id="more"></a><h2><span id="本文试图解决的问题">本文试图解决的问题</span></h2><ul><li>如何通过 SSH 命令正确上网</li><li>Docker 镜像、Golang 仓库总是被墙怎么办</li><li>公司跳板机要输入动态 Token，太麻烦了，如何省略掉这个 Token；</li><li>比如多机房总是要走跳板机，如何 <code>绕过</code> 跳板机直连；</li><li>我的开发测试机器如何免打通、免密码、直达；</li><li>如何访问隔离环境中( K8s )的 Web 服务 – 将隔离环境中的web端口映射到本地</li><li>如何让隔离环境的机器用上 Yum、APT</li><li>如何将服务器的图形界面映射到本地(类似 VNC 的作用)</li><li>SSH 如何调试诊断，这才是终极技能……</li></ul><h2><span id="注意事项">注意事项</span></h2><ul><li>SSH 是指的 openSSH 命令工具</li><li>本文适用于各种 Linux、macOS 下命令行操作，Windows 的话各种可视化工具都可以复制 Session、配置 Tunnel 来实现类似功能。</li><li>如果文章中提到的文件、文件夹不存在可以直接创建出来。</li><li>所有配置都是在你的笔记本上（相当于 SSH Client上）</li></ul><h2><span id="正确上网">正确上网</span></h2><p>有时候正确上网还得靠自己，一行 SSH 命令来正确上网:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ssh -qTfnN -D 127.0.0.1:38080 root@1.1.1.1 &quot;vmstat 10&quot; 2&gt;&amp;1 &gt;&#x2F;dev&#x2F;null &amp;</span><br></pre></td></tr></table></figure><p>上面的 1.1.1.1 是你在境外的一台服务器，已经做好了免密登陆（免密见后面，要不你还得输一下密码），这句话的意思就是在本地启动一个 38080 的端口，上面收到的任何东西都会转发给 1.1.1.1:22（做了 SSH 加密），1.1.1.1:22 会解密收到的东西，然后把他们转发给 Google 之类的网站（比如你要访问的是 Google），结果依然通过原路返回</p><p>127.0.0.1:38080  就是要填入到你的浏览器中的 Socks5 代理服务器，什么都不需要装，非常简单。</p><p><img src="https://img.hi-linux.com/staticfile/n3mrq5-2024-01-22-7OPIZB.png" alt></p><p>原理图如下(灰色矩形框就是你本地 SSH 命令，SSH 线就是在穿墙， 国外服务器就是命令中的 1.1.1.1)：</p><p><img src="https://img.hi-linux.com/staticfile/Wqm4wS-2024-01-22-UmMYjx.png" alt></p><h3><span id="正确上网之-http-特殊代理-利用-ssh-本地转发是-http-协议">正确上网之 HTTP 特殊代理 – 利用 SSH 本地转发是 HTTP 协议</span></h3><p>前面所说的代理是 Socks5 代理，一般浏览器都有插件支持，但是比如你的 Docker（或者其他程序）需要通过 HTTP 去拉取镜像就会出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon 8.704 kB</span><br><span class="line">Step 1 : FROM k8s.gcr.io&#x2F;kube-cross:v1.10.1-1</span><br><span class="line">Get https:&#x2F;&#x2F;k8s.gcr.io&#x2F;v1&#x2F;_ping: dial tcp 108.177.125.82:443: i&#x2F;o timeout</span><br></pre></td></tr></table></figure><p><a href="https://www.atatech.org/articles/102153" target="_blank" rel="noopener">如果是 Git 这样的应用内部可以配置 Socks5 和 HTTP 代理服务器，请参考另外一篇文章</a>，但是有些应用就不能配置了，当然最终通过 SSH 大法还是可以解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssh -L 443:108.177.125.82:443 root@1.1.1.1 &#x2F;&#x2F; 在本地监听 443，转发给远程 108.177.125.82 的 443 端口</span><br></pre></td></tr></table></figure><p>然后再在 <code>/etc/hosts</code> 中将域名 <a href="http://k8s.gcr.io" target="_blank" rel="noopener">k8s.gcr.io</a> 指向 127.0.0.1， 那么本来要访问 <a href="http://k8s.gcr.io:443" target="_blank" rel="noopener">k8s.gcr.io:443</a> 的，变成了访问本地 127.0.0.1:443 而 127.0.0.1:443 又通过 SSH 重定向到了 108.177.125.82:443 这样就实现了 HTTP 代理或者说这种特殊情况下的正确上网。这个方案不需要装任何东西，但是每个访问目标都要这样处理，好在这种情况不多。</p><h2><span id="内部堡垒机-跳板机都需要密码动态码太复杂了怎么解">内部堡垒机、跳板机都需要密码+动态码，太复杂了，怎么解？</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/config </span></span><br><span class="line"><span class="meta">#</span><span class="bash">reuse the same connection --关键配置</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~/tmp/ssh_mux_%h_%p_%r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查了下 ControlPersist 是在 OpenSSH5.6 加入的，5.3还不支持</span></span><br><span class="line"><span class="meta">#</span><span class="bash">不支持的话直接把这行删了，不影响功能</span></span><br><span class="line"><span class="meta">#</span><span class="bash">keep one connection <span class="keyword">in</span> 72hour</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ControlPersist 72h</span></span><br><span class="line"><span class="meta">#</span><span class="bash">复用连接的配置到这里，后面的配置与复用无关</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">其它也很有用的配置</span></span><br><span class="line">GSSAPIAuthentication=no</span><br><span class="line"><span class="meta">#</span><span class="bash">这个配置在公网因为安全原因请谨慎关闭</span></span><br><span class="line">StrictHostKeyChecking=no</span><br><span class="line">TCPKeepAlive=yes</span><br><span class="line">CheckHostIP=no</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"ServerAliveInterval [seconds]"</span> configuration <span class="keyword">in</span> the SSH configuration so that your ssh client sends a <span class="string">"dummy packet"</span> on a regular interval so that the router thinks that the connection is active even <span class="keyword">if</span> it<span class="string">'s particularly quiet</span></span></span><br><span class="line">ServerAliveInterval=15</span><br><span class="line"><span class="meta">#</span><span class="bash">ServerAliveCountMax=6</span></span><br><span class="line">ForwardAgent=yes</span><br><span class="line"></span><br><span class="line">UserKnownHostsFile /dev/null</span><br></pre></td></tr></table></figure><p>在你的 SSH 配置文件增加上述参数，意味着 72 小时内登录同一台跳板机只有第一次需要输入密码，以后都是重用之前的连接，所以也就不再需要输入密码了。</p><p>加了如上参数后的登录过程就有这样的东东(默认没有，这是 Debug 信息)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">debug1: setting up multiplex master socket</span><br><span class="line">debug3: muxserver_listen: temporary control path   &#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.**_22_corp.86g3C34vy36tvCtn</span><br><span class="line">debug2: fd 3 setting O_NONBLOCK</span><br><span class="line">debug3: fd 3 is O_NONBLOCK</span><br><span class="line">debug3: fd 3 is O_NONBLOCK</span><br><span class="line">debug1: channel 0: new [&#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.*.*_22_corp]</span><br><span class="line">debug3: muxserver_listen: mux listener channel 0 fd 3</span><br><span class="line">debug1: control_persist_detach: backgrounding master process</span><br><span class="line">debug2: control_persist_detach: background process is 15154</span><br><span class="line">debug2: fd 3 setting O_NONBLOCK</span><br><span class="line">debug1: forking to background</span><br><span class="line">debug1: Entering interactive session.</span><br><span class="line">debug2: set_control_persist_exit_time: schedule exit in 259200 seconds</span><br><span class="line">debug1: multiplexing control connection</span><br></pre></td></tr></table></figure><p><code>/home/ren/tmp/ssh_mux_10.16.*.*_22_corp</code> 这个就是保存好的 Socket，下次可以重用，免密码。 in 259200 seconds 对应 72小时</p><h2><span id="我有很多不同机房或者说不同客户的机器都需要跳板机来登录能一次直接-ssh-上去吗">我有很多不同机房（或者说不同客户）的机器都需要跳板机来登录，能一次直接 SSH 上去吗？</span></h2><p>比如有一批客户机房的机器 IP 都是 192.168.<em>.</em>, 然后需要走跳板机 100.10.1.2 才能访问到，那么我希望以后<strong>在笔记本上直接 ssh 192.168.1.5 就能直接连上</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;ssh&#x2F;ssh_config</span><br><span class="line"></span><br><span class="line">Host 192.168.*.*</span><br><span class="line">ProxyCommand ssh -l ali-renxijun 100.10.1.2 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br></pre></td></tr></table></figure><p>上面配置的意思是执行 <code>ssh 192.168.1.5</code> 的时候命中规则 <code>Host 192.168.*.*</code> 所以执行 <code>ProxyCommand</code> 先连上跳板机再通过跳板机连向 192.168.1.5 。这样在你的笔记本上就跟 192.168.<em>.</em> 的机器仿佛在一起，SSH 可以上去，但是 ping 不通这个 192.168.1.5 的 IP</p><p><strong>划重点：公司的线上跳板机做了特殊限制，限制了这个技能。日常环境跳板机支持这个功能</strong></p><p>比如我的跳板配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#到美国的机器用美国的跳板机速度更快</span><br><span class="line">Host 10.74.*</span><br><span class="line">ProxyCommand ssh -l user us.jump exec &#x2F;bin&#x2F;nc %h %p 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">#到中国的机器用中国的跳板机速度更快</span><br><span class="line">Host 10.70.*</span><br><span class="line">ProxyCommand ssh -l user cn.jump exec &#x2F;bin&#x2F;nc %h %p 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">   </span><br><span class="line">Host 192.168.0.*</span><br><span class="line">ProxyCommand ssh -l user 1.1.1.1 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br></pre></td></tr></table></figure><p>其实我的配置文件里面还有很多规则，懒得一个个隐藏 IP 了，这些规则是可以重复匹配的</p><p>来看一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ren@ren-VirtualBox:&#x2F;$ ping -c 1 10.16.1.*</span><br><span class="line">        PING 10.16.1.* (10.16.1.*) 56(84) bytes of data.^C</span><br><span class="line">    --- 10.16.1.* ping statistics ---</span><br><span class="line">    1 packets transmitted, 0 received, 100% packet loss, time 0ms</span><br><span class="line">    </span><br><span class="line">ren@ren-VirtualBox:~$ ssh -l corp 10.16.1.* -vvv</span><br><span class="line">OpenSSH_6.7p1 Ubuntu-5ubuntu1, OpenSSL 1.0.1f 6 Jan 2014</span><br><span class="line">debug1: Reading configuration data &#x2F;home&#x2F;ren&#x2F;.ssh&#x2F;config</span><br><span class="line">debug1: Reading configuration data &#x2F;etc&#x2F;ssh&#x2F;ssh_config</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 28: Applying options for *</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 44: Applying options for 10.16.*.*</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 68: Applying options for *</span><br><span class="line">debug1: auto-mux: Trying existing master</span><br><span class="line">debug1: Control socket &quot;&#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.1.*_22_corp&quot; does not exist</span><br><span class="line">debug1: Executing proxy command: exec ssh -l corp 139.*.*.* exec &#x2F;usr&#x2F;bin&#x2F;nc 10.16.1* 22</span><br></pre></td></tr></table></figure><p>本来我的笔记本跟 10.16.1.* 是不通的(ping 不通），但是 SSH 可以直接连上，实际 SSH 登录过程中自动走跳板机 139.<em>.</em>.* 就连上了</p><p><code>-vvv</code> 参数是 debug，把 SSH 登录过程的日志全部打印出来。</p><h2><span id="将隔离环境中的-web-端口映射到本地本地代理">将隔离环境中的 Web 端口映射到本地（本地代理）</span></h2><p>远程机器部署了 Web Server（端口 8083），需要通过浏览器来访问这个 WEB 服务，但是 server 在隔离环境中，只能通过 SSH 访问到。一般来说会在隔离环境中部署一个 Windows 机器，通过这个 Windows 机器来访问到这个 Web Server。能不能省掉这个 Windows 机器呢？</p><p>现在我们试着用 SSH 来实现本地浏览器直接访问到这个隔离环境中的 Web Server。</p><p>假设 Web Server 是：10.1.1.123:8083， SSH 账号是：user</p><p>先配置好本地直接 <code>ssh user@10.1.1.123</code> （参考前面的 <code>ProxyCommand</code> 配置过程，最好是免密也配置好），然后在你的笔记本上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CNfL 0.0.0.0:8088:10.1.1.123:8083 user@10.1.1.123</span><br></pre></td></tr></table></figure><p>或者：(<a href="mailto:root@100.1.2.3">root@100.1.2.3</a> -p 54900 是可达10.1.1.123的代理服务器)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CNfL 0.0.0.0:8089:10.1.1.123:8083 root@100.1.2.3 -p 54900</span><br></pre></td></tr></table></figure><p>这表示在本地启动一个 8088 的端口，将这个 8088 端口映射到 10.1.1.123 的 8083 端口上，用的 SSH 账号是 user</p><p>然后在笔记本上的浏览器中输入：127.0.0.1:8088 就看到了如下界面：</p><p><img src="https://img.hi-linux.com/staticfile/bOUSWh-2024-01-22-CPWM1b.png" alt></p><p>反过来，<strong>也可以让隔离环境机器通过代理上网，比如安装 yum</strong></p><h2><span id="为什么有时候-ssh-比较慢比如总是需要-30-秒钟后才能正常登录">为什么有时候 SSH 比较慢，比如总是需要 30 秒钟后才能正常登录</span></h2><p>先了解如下知识点，在 ~/.ssh/config 配置文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GSSAPIAuthentication&#x3D;no</span><br></pre></td></tr></table></figure><p>禁掉 GSSAPI 认证，GSSAPIAuthentication 是个什么鬼东西请自行 Google (多一次没必要的授权认证过程，然后等待超时)。 这里要理解 SSH 登录的时候有很多种认证方式（公钥、密码等等），具体怎么调试请记住强大的命令参数 <code>ssh -vvv</code> 上面讲到的技巧都能通过 <code>-vvv</code> 看到具体过程。</p><p>比如我第一次碰到 ssh 比较慢总是需要 30 秒后才登录，不能忍受，于是登录的时候加上 -vvv 明显看到控制台停在了：GSSAPIAuthentication 然后 Google 了一下，禁掉就好了</p><p>当然还有去掉每次 SSH 都需要先输入 Yes</p><h2><span id="批量打通所有机器之间的-ssh-登录免密码">批量打通所有机器之间的 SSH 登录免密码</span></h2><p><strong>Expect 在有些公司是被禁止的</strong></p><p>SSH 免密码的原理是将本机的 Pubkey 复制到目标机器的 <code>~/.ssh/authorized_keys</code> 里面。可以手工复制粘贴，也可以 ssh-copy-id 等。</p><p>如果有 100 台机器，互相两两打通还是比较费事（大概需要100*99次 copy key）。 下面通过 expect 来解决输入密码，然后配合 Shell 脚本来批量解决这个问题。</p><p><img src="https://img.hi-linux.com/staticfile/OkaCp5-2024-01-22-dxXOti.png" alt></p><p>这个脚本需要四个参数：目标IP、用户名、密码、Home 目录，也就是 SSH 到一台机器的时候帮我们自动填上 yes，和密码，这样就不需要人肉一个个输入了。</p><p>再在外面写一个循环对每个 IP 执行如下操作：</p><p><img src="https://img.hi-linux.com/staticfile/S3qQYl-2024-01-22-BqCQTy.png" alt></p><p>if 代码部分检查本机 ~/.ssh/ 下有没有 id_rsa.pub，也就是是否以前生成过密钥对，没生成的话就帮忙生成一次。</p><p>for 循环部分一次把生成的密钥对和 authorized_keys 复制到所有机器上，这样所有机器之间都不需要输入密码就能互相登陆了（当然本机也不需要输入密码登录所有机器）</p><p>最后一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh $user@$n &quot;hostname -i&quot;</span><br></pre></td></tr></table></figure><p>验证一下没有输密码是否能成功 SSH 上去。</p><p><strong>思考一下，为什么这么做就可以打通两两之间的免密码登录，这里没有把所有机器的 PubKey 复制到其他所有机器上去啊</strong></p><blockquote><p>答案：其实这个脚本做了一个取巧投机的事，那就是让所有机器共享一套公钥、私钥。<br>有时候我也会把我的 Windows 笔记本和我专用的某台虚拟机共享一套秘钥，这样任何新申请的机器打通一次账号就可以在两台机器上随便登录。请保护好自己的私钥</p></blockquote><p>如果免密写入 authorized_keys 成功，但是通过 SSH Pubkey 认证的时候还是有可能失败，这是因为 Pubkey 认证要求：</p><ul><li>authorized_keys  文件权限要对</li><li>.ssh 文件夹权限要对</li><li>/home/user 文件夹权限要对 ----这个容易忽视掉</li></ul><h2><span id="留个作业第一次-ssh-某台机器的时候总是出来一个警告需要-yes-确认才能往下走怎么干掉他">留个作业：第一次 SSH 某台机器的时候总是出来一个警告，需要 Yes 确认才能往下走，怎么干掉他？</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; StrictHostKeyChecking&#x3D;no</span><br><span class="line">&gt; UserKnownHostsFile&#x3D;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p><strong>这里只是帮大家入门了解 SSH ，掌握好这些配置文件和 -vvv 后有好多好玩的可以去挖掘，同时也请在留言中说出你的黑技能</strong></p><h2><span id="~sshconfig-参考配置">~/.ssh/config 参考配置</span></h2><p>下面是我个人常用的 SSH Config 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat ~/.ssh/config</span></span><br><span class="line"><span class="meta">#</span><span class="bash">GSSAPIAuthentication=no</span></span><br><span class="line">StrictHostKeyChecking=no</span><br><span class="line"><span class="meta">#</span><span class="bash">TCPKeepAlive=yes</span></span><br><span class="line">CheckHostIP=no</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"ServerAliveInterval [seconds]"</span> configuration <span class="keyword">in</span> the SSH configuration so that your ssh client sends a <span class="string">"dummy packet"</span> on a regular interval so that the router thinks that the connection is active even <span class="keyword">if</span> it<span class="string">'s particularly quiet</span></span></span><br><span class="line">ServerAliveInterval=15</span><br><span class="line"><span class="meta">#</span><span class="bash">ServerAliveCountMax=6</span></span><br><span class="line">ForwardAgent=yes</span><br><span class="line"></span><br><span class="line">UserKnownHostsFile /dev/null</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">reuse the same connection</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath /tmp/ssh_mux_%h_%p_%r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">keep one connection <span class="keyword">in</span> 72hour</span></span><br><span class="line">ControlPersist 72h</span><br><span class="line"></span><br><span class="line">Host 192.168.1.*</span><br><span class="line">ProxyCommand ssh user@us.jump exec /usr/bin/nc %h %p 2&gt;/dev/null</span><br><span class="line">Host 192.168.2.*</span><br><span class="line">ProxyCommand ssh user@cn.jump exec /usr/bin/nc %h %p 2&gt;/dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash">ProxyCommand /bin/nc -x localhost:12346 %h %p</span></span><br><span class="line"></span><br><span class="line">Host 172</span><br><span class="line">    HostName 10.172.1.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump root@1.2.3.4:12345</span><br><span class="line"></span><br><span class="line">Host 176</span><br><span class="line">    HostName 10.176.1.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump admin@1.2.3.4:12346</span><br><span class="line">    </span><br><span class="line">Host 10.5.*.*, 10.*.*.*</span><br><span class="line">    port 22</span><br><span class="line">user root</span><br><span class="line">ProxyJump plantegg@1.2.3.4:12347</span><br></pre></td></tr></table></figure><p>ProxyJump 完全可以取代 ProxyCommand，比如 ProxyJump 不再依赖 nc、也更灵活一些。</p><h2><span id="etcsshssh_config-参考配置">/etc/ssh/ssh_config 参考配置</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">Protocol 2</span><br><span class="line">ServerAliveInterval 30</span><br><span class="line">User admin</span><br><span class="line"></span><br><span class="line">host 10.10.55.*</span><br><span class="line">ProxyCommand ssh -l admin admin.jump  exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line"># uos is a hostname</span><br><span class="line">Host 10.10.1.13* 192.168.2.133 uos</span><br><span class="line">ProxyCommand ssh -l root -p 54900 1.1.1.1 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line">#debug for git proxy</span><br><span class="line">Host github.com</span><br><span class="line">#    LogLevel DEBUG3</span><br><span class="line">#    ProxyCommand ssh  -l root gfw.jump exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line">#    ProxyCommand ssh -oProxyCommand&#x3D;&#39;ssh -l admin gfw.jump:22&#39; -l root gfw.jump2 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ForwardAgent yes</span><br><span class="line">ForwardX11 yes</span><br><span class="line">ForwardX11Trusted yes</span><br><span class="line"></span><br><span class="line">    SendEnv LANG LC_*</span><br><span class="line">    HashKnownHosts yes</span><br><span class="line">    GSSAPIAuthentication no</span><br><span class="line">    GSSAPIDelegateCredentials no</span><br><span class="line">    Compression yes</span><br></pre></td></tr></table></figure><h2><span id="其他知识点">其他知识点</span></h2><p>参数的优先级是：<strong>命令行配置选项 &gt; ~/.ssh/config &gt; /etc/ssh/ssh_config</strong></p><p>在 SSH 的 <strong>身份验证阶段，SSH只支持服务端保留公钥，客户端保留私钥的方式</strong>，所以方式只有两种：客户端生成密钥对，将公钥分发给服务端；服务端生成密钥对，将私钥分发给客户端。只不过出于安全性和便利性，一般都是客户端生成密钥对并分发公钥（阿里云服务器秘钥对–服务器将一对密钥中的公钥放在 authorized_keys, 私钥给client登陆用）</p><p>服务器上的 <code>/etc/ssh/ssh_host*</code> 是用来验证服务器身份的秘钥对（对应 Client的 Known_hosts), <strong>在主机验证阶段，服务端持有的是私钥，客户端保存的是来自于服务端的公钥。注意，这和身份验证阶段密钥的持有方是相反的。</strong></p><p>SSH 支持多种身份验证机制，<strong>它们的验证顺序如下：gssapi-with-mic,hostbased,publickey,keyboard-interactive,password</strong>，但常见的是密码认证机制 (password) 和公钥认证机制 (public key). 当公钥认证机制未通过时，再进行密码认证机制的验证。这些认证顺序可以通过 SSH 配置文件(注意，不是sshd 的配置文件)中的指令 PreferredAuthentications 改变。</p><h3><span id="永久隧道">永久隧道</span></h3><p>大多时候隧道会失效，或者断开，我们需要有重连机制，一般可以通过 autossh（需要单独安装）搞定自动重连，再配合 Systemd 或者 Crond 搞定永久自动重连</p><p>比如以下代码在 gf 开启 2 个远程转发端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">remote_port&#x3D;(30081 30082)</span><br><span class="line">for port in &quot;$&#123;remote_port[@]&#125;&quot;</span><br><span class="line">do</span><br><span class="line">    line&#x3D;&#96;ps aux |grep ssh |grep $port | wc -l&#96;</span><br><span class="line">    if [[ &quot;$line&quot; -lt 1 ]]; then</span><br><span class="line">        autossh -M 0 -fNR gf:$port:127.0.0.1:22 root@gf</span><br><span class="line">    fi;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">line&#x3D;&#96;ps aux |grep ssh |grep 13129 | wc -l&#96;</span><br><span class="line">if [[ &quot;$line&quot; -lt 1 ]]; then</span><br><span class="line">    nohup ssh -fNR gf:13129:172.16.1.2:3129 root@gf</span><br><span class="line">fi;</span><br><span class="line"></span><br><span class="line">#cat &#x2F;etc&#x2F;cron.d&#x2F;jump</span><br><span class="line">#* * * * * root sh &#x2F;root&#x2F;drds_private_cloud&#x2F;jump.sh</span><br></pre></td></tr></table></figure><p>或者另外创建一个 Service 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;AutoSSH tunnel on 31081 to gf server</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment&#x3D;&quot;AUTOSSH_GATETIME&#x3D;0&quot;</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;autossh -M 0 -q -N -o &quot;ServerAliveInterval 60&quot; -o &quot;ServerAliveCountMax 3&quot; -NR gf:31081:172.16.1.2:22 -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa root@gf</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><h3><span id="调试-ssh终极大招">调试 SSH–终极大招</span></h3><p>好多问题我都是 Debug 发现的</p><ul><li>客户端增加参数 -vvv 会把所有流程在控制台显示出来。卡在哪个环节；密码不对还是 Key 不对一看就知道</li><li>server 端还可以：<code>/usr/sbin/sshd -ddd -p 2222</code> 在 2222 端口对 sshd 进行 Debug，看输出信息验证为什么 pubkey 不能 Login 等. 一般都是权限不对，/root 以及 /root/.ssh 文件夹的权限和owner都要对，更不要说 /root/.ssh/authorized_keys 了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;sshd -ddd -p 2222</span><br></pre></td></tr></table></figure><h3><span id="ssh-提示信息"></span></h3><p>可以用一下脚本生成一个彩色文件，放到 /etc/motd 中就行</p><p>Basic colors are numbered:</p><ul><li>1 – Red</li><li>2 – Green</li><li>3 – Yellow</li><li>4 – Blue</li><li>5 – Magenta</li><li>6 – Cyan</li><li>7 – White</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">export TERM=xterm-256color</span><br><span class="line"></span><br><span class="line">read one five fifteen rest &lt; /proc/loadavg</span><br><span class="line">echo "$(tput setaf 2)</span><br><span class="line">Kernel: `uname -v | awk -v OFS=' ' '&#123;print $4, $5&#125;'`</span><br><span class="line">                                                                                                                                   </span><br><span class="line">        \\   ^__^</span><br><span class="line">         \\  (oo)\\_______</span><br><span class="line">            (__)\\       )\\\/\\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br><span class="line"></span><br><span class="line">本机器为长稳测试环境, 千万不要kill进程, 不要跑负载过重的任务</span><br><span class="line"></span><br><span class="line">有任何需要请联系 ** 多谢!</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput setaf 4)Load Averages......: <span class="variable">$&#123;one&#125;</span>, <span class="variable">$&#123;five&#125;</span>, <span class="variable">$&#123;fifteen&#125;</span> (1, 5, 15 min)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput setaf 5)</span></span><br><span class="line"> ______________</span><br><span class="line">本机器为长稳测试环境, 千万不要kill进程, 不要跑负载过重的任务</span><br><span class="line"></span><br><span class="line">有任何需要请联系 ** 多谢!</span><br><span class="line"> --------------</span><br><span class="line">        \\   ^__^</span><br><span class="line">         \\  (oo)\\_______</span><br><span class="line">            (__)\\       )\\\/\\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput sgr0)<span class="string">"</span></span></span><br></pre></td></tr></table></figure><p>以上脚本运行结果</p><p><img src="https://img.hi-linux.com/staticfile/8Hcheo-2024-01-22-Cpn0tg.png" alt></p><h3><span id="sshd-banner">SSHD Banner</span></h3><p><code>Banner</code>指定用户登录后，sshd 向其展示的信息文件（<code>Banner /usr/local/etc/warning.txt</code>），默认不展示任何内容。</p><p>或者配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"># no default banner path</span><br><span class="line">#Banner none</span><br><span class="line">#在配置文件末尾添加Banner &#x2F;etc&#x2F;ssh&#x2F;my_banner这一行内容：</span><br><span class="line">Banner &#x2F;etc&#x2F;ssh&#x2F;my_banner</span><br></pre></td></tr></table></figure><p><code>/etc/ssh/my_banner</code> 中可以放置提示内容。</p><h3><span id="验证秘钥对">验证秘钥对</span></h3><p><strong>-y</strong> Read a private OpenSSH format file and print an OpenSSH public key to stdout.</p><blockquote><p>cd ~/.ssh/ ; ssh-keygen -y -f id_rsa | cut -d’ ’ -f 2  ;  cut -d’ ’ -f 2 id_rsa.pub</p></blockquote><p><code>ssh-keygen -y -e -f &lt;private key&gt;</code>获取一个私钥并打印相应的公钥，该公钥可以直接与您可用的公钥进行比较</p><h3><span id="github-上你的公钥">Github 上你的公钥</span></h3><p>Github 可以取到你的公钥，如果别人让你查看他的服务器，直接给 <a href="https://github.com/plantegg.keys" target="_blank" rel="noopener">https://github.com/plantegg.keys</a> 这个链接，让他把下载的 Key 加到 ~/.ssh/authorized_keys 里面就行了。</p><h3><span id="通过-ssh-keygen-生成公钥">通过 ssh-keygen 生成公钥</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &lt;&lt;&lt;y</span><br><span class="line">ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &lt;&lt;&lt;y &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">//修改 Passphrase</span><br><span class="line">ssh-keygen -p -P "12345" -N "abcde" -f .ssh/id_rsa</span><br><span class="line">//ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]</span><br><span class="line">//或者直接通过提示一步步修改：</span><br><span class="line">ssh-keygen -p</span><br></pre></td></tr></table></figure><p>删除或者修改 Passphrase</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; run &#96;ssh-keygen -p&#96; in a terminal. It will then prompt you for a keyfile (defaulted to the correct file for me, &#96;~&#x2F;.ssh&#x2F;id_rsa&#96;), the old passphrase (enter what you have now) and the new passphrase (enter nothing). </span><br><span class="line"></span><br><span class="line">[要注意 OpenSSH 不同版本使用的不同 format](https:&#x2F;&#x2F;www.ibm.com&#x2F;support&#x2F;pages&#x2F;openssl-wont-understand-rsa-keys-rfc4716-format)，用 OpenSSH 8.0 默认用 &quot;RFC4716&quot; 格式，老的 4.0 默认是 PKCS8 格式</span><br><span class="line"></span><br><span class="line">去修改 DSA 密钥后 Openssh 4.0 不认。 </span><br><span class="line"></span><br><span class="line">&gt; -m key_format</span><br><span class="line">&gt;         Specify a key format for the -i (import) or -e (export) conversion options.  The sup‐</span><br><span class="line">&gt;         ported key formats are: “RFC4716” (RFC 4716&#x2F;SSH2 public or private key), “PKCS8” (PEM</span><br><span class="line">&gt;         PKCS8 public key) or “PEM” (PEM public key).  The default conversion format is</span><br><span class="line">&gt;         “RFC4716”.</span><br></pre></td></tr></table></figure><p>如果用 8.0 去修改 PKCS8 格式的 key 可以指定格式参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p  -m &quot;PKCS8&quot; -f .&#x2F;id_dsa</span><br></pre></td></tr></table></figure><h3><span id="ssh-agent">SSH-Agent</span></h3><p>私钥设置了密码以后，每次使用都必须输入密码，有时让人感觉非常麻烦。比如，连续使用<code>scp</code>命令远程拷贝文件时，每次都要求输入密码。</p><p><code>ssh-agent</code>命令就是为了解决这个问题而设计的，它让用户在整个 Bash 对话（session）之中，只在第一次使用 SSH 命令时输入密码，然后将私钥保存在内存中，后面都不需要再输入私钥的密码了。</p><p>第一步，使用下面的命令新建一次命令行对话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval &#96;ssh-agent&#96;</span><br></pre></td></tr></table></figure><p>上面命令中，<code>ssh-agent</code> 会先自动在后台运行，并将需要设置的环境变量输出在屏幕上，类似下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent</span><br><span class="line">SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-barrett&#x2F;ssh-22841-agent; export SSH_AUTH_SOCK;</span><br><span class="line">SSH_AGENT_PID&#x3D;22842; export SSH_AGENT_PID;</span><br><span class="line">echo Agent pid 22842;</span><br></pre></td></tr></table></figure><p><code>eval</code>命令的作用，就是运行上面的 <code>ssh-agent</code> 命令的输出，设置环境变量。</p><p>第二步，在新建的 Shell 对话里面，使用 <code>ssh-add</code> 命令添加默认的私钥（比如<code>~/.ssh/id_rsa</code>，或<code>~/.ssh/id_dsa</code>，或<code>~/.ssh/id_ecdsa</code>，或<code>~/.ssh/id_ed25519</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add</span><br><span class="line">Enter passphrase for &#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa: ********</span><br><span class="line">Identity added: &#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa (&#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa)</span><br></pre></td></tr></table></figure><p>上面例子中，添加私钥时，会要求输入密码。以后，在这个对话里面再使用密钥时，就不需要输入私钥的密码了，因为私钥已经加载到内存里面了。</p><p>如果添加的不是默认私钥，<code>ssh-add</code>命令需要显式指定私钥文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add my-other-key-file</span><br></pre></td></tr></table></figure><p>上面的命令中，<code>my-other-key-file</code>就是用户指定的私钥文件。</p><p>SSH agent 程序能够将您的已解密的私钥缓存起来，在需要的时候用它来解密key chanllge返回给 SSHD  <a href="https://webcache.googleusercontent.com/search?q=cache:7OfvSBFki10J:https://www.ibm.com/developerworks/cn/linux/security/openssh/part2/+&amp;cd=7&amp;hl=en&amp;ct=clnk&amp;gl=hk" target="_blank" rel="noopener">https://webcache.googleusercontent.com/search?q=cache:7OfvSBFki10J:https://www.ibm.com/developerworks/cn/linux/security/openssh/part2/+&amp;cd=7&amp;hl=en&amp;ct=clnk&amp;gl=hk</a> keychain介绍</p><h3><span id="安装-sshd-和-debug">安装 sshd 和 debug</span></h3><p>sshd 有自己的一对或多对密钥。它使用密钥向客户端证明自己的身份。所有密钥都是公钥和私钥成对出现，公钥的文件名一般是私钥文件名加上后缀<code>.pub</code>。</p><p>DSA 格式的密钥文件默认为 <code>/etc/ssh/ssh_host_dsa_key</code>（公钥为<code>ssh_host_dsa_key.pub</code>），RSA 格式的密钥为 <code>/etc/ssh/ssh_host_rsa_key</code>（公钥为 <code>ssh_host_rsa_key.pub</code>）。如果需要支持 SSH 1 协议，则必须有密钥<code>/etc/ssh/ssh_host_key</code>。</p><p>如果密钥不是默认文件，那么可以通过配置文件 <code>sshd_config</code> 的 <code>HostKey</code> 配置项指定。默认密钥的 <code>HostKey</code> 设置如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># HostKey for protocol version 1</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_key</span><br><span class="line"></span><br><span class="line"># HostKeys for protocol version 2</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_key</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_dsa_ke</span><br></pre></td></tr></table></figure><p>注意，如果重装 sshd，<code>/etc/ssh</code>下的密钥都会重新生成（这些密钥对用于验证Server的身份），导致客户端重新 ssh 连接服务器时，会跳出警告，拒绝连接。为了避免这种情况，可以在重装 sshd 时，先备份<code>/etc/ssh</code>目录，重装后再恢复这个目录。</p><blockquote><p>调试：非后台(-D)和debug(-d)模式启动sshd，同时监听2222和3333端口</p><p>sshd -D -d -p 2222 -p 3333</p></blockquote><p>sshd config 配置多端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line">Port 22022</span><br><span class="line">Port 22</span><br><span class="line">#AddressFamily any</span><br><span class="line">#ListenAddress 0.0.0.0</span><br></pre></td></tr></table></figure><h3><span id="scp-设置-socks-代理">Scp 设置 socks 代理</span></h3><blockquote><p>scp -o “ProxyCommand=nc -X 5 -x <strong>[SOCKS_HOST]</strong>:<strong>[SOCKS_PORT]</strong> %h %p” <strong>[LOCAL/FILE/PATH]</strong> <strong>[REMOTE_USER]</strong>@<strong>[REMOTE_HOST]</strong>:<strong>[REMOTE/FILE/PATH]</strong></p></blockquote><p>其中[SOCKS_HOST]和[SOCKS_PORT]是 Socks 代理的 LOCAL_ADDRESS 和 LOCAL_PORT。[LOCAL/FILE/PATH]、[REMOTE_USER]、[REMOTE_HOST]和[REMOTE/FILE/PATH] 分别是要复制文件的本地路径、要复制到的远端主机的用户名、要复制到的远端主机名、要复制文件的远端路径，这些参数与不使用代理时一样。“ProxyCommand=nc” 表示当前运行命令的主机上需要有 nc 命令。</p><h3><span id="proxycommand">ProxyCommand</span></h3><blockquote><p>Specifies the proxy command for the connection. This command is launched prior to making the connection to Hostname. %h is replaced with the host defined in HostName and %p is replaced with 22 or is overridden by a Port directive.</p></blockquote><p>在 SSH 连接目标主机前先执行 ProxyCommand 中的命令，比如 <code>.ssh/config</code> 中有如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">host remote-host</span><br><span class="line">ProxyCommand ssh -l root -p 52146 1.2.3.4 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以上配置等价下面的命令</span><br><span class="line">ssh -o ProxyCommand&#x3D;&quot;ssh -l root -p 52146 1.2.3.4 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p&quot; remote-host</span><br><span class="line">&#x2F;&#x2F;or 等价</span><br><span class="line">ssh -o ProxyCommand&#x3D;&quot;ssh -l root -p 52146 -W %h:%p 1.2.3.4 &quot; remote-host</span><br><span class="line">&#x2F;&#x2F;or 等价 debug1: Setting implicit ProxyCommand from ProxyJump: ssh -l root -p 52146 -vvv -W &#39;[%h]:%p&#39; 1.2.3.4</span><br><span class="line">ssh -J root@1.2.3.4:52146 remote-host</span><br></pre></td></tr></table></figure><p>如上配置指的是，如果执行ssh remote-host 命中host规则，那么先执行命令 ssh -l root -p 52146 1.2.3.4 exec /usr/bin/nc 同时把remote-host和端口(默认22)传给nc</p><p>ProxyCommand 和 ProxyJump 很类似，ProxyJump 使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ssh到centos8机器上，走的是gf这台跳板机，本地一般和centos8不通</span><br><span class="line">ssh -J gf:22 centos8</span><br></pre></td></tr></table></figure><h3><span id="proxyjump">ProxyJump</span></h3><p>需要 <code>OpenSSH 7.3</code> 以上版本才可以使用 <code>ProxyJump</code>, 相对 ProxyCommand 更简洁方便些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ssh 116 就可以通过 jumpserver:50023 连上 root@1.116.2.1:22</span><br><span class="line">Host 116</span><br><span class="line">    HostName 1.116.2.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump admin@jumpserver:50023</span><br><span class="line"></span><br><span class="line">#ssh 1.112.任意ip 都会默认走 jumpserver 跳转过去</span><br><span class="line">Host 1.112.*.*</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump root@jumpserver</span><br></pre></td></tr></table></figure><h3><span id="加密算法"></span></h3><p>列出本地所支持默认的加密算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#ssh -Q key                                                            </span><br><span class="line">ssh-ed25519</span><br><span class="line">ssh-ed25519-cert-v01@openssh.com</span><br><span class="line">ssh-rsa</span><br><span class="line">ssh-dss</span><br><span class="line">ecdsa-sha2-nistp256</span><br><span class="line">ecdsa-sha2-nistp384</span><br><span class="line">ecdsa-sha2-nistp521</span><br><span class="line">ssh-rsa-cert-v01@openssh.com</span><br><span class="line">ssh-dss-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp256-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp384-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp521-cert-v01@openssh.com</span><br><span class="line"></span><br><span class="line">ssh -Q cipher       # List supported ciphers</span><br><span class="line">ssh -Q mac          # List supported MACs</span><br><span class="line">ssh -Q key          # List supported public key types</span><br><span class="line">ssh -Q kex          # List supported key exchange algorithms</span><br></pre></td></tr></table></figure><p>比如连服务器报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug1: kex: algorithm: (no match)</span><br><span class="line">Unable to negotiate with server port 22: no matching key exchange method found. Their offer: diffie-hellman-group1-sha1,diffie-hellman-group14-sha1</span><br></pre></td></tr></table></figure><p>表示服务端支持 diffie-hellman-group1-sha1,diffie-hellman-group14-sha1 加密，但是client端不支持，那么可以指定算法来强制client端使用某种和server一致的加密方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh  -oKexAlgorithms&#x3D;+diffie-hellman-group14-sha1 -l user</span><br><span class="line"></span><br><span class="line">或者config中配置：</span><br><span class="line">host server_ip</span><br><span class="line">KexAlgorithms +diffie-hellman-group1-sha1</span><br></pre></td></tr></table></figure><p>如果仍然报以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debug2: first_kex_follows 0</span><br><span class="line">debug2: reserved 0</span><br><span class="line">debug1: kex: algorithm: diffie-hellman-group14-sha1</span><br><span class="line">debug1: kex: host key algorithm: (no match)</span><br><span class="line">Unable to negotiate with server_ip port 22: no matching host key type found. Their offer: ssh-rsa</span><br></pre></td></tr></table></figure><p>那么可以配置来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">    HostKeyAlgorithms +ssh-rsa</span><br><span class="line">    PubkeyAcceptedKeyTypes +ssh-rsa</span><br></pre></td></tr></table></figure><p>When an SSH client connects to a server, each side offers lists of connection parameters to the other. These are, with the corresponding <a href="https://man.openbsd.org/ssh_config.5" target="_blank" rel="noopener">ssh_config</a> keyword:</p><ul><li><code>KexAlgorithms</code>: the key exchange methods that are used to generate per-connection keys</li><li><code>HostkeyAlgorithms</code>: the public key algorithms accepted for an SSH server to authenticate itself to an SSH client</li><li><code>Ciphers</code>: the ciphers to encrypt the connection</li><li><code>MACs</code>: the message authentication codes used to detect traffic modification</li></ul><h2><span id="无所不能的-ssh-三大转发模式">无所不能的 SSH 三大转发模式</span></h2><p>了解完前面的一些小知识，再来看看无所不能的三大杀招。上面的各种代理基本都是由这三种转发模式实现的。</p><p>SSH 能够做动态转发、本地转发、远程转发。先简要概述下他们的特点和使用场景</p><p><strong><a href="https://www.skywind.me/blog/archives/2546" target="_blank" rel="noopener">三个转发模式的比较</a>：</strong></p><ul><li>动态转发完全可以代替本地转发，只是动态转发是 <code>socks5协议</code>，当正确上网用，本地转发是 TCP 协议</li><li>本地转发完全是把动态转发特例化到访问某个固定目标的转发，类似 Iptable 的 Port Forwarding</li><li>远程转发是启动转端口的机器同时连上两端的两个机器，把本来不连通的两端拼接起来，中间显得多了个节点。</li><li>三个转发模式可以串联使用</li></ul><p>动态转发常用来正确上网，本地转发用来打洞，这两种转发启动的端口都是在本地；远程转发也是打洞的一种，只不过启用的端口在远程机器上。</p><p><img src="https://img.hi-linux.com/staticfile/sKbEgK-2024-01-22-mnPbqn.png" alt></p><h3><span id="动态转发-d-socks5-协议">动态转发 (-D)  SOCKS5 协议</span></h3><p>动态转发指的是，本机与 SSH 服务器之间创建了一个加密连接，然后本机内部针对某个端口的通信，都通过这个加密连接转发。它的一个使用场景就是，访问所有外部网站，都通过 SSH 转发。</p><p>动态转发需要把本地端口绑定到 SSH 服务器。<strong>至于 SSH 服务器要去访问哪一个网站，完全是动态的，取决于原始通信，所以叫做动态转发</strong>。</p><p>动态的意思就是：需要访问的目标、端口还不确定。后面要讲的本地转发、远程转发都是针对具体 IP、Port 的转发。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -D 4444 ssh-server -N</span></span><br><span class="line">//或者如下方式：</span><br><span class="line">nohup ssh -qTfnN -D *:13658 root@jump vmstat 10  &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>注意，这种转发采用了 SOCKS5 协议。访问外部网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。<code>-N</code>参数表示，这个 SSH 连接不能执行远程命令，只能充当隧道。</p><p><img src="https://img.hi-linux.com/staticfile/8wIxNP-2024-01-22-qJOasK.png" alt></p><p>下面是 SSH  隧道建立后的一个<strong>使用实例</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -x socks5://localhost:4444 http://www.example.com</span><br><span class="line">or</span><br><span class="line">curl --socks5-hostname localhost:4444 https://www.twitter.com</span><br></pre></td></tr></table></figure><p>上面命令中，curl 的 <code>-x</code> 参数指定代理服务器，即通过 SOCKS5 协议的本地<code>3000</code>端口，访问<code>http://www.example.com</code>。</p><p>官方文档关于 <code>-D</code> 的介绍</p><blockquote><p>-D [bind_address:]port<br>Specifies a local “dynamic” application-level port forwarding.  This works by allocat‐<br>ing a socket to listen to port on the local side, optionally bound to the specified<br>bind_address.  Whenever a connection is made to this port, the connection is forwarded<br>over the secure channel, and the application protocol is then used to determine where<br>to connect to from the remote machine.  Currently the SOCKS4 and SOCKS5 protocols are<br>supported, and ssh will act as a SOCKS server.  Only root can forward privileged ports.<br>Dynamic port forwardings can also be specified in the configuration file.</p></blockquote><p>特别注意，如果 <code>ssh -D</code> 要启动的本地 Port 已经被占用了是不会报错的，但是实际 Socks 代理会没启动成功。</p><h3><span id="本地转发-l">本地转发 (-L)</span></h3><p>本地转发（Local Forwarding）指的是，SSH 服务器作为中介的跳板机，建立本地计算机与特定<code>目标网站</code>之间的加密连接。本地转发是在本地计算机的 SSH 客户端建立的转发规则。</p><p>典型使用场景就是，打洞，经过跳板机访问无法直接连通的服务。</p><p>它会指定一个本地端口（Local-Port），所有发向那个端口的请求，都会转发到 SSH 跳板机（ssh-server），然后 SSH 跳板机作为中介，将收到的请求发到目标服务器（target-host）的目标端口（target-port）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -L :<span class="built_in">local</span>-port:target-host:target-port ssh-server  //target-host是ssh-server的target-host, target-host 域名解析、路由都是由 ssh-server 完成</span></span><br></pre></td></tr></table></figure><p>上面命令中，<code>-L</code>参数表示本地转发，<code>local-port</code>是本地端口，<code>target-host</code>是你想要访问的目标服务器，<code>target-port</code>是目标服务器的端口，<code>ssh-server</code> 是 SSH 跳板机。当你访问 localhost:local-port 的时候会通过 ssh-server 把请求转给 target-host:target-port</p><p><img src="https://img.hi-linux.com/staticfile/INjeHZ-2024-01-22-EWAI33.png" alt></p><p>上图对应的命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 53682:remote-server:53682 ssh-server</span><br></pre></td></tr></table></figure><p>然后，访问本机的 53682 端口，就是访问 <code>remote-server</code> 的 53682 端口.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;localhost:53682</span><br></pre></td></tr></table></figure><p>注意，<strong>本地端口转发采用 HTTP 协议，不用转成 SOCKS5 协议</strong>。如果需要 HTTP 的动态代理，可以先起 Socks5 动态代理，然后再起一个本地转发给动态代理的 Socks5 端口，这样就有一个 HTTP 代理了，能给 Yum、Docker 之类的使用。</p><p>这个命令最好加上<code>-N</code>参数，表示不在 SSH 跳板机执行远程命令，让 SSH 只充当隧道。另外还有一个<code>-f</code>参数表示 SSH 连接在后台运行。</p><p>如果经常使用本地转发，可以将设置写入 SSH 客户端的用户个人配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host test.example.com</span><br><span class="line">LocalForward client-IP:client-port server-IP:server-port</span><br></pre></td></tr></table></figure><h3><span id="远程转发-r">远程转发(-R)</span></h3><p>远程端口指的是在远程 SSH 服务器建立的转发规则。主要是执行 SSH 转发的机器别人连不上，所以需要一台 Client 能连上的机器当远程转发端口，要不就是本地转发了。</p><p>由于本机无法访问内网 SSH 跳板机，就无法从外网发起 SSH 隧道，建立端口转发。必须反过来，从 SSH 跳板机发起隧道，建立端口转发，这时就形成了远程端口转发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -fNR 30.1.2.3:30081:166.100.64.1:3128 root@30.1.2.3 -p 2728</span><br></pre></td></tr></table></figure><p>上面的命令，首先需要注意，<strong>不是在 30.1.2.3 或者 166.100.64.1 上执行的，而是找一台能联通 30.1.2.3 和 166.100.64.1 的机器来执行</strong>，在执行前 Remote Clients 能连上 30.1.2.3 但是 30.1.2.3 和 166.100.64.1 不通，所以需要一个中介将 30.1.2.3 和166.100.64.1打通，这个中介就是下图中的MobaXterm所在的机器，命令在 MobaXterm 机器上执行</p><p><img src="https://img.hi-linux.com/staticfile/PER8yY-2024-01-22-IvkyqB.png" alt></p><p>执行上面的命令以后，跳板机 30.1.2.3 到 166.100.64.1 的隧道已经建立了，这个隧道是依赖两边都能连通的 MobaXterm 机器。然后，就可以从 Remote Client 访问目标服务器了，即在 Remote Client 上执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;30.1.2.3:30081</span><br></pre></td></tr></table></figure><p>执行上面的命令以后，命令就会输出服务器 166.100.64.1 的3128端口返回的内容。</p><p>如果经常执行远程端口转发，可以将设置写入 SSH 客户端的用户个人配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host test.example.com</span><br><span class="line">RemoteForward local-IP:local-port target-ip:target-port</span><br></pre></td></tr></table></figure><p>注意远程转发需要：</p><blockquote><ol><li>sshd_config 里要打开 <code>AllowTcpForwarding</code> 选项，否则 <code>-R</code> 远程端口转发会失败。</li><li>默认转发到远程主机上的端口绑定的是 <code>127.0.0.1</code>，<a href="https://serverfault.com/questions/997124/ssh-r-binds-to-127-0-0-1-only-on-remote" target="_blank" rel="noopener">如要绑定 <code>0.0.0.0</code> 需要打开 sshd_config 里的 <code>GatewayPorts</code> 选项(然后ssh -R 后加上 *:port )</a>。这个选项如果由于权限没法打开也有办法，可配合 <code>ssh -L</code> 将端口绑定到 <code>0.0.0.0</code>。</li></ol></blockquote><p>开通远程转发后，如果需要动态代理（比如访问所有 Web 服务），那么可以在 30081 端口机器上(30.1.2.3)执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ssh -qTfnN -D *:13658 root@127.0.0.1 -p 30081 vmstat 10  &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>表示在 30081 机器上(30.1.2.3)启动了一个 Socks5 动态代理服务</p><h2><span id="调试转发-代理是否能联通">调试转发、代理是否能联通</span></h2><h3><span id="通过-curl-调试"></span></h3><blockquote><p>curl -I --socks5-hostname localhost:13659 <a href="http://twitter.com" target="_blank" rel="noopener">twitter.com</a></p><p>curl -x socks5://localhost:13659 <a href="http://twitter.com" target="_blank" rel="noopener">twitter.com</a></p></blockquote><p>Suppose you have a socks5 proxy running on localhost:13659 .</p><p><a href="https://blog.emacsos.com/use-socks5-proxy-in-curl.html" target="_blank" rel="noopener">In curl &gt;= 7.21.7, you can use</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -x socks5h://localhost:13659 http://www.google.com/</span><br></pre></td></tr></table></figure><blockquote><p>In a proxy string, socks5h:// and socks4a:// mean that the hostname is<br>resolved by the SOCKS server. socks5:// and socks4:// mean that the<br>hostname is resolved locally. socks4a:// means to use SOCKS4a, which is<br>an extension of SOCKS4. Let’s make urllib3 honor it.</p></blockquote><p>In curl &gt;= 7.18.0, you can use</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --socks5-hostname localhost:13659 http://www.google.com/</span><br></pre></td></tr></table></figure><p><code>--proxy</code> 参数含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The --socks5 option is basically considered obsolete since curl 7.21.7. This is because starting in that release, you can now specify the proxy protocol directly in the string that you specify the proxy host name and port number with already. The server you specify with --proxy. If you use a socks5:&#x2F;&#x2F; scheme, curl will go with SOCKS5 with local name resolve but if you instead use socks5h:&#x2F;&#x2F; it will pick SOCKS5 with proxy-resolved host name.</span><br></pre></td></tr></table></figure><h3><span id="wget">wget</span></h3><p><strong>指定命令行参数</strong>,通过命令行指定 HTTP 代理服务器的方式如下：</p><blockquote><p>wget -Y on -e “http_proxy=http://<strong>[HTTP_HOST]</strong>:<strong>[HTTP_PORT]</strong>” <a href="http://facebook.com/" target="_blank" rel="noopener">http://facebook.com/</a></p></blockquote><p>其中：[HTTP_HOST]和[HTTP_PORT]是 HTTP Proxy 的 ADDRESS 和 PORT。</p><ul><li>-Y 表示是否使用代理，on表示使用代理。</li><li>-e 执行后面跟的命令，相当于在.wgetrc配置文件中添加了一条命令，将 http_proxy 设置为需要使用的代理服务器。</li><li>–limit-rate=2.5k 限制下载速度，进行测试</li></ul><h2><span id="pki-public-key-infrastructure证书">PKI (Public Key Infrastructure)证书</span></h2><p>X.509 只是一种常用的证书格式，一般以PEM编码，PEM 编码的证书通常以 <strong><code>.pem</code>、<code>.crt</code> 或 <code>.cer</code></strong> 为后缀。再次提醒，这只是“通常”情况，实际上某些工具可能并不遵循这些惯例。通过pem证书可以访问需要认证的 HTTPS 服务(比如Etcd、Apiserver 等)</p><ul><li><strong>ASN.1 用于定义数据类型</strong>，例如证书（certificate）和秘钥（key）——就像用 JSON 定义一个 request body —— X.509 用 ASN.1 定义。</li><li>DER 是一组将 ASN.1 编码成二进制（比特和字节）的编码规则（encoding rules）。</li><li>PKCS#7 and PKCS#12 是比 X.509 更大的数据结构（封装格式），也用 ASN.1 定义，其中能包含除了证书之外的其他东西。二者分别在 Java 和 Microsoft 产品中使用较多。</li><li>DER 编码之后是二进制数据，不方便复制粘贴，因此大部分证书都是用 PEM 编码的，它用 base64 对 DER 进行编码，然后再加上自己的 label。</li><li>私钥通常用是 PEM 编码的 PKCS#8 对象，但有时也会用密码来加密。</li></ul><p>通过命令 <code>cat /etc/kubernetes/pki/ca.crt | openssl x509 -text</code> 也可以得到下图信息</p><p><img src="https://img.hi-linux.com/staticfile/6ET22D-2024-01-22-hjfjim.png" alt></p><h3><span id="公钥-私钥常见扩展名">公钥、私钥常见扩展名</span></h3><ul><li>公钥：<code>.pub</code> or <code>.pem</code>，<code>ca.crt</code></li><li>私钥：<code>.prv,</code> <code>.key</code>, or <code>.pem</code> , <code>ca.key</code>。</li></ul><h3><span id="证书生成过程演示">证书生成过程演示</span></h3><p>并不是所有的场景都需要向这些大型的 CA 机构申请公钥证书，在任何一个企业，组织或是团体内都可以自己形这样的“小王国”，也就是说，你可以自行生成这样的证书，只需要你自己保证自己的生成证书的私钥的安全，以及不需要扩散到整个互联网。下面，我们用 <code>openssl</code>命令来演示这个过程。</p><ol><li>生成 CA 机构的证书（公钥） <code>ca.crt</code> 和私钥 <code>ca.key</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 \</span><br><span class="line">    -new -nodes -x509 \</span><br><span class="line">    -days 365 \</span><br><span class="line">    -out ca.crt \</span><br><span class="line">    -keyout ca.key \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;SO&#x2F;ST&#x3D;Earth&#x2F;L&#x3D;Mountain&#x2F;O&#x3D;CoolShell&#x2F;OU&#x3D;HQ&#x2F;CN&#x3D;localhost&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>生成 alice 的私钥</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out alice.key 2048</span><br></pre></td></tr></table></figure><ol start="3"><li>生成 Alice 的 CSR – Certificate Signing Request</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key alice.key -days 365 -out alice.csr \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;CN&#x2F;ST&#x3D;Beijing&#x2F;L&#x3D;Haidian&#x2F;O&#x3D;CoolShell&#x2F;OU&#x3D;Test&#x2F;CN&#x3D;localhost.alice&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 CA 给 Alice 签名证书</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl x509  -req -in alice.csr \</span><br><span class="line">    -extfile &lt;(printf &quot;subjectAltName&#x3D;DNS:localhost.alice&quot;) \ </span><br><span class="line">    -CA ca.crt -CAkey ca.key  \</span><br><span class="line">    -days 365 -sha256 -CAcreateserial \</span><br><span class="line">    -out alice.crt</span><br></pre></td></tr></table></figure><h2><span id="参考资料">参考资料：</span></h2><ul><li><a href="http://docs.corp-inc.com/pages/editpage.action?pageId=203555361" target="_blank" rel="noopener">http://docs.corp-inc.com/pages/editpage.action?pageId=203555361</a></li><li><a href="https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/SSH_keys_(简体中文)</a></li><li><a href="https://wangdoc.com/ssh/key.html" target="_blank" rel="noopener">https://wangdoc.com/ssh/key.html</a></li><li><a href="https://robotmoon.com/ssh-tunnels/" target="_blank" rel="noopener">https://robotmoon.com/ssh-tunnels/</a></li><li><a href="https://blog.gwlab.page/vpn-over-ssh-the-socks-proxy-8a8d7bdc7028" target="_blank" rel="noopener">通过SSH动态转发来建立Socks代以及各种场景应用案例</a></li><li><a href="https://daniel.haxx.se/blog/2020/05/26/curl-ootw-socks5/" target="_blank" rel="noopener">https://daniel.haxx.se/blog/2020/05/26/curl-ootw-socks5/</a></li><li><a href="http://www.allanjude.com/bsd/AsiaBSDCon2017_-_SSH_Performance.pdf" target="_blank" rel="noopener">SSH Performance</a></li><li><a href="https://stackoverflow.com/questions/8849240/why-when-i-transfer-a-file-through-sftp-it-takes-longer-than-ftp" target="_blank" rel="noopener">Why when I transfer a file through SFTP, it takes longer than FTP?</a></li><li><a href="https://zhuanlan.zhihu.com/p/413732839" target="_blank" rel="noopener">一行代码解决scp在Internet传输慢的问题</a></li><li><a href="https://www.cnxct.com/everything-about-pki-zh/" target="_blank" rel="noopener">关于证书（certificate）和公钥基础设施（PKI）的一切</a></li><li><a href="https://coolshell.cn/articles/21708.html" target="_blank" rel="noopener">网络数字身份认证术</a></li></ul><blockquote><p>本文转载自：「 plantegg 的博客 」，原文：<a href="http://tinyurl.com/25py66n3" target="_blank" rel="noopener">http://tinyurl.com/25py66n3</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我见过太多的老鸟、新手对 SSH 基本只限于 SSH 到远程机器，实际这个命令我们一天要用很多次，但是对它的了解太少了，他的强大远远超出你的想象。当于你也许会说够用就够了，确实没错，但是你考虑过效率没有，或者还有哪些脑洞大开的功能会让你爱死他，这些功能又仅仅是一行命令就够了。&lt;/p&gt;
&lt;p&gt;疫情期间一行 SSH 命令让我节省了 70% 的出差时间，来，让我们一起走一遍，看看会不会让你大开眼界。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="https://www.hi-linux.com/categories/SSH/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="SSH" scheme="https://www.hi-linux.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>国内外公共/加密 DNS 服务器列表</title>
    <link href="https://www.hi-linux.com/posts/19661.html"/>
    <id>https://www.hi-linux.com/posts/19661.html</id>
    <published>2024-01-18T01:00:00.000Z</published>
    <updated>2024-01-18T09:01:06.242Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>国内外公共 DNS，加密 DNS 汇总，可用作各种 DNS 服务器的上游服务器，在下面的列表中 <strong>选择 2-3 个为宜</strong>。选得多并不是最优解，望周知。</p><p>作为上游服务器列表时，因为 UDP 传输时间短，公共 DNS 统一选择 <code>udp</code>，而<strong>加密 DNS</strong> 统一选择：<code>https</code>，当然<code>tls</code>也可以。</p><h2><span id="国内-dns-列表">国内 DNS 列表:</span></h2><h3><span id="1-国内公共-dns-列表">1. 国内公共 DNS 列表</span></h3><h4><span id="阿里公共-dns">阿里公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">223.5.5.5</span><br><span class="line">223.6.6.6</span><br></pre></td></tr></table></figure><h4><span id="腾讯公共-dns">腾讯公共 DNS:</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">119.29.29.29</span><br></pre></td></tr></table></figure><a id="more"></a><h4><span id="百度公共-dns">百度公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">180.76.76.76</span><br></pre></td></tr></table></figure><h4><span id="360-公共-dns">360 公共 DNS</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">电信、移动、铁通：</span><br><span class="line">101.226.4.6</span><br><span class="line">218.30.118.6</span><br><span class="line">联通：</span><br><span class="line">123.125.81.6</span><br><span class="line">140.207.198.6</span><br></pre></td></tr></table></figure><h4><span id="114-公共-dns">114 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">114.114.114.114</span><br><span class="line">114.114.115.115</span><br></pre></td></tr></table></figure><h3><span id="2国内加密-dns-列表">2.国内加密 DNS 列表：</span></h3><h4><span id="阿里加密-dns">阿里加密 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alidns_ip&#x2F;dns-query</span><br><span class="line">dns.alidns.com&#x2F;dns-query</span><br></pre></td></tr></table></figure><h4><span id="腾讯加密-dns">腾讯加密 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doh.pub&#x2F;dns-query</span><br><span class="line">sm2.doh.pub&#x2F;dns-query</span><br></pre></td></tr></table></figure><h2><span id="国外-dns-列表">国外 DNS 列表：</span></h2><h3><span id="1-国外公共-dns-列表">1. 国外公共 DNS 列表</span></h3><h4><span id="cloudflare-公共-dns">Cloudflare 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.1.1.1</span><br></pre></td></tr></table></figure><h4><span id="google-公共-dns">Google 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8</span><br><span class="line">8.8.4.4</span><br></pre></td></tr></table></figure><h4><span id="norton-公共-dns">Norton 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">199.85.126.10    </span><br><span class="line">199.85.127.10</span><br></pre></td></tr></table></figure><h4><span id="威瑞信-公共-dns">威瑞信 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">64.6.64.6</span><br><span class="line">64.6.65.6</span><br></pre></td></tr></table></figure><h4><span id="comodo-公共-dns">Comodo 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.26.56.2  </span><br><span class="line">68.20.247.2</span><br></pre></td></tr></table></figure><h4><span id="dns-watch-公共-dns">DNS Watch 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">84.200.69.80</span><br><span class="line">84.200.70.40</span><br></pre></td></tr></table></figure><h4><span id="opendns-公共-dns">OpenDNS 公共 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">208.67.222.222</span><br></pre></td></tr></table></figure><h3><span id="2-国外加密-dns-列表">2. 国外加密 DNS 列表</span></h3><h4><span id="google-加密-dns">Google 加密 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dns.google&#x2F;dns-query   类型选择：https</span><br><span class="line">dns.google   类型选择：tls</span><br></pre></td></tr></table></figure><h4><span id="cloudflare-加密-dns">Cloudflare 加密 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.1.1.1&#x2F;dns-query   类型选择：tls</span><br></pre></td></tr></table></figure><h4><span id="quda9-加密-dns">Quda9 加密 DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns11.quad9.net&#x2F;dns-query 类型选择：https</span><br></pre></td></tr></table></figure><h4><span id="opendns-加密dns">OpenDNS 加密DNS：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doh.opendns.com&#x2F;dns-query</span><br></pre></td></tr></table></figure><h2><span id="国内外公共-dns-列表合集">国内外公共 DNS 列表合集</span></h2><h3><span id="1-公用-dns-服务器">1. 公用 DNS 服务器</span></h3><table><thead><tr><th>名称</th><th>DNS 服务器 IP 地址</th><th></th></tr></thead><tbody><tr><td><strong>114 DNS</strong></td><td>114.114.114.114</td><td>114.114.115.115</td></tr><tr><td><strong>阿里 AliDNS</strong></td><td>223.5.5.5</td><td>223.6.6.6</td></tr><tr><td><strong>百度 BaiduDNS</strong></td><td>180.76.76.76</td><td></td></tr><tr><td><strong>DNSPod DNS+</strong></td><td>119.29.29.29</td><td>182.254.116.116</td></tr><tr><td><strong>CNNIC SDNS</strong></td><td>1.2.4.8</td><td>210.2.4.8</td></tr><tr><td><strong>oneDNS</strong></td><td>117.50.11.11</td><td>117.50.22.22</td></tr><tr><td><strong>DNS 派电信/移动/铁通</strong></td><td>101.226.4.6</td><td>218.30.118.6</td></tr><tr><td><strong>DNS 派 联通</strong></td><td>123.125.81.6</td><td>140.207.198.6</td></tr><tr><td><strong>Google DNS</strong></td><td>8.8.8.8</td><td>8.8.4.4</td></tr><tr><td><strong>Google IPv6 DNS</strong></td><td>2001:4860:4860::8888</td><td>2001:4860:4860::8844</td></tr><tr><td><strong>IBM Quad9</strong></td><td>9.9.9.9</td><td></td></tr><tr><td><strong>OpenDNS</strong></td><td>208.67.222.222</td><td>208.67.220.220</td></tr><tr><td><strong>V2EX DNS</strong></td><td>199.91.73.222</td><td>178.79.131.110</td></tr><tr><td><strong>Verizon DNS</strong></td><td>4.2.2.1</td><td>4.2.2.2</td></tr><tr><td><strong>中国台湾中华电信 HiNet DNS</strong></td><td>168.95.192.1</td><td>168.95.1.1</td></tr><tr><td><strong>中科大DNS</strong></td><td>202.141.162.123（中国电信）</td><td>202.38.93.153 （教育网）</td></tr><tr><td></td><td>202.141.176.93 （中国移动）</td><td></td></tr><tr><td><strong>韩国KT DNS</strong></td><td>168.126.63.1</td><td>168.126.63.2</td></tr></tbody></table><h3><span id="2-去广告-dns-服务器列表">2. 去广告 DNS 服务器列表</span></h3><table><thead><tr><th>名称</th><th>DNS 服务器 IP 地址</th><th></th></tr></thead><tbody><tr><td><strong>FUN DNS</strong></td><td>119.23.248.241</td><td></td></tr><tr><td><strong>Pure DNS</strong></td><td>123.207.137.88</td><td>115.159.220.214</td></tr><tr><td><strong>CuteDns</strong></td><td>120.77.212.84(南方)</td><td>101.236.28.23（北方）</td></tr><tr><td><strong>aixyz DNS</strong></td><td>115.159.146.99(南方)</td><td>123.206.21.48（北方）</td></tr><tr><td><strong>BAI DNS</strong></td><td>106.14.152.170</td><td></td></tr><tr><td><strong>不知名DNS</strong></td><td>180.97.235.30</td><td>115.159.96.69</td></tr><tr><td></td><td>123.206.21.48</td><td>123.207.137.88</td></tr></tbody></table><h3><span id="3-各地电信-dns-列表">3. 各地电信 DNS 列表</span></h3><table><thead><tr><th>名称</th><th>DNS 服务器 IP 地址</th><th></th></tr></thead><tbody><tr><td><strong>安徽电信 DNS</strong></td><td>61.132.163.68</td><td>202.102.213.68</td></tr><tr><td><strong>北京电信 DNS</strong></td><td>219.141.136.10</td><td>219.141.140.10</td></tr><tr><td><strong>重庆电信 DNS</strong></td><td>61.128.192.68</td><td>61.128.128.68</td></tr><tr><td><strong>福建电信 DNS</strong></td><td>218.85.152.99</td><td>218.85.157.99</td></tr><tr><td><strong>甘肃电信 DNS</strong></td><td>202.100.64.68</td><td>61.178.0.93</td></tr><tr><td><strong>广东电信 DNS</strong></td><td>202.96.128.86</td><td>202.96.128.166</td></tr><tr><td></td><td>202.96.128.68</td><td>202.96.134.33</td></tr><tr><td><strong>广西电信 DNS</strong></td><td>202.103.225.68</td><td>202.103.224.68</td></tr><tr><td><strong>贵州电信 DNS</strong></td><td>202.98.192.67</td><td>202.98.198.167</td></tr><tr><td><strong>河南电信 DNS</strong></td><td>222.88.88.88</td><td>222.85.85.85</td></tr><tr><td><strong>黑龙江电信</strong></td><td>219.147.198.230</td><td>219.147.198.242</td></tr><tr><td><strong>湖北电信 DNS</strong></td><td>202.103.24.68</td><td>202.103.0.68</td></tr><tr><td><strong>湖南电信 DNS</strong></td><td>222.246.129.80</td><td>59.51.78.211</td></tr><tr><td><strong>江苏电信 DNS</strong></td><td>218.2.2.2</td><td>218.4.4.4</td></tr><tr><td></td><td>218.2.135.1</td><td>61.147.37.1</td></tr><tr><td><strong>江西电信 DNS</strong></td><td>202.101.224.69</td><td>202.101.226.68</td></tr><tr><td><strong>内蒙古电信</strong></td><td>219.148.162.31</td><td>222.74.39.50</td></tr><tr><td><strong>山东电信 DNS</strong></td><td>219.146.1.66</td><td>219.147.1.66</td></tr><tr><td><strong>陕西电信 DNS</strong></td><td>218.30.19.40</td><td>61.134.1.4</td></tr><tr><td><strong>上海电信 DNS</strong></td><td>202.96.209.133</td><td>116.228.111.118</td></tr><tr><td></td><td>108.168.255.118</td><td>202.96.209.5</td></tr><tr><td><strong>四川电信 DNS</strong></td><td>61.139.2.69</td><td>218.6.200.139</td></tr><tr><td><strong>天津电信 DNS</strong></td><td>219.150.32.132</td><td>219.146.0.132</td></tr><tr><td><strong>云南电信 DNS</strong></td><td>222.172.200.68</td><td>61.166.150.123</td></tr><tr><td><strong>浙江电信 DNS</strong></td><td>202.101.172.35</td><td>61.153.177.196</td></tr><tr><td></td><td>60.191.244.5</td><td>61.153.81.75</td></tr></tbody></table><h3><span id="4-联通-dns-服务器列表">4. 联通 DNS 服务器列表</span></h3><table><thead><tr><th>名称</th><th>DNS 服务器 IP 地址</th><th></th></tr></thead><tbody><tr><td><strong>北京联通 DNS</strong></td><td>123.123.123.123</td><td>123.123.123.124</td></tr><tr><td></td><td>202.106.195.68</td><td>202.106.0.20</td></tr><tr><td><strong>重庆联通 DNS</strong></td><td>221.5.203.98</td><td>221.7.92.98</td></tr><tr><td><strong>广东联通 DNS</strong></td><td>210.21.196.6</td><td>221.5.88.88</td></tr><tr><td><strong>河北联通 DNS</strong></td><td>202.99.160.68</td><td>202.99.166.4</td></tr><tr><td><strong>河南联通 DNS</strong></td><td>202.102.224.68</td><td>202.102.227.68</td></tr><tr><td><strong>黑龙江联通DNS</strong></td><td>202.97.224.69</td><td>202.97.224.68</td></tr><tr><td><strong>吉林联通 DNS</strong></td><td>202.98.0.68</td><td>202.98.5.68</td></tr><tr><td><strong>江苏联通 DNS</strong></td><td>221.6.4.66</td><td>221.6.4.67</td></tr><tr><td><strong>内蒙古联通 DNS</strong></td><td>202.99.224.68</td><td>202.99.224.8</td></tr><tr><td><strong>山东联通 DNS</strong></td><td>202.102.128.68</td><td>202.102.152.3</td></tr><tr><td></td><td>202.102.154.3</td><td>202.102.134.68</td></tr><tr><td><strong>山西联通 DNS</strong></td><td>202.99.192.66</td><td>202.99.192.68</td></tr><tr><td><strong>陕西联通 DNS</strong></td><td>221.11.1.67</td><td>221.11.1.68</td></tr><tr><td><strong>上海联通 DNS</strong></td><td>210.22.70.3</td><td>210.22.84.3</td></tr><tr><td><strong>四川联通 DNS</strong></td><td>119.6.6.6</td><td>124.161.87.155</td></tr><tr><td><strong>天津联通 DNS</strong></td><td>202.99.104.68</td><td>202.99.96.68</td></tr><tr><td><strong>浙江联通 DNS</strong></td><td>221.12.1.227</td><td>221.12.33.227</td></tr><tr><td><strong>辽宁联通 DNS</strong></td><td>202.96.69.38</td><td>202.96.64.68</td></tr></tbody></table><h3><span id="5-移动-dns-服务器列表">5. 移动 DNS 服务器列表</span></h3><table><thead><tr><th>名称</th><th>DNS 服务器 IP 地址</th><th></th></tr></thead><tbody><tr><td><strong>江苏移动 DNS</strong></td><td>221.131.143.69</td><td>112.4.0.55</td></tr><tr><td><strong>安徽移动 DNS</strong></td><td>211.138.180.2</td><td>211.138.180.3</td></tr><tr><td><strong>山东移动 DNS</strong></td><td>218.201.96.130</td><td>211.137.191.26</td></tr><tr><td><strong>四川移动 DNS</strong></td><td>223.87.238.22</td><td></td></tr></tbody></table><blockquote><p>本文转载自：「再从头的博客 」，原文：<a href="https://url.hi-linux.com/pWijO" target="_blank" rel="noopener">https://url.hi-linux.com/pWijO</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国内外公共 DNS，加密 DNS 汇总，可用作各种 DNS 服务器的上游服务器，在下面的列表中 &lt;strong&gt;选择 2-3 个为宜&lt;/strong&gt;。选得多并不是最优解，望周知。&lt;/p&gt;
&lt;p&gt;作为上游服务器列表时，因为 UDP 传输时间短，公共 DNS 统一选择 &lt;code&gt;udp&lt;/code&gt;，而&lt;strong&gt;加密 DNS&lt;/strong&gt; 统一选择：&lt;code&gt;https&lt;/code&gt;，当然&lt;code&gt;tls&lt;/code&gt;也可以。&lt;/p&gt;
&lt;h2 id=&quot;国内-DNS-列表&quot;&gt;国内 DNS 列表:&lt;/h2&gt;
&lt;h3 id=&quot;1-国内公共-DNS-列表&quot;&gt;1. 国内公共 DNS 列表&lt;/h3&gt;
&lt;h4 id=&quot;阿里公共-DNS：&quot;&gt;阿里公共 DNS：&lt;/h4&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;223.5.5.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;223.6.6.6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;腾讯公共-DNS&quot;&gt;腾讯公共 DNS:&lt;/h4&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;119.29.29.29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>一篇超级实用的裁员劳动仲裁指南</title>
    <link href="https://www.hi-linux.com/posts/60168.html"/>
    <id>https://www.hi-linux.com/posts/60168.html</id>
    <published>2023-12-12T01:00:00.000Z</published>
    <updated>2023-12-11T08:49:19.501Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>其实本来另一篇文章已经写好了，但考虑到临近年底，劳动仲裁指南的实用性可能会更大，于是便有了这篇文章。作为劳动仲裁曾经的亲历者，reizhi 希望能够借这篇文章把劳动仲裁这件事给说明白。虽然希望各位都用不上，但多了解一些总是好的。</p><p>在劳动合同签立的过程中，用人单位往往处于极其强势的地位。对应的，劳动者毫无疑问属于弱势的一方。在双方就劳动合同的履行产生争议时，依靠友好协商有时并不能达成让人满意的结果，于是便有了劳动争议仲裁委员会。无论劳动者是否有与用人单位进行协商，只要产生劳动争议，均可以提交劳动仲裁申请。本文接下来将专注于因裁员导致产生劳动仲裁的情形。</p><a id="more"></a><h2><span id="1公司可以合法解除劳动合同的情形">1.公司可以合法解除劳动合同的情形</span></h2><p>除开试用期外，以下情形公司可以单方面解除劳动合同，不需要支付补偿金或者赔偿金（过失类）：</p><ol><li>劳动者严重违反用人单位的规章制度</li><li>劳动者严重失职，营私舞弊，给用人单位造成重大损害</li><li>劳动者同时与其他用人单位建立劳动关系，对完成本单位的工作任务造成严重影响，或者经用人单位提出，拒不改正</li><li>具有以欺诈、胁迫的手段或者乘人之危，使对方在违背真实意思的情况下订立或者变更劳动合同的情形致使劳动合同无效</li><li>劳动者被依法追究刑事责任</li></ol><p>以上这些情形相信大家应该不太能够遇到，同时如果提出过失类解除需要用人单位进行举证，这里便不展开介绍了。</p><h2><span id="2公司需要支付补偿金才能解除劳动合同的情形">2.公司需要支付补偿金才能解除劳动合同的情形</span></h2><p>以下这些情形是大家常说的 N 或者 N+1 补偿的情形：</p><ol><li>双方协商一致，解除劳动合同（由公司提出）</li><li>劳动者患病或者非因工负伤，医疗期满后，不能从事原工作也不能从事由用人单位另行安排的工作</li><li>劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作</li><li>劳动合同订立时所依据的客观情况发生重大变化，致使原劳动合同无法履行，经当事人协商不能就变更劳动合同达成协议</li><li>用人单位濒临破产进行法定整顿期间或者生产经营状况发生严重困难，确需裁减人员的，应当提前三十日向工会或者全体职工说明情况，听取工会或者职工的意见，经向劳动行政部门报告后，可以裁减人员</li></ol><p>其中，适用第二、三、四条进行劳动关系解除时，用人单位需要提前30日书面告知劳动者，否则需要支付额外的一个月工资，即 N+1 。其他情形需要支付 N 补偿，具体如何计算后面还会讲到。</p><p>看到这里可能有人已经开始打退堂鼓了，是否只要公司提出劳动者不能胜任工作，并以绩效完成情况作为证明就能适用 N 或 N+1 辞退呢？其实并不是，如果需要适用第三条的不能胜任工作，公司需要首先进行培训或者调整工作岗位，且能够提供对应的证明材料。其次公司需要提供的证明材料较多，包括：首次不能胜任的相关证明，进行了合理的培训或者调整岗位的证明，再次不能胜任的相关证明。</p><p>故虽然此点可能作为人事的托词，但实际举证难度较大，且绩效考核标准的订立可操作空间大，在实际仲裁乃至诉讼过程中，用人单位被判定为不利的概率极高。一旦此点认定失败，将直接被认定为非法解除劳动合同，从而致使补偿金 N+1 升级为赔偿金 2N 。</p><p>其中的第四条客观情况发生重大变化，也比较喜欢被某些人事加以利用。需要明确的是此点包含两条重要约束，即客观和重大变化。即变化所产生的原因并非用人单位所能主观决定和控制，而非单纯的因为组织架构调整就能够引用此条予以辞退。另外，在解除劳动合同前也需要与劳动者进行协商，提供相近或类似的工作岗位，并且待遇不能低于原岗位。在劳动者拒绝的情况下，才能适用本条。</p><p>最后，对于调岗的情形，需明确调岗后的职级、工作内容与原岗位相近，且待遇不低于原岗位，新岗位不存在任何歧视性、侮辱性。用人单位行使法定调岗权，应对调岗的合理依据承担举证责任。</p><h2><span id="3违法解除劳动合同的情形">3.违法解除劳动合同的情形</span></h2><p>所有不适用以上情形的情况，由公司提出解除劳动合同的情形，均属于违法解除。如果公司方面主张因为以上情形解除劳动关系，则需要由公司进行举证。在公司无法拿出充分证据予以证明的情况下，同样会被认定为违法解除。</p><p>所有的违法解除劳动合同的情形，赔偿金为 2N 。</p><h2><span id="4补偿金或赔偿金如何计算">4.补偿金或赔偿金如何计算</span></h2><p>补偿金 = 在职年限（N）x 工资基数</p><p>赔偿金 = 2 x 在职年限（N）x 工资基数</p><p>无论是第二节中提到的补偿金，还是第三节中提到的赔偿金，其金额基数均为劳动合同解除或者终止前十二个月的平均工资，含奖金、津贴和补贴。如工作不满十二个月，按照实际工作的月数计算平均工资。</p><p>其中的在职年限，除去整年部分后，满六个月以上的计一年，不满六个月的计半年。例：一年三个月按照1.5年计算，两年十个月按照3年计算。</p><p>对于第二节中有提到需提前30日书面告知劳动者的情形，如有进行告知则无需再额外补偿一个月工资。如未告知则需补偿 N+1 。</p><p>综上，对于法定范围内的补偿金或赔偿金，仅有：N, N+1, 2N 三种情形。在递交劳动仲裁申请时，务必按照对应的情形计算可能的最大补偿（或赔偿）金额。具体金额在仲裁审理时会进行重新计算，但不会超过仲裁申请时所提交的金额。</p><h2><span id="5申请劳动仲裁需要提交哪些材料">5.申请劳动仲裁需要提交哪些材料</span></h2><p>如果我们已经确定要提交劳动仲裁申请，必然要先知道所需材料。各地对于劳动仲裁申请所需的材料略有出入，但大体上包含以下这些：</p><ul><li>身份证复印件</li><li>工作证明复印件（如劳动合同）</li><li>离职证明</li><li>公司工商信息</li><li>劳动仲裁申请表</li><li>相关证明材料</li><li>工资条，工资流水</li></ul><p>具体的要求可以在网上搜索当地地名加劳动仲裁，或直接前往劳动仲裁庭咨询了解。其中的公司工商信息可在当地的“企业信用信息公示系统”网站按照企业名称搜索并打印即可，劳动仲裁申请表一般在当地政府政务网站或仲裁机构的网站上可以下载。</p><p>对于裁员请求经济补偿或赔偿的情况，离职证明属于必要材料，需由公司开具。如公司推脱或者拒绝开具，一般可以向当地劳动监察大队举报。</p><p>劳动仲裁申请的部分，可参照参考信息中的链接二，也可以在网上搜索当地地名加劳动仲裁指南。</p><p>多数情况下工作证明即劳动合同，如未有签订劳动合同也可以提交其他证明材料如社保缴纳记录，工资条，打卡考勤记录等。</p><p>其他可能用得上的证明材料如：培训记录、调岗记录、绩效考核标准、绩效考核邮件、其他内部邮件、沟通记录截图等均可以提交。</p><h2><span id="6后续流程">6.后续流程</span></h2><p>在材料递交后，仲裁庭首先会告知是否受理，以及受理后的开庭时间。劳动者本人只需按时出庭即可，用人单位是否出席不影响裁定。这里我并没有实操经验，但大家只需要据实应对，争取合法权益即可。正因为我们之前一直有提到劳动者在合同关系中处于弱势方，仲裁庭基本上还是会尽量出于维护劳动者权益的角度进行裁定。</p><p>另外一方面，在劳动仲裁中用人单位方掌握并且控制了大量的信息，所以相关法条也有进行规定：与争议事项有关的证据属于用人单位掌握管理的，用人单位应当提供；用人单位不提供的，应当承担不利后果。</p><p>既然大家已经选择了进行劳动仲裁，就应该充分信任仲裁庭能够给予公正客观的裁定结果。毕竟设立劳动仲裁庭的目的就是为了保护劳动者的合法权益，总不会有哪个用人单位去申请仲裁吧？</p><p>裁定结果出来后，如果对于我们的主张诉求予以支持，直接找公司要钱即可。如公司拒绝，在超过限定时间后可以向法院申请强制执行。这些后续细节裁定书中应该会有说明，不用太担心。</p><p>任意一方对于裁定结果不服，都可以提起诉讼。涉及到打官司已经超出本文的科普范围了，建议咨询律师。</p><p>在实际操作过程中可能存在仲裁开庭前公司注销的情况发生，reizhi 对此类问题没有操作经验，同样建议咨询律师，有可能需要通过诉讼解决。</p><h2><span id="7协商">7.协商</span></h2><p>上面这些信息对于人事来说都是必知必会，但对方有可能利用信息差在协商中占据优势。在我们了解全部的相关知识后，便可以从容的与人事展开协商谈判了。如果你已经做好了劳动仲裁的决心，以下是一些常见托词的应对逻辑：</p><p><strong>无法胜任</strong>：需由公司举证，且举证难度大；需先调岗或培训；绩效考核存在主观性，可操作空间大，置信度低</p><p><strong>客观情况发生重大变化</strong>：需要是客观的不可抗力；重大变化足以影响公司经营或合同执行；需提供调岗机会</p><p><strong>时间周期长，结果不确定</strong>：仲裁庭的本质是劳动者保护组织；公司举证责任多、难度大；劳动仲裁记录在企查查等网站均可查到，无论结果对于公司都没有好处</p><p>如果公司方已经斩钉截铁的表示无法给到应有的标准，但可以适当降低进行补偿，则是否接受需要取决于自身。</p><h2><span id="8参考信息">8.参考信息</span></h2><blockquote><p><a href="https://www.gov.cn/banshi/2005-05/25/content_905.htm" target="_blank" rel="noopener">https://www.gov.cn/banshi/2005-05/25/content_905.htm</a></p><p><a href="https://www.moj.gov.cn/pub/sfbgw/jgsz/jgszzsdw/zsdwflyzzx/flyzzxgzpt/gzptwlpx/202007/t20200702_190436.html" target="_blank" rel="noopener">https://www.moj.gov.cn/pub/sfbgw/jgsz/jgszzsdw/zsdwflyzzx/flyzzxgzpt/gzptwlpx/202007/t20200702_190436.html</a></p><p><a href="https://rlsbt.zj.gov.cn/art/2020/11/19/art_1450623_58919888.html" target="_blank" rel="noopener">https://rlsbt.zj.gov.cn/art/2020/11/19/art_1450623_58919888.html</a></p><p><a href="https://www.dehenglaw.com/CN/tansuocontent/0008/029228/7.aspx?AID=&amp;BID=00000000000000001988&amp;MID=0902" target="_blank" rel="noopener">https://www.dehenglaw.com/CN/tansuocontent/0008/029228/7.aspx?AID=&amp;BID=00000000000000001988&amp;MID=0902</a></p><p><a href="https://www.yiyang.gov.cn/rsj/4509/4516/5735/content_305410.html" target="_blank" rel="noopener">https://www.yiyang.gov.cn/rsj/4509/4516/5735/content_305410.html</a></p><p><a href="https://gchzfy.hncourt.gov.cn/public/detail.php?id=3294" target="_blank" rel="noopener">https://gchzfy.hncourt.gov.cn/public/detail.php?id=3294</a></p><p><a href="https://www.gov.cn/flfg/2007-12/29/content_847310.htm" target="_blank" rel="noopener">https://www.gov.cn/flfg/2007-12/29/content_847310.htm</a></p></blockquote><blockquote><p>本文转载自：「 reizhi 的博客 」，原文：<a href="https://url.hi-linux.com/KXvBv" target="_blank" rel="noopener">https://url.hi-linux.com/KXvBv</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实本来另一篇文章已经写好了，但考虑到临近年底，劳动仲裁指南的实用性可能会更大，于是便有了这篇文章。作为劳动仲裁曾经的亲历者，reizhi 希望能够借这篇文章把劳动仲裁这件事给说明白。虽然希望各位都用不上，但多了解一些总是好的。&lt;/p&gt;
&lt;p&gt;在劳动合同签立的过程中，用人单位往往处于极其强势的地位。对应的，劳动者毫无疑问属于弱势的一方。在双方就劳动合同的履行产生争议时，依靠友好协商有时并不能达成让人满意的结果，于是便有了劳动争议仲裁委员会。无论劳动者是否有与用人单位进行协商，只要产生劳动争议，均可以提交劳动仲裁申请。本文接下来将专注于因裁员导致产生劳动仲裁的情形。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="职场" scheme="https://www.hi-linux.com/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>一份超实用的 Nginx Location 配置详解</title>
    <link href="https://www.hi-linux.com/posts/51752.html"/>
    <id>https://www.hi-linux.com/posts/51752.html</id>
    <published>2023-12-11T01:00:00.000Z</published>
    <updated>2023-12-11T03:42:28.101Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="前言">前言</span></h2><p>Location 是 Nginx 中一个非常核心的配置，这篇重点讲解一下 Location 的配置问题以及一些注意事项。</p><h2><span id="语法">语法</span></h2><p>关于 Location，举个简单的配置例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123; </span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">      <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.yayujs.com;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">          <span class="attribute">root</span> /home/www/ts/;</span><br><span class="line">          <span class="attribute">index</span> index.html;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>大致的意思是，当你访问 <code>www.yayujs.com</code> 的 <code>80</code> 端口的时候，返回 <code>/home/www/ts/index.html</code> 文件。</p><p>我们看下 Location 的具体语法：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">[ = | ~ | ~* | ^~ ] uri</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>重点看方括号中的 <code>[ = | ~ | ~* | ^~ ]</code>，其中 <code>|</code> 分隔的内容表示你可能会用到的语法，其中：</p><ul><li><code>=</code> 表示精确匹配，比如：</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">= /test</span> &#123;</span><br><span class="line">  return <span class="number">200</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /test ok</span></span><br><span class="line"><span class="comment"># /test/ not ok</span></span><br><span class="line"><span class="comment"># /test2 not ok</span></span><br><span class="line"><span class="comment"># /test/2 not ok</span></span><br></pre></td></tr></table></figure><ul><li><code>~</code> 表示区分大小写的正则匹配，比如：</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">~ ^/test</span>$ &#123;</span><br><span class="line">  [ configuration ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /test ok</span></span><br><span class="line"><span class="comment"># /Test not ok</span></span><br><span class="line"><span class="comment"># /test/ not ok</span></span><br><span class="line"><span class="comment"># /test2 not ok</span></span><br></pre></td></tr></table></figure><ul><li><code>~*</code> 表示不区分大小写的正则匹配</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">~* ^/test</span>$ &#123;     </span><br><span class="line">    [ configuration ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /test ok</span></span><br><span class="line"><span class="comment"># /Test ok</span></span><br><span class="line"><span class="comment"># /test/ not ok</span></span><br><span class="line"><span class="comment"># /test2 not ok</span></span><br></pre></td></tr></table></figure><ul><li><code>^~</code> 表示 uri 以某个字符串开头</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">^~ /images</span>/ &#123;    </span><br><span class="line">    [ configuration ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /images/1.gif ok</span></span><br></pre></td></tr></table></figure><p>而当你不使用这些语法的时候，只写 uri 的时候：</p><p><code>/</code> 表示通用匹配：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">/ &#123;     </span></span><br><span class="line"><span class="title">    [ configuration</span> ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /index.html ok</span></span><br><span class="line"><span class="keyword">location</span> <span class="title">/test</span> &#123;</span><br><span class="line">    [ configuration ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># /test ok</span></span><br><span class="line"><span class="comment"># /test2 ok</span></span><br><span class="line"><span class="comment"># /test/ ok</span></span><br></pre></td></tr></table></figure><h2><span id="匹配顺序">匹配顺序</span></h2><p>当存在多个 location 的时候，他们的匹配顺序引用 <a href="https://link.segmentfault.com/?enc=sah%2Br0st4OoDSH53K0i1lA%3D%3D.IeNU1hnVBfLtvwt4TWcSRag6FLaayC8NDRbkNSiZVvpwANmQuEigx0kLfgTlKJhRuaFlCOH38WFatOeN8H0E4t0rzJimS%2BW8CHUTzh5P%2B7s%3D" target="_blank" rel="noopener">Nginx 官方文档</a>就是：</p><blockquote><p>A location can either be defined by a prefix string, or by a regular expression. Regular expressions are specified with the preceding “~*” modifier (for case-insensitive matching), or the “~” modifier (for case-sensitive matching). To find location matching a given request, nginx first checks locations defined using the prefix strings (prefix locations). Among them, the location with the longest matching prefix is selected and remembered. Then regular expressions are checked, in the order of their appearance in the configuration file. The search of regular expressions terminates on the first match, and the corresponding configuration is used. If no match with a regular expression is found then the configuration of the prefix location remembered earlier is used.</p><p>If the longest matching prefix location has the “^~” modifier then regular expressions are not checked.</p><p>Also, using the “=” modifier it is possible to define an exact match of URI and location. If an exact match is found, the search terminates. For example, if a “/” request happens frequently, defining “location = /” will speed up the processing of these requests, as search terminates right after the first comparison. Such a location cannot obviously contain nested locations.</p></blockquote><p>翻译整理后就是：</p><p>location 的定义分为两种：</p><ul><li>前缀字符串（prefix string）</li><li>正则表达式（regular expression），具体为前面带 <code>~*</code> 和 <code>~</code> 修饰符的</li></ul><p>而匹配 location 的顺序为：</p><ol><li>检查使用前缀字符串的 locations，在使用前缀字符串的 locations 中选择最长匹配的，并将结果进行储存</li><li>如果符合带有 <code>=</code> 修饰符的 URI，则立刻停止匹配</li><li>如果符合带有 <code>^~</code> 修饰符的 URI，则也立刻停止匹配。</li><li>然后按照定义文件的顺序，检查正则表达式，匹配到就停止</li><li>当正则表达式匹配不到的时候，使用之前储存的前缀字符串</li></ol><p>再总结一下就是：</p><p>在顺序上，前缀字符串顺序不重要，按照匹配长度来确定，正则表达式则按照定义顺序。</p><p>在优先级上，<code>=</code> 修饰符最高，<code>^~</code> 次之，再者是正则，最后是前缀字符串匹配。</p><p>我们举几个简单的例子复习下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location &#x2F;doc &#123;</span><br><span class="line">        [ configuration A ] </span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F;docu &#123;</span><br><span class="line">        [ configuration B ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 请求 &#x2F;document 使用 configuration B</span><br><span class="line"># 虽然 &#x2F;doc 也能匹配到，但在顺序上，前缀字符串顺序不重要，按照匹配长度来确定</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location ~ ^&#x2F;doc &#123;</span><br><span class="line">        [ configuration A ] </span><br><span class="line">    &#125;</span><br><span class="line">    location ~ ^&#x2F;docu &#123;</span><br><span class="line">        [ configuration B ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 请求 &#x2F;document 使用 configuration A</span><br><span class="line"># 虽然 ~ ^&#x2F;docu 也能匹配到，但正则表达式则按照定义顺序</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location ^~ &#x2F;doc &#123;</span><br><span class="line">        [ configuration A ] </span><br><span class="line">    &#125;</span><br><span class="line">    location ~ ^&#x2F;docu &#123;</span><br><span class="line">        [ configuration B ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 请求 &#x2F;document 使用 configuration A</span><br><span class="line"># 虽然 ~ ^&#x2F;docu 也能匹配到，但 ^~ 的优先级更高</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location &#x2F;document &#123;</span><br><span class="line">        [ configuration A ] </span><br><span class="line">    &#125;</span><br><span class="line">    location ~ ^&#x2F;docu &#123;</span><br><span class="line">        [ configuration B ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 请求 &#x2F;document 使用 configuration B</span><br><span class="line"># 虽然 &#x2F;document 也能匹配到，但正则的优先级更高</span><br></pre></td></tr></table></figure><h2><span id="root-与-alias-的区别">root 与 alias 的区别</span></h2><p>当我们这样设置 <code>root</code> 的时候：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location <span class="regexp">/i/</span> &#123;</span><br><span class="line">    root <span class="regexp">/data/</span>w3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求 <code>/i/top.gif</code> ，<code>/data/w3/i/top.gif</code> 会被返回。</p><p>当我们这样设置 <code>alias</code> 的时候：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location <span class="regexp">/i/</span> &#123;</span><br><span class="line">    alias <span class="regexp">/data/</span>w3<span class="regexp">/images/</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求 <code>/i/top.gif</code> ，<code>/data/w3/images/top.gif</code> 会被返回。</p><p>乍一看两者很像，但细一看，就能看出两者的区别，root 是直接拼接 <code>root</code> + <code>location</code> 而 alias 是用 <code>alias</code> 替换 <code>location</code>，所以 root 中最后的路径里有 <code>/i/</code>，而 alias 中最后的路径里没有 <code>/i/</code> 。</p><p>所以如果你这样使用 allias 定义一个路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location <span class="regexp">/images/</span> &#123;</span><br><span class="line">    alias <span class="regexp">/data/</span>w3<span class="regexp">/images/</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实使用 root 会更好：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location <span class="regexp">/images/</span> &#123;</span><br><span class="line">    root <span class="regexp">/data/</span>w3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="server-和-location-中的-root">server 和 location 中的 root</span></h2><p>server 和 location 中都可以使用 root，举个例子：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http &#123; </span><br><span class="line">  server &#123;</span><br><span class="line">      listen <span class="number">80</span>;</span><br><span class="line">        server_name www.yayujs.com;</span><br><span class="line">        root <span class="regexp">/home/</span>www<span class="regexp">/website/</span>;</span><br><span class="line">        location <span class="regexp">/ &#123;</span></span><br><span class="line"><span class="regexp">          root /</span>home<span class="regexp">/www/</span>ts<span class="regexp">/;</span></span><br><span class="line"><span class="regexp">          index index.html;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>如果两者都出现，是怎样的优先级呢？</p><p>简单的来说，就是就近原则，如果 location 中能匹配到，就是用 location 中的 root 配置，忽略 server 中的 root，当 location 中匹配不到的时候，则使用 server 中的 root 配置。</p><blockquote><p>本文转载自：「 冴羽的JavaScript博客 」，原文：<a href="https://url.hi-linux.com/e0P8z" target="_blank" rel="noopener">https://url.hi-linux.com/e0P8z</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Location 是 Nginx 中一个非常核心的配置，这篇重点讲解一下 Location 的配置问题以及一些注意事项。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;语法&lt;/h2&gt;
&lt;p&gt;关于 Location，举个简单的配置例子：&lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;http&lt;/span&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;section&quot;&gt;server&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attribute&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;server_name&lt;/span&gt; www.yayujs.com;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;location&lt;/span&gt; / &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;root&lt;/span&gt; /home/www/ts/;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;index&lt;/span&gt; index.html;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>一文带你搞懂旁路由的原理与配置</title>
    <link href="https://www.hi-linux.com/posts/38236.html"/>
    <id>https://www.hi-linux.com/posts/38236.html</id>
    <published>2023-10-17T01:00:00.000Z</published>
    <updated>2023-10-17T09:28:18.953Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最早听到旁路由这个词是在 2020 年折腾 N1 的时候，这台单网口的小盒子只能用网上所说的旁路由方案接入局域网来实现期望的功能。现在回想起来，旁路由这个词有可能就是在那个发烧友大量折腾斐讯 N1/P1/T1 的时期被发明出来的。</p><p>你没办法在发烧友圈子外的互联网及各种学术材料中找到对旁路由的描述和定义，当然也找不到合适的英文翻译（导致这篇文章的 slug 定义困难）；从拓扑上看，旁路由更像是杂糅了二级路由和透明网关的概念，除了实体确实多接了根网线放在主路由旁边，其本身并没有真正地开启一条旁路，做的事情也基本可以和网关的定义对齐。</p><p>不过，由于这个说法主要集中于网友的交流讨论之中，而且几年来在有相关需求的广大用户中被广为接受，所以只要这个词不变为一个学术概念，那我倒也不觉得有什么不妥。下文也仍然会用「旁路由」一词来指代在此类拓扑结构中担任代理网关角色的路由器。</p><p>此外，本文对于原理的解释偏多且为新手向，对于已经熟知相关概念的读者则可以将本文作为 cheat sheet 食用。</p><a id="more"></a><h2><span id="旁路由的适用场景">旁路由的适用场景</span></h2><p>有人认为旁路由的加入（手动指定方式）不会在其出现问题时影响整个网络的可用性，所以应该把非路由功能都交给旁路由来实现。但实际上如果仅仅是为了达成这个目标，那在主路由上直接分流会是个更好的方案，因为这样不仅会大量减少疑难杂症的出现，而且还可以通过设置 fallback 的方式进一步提升网络的可用性。</p><p>所以我认为旁路由实际上只适用于一个场景，那就是出于某种考虑，主路由不能被替换或被大量修改，而主路由的固件又不能满足功能诉求，这时候旁路由便是一个可选的解决方案。</p><h2><span id="旁路由的原理">旁路由的原理</span></h2><p>网上关于旁路由的配置教程多如牛毛，其中大部分是基于 F 大的 N1 OpenWrt 固件使用教程来写的，也有很多是结合了自己的踩坑经验的细化版本。由于版本太多、完整的说明太少，而且大部分没有讲清楚教程的环境上下文和原理，导致按照这些教程来配置的用户往往不得不一遍遍地折腾重试，甚至会遇到逐步配置最终却断网、访问不了部分网站等令人头疼的问题。</p><p>授之以鱼不如授之以渔，为了能彻底讲清楚旁路由该如何配置，我们暂且不谈具体步骤，而是先搞明白旁路由的运作原理。</p><h3><span id="名词解释">名词解释</span></h3><p>由于计算机网络的术语在不同时期、不同环境下，对于细节的含义其实有比较大的差异，故首先我们先定义好下文中将使用到的各类专有名词的含义，以免出现信息不对称的情况。同时为了方便理解，我们也尽量和 OpenWrt 的名词对齐，并尝试与现实生活场景进行类比。</p><ol><li><strong>路由</strong>：将数据从源地址传输到目的地址的行为。可以看出，这个行为抽象涵盖了两个动作，一是找到地址、二是转发数据。可以类比为网购时快递公司将商品从卖家发送给买家的过程。</li><li><strong>路由表</strong>：可以简单理解为路由过程中的地址关联信息的合集，也就是现实中发货地址和收货地址的映射关系。</li><li><strong>路由器</strong>：本文中指家用的、具备路由功能的实体网络设备，其本身并不一定需要真的承担或只承担路由功能，可以抽象理解为就是一台普通的电脑或服务器。当然，它也可以是一个容器实例、一个虚拟机。对应到现实中就是快递公司。</li><li><strong>接口</strong>：这里特指网络接口，指两个网络设备或协议层的连接点。现实中连接路由器时，wan/lan 不同的网线插槽其实就可以理解为接口。只不过接口并不一定是物理实体，所以我们才会在 OpenWrt 的接口设置里看到甚至新增许多物理设备上所没有的接口。</li><li><strong>网关</strong>：这里特指网络中的网关，负责执行数据转发的某个抽象设备。这里可能容易与路由器的功能混淆，毕竟路由器如果用来做路由似乎也是在做转发的工作。实际上这是由于术语的历史使用缺少规范导致的边界不够清晰，可以粗略理解为承担路由功能的路由器就是网关，但网关不一定是只能由路由器担任。</li><li><strong>IP</strong>：本身指 IP 协议，本文为方便也可能将其作为 IP 地址的简称，且默认为 IPv4 。本节所有的名词其实都是基于 IP 协议运作的，而 IP 地址即上文各类「地址」的实际值。可以理解为你用于发送和接收快递的门牌号。</li><li><strong>DHCP</strong>：IP 地址的管理和分配协议，本文中不单单指协议本身，还指负责执行该协议的设备。可以理解为给你分配门牌号的物业，只不过这个门牌号是动态变化的。</li><li><strong>DNS</strong>：上文说到数据的传输需要源地址和目的地址，而这个地址就是 IP 地址。但由于 IP 地址难以记忆，所以才会有了可以作为 IP 地址别名的域名，而 DNS 就是负责进行域名和 IP 地址映射转换的系统。本文中 DNS 也指代负责运行该系统的设备。</li><li><strong>NAT</strong>：出于各种考虑，局域网与因特网的 IP 地址是隔离的，NAT 可以理解为内外网 IP 地址转换的流程。类比网购，相当于快递公司把快递送到附近快递站，快递站的快递员再把货物送到你家门口的流程。</li><li><strong>SNAT</strong>：NAT 的一种，本质上是在修改网络包的源地址，目的是可以强制网络包返回时经过期望的地址。可以理解为支付宝的作用，即钱虽然表面上是点对点转账的，但经过支付宝后，支付宝就要求相关转账信息的回执必须由它中转一次再告知转账发起人。</li></ol><h3><span id="网络拓扑">网络拓扑</span></h3><p><img src="https://img.hi-linux.com/staticfile/ee0724cd54a8e17f32a0971e2f4969fc-20231017155659529-2023-10-17-FjrDYN.png" alt="旁路由架构的网络拓扑图"></p><p>可以看到，无论如何配置，我们都需要保证数据按图中的拓扑进行流转，才能实现我们所希望的只在旁路由增加功能而不修改主路由的目的。由于流量（至少上行流量）总会流经旁路由，所以旁路由实质上就是一层透明代理。</p><h3><span id="工作原理">工作原理</span></h3><p>那么我们该怎么实现这样的网络拓扑呢？让我们先来看下数据在网络的更底层是如何流转的。</p><p><img src="https://img.hi-linux.com/staticfile/d247c8b3d92cd3990245b622d5e7aa56-2023-10-17-axxUVL.png" alt="旁路由架构的数据流转示意图"></p><p>从图中可以看到，当我们从手机等终端设备发出一个数据包时，数据包总是由我们的终端设备经由网关路由至目的地址，目的地址返回数据时也是相同的路径。这是因为终端设备本身通常是不具备路由功能的，单单一个路由表终端设备就搞不定。</p><p>既然数据必然经过网关，那么我们只要强制把旁路由作为终端设备对外数据交互的第一层网关即可。至此旁路由的工作原理其实就已经解释清楚了，即在另一台路由器上实现的基于网关的透明代理。而网上各式各样的教程其实都是在教我们解决如何配置网关的问题。</p><p>在这一章节还需要说明的是为什么各个教程都要求我们把旁路由的 IP 配置在和主路由相同的 IP 网段。所谓的 IP 网段实际上就是子网，同一子网下的主机（设备）可以直接通信，跨子网则需要通过某种形式转换后才能通信，而这些转换虽然可行但比较复杂，在旁路由这个场景下显然是没有必要的。本着不改变原有网络拓扑的原则，旁路由自然也要配置在和主路由及其他设备相同的子网才行。</p><h2><span id="旁路由的配置">旁路由的配置</span></h2><p>那么我们该如何配置网关以让数据按上文的工作原理进行流转呢？</p><h3><span id="一旁路由的网关设置">（一）旁路由的网关设置</span></h3><p>首先我们先来解决旁路由的网关问题。在上文的拓扑图中我们可以看到，旁路由虽然挂着路由器的名字，但它本质上也是网络链路中的一个节点，因此它也需要请求上层网关才能完成数据流转。而主路由是这个网络拓扑的出口，所以旁路由的网关自然要配置为主路由的 IP 地址。这一项配置是必须且不会随终端网关配置方式的变化而改变的，无论如何指定网关请求旁路由，旁路由本身都要依赖此配置才能完成正常的流量转发。</p><p>此外，还有子网掩码需要进行配置。前面有提到，在同一子网内的主机之间才能直接通信，而 IP 和子网掩码相组合便能确定设备当前所在的子网。旁路由并不改变网络拓扑，所以需要和主路由在同一子网内。因此将旁路由的子网掩码配置设置为主路由的子网掩码即可。同理，下文的所有子网掩码配置也均需要与主路由的保持一致。</p><h3><span id="二旁路由的dhcp配置">（二）旁路由的DHCP配置</span></h3><p>虽然配置了网关后数据流转图中的左半边已经成型，但如果不对旁路由的 DHCP 进行配置，实际上会导致各种各样的疑难杂症或直接无法联网。</p><p>原因在于 DHCP 使用了 UDP 协议，UDP 是没有连接的，如果主路由和旁路由同时开启 DHCP，则任意一个 DHCP 服务器都可能会应答终端的申请，进而导致 IP 下发和路由表的混乱造成各种无法连接的疑难杂症。当然，我们可以将两个 DHCP 的子网网段拆分开来解决共存问题，但这个行为在旁路由场景下并没有实际意义。</p><p>因此我们需要保证网络中只有一个设备承担 DHCP 功能，出于不改变原网络拓扑和避免无意义 NAT 的考虑，我们通常选择关闭旁路由的 DHCP 功能（对应到 OpenWrt 则选择「忽略此接口」）。</p><h3><span id="三终端网关配置">（三）终端网关配置</span></h3><p>对于手机、电脑等终端，我们的目标是将其网关配置为旁路由的 IP 。实现方案很多，成本较低的主要为以下两种。</p><h4><span id="手动指定">手动指定</span></h4><p>顾名思义，只需要在终端设备的网络设置中将网关手动配置为旁路由即可。以 iOS 系统为例：</p><p><img src="https://img.hi-linux.com/staticfile/3f58fee3de6f48c714173df4f26aac2e-20231017155712142-2023-10-17-r8gGV8.jpg" alt="iOS 网络配置界面"></p><p>手动填写一个网络上未被占用的 IP 地址，而子网掩码以主路由为准，网关则填写旁路由的 IP 地址。</p><p>手动指定的好处在于完全不影响原网络的使用，设备按需配置是否使用旁路由作为网关以实现特定功能。当旁路由故障时，未手动指定的设备仍能正常上网。</p><p>缺点在于操作烦琐。手机、电脑还好，但电视或根本没有屏幕的设备设置起来就会很麻烦。</p><h4><span id="依赖dhcp指定">依赖DHCP指定</span></h4><p>DHCP 除了可以管理 IP 的分配，还会下发网关和 DNS 服务器信息，因此我们还可以借助 DHCP 的这一机制来为所有终端统一设置网关，而不再需要逐个手动修改。</p><p>前面提到，我们关闭了旁路由的 DHCP 功能，因此这个统一下发的工作就要交给主路由来完成。只需要在主路由的 DHCP 配置中将网关配置为旁路由的 IP 地址即可。</p><p><img src="https://img.hi-linux.com/staticfile/fc7f640460453d3eb1b6aa3d5c849c5c-2023-10-17-J0Xb4B.png" alt="OpenWrt 的 DHCP 配置界面"></p><p>以 OpenWrt 为例，将主路由 DHCP 下发的网关配置为旁路由 IP 地址即可（3 表示网关，6 表示 DNS 服务器地址）。</p><p>不过有些路由器的默认固件没有开放该配置项，对于这些设备，除非可以 SSH 连接后手动改配置，不然无法使用此种指定方式。</p><p>这种方式的好处显而易见，一次配置全家受用；缺点在于当旁路由出现故障时，所有连接的设备都会无法上网。</p><h3><span id="四dns的配置">（四）DNS的配置</span></h3><p>细心的读者可能发现了上文只提到了网关的配置，但未提到很多教程中的 DNS 配置。实际上单单就旁路由本身来说，网关配置完成后整个网络拓扑就已经搭建完毕了。但对于一些特定诉求，比如依赖旁路由进行统一的 DNS 劫持（很多功能的底层都依赖于此），则需要将对应位置的 DNS 也配置为旁路由的 IP 以将域名解析工作也完全交由旁路由处理。</p><h2><span id="配置步骤总结">配置步骤总结</span></h2><h3><span id="手动指定方案">手动指定方案</span></h3><ol><li>为旁路由配置和主路由同网段的静态 IP 地址，同时将旁路由的网关和 DNS 指向主路由，子网掩码与主路由保持一致。</li><li>旁路由关闭 DHCP 服务。</li><li>在主路由防火墙开启 SYN-flood 防御的情况下，关闭旁路由防火墙的 SYN-flood 防御（可选）。</li><li>在需要接入旁路由的终端设备中，将网关和 DNS 配置为旁路由 IP 地址，配置同网段的 IP 地址和与主路由相同的子网掩码。</li></ol><h3><span id="dhcp下发方案">DHCP下发方案</span></h3><ol><li>为旁路由配置和主路由同网段的静态 IP 地址，同时将旁路由的网关和 DNS 指向主路由，子网掩码与主路由保持一致。</li><li>旁路由关闭 DHCP 服务。</li><li>在主路由防火墙开启 SYN-flood 防御的情况下，关闭旁路由防火墙的 SYN-flood 防御（可选）。</li><li>在主路由的 DHCP 配置中，将其下发的网关和 DNS 配置为旁路由的 IP 地址。</li></ol><h2><span id="疑难杂症的解决">疑难杂症的解决</span></h2><p>虽然配置步骤看上去很简单，但很多人在实际使用中都会遇到逐步配置却上不了网或网络慢的问题，这里挑几个典型案例来解析。</p><h3><span id="一该不该设置iptables的masquerade">（一）该不该设置iptables的MASQUERADE</span></h3><p>这可能是争议最大的一条，有人说这条规则加上后影响性能而且没意义，但也有很多人表示不配这条就是连不上网（大多为连接不上国内网络）。</p><p>这条规则的作用本质上是在旁路由上做 SNAT，只不过修改的地址不需要指定而是动态获取旁路由对应接口网卡的 IP 地址，在 OpenWrt 里被称为「IP 伪装」。</p><p><img src="https://img.hi-linux.com/staticfile/2d0c6641e3f951044153129b3176ab66-20231017155721745-2023-10-17-FI1Wzy.png" alt="配置 MASQUERADE 后的数据流转示意图"></p><p>单从旁路由的网络拓扑来说，这条规则确实没意义，因为主路由作为对外出口必做 NAT，但旁路由本身就在局域网内且只是链路上的一环，没有必要再对内网 IP 进行耗费性能的 NAT 操作。</p><p>但不要忘了，理论和现实是两回事，物理网络拓扑中的不同设备、不同固件都有可能产生各种奇怪的兼容问题。我自己倒是没有遇到过该问题，但检索网友们的各种帖子，大概可以分为以下几种原因：</p><ol><li><strong>主路由固件数据包处理问题</strong>：部分路由器（似乎主要为国产品牌）的无线网在桥接和 iptables 处理过程中，当旁路由将国内流量重新转发回主路由时，主路由根据流中的首个数据包的状态做判断导致后续数据包未进行 NAT 就直接访问了互联网。<a href="https://blog.csdn.net/qq1337715208/article/details/122271608" target="_blank" rel="noopener">这篇文章</a>对此有比较详细的讲解（CSDN 也是有很多好文章的）。</li><li><strong>主路由 NAT 硬件加速导致的问题</strong>：可能是由于硬件加速流程对数据包的处理出现了类似于原因 1 的问题导致无法正确完成数据交互。由于硬件加速本质上是在运行特殊驱动，而各家厂商的该驱动几乎都是闭源的，所以网上也没见到有探究深层原因的资料。这种情况下把硬件加速关闭即可（会一定程度牺牲主路由 NAT 性能）。</li><li><strong>IP 和 MAC 校验机制导致包被丢弃的推论</strong>：由旁路由的网络拓扑可知，配置网关后上行流量必然经过旁路由，但在旁路由不进行 NAT 时数据包中的 IP 仍然是终端设备的，所以理论上下行数据并不会经过旁路由而是由主路由直接转发至终端。显然，由于旁路由的存在，IP 地址和 MAC 地址在某个环节会有不匹配的情况，如果主路由对此有校验，那数据包就会被丢弃掉。但这也只是个推论没有证据佐证，同时由于网络可能的复杂性，主路由通常也不会主动做这种校验。</li></ol><p>MASQUERADE 配置其实并没有定向地去解决上面这些具体问题，而是通过 NAT 来隐藏终端设备、只向主路由暴露旁路由 IP 的方式，一刀切地避免了上述原因导致的问题。但由于上下行流量都会经过旁路由，所有流量都会被二次 NAT 和二次转发，网络的吞吐会有不小的下降，直观感受就是下载速度变慢了。</p><p><strong>所以比较理想的策略是，先不加 MASQUERADE 规则观察是否有问题（尤其是国内流量），如果确实有问题，在权衡可以接受性能的损失后再配上该规则。</strong></p><h3><span id="二lan和wan是否需要绑定">（二）LAN和WAN是否需要绑定</span></h3><p>具体操作是取消桥接，再设置 WAN 和 LAN 共用同一个网卡（如 eth0 ）。这个操作其实和 MASQUERADE 规则的效果类似，因为绑定后经过 WAN 的流量必然会被 SNAT 。<strong>适用于确实遇到了疑难杂症且能接受性能损失场景下的备选方案。</strong></p><h3><span id="三是否需要关闭旁路由桥接">（三）是否需要关闭旁路由桥接</span></h3><p>在许多教程里，这个操作和添加 MASQUERADE 规则是配套的。但桥接与否实际上并不会影响整体的网络拓扑，这看上去又是一项没有意义的配置。我猜测可能是网上流传的添加 MASQUERADE 规则的方式是下面这条固定命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>也就是要求 SNAT 时从 eth0 网卡动态获取 IP 。而在桥接模式下，MASQUERADE 时是需要从 br-lan （常见的桥接后的默认网卡名称，也可能是其他名称，要视实际情况而定）获取 IP 的，直接复制粘贴上面的命令会导致 IP 伪装失败。<strong>所以只要把 -o 参数的值改为 br-lan 即可：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -I POSTROUTING -o br-lan -j MASQUERADE</span><br></pre></td></tr></table></figure><p>但似乎确实有网友不取消桥接就无法联网，这种情况大概率是旁路由固件对桥接模式的处理有问题（多见于 ARM 架构的固件，这类固件通常要做很多的魔改适配），<strong>如果真的遇到这种情况的话则确实可以取消桥接尝试下</strong>，毕竟大多数情况下旁路由内部的桥接也没什么实际意义，去掉后由于少了流量判断流程可能还会有非常微小的性能提升。</p><p>至于 N1 这种自带无线功能但实际上没人用的设备，在关掉无线后，确实可以顺便取消掉没有意义的桥接。只是在 OpenWrt 取消桥接保存配置时，要确定选中了有线网卡对应的接口比如 LAN/eth0 ，不然如果后台的前端存在体验问题自动选择了 wlan ，那保存后路由器可就直接失联了。</p><h3><span id="四是否需要设置dhcp强制">（四）是否需要设置DHCP强制</span></h3><p>如果我想通过 DHCP 下发网关但又不想改变主路由的原配置该怎么办呢？在 OpenWrt 的接口 DHCP 配置中有一个选项叫做「强制」，勾选后，此设备会忽略网络上已经存在的 DHCP 服务，强制启动本机的 DHCP 服务，所以似乎我们只需要在旁路由上配置此选项，并在旁路由 DHCP 中配置好网关，主路由不做任何变更，即可实现本段开头的诉求。</p><p>但上文提到同一子网中只能有一个用于分配指定网段的 DHCP 服务，因此旁路由强制开启 DHCP 后，还需要主路由具备主动判断网络情况停止提供 DHCP 服务的能力，这个流程才能真正运转起来。<strong>但并不是所有的路由器和固件都支持这个能力，目前来看 OpenWrt 作为主路由固件时可以正确检测并停用 DHCP ，其他固件则需要在使用时做下兼容性测试。从工程角度上讲，由于这样的操作过于依赖外部能力，属于和外部组件产生了强耦合，不利于未来维护，故不太推荐此种方案。</strong></p><h3><span id="五旁路由的某些功能无法使用">（五）旁路由的某些功能无法使用</span></h3><p>各种组件内部实现大不相同，如果某个组件的代码对网络结构做了强限定（如上文所说的校验 IP 和 MAC 的匹配关系），那旁路由的加入可能就会打破组件预期的网络结构导致其无法运行。这种情况在组件本身不做适配时基本无解，只能尝试下开启 MASQUERADE 等配置，<strong>看看多加一层 NAT 后的网络拓扑是否能符合组件要求，但代价同样是会牺牲性能。</strong></p><h3><span id="六是否应该关闭旁路由防火墙的syn-flood防御">（六）是否应该关闭旁路由防火墙的SYN-flood防御</span></h3><p>SYN-flood 是一种常见的攻击方式，SYN 指 TCP 建连三次握手中的第一步报文，flood 指大量发起该步骤的报文。由于 TCP 的实现原理要求服务端接收到 SYN 报文后回复客户端 SYN+ACK 报文表明请求被接受，并在一段时间内等待客户端回复最终的 ACK 报文，那么大量的 SYN 报文就会导致服务端出现大量等待最终资源耗尽挂掉，而攻击者并不需要真的完成建连，只要持续发送 ACK 包即可。</p><p>那路由器的防火墙又是如何作防御的呢？以 OpenWrt 为例，虽然 OpenWrt 的防火墙配置已经迁移到了 fw3 ，但翻看代码历史我们就会看到当时 OpenWrt 直接基于 iptables 的早期实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$IPTABLES -N syn_flood</span><br><span class="line">$IPTABLES -A syn_flood -p tcp --syn -m limit --limit $rate&#x2F;second --limit-burst $burst -j RETURN</span><br><span class="line">$IPTABLES -A syn_flood -j DROP</span><br><span class="line">$IPTABLES -A INPUT -p tcp --syn -j syn_flood</span><br></pre></td></tr></table></figure><p>即借助 iptables 的 SYN 限流能力进行防御，同时此配置位于 default 配置中，会在 NAT 等具体网络操作之前执行。</p><p>对应到主路由，wan 口接收到攻击流量后便会进行限流，攻击者无法直接向后攻击到内网主机，那么同样为内网主机的旁路由自然理论上也就不会被攻击到。</p><p>但对于旁路由来说，理论上网络中的所有上行流量都会通过它来转发，那当流量超过防火墙的限流阈值时便会触发拦截，进而在终端上表现为网络时断时续。<strong>所以在主路由已开启 SYN-flood 防御的情况下，旁路由关闭该配置可以避免出现可能的网络不稳定问题。</strong></p><h2><span id="旁路由与ipv6">旁路由与IPv6</span></h2><p>IPv6 在家用网络中通常默认是没有 NAT 转换流程的，同时其动态地址配置方案比 IPv4 要复杂得多，比如 SLAAC 和之前的 DHCP 可以说完全不是一套机制，而 DHCPv6 又分有状态和无状态两类。而前面提到，我们实现旁路由网络拓扑的过程，其实就是在指定一个具备透明代理功能的网关的过程，但 SLAAC/DHCPv6 都没有提供网关下发能力，终端设备总是会以其所交互的主机作为网关，同时大多也不支持直接修改网关。此外，运营商不支持 DHCPv6-PD 、IPv6 子网限定范围等情况，<strong>都使得旁路由支持 IPv6 非常困难，在不同场景、不同网络下要面临不同的配置，甚至无方案可配置。</strong></p><p>网上比较流行的旁路由 IPv6 实现是个曲线救国的折中方案，即先开启主路由的内网的 IPv6 地址分配进而让旁路由获得内网 IPv6 地址，随后再通过在旁路由开启一个 DHCPv6-Client 的方式获取到公网的 IPv6 地址，这样便可以将主路由的 DHCPv6 下发的 DNSv6 配置为旁路由的 IPv6 地址。此时除了 DNSv6 的解析是在旁路由进行，其他流程仍按原链路直连。而在需要分流的场景中，OpenWrt 的相关组件可以选择在解析域名时放过不需要处理的 IPv6 流量让其正常解析出 AAAA 记录，而对域名名单中的流量强制解析为 A 记录以继续走 IPv4 协议，从而实现和此前的类似的旁路由功能。</p><p>当然，这种解析实际上依赖于组件的能力。如果组件并不支持，那通过各种方式强制定义 IPv6 的路由表保证相关 IPv6 流量必然经过旁路由也是一种解决方案。<strong>不过无论哪种实现，由于不借助网关配置，其实都已经和本文的旁路由不相关了。</strong></p><p>此外，还有种方案是通过 radvd 等支持配置路由单播和优先级的工具，用更高的优先级来指定终端的 IPv6 路由（可以简单理解为 IPv4 的网关），这样就替代了 IPv4 下手动配置或 DHCP 下发网关对应的功能，完美满足本文所说的旁路由网络拓扑，同时对 IPv6 动态地址配置方案的要求很低，但要求终端设备支持路由优先级配置。</p><h2><span id="总结">总结</span></h2><p>旁路由实际上是运行透明代理功能的网关，有人认为这个概念很民科，但我并不认同，毕竟它只是在通过已有的能力来解决特定场景的问题，和我们写代码、做产品没有本质区别，而「旁路由」这个名词也不过是个约定俗成的叫法而已，不应该被批判。</p><p>另一方面，由于旁路由在不同设备、不同网络环境有可能遇到很多奇怪问题，其实对于非专业用户来说付出的时间成本很有可能会远大于直接替换主路由的成本。但生命不息，折腾不止，如果是为了收获折腾的快乐、学习到新的知识，那又有何不可呢？</p><blockquote><p>本文转载自：「 Eason Yang’s Blog 」，原文：<a href="https://url.hi-linux.com/1jwRt" target="_blank" rel="noopener">https://url.hi-linux.com/1jwRt</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最早听到旁路由这个词是在 2020 年折腾 N1 的时候，这台单网口的小盒子只能用网上所说的旁路由方案接入局域网来实现期望的功能。现在回想起来，旁路由这个词有可能就是在那个发烧友大量折腾斐讯 N1/P1/T1 的时期被发明出来的。&lt;/p&gt;
&lt;p&gt;你没办法在发烧友圈子外的互联网及各种学术材料中找到对旁路由的描述和定义，当然也找不到合适的英文翻译（导致这篇文章的 slug 定义困难）；从拓扑上看，旁路由更像是杂糅了二级路由和透明网关的概念，除了实体确实多接了根网线放在主路由旁边，其本身并没有真正地开启一条旁路，做的事情也基本可以和网关的定义对齐。&lt;/p&gt;
&lt;p&gt;不过，由于这个说法主要集中于网友的交流讨论之中，而且几年来在有相关需求的广大用户中被广为接受，所以只要这个词不变为一个学术概念，那我倒也不觉得有什么不妥。下文也仍然会用「旁路由」一词来指代在此类拓扑结构中担任代理网关角色的路由器。&lt;/p&gt;
&lt;p&gt;此外，本文对于原理的解释偏多且为新手向，对于已经熟知相关概念的读者则可以将本文作为 cheat sheet 食用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="网络" scheme="https://www.hi-linux.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="路由" scheme="https://www.hi-linux.com/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>SRE 生产环境上线操作指南</title>
    <link href="https://www.hi-linux.com/posts/20428.html"/>
    <id>https://www.hi-linux.com/posts/20428.html</id>
    <published>2023-10-13T01:00:00.000Z</published>
    <updated>2023-10-13T05:43:26.125Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>我们每天要进行大量的线上变更操作。怎么保证这些操作安全，不会导致故障，是我每天都在思考的问题。</p><p>这篇文章从工作经历总结一些原则和想法，希望能有帮助。</p><p>线上操作有几点基本的要求：</p><ul><li>操作需要是可以<strong>灰度的</strong> (Canary)：即能够在一小部分范围内生效，如果没有问题，可以继续操作更多的部分；</li><li>操作必须是可以验证和监控的：要知道自己操作的结果，是否符合预期；</li><li>操作必须是可以回滚的：如果发现自己的操作不符合预期，那么有办法能够回到之前的状态；</li></ul><p>逻辑很简答：假设我一开始做操作范围很小，可以灰度，做完之后我可以监控是否符合预期，如果不符合预期就回滚，那么，操作就是安全的。</p><p>这三步中的每一步看似很简单，但是实际做起来很难。</p><a id="more"></a><h2><span id="灰度">灰度</span></h2><p>发布过程是最简单的一种灰度场景，现在有蓝绿发布模式：</p><ol><li>分成两组，将所有的流量切换到绿组；</li><li>先发布蓝组，此时是没有流量的，发布完成之后，将流量逐渐切换到蓝组；清空绿组；</li><li>然后发布绿组，发布完成之后将流量切换到平均到两组</li></ol><p>还有滚动发布，对于每一个实例：让 Load Balancer 不再发给它新的流量，然后升级，然后开始接收流量，如果没有问题，继续以此处理其他的实例。</p><p>几乎每个人都可以理解灰度的必要性，但是不是每一种操作都是可以灰度的。</p><p>比如说数据库 DDL 的变更，很难灰度，提交到数据库，数据库就开始应用了；还有一些动态配置系统，一些全局配置，如果修改，就对所有的应用同时生效的；一般都是这样一些数据源类型的变更，很容易出现不支持灰度的情况。不可以灰度的情况也是最容易导致问题的。</p><p>一个替代方案是，搭建一套一模一样的环境，在这个环境先应用变更，测试一下是否符合预期。但是在今天分布式环境下，很难模拟出来一模一样的环境，可能规模小了，可能测试环境没有一些用户的使用场景，等等。总之，模拟的环境没有问题，不能代表生产的环境就没有问题。</p><p>最好的解决办法，还是在软件和架构，从设计上就能支持灰度。</p><h2><span id="验证与监控">验证与监控</span></h2><p>所有的操作，一定要知道自己在做什么，效果是什么。做完之后进行验证。听起来很简单，但是实际上，很多人做事像是闭着眼睛，不知道自己在做什么，做完之后有什么效果也不管。</p><h3><span id="验证操作的结果">验证操作的结果</span></h3><p>举一个例子，比如目前网关遇到了什么问题，经过查询，发现和 Nginx 的一个参数有关，然后根据网上的内容修改了这个参数，回头去看问题解决了没有。如果没有，继续在网上查资料，看和什么参数有关。</p><p>上述操作，一个潜在的问题是，当问题真正修复了之后，我们不知道自己做了啥才修复问题的。也有一些时候，相同的配置变了名字，实际上这个修改这个参数是可以解决问题的，只不过我们用了从网上得到的过时的参数名字，所以不生效。</p><p>所以，对于每一个操作，推荐直接去验证目前的操作结果。比如改了一个 log 参数，那么直接去看这个参数是否生效，是否符合预期，然后再去看其他的问题是否得到解决。</p><p>做操作要一步一步来，做一步验证一步。</p><p>另外，最好去验证操作的副作用，而不是验证操作本身。比如，修改了一个配置，不是去 <code>cat</code> 一下配置文件确认就可以了，而是要去看自己修改的配置是否真的生效了。比如路由器设备，我们执行了一些命令 <code>ip route ...</code> ，验证的方法并不是 <code>show running-config</code> 去看配置是否有这一条，而是要去看 <code>show ip route</code> 确定配置是否生效。</p><h3><span id="验证核心的业务指标">验证核心的业务指标</span></h3><p>除了验证操作结果之外，也要关注业务指标是否还正常。</p><p>如果业务指标不正常了，而恰好和自己的操作时间吻合，那么就应该立即回滚。</p><p>听起来很合理？但是实际上，很多人（我也是）第一反应都会是，我的操作不可能引起这个问题，让我先看看日志，到底发生什么了。</p><p>当发生问题的时候，时间很宝贵，正确的做法是第一时间在群组里面宣布自己的操作（事实上，操作之前就宣布了，但是消息太多，没有问题的时候没有人会认真看操作历史），然后开始进行回滚。可惜的是，我发现这么做的人很少，大部分都是想去排查，直到确定是自己的操作导致的，才开始回滚。</p><h2><span id="回滚">回滚</span></h2><p>同上，不是所有的操作都可以回滚的。一些可以补偿的方案有，操作上尽量设计成可以回滚的（有些废话）。比如，<a href="https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321" target="_blank" rel="noopener">DDIA</a> 这本书就介绍了数据上如何做向前兼容和向后兼容的方法。</p><p>举个例子，比如软件新版本的一个配置要从名字 A 改成 B，不要直接改，而是添加一个配置 B，代码里面可以读 B，如果没有的话，尝试读 A。等升级完成之后，在下一个新版本中，去掉 A 的逻辑。这样，每两个版本之间都是兼容的。</p><p>除此之外，还有一些我认为非常重要的东西。</p><h2><span id="操作计划和操作记录">操作计划和操作记录</span></h2><p>一些复杂的操作，比如修改 DNS，配置网关，配置其他东西，可能是联动的。而且显示中也不是所有的东西都适合自动化的。这些复杂的操作，推荐在操作之前就写好操作计划，然后对着一步一步操作，贴上必要的验证结果和操作时间。万一出现什么异常，就可以将异常出现的时间和自己的操作记录对照，很有用的。操作计划也可以相互 review，如果是 gitops 的话，就更好了。</p><h2><span id="效率">效率</span></h2><p>这是 <strong>Last but not least!</strong> 操作的效率至关重要。</p><p>我认为运维平台要设计成简洁，没有歧义，流程清晰的，非必要不审批。这可能跟直觉相反，尤其是领导的直觉。</p><p>领导（不知为何）觉得审批流程越多越好，出了事故就开始思考在哪一个阶段可以加上一个审批流程，来避免类似的问题发生。但其实，我觉得流程越多，出问题的概率不减反增。</p><p>程序员天生就不喜欢繁重的流程，如果流程太重，就会出现其他的问题，比如，人们会想办法绕过不必要的流程；会想办法“搭车发布”（意思就是将多个操作合并成一个，这也是违反原则的，一次应该只做一个操作）；对于明显出现异常苗头的时候，因为不想重新走审批而铤而走险。</p><p>但是出现这种情况，领导不会觉得流程有问题，领导会觉得你小子不按照流程办事，开除。</p><p>最后导致 SRE 的幸福感很低，事情还是要那么多，完成工作不得不铤而走险，还得责任自负。</p><p>事实上，真正能保证安全的是架构设计简单，做事的人知道自己在做什么，操作按照如上灰度、验证，出问题回滚，而不是靠流程。SRE 之间 Review 是有价值的，审批是没有价值的，大部分的审批仅仅是请示一下领导而已，领导可能看不懂操作的后果是什么。</p><p>所以，流程是有代价的。</p><blockquote><p>本文转载自：「卡瓦邦噶」，原文：<a href="https://url.hi-linux.com/0LB3T" target="_blank" rel="noopener">https://url.hi-linux.com/0LB3T</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们每天要进行大量的线上变更操作。怎么保证这些操作安全，不会导致故障，是我每天都在思考的问题。&lt;/p&gt;
&lt;p&gt;这篇文章从工作经历总结一些原则和想法，希望能有帮助。&lt;/p&gt;
&lt;p&gt;线上操作有几点基本的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作需要是可以&lt;strong&gt;灰度的&lt;/strong&gt; (Canary)：即能够在一小部分范围内生效，如果没有问题，可以继续操作更多的部分；&lt;/li&gt;
&lt;li&gt;操作必须是可以验证和监控的：要知道自己操作的结果，是否符合预期；&lt;/li&gt;
&lt;li&gt;操作必须是可以回滚的：如果发现自己的操作不符合预期，那么有办法能够回到之前的状态；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;逻辑很简答：假设我一开始做操作范围很小，可以灰度，做完之后我可以监控是否符合预期，如果不符合预期就回滚，那么，操作就是安全的。&lt;/p&gt;
&lt;p&gt;这三步中的每一步看似很简单，但是实际做起来很难。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DevOps" scheme="https://www.hi-linux.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>一文带你搞懂公网、私网、内网、外网的区别</title>
    <link href="https://www.hi-linux.com/posts/4852.html"/>
    <id>https://www.hi-linux.com/posts/4852.html</id>
    <published>2023-09-28T01:00:00.000Z</published>
    <updated>2023-09-28T08:25:04.382Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最近经常有很多小白朋友在后台问，<strong>公网、私网、内网、外网，这些的概念是啥样的，又该怎么去界定。</strong></p><p>关于 IP 地址，确实没有太明确的区分，其实也不必太过咬文嚼字。</p><p>内网、外网就是一个参考系选择的结果。</p><p>毕竟对你而言是外网，其实是别人的内网，，各有各的定义，最多只能具体问题具体分析。</p><p>不过在一般情况下，还是可以区分的。</p><p><strong>内、外网是相对于防火墙而言的，在防火墙内部叫做内网，反之就是外网。</strong></p><p><strong>所以在一定程度上外网等同于公网，内网等同于私网。</strong></p><p>那具体怎么分，再展开探讨一番。</p><a id="more"></a><h2><span id="01-公网外网">01. 公网=外网？</span></h2><p><strong>私网=内网？</strong></p><p>前面只是浅浅说一下，那到底可以这么理解吗？</p><p>这四个名词的意思，很浅显。</p><p><strong>公网=公共网络</strong></p><p><strong>私网=私有网络</strong></p><p><strong>内网=内部网络</strong></p><p><strong>外网=外部网络</strong></p><p>假设现在我们用大写字母表示网络群组，后面括号跟上数字代表其规模表示群组中有多少台计算机。</p><p>C (567918467)-中国网络群组</p><p>W (407619781)-全球网络群组</p><p>A (57619)-阿里云服务器群组</p><p>H (3)-你家里的网络群组</p><p><strong>然后这其中就包含了一些关系，W←→C[A,H]。</strong></p><p>我们知道由于国内网络实际上被限制了的，可以称之为全球最大的局域网，所以国内网络群组可以（科学）访问国外网络群组，而阿里云和你自家电脑都属于C。</p><p>那么如果你的电脑在 C，W 对于你来说就叫<strong>外网</strong>，自己所在的网络就叫<strong>内网</strong>，反之同理。</p><p><strong>局域网</strong>也是这个概念，如果你身处局域网，那么外部网络就叫外网。</p><p>那么什么是<strong>公网</strong>呢，顾名思义，人人都能访问的网络。</p><p>例如 H 和 A，他们都能访问自己的上层也就是 C，那么 C 对于 A 和 H 来说就叫公网。</p><p>**公网=外网吗？**<strong>可以是可以，但又有部分情况需要具体问题具体分析。</strong></p><p>比如说有时候像大型网络当中会有自建的广域网，也就是我们自建的骨干网络，对这种<strong>骨干网络</strong>我们也会叫公网。</p><p>然后内部的网络的话也会叫内网，这种情况就不太一样。</p><p>比如像政务外网或者政务网此类，那政务网它的公共部分其实它并不能上互联网，但是也叫<strong>公网</strong>。</p><p><strong>私网</strong>，私有网络，未经授权无法访问的网络。</p><p><strong>局域网</strong>也是某种意义上的私网，路由器只提供访问外网的权限和连接，于是对于 A 和 H 来说，他们也就是互为私网。</p><p>所以其实不必过于纠结叫法，这个并没有明确的定义。</p><h2><span id="02内网局域网">02.「内网」局域网</span></h2><p>接下来展开说说。</p><p><strong>内网也叫局域网，从范围上来讲内网就是小部分的网络。</strong></p><p>局域网指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。</p><p>局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。</p><p><strong>局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</strong></p><p><img src="https://img.hi-linux.com/staticfile/202309061009261-20230928154938259-2023-09-28-Ytvk9o.png" alt></p><p><strong>我们常说的内网，从字面意思上来讲是区别于外网的。</strong></p><p><strong>也就是说内网一般是用于局域网内部的计算机之间的互相通信，如果需要访问 Internet，需要借助外网。</strong></p><p><strong>局域网主要特点：</strong></p><p>覆盖的地理范围较小，适合小范围的组网。比如学校、工厂、机关单位等。</p><p>使用专门铺设的传输介质进行联网，数据传输速率高（10Mb/s～10Gb/s）；</p><p>通信延迟时间短，可靠性较高；</p><p>局域网可以支持多种传输介质；</p><h2><span id="03外网广域网">03.「外网」广域网</span></h2><p>外网即广域网，一般情况下又称公网。</p><p>是连接不同地区局域网或者城域网计算机的通信的远程网络。</p><p><img src="https://img.hi-linux.com/staticfile/202309061009262-2023-09-28-CRxWGX.png" alt></p><p>连接不同地区局域网或城域网计算机通信的远程网。</p><p><strong>通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。</strong></p><p>广域网并不等同于互联网。</p><h2><span id="04nat地址转换技术">04.「NAT」地址转换技术</span></h2><p><strong>这里浅聊一下NAT——“网络地址转换”技术。</strong> <strong>它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术用。</strong> 大概意思是，NAT 就是在局域网中使用内部地址，而当内部节点要与外部网络进行通讯时，就在网关处，将内部地址替换成公用地址，从而在外部公网（Internet）上正常使用。</p><p><img src="https://img.hi-linux.com/staticfile/202309061009263-2023-09-28-Hr16eS.jpg" alt></p><p>NAT可以使多台计算机共享 Internet 连接，这一功能很好地解决了公共 IP地址紧缺的问题。 通过这种方法，可以只申请一个合法IP地址，就把整个局域网中的计算机接入 Internet 中。 正是因为 NAT 技术的出现才使得内网地址能很方便的访问互联网。</p><h2><span id="05-内网和外网的区别">05. 内网和外网的区别</span></h2><p><strong>2 个例子给你说明白</strong></p><p><img src="https://img.hi-linux.com/staticfile/202309061009264-2023-09-28-KuqWBt.jpg" alt></p><p>如图，假设我们的计算机是设备一，想要访问百度。</p><h3><span id="1-怎么使用校园网">1. 怎么使用校园网</span></h3><p>如果使用校园网，首先需要先通过校园网的路由器把我们的内网 IP 转为校园网的外网 IP。 然后通过这个外网 IP 先连接上湖南电信的网关，最后在连接上百度的网关。 百度把你请求的信息回传到你的校园网网关，校园网网关再把信息传给你（整个网络呈网状结构。 它会自动找到一条通往百度的路径——基于深度优先搜索或者广度优先搜索）。</p><p>这个过程就跟淘宝购物差不多，转换一下。 假设在学校里<strong>订购</strong>了一本书，淘宝那边接收到你的订单准备好物品就开始给你发货了。 他发现你的收货地址在湖南，于是它可能从杭州出发，先去了福建的中转站，然后再到江西的中转站。 突然发现江西到湖南的中转站不通，于是它只能再绕到广东的中转站，最后再到湖南中转站。 这些中转站就相当于公网上的各个网关。 到了湖南中转站，快递小哥再把包裹送到你的校门（这就是最后一级网关）。 这时快递小哥就走了，校门处的管理人员在根据的你的宿舍信息把包裹拿给你。（局域网内部的信息交流由校园网这个网关来处理） 这对刚接触互联网的人来说有些难以理解内网 IP 和公网 IP 的区别，那我们再举一个例子。</p><h3><span id="2-一个对内一个对外">2. 一个对内，一个对外</span></h3><p>我们把酒店的 201 房比作内网 IP，那么凡是酒店都可能有 201 房，假如你饿了会对服务员说：“我在 201 房间，麻烦送些吃的过来“。 而假如你要点外卖的话你对店家仅说送来 201 房间（内网 IP），外面的人是不可能知道的。 这时你就要对店家说某某市某某区某某酒店（公网 IP）再加上 201 房店家才能找到你。 运营商所分配公网 IP 地址（某某市某某区某某酒店）也就是所住的酒店，而 201 房（内网 IP ） 则是酒店管家（路由器）所分配的。 所以一个酒店可以有很多的房间（内网 IP ）但是当外面的朋友问你住哪里，你肯定不会说你住在201房间（内网 IP ）而会说你住在某某市某某区某某酒店（公网 IP ）。 这是内网 IP 和公网 IP 的本质区别。 一个对内，一个对外。</p><h3><span id="3-你需要知道的-5-个点-说几个注意点">3. 你需要知道的 5 个点 说几个注意点：</span></h3><ol><li><p>公网 IP 具有世界范围的唯一性，而内网 IP 只在局域网内部具有唯一性</p></li><li><p>一个局域网里所有电脑的内网IP是互不相同的，但共用一个外网 IP。 就像前面酒店的例子一样： 你所在学校的校名在整个世界上只有一个，但是你学校里面的 A 栋大楼 3 层 3 号教室只有在你的校园内部才具有唯一性。 别的学校也有 A 栋大楼 3 层 3 号教室。 你只能跟快递小哥说请帮我把包裹送到 xx 大学，而不能说请帮我把包裹送到 A 栋大楼 3 层 3 号教室。</p></li><li><p>在局域网中，每台电脑都可以自己分配自己的 IP，但是这个 IP 只在局域网中有效。 而如果你将电脑连接到互联网，你的网络提供商的服务器会为你分配一个 IP 地址，这个IP地址才是你在外网的 IP。 两个 IP 同时存在，一个对内，一个对外。</p></li><li><p>互联网上的 IP（即外网 IP）地址统一由一个叫 “IANA（互联网网络号分配机构）” 的组织来管理。 由于分配不合理以及 IPv4 协议本身存在的局限，现在互联网的IP地址资源越来越紧张。 IANA 将 A、B、C 类 IP 地址的一部分保留下来，留作局域网使用。 具体如下——IP地址空间： A 类网 10.0.0.0 ~ 10.255.255.255，B 类网172.16.0.0 ~ 172.31.255.255，C 类网 192.168.0. 0~ 192.168.255.255。 也就是说，如果你查到的 IP 地址在以上 A、B、C 类IP 地址的范围内，它一定就是局域网的 IP 地址，否则就是公网的地址。</p></li><li><p>实际生活中不仅有一级 NAT 技术，还有二级 NAT 技术。 也就是可能你的校园网关也只是个局域网。通过多级转换可以得到更多的地址。</p></li></ol><h4><span id="经验法">经验法</span></h4><p>1、一般电信 ADSL 带宽在未升级大带宽前是（动态）公网 IP。如果花费很少的钱给你升级为 100M 光纤上网，99.99% 是内网IP，那 0.01% 是我还没有发现过案例。</p><p>2、代理网络运营商 99.99% 都是内网IP，如长城带宽、聚友E家等。</p><p>3、光纤上网的 99.99% 都是内网IP。</p><h4><span id="直观法">直观法</span></h4><p>以下 IP 段的地址都是内网 IP 地址</p><ul><li>10.0.0.0 到 10.255.255.255</li><li>172.16.0.0 到 172.31.255.255</li><li>192.168.0.0 到 192.168.255.255</li></ul><blockquote><p>本文转载自：「 Lenix Blog 」，原文：<a href="https://url.hi-linux.com/nDA6x" target="_blank" rel="noopener">https://url.hi-linux.com/nDA6x</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近经常有很多小白朋友在后台问，&lt;strong&gt;公网、私网、内网、外网，这些的概念是啥样的，又该怎么去界定。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于 IP 地址，确实没有太明确的区分，其实也不必太过咬文嚼字。&lt;/p&gt;
&lt;p&gt;内网、外网就是一个参考系选择的结果。&lt;/p&gt;
&lt;p&gt;毕竟对你而言是外网，其实是别人的内网，，各有各的定义，最多只能具体问题具体分析。&lt;/p&gt;
&lt;p&gt;不过在一般情况下，还是可以区分的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内、外网是相对于防火墙而言的，在防火墙内部叫做内网，反之就是外网。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以在一定程度上外网等同于公网，内网等同于私网。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那具体怎么分，再展开探讨一番。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="网络" scheme="https://www.hi-linux.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 是如何解决惊群效应的？</title>
    <link href="https://www.hi-linux.com/posts/34515.html"/>
    <id>https://www.hi-linux.com/posts/34515.html</id>
    <published>2023-09-12T01:00:00.000Z</published>
    <updated>2023-09-11T09:10:26.562Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="前置知识">前置知识</span></h2><ul><li>linux 网络处理的基本方法：bind listen accept</li><li>epoll 的基本方法：epoll_create epoll_ctl epoll_wait</li></ul><h2><span id="什么是惊群效应">什么是惊群效应？</span></h2><p>第一次听到的这个名词的时候觉得很是有趣，不知道是个什么意思，总觉得又是奇怪的中文翻译导致的。</p><p>复杂的说（来源于网络）TLDR;</p><blockquote><p>惊群效应（thundering herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群效应。</p></blockquote><p>简单的讲（我的大白话）</p><blockquote><p>有一道雷打下来，把很多人都吵醒了，但只有其中一个人去收衣服了。<br>也就是：<br>有一个请求过来了，把很多进程都唤醒了，但只有其中一个能最终处理。</p></blockquote><a id="more"></a><h3><span id="原因amp问题">原因&amp;问题</span></h3><p>说起来其实也简单，多数时候为了提高应用的请求处理能力，会使用多进程（多线程）去监听请求，当请求来时，因为都有能力处理，所以就都被唤醒了。</p><p>而问题就是，最终还是只能有一个进程能来处理。当请求多了，不停地唤醒、休眠、唤醒、休眠，做了很多的无用功，上下文切换又累，对吧。那怎么解决这个问题呢？下面就是今天要看的重点，我们看看 nginx 是如何解决这个问题的。</p><h2><span id="nginx-架构">Nginx 架构</span></h2><p>第一点我们需要了解 nginx 大致的架构是怎么样的。nginx 将进程分为 master 和 worker 两类，非常常见的一种 M-S 策略，也就是 master 负责统筹管理 worker，当然它也负责如：启动、读取配置文件，监听处理各种信号等工作。</p><p><img src="https://img.hi-linux.com/staticfile/hsz3mL-2023-09-11-A7PETT.png" alt></p><p>图片来自： <a href="https://aosabook.org/en/v2/nginx.html" target="_blank" rel="noopener">https://aosabook.org/en/v2/nginx.html</a></p><p>但是，第一个要注意的问题就出现了，master 的工作有且只有这些，对于请求来说它是不管的，就如同图中所示，请求是直接被 worker 处理的。如此一来，请求应该被哪个 worker 处理呢？worker 内部又是如何处理请求的呢？</p><h2><span id="nginx-使用-epoll">Nginx 使用 epoll</span></h2><p>接下来我们就要知道 nginx 是如何使用 epoll 来处理请求的。下面可能会涉及到一些源码的内容，但不用担心，你不需要全部理解，只需要知道它们的作用就可以了。顺便我会简单描述一下我是如何去找到这些源码的位置的。</p><h3><span id="master-的工作">Master 的工作</span></h3><p>其实 Master 并不是毫无作为，至少端口是它来占的。<br><a href="https://github.com/nginx/nginx/blob/b489ba83e9be446923facfe1a2fe392be3095d1f/src/core/ngx_connection.c#L407C13-L407C13" target="_blank" rel="noopener">https://github.com/nginx/nginx/blob/b489ba83e9be446923facfe1a2fe392be3095d1f/src/core/ngx_connection.c#L407C13-L407C13</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ngx_open_listening_sockets(ngx_cycle_t *cycle)</span><br><span class="line">&#123;</span><br><span class="line">    .....</span><br><span class="line">    for (i &#x3D; 0; i &lt; cycle-&gt;listening.nelts; i++) &#123;</span><br><span class="line">        .....</span><br><span class="line">        if (bind(s, ls[i].sockaddr, ls[i].socklen) &#x3D;&#x3D; -1) &#123;</span><br><span class="line"></span><br><span class="line">        if (listen(s, ls[i].backlog) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，根据我们 nginx.conf 的配置文件，看需要监听哪个端口，于是就去 bind 的了，这里没问题。</p><p>【发现源码】这里我是直接在代码里面搜 bind 方法去找的，因为我知道，不管你怎么样，你总是要绑定端口的</p><p>然后是创建 worker 的，虽不起眼，但很关键。 <a href="https://github.com/nginx/nginx/blob/b489ba83e9be446923facfe1a2fe392be3095d1f/src/os/unix/ngx_process.c#L186" target="_blank" rel="noopener">https://github.com/nginx/nginx/blob/b489ba83e9be446923facfe1a2fe392be3095d1f/src/os/unix/ngx_process.c#L186</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx_spawn_process(ngx_cycle_t *cycle, ngx_spawn_proc_pt proc, void *data,</span><br><span class="line">    char *name, ngx_int_t respawn)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    pid &#x3D; fork();</span><br></pre></td></tr></table></figure><blockquote><p>【发现源码】这里我直接搜 fork，整个项目里面需要 fork 的情况只有两个地方，很快就找到了 worker</p></blockquote><p>由于是 fork 创建的，也就是复制了一份 task_struct 结构。所以 master 的几乎全部它都有。</p><h3><span id="worker-的工作">Worker 的工作</span></h3><p>Nginx 有一个分模块的思想，它将不同功能分成了不同的模块，而 epoll 自然就是在 ngx_epoll_module.c 中了</p><p><a href="https://github.com/nginx/nginx/blob/b489ba83e9be446923facfe1a2fe392be3095d1f/src/event/modules/ngx_epoll_module.c#L330C23-L330C23" target="_blank" rel="noopener">https://github.com/nginx/nginx/blob/b489ba83e9be446923facfe1a2fe392be3095d1f/src/event/modules/ngx_epoll_module.c#L330C23-L330C23</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ngx_epoll_init(ngx_cycle_t *cycle, ngx_msec_t timer)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_epoll_conf_t  *epcf;</span><br><span class="line"></span><br><span class="line">    epcf &#x3D; ngx_event_get_conf(cycle-&gt;conf_ctx, ngx_epoll_module);</span><br><span class="line">    </span><br><span class="line">    if (ep &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        ep &#x3D; epoll_create(cycle-&gt;connection_n &#x2F; 2);</span><br></pre></td></tr></table></figure><p>其他不重要，就连 epoll_ctl 和 epoll_wait 也不重要了，这里你需要知道的就是，从调用链路来看，是 worker 创建的 epoll 对象，也就是每个 worker 都有自己的 epoll 对象，而监听的sokcet 是一样的！</p><blockquote><p>【发现源码】这里更加直接，搜索 epoll_create 肯定就能找到</p></blockquote><h3><span id="问题的关键">问题的关键</span></h3><p>此时问题的关键基本就能了解了，每个 worker 都有处理能力，请求来了此时应该唤醒谁呢？讲道理那不是所有 epoll 都会有事件，所有 worker 都 accept 请求？显然这样是不行的。那么 nginx 是如何解决的呢？</p><h2><span id="如何解决">如何解决</span></h2><p>解决方式一共有三种，下面我们一个个来看：</p><ol><li>accept_mutex（应用层的解决方案）</li><li>EPOLLEXCLUSIVE（内核层的解决方案）</li><li>SO_REUSEPORT（内核层的解决方案）</li></ol><h3><span id="accept_mutex">accept_mutex</span></h3><p>看到 mutex 可能你就知道了，锁嘛！这也是对于高并发处理的 ”基操“ 遇事不决加锁，没错，加锁肯定能解决问题。 <a href="https://github.com/nginx/nginx/blob/b489ba83e9be446923facfe1a2fe392be3095d1f/src/event/ngx_event_accept.c#L328" target="_blank" rel="noopener">https://github.com/nginx/nginx/blob/b489ba83e9be446923facfe1a2fe392be3095d1f/src/event/ngx_event_accept.c#L328</a></p><p>具体代码就不展示了，其中细节很多，但本质很容易理解，就是当请求来了，谁拿到了这个锁，谁就去处理。没拿到的就不管了。锁的问题很直接，除了慢没啥不好的，但至少很公平。</p><h3><span id="epollexclusive">EPOLLEXCLUSIVE</span></h3><blockquote><p>EPOLLEXCLUSIVE 是 2016 年 4.5+ 内核新添加的一个 epoll 的标识。它降低了多个进程/线程通过 epoll_ctl 添加共享 fd 引发的惊群概率，使得一个事件发生时，只唤醒一个正在 epoll_wait 阻塞等待唤醒的进程（而不是全部唤醒）。</p></blockquote><p>关键是：每次内核只唤醒一个睡眠的进程处理资源</p><p>但，这个方案不是完美的解决了，它仅是降低了概率哦。为什么这样说呢？相比于原来全部唤醒，那肯定是好了不少，降低了冲突。但由于本质来说 socket 是共享的，当前进程处理完成的时间不确定，在后面被唤醒的进程可能会发现当前的 socket 已经被之前唤醒的进程处理掉了。</p><h3><span id="so_reuseport">SO_REUSEPORT</span></h3><p>Nginx 在 1.9.1 版本加入了这个功能 <a href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/" target="_blank" rel="noopener">https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/</a></p><p>其本质是利用了 Linux 的 reuseport 的特性，使用 reuseport 内核允许多个进程 listening socket 到同一个端口上，而从内核层面做了负载均衡，每次唤醒其中一个进程。</p><p>反应到 Nginx 上就是，每个 Worker 进程都创建独立的 listening socket，监听相同的端口，accept 时只有一个进程会获得连接。效果就和下图所示一样。</p><p><img src="https://img.hi-linux.com/staticfile/UjOzmp-2023-09-11-5Q4Vve.png" alt></p><p>而使用方式则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">     server &#123;</span><br><span class="line">          listen 80 reuseport;</span><br><span class="line">          server_name  localhost;</span><br><span class="line">          # ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从官方的测试情况来看确实是厉害</p><p><img src="https://img.hi-linux.com/staticfile/2UzsJK-2023-09-11-63Mvfo.png" alt></p><p>当然，正所谓：完事无绝对，技术无银弹。这个方案的问题在于内核是不知道你忙还是不忙的。只会无脑的丢给你。与之前的抢锁对比，抢锁的进程一定是不忙的，现在手上的工作都已经忙不过来了，没机会去抢锁了；而这个方案可能导致，如果当前进程忙不过来了，还是会只要根据 reuseport 的负载规则轮到你了就会发送给你，所以会导致有的请求被前面慢的请求卡住了。</p><h2><span id="总结">总结</span></h2><p>本文，从了解什么 ”惊群效应“ 到 nginx 架构和 epoll 处理的原理，最终分析三种不同的处理 “惊群效应” 的方案。分析到这里，我想你应该明白其实 nginx 这个多队列服务模型是所存在的一些问题，只不过绝大多数场景已经完完全全够用了。</p><h2><span id="参考链接">参考链接</span></h2><ul><li>这一篇对于 nginx 锁内部实现有详细解析</li><li><a href="https://aosabook.org/en/v2/nginx.html" target="_blank" rel="noopener">https://aosabook.org/en/v2/nginx.html</a></li><li>epoll和惊群</li></ul><blockquote><p>本文转载自：「 LinkinStar’s Blog 」，原文：<a href="https://url.hi-linux.com/1472i" target="_blank" rel="noopener">https://url.hi-linux.com/1472i</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前置知识&quot;&gt;前置知识&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;linux 网络处理的基本方法：bind listen accept&lt;/li&gt;
&lt;li&gt;epoll 的基本方法：epoll_create epoll_ctl epoll_wait&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是惊群效应？&quot;&gt;什么是惊群效应？&lt;/h2&gt;
&lt;p&gt;第一次听到的这个名词的时候觉得很是有趣，不知道是个什么意思，总觉得又是奇怪的中文翻译导致的。&lt;/p&gt;
&lt;p&gt;复杂的说（来源于网络）TLDR;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;惊群效应（thundering herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群效应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的讲（我的大白话）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一道雷打下来，把很多人都吵醒了，但只有其中一个人去收衣服了。&lt;br&gt;
也就是：&lt;br&gt;
有一个请求过来了，把很多进程都唤醒了，但只有其中一个能最终处理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.hi-linux.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>作为一名软件工程师，我在 20 年职业生涯中学到的事情</title>
    <link href="https://www.hi-linux.com/posts/43069.html"/>
    <id>https://www.hi-linux.com/posts/43069.html</id>
    <published>2023-08-18T01:00:00.000Z</published>
    <updated>2023-08-18T03:02:53.366Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>（1）优秀的软件工程师不仅编写代码，还会考虑谁将使用它、为什么使用它、如何使用它。牢记用户需求才能创造良好的用户体验。</p><p>（2）水平再高的程序员，也会在自己擅长的领域犯错，如果遇到复杂的问题，就更是如此了。始终牢记，最好的代码是没有代码，或者不需要维护的代码。</p><p>（3）任何软件工程师的主要工作都是交付价值。软件只是达到目的的手段。</p><p>（4）警惕那些很长时间没有编写任何代码、却在设计系统的人。</p><p>（5）Bjarne Stroustrup 有一句名言：“只有两种计算机语言：人们抱怨的语言和没人使用的语言”。大型系统也是如此，每个系统最终都很糟糕。因此，不要太在意代码的优雅和完美，而要持续改进，创建一个可用的系统，让开发者喜欢在其中工作并可以提供价值。</p><a id="more"></a><p>（6）10 倍程序员是一个愚蠢的神话。我只见过程序员将代码规模增加了 10 倍，最终结果是你必须修复10倍的bug。</p><p>真正要做的不是找到神话中的10倍程序员，而是要避免出现 0.1 倍程序员。那些浪费时间、不寻求反馈、不测试代码、不考虑边缘情况等的程序员，必须保证让这样的人远离我们的团队。</p><p>（7）人们说他们想要创新，但实际上，他们想要通常的只是某种新颖性和业务成功。如果你的创新改变了人们做事的方式，大多数情况下会得到负面反馈。如果你相信你正在做的事情，并知道它真的会改善事情，那么就准备好迎接一场持久战吧。</p><p>（8）数据是系统中最重要的部分。数据可能会比你的代码寿命更长，保持数据的有序和清洁，避免脏数据，从长远来看，会得到很好的回报。</p><p>（9）一直存在的旧技术不是恐龙，而是鲨鱼。它们很好地解决了问题，所以一直活到了现在，没有被快速变化的技术浪潮淘汰。</p><p>不要轻易押注新技术，只有在充分理由的情况下才替换正在发挥作用的旧技术。那些老式的技术工具不花哨，也不令人兴奋，但它们可以完成工作，不会给你带来很多个不眠之夜。</p><p>（10）很多软件工程师除非被问到，否则不会发表意见。不要因为有人没当面发表意见，而认为他们没什么要补充的。有时，会议上嗓门最高的人是我最不想听的人。</p><p>（11）如果将人们与他们的工作成果分开，他们就会不太关心他们的工作。软件工程师和所有人一样，需要有主人翁的感觉，从头到尾拥有整个流程，直接负责交付价值。</p><p>让一群充满激情的人完全拥有设计、构建和交付软件的所有权，令人惊奇的事情就会发生。</p><p>（12）面试最好用于了解某人是谁，以及他们对特定专业领域的兴趣程度，对于试图弄清楚他们是否将成为一个优秀的团队成员，那是徒劳的。</p><p>（13）始终努力构建一个更小的系统。</p><p>有很多原因会推动你，去构建一个比原先设想的更大的系统，人类似乎有一种提供更多功能的欲望。你应该抵制这种欲望，在满足设计目标的前提下，始终努力构建一个更小的系统，这样你最终会得到一个比最初设计更好的系统。</p><blockquote><p>本文转载自：「阮一峰的网络日志」，原文：<a href="https://url.hi-linux.com/kGCyW" target="_blank" rel="noopener">https://url.hi-linux.com/kGCyW</a> ，版权归原作者所有。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（1）优秀的软件工程师不仅编写代码，还会考虑谁将使用它、为什么使用它、如何使用它。牢记用户需求才能创造良好的用户体验。&lt;/p&gt;
&lt;p&gt;（2）水平再高的程序员，也会在自己擅长的领域犯错，如果遇到复杂的问题，就更是如此了。始终牢记，最好的代码是没有代码，或者不需要维护的代码。&lt;/p&gt;
&lt;p&gt;（3）任何软件工程师的主要工作都是交付价值。软件只是达到目的的手段。&lt;/p&gt;
&lt;p&gt;（4）警惕那些很长时间没有编写任何代码、却在设计系统的人。&lt;/p&gt;
&lt;p&gt;（5）Bjarne Stroustrup 有一句名言：“只有两种计算机语言：人们抱怨的语言和没人使用的语言”。大型系统也是如此，每个系统最终都很糟糕。因此，不要太在意代码的优雅和完美，而要持续改进，创建一个可用的系统，让开发者喜欢在其中工作并可以提供价值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="程序员" scheme="https://www.hi-linux.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>为什么只有 13 台根服务器</title>
    <link href="https://www.hi-linux.com/posts/48287.html"/>
    <id>https://www.hi-linux.com/posts/48287.html</id>
    <published>2023-06-08T01:00:00.000Z</published>
    <updated>2023-06-20T02:53:34.634Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>网上很多人都说 DNS 根服务器只有 13 台，中国一台也没有。在网络世界，中国被美国卡住了脖子。那 DNS 根服务器真的只有 13 台吗？如果是，那原因又是什么？今天就给大家说道说道。</p><h2><span id="dns-基本概念">DNS 基本概念</span></h2><p>在回答这个问题之前，我们需要先回顾一些基本概念。DNS 是一种分层结构，这种层级就体现在域名的『点』里。以我的域名为例，<code>TAOSHU.IN</code> 它的完整域名其实是 <code>TAOSHU.IN.</code>。注意最后有一个点。它分三个层级，结结构为<code>.</code> ➜ <code>IN</code> ➜ <code>TAOSHU</code>。</p><p>DNS 又是分布式系统，每一层级都有自己的解析服务器。<code>.</code>是第一层级，它的解析服务器就是根服务器。第二层级是对应我们常说的<code>COM/NET</code>等顶级域名 TLD，而我用的<code>IN</code>是印度的国家域名，跟中国的<code>CN</code>一样，它们都是 CCTLD，也就是所谓的国家顶级域名。<code>TAOSHU</code> 就是普通的一级域名。每个域名都可以自行设置子域名，不受上级域名限制。</p><p>域名解析过程也是分布式的。还是以<code>TAOSHU.IN</code>为例。客户端先找到根服务器的地址，并其查询<code>IN</code>的解析服务器。再向<code>IN</code>的服务器查询<code>TAOSHU.IN</code>的服务器。最后向<code>TAOSHU.IN</code> 的服务器查询具体的解析记录，比如 A 记录等。</p><p>更多关于 DNS 的细节，请参考的另一篇<a href="https://taoshu.in/dns/dns-intro.html" target="_blank" rel="noopener">文章</a>。</p><a id="more"></a><h2><span id="当前根服务器">当前根服务器</span></h2><p>从上面的过程可知，所有的 DNS 查询都从根服务器开始。所以根服务器是整个 DNS 系统的核心。如果根服务器出现故障，那所有 DNS 查询都会失败！为了避免出现这种问题，人们设置了多个 DNS 根服务器。发展到现在，互联网社区累计设置了 13 台，它们分别是：</p><table><thead><tr><th style="text-align:left">主机名</th><th style="text-align:left">IP 地址</th><th style="text-align:left">运营机构</th><th style="text-align:left">国家</th></tr></thead><tbody><tr><td style="text-align:left"><a href="http://a.root-servers.net" target="_blank" rel="noopener">a.root-servers.net</a></td><td style="text-align:left">198.41.0.4, 2001:503:ba3e::2:30</td><td style="text-align:left">Verisign, Inc.</td><td style="text-align:left">美国</td></tr><tr><td style="text-align:left"><a href="http://b.root-servers.net" target="_blank" rel="noopener">b.root-servers.net</a></td><td style="text-align:left">199.9.14.201, 2001:500:200::b</td><td style="text-align:left">University of Southern California, Information Sciences Institute</td><td style="text-align:left">美国</td></tr><tr><td style="text-align:left"><a href="http://c.root-servers.net" target="_blank" rel="noopener">c.root-servers.net</a></td><td style="text-align:left">192.33.4.12, 2001:500:2::c</td><td style="text-align:left">Cogent Communications</td><td style="text-align:left">美国</td></tr><tr><td style="text-align:left"><a href="http://d.root-servers.net" target="_blank" rel="noopener">d.root-servers.net</a></td><td style="text-align:left">199.7.91.13, 2001:500:2d::d</td><td style="text-align:left">University of Maryland</td><td style="text-align:left">美国</td></tr><tr><td style="text-align:left"><a href="http://e.root-servers.net" target="_blank" rel="noopener">e.root-servers.net</a></td><td style="text-align:left">192.203.230.10, 2001:500:a8::e</td><td style="text-align:left">NASA (Ames Research Center)</td><td style="text-align:left">美国</td></tr><tr><td style="text-align:left"><a href="http://f.root-servers.net" target="_blank" rel="noopener">f.root-servers.net</a></td><td style="text-align:left">192.5.5.241, 2001:500:2f::f</td><td style="text-align:left">Internet Systems Consortium, Inc.</td><td style="text-align:left">美国</td></tr><tr><td style="text-align:left"><a href="http://g.root-servers.net" target="_blank" rel="noopener">g.root-servers.net</a></td><td style="text-align:left">192.112.36.4, 2001:500:12::d0d</td><td style="text-align:left">US Department of Defense (NIC)</td><td style="text-align:left">美国</td></tr><tr><td style="text-align:left"><a href="http://h.root-servers.net" target="_blank" rel="noopener">h.root-servers.net</a></td><td style="text-align:left">198.97.190.53, 2001:500:1::53</td><td style="text-align:left">US Army (Research Lab)</td><td style="text-align:left">美国</td></tr><tr><td style="text-align:left"><a href="http://i.root-servers.net" target="_blank" rel="noopener">i.root-servers.net</a></td><td style="text-align:left">192.36.148.17, 2001:7fe::53</td><td style="text-align:left">Netnod</td><td style="text-align:left">瑞典</td></tr><tr><td style="text-align:left"><a href="http://j.root-servers.net" target="_blank" rel="noopener">j.root-servers.net</a></td><td style="text-align:left">192.58.128.30, 2001:503:c27::2:30</td><td style="text-align:left">Verisign, Inc.</td><td style="text-align:left">美国</td></tr><tr><td style="text-align:left"><a href="http://k.root-servers.net" target="_blank" rel="noopener">k.root-servers.net</a></td><td style="text-align:left">193.0.14.129, 2001:7fd::1</td><td style="text-align:left">RIPE NCC</td><td style="text-align:left">荷兰</td></tr><tr><td style="text-align:left"><a href="http://l.root-servers.net" target="_blank" rel="noopener">l.root-servers.net</a></td><td style="text-align:left">199.7.83.42, 2001:500:9f::42</td><td style="text-align:left">ICANN</td><td style="text-align:left">国际</td></tr><tr><td style="text-align:left"><a href="http://m.root-servers.net" target="_blank" rel="noopener">m.root-servers.net</a></td><td style="text-align:left">202.12.27.33, 2001:dc3::35</td><td style="text-align:left">WIDE Project</td><td style="text-align:left">日本</td></tr></tbody></table><p>资料来源：IANA<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fn1" target="_blank" rel="noopener">1</a> 资料截止时间：2023年06月06日</p><p>在 1984 年，Jon Postel 和 Paul Mockapetris 在南加州大学设立了世界上第一台根服务器<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fn2" target="_blank" rel="noopener">2</a>。到了 1990 年，根服务器的数量扩展到了 7 台，分属不同的组织给护，但全都在美国。到了 1991 年，KTH 在瑞典设立一台根服务器。这是首次在美国之外部署根服务器。此后一直有旧的根服务器退役，新的服务器入役。到了 1995 年，根服务器已经扩展到 9 台。这个时候就遇到了<strong>技术瓶颈，无法添加新的根服务器</strong>了。</p><p>到底是什么技术瓶颈呢？这就得说说 DNS 的底层实现细节了。</p><h2><span id="priming-查询">Priming 查询</span></h2><p>前面说所有的 DNS 查询都从根服务器开始。那客户端怎么知道当前有哪些根服务器呢？没什么好办法，就是在各自的代码中写死！对，是硬编码。但我们前面也说了，在役的根服务器并非一成不变，写死的话新添加的服务怎么生效呢？</p><p>这就用到了所谓的 Priming Queries<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fn3" target="_blank" rel="noopener">3</a>。简单来说，所有 DNS 解析客户端都随软件附带一个列表文件，里面有当前所有根服务器的信息，包括域名、IP地址等信息。这个文件叫 Root Hints，可以从 IANA 官网<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fn4" target="_blank" rel="noopener">4</a>下载。但考虑到根服务器的列表可能会变，所以客户端需要定期<strong>从已知的根服务器查询当前最新的服务器列表</strong>，用的也是 DNS 协议，这类请求叫作 Priming 查询。</p><p>对于客户端来说，它先从 Root Hints 中根据某种规则<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fn5" target="_blank" rel="noopener">5</a>选出一台根服务器，然后向它查询最新的根服务器列表，并本机缓存一段时间，过期之前都以该列表为准。</p><p>因为 Priming 查询也是用 DNS 协议，自然也走 UDP 传输。互联网早期 IP 网络的最大传输单元长度(MTU)也就五百多字节，所以 DNS 回复信息的最大长度同样不能太长。所以 DNS 协议规定回复信息不能超过 512 字节。这就是添加根服务器遇到的技术瓶颈。</p><p>其实解决这个问题很容易，完全可以要求客户端使用 TCP 连接传输 Priming 查询结果嘛。可惜当时没有采用这种方案。不过，如果是我，也不会选 TCP 方案。因为所有 DNS 查询都走 UDP 协议，简单而统一。虽然 DNS 也支持使用 TCP，但让 Priming 查询单独走 TCP 明显会让系统变得很复杂。</p><p>社区最终决定想办法压缩查询结果长度。</p><h2><span id="报文结构与编码">报文结构与编码</span></h2><p>DNS 报文结构如下，分为五个部分<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fn6" target="_blank" rel="noopener">6</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|        Header       |</span><br><span class="line">+---------------------+</span><br><span class="line">|       Question      | the question for the name server</span><br><span class="line">+---------------------+</span><br><span class="line">|        Answer       | RRs answering the question</span><br><span class="line">+---------------------+</span><br><span class="line">|      Authority      | RRs pointing toward an authority</span><br><span class="line">+---------------------+</span><br><span class="line">|      Additional     | RRs holding additional information</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h3><span id="header">Header</span></h3><p>Header 为报文头信息，长度固定为 12 字节，结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                      ID                       |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    QDCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    ANCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    NSCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    ARCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></pre></td></tr></table></figure><p>Header 中跟本文内内直接相关的就是 QDCOUNT/ANCOUNT/NSCOUNT/ARCOUNT 这四个字段，分别表示后续 Question/Answer/Authority/Additional 段的数量。</p><h3><span id="question">Question</span></h3><p>Question 段保存查询请求信息，通长只有一个。它分成三个部分。后两个部分表示查询类型和网络类型。含义不重要，重要的是长度固定为 4 字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                                               |</span><br><span class="line">&#x2F;                     QNAME                     &#x2F;</span><br><span class="line">&#x2F;                                               &#x2F;</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                     QTYPE                     |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                     QCLASS                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></pre></td></tr></table></figure><p>第一部分 QNAME 长度可变，保存查询的域名。但存储的方式有点特别。以域名<code>A.ROOT-SERVERS.NET.</code> 为例，它会分成三部分<code>A</code>、<code>ROOT-SERVERS</code>和<code>NET</code>。每一部分称作一个标签(Label)， QNAME 字段只保存标签，不保存<code>.</code>。每个标签用第一个字节记录当前标签长度，后面跟着标签内容。最后用一个长度为零的标签表示结尾。所以完整的 QNAME 字段编码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">20 |           1           |           A           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">22 |           12          |           R           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">24 |           O           |           O           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">26 |           T           |           -           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">28 |           S           |           E           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">30 |           R           |           V           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">32 |           E           |           R           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">34 |           S           |           3           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">36 |           N           |           E           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">38 |           T           |           0           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></pre></td></tr></table></figure><p>长度为 20 字节。特别的，对于根域名<code>.</code>，它的 QNAME 编码是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">20 |           0           |                       |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></pre></td></tr></table></figure><p>长度为 1 字节。</p><h3><span id="answer">Answer</span></h3><p>Answer 段是服务器返回的响应结果。数量为一条到多条不等。每一条称为一个 RR，全称是 Resource Record。其结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                                               |</span><br><span class="line">&#x2F;                                               &#x2F;</span><br><span class="line">&#x2F;                      NAME                     &#x2F;</span><br><span class="line">|                                               |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                      TYPE                     |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                     CLASS                     |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                      TTL                      |</span><br><span class="line">|                                               |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                   RDLENGTH                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|</span><br><span class="line">&#x2F;                     RDATA                     &#x2F;</span><br><span class="line">&#x2F;                                               &#x2F;</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></pre></td></tr></table></figure><p>RR 跟前面的 Question 相比多了 TTL/RDLENGTH/RDATA 三个字段。TTL 表示有效时长， RDLENGTH 表示后续 RDATA 的长度，RDATA 保存实际的响应数据。根据 TYPE 和 CLASS 的不同，RDATA 内容也各不相同。在 Priming 查询中，RDATA 保存各根服务器的域名，编码跟前 Question 中的 QNAME 一样。</p><p>如果服务器返回如下一条 RR 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.       518400  IN      NS      a.root-servers.net.</span><br></pre></td></tr></table></figure><p>那么 RR 的总长度是 1+2+2+4+2+20=31 字节。</p><h3><span id="authority">Authority</span></h3><p>Authority 段用来返回待查询域名的权威服务器信息。比如我们尝试向根服务器直接查询 <code>TAOSHU.IN</code> 的 <code>A</code> 记录，根服务器就会在 Authority 段返回 <code>IN</code> 域名的解析服器。因为根服务器并不保存<code>TAOSHU.IN</code>的域名信息。不过在本文中，Priming 查询的权威服务器就是根服务器，所以此段长度为零。</p><p>最后的 Additional 段用来返回一些附加信息。Answer 中只有域名信息。我们希望直接返回 IP 地址，所以需要用到 Additional 段。Additional 中也是一条一条的 PR，计算方式跟 Answer 的一模一样。</p><p>因为 Priming 查询会返回所有的根服务器域名及其对应的 IP 地址<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fn7" target="_blank" rel="noopener">7</a>，所以根服务器数量越多，返回的数据就越长。但 DNS 协议规定最长只能是 512 字节，这就产生了瓶颈。</p><p>到了 1995 年，已经开通了 9 台根服务器，Priming 查询结果快要超过 512 字节了。社区开始着手解决这个问题。方案是标签压缩。</p><h3><span id="标签压缩">标签压缩</span></h3><p>压缩办法也很简单，就是在 NAME 中引入<strong>指针结构</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">| 1  1|                OFFSET                   |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></pre></td></tr></table></figure><p>DNS 还有一个规定，域名的长度不能超过 63 字节。NAME 中第一个字节表示长度，最大值就是 63，二进制表示为<code>00111111</code>，可见高两位是零。于是大家约定高两位设为<code>11</code>的时候，后面的 14 位就表示从报文 Header 开始的偏移量。这样一来，如果多个 RR 的域名中有相同的部分，就不需要重复传输，减少响应长度。</p><p>举个例子，比如要同时返回<code>A.ROOT-SERVERS.NET</code>和<code>B.ROOT-SERVERS.NET</code>两个域名，显然它们有共同的后缀<code>ROOT-SERVERS.NET</code>。假设<code>A.ROOT-SERVERS.NET</code>的偏移量为 20，那么可以表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">A.ROOT-SERVERS.NET</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">20 |           1           |           A           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">22 |           12          |           R           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">24 |           O           |           O           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">26 |           T           |           -           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">28 |           S           |           E           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">30 |           R           |           V           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">32 |           E           |           R           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">34 |           S           |           3           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">36 |           N           |           E           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">38 |           T           |           0           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">B.ROOT-SERVERS.NET</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">40 |           1           |           B           |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">44 | 1  1|                20                       |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">46 |           0           |                       |</span><br><span class="line">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></pre></td></tr></table></figure><p>利用标签压缩技术，域名<code>B.ROOT-SERVERS.NET</code>只需要占用 5 个字节，比 <code>A.ROOT-SERVERS.NET</code> 节省了 15 个字节。</p><h2><span id="根服务器更名">根服务器更名</span></h2><p>要想使用压缩，前提是所有域名有重复的部分。但之前的根服务器域名不相同，这就得改名。到了 1995 年，社区统一的域名为根服务器重新编组并部署标签压缩功能。</p><table><thead><tr><th style="text-align:left">旧域名</th><th style="text-align:left">新域名</th><th style="text-align:left">运营机构</th></tr></thead><tbody><tr><td style="text-align:left"><a href="http://NS.INTERNIC.NET" target="_blank" rel="noopener">NS.INTERNIC.NET</a></td><td style="text-align:left"><a href="http://A.ROOT-SERVERS.NET" target="_blank" rel="noopener">A.ROOT-SERVERS.NET</a></td><td style="text-align:left">InterNIC (operated by NSI)</td></tr><tr><td style="text-align:left"><a href="http://NS1.ISI.EDU" target="_blank" rel="noopener">NS1.ISI.EDU</a></td><td style="text-align:left"><a href="http://B.ROOT-SERVERS.NET" target="_blank" rel="noopener">B.ROOT-SERVERS.NET</a></td><td style="text-align:left">Information Sciences Institute, USC</td></tr><tr><td style="text-align:left"><a href="http://C.PSI.NET" target="_blank" rel="noopener">C.PSI.NET</a></td><td style="text-align:left"><a href="http://C.ROOT-SERVERS.NET" target="_blank" rel="noopener">C.ROOT-SERVERS.NET</a></td><td style="text-align:left">PSINet</td></tr><tr><td style="text-align:left"><a href="http://TERP.UMD.EDU" target="_blank" rel="noopener">TERP.UMD.EDU</a></td><td style="text-align:left"><a href="http://D.ROOT-SERVERS.NET" target="_blank" rel="noopener">D.ROOT-SERVERS.NET</a></td><td style="text-align:left">University of Maryland</td></tr><tr><td style="text-align:left"><a href="http://NS.NASA.GOV" target="_blank" rel="noopener">NS.NASA.GOV</a></td><td style="text-align:left"><a href="http://E.ROOT-SERVERS.NET" target="_blank" rel="noopener">E.ROOT-SERVERS.NET</a></td><td style="text-align:left">NASA Ames Research Center</td></tr><tr><td style="text-align:left"><a href="http://NS.ISC.ORG" target="_blank" rel="noopener">NS.ISC.ORG</a></td><td style="text-align:left"><a href="http://F.ROOT-SERVERS.NET" target="_blank" rel="noopener">F.ROOT-SERVERS.NET</a></td><td style="text-align:left">Internet Software Consortium</td></tr><tr><td style="text-align:left">NS.NIC.DDN.MIL</td><td style="text-align:left"><a href="http://G.ROOT-SERVERS.NET" target="_blank" rel="noopener">G.ROOT-SERVERS.NET</a></td><td style="text-align:left">GSI (operated by NSI)</td></tr><tr><td style="text-align:left">AOS.ARL.ARMY .MIL</td><td style="text-align:left"><a href="http://H.ROOT-SERVERS.NET" target="_blank" rel="noopener">H.ROOT-SERVERS.NET</a></td><td style="text-align:left">U.S. Army Research Lab</td></tr><tr><td style="text-align:left"><a href="http://NIC.NORDU.NET" target="_blank" rel="noopener">NIC.NORDU.NET</a></td><td style="text-align:left"><a href="http://I.ROOT-SERVERS.NET" target="_blank" rel="noopener">I.ROOT-SERVERS.NET</a></td><td style="text-align:left">NORDUnet</td></tr></tbody></table><p>上线之后，为新的根服务器留出了空间。于是在 1997 年，又上线了 J/K/L/M 四台根服务器。</p><p>这时候 Priming 查询响应的返回值有多大呢？我们可以算一下：</p><ul><li>Header 固定 12 字节</li><li>第一个 PR 保存完整域名，31 字节</li><li>另外 12 PR 保存压缩后的域名，12*15 = 180 字节</li><li>13 个 PR 保存 A 记录，13 * 16 = 208 字节<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fn8" target="_blank" rel="noopener">8</a></li><li>Question 段中 QTYPE 和 QCLASS 字段， 4 字节</li><li>Question 段中 QNAME 字段，1 字节</li></ul><p>总共为 12+31+180+208+4+1=436 字节。剩余可用 512−436=76 字节。一组台服务器需要额外占用 15+16=31 字节。理论上还可以再添加两台根服务器，也就是最多15台。</p><p>如果只管根服务器功能，确实还可以添加。但是早期的根服务器同时也是<code>COM/NET/ORG</code>的解析服务器。客户端可以向根服器发起针对特定<code>COM</code>域名的 Priming 查询。因为响应结果需要包含查询域名 QNAME，所以上面说的 76 字节中至少要保留 64 字节给 QNAME。这样就只剩下 12 字节。所以就不能再添加新的根服务器了。</p><h2><span id="ipv6-与-anycast">IPv6 与 Anycast</span></h2><p>虽然理论上是不能再加新的根服务器了，但后来网络不断发展，UDP 报文早已不需要把长度限制到 512 字节。而且引入 IPv6 网络后，Priming 查询结果中还需要返回 AAAA 记录， 512 个字节肯定不够用。所以社区又设计了 EDNS0<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fn9" target="_blank" rel="noopener">9</a> 来支持返回超过 512 字节的 DNS 响应。</p><p>理论上还是可以继续添加新的根服务器。但为什么不加了呢？那是因为有了更先进的技术 Anycast，中文译作任播。任播，可以简单理解为允许不同网络中的计算机共用一个 IP 地址，同时对外提供 DNS 查询服务。互联网会根据客户端的位置将请求路由到就近的计算机。</p><p>Anycast 技术将原来的单台服务器变成了一组多台服务器。到了2002年，J根服务器首次部署 Anycast 功能。到现在为止，前面说的13台根服务器严格来说是 13 个域名并且对应 13 对 IPv4 和 IPv6 地址。每对地址之后都通过 Anycast 部署了很多台实例，总计有超过 1500 台根服务器实例。这些实例又称为根<strong>镜像服务器</strong>。</p><h2><span id="中国根服务器镜像">中国根服务器镜像</span></h2><p>虽说中国没有自己的根服务器，但境内还是有不少根镜像服务器：</p><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:left">城市</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:left">广州</td></tr><tr><td style="text-align:center">D</td><td style="text-align:left">香港 台北</td></tr><tr><td style="text-align:center">E</td><td style="text-align:left">台北</td></tr><tr><td style="text-align:center">F</td><td style="text-align:left">北京 重庆 杭州 高雄 南宁 台北</td></tr><tr><td style="text-align:center">I</td><td style="text-align:left">北京 香港 沈阳 台北</td></tr><tr><td style="text-align:center">J</td><td style="text-align:left">北京 香港 湖州 上海</td></tr><tr><td style="text-align:center">K</td><td style="text-align:left">北京 广州 贵阳 台北</td></tr><tr><td style="text-align:center">L</td><td style="text-align:left">北京 长沙 海口 上海 武汉 西宁 新北 郑州</td></tr><tr><td style="text-align:center">M</td><td style="text-align:left">高雄</td></tr></tbody></table><p>资料来源：<a href="https://root-servers.org/" target="_blank" rel="noopener">https://root-servers.org</a> 资料截止时间：2023年06月06日</p><p>大家不妨通过 Ping 命令测一下，上面的几个根服务器的延迟都在 50ms 左右，一看就是在国内，不然不会这么快。</p><p>那为什么中国没有自己的根服务器呢？这个问题涉及到世界互联网的发展史和中国的互联网发展历程，我会专门撰文讲解。敬请期待。</p><hr><ol><li><a href="https://www.iana.org/domains/root/servers" target="_blank" rel="noopener">https://www.iana.org/domains/root/servers</a><a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fnref1" target="_blank" rel="noopener">↩︎</a></li><li><a href="https://www.icann.org/en/system/files/files/rssac-023-04nov16-en.pdf" target="_blank" rel="noopener">https://www.icann.org/en/system/files/files/rssac-023-04nov16-en.pdf</a><a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fnref2" target="_blank" rel="noopener">↩︎</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc8109" target="_blank" rel="noopener">https://datatracker.ietf.org/doc/html/rfc8109</a><a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fnref3" target="_blank" rel="noopener">↩︎</a></li><li><a href="https://www.iana.org/domains/root/files" target="_blank" rel="noopener">https://www.iana.org/domains/root/files</a><a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fnref4" target="_blank" rel="noopener">↩︎</a></li><li>如何选择没有公开的标准。有的实现会随机选，有的会根据 Ping 延迟选择最近的。<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fnref5" target="_blank" rel="noopener">↩︎</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc1035" target="_blank" rel="noopener">https://datatracker.ietf.org/doc/html/rfc1035</a><a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fnref6" target="_blank" rel="noopener">↩︎</a></li><li>早期只有 IPv4，所以只会返回 A 记录。IPv6 出现后还需要返回对应的 AAAA 记录。<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fnref7" target="_blank" rel="noopener">↩︎</a></li><li>因为 IP 地址各不相同，自然也无法压缩。<a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fnref8" target="_blank" rel="noopener">↩︎</a></li><li><a href="https://www.rfc-editor.org/rfc/rfc6891.html" target="_blank" rel="noopener">https://www.rfc-editor.org/rfc/rfc6891.html</a><a href="https://taoshu.in/dns/13-roots.html?utm_source=pocket_saves#fnref9" target="_blank" rel="noopener">↩︎</a></li></ol><blockquote><p>本文转载自：「 涛叔的博客 」，原文：<a href="https://taoshu.in/dns/13-roots.html" target="_blank" rel="noopener">https://taoshu.in/dns/13-roots.html</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上很多人都说 DNS 根服务器只有 13 台，中国一台也没有。在网络世界，中国被美国卡住了脖子。那 DNS 根服务器真的只有 13 台吗？如果是，那原因又是什么？今天就给大家说道说道。&lt;/p&gt;
&lt;h2 id=&quot;DNS-基本概念&quot;&gt;DNS 基本概念&lt;/h2&gt;
&lt;p&gt;在回答这个问题之前，我们需要先回顾一些基本概念。DNS 是一种分层结构，这种层级就体现在域名的『点』里。以我的域名为例，&lt;code&gt;TAOSHU.IN&lt;/code&gt; 它的完整域名其实是 &lt;code&gt;TAOSHU.IN.&lt;/code&gt;。注意最后有一个点。它分三个层级，结结构为&lt;code&gt;.&lt;/code&gt; ➜ &lt;code&gt;IN&lt;/code&gt; ➜ &lt;code&gt;TAOSHU&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;DNS 又是分布式系统，每一层级都有自己的解析服务器。&lt;code&gt;.&lt;/code&gt;是第一层级，它的解析服务器就是根服务器。第二层级是对应我们常说的&lt;code&gt;COM/NET&lt;/code&gt;等顶级域名 TLD，而我用的&lt;code&gt;IN&lt;/code&gt;是印度的国家域名，跟中国的&lt;code&gt;CN&lt;/code&gt;一样，它们都是 CCTLD，也就是所谓的国家顶级域名。&lt;code&gt;TAOSHU&lt;/code&gt; 就是普通的一级域名。每个域名都可以自行设置子域名，不受上级域名限制。&lt;/p&gt;
&lt;p&gt;域名解析过程也是分布式的。还是以&lt;code&gt;TAOSHU.IN&lt;/code&gt;为例。客户端先找到根服务器的地址，并其查询&lt;code&gt;IN&lt;/code&gt;的解析服务器。再向&lt;code&gt;IN&lt;/code&gt;的服务器查询&lt;code&gt;TAOSHU.IN&lt;/code&gt;的服务器。最后向&lt;code&gt;TAOSHU.IN&lt;/code&gt; 的服务器查询具体的解析记录，比如 A 记录等。&lt;/p&gt;
&lt;p&gt;更多关于 DNS 的细节，请参考的另一篇&lt;a href=&quot;https://taoshu.in/dns/dns-intro.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>如何利用谷歌邮箱别名功能获取无限 Gmail 邮箱</title>
    <link href="https://www.hi-linux.com/posts/41141.html"/>
    <id>https://www.hi-linux.com/posts/41141.html</id>
    <published>2023-02-23T01:00:00.000Z</published>
    <updated>2023-02-23T07:10:24.912Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>我们注册有些国外的服务时，是不能用国内邮箱注册的，这时一个 Gmail 邮箱就显得很有必要。而有时候我们会需要注册多个账号，当然你可以用多个 Gmail 邮箱来注册。</p><p>但多个 Gmail 邮箱又不好管理，而且现在 Gmail 邮箱也不是那么好注册了，这时你就会需要下面我要介绍的内容了，利用 Gmail 邮箱的别名功能来实现同一邮箱获取无限多个 Gmail 邮箱号。</p><p>在这之前你需要有一个谷歌账号（Gmail邮箱）。没有的话去到这里注册：<a href="http://mail.google.com/" target="_blank" rel="noopener">http://mail.google.com</a>（目前注册需要正确上网，请自行搜索解决）。</p><a id="more"></a><h2><span id="gmail-邮箱别名设置">Gmail 邮箱别名设置</span></h2><p>这里我们假设你的 Gmail 邮箱为：<code>abcdef@gmail.com</code> ，那就可以通过以下办法得到无限的谷歌邮箱别名。</p><h3><span id="1用户名之间加-英文半角">1.用户名之间加 <code>.</code> （英文半角）</span></h3><blockquote><p><strong>例如：</strong> <code>abc.def@gmail.com</code></p><p>因为 Gmail 的用户名是不区分 <code>.</code> 符号的，所以下面其实都是同一个用户名</p></blockquote><ul><li>abcde.f</li><li>a.bcdef</li><li>ab.cdef</li><li>a.b.cdef</li><li>abc.d.ef</li></ul><h3><span id="2用户名后面加-任意字符">2.用户名后面加 <code>+任意字符</code></span></h3><blockquote><p><strong>例如：</strong> <code>abcdef+dev@gmail.com</code></p><p><code>+</code> 号后面可以是任意字符，例如：</p></blockquote><ul><li>+dev</li><li>+my</li><li>+sub</li><li>……</li></ul><p>**PS：**使用“+”号法，在许多网站注册时候，并不识别邮箱地址中的“+”，会提示你邮箱错误。</p><h3><span id="3改变用户名中任意字符的大小写">3.改变用户名中任意字符的大小写</span></h3><blockquote><p><strong>例如：</strong> <code>aBCdef@gmail.com</code></p><p>可以是用户名里的某个或多个字符，</p></blockquote><ul><li><a href="mailto:Abcdef@gmail.com">Abcdef@gmail.com</a></li><li><a href="mailto:AbcDeF@gmail.com">AbcDeF@gmail.com</a></li><li><a href="mailto:abcdEf@gmail.com">abcdEf@gmail.com</a></li></ul><h3><span id="4-把后缀变为-googlemailcom">4. 把后缀变为 <code>googlemail.com</code></span></h3><blockquote><p>因为之前 Gmail 在某些国家的商标没有谈好，不能使用 Gmail 商标，只好用 googlemail，这个很好理解。（貌似现在全球的商标都已经谈妥了）</p></blockquote><p><strong>例如：</strong> <code>abcdef@googlemail.com</code></p><h3><span id="5以上4种方法的结合">５.以上４种方法的结合</span></h3><blockquote><p>可以结合上面的4种方法来实现理论上的无限别名。例如：</p></blockquote><ul><li><a href="mailto:aBcdef+dev@googlemail.com">aBcdef+dev@googlemail.com</a></li><li><a href="mailto:AbcDEf+sub@googlemail.com">AbcDEf+sub@googlemail.com</a></li></ul><h2><span id="总结">总结</span></h2><p>了解了上面的 Gmail 别名设置的方法后，当你要注册一些服务的时候，只要在填写Gmail邮箱的时候填写通过上述的方法得到的别名邮箱就可以了。无需到 Gmail 设置，所有的别名邮箱的邮件都会发送到你原来的邮箱 <code>abcdef@gmail.com</code> 中。</p><blockquote><p>本文转载自：「涅哥社区」，原文：<a href="https://url.hi-linux.com/RiANA" target="_blank" rel="noopener">https://url.hi-linux.com/RiANA</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们注册有些国外的服务时，是不能用国内邮箱注册的，这时一个 Gmail 邮箱就显得很有必要。而有时候我们会需要注册多个账号，当然你可以用多个 Gmail 邮箱来注册。&lt;/p&gt;
&lt;p&gt;但多个 Gmail 邮箱又不好管理，而且现在 Gmail 邮箱也不是那么好注册了，这时你就会需要下面我要介绍的内容了，利用 Gmail 邮箱的别名功能来实现同一邮箱获取无限多个 Gmail 邮箱号。&lt;/p&gt;
&lt;p&gt;在这之前你需要有一个谷歌账号（Gmail邮箱）。没有的话去到这里注册：&lt;a href=&quot;http://mail.google.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mail.google.com&lt;/a&gt;（目前注册需要正确上网，请自行搜索解决）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Google" scheme="https://www.hi-linux.com/tags/Google/"/>
    
      <category term="Gmail" scheme="https://www.hi-linux.com/tags/Gmail/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 zSwap 提高系统性能</title>
    <link href="https://www.hi-linux.com/posts/43918.html"/>
    <id>https://www.hi-linux.com/posts/43918.html</id>
    <published>2023-02-23T01:00:00.000Z</published>
    <updated>2023-02-23T06:37:57.460Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p><strong>使用 zSWAP、zstd 和 z3fold 来提高操作系统的性能</strong></p></blockquote><p>压缩可以降低占用空间，顾名思义，内存压缩就是压缩内存，节省内存空间。就目前的技术而言， <code>I/O</code> 的速度远远慢于这 <code>RAM</code> 操作速度。因此，如果频繁地做 <code>I/O</code> 操作，不仅影响 <code>flash</code> 使用寿命，还严重影响系统性能。内存压缩是一种让 <code>I/O</code> 过程平滑过渡的做法, 即尽量减少由于内存紧张导致的 <code>I/O</code>，提升性能。</p><a id="more"></a><blockquote><p><strong>介绍 zSwap 技术</strong></p></blockquote><p><code>zSwap</code> 是 <code>Linux</code> 内核的一个功能，它为交换页提供了一个压缩的回写缓存，作为一种虚拟内存压缩形式。当内存页要被换出时，<code>zSwap</code> 不会把它们移到交换设备上，而是对它们进行压缩，然后把它们存储到系统 <code>RAM</code> 中动态分配的内存池中。后来，向实际的交换设备的回写被推迟了，甚至完全避免了，从而大大减少了需要交换的 <code>Linux</code> 系统的 <code>I/O</code>，其代价是需要额外的 <code>CPU</code> 周期来执行压缩。</p><p><code>zSwap</code> 允许 <code>Linux</code> 更有效地利用 <code>RAM</code>，因为它实际上增加了内存容量，而不是在压缩/解压缩交换页时稍微增加 <code>CPU</code> 的使用。<code>zSwap</code> 存在于内核中，但默认并没有开启，要使用它必须通过修改配置文件开启。</p><blockquote><p><strong>主流内存压缩技术</strong></p></blockquote><ul><li><strong>zSwap</strong></li></ul><p><code>zSwap</code> 是在 <code>memory</code> 与 <code>flash</code> 之间的一层缓存，当内存需要 <code>swap</code> 出去磁盘的时候，先通过压缩放到 <code>zSwap</code> 中去，<code>zSwap</code> 空间按需增长。达到一定程度后则会按照 <code>LRU</code> 的顺序(前提是使用的内存分配方法需要支持 <code>LRU</code>)将就最旧的 <code>page</code> 解压写入磁盘 <code>swap device</code>，之后将当前的 <code>page</code> 压缩写入 <code>zSwap</code>。</p><p><code>zSwap</code> 本身存在一些缺陷或问题：如果开启当 <code>zSwap</code> 满交换出 <code>backing store</code> 的功能, 由于需要将 <code>zSwap</code> 里的内存按 <code>LRU</code> 顺序解压再 <code>swap out</code>，这就要求内存分配器支持 <code>LRU</code> 功能；如果不开启当 <code>zSwap</code> 满交换出 <code>backing store</code> 的功能, 和 <code>zRam</code> 是类似的。</p><ul><li><strong>zRAM</strong></li></ul><p><code>zRram</code> 即压缩的内存，使用内存模拟 <code>block device</code> 的做法。实际不会写到块设备中去，只会压缩后写到模拟的块设备中，其实也就是还是在 <code>RAM</code> 中，只是通过压缩了。由于压缩和解压缩的速度远比读写 <code>I/O</code> 好，因此在移动终端设备广泛被应用。</p><p><code>zRram</code> 本身存在一些缺陷或问题：<code>zRam</code> 大小是可灵活配置的，配置多少成为了一个问题；使用 <code>zRam</code> 可能会在低内存场景由于频繁的内存压缩导致 <code>kswapd</code> 进程占 <code>CPU</code> 高；增大了 <code>zRam</code> 配置，对系统内存碎片是否有影响</p><ul><li><strong>zCache</strong></li></ul><p><code>zCache</code> 是 <code>oracle</code> 提出的一种实现文件页压缩技术，也是 <code>memory</code> 与 <code>block dev</code> 之间的一层存储，与 <code>zSwap</code> 比较接近，但 <code>zCache</code> 目前压缩的是文件页，而 <code>zSwap</code> 和 <code>zRAM</code> 压缩是匿名页。</p><blockquote><p><strong>介绍 zstd 压缩算法</strong></p></blockquote><p><code>Zstandard</code> 是一种实时压缩算法，提供高压缩率。它提供了非常广泛的压缩/速度权衡，同时有一个非常快的解码器支持。它还为小数据提供了一种特殊的模式，称为字典压缩，并可以从任何样本集中创建字典。<code>Zstandard</code> 库是作为使用 <code>BSD</code> 许可证的开源软件提供的。</p><blockquote><p><strong>开启 zSwap 的方法</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># edit grub as root</span></span><br><span class="line">$ sudo vim /etc/default/grub</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">"quiet splash zswap.enabled=1 zswap.compressor=zstd zswap.zpool=z3fold"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># update grub</span></span><br><span class="line">$ sudo update-grub</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install zstd and Z3fold</span></span><br><span class="line">$ sudo apt install checkinstall build-essential</span><br><span class="line">$ sudo apt install zstd <span class="comment"># not the latest version</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># edit the modules file</span></span><br><span class="line">$ sudo vim /etc/initramfs-tools/modules</span><br><span class="line">...</span><br><span class="line">zstd</span><br><span class="line">zstd_compress</span><br><span class="line">z3fold</span><br><span class="line"></span><br><span class="line"><span class="comment"># update initramfs</span></span><br><span class="line">$ sudo update-initramfs -u -k all</span><br><span class="line"></span><br><span class="line"><span class="comment"># restart PC and verify ZSWAP if enabled</span></span><br><span class="line">$ cat /sys/module/zswap/parameters/enabled</span><br><span class="line">Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># verify ZSWAP if its using zstd and z3fold</span></span><br><span class="line">$ sudo dmesg | grep -i zswap:</span><br><span class="line">[    1.059997] zswap: loaded using pool zstd/z3fold</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考链接地址</strong></p></blockquote><ul><li><a href="https://jamespotz.github.io/blog/eos-zswap-zstd-z3fold/" target="_blank" rel="noopener">Improving Elementary Os Performance using ZSWAP, zstd and z3fold</a></li><li><a href="https://cclinuxer.github.io/2020/09/Linux%E5%86%85%E5%AD%98%E5%8E%8B%E7%BC%A9%E6%B5%85%E6%9E%90%E4%B9%8B%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Linux 内存压缩浅析之原理</a></li></ul><blockquote><p>本文转载自：「 Escape 的博客 」，原文：<a href="https://url.hi-linux.com/oIcpv" target="_blank" rel="noopener">https://url.hi-linux.com/oIcpv</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用 zSWAP、zstd 和 z3fold 来提高操作系统的性能&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;压缩可以降低占用空间，顾名思义，内存压缩就是压缩内存，节省内存空间。就目前的技术而言， &lt;code&gt;I/O&lt;/code&gt; 的速度远远慢于这 &lt;code&gt;RAM&lt;/code&gt; 操作速度。因此，如果频繁地做 &lt;code&gt;I/O&lt;/code&gt; 操作，不仅影响 &lt;code&gt;flash&lt;/code&gt; 使用寿命，还严重影响系统性能。内存压缩是一种让 &lt;code&gt;I/O&lt;/code&gt; 过程平滑过渡的做法, 即尽量减少由于内存紧张导致的 &lt;code&gt;I/O&lt;/code&gt;，提升性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="zSwap" scheme="https://www.hi-linux.com/tags/zSwap/"/>
    
  </entry>
  
  <entry>
    <title>如何在 sudo 提权后使用别名命令</title>
    <link href="https://www.hi-linux.com/posts/35352.html"/>
    <id>https://www.hi-linux.com/posts/35352.html</id>
    <published>2023-02-13T01:00:00.000Z</published>
    <updated>2023-02-13T02:54:35.575Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>一般来说，<code>sudo</code>会忽略通过<code>.bashrc</code>文件、<code>.bash_aliases</code>文件或者<code>alias</code>命令设置的别名命令(aliased commands)。</p><p>比如，我们经常将<code>ll</code>用作<code>ls -lh</code>命令的别名。然后，我们输入<code>ll</code>，终端将会返回一个关于当前目录的长列表。但是，当我们输入<code>sudo ll</code>时，终端将会返回:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ll</span><br><span class="line">&#x3D;&gt;  sudo: ll: command not found</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="解决方案">解决方案</span></h2><p>我们给<code>shutdown</code>命令创建一个别名，当<code>rotorrent</code>运行的时候尝试输入这个别名去关机，我们可以看到系统不会关机。想要运行<code>/sbin/shutdown</code>需要root权限，然而<code>sudo</code>会完全忽略<code>shutdown</code>的这个别名。解决办法是，我们需要添加另一个别名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias sudo&#x3D;&#39;sudo &#39;</span><br></pre></td></tr></table></figure><p><code>sudo</code>后面的那个空格将会告诉<code>bash</code>，去检查跟在空格后面的命令是否也是一个别名。bash手册(通过<code>man bash</code>查看)上面是这么描述的:</p><blockquote><p>If the last character of the alias value is a blank, then the next command word following the alias is also checked for alias expansion. 如果别名值的最后一个字符是空格，将会检查”跟在别名后的下一个命令”是否也是别名扩展。</p></blockquote><p>下面是我机器<code>.bash_aliases</code>文件中的一些别名设置(因为系统才安装，可能以后会加更多别名设置):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Shortcuts</span><br><span class="line">alias ll&#x3D;&#39;ls -lh&#39;</span><br><span class="line">alias la&#x3D;&#39;ls -lhA&#39;</span><br><span class="line">alias l&#x3D;&#39;ls&#39;</span><br><span class="line">alias c&#x3D;&#39;clear&#39;</span><br><span class="line">alias x&#x3D;&#39;exit&#39;</span><br><span class="line">alias q&#x3D;&#39;exit&#39;</span><br><span class="line"></span><br><span class="line"># Don&#39;t run shutdown if rtorrent is running - as long as there&#39;s a screen with &quot;tor&quot; in its name, shutdown won&#39;t run (unless you call &#x2F;sbin&#x2F;shutdown, or unalias it)</span><br><span class="line">alias shutdown&#x3D;&#39;&#x2F;home&#x2F;james&#x2F;scripts&#x2F;safe.shutdown.sh&#39;</span><br><span class="line"></span><br><span class="line"># When using sudo, use alias expansion (otherwise sudo ignores your aliases)</span><br><span class="line">alias sudo&#x3D;&#39;sudo &#39;</span><br></pre></td></tr></table></figure><h2><span id="参考文档">参考文档</span></h2><ol><li><a href="http://www.shellperson.net/using-sudo-with-an-alias/" target="_blank" rel="noopener">Using sudo with an alias</a></li></ol><blockquote><p>本文转载自：「 Legolas’ Blogs 」，原文：<a href="https://url.hi-linux.com/lAqFF" target="_blank" rel="noopener">https://url.hi-linux.com/lAqFF</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般来说，&lt;code&gt;sudo&lt;/code&gt;会忽略通过&lt;code&gt;.bashrc&lt;/code&gt;文件、&lt;code&gt;.bash_aliases&lt;/code&gt;文件或者&lt;code&gt;alias&lt;/code&gt;命令设置的别名命令(aliased commands)。&lt;/p&gt;
&lt;p&gt;比如，我们经常将&lt;code&gt;ll&lt;/code&gt;用作&lt;code&gt;ls -lh&lt;/code&gt;命令的别名。然后，我们输入&lt;code&gt;ll&lt;/code&gt;，终端将会返回一个关于当前目录的长列表。但是，当我们输入&lt;code&gt;sudo ll&lt;/code&gt;时，终端将会返回:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo ll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x3D;&amp;gt;  sudo: ll: command not found&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Avahi 在局域网轻松发现你的系统服务</title>
    <link href="https://www.hi-linux.com/posts/45401.html"/>
    <id>https://www.hi-linux.com/posts/45401.html</id>
    <published>2023-01-29T01:00:00.000Z</published>
    <updated>2023-01-29T01:11:02.833Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>大多数 <code>Linux</code> 用户通常在没有复杂 <code>DNS</code> 服务的路由器上拥有多个 <code>Linux</code> 系统。本文将介绍一种方法，让你不必修改 <code>/etc/hosts</code> 之类文件的情况下实现按名称与多个系统通信。</p><p><code>mDNS</code> 是一种零配置网络服务，它允许系统在本地网络上按名称广播查询其他资源。大多数 <code>Linux</code> 都提供一个包含 <code>mDNS</code> 的零配置的软件包 <code>Avahi</code>。mDNS 同样也支持 macOS，是 Bonjour 软件包中的一部分。</p><a id="more"></a><p>本文假设你有两个支持 <code>Avahi</code> 软件包的 <code>Linux</code> 系统，这里以 <code>Ubuntu 20.04</code> 为例，它们的主机名分别是 <code>Mike-Ubuntu-01</code> 和 <code>Mike-Ubuntu-02</code>。</p><h2><span id="安装-avahi">安装 Avahi</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Ubuntu &#x2F; Debian</span><br><span class="line">$ sudo apt install avahi-daemon avahi-utils</span><br><span class="line"></span><br><span class="line"># CentOS</span><br><span class="line">$ sudo yum install nss-mdns avahi avahi-tools</span><br><span class="line"></span><br><span class="line"># Fedora </span><br><span class="line">$ sudo dnf install nss-mdns avahi avahi-tools</span><br></pre></td></tr></table></figure><p><code>avahi-tools</code> 软件包包括许多方便的实用程序，可用于检查系统上的 <code>mDNS</code> 服务的工作情况。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看局域网内所有已注册的 mDNS 服务</span><br><span class="line">$ avahi-browse -a -r</span><br><span class="line"></span><br><span class="line"># 发现某个类型的服务的返回包</span><br><span class="line">$ avahi-browse -r &quot;xxx&quot;</span><br><span class="line">-xxx 是指服务类型，如_http._tcp</span><br></pre></td></tr></table></figure><p>安装完成后，你可以检查下 <code>/etc/nsswitch.conf</code> 文件，它控制你的系统使用哪些服务来进行名称解析以及服务优先级。 你应该在该文件中看到如下一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;nsswitch.conf</span><br><span class="line">hosts: files mdns4_minimal [NOTFOUND&#x3D;return] dns myhostname</span><br></pre></td></tr></table></figure><blockquote><p>注意：命令 <code>mdns4_minimal [NOTFOUND=return]</code>，它告诉你的系统使用多播 DNS 解析器将主机名解析为 IP 地址。当名称无法解析时，也会尝试剩余的服务。通常 <code>nss-mdns</code> 包会为你处理此问题，如果你没有看到与此类似的配置，可以编辑这个文件加上它。</p></blockquote><p><strong>以上所有操作在两台机器上，都需要进行。</strong></p><h2><span id="设置主机名和测试">设置主机名和测试</span></h2><p>现在你已经完成了常见的配置工作，请通过以下方式为每个主机设置名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Mike-Ubuntu-01</span><br><span class="line">$ hostnamectl set-hostname Mike-Ubuntu-01</span><br><span class="line"></span><br><span class="line"># Mike-Ubuntu-02</span><br><span class="line">$ hostnamectl set-hostname Mike-Ubuntu-02</span><br></pre></td></tr></table></figure><blockquote><p>注：你也可以编辑 <code>/etc/avahi/avahi-daemon.conf</code> 文件，通过 <code>host-name</code> 来设置主机名称。 但默认情况下，Avahi 优先使用系统提供的主机名。</p></blockquote><p>接下来，重新启动 <code>Avahi</code> 服务，以便它接受变更：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart avahi-daemon.service</span><br></pre></td></tr></table></figure><p>如果你需要开机自启 <code>Avahi</code> 服务，可以使用以下命令来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable --now avahi-daemon.service</span><br></pre></td></tr></table></figure><p>最后，我们能够登录到 <code>Mike-Ubuntu-01</code> 并 <code>ping</code> 另一台机器的主机名 <code>Mike-Ubuntu-02</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 你应该使用默认的 .local 域名，以便解析正常工作。</span><br><span class="line">$ ping Mike-Ubuntu-02.local</span><br><span class="line">PING Mike-Ubuntu-02.local (192.168.5.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.5.2 (192.168.5.2): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;1.16 ms</span><br><span class="line">64 bytes from 192.168.5.2 (192.168.5.2): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;1.18 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>同样的，你在 <code>Mike-Ubuntu-02</code> 上也能 <code>ping</code> 通 <code>Mike-Ubuntu-01</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ping Mike-Ubuntu-01.local</span><br><span class="line">PING Mike-Ubuntu-01.local (192.168.5.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.5.1 (192.168.5.1): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;1.26 ms</span><br><span class="line">64 bytes from 192.168.5.1 (192.168.5.1): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;1.28 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样通过网络名称访问你的系统服务，是不是更加方便呢？</p><h2><span id="参考文档">参考文档</span></h2><ol><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li><li><a href="https://bynss.com/linux/663658.html" target="_blank" rel="noopener">https://bynss.com/linux/663658.html</a></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大多数 &lt;code&gt;Linux&lt;/code&gt; 用户通常在没有复杂 &lt;code&gt;DNS&lt;/code&gt; 服务的路由器上拥有多个 &lt;code&gt;Linux&lt;/code&gt; 系统。本文将介绍一种方法，让你不必修改 &lt;code&gt;/etc/hosts&lt;/code&gt; 之类文件的情况下实现按名称与多个系统通信。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mDNS&lt;/code&gt; 是一种零配置网络服务，它允许系统在本地网络上按名称广播查询其他资源。大多数 &lt;code&gt;Linux&lt;/code&gt; 都提供一个包含 &lt;code&gt;mDNS&lt;/code&gt; 的零配置的软件包 &lt;code&gt;Avahi&lt;/code&gt;。mDNS 同样也支持 macOS，是 Bonjour 软件包中的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="DNS" scheme="https://www.hi-linux.com/tags/DNS/"/>
    
      <category term="Avahi" scheme="https://www.hi-linux.com/tags/Avahi/"/>
    
  </entry>
  
  <entry>
    <title>五分钟带你了解 Web 3.0 与云原生</title>
    <link href="https://www.hi-linux.com/posts/49204.html"/>
    <id>https://www.hi-linux.com/posts/49204.html</id>
    <published>2023-01-28T01:00:00.000Z</published>
    <updated>2023-01-28T08:21:43.416Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2><span id="什么是-web-30">什么是 Web 3.0</span></h2><h3><span id="1-概念">1. 概念</span></h3><p>Web 3.0 并不是什么新鲜词，参考<a href="https://zh.wikipedia.org/zh-my/Web3" target="_blank" rel="noopener">维基百科</a>和<a href="https://baike.baidu.com/item/web3.0/4873257" target="_blank" rel="noopener">百度百科</a>上的描述。总结下个人理解。</p><p>Web 3.0 并没有一个非常明确的定义，Web 3.0 概念从 2016 年提出，随着技术的不断变化，一直在调整和延伸其定义。以下列举三个比较说明性的定义：</p><ul><li><p>Netflix 创始人 Reed Hastings 于 2016 年 11 月的 Technet 峰会上提出：Web 1.0 是拨号上网，50K 平均带宽，Web 2.0 是 1M 平均带宽那 Web 3.0 就该是 10M 带宽，全影像的网络，这才感觉像 Web 3.0。</p></li><li><p>以太坊联合创始人 Gavin Wood（加文·伍德）提出的定义：主要与基于区块链的去中心化、加密货币以及非同质化代币有关。Web 3.0 被用来描述互联网潜在的下一阶段，一个运行在“区块链”技术之上的“去中心化”的互联网。</p></li><li><p>美国企业家兼风险投资家诺瓦·斯皮瓦克建议将 Web 3.0 的定义延伸至当前各大技术潮流迈向新的成熟阶段的具体体现：</p><p><strong>无处不联网</strong>：宽带网普及和发展，移动通信设备的互联网介入。(例如：平板电脑)<br><strong>网络计算</strong>：“软件即服务”的商业模型，Web服务互用性，分布式计算，网格计算和效用计算（又称“云端计算”）。<br><strong>开放技术</strong>：开放API和协议，开放数据格式，开源软件平台和开放数据（如创作共用、开放数据许可）。<br><strong>开放身份</strong>：OpenID，开放名声，跨域身份和个人数据。<br><strong>智能网络</strong>：语义网技术比如：资源描述框架，网络本体语言，SWRL，SPARQL，语义应用程序平台和基于声明的数据储备。<br><strong>分布式数据库</strong>：万维数据库（“World Wide Database”，由语义网的技术实现）。<br><strong>智能应用程序</strong>：普通语言的处理，机器学习，机器推理，自主代理。</p></li></ul><a id="more"></a><h3><span id="2-价值">2. 价值</span></h3><p><img src="https://img.hi-linux.com/staticfile/webv1-2-3-2022-09-21-abiIWn.png" alt></p><p>这是比较老的一张图，但很能形象的说明问题：</p><ul><li><p>Web 1.0 下用户无法主动创建内容，不享有网络发言权，只是把传统的纸媒搬上了网络，典型的就是yahoo、新浪、网易这类门户网站，数据的交互是单向的；</p></li><li><p>Web 2.0 时代伴随着智能手机的普及、社交网络的兴起和云计算的发展而到来，所有用户都可以在社交媒体分享自己的所思所想并和他人交互，互联网世界的话语权从商业巨头转移到每一位终端用户手中。典型的就是 Facebook、QQ 这种社交媒体类应用，其是一个“可读+可写”的双向交互时代；</p></li><li><p>Web 3.0 相较 Web 2.0 出现了更多的内容创建者，出现了更多的信息交互。在物联网、人工智能、AR等新技术出现后，在新的概念里就提出了<strong>人与人、物与人、物与物信息交互</strong>，这个对应上面诺瓦·斯皮瓦克提出的无处不联网的概念（万物互联）。其大概率是去中心化，多向交互式的。</p></li></ul><table><thead><tr><th></th><th>web1.0</th><th>web2.0</th><th>web3.0</th></tr></thead><tbody><tr><td>信息互动方式</td><td>只读</td><td>交互</td><td>去中心化</td></tr><tr><td>描述</td><td>网站提供内容，用户阅读内容</td><td>用户可生成内容，与他人、网站交互</td><td>（数字）身份、资产和数据回归个人</td></tr><tr><td>典型代表</td><td>yahoo、新浪等门户网站</td><td>facebook、QQ等社交平台</td><td>各类Dapp</td></tr></tbody></table><p>由于 Web 3.0 的定义还是模糊的，我们只能大致的推断 Web 3.0 应该是如下的架构：</p><p><img src="https://img.hi-linux.com/staticfile/web3-information-2022-09-21-c3Fu8v.png" alt></p><p>Web 1.0 的本质是联合，那么 Web 2.0 的本质就是互动，它让网民更多地参与信息产品的创造、传播和分享，而这个过程是有价值的。Web 2.0 的缺点是没有体现出网民劳动的价值，所以 2.0 很脆弱，缺乏商业价值。Web 3.0 是在 Web 2.0 的基础上发展起来的能够更好地体现网民的劳动价值，并且能够实现价值均衡分配的一种互联网方式。（抖音和头条代表的自媒体时代多少有点这个意思了，实现了网民劳动价值的分配，不过这还是中心化的，另外对于创造的数字资产也未能利用区块链技术实现版权的强保护。）</p><h3><span id="3-生态">3. 生态</span></h3><p>按照普适各种技术的 Web 3.0的定义，在 3D 维度上的 Web 3.0 的生态见下图：</p><p><img src="https://img.hi-linux.com/staticfile/web3-ecology-2022-09-21-8zgIP1.png" alt></p><p>Web 3.0主要辐射的赛道包括 “应用层”、“交互层”、“软件层” 三个维度。其分别对应 “NFT数字藏品、游戏、社交等应用”、“可穿戴设备或者操控设备等硬件设备” 和 “人工智能和操作系统”。</p><p>Web3.0 造富创作者，整个 Web 3.0 生态就是对数据、所有权和用户关系的改革。Web 3.0 能够更明确的确权和分润，即，所有使用内容的用户都需要用虚拟货币或者 NFT 等工具向作者进行 ‘支付’，创作者也保留作品 100% 的所有权。</p><h2><span id="web30-与-云原生">web3.0 与 云原生</span></h2><ul><li>Web 3.0 的基础是云原生和区块链。</li><li>电是电气时代的基础，交流电是电大规模远距离传输的基础。</li><li>云计算是 Web 3.0 的技术基础，云原生是未来云计算的主要表现形式（就像交流电）。</li></ul><p>未来云基础设施是面向应用快速落地的，人们不用再去关心底层是如何实现的。就像有人买了电器，只用关心插上插头能不能用，不会关心电是怎么过来的。不需要再自己生产电，拉电线进到屋子里，这是基础设施，买或租了房子后，天然具备的。（云原生类比 Web 3.0，Web 3.0 就是冰箱、彩电、洗衣机，云原生就是房子里的电插头。）</p><p>在 Web 3.0 时代，云计算会以云原生的方式出现。当电灯出现时，用电的主要目的是照明，后面人们发现电的用途还可以更多，于是出现了冰箱、彩电、洗衣机等家用电器。因为有了电，我们开始创造发明各种终端的用电工具。</p><p>云计算也一样。云计算原本是为数据存储和终端提供平台，但当云计算平台系统和生态建立起来时，大量的应用基于云计算发生。也就是说，云计算的出现会激发更多的基于云计算的应用出现。云计算应用大规模兴起后，数据和计算还在云计算平台。所以，云计算会变成原生的应用平台，帮助元宇宙的应用广泛发展。所以，元宇宙的世界一定是由云计算承载的云原生世界。</p><h2><span id="写在最后">写在最后</span></h2><p>触碰到红利天花板的互联网大厂们已经走到了一个时代的路口，从今年 Facebook(Meta)、腾讯、阿里、美团等大厂下滑的财报数据也能窥见一二。互联网巨头们需要一个新的故事来引领一个新的时代 — Web 3.0。</p><p>Web 3.0 想要较好的发展，需要先解决三个重要的基础设施建设主题——隐私计算、元宇宙和可编程金融，基于这些主题，Web 3.0的内涵和外延能得以不断丰富和拓展，使互联网更加开放、普惠和安全，向更高阶发展。</p><blockquote><p>本文转载自：「 云原生之路 」，原文：<a href="https://url.hi-linux.com/JcHqB" target="_blank" rel="noopener">https://url.hi-linux.com/JcHqB</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Web-3-0&quot;&gt;什么是 Web 3.0&lt;/h2&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;1. 概念&lt;/h3&gt;
&lt;p&gt;Web 3.0 并不是什么新鲜词，参考&lt;a href=&quot;https://zh.wikipedia.org/zh-my/Web3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/web3.0/4873257&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度百科&lt;/a&gt;上的描述。总结下个人理解。&lt;/p&gt;
&lt;p&gt;Web 3.0 并没有一个非常明确的定义，Web 3.0 概念从 2016 年提出，随着技术的不断变化，一直在调整和延伸其定义。以下列举三个比较说明性的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Netflix 创始人 Reed Hastings 于 2016 年 11 月的 Technet 峰会上提出：Web 1.0 是拨号上网，50K 平均带宽，Web 2.0 是 1M 平均带宽那 Web 3.0 就该是 10M 带宽，全影像的网络，这才感觉像 Web 3.0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以太坊联合创始人 Gavin Wood（加文·伍德）提出的定义：主要与基于区块链的去中心化、加密货币以及非同质化代币有关。Web 3.0 被用来描述互联网潜在的下一阶段，一个运行在“区块链”技术之上的“去中心化”的互联网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;美国企业家兼风险投资家诺瓦·斯皮瓦克建议将 Web 3.0 的定义延伸至当前各大技术潮流迈向新的成熟阶段的具体体现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无处不联网&lt;/strong&gt;：宽带网普及和发展，移动通信设备的互联网介入。(例如：平板电脑)&lt;br&gt;
&lt;strong&gt;网络计算&lt;/strong&gt;：“软件即服务”的商业模型，Web服务互用性，分布式计算，网格计算和效用计算（又称“云端计算”）。&lt;br&gt;
&lt;strong&gt;开放技术&lt;/strong&gt;：开放API和协议，开放数据格式，开源软件平台和开放数据（如创作共用、开放数据许可）。&lt;br&gt;
&lt;strong&gt;开放身份&lt;/strong&gt;：OpenID，开放名声，跨域身份和个人数据。&lt;br&gt;
&lt;strong&gt;智能网络&lt;/strong&gt;：语义网技术比如：资源描述框架，网络本体语言，SWRL，SPARQL，语义应用程序平台和基于声明的数据储备。&lt;br&gt;
&lt;strong&gt;分布式数据库&lt;/strong&gt;：万维数据库（“World Wide Database”，由语义网的技术实现）。&lt;br&gt;
&lt;strong&gt;智能应用程序&lt;/strong&gt;：普通语言的处理，机器学习，机器推理，自主代理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="云原生" scheme="https://www.hi-linux.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议简介</title>
    <link href="https://www.hi-linux.com/posts/58517.html"/>
    <id>https://www.hi-linux.com/posts/58517.html</id>
    <published>2023-01-28T01:00:00.000Z</published>
    <updated>2023-06-20T02:53:25.016Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>HTTP 全称 Hypertext Transfer Protocol，中文是超文本传输协议。网上讲 HTTP 协议的资料可以说是五花八门，但大多数都在罗列 HTTP 协议具体的规定，很少有讲 HTTP 协议这样设计的原因。今天我就尝试从解决问题的角度分析 HTTP 协议主要特性，希望能帮助大家快速理解 HTTP 协议。</p><p>HTTP 是一种通过网络传输数据的协议。我们不希望数据在传输的过程中出现丢失或者损坏的问题。所以 HTTP 选用 TCP 作为底层网络协议，因为 TCP 是一种可靠的传输层协议。</p><p>通信双方就建立 TCP 连接后立马发现一个新问题：服务端要给客户端发送什么数据呢？所以客户端必需在连接建立后将自己想要的内容发送给服务端，这就是所谓的「请求」，也就 HTTP Request。由此就确立了 HTTP 协议最根本的设计，即由客户端主导的请求应答式协议。</p><a id="more"></a><p>客户端上来就给服务端发了一个「请求」。但服务端有可能收到的内容跟客户端并不完全一样。等等，TCP不是可靠传输协议吗？接收到的数据怎么会不一样？这就涉及到数据分段的问题。比如客户端发送”abcdef”，底层 TCP 协议可能分两次传输 “abc” 和 “def”，也可能分好多次传输。不论分几次，它们的顺序是固定的，跟客户端发送的顺序完全一致。服务端可能会收到多段数据，所以服务端需要把收到的数据「攒」起来，等到客户端的数据全部收到之后才能看到客户端「请求」的全貌。</p><p>那到什么时候算全部收到呢？这是 TCP 通信的一个基本问题。解决这个问题有两个流派：长度流和分隔符流。</p><p>所谓长度流就是在实际发送数据之前，先发送数据的长度。服务端先读取长度信息，然后再根据长度来「攒」后面的数据。那服务端在读取长度的时候不会碰到分段问题吗？其实不会，因为 TCP 只会对比较长的数据做分段。前面说的”abcdef”分两段只是一种极端的例子，实际上很难发生。所以，只要先发送的长度数据不要太长，服务端就能一次性收到。退一步，即便是真的会分段，这类长度流协议都会规定长度数据自身的长度。比如用两个字节表示长度，那范围就是数据长度的范围就是0-65535。服务端可以先收两个字节，然后再根据数据长度来接收后面的内容。</p><p>长度流最大的优点就是实现简单，内存效率高，服务端不用事先分配很多内存。但缺点也比较突出，长度的范围不够灵活。如果我们规定长度字段为两个字节，但就不能传输超过64k的数据。但如果规定长度字段为八个字节，那在传输比较短的数据时就造成浪费。如何设置最优长度字段，大家可以参考我的另一篇<a href="https://taoshu.in/pb-encoding.html" target="_blank" rel="noopener">文章</a>。</p><p>此外，长度流的扩展性也比较差。如果我们想在长度之外传输其他信息，比如数据类型、版本号之类，我们都需要提前规定好这些数据的长度。长度一旦定好，以后就很难扩展了。最典型的长度流协议就是 IP 报文。有兴趣的朋友可以去看看 IP 协议是怎么规定数据长度的。</p><p>有鉴于长度流的不足，人们又搞出了分割符流。简单来说就是用一个特殊的分割符表示数据的结尾。最经典的例子就是C语言的字符串，结尾用<code>\0</code>来表示。使用这个流派的服务端程序要不停地从客户端接收数据，直到收到某一个分割符，就表明已经收到了完整的「请求」。</p><p>因为不需要事先指定数据的长度，所以分割符流派一下子就解决了长度流长度范围不灵活的问题。分割符流派的协议可以接收任意长度的数据。但是，分割符流派为些也付出了代价。因为长度不固定，服务端必须分配比较大的内存或者多次动态分配内存，这会产生比较大的资源消耗。恶意用户可能通过构造很长的数据来占满服务器的内存。</p><p>但是 HTTP 协议还是加入了这个流派，它用的分割符是<code>\r\n</code>。这里的<code>\r</code>表示回车，就是让打印机把打印头回到最左边的位置。<code>\n</code>表示换行，就是让打印机把纸向上挪一行，准备打印新的实符。上古时代的电脑没用现在的液晶屏，用电传打印机来「显示」内容，所以需要传输<code>\r\n</code>两个字符。现在这些都淘汰了，理论上用<code>\n</code>也可以，像 Nginx 就支持只用<code>\n</code>。</p><p>所以，一个最简单的 HTTP 请求长这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;mypage.html\r\n</span><br></pre></td></tr></table></figure><p>这里的<code>GET</code>是一种拟人的说法，从服务拿什么东西。这也是 HTTP <strong>语义化</strong>设计的开端(所谓语义化就是普通人能看懂)。后面跟一个空格，再后面是文件的路径。最后是分割符<code>\r\n</code>。因为最后是<code>\r\n</code>，所以上面的数据也叫请求行(request line)。</p><p>客户端跟服务器建立连接后就立即发送上面的数据。服务端等收到<code>\r\n</code>后开始解析，也就是把<code>/mypage.html</code>提取出来，然后找到对应的文件，把文件内容发送给客户端。</p><p>到这里，客户端就收到了服务端发送的文件内容，也叫「响应」。但是，客户端马上面临服务端同样的问题：如何确定已经收到了 mypage.html 的完整的内容呢？服务端要不要在最后发送分割符<code>\r\n</code>呢？不能！因为 mypage.html 的内容里本身就可能包含<code>\r\n</code>。如果客户端还是以<code>\r\n</code>当作结束标记，那可能会丢失数据。</p><p>为此 Tim Berners-Lee (HTTP 协议之父) 采用了更简单的办法——关闭连接。也就是说，服务器在传输完成之后要主动关闭 TCP 连接，这样客户端就明确知道所有的内容已经传输完成了。</p><p>以上就是最原始的 HTTP 协议，大约在1990发布。现在称这个时代的 HTTP 协议为 HTTP/0.9，主要是跟后面标准化之后的 1.x 进行区分。就这样，万维网的时代开启了。</p><p>HTTP/0.9 发布后得到了广泛的应用。但它的功能太简单了，所以很多浏览器都在它的基础上做了扩展。最主要的扩展功能有如下几个：</p><ul><li>添加版本信息</li><li>添加扩展头信息</li><li>添加返回状态信息</li></ul><p>添加版本信息是为了方便客户端和服务端相互识别，这样才能开启扩展功能。添加之后的请求行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;mypage.html HTTP&#x2F;1.0\r\n</span><br></pre></td></tr></table></figure><p>添加扩展头信息是为了传递更多的扩展信息。比如，这时候不同的浏览器会在请求中标记自己的身份。为方便后续添加各种不同的扩展信息，HTTP协议继续使用「行」和分割符的概念。</p><p>首先，跟请求行保持一致，每一条扩展信息占一行，以冒号分割，以<code>\r\n</code>结尾，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: NCSA_Mosaic&#x2F;2.0 (Windows 3.1)\r\n</span><br></pre></td></tr></table></figure><p>其次，这种信息可以有多行。那服务端怎么确定到底有几行呢，这还得用到分割符<code>\r\n</code>。HTTP 协议用一个空行表示后面扩展信息都结束了。所以完整的请求是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;mypage.html HTTP&#x2F;1.0\r\n</span><br><span class="line">Host: taoshu.in\r\n</span><br><span class="line">User-Agent: NCSA_Mosaic&#x2F;2.0 (Windows 3.1)\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>服务端先接收一行，提取文件路程，然后再根据<code>\r\n</code>逐行提取扩展信息。如果收到一个空行，则说明扩展信息接收完成。</p><p>这些扩展信息也叫头信息(header)，后续 HTTP 协议的各种特性都是基于它来实现。</p><p>HTTP/0.9 收到请求后直接传输文件内容。但用些场景需要返回其他信息，比如文件不存在之类的，所以人们给它添加了返回状态信息。此外，扩展后的 HTTP 协议也支持服务端在发送数据前返回多个头信息。一个典型的扩展响应为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">200 OK\r\n</span><br><span class="line">Date: Tue, 15 Nov 1994 08:12:32 GMT\r\n</span><br><span class="line">Server: CERN&#x2F;3.0 libwww&#x2F;2.17\r\n</span><br><span class="line">Content-Type: image&#x2F;gif\r\n</span><br><span class="line">\r\n</span><br><span class="line">(image content)</span><br></pre></td></tr></table></figure><p>服务器首先会发一行数据<code>200 OK\r\n</code>。这里的<code>200</code>是状态码，表示成功。后面的<code>OK</code>是给人看的语义部分。这一行也叫 status code line。紧接着就是扩展信息，形式跟请求里的一模一样，每行一条，以空行表示结束。最后才是文件内容。</p><p>因为有了头信息，HTTP协议的扩展性直接起飞。人们不断给 HTTP 协议添加各种种样的特性。</p><p>HTTP/0.9 只能传输纯文本文件。因为有了 Header，我们可以传输更多的描述信息，比如文件在的类型、长度、更新时间等等。这些传输数据的描述信息也被称为 Entity Header，数据本身称为 Entiy。</p><p>常见的 Entiy Header 有:</p><ul><li>Content-Type 内容类型</li><li>Content-Length 内容长度</li><li>Content-Encoding 数据编码</li></ul><p>Content-Type 表示数据类型，比如 gif 的类型是<code>image/gif</code>。类型的取值最终被标准化为 Multipurpose Internet Mail Extensions(MIME)。</p><p>Content-Length 表示数据长度。但我们前面说过，HTTP/0.9 的服务器不需要返回文件长度，等传输完毕后关闭 TCP 连接就好了。为什么又要定义长度信息呢？</p><p>这里有两个问题。第一个是在请求里支持上传内容，第二个是连接优化问题。</p><p>HTTP/0.9 只有一种 GET 请求。显然光下载是不够的。人们陆续引入了 HEAD 和 POST 等请求，用来给服务器提交数据。一但要提交数据，光用分割符就不够了。因为提交的数据本身就可能包含分割符。所以需要事先指定数据的长度。这个长度用的就是 Content-Length 头来指定。</p><p>另外一个是连接优化问题。其实 HTTP 协议的发展史很大程度上就是传输性能的优化史。</p><p>HTTP/0.9每次请求都会创建一个 TCP 连接，读取结束后连接就会被关闭。如果一次只下载一个文件也没什么问题。但后来 HTML 页面支持嵌入图片等内容，一个页面可能有多个图片。这样浏览器打开一个 HTML 页面的时候就需要发起多次 HTTP 请求，每次请求都要反复建立和关闭 TCP 连接。不但浪费服务器资源，还会拖慢页面的加载速度。</p><p>所以，大家就想办法复用底层的 TCP 连接。简单来说就是服务器在内容发送完成后不主动关闭连接。但不关闭就会出现前面说的问题，客户端不知道响应内容什么时候传输完毕。所以需要事先指定数据的长度。因为 HTTP 协议已经有了 header 机制，所以添加 Content-Length 就是最自然的办法。</p><p>这里还有一个兼容性问题。如果客户端不支持复用 TCP 连接，那服务端不关闭连接的话客户端就会一直在等待。所以复用 TCP 连接这个功能不能默认开启，而是应该由客户端决定要不要使用。这就引出了<code>Connection:Keep-Alive</code>这个头信息。如果客户在请求中指定 Keep-Alive，服务端才不会主动关闭 TCP 连接。</p><p>除了复用 TCP 连接之外，HTTP/0.9 另一个值得优化的地方就是数据压缩。那个时代网速很慢，如果能把数据压缩之后再传输可以显著降低传输耗时。服务端不能随意压缩，因为有的客户端可能不支持。所以就先引入了<code>Accept-Encoding</code>这个头，可能的取值如<code>compress</code>或者<code>gzip</code>。服务端收到这个请求之后才对内容做压缩。因为浏览器可能支持多种压缩算法，浏览器需要选择一种自己也支持的来压缩数据，所以就需要在返回内容的时候指定自己用了哪种算法。这就是<code>Content-Encoding</code>头的用途。</p><p>不论是前面的 Connection 还是后面的 Accept-Encoding，为了尽可能地兼容不同客户端，HTTP 协议会通过添加新的 header 来协商是否使用扩展特性。<strong>这种协商由客户端来主导</strong>，服务器需要根据客户端的请求来配合完成。</p><p>还是因为网络比较慢而且成本很高，HTTP协议需要进一步优化数据传输效率。一个典型的场景是客户端已经下载过某文件内容。当客户端再次请求的时候，服务端还要不要返回。如果不返回，则客户端拿不到最新的内容；如果返回，当服务端的文件没有变化的时候，客户端会花很长时间加载一个已经下载过的文件。怎么优化这个问题呢？</p><p>人们引入了如下 Entity Header：</p><ul><li>Last-Modified 最近修改时间</li><li>Expires 过期时间</li></ul><p>如果文件不经常改动，服务器可以对过 Last-Modified 把最近修改时间发送给浏览器。浏览器如果支持，可以在下次请求该资源的时候带上这个时间，也就是在请求里添加下面的头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\r\n</span><br></pre></td></tr></table></figure><p>服务器收到后会跟文件的当前修改时间做对比，如果没有修改则直接返回304：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">304 Not Modified\r\n</span><br></pre></td></tr></table></figure><p>这种叫作条件请求，可以显著减少不必要的网络传输。</p><p>即使如此，客户端还是发起一次 HTTP 请求才能拿到 304 响应，也会产生网络传输和服务端开销。为了进一步优化，HTTP又引入了 Expires 头，它的含义是一个未来的过期时间。在这个时间之前浏览器可以安全使用本地缓存的副本，不需要从服务器下载。这样连条件请求都不需要发起了。</p><p>不过 Expires 特性有一个副作用，文件一旦下发，在过期之前根本无法修改。</p><p>大约是在1991-1995这个时间，各浏览器厂商陆续实现了上述功能。但不同浏览器和服务端软件支持的功能不同，带来各种兼容问题。于是到 1996 年，IETF 发布 <a href="https://datatracker.ietf.org/doc/html/rfc1945" target="_blank" rel="noopener">RFC1945</a>。RFC1945 只能说是当前最佳实践的总结，并不是推荐标准。但人们还是称它为 HTTP/1.0。</p><p>没过一年，也就是1997年，IETF就发布了<a href="https://datatracker.ietf.org/doc/html/rfc2068" target="_blank" rel="noopener">RFC2068</a>，也就是大名鼎鼎的 HTTP/1.1 协议规范。</p><p>HTTP/1.1 是对 HTTP/1.0 的梳理和扩展。核心的改动有：</p><ul><li>默认开启 TCP 连接复用，客户端不需要再发送 Connection:Keep-Alive</li><li>添加了所谓 pipeline 特性，进一步优化传输效率</li><li>支持 chunked 传输编码</li><li>扩展缓存控制</li><li>内容协商，包括语言、传输编码、类型等</li><li>在同一IP上建立多个 HTTP 网站</li></ul><p>所谓的 pipeline 特性是对 HTTP 协议传输效率的进一步优化，但最终失败了。</p><p>HTTP 协议是请求应答式协议。客户端发一个请求，然后等待服务端返回内容。虽然在 HTTP/1.0 时代就有了 TCP 连接复用、内容压缩和条件请求等优化机制，但客户端发起新请求之前必须等待服务器返回内容。换言之就是客户端无法在一个连接上并行发起多个请求。为此，HTTP/1.1 的 pipeline 就规定客户端可以依次发起多个 HTTP 请求，然后等待服务器返回结果。服务器需要按照请求顺序依次返回对应的响应内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  c        s              c        s</span><br><span class="line">  |  req1  |              |  req1  |</span><br><span class="line">  |-------&gt;|              |-------&gt;|</span><br><span class="line">  |  resp1 |              |  req2  |</span><br><span class="line">  |&lt;-------|              |-------&gt;|</span><br><span class="line">  |  req2  |              |  req3  |</span><br><span class="line">  |-------&gt;|              |-------&gt;|</span><br><span class="line">  |  resp2 |              |  resp1 |</span><br><span class="line">  |&lt;-------|              |&lt;-------|</span><br><span class="line">  |  req3  |              |  resp2 |</span><br><span class="line">  |-------&gt;|              |&lt;-------|</span><br><span class="line">  |  resp3 |              |  resp3 |</span><br><span class="line">  |&lt;-------|              |&lt;-------|</span><br><span class="line">  </span><br><span class="line">without pipeline         with pipeline</span><br></pre></td></tr></table></figure><p>虽然服务器收到多个请求的时候可以并发处理，这种并发带来的优化有限，而且 pipeline 特性并没有减少实际的网络传输。几乎没有软件实现 pipeline 特性，所以这个优化设计以失败告终。</p><p>chunked 编码是一项非常成功的优化，主要解决服务端动态生成响应内容的情况。</p><p>HTTP/1.0 只能使用 Content-Length 指定内容长度，而且是先发送 header 再发送 body。这就要求必须在传输内容之前确定内容的长度。对于静态文件，这当然不是问题。但如果要加载一个由 PHP 动态渲染的 HTML 就有问题了。因为 HTML 是程序动态生成的，没法事先确定内容长度。如果还用原来的办法，只能先把内容生成好保存到一个临时文件，再发送给客户端。显然这种性能太差。</p><p>为了解决这个问题，HTTP/1.1 引入 chunked 编码。简单来说就是回到之前的长度流，将数据逐段发送给客户端，每一段前面加上长度信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK\r\n</span><br><span class="line">Content-Type: text&#x2F;plain\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line"></span><br><span class="line">7\r\n</span><br><span class="line">Mozilla\r\n</span><br><span class="line">9\r\n</span><br><span class="line">Developer\r\n</span><br><span class="line">7\r\n</span><br><span class="line">Network\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>Transfer-Encoding 指定为 chunked。接下来的数据也是分行传输。一行长度，一行数据。结束的时候长度指定为零，然后再加一个空行。这样服务端就不需要事先确定响应内容的长度，PHP 就可以有边渲染一边发送。这个特性还是 WebSocket 没有普及的年代被用于实现消息推送。大家可以搜索 Comet 或者 HTTP 长轮询了解更多信息。</p><p>HTTP/1.1 对缓存做了更粗细化的定义，引入了 Cache-Control 扩展信息。这一部分内容比较复杂，除了会影响浏览器的缓存行为之外，还会影响 CDN 节点的行为。部分 CDN 厂商还会扩展 标准缓存指令的语义。限于篇幅，在此就不展开了。</p><p>但 HTTP/1.1 对条件请求做了扩展，可以说一下。</p><p>操作系统会自动记录文件的修改时间，读取该时间也非常方便，但 Last-Modified 不能覆盖所有情况。有时候我们需要用程序定时生成某些文件，它的修改时间会周期性变化，但内容不一定有改变。所以光用 Last-Modified 还是可能产生不必要的网络传输。于是 HTTP 协议引入了一个新的头信息 Etag。</p><p>Etag 的语义是根据文件内容计算一个值，只有在修改内容的时候才会产生新的 Etag。客户端每次请求的时候把上一次的 Etag 带回来，也就是添加下面的头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;c3piozzzz&quot;\r\n</span><br></pre></td></tr></table></figure><p>服务端收到后会对比 Etag，只有发生变化的时候才会返回新的文件内容。</p><p>那个时候的网络很不稳定，断网是家常便饭。想想一个文件下载到99%然后断网了是一种怎样的体验。为了减少不必要的数据传输，人们很快就给 HTTP 协议添加了「断点续传」功能。其实断点续传是从客户端视角来看的。从协议角度来看，需要添加的功能是根据指定范围传输数据。也就是说原来的文件是100字节，客户端可以指定只下载最后的10字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes 91-100&#x2F;100\r\n</span><br></pre></td></tr></table></figure><p>这里的<code>91-100</code>表示要下载的范围，后面的100表示整个文件的长度。如果服务器支持，则会返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 206 Partial content\r\n</span><br><span class="line">Date: Wed, 15 Nov 1995 06:25:24 GMT\r\n</span><br><span class="line">Last-modified: Wed, 15 Nov 1995 04:58:08 GMT\r\n</span><br><span class="line">Content-Range: bytes 91-100&#x2F;100\r\n</span><br><span class="line">Content-Length: 10\r\n</span><br><span class="line">Content-Type: image&#x2F;gif\r\n</span><br><span class="line">\r\n</span><br><span class="line">(image data)</span><br></pre></td></tr></table></figure><p>该功能除了用于断点续传外，还可以实现并行下载加速。客户端可以起多个线程，建立多条 TCP 连接，每个线程下载一部分，最后把有的内容连到一直。就这么简单。</p><p>另外，HTTP/1.1 还要求客户端在请求的时候必须发送 Host 头信息。这里面保存着当前请求对应的网站域名。服务器收到请求后会根据 Host 里的域名和请求行里的路径来确定需要返回的内容。这样就能实现在同一个 IP 上搭建不同域名的网站，也就是所谓的虚拟主机。这大大降低了网站的建设成本，对 Web 生态的发展起到了至关重要的作用。</p><p>除了扩展 HTTP/1.0 原来的功能外，HTTP/1.1 还引入了连接升级功能。其实这个功能后面用的不多，但有一个重量级的协议 WebSocket 在用，所以不得不说。</p><p>所以连接升级就是把当前用于 HTTP 会话的 TCP 连接切换到其他协议。以 WebSocket 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: taoshu.in</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>这里把 Connection 设成了 Upgrade，表示希望切换协议。而 Upgrade:websocket 表示要切换到 websocket 协议。在切换之前，这还是一个普通的 HTTP 请求。服务器可以对该请求做各种鉴权等 HTTP 动作。服务器如果接受用户的请求，则会返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>从这一该起，双方就不能在该 TCP 连接上发送 HTTP 协议数据了。因为协议已经切换到 WebSocket。</p><p>从 1999 年开始，到 2015 年 HTTP/2 发布，HTTP 协议有15年的时候没有大的变化。与此同时，互联网蓬勃发展，从 Web 1.0 过渡到 Web 2.0，从 PC 互联网发展到移动互联网，从明文 HTTP 也切换到加密 HTTPS。整个过程 HTTP 协议都发挥了核心作用。这从侧面也说明 HTTP 协议是一种扩展性非常好的协议。</p><p>但 HTTP/1.1 毕竟是九十年代设计的协议。2010年之后，移动互联网兴起，业界希望对 HTTP 的问题做够进一步优化。那还有哪些问题可以优化呢？主要有几个方面：</p><ol><li>协议使用文本格式，传输和解析效率都比较低</li><li>Header 部分信息无法压缩，但现实情况是 Header 体积也不小（比如 cookie）</li><li>无法在单一 TCP 连接上并发请求资源（pipeline 失败了）</li><li>服务端无法主动给客户发送内容</li></ol><p>文本格式其实是 HTTP 的一大特色。我们在调试的时候可以直接使用 telnet 连接服务器，然后用肉眼看服务器的返回结果。但对人类友好的设计对机器一定不友好。HTTP协议使用<code>\r\n</code>作为分割符，双不限制头信息的数量，这必然导致解析的时候需要动态分配内存。而且还要把数字、日期等信息转换成对应的二进制格式，这都需要额外的解析成本。</p><p>HTTP/1.x 支持压缩数据内容，而且使用头信息保存压缩算法。所以就不能用相同的算法压缩头信息了。只能另辟蹊径。</p><p>HTTP/1.1 的 pipeline 已然失败，无法充分复用 TCP 连接。HTTP 从一开始就是请求应答式的设计，服务器没办法主动推送内容到客户端。</p><p>为了解决这几个问题，Google 挟 YouTube 和 Chrome 两大杀器，推出了 SPDY 协议。该协议有两个特点：</p><ol><li>兼容 HTTP 语义</li><li>使用二进行格式传输数据</li></ol><p>SPDY 引入了帧做为最小的传输单位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------+</span><br><span class="line">|                 Length (24)                   |</span><br><span class="line">+---------------+---------------+---------------+</span><br><span class="line">|   Type (8)    |   Flags (8)   |</span><br><span class="line">+-+-------------+---------------+-------------------------------+</span><br><span class="line">|R|                 Stream Identifier (31)                      |</span><br><span class="line">+&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+</span><br><span class="line">|                   Frame Payload (0...)                      ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">                      Figure 1: Frame Layout</span><br></pre></td></tr></table></figure><p>每一帧前三个字节表示数据长度，然后用一个字节表示类型，再用一个字节保存一些扩展标记。然后就是四个字节的 stream ID，最后是真正的数据。这其实就表明 HTTP 协议从分割符流转向了长度流。</p><p>在同一个 TCP 连接上，数据帧可以交替发送，不再受请求应答模式制约。也就是说服务端也可以主动给客户端发消息了。同一个请求的 header 和数据部分也可以分开发送，不再要求先发 header 再发 body。也正是因为数据帧交错传输，同一个会话下的数据需要能关联起来，所以 SPDY 给每一帧添加了 stram ID。换句话说 SPDY 在一个 TCP 连接上虚拟出了多个 stream，每一个 stream 从效果看都是一个 TCP 连接。不同的 HTTP 请求和响应数据可以使用自己的 stream 并发传输，互不影响。这样一下子就解决了上面的一、三和四这三个问题。</p><p>第二个问题比较麻烦。但解决思路也很简单。HTTP/1.x 的头信息都是 K-V 型的，而且都是字符串。这里的 K-V 都很少变化。比如只要是访问我的博客，不论有多少请求，都得发送 <code>Host: taoshu.in</code>。对于这种不变的，我们完全可以在两端各保存一张映射表，给每个 Key 和 Value 都指定一个编号。这样后续的请求只要传 Key 和 Value 的编号就行了，从而实现压缩的效果。单看 Host 可能不觉得有多少进步。但大家想想自己的 cookie，里面有登录会话信息，每次都重复发送浪费相当惊人。所以压缩头信息带来的优化还是惊人的。</p><p>因为谷歌一边控制着市场份额最大的 Chrome 浏览器，另一边又控制像 Google/YouTube 这样的内容服务，所以开发下一代 HTTP 协议便一件非常容易的事情。SPDY 于 2012 年发布，最终在 IETF 完成标准化，并于 2015 年发布，也就是<a href="https://datatracker.ietf.org/doc/html/rfc7540" target="_blank" rel="noopener">RFC7540</a>。</p><p>随着社会的发展，隐私保护成了人们关注的重要课题。为了保护用户信息，业界一真在推动 HTTP + TLS 也就是 HTTPS 的普及。HTTPS 服务使用 443 端口。我们前面讲过，HTTP/2 使用二进制编码，跟 HTTP/1.x 并不兼容。但客户端又不会一夜之间都升级的 HTTP/2。那怎么才能在一个端口上同时支持两种 HTTP 协议呢？这就用到了 TLS 协议的 ALPN 扩展。简单来说就是客户端在发起 TLS 会话的时候会通过 ALPN 扩展附带自己支持的应用层协议，比如 http/1.1 和 h2。服务端收到后会把自己支持的应用层协议返回给客户端。这样双方就能确定接下来在 TLS 会话是使用什么协议。</p><p>理论上 HTTP/2 可以通过 HTTP/1.1 的升级机制来协商，这样也能解决两个版本共用 TLS 会话的问题。但这种升级会再来额外的延迟，所以主流的浏览器都不支持。</p><p>HTTP/2 发布之后，整个业界都在积极迁移到新的协议。但实践证明，HTTP/2并没有想象中的那么好。为什么呢？因为对于同一个域名，浏览器默认只会开一个连接，所有请求都使用一个TCP连接收发。虽然不同的请求使用不同的 stream，但底层的连接只有一个。如果网络出现抖动，不论是哪一个请求的数据需要重传，其他请求的数据都必须等待。这就是所谓的 Head of Line blocking 问题。HTTP/2 非但没有优化，甚至还比 HTTP/1.x 还要差。因为在 HTTP/1.x 时代，浏览器自知 HTTP 无法复用连接，所以会为同一个域名创建多个 TCP 连接。不同的请求可能会分布到不同的连接上，出现网络抖动的影响比只用一个连接要好一点。</p><p>HTTP/2 的另一个问题就是功能太复杂。比如它支持在服务器主动推送资源（比如 CSS 文件）到浏览器，这样客户端在加载的时候就需要等待网络传输。但该功能非常复杂，而且效果有限，最终连 Chrome 自己都放弃支持该功能了。这部分功能被 HTTP 103 Early Hints 状态码代替，具体可以参考<a href="https://www.rfc-editor.org/rfc/rfc8297.html" target="_blank" rel="noopener">RFC8297</a>。</p><p>一计不成，再生一计。谷歌的工程师跟 Head of Line blocking 问题死磕。这次他们把矛头指向了问题的根源 TCP 协议。因为 TCP 是可靠传输协议，数据必须按顺序收发，而且要边确认边发送。如果底层用 TCP 连接，就不可能解决 Head of Line blocking 问题。为此，他们基于 UDP 协议设计了 QUIC 协议。</p><p>QUIC 协议简单来说就是一种面向消息的传输协议（TCP 是面向数据流的传输协议）。QUIC 也有 stream 的概念，每个会话可以有多个流。不同的流的数据都使用 UDP 收发，互不干扰。跟 TCP 一样，数据发出后也需要对方确认。然后再把 QUIC 跟 HTTP/2 的帧映射到一起，最终形成 HTTP/3 协议，也就是<a href="https://datatracker.ietf.org/doc/html/rfc9114" target="_blank" rel="noopener">RFC9114</a>。</p><p>那 QUIC 有没有问题呢？也有，但基本都不是设计上的问题。</p><p>第一个问题就是运营商可能对 UDP 流量做限流，很多防火墙可能会阻止 QUIC 流量。这是之前 UDP 通信使用不广泛导致的。 随着 HTTP/3 技术的普及，这些问题会逐渐改善。</p><p>第二个问题是 HTTP/3 启动延迟的问题。HTTP/3 使用 UDP 通信，跟 HTTP/1.x 和 HTTP/2 不兼容，所以浏览器没法判断服务器是否支持 HTTP/3。</p><p>目前主流的做法是网站同时支持 HTTP/2 和 HTTP/3。浏览器先通过过 TCP 连接访问服务器。服务器在第一个响应中返回一个特殊的 Header：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alt-Svc: h3&#x3D;&quot;:4430&quot;; ma&#x3D;3600</span><br></pre></td></tr></table></figure><p>这里的意思是在 UDP 的 4430 端口提供 HTTP/3 服务，该信息的有效时间为 3600 秒。后面浏览器就可以使用 QUIC 连接 4430 端口了。</p><p>明眼人一看就知道这里有问题，建立 HTTP/3 会话之前还得先用一下 HTTP/2 启动有把。这不科学🔬而且这会带来额外的耗时。为此，人们又开始想别的办法，这就是 DNS SVCB/HTTPS 记录。</p><p>DNS SVCB/HTTPS 简单来说就是用一种特殊的 DNS 记录把前面的 Alt-Svc 信息曝露出来。浏览器在访问网站之前先通过 DNS 查询是否支持 HTTP/3 以及对应的 UDP 端口，然后就直接发起 HTTP/3 会话就好。这样就完全不依赖 TCP 连接了。关于 DNS SVCB/HTTPS 记录的更多信息请看我的专门<a href="https://taoshu.in/dns-svcb-https.html" target="_blank" rel="noopener">文章</a>。</p><p>顺便说一句，HTTP/3 默认可以工作在任意 UDP 端口，不像 HTTPS 那样默认工作在 443 端口。如果运营商封掉 443 就没法对外服务。等 HTTP/3 普及了，所有人都可以使用自家的宽带搭建网站😄具体做法可以参考我的这篇<a href="https://taoshu.in/http3-port.html" target="_blank" rel="noopener">文章</a>。</p><p>好了，到现在快肝了一万字了。我认为基本讲清楚了 HTTP 协议的发展脉络。现于篇幅，没能详细讨论 HTTP/2 和 HTTP/3 的技术细节，不能说不是个遗憾。先开个坑，后面有时间再补上。希望本文能帮助你更好地理解 HTTP 协议。</p><p>参考链接：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP</a></li></ul><blockquote><p>本文转载自：「涛叔」，原文：<a href="https://taoshu.in/net/http.html" target="_blank" rel="noopener">https://taoshu.in/net/http.html</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP 全称 Hypertext Transfer Protocol，中文是超文本传输协议。网上讲 HTTP 协议的资料可以说是五花八门，但大多数都在罗列 HTTP 协议具体的规定，很少有讲 HTTP 协议这样设计的原因。今天我就尝试从解决问题的角度分析 HTTP 协议主要特性，希望能帮助大家快速理解 HTTP 协议。&lt;/p&gt;
&lt;p&gt;HTTP 是一种通过网络传输数据的协议。我们不希望数据在传输的过程中出现丢失或者损坏的问题。所以 HTTP 选用 TCP 作为底层网络协议，因为 TCP 是一种可靠的传输层协议。&lt;/p&gt;
&lt;p&gt;通信双方就建立 TCP 连接后立马发现一个新问题：服务端要给客户端发送什么数据呢？所以客户端必需在连接建立后将自己想要的内容发送给服务端，这就是所谓的「请求」，也就 HTTP Request。由此就确立了 HTTP 协议最根本的设计，即由客户端主导的请求应答式协议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="HTTP" scheme="https://www.hi-linux.com/tags/HTTP/"/>
    
      <category term="TCP" scheme="https://www.hi-linux.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>如何快速批量修改 Git 提交记录中的用户信息</title>
    <link href="https://www.hi-linux.com/posts/45540.html"/>
    <id>https://www.hi-linux.com/posts/45540.html</id>
    <published>2023-01-28T01:00:00.000Z</published>
    <updated>2023-01-28T08:18:17.096Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>内网提交需要校验企业邮箱，但有时邮箱设置错误导致 <code>commit</code> 的邮箱有问题，此时可以通过修改已提交记录中的邮箱来修复，无需重新提交。</p><p>经过检索，发现两种方法，分别适用于修改一次和修改多次，引文在最后都有注明。</p><a id="more"></a><h2><span id="修改最近一次提交的邮箱">修改最近一次提交的邮箱</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend --author&#x3D;&quot;NewAuthor &lt;NewEmail@address.com&gt;&quot;</span><br></pre></td></tr></table></figure><h2><span id="批量修改邮箱">批量修改邮箱</span></h2><p>使用该脚本，替换其中 <code>[Your Old Email]</code> <code>[Your New Author Name]</code> <code>[Your New Email]</code> 之后在 git 目录中执行即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">git filter-branch --env-filter &#39;</span><br><span class="line"></span><br><span class="line">an&#x3D;&quot;$GIT_AUTHOR_NAME&quot;</span><br><span class="line">am&#x3D;&quot;$GIT_AUTHOR_EMAIL&quot;</span><br><span class="line">cn&#x3D;&quot;$GIT_COMMITTER_NAME&quot;</span><br><span class="line">cm&#x3D;&quot;$GIT_COMMITTER_EMAIL&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; &#x3D; &quot;[Your Old Email]&quot; ]</span><br><span class="line">then</span><br><span class="line">    cn&#x3D;&quot;[Your New Author Name]&quot;</span><br><span class="line">    cm&#x3D;&quot;[Your New Email]&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; &#x3D; &quot;[Your Old Email]&quot; ]</span><br><span class="line">then</span><br><span class="line">    an&#x3D;&quot;[Your New Author Name]&quot;</span><br><span class="line">    am&#x3D;&quot;[Your New Email]&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export GIT_AUTHOR_NAME&#x3D;&quot;$an&quot;</span><br><span class="line">export GIT_AUTHOR_EMAIL&#x3D;&quot;$am&quot;</span><br><span class="line">export GIT_COMMITTER_NAME&#x3D;&quot;$cn&quot;</span><br><span class="line">export GIT_COMMITTER_EMAIL&#x3D;&quot;$cm&quot;</span><br></pre></td></tr></table></figure><h2><span id="qampa">Q&amp;A</span></h2><ul><li><code>A previous backup already exists in refs/original/</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cannot create a new backup.</span><br><span class="line">A previous backup already exists in refs&#x2F;original&#x2F;</span><br><span class="line">Force overwriting the backup with -f</span><br></pre></td></tr></table></figure><p>出现这一句说明之前曾经执行过 <code>git filter-branch</code> ，在 <code>refs/original/</code> 有一个备份，这个时候只要删掉那个备份即可，删除备份命令为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref -d refs&#x2F;original&#x2F;refs&#x2F;heads&#x2F;master</span><br><span class="line"># 或</span><br><span class="line">$ git filter-branch -f --tree-filter -f &#39;rm -f test&#39; -- --all</span><br></pre></td></tr></table></figure><h2><span id="参考文献">参考文献</span></h2><ul><li><a href="https://blog.csdn.net/diu_brother/article/details/51982993" target="_blank" rel="noopener">git 修改提交作者和邮箱</a></li><li><a href="https://blog.csdn.net/u013202238/article/details/81557710" target="_blank" rel="noopener">git 修改历史提交的用户名和邮箱</a></li></ul><blockquote><p>本文转载自：「Frytea’s Blog」，原文：<a href="https://url.hi-linux.com/MEm0k/" target="_blank" rel="noopener">https://url.hi-linux.com/MEm0k/</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "10135-1588830050631-449",        "name": "「奇妙的 Linux 世界」",        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",        "keyword": "VIP"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内网提交需要校验企业邮箱，但有时邮箱设置错误导致 &lt;code&gt;commit&lt;/code&gt; 的邮箱有问题，此时可以通过修改已提交记录中的邮箱来修复，无需重新提交。&lt;/p&gt;
&lt;p&gt;经过检索，发现两种方法，分别适用于修改一次和修改多次，引文在最后都有注明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.hi-linux.com/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://www.hi-linux.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://www.hi-linux.com/tags/Linux/"/>
    
      <category term="Git" scheme="https://www.hi-linux.com/tags/Git/"/>
    
  </entry>
  
</feed>
