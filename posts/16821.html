<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="Linux,运维,Nginx,Zabbix,Centos,Ansible,MySQL,Python,Docker,ELK,Haproxy,Git,Nodejs,安全,技术">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          一文搞懂 4 种常用的 Kubernetes 容器 - 奇妙的 Linux 世界
        
    </title>

    <link rel="canonical" href="https://www.hi-linux.com/posts/16821.html">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
<link rel="stylesheet" href="/css/beantech.min.css">

    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/toc.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="奇妙的 Linux 世界" type="application/atom+xml">
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/building.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                            
                              <a class="tag" href="/tags/#Docker" title="Docker">Docker</a>
                            
                              <a class="tag" href="/tags/#Kubernetes" title="Kubernetes">Kubernetes</a>
                            
                        </div>
                        <h1>一文搞懂 4 种常用的 Kubernetes 容器</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Mike on
                            2021-07-30
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">奇妙的 Linux 世界</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <div id="vip-container"><p>截止目前 Kubernetes 1.18，Kubernetes 已经支持标准容器，Sidecar 容器，Init 容器，Ephemeral 容器 4 种类型的 Containers。本文我们详细介绍一下这 4 种容器的特性以及使用场景。</p>
<p><img src="https://pic2.zhimg.com/80/v2-fac0971dbc8d39235d81ffb07eb9c7cd_720w.jpg" alt></p>
<h2><span id="标准容器和-sidecar-容器">标准容器和 Sidecar 容器</span></h2>
<p>在  Kubernetes 1.18 之前，这两种容器从 Kubernetes 管理的角度来看，并没有什么区别。只不过人为从功能上做了区分。</p>
<p><img src="https://img.hi-linux.com/staticfile/v2-7240d284cc8376172e49e8105953d726_720w-2021-06-25-Spz7c6.jpg" alt></p>
<h3><span id="使用-sidecar-容器模块化具有的优点">使用 Sidecar 容器（模块化）具有的优点</span></h3>
<ul>
<li>加速应用程序开发，因为容器可以在团队甚至更大的社区之间重复使用</li>
<li>整理专家知识，因为每个人都在一个容器化的实现上进行协作，该实现反映了最佳实践，而不是无数种功能大致相同的自家生产的不同容器</li>
<li>启用敏捷团队，因为容器边界是自然边界，是团队职责的契约</li>
<li>提供关注点分离，并专注于特定功能，以减少意大利面条的依赖性和不可测的组件</li>
</ul>
<h3><span id="对于-sidecar-容器一般来说主要体现在以下-4-种角色">对于 Sidecar 容器一般来说主要体现在以下 4 种角色：</span></h3>
<ul>
<li>代理</li>
</ul>
<p>例如现在 Istio 中 的 Envoy。</p>
<p><img src="https://img.hi-linux.com/staticfile/v2-b134721a06da744cea35d5a399a3d857_720w-2021-06-25-ihOQPI.jpg" alt></p>
<p>通过这种 Sidercar 模式，代理可以拦截进出主容器的流量从而 Istio 可以提取有关流量行为的大量信号作为属性。 Istio 可以使用这些属性来执行策略决策，并将其发送到监视系统以提供有关整个网格行为的信息。</p>
<p>Sidecar 代理模型还允许您将 Istio 功能添加到现有部署中，而无需重新构造或重写代码。</p>
<ul>
<li>适配器</li>
</ul>
<p>适配器容器对输出进行标准化。考虑监视 N 个不同应用程序的任务。可以使用不同的导出监视数据的方式来构建每个应用程序。（例如 JMX，StatsD，特定于应用程序的统计信息），但每个监控系统都希望其收集的监控数据具有一致且统一的数据模型。</p>
<p>通过使用复合容器的适配器模式，您可以通过创建 Pod 来将来自不同系统的异构监视数据转换为一个统一的表示形式，该 Pod 将应用程序容器与知道如何进行转换的适配器分组在一起。同样，由于这些 Pod 共享名称空间和文件系统，因此这两个容器的协调非常简单明了。</p>
<p><img src="https://pic1.zhimg.com/80/v2-eab449fd16b6fb03512cbb7c6153fd60_720w.jpg" alt></p>
<ul>
<li>增强主容器功能</li>
</ul>
<p>Sidecar 容器扩展并增强了 “主” 容器，它们可以使用现有的容器并使它们变得更好。</p>
<p>例如，考虑一个运行 Nginx Web 服务器的容器。添加另一个将文件系统与 Git 存储库同步的容器，在这些容器之间共享文件系统，并且您已经构建了 Git Push-to-deploy。但是您已经以模块化的方式完成了此工作，其中 Git 同步器可以由不同的团队构建，并且可以在许多不同的Web服务器（Apache，Python，Tomcat等）上重复使用。</p>
<p>由于这种模块化，您只需编写和测试 Git 同步器一次，即可在众多应用程序中重复使用它。而且，如果有人编写它，您甚至不需要这样做。</p>
<ul>
<li>实现辅助功能</li>
</ul>
<p>这种场景一般出现在 DevOps 中。比如将收集日志的组件以 Sidecar 的方式部署，实现收集日志的用途，或是部署一个 Sidecar 组件从配置中心监听配置变化，实时更新本地配置。</p>
<h3><span id="生命周期">生命周期</span></h3>
<p>Sidecar 容器的所有问题都与容器生命周期相关性有关。由于和 Pod 中的常规容器之间没有区别，因此无法控制哪个容器首先启动或最后终止，但是先正确运行 Sidecar 容器通常是应用程序容器正确运行的要求。</p>
<p>从 1.18 版本开始，K8S 内置的 Sidecar 功能将确保 Sidecar 容器在正常业务流程开始之前就启动并运行，即通过更改 Pod 的启动生命周期，在 Init 容器完成后启动 Sidecar 容器，在 Sidecar 容器就绪后启动业务容器，从启动流程上保证顺序性。</p>
<p><img src="https://img.hi-linux.com/staticfile/v2-1389722cbb68cad9a4673ca4f3d918d7_b-2021-06-25-1nAhaU.jpg" alt></p>
<p>通过更改 Pod 规范中的 <code>container.lifecycle.type</code> 将容器标记为 Sidecar 类型：<code>Sidecar</code>，默认为 <code>Standard</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: bookings-v1-b54bc7c9c-v42f6</span><br><span class="line">  labels:</span><br><span class="line">    app: demoapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: bookings</span><br><span class="line">    image: banzaicloud&#x2F;allspark:0.1.1</span><br><span class="line">    ...</span><br><span class="line">  - name: istio-proxy</span><br><span class="line">    image: docker.io&#x2F;istio&#x2F;proxyv2:1.4.3</span><br><span class="line">    lifecycle:</span><br><span class="line">      type: Sidecar</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h2><span id="init-容器">Init 容器</span></h2>
<p>在 Kubernetes 中，Init 容器是在同一 Pod 中的其他容器之前开始并执行的容器。它旨在为 Pod 上托管的主应用程序执行初始化逻辑。例如，创建必要的用户帐户，执行数据库迁移，创建数据库结构等。</p>
<p>Init 容器与普通的容器非常像，除了如下两点：</p>
<ul>
<li>它们总是运行到完成。</li>
<li>每个都必须在下一个启动之前成功完成。</li>
</ul>
<h3><span id="与普通容器的不同之处">与普通容器的不同之处</span></h3>
<p></p>
<ul>
<li>Init 容器支持应用容器的全部字段和特性，包括资源限制、数据卷和安全设置。 然而，Init 容器对资源请求和限制的处理稍有不同。</li>
<li>同时 Init 容器不支持 Readiness Probe，因为它们必须在 Pod 就绪之前运行完成。</li>
<li>如果为一个 Pod 指定了多个 Init 容器，这些容器会按顺序逐个运行。每个 Init 容器必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时，Kubernetes 才会为 Pod 初始化应用容器并像平常一样运行。</li>
</ul>
<h3><span id="init-容器作用">Init 容器作用</span></h3>
<p>因为 Init 容器具有与应用容器分离的单独镜像，其启动相关代码具有如下优势：</p>
<ul>
<li>Init 容器可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码。例如，没有必要仅为了在安装过程中使用类似 sed、 awk、 python 或 dig 这样的工具而去FROM 一个镜像来生成一个新的镜像。</li>
<li>Init 容器可以安全地运行这些工具，避免这些工具导致应用镜像的安全性降低。</li>
<li>应用镜像的创建者和部署者可以各自独立工作，而没有必要联合构建一个单独的应用镜像。</li>
<li>Init 容器能以不同于Pod内应用容器的文件系统视图运行。因此，Init容器可具有访问 Secrets 的权限，而应用容器不能够访问。</li>
<li>由于 Init 容器必须在应用容器启动之前运行完成，因此 Init 容器提供了一种机制来阻塞或延迟应用容器的启动，直到满足了一组先决条件。一旦前置条件满足，Pod内的所有的应用容器会并行启动。</li>
</ul>
<h3><span id="创建-initcontainer-时应考虑一些注意事项">创建 InitContainer 时应考虑一些注意事项：</span></h3>
<ul>
<li>它们总是在 Pod 中的其他容器之前执行。因此，它们不应包含需要很长时间才能完成的复杂逻辑。启动脚本通常很小而简洁。如果发现要向初始化容器添加太多逻辑，则应考虑将其中的一部分移至应用程序容器本身。</li>
<li>初始化容器按顺序启动和执行。除非一个初始化容器被成功执行，否则下一个初始化容器不会被开始执行。因此，如果启动任务很长，则可以考虑将其分为多个步骤，每个步骤都由一个初始化容器处理，以便您知道哪些步骤失败。</li>
<li>如果任何初始化容器失败，则将重新启动整个 Pod（除非您将 restartPolicy 设置为 Never）。重新启动 Pod 意味着再次重新执行所有容器，包括任何初始化容器。因此，您可能需要确保启动逻辑允许多次执行而不会导致重复。例如，如果数据库迁移已经完成，则应仅忽略再次执行迁移命令。</li>
<li>初始化容器是延迟应用程序初始化直到一个或多个依赖项可用的很好的选择。例如，如果您的应用程序依赖于施加API请求速率限制的 API，则您可能需要等待一段时间才能接收来自该 API 的响应。在应用程序容器中实现此逻辑可能很复杂；因为它需要与健康和就绪状态探测器结合使用。一种更简单的方法是创建一个初始化容器，该容器要等到API准备好后才能成功退出。只有在初始化容器成功完成其工作之后，应用程序容器才会启动。</li>
<li>初始化容器不能像应用程序容器那样使用运行状况和就绪探针。原因是它们要成功启动和退出，就像 Jobs 和 CronJobs 的行为一样。</li>
<li>同一Pod 上的所有容器共享相同的卷和网络。您可以利用此功能在应用程序及其初始化容器之间共享数据。</li>
</ul>
<blockquote>
<p>正如我们刚刚讨论的那样，Init 容器总是比同一个 Pod 上的其他应用程序容器先启动。结果，调度程序对 Init 容器的资源和限制赋予了更高的优先级。必须仔细考虑这种行为，因为这可能会导致不良后果。例如，如果您有一个初始化容器和一个应用程序容器，并且将初始化容器的资源和限制设置为高于应用程序容器的资源和限制，那么只有在有一个可用节点满足初始化的情况下，才调度整个 Pod 容器要求。换句话说，即使有一个未使用的节点可以在其中运行应用程序容器，但如果初始化容器具有该节点可以处理的更高资源先决条件，则 Pod 也不会部署到该节点。因此，在定义初始化容器的请求和限制时，您应尽可能严格。最佳做法是，除非绝对必要，否则请勿将这些参数设置为高于应用程序容器的值。</p>
</blockquote>
<h3><span id="使用-init-容器">使用 Init 容器</span></h3>
<p>下面的例子定义了一个具有 2 个 Init 容器的简单 Pod。 第一个等待 myservice 启动，第二个等待 mydb 启动。 一旦这两个 Init容器 都启动完成，Pod 将启动 spec 区域中的应用容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-pod</span><br><span class="line">  labels:</span><br><span class="line">    app: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp-container</span><br><span class="line">    image: busybox:1.28</span><br><span class="line">    command: [&#39;sh&#39;, &#39;-c&#39;, &#39;echo The app is running! &amp;&amp; sleep 3600&#39;]</span><br><span class="line">  initContainers:</span><br><span class="line">  - name: init-myservice</span><br><span class="line">    image: busybox:1.28</span><br><span class="line">    command: [&#39;sh&#39;, &#39;-c&#39;, &quot;until nslookup myservice.$(cat &#x2F;var&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount&#x2F;namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&quot;]</span><br><span class="line">  - name: init-mydb</span><br><span class="line">    image: busybox:1.28</span><br><span class="line">    command: [&#39;sh&#39;, &#39;-c&#39;, &quot;until nslookup mydb.$(cat &#x2F;var&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount&#x2F;namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&quot;]</span><br></pre></td></tr></table></figure>
<p>这是 Kubernetes 1.6 版本的新语法，尽管老的 annotation 语法仍然可以使用。我们已经把 Init 容器的声明移到 spec 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-pod</span><br><span class="line">  labels:</span><br><span class="line">    app: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp-container</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [&#39;sh&#39;, &#39;-c&#39;, &#39;echo The app is running! &amp;&amp; sleep 3600&#39;]</span><br><span class="line">  initContainers:</span><br><span class="line">  - name: init-myservice</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [&#39;sh&#39;, &#39;-c&#39;, &#39;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#39;]</span><br><span class="line">  - name: init-mydb</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [&#39;sh&#39;, &#39;-c&#39;, &#39;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#39;]</span><br></pre></td></tr></table></figure>
<p>1.5 版本的语法在 1.6 版本仍然可以使用，但是我们推荐使用 1.6 版本的新语法。 在 Kubernetes 1.6 版本中，Init 容器在 API 中新建了一个字段。 虽然期望使用 beta 版本的 annotation，但在未来发行版将会被废弃掉。</p>
<p>在所有的 Init 容器没有成功之前，Pod 将不会变成 Ready 状态。 Init 容器的端口将不会在 Service 中进行聚集。 正在初始化中的 Pod 处于 Pending 状态，但应该会将条件 Initializing 设置为 true。</p>
<p>如果 Pod 重启，所有 Init 容器必须重新执行。</p>
<p>对 Init 容器 spec 的修改，被限制在容器 image 字段中。 更改 Init 容器的 image 字段，等价于重启该 Pod。</p>
<h3><span id="ephemeral-容器">Ephemeral 容器</span></h3>
<p>临时容器与其他容器的不同之处在于，它们缺少对资源或执行的保证，并且永远不会自动重启，因此不适用于构建应用程序。临时容器使用与常规容器相同的 <code>ContainerSpec</code> 段进行描述，但许多字段是不相容且不允许的。</p>
<ul>
<li>临时容器没有端口配置，因此像 <code>ports</code>，<code>livenessProbe</code>，<code>readinessProbe</code> 这样的字段是不允许的。</li>
<li>Pod 资源分配是不可变的，因此 <code>resources</code> 配置是不允许的。</li>
<li>有关允许字段的完整列表，请参见<a href="https://link.zhihu.com/?target=https%3A//kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/%23ephemeralcontainer-v1-core">临时容器参考文档</a>。</li>
</ul>
<p>临时容器是使用 API 中的一种特殊的 <code>ephemeralcontainers</code> 处理器进行创建的，而不是直接添加到 <code>pod.spec</code> 段，因此无法使用 <code>kubectl edit</code> 来添加一个临时容器。</p>
<p>与常规容器一样，将临时容器添加到 Pod 后，将不能更改或删除临时容器。</p>
<h3><span id="为什么我们需要-ephemeral-容器">为什么我们需要 Ephemeral 容器？</span></h3>
<p>我们知道容器的优点是它们通过使用不变方法提供所有必需的依赖项来运行隔离的进程。通过仅将所需的依赖项添加到镜像中，容器可以降低攻击面并提供更快的启动和部署。使用 “distroless” 方法构建容器镜像（基于 Scratch ），通过仅包含已编译的应用程序二进制文件，将容器镜像提升到了一个新的水平。与普通的容器镜像不同，它们不基于任何种类的 Linux 发行版，因此不包含任何其他可通过 <code>kubectl exec</code>  执行以进行故障排除的二进制文件和工具。这就决定了该容器有助于提供安全可靠的运行时环境，但也很难在问题发生时进行调试。</p>
<p>在这种情况下，临时容器发挥作用。它们实现了调试容器附加到主进程的功能，然后你可以用于调试任何类型的问题。调试容器可以基于任何镜像，因此可以根据您的需求进行定制。您可以构建自己的调试镜像，其中包含特殊的调试二进制文件或仅包含 curl，OpenSSL 和 MongoDB客户端之类的工具。但是，您也可以选择Linux发行版（如Ubuntu）或仅运行Busybox镜像，这两个镜像都已经包含了许多有用的工具。</p>
<h3><span id="如何使用临时容器">如何使用临时容器？</span></h3>
<p>临时容器是alpha功能，因此默认情况下处于禁用状态。您将需要激活以下功能门才能使用它们：</p>
<ul>
<li>临时容器</li>
<li>PodShareProcessNamespace（v1.16中的beta版，因此默认情况下已启用）</li>
</ul>
<p>本节中的示例演示了临时容器如何出现在 API 中。 通常，您可以使用 <code>kubectl</code> 插件进行故障排查，从而自动化执行这些步骤。</p>
<p>临时容器是使用 Pod 的 <code>ephemeralcontainers</code> 子资源创建的，可以使用 <code>kubectl --raw</code> 命令进行显示。首先描述临时容器被添加为一个 <code>EphemeralContainers</code> 列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">    &quot;kind&quot;: &quot;EphemeralContainers&quot;,</span><br><span class="line">    &quot;metadata&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;example-pod&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ephemeralContainers&quot;: [&#123;</span><br><span class="line">        &quot;command&quot;: [</span><br><span class="line">            &quot;sh&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;image&quot;: &quot;busybox&quot;,</span><br><span class="line">        &quot;imagePullPolicy&quot;: &quot;IfNotPresent&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;debugger&quot;,</span><br><span class="line">        &quot;stdin&quot;: true,</span><br><span class="line">        &quot;tty&quot;: true,</span><br><span class="line">        &quot;terminationMessagePolicy&quot;: &quot;File&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下命令更新已运行的临时容器 <code>example-pod</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl replace --raw &#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods&#x2F;example-pod&#x2F;ephemeralcontainers  -f ec.json</span><br></pre></td></tr></table></figure>
<p>这将返回临时容器的新列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;kind&quot;:&quot;EphemeralContainers&quot;,</span><br><span class="line">   &quot;apiVersion&quot;:&quot;v1&quot;,</span><br><span class="line">   &quot;metadata&quot;:&#123;</span><br><span class="line">      &quot;name&quot;:&quot;example-pod&quot;,</span><br><span class="line">      &quot;namespace&quot;:&quot;default&quot;,</span><br><span class="line">      &quot;selfLink&quot;:&quot;&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods&#x2F;example-pod&#x2F;ephemeralcontainers&quot;,</span><br><span class="line">      &quot;uid&quot;:&quot;a14a6d9b-62f2-4119-9d8e-e2ed6bc3a47c&quot;,</span><br><span class="line">      &quot;resourceVersion&quot;:&quot;15886&quot;,</span><br><span class="line">      &quot;creationTimestamp&quot;:&quot;2019-08-29T06:41:42Z&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;ephemeralContainers&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;name&quot;:&quot;debugger&quot;,</span><br><span class="line">         &quot;image&quot;:&quot;busybox&quot;,</span><br><span class="line">         &quot;command&quot;:[</span><br><span class="line">            &quot;sh&quot;</span><br><span class="line">         ],</span><br><span class="line">         &quot;resources&quot;:&#123;</span><br><span class="line"></span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;terminationMessagePolicy&quot;:&quot;File&quot;,</span><br><span class="line">         &quot;imagePullPolicy&quot;:&quot;IfNotPresent&quot;,</span><br><span class="line">         &quot;stdin&quot;:true,</span><br><span class="line">         &quot;tty&quot;:true</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用以下命令查看新创建的临时容器的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod example-pod</span><br><span class="line">...</span><br><span class="line">Ephemeral Containers:</span><br><span class="line">  debugger:</span><br><span class="line">    Container ID:  docker:&#x2F;&#x2F;cf81908f149e7e9213d3c3644eda55c72efaff67652a2685c1146f0ce151e80f</span><br><span class="line">    Image:         busybox</span><br><span class="line">    Image ID:      docker-pullable:&#x2F;&#x2F;busybox@sha256:9f1003c480699be56815db0f8146ad2e22efea85129b5b5983d0e0fb52d9ab70</span><br><span class="line">    Port:          &lt;none&gt;</span><br><span class="line">    Host Port:     &lt;none&gt;</span><br><span class="line">    Command:</span><br><span class="line">      sh</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Thu, 29 Aug 2019 06:42:21 +0000</span><br><span class="line">    Ready:          False</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:         &lt;none&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以使用以下命令连接到新的临时容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl attach -it example-pod -c debugger</span><br></pre></td></tr></table></figure>
<p>如果启用了进程命名空间共享，则可以查看该 Pod 所有容器中的进程。 例如，运行上述 <code>attach</code> 操作后，在调试器容器中运行 <code>ps</code> 操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在 &quot;debugger&quot; 临时容器内中运行此 shell 命令</span><br><span class="line">$ ps auxww</span><br></pre></td></tr></table></figure>
<p>运行命令后，输出类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 &#x2F;pause</span><br><span class="line">    6 root      0:00 nginx: master process nginx -g daemon off;</span><br><span class="line">   11 101       0:00 nginx: worker process</span><br><span class="line">   12 101       0:00 nginx: worker process</span><br><span class="line">   13 101       0:00 nginx: worker process</span><br><span class="line">   14 101       0:00 nginx: worker process</span><br><span class="line">   15 101       0:00 nginx: worker process</span><br><span class="line">   16 101       0:00 nginx: worker process</span><br><span class="line">   17 101       0:00 nginx: worker process</span><br><span class="line">   18 101       0:00 nginx: worker process</span><br><span class="line">   19 root      0:00 &#x2F;pause</span><br><span class="line">   24 root      0:00 sh</span><br><span class="line">   29 root      0:00 ps auxww</span><br></pre></td></tr></table></figure>
<h3><span id="总结">总结</span></h3>
<p>本文简单介绍了标准容器，Sidecar 容器，Init 容器，Ephemeral 容器 4 种类型的 Containers。随着 Kubernetes 日益普及，我们需要充分掌握这几种类型容器原理和使用方法，才能更好地服务业务。</p>
<p>此外 Sidecar 容器将会成为未来软件交付的一种新的方式，参照 Dapr 等，不同的团队提供自己的功能容器，然后选择性注入 Sidecar 到主业务容器，实现解耦。</p>
<h2><span id="参考文档">参考文档</span></h2>
<ol>
<li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/145233597" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/145233597</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1645954" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1645954</a></li>
</ol>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "10135-1588830050631-449",
			        "name": "「奇妙的 Linux 世界」",
			        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",
			        "keyword": "VIP"
			    });
			}
			</script>
		
                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/posts/4939.html" data-toggle="tooltip" data-placement="top" title="推荐一款快速安装 macOS 的开源脚本 (全平台、多版本支持，可免费下载！）">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/posts/4224.html" data-toggle="tooltip" data-placement="top" title="超赞，腾讯开源运维必备海量服务器管理系统！">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                
                    <!-- disqus 评论框 start -->
                    <div class="comment">
                        <div id="lv-container" data-id="city" data-uid="MTAyMC8yNzg2My80NDQw"></div>
                    </div>
                    <!-- disqus 评论框 end -->
                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">标准容器和 Sidecar 容器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">使用 Sidecar 容器（模块化）具有的优点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">对于 Sidecar 容器一般来说主要体现在以下 4 种角色：</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">生命周期</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">Init 容器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">与普通容器的不同之处</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">Init 容器作用</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">创建 InitContainer 时应考虑一些注意事项：</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">使用 Init 容器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.5.</span> <span class="toc-nav-text">Ephemeral 容器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.6.</span> <span class="toc-nav-text">为什么我们需要 Ephemeral 容器？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.7.</span> <span class="toc-nav-text">如何使用临时容器？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.8.</span> <span class="toc-nav-text">总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">参考文档</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                        
                          <a class="tag" href="/tags/#Docker" title="Docker">Docker</a>
                        
                          <a class="tag" href="/tags/#Kubernetes" title="Kubernetes">Kubernetes</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://www.mike.org.cn/" target="_blank">简单.生活</a></li>
                    
                        <li><a href="http://shang.qq.com/wpa/qunwpa?idkey=ea4c43493c2269428ac6ef6141de4b6d78e5ab2d41380ca4099b833b62884ee9" target="_blank">技术交流群</a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






    <!-- 来必力City版公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
       (function(d, s) {
           var j, e = d.getElementsByTagName(s)[0];
    
           if (typeof LivereTower === 'function') { return; }
    
           j = d.createElement(s);
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;
    
           e.parentNode.insertBefore(j, e);
       })(document, 'script');
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    <!-- 来必力City版 公共JS代码 end -->



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                    <li>
                        <a href="/atom.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/80imike">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/2093524665">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Mike 2022 | Hosted by <a href="https://pages.coding.me" target="_blank" rel="noopener" style="font-weight: bold">Coding Pages</a>
                    <br>
                    Theme by <a href="http://beantech.org" target="_blank" rel="noopener">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://www.huweihuang.com" target="_blank" rel="noopener">胡伟煌</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huweihuang&repo=hexo-theme-huweihuang&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://www.hi-linux.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->



<script async defer data-website-id="0d8da2a4-a24e-4240-9304-00a6e347ddfe"
    src="https://umami.hi-linux.com/umami.js"></script>



	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://www.hi-linux.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script>(function(w,d, s, id) {w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js, fjs = d.getElementsByTagName(s)[0];js = d.createElement(s); js.id = id;js.src = 'https://cdn.webpushr.com/app.min.js';fjs.parentNode.appendChild(js);}(window,document, 'script', 'webpushr-jssdk'));webpushr('init','BF9JK7xV9kjWTdMx2lr6RWaPfXV7wNuZaVAJ1bfIGoBNJavqLEBVFMKLubITnCA4bh2fI9iH9tMF95nXnPt7xxY');</script></body>

</html>
