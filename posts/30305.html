<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="Linux,运维,Nginx,Zabbix,Centos,Ansible,MySQL,Python,Docker,ELK,Haproxy,Git,Nodejs,安全,技术">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          从 Kubectl run 开始揭开 Kubernetes 的神迷面纱 - 奇妙的 Linux 世界
        
    </title>

    <link rel="canonical" href="https://www.hi-linux.com/posts/30305.html">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
<link rel="stylesheet" href="/css/beantech.min.css">

    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/toc.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="奇妙的 Linux 世界" type="application/atom+xml">
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/article.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                            
                              <a class="tag" href="/tags/#Kubernetes" title="Kubernetes">Kubernetes</a>
                            
                        </div>
                        <h1>从 Kubectl run 开始揭开 Kubernetes 的神迷面纱</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Mike on
                            2018-08-08
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">奇妙的 Linux 世界</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <div id="vip-container"><p>想象一下，如果我想将 <code>Nginx</code> 部署到 <code>Kubernetes</code> 集群，我可能会在终端中输入类似这样的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run --image&#x3D;nginx --replicas&#x3D;3</span><br></pre></td></tr></table></figure>
<p>然后回车。几秒钟后，你就会看到三个 <code>Nginx Pod</code> 分布在所有的工作节点上。这一切就像变魔术一样，但你并不知道这一切的背后究竟发生了什么事情。</p>
<p><code>Kubernetes</code> 的神奇之处在于：它可以通过用户友好的 <code>API</code> 来处理跨基础架构的 <code>Deployments</code>，而背后的复杂性被隐藏在简单的抽象中。但为了充分理解它为我们提供的价值，我们需要理解它的内部原理。</p>
<p>本指南将引导您理解从 <code>Client</code> 到 <code>Kubelet</code> 请求的完整生命周期，必要时会通过源代码来说明背后发生了什么。</p>
<p>这是一份可以在线修改的文档，如果你发现有什么可以改进或重写的，欢迎提供帮助！</p>
<h3><span id="1-kubectl">1. Kubectl</span></h3>
<p><strong>验证和生成器</strong></p>
<p>当敲下回车键以后，<code>Kubectl</code> 首先会执行一些客户端验证操作，以确保不合法的请求（例如：创建不支持的资源或使用格式错误的镜像名称）将会快速失败，也不会发送给 <code>Kube-Apiserver</code>。通过减少不必要的负载来提高系统性能。</p>
<p>验证通过之后，<code>Kubectl</code> 开始将发送给 <code>Kube-Apiserver</code> 的 <code>HTTP</code> 请求进行封装。<code>Kube-Apiserver</code> 与 <code>Etcd</code> 进行通信，所有尝试访问或更改 <code>Kubernetes</code> 系统状态的请求都会通过 <code>Kube-Apiserver</code> 进行，<code>Kubectl</code> 也不例外。<code>Kubectl</code> 使用生成器（<a href="https://kubernetes.io/docs/user-guide/kubectl-conventions/#generators" target="_blank" rel="noopener">Generators</a>）来构造 <code>HTTP</code> 请求。生成器是一个用来处理序列化的抽象概念。</p>
<p>通过 <code>kubectl run</code> 不仅可以运行 <code>Deployment</code>，还可以通过指定参数 <code>--generator</code> 来部署其他多种资源类型。如果没有指定 <code>--generator</code> 参数的值，<code>Kubectl</code> 将会自动判断资源的类型。</p>
<p>例如：带有参数 <code>--restart-policy=Always</code> 的资源将被部署为 <code>Deployment</code>，而带有参数 <code>--restart-policy=Never</code> 的资源将被部署为 <code>Pod</code>。同时 <code>Kubectl</code> 也会检查是否需要触发其他操作，例如：记录命令（用来进行回滚或审计）。</p>
<p>在 <code>Kubectl</code> 判断出要创建一个 <code>Deployment</code> 后，它将使用 <code>DeploymentV1Beta1</code> 生成器从我们提供的参数中生成一个运行时对象。</p>
<a id="more"></a>
<p><strong>API 版本协商与 API 组</strong></p>
<p>为了更容易地消除字段或者重新组织资源结构，<code>Kubernetes</code> 支持多个 <code>API</code> 版本，每个版本都在不同的 <code>API</code> 路径下，例如 <code>/api/v1</code> 或者 <code>/apis/extensions/v1beta1</code>。不同的 <code>API</code> 版本表明不同的稳定性和支持级别，更详细的描述可以参考 <a href="https://k8smeetup.github.io/docs/reference/api-overview/" target="_blank" rel="noopener">Kubernetes API 概述</a>。</p>
<p><code>API</code> 组主要作用是对类似资源进行分类，以便使得 <code>Kubernetes API</code> 更容易扩展。<code>API</code> 的组别在 <code>REST</code> 路径或者序列化对象的 <code>apiVersion</code> 字段中指定。例如：<code>Deployment</code> 的 <code>API</code> 组名是 <code>apps</code>，最新的 <code>API</code> 版本是 <code>v1beta2</code>，这就是为什么你要在 <code>Deployment manifests</code> 顶部输入 <code>apiVersion: apps/v1beta2</code>。</p>
<p><code>Kubectl</code> 在生成运行时对象后，开始为它找到适当的 <code>API</code> 组和 <code>API</code> 版本，然后组装成一个版本化客户端，该客户端知道资源的各种 <code>REST</code> 语义。该阶段被称为版本协商，<code>Kubectl</code> 会扫描 <code>Remote API</code> 上的 <code>/apis</code> 路径来检索所有可能的 <code>API</code> 组。由于 <code>Kube-Apiserver</code> 在 <code>/apis</code> 路径上公开了 <code>OpenAPI</code> 格式的模式文档， 因此客户端很容易找到合适的 <code>API</code>。</p>
<p>为了提高性能，<code>Kubectl</code> 将 <code>OpenAPI</code> 模式缓存到了 <code>~/.kube/cache</code> 目录。如果你想了解 <code>API</code> 发现的过程，请尝试删除该目录并在运行 <code>kubectl</code> 命令时将 <code>-v</code> 参数的值设为最大值，然后你将会看到所有试图找到这些 <code>API</code> 版本的 <code>HTTP</code> 请求。参考 <a href="https://k8smeetup.github.io/docs/reference/kubectl/cheatsheet/" target="_blank" rel="noopener">Kubectl 备忘单</a>。</p>
<p>最后一步才是真正地发送 <code>HTTP</code> 请求。一旦请求发送之后获得成功的响应，<code>Kubectl</code> 将会根据所需的输出格式打印 Success Message。</p>
<p><strong>客户端身份认证</strong></p>
<p>在发送 <code>HTTP</code> 请求之前还要进行客户端认证，这是之前没有提到的，现在可以来看一下。</p>
<p>为了能够成功发送请求，<code>Kubectl</code> 需要先进行身份认证。用户凭证保存在 <code>Kubeconfig</code> 文件中，<code>Kubectl</code> 通过以下顺序来找到 <code>Kubeconfig</code> 文件：</p>
<ul>
<li>如果提供了 <code>--kubeconfig</code> 参数， <code>Kubectl</code> 就使用 <code>--kubeconfig</code> 参数提供的 <code>Kubeconfig</code> 文件。</li>
<li>如果没有提供 <code>--kubeconfig</code> 参数，但设置了环境变量 <code>$KUBECONFIG</code>，则使用该环境变量提供的 <code>Kubeconfig</code> 文件。</li>
<li>如果 <code>--kubeconfig</code> 参数和环境变量 <code>$KUBECONFIG</code> 都没有提供，<code>Kubectl</code> 就使用默认的 <code>Kubeconfig</code> 文件 <code>$HOME/.kube/config</code>。</li>
</ul>
<p>解析完 <code>Kubeconfig</code> 文件后，<code>Kubectl</code> 会确定当前要使用的上下文、当前指向的群集以及与当前用户关联的任何认证信息。如果用户提供了额外的参数（例如: <code>--username</code>），则优先使用这些参数覆盖 <code>Kubeconfig</code> 中指定的值。一旦拿到这些信息之后， <code>Kubectl</code> 就会把这些信息填充到将要发送的 <code>HTTP</code> 请求头中：</p>
<ul>
<li><code>x509</code> 证书使用 <code>tls.TLSConfig</code> 发送（包括 <code>CA</code> 证书）。</li>
<li><code>bearer tokens</code> 在 HTTP 请求头 <code>Authorization</code> 中发送。</li>
<li>用户名和密码通过 <code>HTTP</code> 基本认证发送。</li>
<li><code>OpenID</code> 认证过程是由用户事先手动处理的，产生一个像 <code>Bearer Token</code> 一样被发送的 <code>Token</code>。</li>
</ul>
<h3><span id="2-kube-apiserver">2. Kube-Apiserver</span></h3>
<p><strong>认证</strong></p>
<p>现在我们的请求已经成功发送了，接下来将会发生什么？这时候就该 <code>Kube-Apiserver</code> 闪亮登场了！<code>Kube-Apiserver</code> 是客户端和系统组件用来保存和检索集群状态的主要接口。为了执行相应的功能，<code>Kube-Apiserver</code> 需要能够验证请求者是合法的，这个过程被称为认证。</p>
<p>那么 <code>Apiserver</code> 如何对请求进行认证呢？当 <code>Kube-Apiserver</code> 第一次启动时，它会查看用户提供的所有 <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" target="_blank" rel="noopener">CLI</a> 参数，并组合成一个合适的令牌列表。</p>
<p>举个例子：如果提供了 <code>--client-ca-file</code> 参数，则会将 <code>x509</code> 客户端证书认证添加到令牌列表中；如果提供了 <code>--token-auth-file</code> 参数，则会将 <code>breaer token</code> 添加到令牌列表中。</p>
<p>每次收到请求时，<code>Apiserver</code> 都会通过令牌链进行认证，直到某一个认证成功为止：</p>
<ul>
<li><code>x509</code> 处理程序将验证 <code>HTTP</code> 请求是否是由 <code>CA</code> 根证书签名的 <code>TLS</code> 密钥进行编码的。</li>
<li><code>bearer token</code> 处理程序将验证 <code>--token-auth-file</code> 参数提供的 <code>Token</code> 文件是否存在。</li>
<li>基本认证处理程序确保 <code>HTTP</code> 请求的基本认证凭证与本地的状态匹配。</li>
</ul>
<p>如果认证失败，则请求失败并返回相应的错误信息；如果验证成功，则将请求中的 <code>Authorization</code> 请求头删除，并将用户信息添加到其上下文中。这给后续的授权和准入控制器提供了访问之前建立的用户身份的能力。</p>
<p><strong>授权</strong></p>
<p>OK，现在请求已经发送，并且 <code>Kube-Apiserver</code> 已经成功验证我们是谁，终于解脱了！</p>
<p>然而事情并没有结束，虽然我们已经证明了我们是合法的，但我们有权执行此操作吗？毕竟身份和权限不是一回事。为了进行后续的操作，<code>Kube-Apiserver</code> 还要对用户进行授权。</p>
<p><code>Kube-Apiserver</code> 处理授权的方式与处理身份验证的方式相似：通过 <code>Kube-Apiserver</code> 的启动参数 <code>--authorization_mode</code> 参数设置。它将组合一系列授权者，这些授权者将针对每个传入的请求进行授权。如果所有授权者都拒绝该请求，则该请求会被禁止响应并且不会再继续响应。如果某个授权者批准了该请求，则请求继续。</p>
<p><code>Kube-Apiserver</code> 目前支持以下几种授权方法：</p>
<ul>
<li><a href="https://k8smeetup.github.io/docs/admin/authorization/webhook/" target="_blank" rel="noopener">webhook</a>: 它与集群外的 <code>HTTP(S)</code> 服务交互。</li>
<li><a href="https://k8smeetup.github.io/docs/admin/authorization/abac/" target="_blank" rel="noopener">ABAC</a>: 它执行静态文件中定义的策略。</li>
<li><a href="https://k8smeetup.github.io/docs/admin/authorization/rbac/" target="_blank" rel="noopener">RBAC</a>: 它使用 <code>rbac.authorization.k8s.io</code> API Group实现授权决策，允许管理员通过 <code>Kubernetes API</code> 动态配置策略。</li>
<li><a href="https://k8smeetup.github.io/docs/admin/authorization/node/" target="_blank" rel="noopener">Node</a>: 它确保 <code>Kubelet</code> 只能访问自己节点上的资源。</li>
</ul>
<p><strong>准入控制</strong></p>
<p>突破了之前所说的认证和授权两道关口之后，客户端的调用请求就能够得到 <code>API Server</code> 的真正响应了吗？答案是：不能！</p>
<p>从 <code>Kube-Apiserver</code> 的角度来看，它已经验证了我们的身份并且赋予了相应的权限允许我们继续，但对于 <code>Kubernetes</code> 而言，其他组件对于应不应该允许发生的事情还是很有意见的。所以这个请求还需要通过 <code>Admission Controller</code> 所控制的一个准入控制链的层层考验，官方标准的关卡有近十个之多，而且还能自定义扩展！</p>
<p>虽然授权的重点是回答用户是否有权限，但准入控制器会拦截请求以确保它符合集群的更广泛的期望和规则。它们是资源对象保存到 <code>Etcd</code> 之前的最后一个堡垒，封装了一系列额外的检查以确保操作不会产生意外或负面结果。不同于授权和认证只关心请求的用户和操作，准入控制还处理请求的内容，并且仅对创建、更新、删除或连接（如：代理）等有效，而对读操作无效。</p>
<blockquote>
<p>注：准入控制器的工作方式与授权者和验证者的工作方式类似，但有一点区别：与验证链和授权链不同，如果某个准入控制器检查不通过，则整个链会中断，整个请求将立即被拒绝并且返回一个错误给终端用户。</p>
</blockquote>
<p>准入控制器设计的重点在于提高可扩展性，每个控制器都作为一个插件存储在 <code>plugin/pkg/admission</code> 目录中，并且与每一个接口相匹配，最后被编译到 <code>Kube-Apiserver</code> 二进制文件中。</p>
<p>大部分准入控制器都比较容易理解，接下来着重介绍 <code>SecurityContextDeny</code>、<code>ResourceQuota</code> 及 <code>LimitRanger</code> 这三个准入控制器。</p>
<ul>
<li>
<p><code>SecurityContextDeny</code> 该插件将禁止创建设置了 <code>Security Context</code> 的 <code>Pod</code>。</p>
</li>
<li>
<p><code>ResourceQuota</code> 不仅能限制某个 <code>Namespace</code> 中创建资源的数量，而且能限制某个 <code>Namespace</code> 中被 <code>Pod</code> 所请求的资源总量。该准入控制器和资源对象 <code>ResourceQuota</code> 一起实现了资源配额管理。</p>
</li>
<li>
<p><code>LimitRanger</code> 作用类似于上面的 <code>ResourceQuota</code> 控制器，针对 <code>Namespace</code> 资源的每个个体（<code>Pod</code> 与 <code>Container</code> 等）的资源配额。该插件和资源对象 <code>LimitRange</code> 一起实现资源配额管理。</p>
</li>
</ul>
<h3><span id="3-etcd">3. Etcd</span></h3>
<p>到现在为止，<code>Kubernetes</code> 已经对该客户端的调用请求进行了全面彻底地审查，并且已经验证通过，运行它进入下一个环节。下一步 <code>Kube-Apiserver</code> 将对 <code>HTTP</code> 请求进行反序列化，然后利用得到的结果构建运行时对象（有点像 <code>Kubectl</code> 生成器的逆过程），并保存到 <code>Etcd</code> 中。下面我们将这个过程分解一下。</p>
<p>当收到请求时，<code>Kube-Apiserver</code> 是如何知道它该怎么做的呢？事实上，在客户端发送调用请求之前就已经产生了一系列非常复杂的流程。我们就从 <code>Kube-Apiserver</code> 二进制文件首次运行开始分析吧：</p>
<ol>
<li>当运行 <code>Kube-Apiserver</code> 二进制文件时，它会创建一个允许 <code>Apiserver</code> 聚合的服务链。这是一种对 <code>Kubernetes API</code> 进行扩展的方式。</li>
<li>同时会创建一个 <code>Generic Apiserver</code> 作为默认的 <code>Apiserver</code>。</li>
<li>然后生成 <code>OpenAPI</code> 规范的配置</li>
<li>然后 <code>Kube-Apiserver</code> 遍历数据结构中指定的所有 <code>API</code> 组，并将每一个 <code>API</code> 组作为通用的存储抽象保存到 <code>Etcd</code> 中。当你访问或变更资源状态时，<code>Kube-Apiserver</code> 就会调用这些 <code>API</code> 组。</li>
<li>每个 <code>API</code> 组都会遍历它的所有组版本，并且将每个 <code>HTTP</code> 路由映射到 <code>REST</code> 路径中。</li>
<li>当请求的 <code>METHOD</code> 是 <code>POST</code> 时，<code>Kube-Apiserver</code> 就会将请求转交给资源创建处理器。</li>
</ol>
<p>现在 <code>Kube-Apiserver</code> 已经知道了所有的路由及其对应的 <code>REST</code> 路径，以便在请求匹配时知道调用哪些处理器和键值存储。多么机智的设计！现在假设客户端的 <code>HTTP</code> 请求已经被 <code>Kube-Apiserver</code> 收到了：</p>
<ol>
<li>如果处理链可以将请求与已经注册的路由进行匹配，就会将该请求交给注册到该路由的专用处理器来处理；如果没有任何一个路由可以匹配该请求，就会将请求转交给基于路径的处理器（比如：当调用 /apis 时）；如果没有任何一个基于路径的处理器注册到该路径，请求就会被转交给 <code>not found</code> 处理器，最后返回 404。</li>
<li>幸运的是，我们有一个名为 <code>CreateHandler</code> 的注册路由！它有什么作用呢？首先它会解码 <code>HTTP</code> 请求并进行基本的验证，例如：确保请求提供的 <code>JSON</code> 与 <code>API</code> 资源的版本相匹配。</li>
<li>接下来进入审计和准入控制阶段。</li>
<li>然后资源将会通过 <code>Storage Provider</code> 保存到 <code>Etcd</code> 中。默认情况下保存到 <code>Etcd</code> 中的键的格式为 <code>&lt;namespace&gt;/&lt;name&gt;</code>，你也可以自定义。</li>
<li>资源创建过程中出现的任何错误都会被捕获，最后 <code>Storage Provider</code> 会执行 <code>Get</code> 调用来确认该资源是否被成功创建。如果需要额外的清理工作，就会调用后期创建的处理器和装饰器。</li>
<li>最后构造 <code>HTTP</code> 响应并返回给客户端。</li>
</ol>
<p>原来 <code>Apiserver</code> 做了这么多的工作，以前竟然没有发现呢！到目前为止，我们创建的 <code>Deployment</code> 资源已经保存到了 <code>Etcd</code> 中，但 <code>Apiserver</code> 仍然看不到它。</p>
<h3><span id="4-初始化">4. 初始化</span></h3>
<p>在一个资源对象被持久化到数据存储之后，<code>Apiserver</code> 还无法完全看到或调度它，在此之前还要执行一系列<a href="https://kubernetes.io/docs/admin/extensible-admission-controllers/#initializers" target="_blank" rel="noopener">初始化器</a>。初始化器是一种与资源类型相关联的控制器，它会在资源对外可用之前执行某些逻辑。如果某个资源类型没有初始化器，就会跳过此初始化步骤立即使资源对外可见。</p>
<p>正如<a href="https://ahmet.im/blog/initializers/" target="_blank" rel="noopener">大佬的博客</a>指出的那样，初始化器是一个强大的功能，因为它允许我们执行通用引导操作。例如：</p>
<ul>
<li>将代理 <code>Sidecar</code> 容器注入到暴露 80 端口的 <code>Pod</code> 中，或者加上特定的 <code>Annotation</code>。</li>
<li>将保存着测试证书的<code> Volume</code> 注入到特定命名空间的所有 <code>Pod</code> 中。</li>
<li>如果 <code>Secret</code> 中的密码小于 20 个字符，就组织其创建。</li>
</ul>
<p><code>initializerConfiguration</code> 资源对象允许你声明某些资源类型应该运行哪些初始化器。如果你想每创建一个 <code>Pod</code> 时就运行一个自定义初始化器，你可以这样做：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitializerConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">custom-pod-initializer</span></span><br><span class="line"><span class="attr">initializers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podimage.example.com</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">        <span class="attr">apiVersions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pods</span></span><br></pre></td></tr></table></figure>
<p>通过该配置创建资源对象 <code>InitializerConfiguration</code> 之后，就会在每个 <code>Pod</code> 的 <code>metadata.initializers.pending</code> 字段中添加 <code>custom-pod-initializer</code> 字段。该初始化控制器会定期扫描新的 <code>Pod</code>，一旦在 <code>Pod</code> 的 <code>pending</code> 字段中检测到自己的名称，就会执行其逻辑，执行完逻辑之后就会将 <code>pending</code> 字段下的自己的名称删除。</p>
<p>只有在 <code>pending</code> 字段下的列表中的第一个初始化器可以对资源进行操作，当所有的初始化器执行完成，并且 <code>pending</code> 字段为空时，该对象就会被认为初始化成功。</p>
<p>你可能会注意到一个问题：如果 <code>Kube-Apiserver</code> 不能显示这些资源，那么用户级控制器是如何处理资源的呢？</p>
<p>为了解决这个问题，<code>Kube-Apiserver</code> 暴露了一个 <code>?includeUninitialized</code> 查询参数，它会返回所有的资源对象（包括未初始化的）。</p>
<h3><span id="5-控制循环">5. 控制循环</span></h3>
<p><strong>Deployments controller</strong></p>
<p>到了这个阶段，我们的 <code>Deployment</code> 记录已经保存在 <code>Etcd</code> 中，并且所有的初始化逻辑都执行完成，接下来的阶段将会涉及到该资源所依赖的拓扑结构。在 <code>Kubernetes</code> 中，<code>Deployment</code> 实际上只是一系列 <code>Replicaset</code> 的集合，而 <code>Replicaset</code> 是一系列 <code>Pod</code> 的集合。那么 <code>Kubernetes</code> 是如何从一个 <code>HTTP</code> 请求按照层级结构依次创建这些资源的呢？其实这些工作都是由 <code>Kubernetes</code> 内置的 <code>Controller</code>(控制器) 来完成的。</p>
<p><code>Kubernetes</code> 在整个系统中使用了大量的 <code>Controller</code>，<code>Controller</code> 是一个用于将系统状态从当前状态修正到期望状态的异步脚本。所有 <code>Controller</code> 都通过 <code>Kube-Controller-Manager</code> 组件并行运行，每种 <code>Controller</code> 都负责一种具体的控制流程。首先介绍一下 <code>Deployment Controller</code>：</p>
<p>将 <code>Deployment</code> 记录存储到 <code>Etcd</code> 并初始化后，就可以通过 <code>Kube-Apiserver</code> 使其可见，然后 <code>Deployment Controller</code> 就会检测到它（它的工作就是负责监听 <code>Deployment</code> 记录的更改）。在我们的例子中，控制器通过一个 <code>Informer</code> 注册一个创建事件的特定回调函数（更多信息参加下文）。</p>
<p>当 <code>Deployment</code> 第一次对外可见时，该 <code>Controller</code> 就会将该资源对象添加到内部工作队列，然后开始处理这个资源对象：</p>
<blockquote>
<p>通过使用标签选择器查询 <code>Kube-Apiserver</code> 来检查该 <code>Deployment</code> 是否有与其关联的 <code>ReplicaSet</code> 或 <code>Pod</code> 记录。</p>
</blockquote>
<p>有趣的是，这个同步过程是状态不可知的，它核对新记录与核对已经存在的记录采用的是相同的方式。</p>
<p>在意识到没有与其关联的 <code>ReplicaSet</code> 或 <code>Pod</code> 记录后，<code>Deployment Controller</code> 就会开始执行弹性伸缩流程：</p>
<blockquote>
<p>创建 <code>ReplicaSet</code> 资源，为其分配一个标签选择器并将其版本号设置为 1。</p>
</blockquote>
<p><code>ReplicaSet</code> 的 <code>PodSpec</code> 字段从 <code>Deployment</code> 的 <code>manifest</code> 以及其他相关元数据中复制而来。有时 <code>Deployment</code> 记录在此之后也需要更新（例如：如果设置了 <code>Process Deadline</code>）。</p>
<p>当完成以上步骤之后，该 <code>Deployment</code> 的 <code>Status</code> 就会被更新，然后重新进入与之前相同的循环，等待 <code>Deployment</code> 与期望的状态相匹配。由于 <code>Deployment Controller</code> 只关心 <code>ReplicaSet</code>，因此需要通过 <code>ReplicaSet Controller</code> 来继续协调。</p>
<p><strong>ReplicaSets controller</strong></p>
<p>在前面的步骤中，<code>Deployment Controller</code> 创建了第一个 <code>ReplicaSet</code>，但仍然还是没有 <code>Pod</code>，这时候就该 <code>ReplicaSet Controller</code> 登场了！<code>ReplicaSet Controller</code> 的工作是监视 <code>ReplicaSets</code> 及其相关资源（<code>Pod</code>）的生命周期。和大多数其他 <code>Controller</code> 一样，它通过触发某些事件的处理器来实现此目的。</p>
<p>当创建 <code>ReplicaSet</code> 时（由 <code>Deployment Controller</code> 创建），<code>RS Controller</code> 检查新 <code>ReplicaSet</code> 的状态，并检查当前状态与期望状态之间存在的偏差，然后通过调整 <code>Pod</code> 的副本数来达到期望的状态。</p>
<p><code>Pod</code> 的创建也是批量进行的，从 <code>SlowStartInitialBatchSize</code> 开始，然后在每次成功的迭代中以一种 <code>Slow Start</code> 操作加倍。这样做的目的是在大量 <code>Pod</code> 启动失败时（例如：由于资源配额），可以减轻 <code>Kube-Apiserver</code> 被大量不必要的 <code>HTTP</code> 请求吞没的风险。如果创建失败，最好能够优雅地失败，并且对其他的系统组件造成的影响最小！</p>
<p><code>Kubernetes</code> 通过 <code>Owner References</code>（在子级资源的某个字段中引用其父级资源的 ID） 来构造严格的资源对象层级结构。这确保了一旦 <code>Controller</code> 管理的资源被删除（级联删除），子资源就会被垃圾收集器删除，同时还为父级资源提供了一种有效的方式来避免他们竞争同一个子级资源（想象两对父母都认为他们拥有同一个孩子的场景）。</p>
<p><code>Owner References</code> 的另一个好处是：它是有状态的。如果有任何 <code>Controller</code> 重启了，那么由于资源对象的拓扑关系与 <code>Controller</code> 无关，该操作不会影响到系统的稳定运行。这种对资源隔离的重视也体现在 <code>Controller</code> 本身的设计中：<code>Controller</code> 不能对自己没有明确拥有的资源进行操作，它们应该选择对资源的所有权，互不干涉，互不共享。</p>
<p>有时系统中也会出现孤儿（<code>Orphaned</code>）资源，通常由以下两种途径产生：</p>
<ul>
<li>父级资源被删除，但子级资源没有被删除</li>
<li>垃圾收集策略禁止删除子级资源</li>
</ul>
<p>当发生这种情况时，<code>Controller</code> 将会确保孤儿资源拥有新的 <code>Owner</code>。多个父级资源可以相互竞争同一个孤儿资源，但只有一个会成功（其他父级资源会收到验证错误）。</p>
<p><strong>Informers</strong></p>
<p>你可能已经注意到，某些 <code>Controller</code>（例如：<code>RBAC</code> 授权器或 <code>Deployment Controller</code>）需要先检索集群状态然后才能正常运行。拿 <code>RBAC</code> 授权器举例，当请求进入时，授权器会将用户的初始状态缓存下来，然后用它来检索与 <code>Etcd</code> 中的用户关联的所有角色（<code>Role</code>）和 角色绑定（<code>RoleBinding</code>）。那么问题来了，<code>Controller</code> 是如何访问和修改这些资源对象的呢？事实上 <code>Kubernetes</code> 是通过 <code>Informer</code> 机制来解决这个问题的。</p>
<p><code>Infomer</code> 是一种模式，它允许 <code>Controller</code> 查找缓存在本地内存中的数据(这份数据由 <code>Informer</code> 自己维护)并列出它们感兴趣的资源。</p>
<p>虽然 <code>Informer</code> 的设计很抽象，但它在内部实现了大量的对细节的处理逻辑（例如：缓存），缓存很重要，因为它不但可以减少对 <code>Kubenetes API</code> 的直接调用，同时也能减少 <code>Server</code> 和 <code>Controller</code> 的大量重复性工作。通过使用 <code>Informer</code>，不同的 <code>Controller</code> 之间以线程安全（<code>Thread safety</code>）的方式进行交互，而不必担心多个线程访问相同的资源时会产生冲突。</p>
<p>有关 <code>Informer</code> 的更多详细解析，请参考这篇文章：<a href="https://borismattijssen.github.io/articles/kubernetes-informers-controllers-reflectors-stores" target="_blank" rel="noopener">Kubernetes: Controllers, Informers, Reflectors and Stores</a></p>
<p><strong>Scheduler</strong></p>
<p>当所有的 <code>Controller</code> 正常运行后，<code>Etcd</code> 中就会保存一个 <code>Deployment</code>、一个 <code>ReplicaSet</code> 和三个 <code>Pod</code> 资源记录，并且可以通过 <code>Kube-Apiserver</code> 查看。然而，这些 <code>Pod</code> 资源现在还处于 <code>Pending</code> 状态，因为它们还没有被调度到集群中合适的 <code>Node</code> 上运行。这个问题最终要靠调度器 <code>Scheduler</code> 来解决。</p>
<p><code>Scheduler</code> 作为一个独立的组件运行在集群控制平面上，工作方式与其他 <code>Controller</code> 相同：监听实际并将系统状态调整到期望的状态。具体来说，<code>Scheduler</code> 的作用是将待调度的 <code>Pod</code> 按照特定的算法和调度策略绑定到集群中某个合适的  <code>Node</code> 上，并将绑定信息写入 <code>Etcd</code> 中（它会过滤其 <code>PodSpec</code> 中 <code>NodeName</code> 字段为空的 <code>Pod</code>），默认的调度算法的工作方式如下：</p>
<ol>
<li>
<p>当 <code>Scheduler</code> 启动时，会注册一个默认的预选策略链，这些预选策略会对备选节点进行评估，判断备选节点是否满足备选 <code>Pod</code> 的需求。例如：如果 <code>PodSpec</code> 字段限制了 <code>CPU</code> 和内存资源，那么当备选节点的资源容量不满足备选 <code>Pod</code> 的需求时，备选 <code>Pod</code> 就不会被调度到该节点上（资源容量=备选节点资源总量-节点中已存在 <code>Pod</code> 的所有容器的需求资源（<code>CPU</code> 和内存的总和）</p>
</li>
<li>
<p>一旦筛选出符合要求的候选节点，就会采用优选策略计算出每个候选节点的积分，然后对这些候选节点进行排序，积分最高者胜出。例如：为了在整个系统中分摊工作负载，这些优选策略会从备选节点列表中选出资源消耗最小的节点。每个节点通过优选策略时都会算出一个得分，计算各项得分，最终选出分值大的节点作为优选的结果。</p>
</li>
</ol>
<p>一旦找到了合适的节点，<code>Scheduler</code> 就会创建一个 <code>Binding</code> 对象，该对象的 <code>Name</code> 和 <code>UID</code> 与 <code>Pod</code> 相匹配，并且其 <code>ObjectReference</code> 字段包含所选节点的名称，然后通过 <code>POST</code> 请求发送给 <code>Apiserver</code>。</p>
<p>当 <code>Kube-Apiserver</code> 接收到此 <code>Binding</code> 对象时，注册表会将该对象反序列化并更新 <code>Pod</code> 资源中的以下字段：</p>
<ul>
<li>将 <code>NodeName</code> 的值设置为 <code>ObjectReference</code> 中的 <code>NodeName</code>。</li>
<li>添加相关的注释。</li>
<li>将 <code>PodScheduled</code> 的 <code>Status</code> 值设置为 <code>True</code>。可以通过 <code>Kubectl</code> 来查看：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get &lt;PODNAME&gt; -o go-template=<span class="string">'&#123;&#123;range .status.conditions&#125;&#125;&#123;&#123;if eq .type "PodScheduled"&#125;&#125;&#123;&#123;.status&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<p>一旦 <code>Scheduler</code> 将 <code>Pod</code> 调度到某个节点上，该节点的 <code>Kubelet</code> 就会接管该 <code>Pod</code> 并开始部署。</p>
<blockquote>
<p>注：预选策略和优选策略都可以通过 <code>--policy-config-file</code> 参数来扩展，如果默认的调度器不满足要求，还可以部署自定义的调度器。如果 <code>podSpec.schedulerName</code> 的值设置为其他的调度器，则 <code>Kubernetes</code> 会将该 <code>Pod</code> 的调度转交给那个调度器。</p>
</blockquote>
<h3><span id="6-kubelet">6. Kubelet</span></h3>
<p><strong>Pod 同步</strong></p>
<p>现在，所有的 <code>Controller</code> 都完成了工作，我们来总结一下：</p>
<ul>
<li><code>HTTP</code> 请求通过了认证、授权和准入控制阶段。</li>
<li>一个 <code>Deployment</code>、<code>ReplicaSet</code> 和三个 <code>Pod</code> 资源被持久化到 <code>Etcd</code> 存储中。</li>
<li>然后运行了一系列初始化器。</li>
<li>最后每个 <code>Pod</code> 都被调度到合适的节点。</li>
</ul>
<p>然而到目前为止，所有的状态变化仅仅只是针对保存在 <code>Etcd</code> 中的资源记录，接下来的步骤涉及到运行在工作节点之间的 <code>Pod</code> 的分布状况，这是分布式系统（比如：<code>Kubernetes</code>）的关键因素。这些任务都是由 <code>Kubelet</code> 组件完成的，让我们开始吧！</p>
<p>在 <code>Kubernetes</code> 集群中，每个 <code>Node</code> 节点上都会启动一个 <code>Kubelet</code> 服务进程，该进程用于处理 <code>Scheduler</code> 下发到本节点的任务，管理 <code>Pod</code> 的生命周期，包括挂载卷、容器日志记录、垃圾回收以及其他与 <code>Pod</code> 相关的事件。</p>
<p>如果换一种思维模式，你可以把 <code>Kubelet</code> 当成一种特殊的 <code>Controller</code>，它每隔 20 秒（可以自定义）向 <code>Kube-Apiserver</code> 通过 <code>NodeName</code> 获取自身 <code>Node</code> 上所要运行的 <code>Pod</code> 清单。一旦获取到了这个清单，它就会通过与自己的内部缓存进行比较来检测新增加的 <code>Pod</code>，如果有差异，就开始同步 <code>Pod</code> 列表。我们来详细分析一下同步过程：</p>
<ol>
<li>
<p>如果 <code>Pod</code> 正在创建， <code>Kubelet</code> 就会记录一些在 <code>Prometheus</code> 中用于追踪 <code>Pod</code> 启动延时的指标。</p>
</li>
<li>
<p>然后生成一个 <code>PodStatus</code> 对象，它表示 <code>Pod</code> 当前阶段的状态。<code>Pod</code> 的状态(<code>Phase</code>) 是 <code>Pod</code> 在其生命周期中的最精简的概要，包括 <code>Pending</code>、<code>Running</code>、<code>Succeeded</code>、<code>Failed</code> 和 <code>Unkown</code> 这几个值。状态的产生过程非常复杂，所以很有必要深入了解一下背后的原理：</p>
<ul>
<li>
<p>首先串行执行一系列 <code>Pod</code> 同步处理器（<code>PodSyncHandlers</code>），每个处理器检查 <code>Pod</code> 是否应该运行在该节点上。当所有的处理器都认为该 <code>Pod</code> 不应该运行在该节点上，则 <code>Pod</code> 的 <code>Phase</code> 值就会变成 <code>PodFailed</code>，并且将该 <code>Pod</code> 从该节点上驱逐出去。例如：当你创建一个 <code>Job</code> 时，如果 <code>Pod</code> 失败重试的时间超过了 <code>spec.activeDeadlineSeconds</code> 设置的值，就会将 <code>Pod</code> 从该节点驱逐出去。</p>
</li>
<li>
<p>接下来，<code>Pod</code> 的 <code>Phase</code> 值由 <code>Init</code> 容器和应用容器的状态共同来决定。因为目前容器还没有启动，容器被视为处于等待阶段，如果 <code>Pod</code> 中至少有一个容器处于等待阶段，则其 <code>Phase</code> 值为 <code>Pending</code>。</p>
</li>
<li>
<p>最后，<code>Pod</code> 的 <code>Condition</code> 字段由 <code>Pod</code> 内所有容器的状态决定。现在我们的容器还没有被容器运行时创建，所以 <code>PodReady</code> 的状态被设置为 <code>False</code>。可以通过 <code>Kubectl</code> 查看：</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get &lt;PODNAME&gt; -o go-template=<span class="string">'&#123;&#123;range .status.conditions&#125;&#125;&#123;&#123;if eq .type "Ready"&#125;&#125;&#123;&#123;.status&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>生成 <code>PodStatus</code> 之后（<code>Pod</code> 中的 <code>Status</code> 字段），<code>Kubelet</code> 就会将它发送到 <code>Pod</code> 的状态管理器，该管理器的任务是通过 <code>Apiserver</code> 异步更新 <code>Etcd</code> 中的记录。</p>
</li>
<li>
<p>接下来运行一系列准入处理器来确保该 <code>Pod</code> 是否具有相应的权限（包括强制执行 <code>AppArmor</code> 配置文件和 <code>NO_NEW_PRIVS</code>），被准入控制器拒绝的 <code>Pod</code> 将一直保持 <code>Pending</code> 状态。</p>
</li>
<li>
<p>如果 <code>Kubelet</code> 启动时指定了 <code>cgroups-per-qos</code> 参数，<code>Kubelet</code> 就会为该 <code>Pod</code> 创建 <code>Cgroup</code> 并进行相应的资源限制。这是为了更方便地对 <code>Pod</code> 进行服务质量（<code>QoS</code>）管理。</p>
</li>
<li>
<p>然后为 <code>Pod</code> 创建相应的目录，包括 <code>Pod</code> 的目录（/var/run/kubelet/pods/<podid>），该 <code>Pod</code> 的卷目录（<code>&lt;podDir&gt;/volumes</code>）和该 Pod 的插件目录（<code>&lt;podDir&gt;/plugins</code>）。</podid></p>
</li>
<li>
<p>卷管理器会挂载 <code>Spec.Volumes</code> 中定义的相关数据卷，然后等待是否挂载成功。根据挂载卷类型的不同，某些 <code>Pod</code> 可能需要等待更长的时间（比如：<code>NFS</code> 卷）。</p>
</li>
<li>
<p>从 <code>Apiserver</code> 中检索 <code>Spec.ImagePullSecrets</code> 中定义的所有 <code>Secret</code>，然后将其注入到容器中。</p>
</li>
<li>
<p>最后通过容器运行时接口（<code>Container Runtime Interface</code>（CRI））开始启动容器（下面会详细描述）。</p>
</li>
</ol>
<p><strong>CRI 与 Pause 容器</strong></p>
<p>到了这个阶段，大量的初始化工作都已经完成，容器已经准备好开始启动了，而容器是由容器运行时（例如：<code>Docker</code> 和 <code>Rkt</code>）启动的。</p>
<p>为了更容易扩展，<code>Kubelet</code> 从 1.5.0 开始通过容器运行时接口与容器运行时（<code>Container Runtime</code>）交互。简而言之，<code>CRI</code> 提供了 <code>Kubelet</code> 和特定的运行时之间的抽象接口，它们之间通过<a href="https://github.com/google/protobuf" target="_blank" rel="noopener">协议缓冲区</a>（它像一个更快的 <code>JSON</code>）和 <a href="https://grpc.io/" target="_blank" rel="noopener">gRPC API</a>（一种非常适合执行 <code>Kubernetes</code> 操作的 <code>API</code>）交互。这是一个非常酷的想法，通过使用 <code>Kubelet</code> 和运行时之间定义的契约关系，容器如何编排的具体实现细节已经变得无关紧要。由于不需要修改 <code>Kubernetes</code> 的核心代码，开发者可以以最小的开销添加新的运行时。</p>
<p>不好意思有点跑题了，让我们继续回到容器启动的阶段。第一次启动 <code>Pod</code> 时，<code>Kubelet</code> 会通过 <code>Remote Procedure Command</code>(RPC) 协议调用 <code>RunPodSandbox</code>。<code>Sandbox</code> 用于描述一组容器，例如：在 <code>Kubernetes</code> 中它表示的是 <code>Pod</code>。<code>Sandbox</code> 是一个很宽泛的概念，所以对于其他没有使用容器的运行时仍然是有意义的（比如：在一个基于 <code>Hypervisor</code> 的运行时中，<code>Sandbox</code> 可能指的就是虚拟机）。</p>
<p>我们的例子中使用的容器运行时是 <code>Docker</code>，创建 <code>Sandbox</code> 时首先创建的是 <code>Pause</code> 容器。<code>Pause</code> 容器作为同一个 <code>Pod</code> 中所有其他容器的基础容器，它为 <code>Pod</code> 中的每个业务容器提供了大量的 <code>Pod</code> 级别资源，这些资源都是 <code>Linux</code> 命名空间（包括：网络命名空间，<code>IPC</code> 命名空间和 <code>PID</code> 命名空间）。</p>
<p><code>Pause</code> 容器提供了一种方法来管理所有这些命名空间并允许业务容器共享它们，在同一个网络命名空间中的好处是：同一个 <code>Pod</code> 中的容器可以使用 <code>Localhost</code> 来相互通信。<code>Pause</code> 容器的第二个功能与 <code>PID</code> 命名空间的工作方式相关，在 <code>PID</code> 命名空间中，进程之间形成一个树状结构，一旦某个子进程由于父进程的错误而变成了孤儿进程，其便会被 <code>Init</code> 进程进行收养并最终回收资源。关于 <code>Pause</code> 工作方式的详细信息可以参考：<a href="https://www.ianlewis.org/en/almighty-pause-container" target="_blank" rel="noopener">The Almighty Pause Container</a>。</p>
<p>一旦创建好了 <code>Pause</code> 容器，下面就会开始检查磁盘状态然后开始启动业务容器。</p>
<p><strong>CNI 和 Pod 网络</strong></p>
<p>现在我们的 <code>Pod</code> 已经有了基本的骨架：一个共享所有命名空间以允许业务容器在同一个 <code>Pod</code> 里进行通信的 <code>Pause</code> 容器。但现在还有一个问题，那就是容器的网络是如何建立的？</p>
<p>当 <code>Kubelet</code> 为 <code>Pod</code> 创建网络时，它会将创建网络的任务交给 <code>CNI</code> 插件。<code>CNI</code> 表示容器网络接口（<code>Container Network Interface</code>），和容器运行时的运行方式类似，它也是一种抽象，允许不同的网络提供商为容器提供不同的网络实现。通过将 <code>JSON</code> 配置文件（默认在 <code>/etc/cni/net.d</code> 路径下）中的数据传送到相关的 <code>CNI</code> 二进制文件（默认在 <code>/opt/cni/bin</code> 路径下）中，<code>CNI</code> 插件可以给 <code>Pause</code> 容器配置相关的网络，然后<code> Pod</code> 中其他的容器都使用 <code>Pause</code> 容器的网络。下面是一个简单的示例配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">    <span class="attr">"cniVersion":</span> <span class="string">"0.3.1"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">"name":</span> <span class="string">"bridge"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">"type":</span> <span class="string">"bridge"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">"bridge":</span> <span class="string">"cnio0"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">"isGateway":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">    <span class="attr">"ipMasq":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">    <span class="attr">"ipam":</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"type":</span> <span class="string">"host-local"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"ranges":</span> <span class="string">[</span></span><br><span class="line">          <span class="string">[&#123;"subnet":</span> <span class="string">"$&#123;POD_CIDR&#125;"</span><span class="string">&#125;]</span></span><br><span class="line">        <span class="string">],</span></span><br><span class="line">        <span class="attr">"routes":</span> <span class="string">[&#123;"dst":</span> <span class="string">"0.0.0.0/0"</span><span class="string">&#125;]</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>CNI</code> 插件还会通过 <code>CNI_ARGS</code> 环境变量为 <code>Pod</code> 指定其他的元数据，包括 <code>Pod</code> 名称和命名空间。</p>
<p>下面我们以 <code>Bridge</code> 插件举例(步骤会因不同 <code>CNI</code> 插件而异)：</p>
<ul>
<li>
<p>该插件首先会在根网络命名空间（也就是宿主机的网络命名空间）中设置本地 <code>Linux</code> 网桥，以便为该主机上的所有容器提供网络服务。</p>
</li>
<li>
<p>然后它会将一个网络接口（<code>Veth</code> 设备对的一端）插入到 <code>Pause</code> 容器的网络命名空间中，并将另一端连接到网桥上。你可以这样来理解 <code>Veth</code> 设备对：它就像一根很长的管道，一端连接到容器，一端连接到根网络命名空间中，数据包就在管道中进行传播。</p>
</li>
<li>
<p>接下来 <code>JSON</code> 文件中指定的 <code>IPAM Plugin</code> 会为 <code>Pause</code> 容器的网络接口分配一个 <code>IP</code> 并设置相应的路由，现在 <code>Pod</code> 就有了自己的 <code>IP</code>。</p>
<ul>
<li><code>IPAM Plugin</code> 的工作方式和 <code>CNI Plugin</code> 类似：通过二进制文件调用并具有标准化的接口，每一个 <code>IPAM Plugin</code> 都必须要确定容器网络接口的 <code>IP</code>、子网以及网关和路由，并将信息返回给 <code>CNI</code> 插件。最常见的 <code>IPAM Plugin</code> 是 <code>host-local</code>，它从预定义的一组地址池中为容器分配 <code>IP</code> 地址。它将地址池的信息以及分配信息保存在主机的文件系统中，从而确保了同一主机上每个容器的 <code>IP</code> 地址的唯一性。</li>
</ul>
</li>
<li>
<p>最后 <code>Kubelet</code> 会将集群内部的 <code>DNS</code> 服务器的 <code>Cluster IP</code> 地址传给 <code>CNI</code> 插件，然后 <code>CNI</code> 插件将它们写到容器的 <code>/etc/resolv.conf</code> 文件中。</p>
</li>
</ul>
<p>一旦完成了上面的步骤，<code>CNI</code> 插件就会将操作的结果以 <code>JSON</code> 的格式返回给 <code>Kubelet</code>。更多关于 <code>CNI</code> 相关信息可参考 「<a href="https://zhuanlan.zhihu.com/p/27460083" target="_blank" rel="noopener">CNI网络插件指南</a>」一文。</p>
<p><strong>跨主机容器网络</strong></p>
<p>到目前为止，我们已经描述了容器如何与宿主机进行通信，但跨主机之间的容器如何通信呢？</p>
<p>通常情况下使用 <code>Overlay</code> 网络来进行跨主机容器通信，这是一种动态同步多个主机间路由的方法。 其中最常用的 <code>Overlay</code> 网络插件是 <code>Flannel</code>，<code>Flannel</code> 具体的工作方式可以参考 <a href="https://github.com/coreos/flannel" target="_blank" rel="noopener">CoreOS</a> 的文档。</p>
<p><strong>容器启动</strong></p>
<p>所有网络都配置完成后，接下来就开始真正启动业务容器了！</p>
<p>一旦 <code>Sanbox</code> 完成初始化并处于 <code>Active</code> 状态，<code>Kubelet</code> 就可以开始为其创建容器了。首先启动 <code>PodSpec</code> 中定义的 <code>Init</code> 容器，然后再启动业务容器。具体过程如下：</p>
<ol>
<li>首先拉取容器的镜像。如果是私有仓库的镜像，就会利用 <code>PodSpec</code> 中指定的 <code>Secret</code> 来拉取该镜像。</li>
<li>然后通过 <code>CRI</code> 接口创建容器。<code>Kubelet</code> 向 <code>PodSpec</code> 中填充了一个 <code>ContainerConfig</code> 数据结构（在其中定义了命令、镜像、标签、挂载卷、设备、环境变量等），然后通过 <code>Protobufs</code> 发送给 <code>CRI</code> 接口。对于 <code>Docker</code> 来说，它会将这些信息反序列化并填充到自己的配置信息中，然后再发送给 <code>Dockerd</code> 守护进程。在这个过程中，它会将一些元数据标签（例如：容器类型、日志路径、<code>Sandbox ID</code> 等）添加到容器中。</li>
<li>接下来会使用 <code>CPU</code> 管理器来约束容器，这是 1.8 中新添加的 <code>Alpha</code> 特性，它使用 <code>UpdateContainerResources</code> CRI 方法将容器分配给本节点上的 <code>CPU</code> 资源池。</li>
<li>最后容器开始真正启动。</li>
<li>如果 <code>Pod</code> 中配置了容器生命周期钩子（<code>Hook</code>），容器启动之后就会运行这些 <code>Hook</code>。<code>Hook</code> 的类型包括两种：<code>Exec</code>（执行一段命令） 和 <code>HTTP</code>（发送 <code>HTTP</code> 请求）。如果 <code>PostStart Hook</code> 启动的时间过长、挂起或者失败，容器将永远不会变成 <code>Running</code> 状态。</li>
</ol>
<h3><span id="7-总结">7. 总结</span></h3>
<p>如果上面一切顺利，现在你的集群上应该会运行三个容器，所有的网络，数据卷和秘钥都被通过 <code>CRI</code> 接口添加到容器中并配置成功。</p>
<h3><span id="8-原文链接">8. 原文链接</span></h3>
<p><a href="https://github.com/jamiehannaford/what-happens-when-k8s" target="_blank" rel="noopener">What happens when … Kubernetes edition!</a></p>
<blockquote>
<p>来源：Ryan Yang 的 Blog<br>
原文：<a href="http://t.cn/RDhqlnT" target="_blank" rel="noopener">http://t.cn/RDhqlnT</a><br>
题图：来自谷歌图片搜索<br>
版权：本文版权归原作者所有</p>
</blockquote>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "10135-1588830050631-449",
			        "name": "「奇妙的 Linux 世界」",
			        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",
			        "keyword": "VIP"
			    });
			}
			</script>
		
                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/posts/21466.html" data-toggle="tooltip" data-placement="top" title="Helm 入门指南">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/posts/57498.html" data-toggle="tooltip" data-placement="top" title="如何 10 步 Docker 化一个应用">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                
                    <!-- disqus 评论框 start -->
                    <div class="comment">
                        <div id="lv-container" data-id="city" data-uid="MTAyMC8yNzg2My80NDQw"></div>
                    </div>
                    <!-- disqus 评论框 end -->
                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1. Kubectl</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2. Kube-Apiserver</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3. Etcd</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4. 初始化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">5. 控制循环</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">6. Kubelet</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">7. 总结</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">8. 原文链接</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                        
                          <a class="tag" href="/tags/#Kubernetes" title="Kubernetes">Kubernetes</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://www.mike.org.cn/" target="_blank">简单.生活</a></li>
                    
                        <li><a href="http://shang.qq.com/wpa/qunwpa?idkey=ea4c43493c2269428ac6ef6141de4b6d78e5ab2d41380ca4099b833b62884ee9" target="_blank">技术交流群</a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






    <!-- 来必力City版公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
       (function(d, s) {
           var j, e = d.getElementsByTagName(s)[0];
    
           if (typeof LivereTower === 'function') { return; }
    
           j = d.createElement(s);
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;
    
           e.parentNode.insertBefore(j, e);
       })(document, 'script');
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    <!-- 来必力City版 公共JS代码 end -->



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                    <li>
                        <a href="/atom.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/80imike">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/2093524665">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Mike 2024 | Hosted by <a href="https://pages.coding.me" target="_blank" rel="noopener" style="font-weight: bold">Coding Pages</a>
                    <br>
                    Theme by <a href="http://beantech.org" target="_blank" rel="noopener">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://www.huweihuang.com" target="_blank" rel="noopener">胡伟煌</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huweihuang&repo=hexo-theme-huweihuang&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://www.hi-linux.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->



<script async defer data-website-id="0d8da2a4-a24e-4240-9304-00a6e347ddfe"
    src="https://umami.hi-linux.com/umami.js"></script>



	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://www.hi-linux.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script>(function(w,d, s, id) {w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js, fjs = d.getElementsByTagName(s)[0];js = d.createElement(s); js.id = id;js.src = 'https://cdn.webpushr.com/app.min.js';fjs.parentNode.appendChild(js);}(window,document, 'script', 'webpushr-jssdk'));webpushr('init','BF9JK7xV9kjWTdMx2lr6RWaPfXV7wNuZaVAJ1bfIGoBNJavqLEBVFMKLubITnCA4bh2fI9iH9tMF95nXnPt7xxY');</script></body>

</html>
