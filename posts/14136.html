<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="Linux,运维,Nginx,Zabbix,Centos,Ansible,MySQL,Python,Docker,ELK,Haproxy,Git,Nodejs,安全,技术">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          浅谈 Kubernetes 数据持久化方案 - 运维之美
        
    </title>

    <link rel="canonical" href="https://www.hi-linux.com/posts/14136.html">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
<link rel="stylesheet" href="/css/beantech.min.css">

    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/toc.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="运维之美" type="application/atom+xml">
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/article.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                            
                              <a class="tag" href="/tags/#Kubernetes" title="Kubernetes">Kubernetes</a>
                            
                        </div>
                        <h1>浅谈 Kubernetes 数据持久化方案</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Mike on
                            2018-08-25
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">运维之美</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <div id="vip-container"><h3 id="kubernetes-volume-相关概念">Kubernetes Volume 相关概念</h3>
<p>缺省情况下，一个运行中的容器对文件系统的写入都是发生在其分层文件系统的可写层。一旦容器运行结束，所有写入都会被丢弃。如果数据需要长期存储，那就需要对容器数据做持久化支持。</p>
<p>Kubernetes 和 Docker 类似，也是通过 Volume 的方式提供对存储的支持。Volume 被定义在 Pod 上，可以被 Pod 里的多个容器挂载到相同或不同的路径下。Kubernetes 中 Volume 的 概念与Docker 中的 Volume 类似，但不完全相同。具体区别如下：</p>
<ul>
<li>Kubernetes 中的 Volume 与 Pod 的生命周期相同，但与容器的生命周期不相关。当容器终止或重启时，Volume 中的数据也不会丢失。</li>
<li>当 Pod 被删除时，Volume 才会被清理。并且数据是否丢失取决于 Volume 的具体类型，比如：emptyDir 类型的 Volume 数据会丢失，而 PV 类型的数据则不会丢失。</li>
</ul>
<p>Volume 的核心是目录，可以通过 Pod 中的容器来访问。该目录是如何形成的、支持该目录的介质以及其内容取决于所使用的特定卷类型。要使用 Volume，需要为 Pod 指定为 Volume (<code>spec.volumes</code> 字段) 以及将它挂载到容器的位置 (<code>spec.containers.volumeMounts</code> 字段)。Kubernetes 支持多种类型的卷，一个 Pod 可以同时使用多种类型的 Volume。</p>
<p>容器中的进程看到的是由其 Docker 镜像和 Volume 组成的文件系统视图。 Docker 镜像位于文件系统层次结构的根目录，任何 Volume 都被挂载在镜像的指定路径中。Volume 无法挂载到其他 Volume 上或与其他 Volume 的硬连接。Pod 中的每个容器都必须独立指定每个 Volume 的挂载位置。</p>
<p>Kubernetes 目前支持多种 Volume 类型，大致如下：</p>
<ul>
<li>awsElasticBlockStore</li>
<li>azureDisk</li>
<li>azureFile</li>
<li>cephfs</li>
<li>csi</li>
<li>downwardAPI</li>
<li>emptyDir</li>
<li>fc (fibre channel)</li>
<li>flocker</li>
<li>gcePersistentDisk</li>
<li>gitRepo</li>
<li>glusterfs</li>
<li>hostPath</li>
<li>iscsi</li>
<li>local</li>
<li>nfs</li>
<li>persistentVolumeClaim</li>
<li>projected</li>
<li>portworxVolume</li>
<li>quobyte</li>
<li>rbd</li>
<li>scaleIO</li>
<li>secret</li>
<li>storageos</li>
<li>vsphereVolume</li>
</ul>
<blockquote>
<p>注：这些 Volume 并非全部都是持久化的，比如: emptyDir、secret、gitRepo 等，就会随着 Pod 的消亡而消失。</p>
</blockquote>
<a id="more"></a>
<h3 id="kubernetes-非持久化存储方式">Kubernetes 非持久化存储方式</h3>
<p>下面我们对一些常见的 Volume 做一个基本的介绍。</p>
<h4 id="emptrydir">emptryDir</h4>
<p>emptryDir，顾名思义是一个空目录，它的生命周期和所属的 Pod 是完全一致的。emptyDir 类型的 Volume 在 Pod 分配到 Node 上时会被创建，Kubernetes 会在 Node 上自动分配一个目录，因此无需指定 Node 宿主机上对应的目录文件。这个目录的初始内容为空，当 Pod 从 Node 上移除（Pod 被删除或者 Pod 发生迁移）时，emptyDir 中的数据会被永久删除。</p>
<p>emptyDir Volume 主要用于某些应用程序无需永久保存的临时目录，在多个容器之间共享数据等。缺省情况下，emptryDir 是使用主机磁盘进行存储的。你也可以使用其它介质作为存储，比如：网络存储、内存等。设置 <code>emptyDir.medium</code> 字段的值为 Memory 就可以使用内存进行存储，使用内存做为存储可以提高整体速度，但是要注意一旦机器重启，内容就会被清空，并且也会受到容器内存的限制。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/google_containers/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/cache</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">    <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="hostpath">hostPath</h4>
<p>hostPath 类型的 Volume 允许用户挂载 Node 宿主机上的文件或目录到 Pod 中。大多数 Pod 都用不到这种 Volume，其缺点比较明显，比如：</p>
<ul>
<li>由于每个节点上的文件都不同，具有相同配置（例如：从 podTemplate 创建的）的 Pod 在不同节点上的行为可能会有所不同。</li>
<li>在底层主机上创建的文件或目录只能由 root 写入。您需要在特权容器中以 root 身份运行进程，或修改主机上的文件权限才可以写入 hostPath 卷。</li>
</ul>
<p>当然，存在即合理。这种类型的 Volume 主要用在以下场景中：</p>
<ul>
<li>运行中的容器需要访问 Docker 内部的容器，使用 /var/lib/docker 来做为 hostPath 让容器内应用可以直接访问 Docker 的文件系统。</li>
<li>在容器中运行 cAdvisor，使用 /dev/cgroups 来做为 hostPath。</li>
<li>和 DaemonSet 搭配使用，用来操作主机文件。例如：日志采集方案 FLK 中的 FluentD 就采用这种方式来加载主机的容器日志目录，达到收集本主机所有日志的目的。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">k8s.gcr.io/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/test-pd</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="comment"># directory location on host</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/data</span></span><br><span class="line">      <span class="comment"># this field is optional</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure>
<h3 id="kubernetes-持久化存储方式">Kubernetes 持久化存储方式</h3>
<p>Kubernetes 目前可以使用 PersistentVolume、PersistentVolumeClaim、StorageClass 三种 API 资源来进行持久化存储，下面分别介绍下各种资源的概念。</p>
<h4 id="pv">PV</h4>
<p>PV 的全称是：PersistentVolume（持久化卷）。PersistentVolume 是 Volume 的一种类型，是对底层的共享存储的一种抽象。PV 由集群管理员进行创建和配置，就像节点 (Node) 是集群中的资源一样，PV 也是集群资源的一种。PV 包含存储类型、存储大小和访问模式。PV 的生命周期独立于 Pod，例如：当使用它的 Pod 销毁时对 PV 没有影响。</p>
<p>PersistentVolume 通过插件机制实现与共享存储的对接。Kubernetes 目前支持以下插件类型：</p>
<ul>
<li>GCEPersistentDisk</li>
<li>AWSElasticBlockStore</li>
<li>AzureFile</li>
<li>AzureDisk</li>
<li>FC (Fibre Channel)</li>
<li>FlexVolume</li>
<li>Flocker</li>
<li>NFS</li>
<li>iSCSI</li>
<li>RBD (Ceph Block Device)</li>
<li>CephFS</li>
<li>Cinder (OpenStack block storage)</li>
<li>Glusterfs</li>
<li>VsphereVolume</li>
<li>Quobyte Volumes</li>
<li>HostPath</li>
<li>VMware Photon</li>
<li>Portworx Volumes</li>
<li>ScaleIO Volumes</li>
<li>StorageOS</li>
</ul>
<h4 id="pvc">PVC</h4>
<p>PVC 的全称是：PersistentVolumeClaim（持久化卷声明），PVC 是用户对存储资源的一种请求。PVC 和 Pod 比较类似，Pod 消耗的是节点资源，PVC 消耗的是 PV 资源。Pod 可以请求 CPU 和内存，而 PVC 可以请求特定的存储空间和访问模式。对于真正使用存储的用户不需要关心底层的存储实现细节，只需要直接使用 PVC 即可。</p>
<h4 id="storageclass">StorageClass</h4>
<p>由于不同的应用程序对于存储性能的要求也不尽相同，比如：读写速度、并发性能、存储大小等。如果只能通过 PVC 对 PV 进行静态申请，显然这并不能满足任何应用对于存储的各种需求。为了解决这一问题，Kubernetes 引入了一个新的资源对象：StorageClass，通过 StorageClass 的定义，集群管理员可以先将存储资源定义为不同类型的资源，比如快速存储、慢速存储等。</p>
<p>当用户通过 PVC 对存储资源进行申请时，StorageClass 会使用 Provisioner（不同 Volume 对应不同的 Provisioner）来自动创建用户所需 PV。这样应用就可以随时申请到合适的存储资源，而不用担心集群管理员没有事先分配好需要的 PV。</p>
<ul>
<li>自动创建的 PV 以 <code>${namespace}-${pvcName}-${pvName}</code> 这样的命名格式创建在后端存储服务器上的共享数据目录中。</li>
<li>自动创建的 PV 被回收后会以 <code>archieved-${namespace}-${pvcName}-${pvName}</code> 这样的命名格式存在后端存储服务器上。</li>
</ul>
<h3 id="kubernetes-访问存储资源的方式">Kubernetes 访问存储资源的方式</h3>
<p>Kubernetes 目前可以使用三种方式来访问存储资源。</p>
<ul>
<li>直接访问</li>
</ul>
<p>该种方式移植性比较差，可扩展能力差。把 Volume 的基本信息完全暴露给用户，有安全隐患。</p>
<p><img src="https://www.hi-linux.com/img/linux/k8s-pv01.png" alt=""></p>
<ul>
<li>静态 PV</li>
</ul>
<p>集群管理员提前手动创建一些 PV。它们带有可供集群用户使用的实际存储的细节，之后便可用于 PVC 消费。</p>
<p><img src="https://www.hi-linux.com/img/linux/k8s-pv02.png" alt=""></p>
<blockquote>
<p>注：这种方式请求的 PVC 必须要与管理员创建的 PV 保持一致，如：存储大小和访问模式，否则不能将 PVC 绑定到 PV 上。</p>
</blockquote>
<ul>
<li>动态 PV</li>
</ul>
<p>当集群管理员创建的静态 PV 都不匹配用户的 PVC 时，PVC 请求存储类 StorageClass，StorageClass 动态的为 PVC 创建所需的 PV。</p>
<p><img src="https://www.hi-linux.com/img/linux/k8s-pv03.png" alt=""></p>
<blockquote>
<p>注：此功能需要基于 StorageClass。集群管理员必须先创建并配置好请求的 StorageClass，只有请求的 StorageClass 存在的情况下才能进行动态的创建。</p>
</blockquote>
<h3 id="使用-pv-进行持久化存储实例">使用 PV 进行持久化存储实例</h3>
<p>这里我们将介绍如何使用 PV 资源进行数据持久化，这也是本文的重点内容。我们将以 NFS 做为后端存储结合 PV 为例，讲解 Kubernetes 如何实现数据持久化。</p>
<h4 id="部署-nfs-服务器">部署 NFS 服务器</h4>
<h5 id="安装-nfs-服务端">安装 NFS 服务端</h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Ubuntu &#x2F; Debian</span><br><span class="line">$ sudo apt install nfs-kernel-server</span><br></pre></td></tr></table></figure>
<h5 id="新建数据目录和设置目录权限">新建数据目录和设置目录权限</h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">$ sudo chmod 755 &#x2F;data&#x2F;kubernetes&#x2F;</span><br></pre></td></tr></table></figure>
<h5 id="配置-nfs-服务端">配置 NFS 服务端</h5>
<p>NFS 的默认配置文件是 <code>/etc/exports</code> ，在该配置文件中添加下面的配置信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;exports</span><br><span class="line">&#x2F;data&#x2F;kubernetes  *(rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure>
<p>配置文件说明：</p>
<ul>
<li>/data/kubernetes  设置共享的数据的目录。</li>
<li><code>*</code> 表示任何人都有权限连接，当然也可以设置成是一个网段、一个 IP、或者是域名。</li>
<li>rw 设置共享目录的读写权限。</li>
<li>sync 表示文件同时写入硬盘和内存。</li>
<li>no_root_squash 当登录 NFS 主机使用共享目录的使用者是 root 时，其权限将被转换成为匿名使用者，通常它的 UID 与 GID，都会变成 nobody 身份。</li>
</ul>
<h5 id="启动-nfs-服务端">启动 NFS 服务端</h5>
<ul>
<li>启动 NFS 服务端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nfs-kernel-server</span><br></pre></td></tr></table></figure>
<ul>
<li>验证 NFS 服务端是否正常启动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpcinfo -p|grep nfs</span><br><span class="line">100003    3   tcp   2049  nfs</span><br><span class="line">100003    4   tcp   2049  nfs</span><br><span class="line">100003    3   udp   2049  nfs</span><br></pre></td></tr></table></figure>
<ul>
<li>查看具体目录挂载权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;var&#x2F;lib&#x2F;nfs&#x2F;etab</span><br><span class="line">&#x2F;data&#x2F;kubernetes	*(rw,sync,wdelay,hide,nocrossmnt,secure,no_root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid&#x3D;65534,anongid&#x3D;65534,sec&#x3D;sys,rw,secure,no_root_squash,no_all_squash)</span><br></pre></td></tr></table></figure>
<p>如果以上步骤都正常的话，到这里 NFS 服务端就已经正常安装完成。</p>
<h5 id="安装-nfs-客户端">安装 NFS 客户端</h5>
<ul>
<li>安装 NFS 客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install nfs-common</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：所有 Node 宿主机都需要安装 NFS 客户端。</p>
</blockquote>
<ul>
<li>验证 RPC 服务状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status rpcbind.service</span><br><span class="line">● rpcbind.service - RPC bind portmap service</span><br><span class="line">   Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;rpcbind.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Tue 2018-08-07 09:54:29 CST; 49s ago</span><br><span class="line">     Docs: man:rpcbind(8)</span><br><span class="line"> Main PID: 17501 (rpcbind)</span><br><span class="line">    Tasks: 1 (limit: 2313)</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;rpcbind.service</span><br><span class="line">           └─17501 &#x2F;sbin&#x2F;rpcbind -f -w</span><br></pre></td></tr></table></figure>
<ul>
<li>检查 NFS 服务端可用的共享目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo showmount -e 192.168.100.213</span><br><span class="line">Export list for 192.168.100.213:</span><br><span class="line">&#x2F;data&#x2F;kubernetes *</span><br></pre></td></tr></table></figure>
<ul>
<li>挂载 NFS 共享目录到本地</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">$ sudo mount -t nfs 192.168.100.213:&#x2F;data&#x2F;kubernetes&#x2F; &#x2F;data&#x2F;kubernetes&#x2F;</span><br></pre></td></tr></table></figure>
<ul>
<li>验证 NFS 客户端</li>
</ul>
<p>挂载成功后，在客户端上面的目录中新建一个文件，然后检查在 NFS 服务端的共享目录下是否也会出现该文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 在 NFS 客户端新建</span><br><span class="line">$ sudo touch &#x2F;data&#x2F;kubernetes&#x2F;test.txt</span><br><span class="line"></span><br><span class="line"># 在 NFS 服务端查看</span><br><span class="line">$ sudo ls -ls &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">total 0</span><br><span class="line">0 -rw-r--r-- 1 root root 0 Aug  7 09:59 test.txt</span><br></pre></td></tr></table></figure>
<h4 id="实现静态-pv">实现静态 PV</h4>
<h5 id="新建-pv-资源">新建 PV 资源</h5>
<p>完成上面的共享存储后，我们就可以来使用 PV 和 PVC 来管理和使用这些共享存储。PV 作为存储资源主要包括存储能力、访问模式、存储类型、回收策略等关键信息。</p>
<p>下面我们来新建一个 PV 对象并使用 NFS 做为后端存储类型，该 PV 包括 1G 的存储空间、访问模式为 ReadWriteOnce、回收策略为 Recyle。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">pv1-nfs.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv1-nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/kubernetes</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.213</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：Kubernetes 支持的 PV 类型有很多，比如常见的 Ceph、GlusterFs、NFS 等。更多的支持类型可以查看<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener">官方文档</a>。</p>
</blockquote>
<p>我们先使用 Kubectl 创建该 PV 资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f pv1-nfs.yaml</span><br><span class="line">persistentvolume &quot;pv1-nfs&quot; created</span><br></pre></td></tr></table></figure>
<p>从下面的结果，我们可以看到 pv1-nfs 已经创建成功。状态是 Available，这表示 pv1-nfs 准备就绪，可以被 PVC 申请。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Available                                      46s</span><br></pre></td></tr></table></figure>
<p>我们对上面的 PV 属性来做一个简单的解读。</p>
<p><strong>Capacity（存储能力）</strong></p>
<p>一般来说，一个 PV 对象都要指定一个存储能力，通过 PV 的 Capacity 属性来设置。这里的 storage=1Gi 表示设置存储空间的大小。</p>
<p><strong>AccessModes（访问模式）</strong></p>
<p>AccessModes 是用来对 PV 进行访问模式的设置，用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：</p>
<ul>
<li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载。</li>
<li>ReadOnlyMany（ROX）：只读权限，可以被多个节点挂载。</li>
<li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载。</li>
</ul>
<blockquote>
<p>注：一些 PV 可能支持多种访问模式，但是在挂载的时候只能使用一种访问模式，多种访问模式是不会生效的。</p>
</blockquote>
<p>下图是一些常用的 Volume 插件支持的访问模式：</p>
<p><img src="https://www.hi-linux.com/img/linux/k8s-pv04.png" alt=""></p>
<p><strong>PersistentVolumeReclaimPolicy（回收策略）</strong></p>
<p>当前 PV 设置的回收策略，我们这里指定的 PV 的回收策略为 Recycle。目前 PV 支持的策略有三种：</p>
<ul>
<li>Retain（保留）- 保留数据，需要管理员手工清理数据。</li>
<li>Recycle（回收）- 清除 PV 中的数据，效果相当于执行 <code>rm -rf /thevoluem/*</code> 。</li>
<li>Delete（删除）- 与 PV 相连的后端存储完成 Volume 的删除操作，这种方式常见于云服务商的存储服务，比如 ASW EBS。</li>
</ul>
<blockquote>
<p>注：目前只有 NFS 和 HostPath 两种类型支持回收策略。设置为 Retain 这种策略会更加保险一些。</p>
</blockquote>
<p><strong>状态</strong></p>
<p>一个 PV 的生命周期中，可能会处于 4 种不同的阶段。</p>
<ul>
<li>Available（可用）：表示可用状态，还未被任何 PVC 绑定。</li>
<li>Bound（已绑定）：表示 PV 已经被 PVC 绑定。</li>
<li>Released（已释放）：PVC 被删除，但是资源还未被集群重新声明。</li>
<li>Failed（失败）： 表示该 PV 的自动回收失败。</li>
</ul>
<h5 id="新建-pvc-资源">新建 PVC 资源</h5>
<p>我们平时真正使用的资源其实是 PVC，就类似于我们的服务是通过 Pod 来运行的，而不是 Node，只是 Pod 跑在 Node 上而已。</p>
<p>首先，我们新建一个数据卷声明，向 PV 请求 1Gi 的存储容量。其访问模式设置为 ReadWriteOnce。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">pvc1-nfs.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc1-nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>
<p>在新建 PVC 之前，我们可以看下之前创建的 PV 的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Available                                      28m</span><br></pre></td></tr></table></figure>
<p>我们可以看到当前 pv1-nfs 是在 Available 的一个状态，所以这个时候我们的 PVC 可以和这个 PV 进行绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f pvc1-nfs.yaml</span><br><span class="line">persistentvolumeclaim &quot;pvc1-nfs&quot; created</span><br><span class="line"></span><br><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc1-nfs   Bound     pv1-nfs   1Gi        RWO                           34s</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看到 pvc1-nfs 创建成功了，并且状态是 Bound 状态。这个时候我们再看下 PV 的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    CLAIM              STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Bound     default&#x2F;pvc1-nfs                            31m</span><br></pre></td></tr></table></figure>
<p>同样我们可以看到 PV 也是 Bound 状态，对应的声明是 default/pvc1-nfs，表示 default 命名空间下面的 pvc1-nfs，表示我们刚刚新建的 pvc1-nfs 和 pv1-nfs 绑定成功。</p>
<p>PV 和 PVC 的绑定是系统自动完成的，不需要显示指定要绑定的 PV。系统会根据 PVC 中定义的要求去查找处于 Available 状态的 PV。</p>
<ul>
<li>如果找到合适的 PV 就完成绑定。</li>
<li>如果没有找到合适的 PV 那么 PVC 就会一直处于 Pending 状态，直到找到合适的 PV 完成绑定为止。</li>
</ul>
<p>下面我们来看一个例子，这里声明一个 PVC 的对象，它要求 PV 的访问模式是 ReadWriteOnce、存储容量 2Gi 和标签值为 app=nfs。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">pvc2-nfs.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc2-nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nfs</span></span><br></pre></td></tr></table></figure>
<p>我们先查看下当前系统的所有 PV 资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    CLAIM              STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Bound     default&#x2F;pvc1-nfs                            52m</span><br></pre></td></tr></table></figure>
<p>从结果可以看到，目前所有 PV 都是 Bound 状态，并没有 Available 状态的 PV。所以我们现在用上面新建的 PVC 是无法匹配到合适的 PV 的。我们来创建 PVC 看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f pvc2-nfs.yaml</span><br><span class="line">persistentvolumeclaim &quot;pvc2-nfs&quot; created</span><br><span class="line"></span><br><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc1-nfs   Bound     pv1-nfs   1Gi        RWO                           28m</span><br><span class="line">pvc2-nfs   Pending                                                      16s</span><br></pre></td></tr></table></figure>
<p>从结果我们可以看到 pvc2-nfs 当前就是 Pending 状态，因为并没有合适的 PV 给这个 PVC 使用。现在我们来新建一个合适该 PVC 使用的 PV。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">pv2-nfs.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv2-nfs</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.213</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/kubernetes</span></span><br></pre></td></tr></table></figure>
<p>使用 Kubectl 创建该 PV。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f pv2-nfs.yaml</span><br><span class="line">persistentvolume &quot;pv2-nfs&quot; created</span><br><span class="line"></span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    CLAIM              STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Bound     default&#x2F;pvc1-nfs                            1h</span><br><span class="line">pv2-nfs   2Gi        RWO            Recycle          Bound     default&#x2F;pvc2-nfs                            18s</span><br></pre></td></tr></table></figure>
<p>创建完 pv2-nfs 后，从上面的结果你会发现该 PV 已经是 Bound 状态了。其对应的 PVC 是 default/pvc2-nfs，这就证明 pvc2-nfs 终于找到合适的 PV 且完成了绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc1-nfs   Bound     pv1-nfs   1Gi        RWO                           36m</span><br><span class="line">pvc2-nfs   Bound     pv2-nfs   2Gi        RWO                           9m</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：如果 PVC 申请的容量大小小于 PV 提供的大小，PV 同样会分配该 PV 所有容量给 PVC，如果 PVC 申请的容量大小大于 PV 提供的大小，此次申请就会绑定失败。</p>
</blockquote>
<h5 id="使用-pvc-资源">使用 PVC 资源</h5>
<p>这里我们已经完成了 PV 和 PVC 创建，现在我们就可以使用这个 PVC 了。这里我们使用 Nginx 的镜像来创建一个 Deployment，将容器的 <code>/usr/share/nginx/html</code> 目录通过 Volume 挂载到名为 pvc2-nfs 的 PVC 上，并通过 NodePort 类型的 Service 来暴露服务。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">nfs-pvc-deploy.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nfs-pvc</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">        <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">          <span class="attr">claimName:</span> <span class="string">pvc2-nfs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-pvc</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs-pvc</span></span><br></pre></td></tr></table></figure>
<p>使用 Kubectl 创建这个 Deployment。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f nfs-pvc-deploy.yaml</span><br><span class="line">deployment.extensions &quot;nfs-pvc&quot; created</span><br><span class="line">service &quot;nfs-pvc&quot; created</span><br><span class="line"></span><br><span class="line">$ kubectl get pods -o wide|grep nfs-pvc</span><br><span class="line">nfs-pvc-789788587b-ctp58                        1&#x2F;1       Running     0          4m        172.30.24.6   dev-node-02</span><br><span class="line">nfs-pvc-789788587b-q294p                        1&#x2F;1       Running     0          4m        172.30.92.6   dev-node-03</span><br><span class="line">nfs-pvc-789788587b-rtl5s                        1&#x2F;1       Running     0          4m        172.30.87.9   dev-node-01</span><br><span class="line"></span><br><span class="line">$ kubectl get svc|grep nfs-pvc</span><br><span class="line">nfs-pvc                         NodePort       10.254.5.24      &lt;none&gt;                                            80:8682&#x2F;TCP                5m</span><br></pre></td></tr></table></figure>
<p>通过 NodePort 访问该服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl -I http:&#x2F;&#x2F;192.168.100.211:8682</span><br><span class="line">HTTP&#x2F;1.1 403 Forbidden</span><br><span class="line">Server: nginx&#x2F;1.7.9</span><br><span class="line">Date: Tue, 07 Aug 2018 03:42:30 GMT</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 168</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>我们可以看到 Nginx 返回了 403，这是因为我们用 NFS 中的共享目录做为 Nginx 的默认站点目录，目前这个 NFS 共享目录中没有可用的 index.html 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls  &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure>
<p>在 NFS 服务端共享目录下新建一个 index.html 的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sh -c &quot;echo &#39;&lt;h1&gt;Hello Kubernetes~&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;data&#x2F;kubernetes&#x2F;index.html&quot;</span><br><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">index.html  test.txt</span><br></pre></td></tr></table></figure>
<p>再次通过 NodePort 访问该服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl  http:&#x2F;&#x2F;192.168.100.211:8682</span><br><span class="line">&lt;h1&gt;Hello Kubernetes~&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>
<h6 id="使用-subpath-对同一个-pv-进行隔离">使用 subPath 对同一个 PV 进行隔离</h6>
<p>从上面的例子中，我们可以看到容器中的数据是直接放到共享数据目录根目录下的。如果有多个容器都使用一个 PVC 的话，这样就很容易造成文件冲突。Pod 中 <code>volumeMounts.subPath</code> 属性可用于指定引用卷内的路径，只需设置该属性就可以解决该问题。</p>
<p>修改刚才创建 Deployment 的 YAML 文件，增加 subPath 行。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">nfs-pvc-deploy.yaml</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">  <span class="attr">subPath:</span> <span class="string">nginx-pvc-test</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>更改完 YAML 文件后，重新更新下 Deployment 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f nfs-pvc-deploy.yaml</span><br><span class="line">Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply</span><br><span class="line">deployment.extensions &quot;nfs-pvc&quot; configured</span><br><span class="line">Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply</span><br><span class="line">service &quot;nfs-pvc&quot; configured</span><br></pre></td></tr></table></figure>
<p>更新完后，NFS 的数据共享目录下就会自动新增一个同 subPath 名字一样的目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls  &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">index.html      nginx-pvc-test&#x2F; test.txt</span><br></pre></td></tr></table></figure>
<p>同样 nginx-pvc-test 目录下默认是空的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;nginx-pvc-test&#x2F;</span><br></pre></td></tr></table></figure>
<p>新增一个 index 文件后访问该服务，一切安好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sh -c &quot;echo &#39;&lt;h1&gt;Hello Kubernetes~&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;data&#x2F;kubernetes&#x2F;nginx-pvc-test&#x2F;index.html&quot;</span><br><span class="line">$ curl  http:&#x2F;&#x2F;192.168.100.211:8682</span><br><span class="line">&lt;h1&gt;Hello Kubernetes~&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>
<h5 id="验证-pvc-中的数据持久化">验证 PVC 中的数据持久化</h5>
<p>上面我们已经成功的在 Pod 中使用了 PVC 来做为存储，现在我们来验证下数据是否会丢失。我们分两种情况来验证：一种是直接删除 Deployment 和 Service，另一种是先删除 PVC 后再删除 Deployment 和 Service。</p>
<h6 id="直接删除-deployment-和-service">直接删除 Deployment 和 Service</h6>
<p>在这种情况下数据会永久保存下来，删除 Deployment 和 Service 不会对数据造成任何影响。</p>
<ul>
<li>删除 Deployment 和 Service</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f nfs-pvc-deploy.yaml</span><br><span class="line">service &quot;nfs-pvc&quot; deleted</span><br><span class="line">deployment.extensions &quot;nfs-pvc&quot; deleted</span><br></pre></td></tr></table></figure>
<ul>
<li>查看数据共享目录下面的数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;nginx-pvc-test&#x2F;</span><br><span class="line">index.html</span><br></pre></td></tr></table></figure>
<h6 id="先删除-pvc-后再删除-deployment-和-service">先删除 PVC 后再删除 Deployment 和 Service</h6>
<ul>
<li>删除 PVC</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pvc pvc2-nfs</span><br><span class="line">persistentvolumeclaim &quot;pvc2-nfs&quot; deleted</span><br></pre></td></tr></table></figure>
<p>我们可以看到 PVC 状态已经变成了 Terminating，但是现在数据共享目录中的文件和服务都是可以正常访问的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS        VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc1-nfs   Bound         pv1-nfs   1Gi        RWO                           3h</span><br><span class="line">pvc2-nfs   Terminating   pv2-nfs   2Gi        RWO                           6m</span><br><span class="line"></span><br><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;nginx-pvc-test&#x2F;</span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">$ curl  http:&#x2F;&#x2F;192.168.100.211:8928</span><br><span class="line">&lt;h1&gt;Hello Kubernetes~&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>
<p>这是因为还有 Pod 正在使用 pvc2-nfs 这个 PVC，那么对应的资源依然可用。如果无 Pod 继续使用 pvc2-nfs 这个 PVC，则相应 PVC 对应的资源就会被收回。</p>
<ul>
<li>删除 Deployment 和 Service</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f nfs-pvc-deploy.yaml</span><br><span class="line">deployment.extensions &quot;nfs-pvc&quot; deleted</span><br><span class="line">service &quot;nfs-pvc&quot; deleted</span><br><span class="line"></span><br><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc1-nfs   Bound     pv1-nfs   1Gi        RWO                           3h</span><br><span class="line"></span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM              STORAGECLASS   REASON    AGE</span><br><span class="line">pv1-nfs   1Gi        RWO            Recycle          Bound       default&#x2F;pvc1-nfs                            4h</span><br><span class="line">pv2-nfs   2Gi        RWO            Recycle          Available                                               25m</span><br><span class="line"></span><br><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;</span><br></pre></td></tr></table></figure>
<p>从上面的结果我们可以看到 pvc2-nfs 这个 PVC 已经不存在了，pv2-nfs 这个 PV 的状态也变成 Available 了。由于我们设置的 PV 的回收策略是 Recycle，我们可以发现 NFS 的共享数据目录下面的数据也没了，这是因为我们把 PVC 给删除掉后回收了数据。</p>
<h4 id="使用-storageclass-实现动态-pv">使用 StorageClass 实现动态 PV</h4>
<p>上面的例子中我们学习了静态 PV 和 PVC 的使用方法，所谓静态 PV 就是我要使用的一个 PVC 的话就必须手动去创建一个 PV。</p>
<p>这种方式在很多使用场景下使用起来都不灵活，需要依赖集群管理员事先完成 PV 的建立。特别是对于 StatefulSet 类型的应用，简单的使用静态的 PV 就不是很合适了。这种情况下我们就需要用到动态 PV，动态 PV 的实现需要用到 StorageClass。</p>
<h5 id="创建-provisioner">创建 Provisioner</h5>
<p>要使用 StorageClass，我们就得安装对应的自动配置程序。比如：我们这里存储后端使用的是 NFS，那么我们就需要使用到一个对应的自动配置程序。支持 NFS 的自动配置程序就是 <a href="https://github.com/kubernetes-incubator/external-storage/tree/master/nfs-client" target="_blank" rel="noopener">nfs-client</a>，我们把它称作 Provisioner。这个程序可以使用我们已经配置好的 NFS 服务器，来自动创建持久卷，也就是自动帮我们创建 PV。</p>
<ul>
<li>以 Deployment 方式部署一个 Provisioner</li>
</ul>
<p>根据实际情况将下面的环境变量 <code>NFS_SERVER</code>、<code>NFS_PATH</code> 和 NFS 相关配置替换成你的对应的值。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">nfs-client.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">quay.io/external_storage/nfs-client-provisioner:latest</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/persistentvolumes</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROVISIONER_NAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">fuseim.pri/ifs</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_SERVER</span></span><br><span class="line">              <span class="attr">value:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.213</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_PATH</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">/data/kubernetes</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.213</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/data/kubernetes</span></span><br></pre></td></tr></table></figure>
<p>使用 Kubectl 命令建立这个 Deployment</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f nfs-client.yaml</span><br><span class="line">deployment.extensions &quot;nfs-client-provisioner&quot; created</span><br></pre></td></tr></table></figure>
<ul>
<li>给 nfs-client-provisioner 创建 ServiceAccount</li>
</ul>
<p>从 Kubernetes 1.6 版本开始，API Server 启用了 RBAC 授权。Provisioner 要想在 Kubernetes 中创建对应的 PV 资源，就得有对应的权限。</p>
<p>这里我们新建一个名为 nfs-client-provisioner 的 ServiceAccount 并绑定在一个名为 nfs-client-provisioner-runner 的 ClusterRole 上。该 ClusterRole 包含对 PersistentVolumes 的增、删、改、查等权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ vim nfs-client-sa.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner-runner</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;persistentvolumes&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;delete&quot;]</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;persistentvolumeclaims&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]</span><br><span class="line">  - apiGroups: [&quot;storage.k8s.io&quot;]</span><br><span class="line">    resources: [&quot;storageclasses&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;events&quot;]</span><br><span class="line">    verbs: [&quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  name: run-nfs-client-provisioner</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: nfs-client-provisioner</span><br><span class="line">    namespace: default</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: nfs-client-provisioner-runner</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>
<p>使用 Kubectl 命令建立这个 ServiceAccount。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f nfs-client-sa.yaml</span><br><span class="line">serviceaccount &quot;nfs-client-provisioner&quot; created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io &quot;nfs-client-provisioner-runner&quot; created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io &quot;run-nfs-client-provisioner&quot; created</span><br></pre></td></tr></table></figure>
<ul>
<li>创建 StorageClass 对象</li>
</ul>
<p>这里我们创建了一个名为 course-nfs-storage 的 StorageClass 对象，注意下面的 Provisioner 对应的值一定要和上面的 Deployment下面 PROVISIONER_NAME 这个环境变量的值一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vim nfs-client-class.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: storage.k8s.io&#x2F;v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: course-nfs-storage</span><br><span class="line">provisioner: fuseim.pri&#x2F;ifs # or choose another name, must match deployment&#39;s env PROVISIONER_NAME&#39;</span><br></pre></td></tr></table></figure>
<p>使用 Kubectl 命令建立这个 StorageClass。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f nfs-client-class.yaml</span><br><span class="line">storageclass.storage.k8s.io &quot;course-nfs-storage&quot; created</span><br></pre></td></tr></table></figure>
<p>以上都创建完成后查看下相关资源的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods|grep nfs-client</span><br><span class="line">NAME                                            READY     STATUS      RESTARTS   AGE</span><br><span class="line">nfs-client-provisioner-9d94b899c-nn4c7          1&#x2F;1       Running     0          1m</span><br><span class="line"></span><br><span class="line">$ kubectl get storageclass</span><br><span class="line">NAME                 PROVISIONER      AGE</span><br><span class="line">course-nfs-storage   fuseim.pri&#x2F;ifs   1m</span><br></pre></td></tr></table></figure>
<h5 id="手动创建的一个-pvc-对象">手动创建的一个 PVC 对象</h5>
<ul>
<li>新建一个 PVC 对象</li>
</ul>
<p>我们这里就来建立一个能使用 StorageClass 资源对象来动态建立 PV 的 PVC，要创建使用 StorageClass 资源对象的 PVC 有以下两种方法。</p>
<p>方法一：在这个 PVC 对象中添加一个 Annotations 属性来声明 StorageClass 对象的标识。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 这里我们声明了一个 PVC 对象，采用 ReadWriteMany 的访问模式并向 PV 请求 100Mi 的空间。</span><br><span class="line">$ vim test-pvc.yaml</span><br><span class="line"></span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pvc</span><br><span class="line">  annotations:</span><br><span class="line">    volume.beta.kubernetes.io&#x2F;storage-class: &quot;course-nfs-storage&quot;</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 100Mi</span><br></pre></td></tr></table></figure>
<p>方法二：把名为 course-nfs-storage 的 StorageClass 设置为 Kubernetes 的默认后端存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl patch storageclass course-nfs-storage -p &#39;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io&#x2F;is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#39;</span><br><span class="line">storageclass.storage.k8s.io &quot;course-nfs-storage&quot; patched</span><br></pre></td></tr></table></figure>
<p>上面这两种方法都是可以的，为了不影响系统的默认行为，这里我们采用第一种方法，直接使用 YAML 文件创建即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f test-pvc.yaml</span><br><span class="line">persistentvolumeclaim &quot;test-pvc&quot; created</span><br></pre></td></tr></table></figure>
<p>创建完成后，我们来看看对应的资源是否创建成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS         AGE</span><br><span class="line">pvc1-nfs   Bound     pv1-nfs                                    1Gi        RWO                                 4h</span><br><span class="line">test-pvc   Bound     pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79   100Mi      RWX            course-nfs-storage   41s</span><br><span class="line"></span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM              STORAGECLASS         REASON    AGE</span><br><span class="line">pv1-nfs                                    1Gi        RWO            Recycle          Bound       default&#x2F;pvc1-nfs                                  5h</span><br><span class="line">pv2-nfs                                    2Gi        RWO            Recycle          Available                                                     1h</span><br><span class="line">pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79   100Mi      RWX            Delete           Bound       default&#x2F;test-pvc   course-nfs-storage             2m</span><br></pre></td></tr></table></figure>
<p>从上面的结果我们可以看到一个名为 test-pvc 的 PVC 对象创建成功并且状态已经是 Bound 了。对应也自动创建了一个名为 pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79 的 PV 对象，其访问模式是 RWX，回收策略是 Delete。STORAGECLASS 栏中的值也正是我们创建的 StorageClass 对象 course-nfs-storage。</p>
<ul>
<li>测试</li>
</ul>
<p>我们用一个简单的示例来测试下用 StorageClass 方式声明的 PVC 对象是否能正常存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ vim test-pod.yaml</span><br><span class="line"></span><br><span class="line">kind: Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: test-pod</span><br><span class="line">    image: busybox</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    command:</span><br><span class="line">    - &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">    args:</span><br><span class="line">    - &quot;-c&quot;</span><br><span class="line">    - &quot;touch &#x2F;mnt&#x2F;SUCCESS &amp;&amp; exit 0 || exit 1&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: nfs-pvc</span><br><span class="line">      mountPath: &quot;&#x2F;mnt&quot;</span><br><span class="line">  restartPolicy: &quot;Never&quot;</span><br><span class="line">  volumes:</span><br><span class="line">  - name: nfs-pvc</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: test-pvc</span><br></pre></td></tr></table></figure>
<p>上面这个 Pod 的作用非常简单，就是在一个 busybox 容器里的 /mnt 目录下面新建一个 SUCCESS 的文件，而 /mnt 目录是挂载到 test-pvc 这个资源对象上的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f test-pod.yaml</span><br><span class="line">pod &quot;test-pod&quot; created</span><br></pre></td></tr></table></figure>
<p>完成 Pod 创建后，我们可以在 NFS 服务器的共享数据目录下面查看数据是否存在。我们可以看到下面有一个名字很长的文件夹，这个文件夹的命名方式是：<code>${namespace}-${pvcName}-${pvName}</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;</span><br><span class="line">default-test-pvc-pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79</span><br></pre></td></tr></table></figure>
<p>再看下这个文件夹下面的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;default-test-pvc-pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79&#x2F;</span><br><span class="line">SUCCESS</span><br></pre></td></tr></table></figure>
<p>我们看到下面有一个 SUCCESS 的文件，说明 PV 对应的存储里可以成功写入文件。</p>
<h5 id="自动创建的一个-pvc-对象">自动创建的一个 PVC 对象</h5>
<p>在上面的演示过程中，我们可以看到是手动创建的一个 PVC 对象，而在实际使用中更多使用 StorageClass 的是 StatefulSet 类型的服务。</p>
<p>StatefulSet 类型的服务是可以通过一个 volumeClaimTemplates 属性来直接使用 StorageClass。volumeClaimTemplates 其实就是一个 PVC 对象的模板，类似于 StatefulSet 下面的 template，而这种模板可以动态的去创建相应的 PVC 对象。</p>
<ul>
<li>创建一个 StatefulSet 对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ vim test-statefulset-nfs.yaml</span><br><span class="line">apiVersion: apps&#x2F;v1beta1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-web</span><br><span class="line">spec:</span><br><span class="line">  serviceName: &quot;nginx&quot;</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nfs-web</span><br><span class="line">    spec:</span><br><span class="line">      terminationGracePeriodSeconds: 10</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.7.9</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: www</span><br><span class="line">          mountPath: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: www</span><br><span class="line">      annotations:</span><br><span class="line">        volume.beta.kubernetes.io&#x2F;storage-class: course-nfs-storage</span><br><span class="line">    spec:</span><br><span class="line">      accessModes: [ &quot;ReadWriteOnce&quot; ]</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br></pre></td></tr></table></figure>
<p>使用 Kubectl 命令建立这个 StatefulSet 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f test-statefulset-nfs.yaml</span><br><span class="line">statefulset.apps &quot;nfs-web&quot; created</span><br></pre></td></tr></table></figure>
<ul>
<li>检查相应资源对像是否已完成创建</li>
</ul>
<p>创建完成后可以看到上面 StatefulSet 对象中定义的 3 个 Pod 已经运行成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME                                            READY     STATUS      RESTARTS   AGE</span><br><span class="line">nfs-web-0                                       1&#x2F;1       Running     0          19s</span><br><span class="line">nfs-web-1                                       1&#x2F;1       Running     0          16s</span><br><span class="line">nfs-web-2                                       1&#x2F;1       Running     0          6s</span><br></pre></td></tr></table></figure>
<p>再查看下 PVC 和 PV 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME            STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS         AGE</span><br><span class="line">www-nfs-web-0   Bound     pvc-16ba792f-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            course-nfs-storage   1m</span><br><span class="line">www-nfs-web-1   Bound     pvc-18c631d4-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            course-nfs-storage   1m</span><br><span class="line">www-nfs-web-2   Bound     pvc-1ed50c38-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            course-nfs-storage   1m</span><br><span class="line"></span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                   STORAGECLASS         REASON    AGE</span><br><span class="line">pvc-16ba792f-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            Delete           Bound       default&#x2F;www-nfs-web-0   course-nfs-storage             3m</span><br><span class="line">pvc-18c631d4-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            Delete           Bound       default&#x2F;www-nfs-web-1   course-nfs-storage             3m</span><br><span class="line">pvc-1ed50c38-9a15-11e8-9a96-001c42c61a79   1Gi        RWO            Delete           Bound       default&#x2F;www-nfs-web-2   course-nfs-storage             3m</span><br></pre></td></tr></table></figure>
<p>我们可以看到生成了 3 个 PVC 对象，名称由模板名称加上 Pod 的名称组合而成，而这 3 个 PVC 对象也都是绑定状态。</p>
<ul>
<li>检查 NFS 服务器上面的是否生成相应的数据目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls  &#x2F;data&#x2F;kubernetes&#x2F; -l</span><br><span class="line">total 16</span><br><span class="line">drwxrwxrwx 2 root root 4096 Aug  7 15:32 default-test-pvc-pvc-3d8d6ecf-9a13-11e8-9a96-001c42c61a79</span><br><span class="line">drwxrwxrwx 2 root root 4096 Aug  7 15:40 default-www-nfs-web-0-pvc-16ba792f-9a15-11e8-9a96-001c42c61a79</span><br><span class="line">drwxrwxrwx 2 root root 4096 Aug  7 15:40 default-www-nfs-web-1-pvc-18c631d4-9a15-11e8-9a96-001c42c61a79</span><br><span class="line">drwxrwxrwx 2 root root 4096 Aug  7 15:40 default-www-nfs-web-2-pvc-1ed50c38-9a15-11e8-9a96-001c42c61a79</span><br></pre></td></tr></table></figure>
<h4 id="部署一个使用-storageclass-的应用">部署一个使用 StorageClass 的应用</h4>
<p>上面的例子中都是简单的运行了一个 Nginx 来演示功能，接下来我们用 Helm 来部署一个具体的应用看看效果。如果你对 Helm 还不够了解，可以先读读 「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486154&amp;idx=1&amp;sn=becd5dd0fadfe0b6072f5dfdc6fdf786&amp;chksm=eac52be3ddb2a2f555b8b1028db97aa3e92d0a4880b56f361e4b11cd252771147c44c08c8913&amp;mpshare=1&amp;scene=23&amp;srcid=0809XT1uzvaUqkaWiouHAUv4%23rd" target="_blank" rel="noopener">Helm 入门指南</a>」一文。</p>
<p>这里我们同样以部署 DokuWiki 的为例。在「<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247486201&amp;idx=1&amp;sn=8ba9e1ce4ce1cd3e62472db8b946daf9&amp;chksm=eac52bd0ddb2a2c6c579d0e083eb180d1a57c6ad968f1c6dd0f5b74f7b0702e77d85325a5128&amp;mpshare=1&amp;scene=23&amp;srcid=08211PurH1JwOAE6ueZYuZVt%23rd" target="_blank" rel="noopener">利用 Helm 快速部署 Ingress</a>」一文中我们在部署时关闭了 PersistentVolume。现在我们就演示加上 PersistentVolume 的效果。</p>
<p>DokuWiki 默认是启用 Persistence 特性的，这里主要通过 <code>persistence.apache.storageClass</code>、<code>persistence.apache.size</code> 和 <code>persistence.dokuwiki.storageClass</code>、<code>persistence.dokuwiki.size</code> 几个参数来设置 Apache 和 DokuWiki 两个应用对应的 storageClass 名称和存储大小 。</p>
<ul>
<li>使用 helm install 进行一键部署</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;k8s&#x2F;charts&#x2F;stable</span><br><span class="line">$ helm install --name dokuwiki --set &quot;ingress.enabled&#x3D;true,ingress.hosts[0].name&#x3D;wiki.hi-linux.com,persistence.apache.storageClass&#x3D;course-nfs-storage,persistence.apache.size&#x3D;500Mi,persistence.dokuwiki.storageClass&#x3D;course-nfs-storage,persistence.dokuwiki.size&#x3D;500Mi&quot;  dokuwiki</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: DEPLOYED</span><br><span class="line"></span><br><span class="line">RESOURCES:</span><br><span class="line">&#x3D;&#x3D;&gt; v1&#x2F;Secret</span><br><span class="line">NAME               TYPE    DATA  AGE</span><br><span class="line">dokuwiki-dokuwiki  Opaque  1     6m</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; v1&#x2F;PersistentVolumeClaim</span><br><span class="line">NAME                        STATUS  VOLUME                                    CAPACITY  ACCESS MODES  STORAGECLASS        AGE</span><br><span class="line">dokuwiki-dokuwiki-apache    Bound   pvc-1bfd0981-9af0-11e8-9a96-001c42c61a79  500Mi     RWO           course-nfs-storage  6m</span><br><span class="line">dokuwiki-dokuwiki-dokuwiki  Bound   pvc-1bffad3d-9af0-11e8-9a96-001c42c61a79  500Mi     RWO           course-nfs-storage  6m</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; v1&#x2F;Service</span><br><span class="line">NAME               TYPE          CLUSTER-IP     EXTERNAL-IP  PORT(S)                   AGE</span><br><span class="line">dokuwiki-dokuwiki  LoadBalancer  10.254.95.241  &lt;pending&gt;    80:8592&#x2F;TCP,443:8883&#x2F;TCP  6m</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; v1beta1&#x2F;Deployment</span><br><span class="line">NAME               DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE</span><br><span class="line">dokuwiki-dokuwiki  1        1        1           1          6m</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; v1beta1&#x2F;Ingress</span><br><span class="line">NAME               HOSTS              ADDRESS  PORTS  AGE</span><br><span class="line">dokuwiki-dokuwiki  wiki.hi-linux.com  80       6m</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; v1&#x2F;Pod(related)</span><br><span class="line">NAME                               READY  STATUS   RESTARTS  AGE</span><br><span class="line">dokuwiki-dokuwiki-bf9fb965c-d9x2w  1&#x2F;1    Running  1         6m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line"></span><br><span class="line">** Please be patient while the chart is being deployed **</span><br><span class="line"></span><br><span class="line">1. Get the DokuWiki URL indicated on the Ingress Rule and associate it to your cluster external IP:</span><br><span class="line"></span><br><span class="line">   export CLUSTER_IP&#x3D;$(minikube ip) # On Minikube. Use: &#96;kubectl cluster-info&#96; on others K8s clusters</span><br><span class="line">   export HOSTNAME&#x3D;$(kubectl get ingress --namespace default dokuwiki-dokuwiki -o jsonpath&#x3D;&#39;&#123;.spec.rules[0].host&#125;&#39;)</span><br><span class="line">   echo &quot;Dokuwiki URL: http:&#x2F;&#x2F;$HOSTNAME&#x2F;&quot;</span><br><span class="line">   echo &quot;$CLUSTER_IP  $HOSTNAME&quot; | sudo tee -a &#x2F;etc&#x2F;hosts</span><br><span class="line"></span><br><span class="line">2. Login with the following credentials</span><br><span class="line"></span><br><span class="line">  echo Username: user</span><br><span class="line">  echo Password: $(kubectl get secret --namespace default dokuwiki-dokuwiki -o jsonpath&#x3D;&quot;&#123;.data.dokuwiki-password&#125;&quot; | base64 --decode)</span><br></pre></td></tr></table></figure>
<ul>
<li>查看部署完成后状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm list</span><br><span class="line">NAME         	REVISION	UPDATED                 	STATUS  	CHART              	NAMESPACE</span><br><span class="line">dokuwiki     	1       	Wed Aug  8 17:47:48 2018	DEPLOYED	dokuwiki-2.0.3     	default</span><br></pre></td></tr></table></figure>
<ul>
<li>在后端存储上查看对应的数据目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 应用对应的数据目录已经自动创建</span><br><span class="line">$ ls &#x2F;data&#x2F;kubernetes&#x2F;*dokuwiki* -ld</span><br><span class="line">drwxrwxrwx 3 root   root   4096 Aug  8 17:52 &#x2F;data&#x2F;kubernetes&#x2F;default-dokuwiki-dokuwiki-apache-pvc-1bfd0981-9af0-11e8-9a96-001c42c61a79</span><br><span class="line">drwxrwxrwx 5 daemon daemon 4096 Aug  8 17:53 &#x2F;data&#x2F;kubernetes&#x2F;default-dokuwiki-dokuwiki-dokuwiki-pvc-1bffad3d-9af0-11e8-9a96-001c42c61a79</span><br><span class="line"></span><br><span class="line"># 查看应用对应的数据目录下文件</span><br><span class="line">$ ls  &#x2F;data&#x2F;kubernetes&#x2F;default-dokuwiki-dokuwiki-dokuwiki-pvc-1bffad3d-9af0-11e8-9a96-001c42c61a79&#x2F; -l</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x  2 daemon daemon 4096 Aug  8 17:49 conf</span><br><span class="line">drwxr-xr-x 12 daemon daemon 4096 Aug  8 17:48 data</span><br><span class="line">drwxr-xr-x  5 daemon daemon 4096 Aug  8 17:48 lib</span><br><span class="line"></span><br><span class="line">$ ls  &#x2F;data&#x2F;kubernetes&#x2F;default-dokuwiki-dokuwiki-apache-pvc-1bfd0981-9af0-11e8-9a96-001c42c61a79&#x2F;conf&#x2F;</span><br><span class="line">bitnami  deflate.conf  extra  httpd.conf  magic  mime.types  original  vhosts</span><br></pre></td></tr></table></figure>
<ul>
<li>访问 Web</li>
</ul>
<p>根据提示生成相应的登陆用户名和密码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo Username: user</span><br><span class="line">Username: user</span><br><span class="line"></span><br><span class="line">$ echo Password: $(kubectl get secret --namespace default dokuwiki-dokuwiki -o jsonpath&#x3D;&quot;&#123;.data.dokuwiki-password&#125;&quot; | base64 --decode)</span><br><span class="line">Password: e2GrABBkwF</span><br></pre></td></tr></table></figure>
<p>通过浏览器访问该应用。效果图如下：</p>
<p><img src="https://www.hi-linux.com/img/linux/k8s-ingress01.png" alt=""></p>
<h3 id="参考文档">参考文档</h3>
<p><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a><br>
<a href="http://t.cn/RmDscuQ" target="_blank" rel="noopener">http://t.cn/RmDscuQ</a><br>
<a href="http://t.cn/RDqXk2U" target="_blank" rel="noopener">http://t.cn/RDqXk2U</a><br>
<a href="http://t.cn/RDqX1qi" target="_blank" rel="noopener">http://t.cn/RDqX1qi</a><br>
<a href="http://t.cn/RDqT4Xw" target="_blank" rel="noopener">http://t.cn/RDqT4Xw</a><br>
<a href="http://t.cn/RmDscuQ" target="_blank" rel="noopener">http://t.cn/RmDscuQ</a><br>
<a href="http://t.cn/RDqg4D0" target="_blank" rel="noopener">http://t.cn/RDqg4D0</a><br>
<a href="http://t.cn/RDqkyoC" target="_blank" rel="noopener">http://t.cn/RDqkyoC</a><br>
<a href="http://t.cn/RDVE0bW" target="_blank" rel="noopener">http://t.cn/RDVE0bW</a><br>
<a href="http://t.cn/R6GaBUK" target="_blank" rel="noopener">http://t.cn/R6GaBUK</a></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "10135-1588830050631-449",
			        "name": "「奇妙的 Linux 世界」",
			        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",
			        "keyword": "VIP"
			    });
			}
			</script>
		
                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/posts/29792.html" data-toggle="tooltip" data-placement="top" title="使用 IPVS 实现 Kubernetes 入口流量负载均衡">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/posts/50873.html" data-toggle="tooltip" data-placement="top" title="浅谈 DDoS 攻击与防御">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                
                    <!-- disqus 评论框 start -->
                    <div class="comment">
                        <div id="lv-container" data-id="city" data-uid="MTAyMC8yNzg2My80NDQw"></div>
                    </div>
                    <!-- disqus 评论框 end -->
                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#kubernetes-volume-相关概念"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">Kubernetes Volume 相关概念</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#kubernetes-非持久化存储方式"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">Kubernetes 非持久化存储方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#emptrydir"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">emptryDir</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#hostpath"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">hostPath</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#kubernetes-持久化存储方式"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">Kubernetes 持久化存储方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#pv"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">PV</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#pvc"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">PVC</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#storageclass"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">StorageClass</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#kubernetes-访问存储资源的方式"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">Kubernetes 访问存储资源的方式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#使用-pv-进行持久化存储实例"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">使用 PV 进行持久化存储实例</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#部署-nfs-服务器"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">部署 NFS 服务器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#安装-nfs-服务端"><span class="toc-nav-number">5.1.1.</span> <span class="toc-nav-text">安装 NFS 服务端</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#新建数据目录和设置目录权限"><span class="toc-nav-number">5.1.2.</span> <span class="toc-nav-text">新建数据目录和设置目录权限</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#配置-nfs-服务端"><span class="toc-nav-number">5.1.3.</span> <span class="toc-nav-text">配置 NFS 服务端</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#启动-nfs-服务端"><span class="toc-nav-number">5.1.4.</span> <span class="toc-nav-text">启动 NFS 服务端</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#安装-nfs-客户端"><span class="toc-nav-number">5.1.5.</span> <span class="toc-nav-text">安装 NFS 客户端</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#实现静态-pv"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">实现静态 PV</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#新建-pv-资源"><span class="toc-nav-number">5.2.1.</span> <span class="toc-nav-text">新建 PV 资源</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#新建-pvc-资源"><span class="toc-nav-number">5.2.2.</span> <span class="toc-nav-text">新建 PVC 资源</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#使用-pvc-资源"><span class="toc-nav-number">5.2.3.</span> <span class="toc-nav-text">使用 PVC 资源</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#使用-subpath-对同一个-pv-进行隔离"><span class="toc-nav-number">5.2.3.1.</span> <span class="toc-nav-text">使用 subPath 对同一个 PV 进行隔离</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#验证-pvc-中的数据持久化"><span class="toc-nav-number">5.2.4.</span> <span class="toc-nav-text">验证 PVC 中的数据持久化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#直接删除-deployment-和-service"><span class="toc-nav-number">5.2.4.1.</span> <span class="toc-nav-text">直接删除 Deployment 和 Service</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#先删除-pvc-后再删除-deployment-和-service"><span class="toc-nav-number">5.2.4.2.</span> <span class="toc-nav-text">先删除 PVC 后再删除 Deployment 和 Service</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#使用-storageclass-实现动态-pv"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text">使用 StorageClass 实现动态 PV</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#创建-provisioner"><span class="toc-nav-number">5.3.1.</span> <span class="toc-nav-text">创建 Provisioner</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#手动创建的一个-pvc-对象"><span class="toc-nav-number">5.3.2.</span> <span class="toc-nav-text">手动创建的一个 PVC 对象</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#自动创建的一个-pvc-对象"><span class="toc-nav-number">5.3.3.</span> <span class="toc-nav-text">自动创建的一个 PVC 对象</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#部署一个使用-storageclass-的应用"><span class="toc-nav-number">5.4.</span> <span class="toc-nav-text">部署一个使用 StorageClass 的应用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#参考文档"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">参考文档</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                        
                          <a class="tag" href="/tags/#Kubernetes" title="Kubernetes">Kubernetes</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://www.mike.org.cn/" target="_blank">简单.生活</a></li>
                    
                        <li><a href="http://shang.qq.com/wpa/qunwpa?idkey=ea4c43493c2269428ac6ef6141de4b6d78e5ab2d41380ca4099b833b62884ee9" target="_blank">技术交流群</a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






    <!-- 来必力City版公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
       (function(d, s) {
           var j, e = d.getElementsByTagName(s)[0];
    
           if (typeof LivereTower === 'function') { return; }
    
           j = d.createElement(s);
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;
    
           e.parentNode.insertBefore(j, e);
       })(document, 'script');
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    <!-- 来必力City版 公共JS代码 end -->



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                    <li>
                        <a href="/atom.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/80imike">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/2093524665">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Mike 2020 | Hosted by <a href="https://pages.coding.me" target="_blank" rel="noopener" style="font-weight: bold">Coding Pages</a>
                    <br>
                    Theme by <a href="http://beantech.org" target="_blank" rel="noopener">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://www.huweihuang.com" target="_blank" rel="noopener">胡伟煌</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huweihuang&repo=hexo-theme-huweihuang&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://www.hi-linux.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://www.hi-linux.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script>(function(w,d, s, id) {w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js, fjs = d.getElementsByTagName(s)[0];js = d.createElement(s); js.id = id;js.src = 'https://cdn.webpushr.com/app.min.js';fjs.parentNode.appendChild(js);}(window,document, 'script', 'webpushr-jssdk'));webpushr('init','BF9JK7xV9kjWTdMx2lr6RWaPfXV7wNuZaVAJ1bfIGoBNJavqLEBVFMKLubITnCA4bh2fI9iH9tMF95nXnPt7xxY');</script></body>

</html>
