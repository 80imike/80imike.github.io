<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="Linux,运维,Nginx,Zabbix,Centos,Ansible,MySQL,Python,Docker,Kubernetes,K3s,AI,WireGuard,ELK,Haproxy,Git,Nodejs,安全,技术">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          史上最全 SSH 暗黑技巧详解 - 奇妙的 Linux 世界
        
    </title>

    <link rel="canonical" href="https://www.hi-linux.com/posts/60266.html">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
<link rel="stylesheet" href="/css/beantech.min.css">

    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/toc.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="奇妙的 Linux 世界" type="application/atom+xml">
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/building.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#技巧" title="技巧">技巧</a>
                            
                              <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                            
                              <a class="tag" href="/tags/#SSH" title="SSH">SSH</a>
                            
                        </div>
                        <h1>史上最全 SSH 暗黑技巧详解</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Mike on
                            2024-01-23
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">奇妙的 Linux 世界</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <div id="vip-container"><p>我见过太多的老鸟、新手对 SSH 基本只限于 SSH 到远程机器，实际这个命令我们一天要用很多次，但是对它的了解太少了，他的强大远远超出你的想象。当于你也许会说够用就够了，确实没错，但是你考虑过效率没有，或者还有哪些脑洞大开的功能会让你爱死他，这些功能又仅仅是一行命令就够了。</p>
<p>疫情期间一行 SSH 命令让我节省了 70% 的出差时间，来，让我们一起走一遍，看看会不会让你大开眼界。</p>
<a id="more"></a>
<h2><span id="本文试图解决的问题">本文试图解决的问题</span></h2>
<ul>
<li>如何通过 SSH 命令正确上网</li>
<li>Docker 镜像、Golang 仓库总是被墙怎么办</li>
<li>公司跳板机要输入动态 Token，太麻烦了，如何省略掉这个 Token；</li>
<li>比如多机房总是要走跳板机，如何 <code>绕过</code> 跳板机直连；</li>
<li>我的开发测试机器如何免打通、免密码、直达；</li>
<li>如何访问隔离环境中( K8s )的 Web 服务 – 将隔离环境中的web端口映射到本地</li>
<li>如何让隔离环境的机器用上 Yum、APT</li>
<li>如何将服务器的图形界面映射到本地(类似 VNC 的作用)</li>
<li>SSH 如何调试诊断，这才是终极技能……</li>
</ul>
<h2><span id="注意事项">注意事项</span></h2>
<ul>
<li>SSH 是指的 openSSH 命令工具</li>
<li>本文适用于各种 Linux、macOS 下命令行操作，Windows 的话各种可视化工具都可以复制 Session、配置 Tunnel 来实现类似功能。</li>
<li>如果文章中提到的文件、文件夹不存在可以直接创建出来。</li>
<li>所有配置都是在你的笔记本上（相当于 SSH Client上）</li>
</ul>
<h2><span id="正确上网">正确上网</span></h2>
<p>有时候正确上网还得靠自己，一行 SSH 命令来正确上网:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ssh -qTfnN -D 127.0.0.1:38080 root@1.1.1.1 &quot;vmstat 10&quot; 2&gt;&amp;1 &gt;&#x2F;dev&#x2F;null &amp;</span><br></pre></td></tr></table></figure>
<p>上面的 1.1.1.1 是你在境外的一台服务器，已经做好了免密登陆（免密见后面，要不你还得输一下密码），这句话的意思就是在本地启动一个 38080 的端口，上面收到的任何东西都会转发给 1.1.1.1:22（做了 SSH 加密），1.1.1.1:22 会解密收到的东西，然后把他们转发给 Google 之类的网站（比如你要访问的是 Google），结果依然通过原路返回</p>
<p>127.0.0.1:38080  就是要填入到你的浏览器中的 Socks5 代理服务器，什么都不需要装，非常简单。</p>
<p><img src="https://img.hi-linux.com/staticfile/n3mrq5-2024-01-22-7OPIZB.png" alt></p>
<p>原理图如下(灰色矩形框就是你本地 SSH 命令，SSH 线就是在穿墙， 国外服务器就是命令中的 1.1.1.1)：</p>
<p><img src="https://img.hi-linux.com/staticfile/Wqm4wS-2024-01-22-UmMYjx.png" alt></p>
<h3><span id="正确上网之-http-特殊代理-利用-ssh-本地转发是-http-协议">正确上网之 HTTP 特殊代理 – 利用 SSH 本地转发是 HTTP 协议</span></h3>
<p>前面所说的代理是 Socks5 代理，一般浏览器都有插件支持，但是比如你的 Docker（或者其他程序）需要通过 HTTP 去拉取镜像就会出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon 8.704 kB</span><br><span class="line">Step 1 : FROM k8s.gcr.io&#x2F;kube-cross:v1.10.1-1</span><br><span class="line">Get https:&#x2F;&#x2F;k8s.gcr.io&#x2F;v1&#x2F;_ping: dial tcp 108.177.125.82:443: i&#x2F;o timeout</span><br></pre></td></tr></table></figure>
<p><a href="https://www.atatech.org/articles/102153" target="_blank" rel="noopener">如果是 Git 这样的应用内部可以配置 Socks5 和 HTTP 代理服务器，请参考另外一篇文章</a>，但是有些应用就不能配置了，当然最终通过 SSH 大法还是可以解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssh -L 443:108.177.125.82:443 root@1.1.1.1 &#x2F;&#x2F; 在本地监听 443，转发给远程 108.177.125.82 的 443 端口</span><br></pre></td></tr></table></figure>
<p>然后再在 <code>/etc/hosts</code> 中将域名 <a href="http://k8s.gcr.io" target="_blank" rel="noopener">k8s.gcr.io</a> 指向 127.0.0.1， 那么本来要访问 <a href="http://k8s.gcr.io:443" target="_blank" rel="noopener">k8s.gcr.io:443</a> 的，变成了访问本地 127.0.0.1:443 而 127.0.0.1:443 又通过 SSH 重定向到了 108.177.125.82:443 这样就实现了 HTTP 代理或者说这种特殊情况下的正确上网。这个方案不需要装任何东西，但是每个访问目标都要这样处理，好在这种情况不多。</p>
<h2><span id="内部堡垒机-跳板机都需要密码动态码太复杂了怎么解">内部堡垒机、跳板机都需要密码+动态码，太复杂了，怎么解？</span></h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/config </span></span><br><span class="line"><span class="meta">#</span><span class="bash">reuse the same connection --关键配置</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~/tmp/ssh_mux_%h_%p_%r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查了下 ControlPersist 是在 OpenSSH5.6 加入的，5.3还不支持</span></span><br><span class="line"><span class="meta">#</span><span class="bash">不支持的话直接把这行删了，不影响功能</span></span><br><span class="line"><span class="meta">#</span><span class="bash">keep one connection <span class="keyword">in</span> 72hour</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ControlPersist 72h</span></span><br><span class="line"><span class="meta">#</span><span class="bash">复用连接的配置到这里，后面的配置与复用无关</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">其它也很有用的配置</span></span><br><span class="line">GSSAPIAuthentication=no</span><br><span class="line"><span class="meta">#</span><span class="bash">这个配置在公网因为安全原因请谨慎关闭</span></span><br><span class="line">StrictHostKeyChecking=no</span><br><span class="line">TCPKeepAlive=yes</span><br><span class="line">CheckHostIP=no</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"ServerAliveInterval [seconds]"</span> configuration <span class="keyword">in</span> the SSH configuration so that your ssh client sends a <span class="string">"dummy packet"</span> on a regular interval so that the router thinks that the connection is active even <span class="keyword">if</span> it<span class="string">'s particularly quiet</span></span></span><br><span class="line">ServerAliveInterval=15</span><br><span class="line"><span class="meta">#</span><span class="bash">ServerAliveCountMax=6</span></span><br><span class="line">ForwardAgent=yes</span><br><span class="line"></span><br><span class="line">UserKnownHostsFile /dev/null</span><br></pre></td></tr></table></figure>
<p>在你的 SSH 配置文件增加上述参数，意味着 72 小时内登录同一台跳板机只有第一次需要输入密码，以后都是重用之前的连接，所以也就不再需要输入密码了。</p>
<p>加了如上参数后的登录过程就有这样的东东(默认没有，这是 Debug 信息)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">debug1: setting up multiplex master socket</span><br><span class="line">debug3: muxserver_listen: temporary control path   &#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.**_22_corp.86g3C34vy36tvCtn</span><br><span class="line">debug2: fd 3 setting O_NONBLOCK</span><br><span class="line">debug3: fd 3 is O_NONBLOCK</span><br><span class="line">debug3: fd 3 is O_NONBLOCK</span><br><span class="line">debug1: channel 0: new [&#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.*.*_22_corp]</span><br><span class="line">debug3: muxserver_listen: mux listener channel 0 fd 3</span><br><span class="line">debug1: control_persist_detach: backgrounding master process</span><br><span class="line">debug2: control_persist_detach: background process is 15154</span><br><span class="line">debug2: fd 3 setting O_NONBLOCK</span><br><span class="line">debug1: forking to background</span><br><span class="line">debug1: Entering interactive session.</span><br><span class="line">debug2: set_control_persist_exit_time: schedule exit in 259200 seconds</span><br><span class="line">debug1: multiplexing control connection</span><br></pre></td></tr></table></figure>
<p><code>/home/ren/tmp/ssh_mux_10.16.*.*_22_corp</code> 这个就是保存好的 Socket，下次可以重用，免密码。 in 259200 seconds 对应 72小时</p>
<h2><span id="我有很多不同机房或者说不同客户的机器都需要跳板机来登录能一次直接-ssh-上去吗">我有很多不同机房（或者说不同客户）的机器都需要跳板机来登录，能一次直接 SSH 上去吗？</span></h2>
<p>比如有一批客户机房的机器 IP 都是 192.168.<em>.</em>, 然后需要走跳板机 100.10.1.2 才能访问到，那么我希望以后<strong>在笔记本上直接 ssh 192.168.1.5 就能直接连上</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;ssh&#x2F;ssh_config</span><br><span class="line"></span><br><span class="line">Host 192.168.*.*</span><br><span class="line">ProxyCommand ssh -l ali-renxijun 100.10.1.2 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br></pre></td></tr></table></figure>
<p>上面配置的意思是执行 <code>ssh 192.168.1.5</code> 的时候命中规则 <code>Host 192.168.*.*</code> 所以执行 <code>ProxyCommand</code> 先连上跳板机再通过跳板机连向 192.168.1.5 。这样在你的笔记本上就跟 192.168.<em>.</em> 的机器仿佛在一起，SSH 可以上去，但是 ping 不通这个 192.168.1.5 的 IP</p>
<p><strong>划重点：公司的线上跳板机做了特殊限制，限制了这个技能。日常环境跳板机支持这个功能</strong></p>
<p>比如我的跳板配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#到美国的机器用美国的跳板机速度更快</span><br><span class="line">Host 10.74.*</span><br><span class="line">ProxyCommand ssh -l user us.jump exec &#x2F;bin&#x2F;nc %h %p 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">#到中国的机器用中国的跳板机速度更快</span><br><span class="line">Host 10.70.*</span><br><span class="line">ProxyCommand ssh -l user cn.jump exec &#x2F;bin&#x2F;nc %h %p 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">   </span><br><span class="line">Host 192.168.0.*</span><br><span class="line">ProxyCommand ssh -l user 1.1.1.1 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br></pre></td></tr></table></figure>
<p>其实我的配置文件里面还有很多规则，懒得一个个隐藏 IP 了，这些规则是可以重复匹配的</p>
<p>来看一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ren@ren-VirtualBox:&#x2F;$ ping -c 1 10.16.1.*</span><br><span class="line">        PING 10.16.1.* (10.16.1.*) 56(84) bytes of data.^C</span><br><span class="line">    --- 10.16.1.* ping statistics ---</span><br><span class="line">    1 packets transmitted, 0 received, 100% packet loss, time 0ms</span><br><span class="line">    </span><br><span class="line">ren@ren-VirtualBox:~$ ssh -l corp 10.16.1.* -vvv</span><br><span class="line">OpenSSH_6.7p1 Ubuntu-5ubuntu1, OpenSSL 1.0.1f 6 Jan 2014</span><br><span class="line">debug1: Reading configuration data &#x2F;home&#x2F;ren&#x2F;.ssh&#x2F;config</span><br><span class="line">debug1: Reading configuration data &#x2F;etc&#x2F;ssh&#x2F;ssh_config</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 28: Applying options for *</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 44: Applying options for 10.16.*.*</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 68: Applying options for *</span><br><span class="line">debug1: auto-mux: Trying existing master</span><br><span class="line">debug1: Control socket &quot;&#x2F;home&#x2F;ren&#x2F;tmp&#x2F;ssh_mux_10.16.1.*_22_corp&quot; does not exist</span><br><span class="line">debug1: Executing proxy command: exec ssh -l corp 139.*.*.* exec &#x2F;usr&#x2F;bin&#x2F;nc 10.16.1* 22</span><br></pre></td></tr></table></figure>
<p>本来我的笔记本跟 10.16.1.* 是不通的(ping 不通），但是 SSH 可以直接连上，实际 SSH 登录过程中自动走跳板机 139.<em>.</em>.* 就连上了</p>
<p><code>-vvv</code> 参数是 debug，把 SSH 登录过程的日志全部打印出来。</p>
<h2><span id="将隔离环境中的-web-端口映射到本地本地代理">将隔离环境中的 Web 端口映射到本地（本地代理）</span></h2>
<p>远程机器部署了 Web Server（端口 8083），需要通过浏览器来访问这个 WEB 服务，但是 server 在隔离环境中，只能通过 SSH 访问到。一般来说会在隔离环境中部署一个 Windows 机器，通过这个 Windows 机器来访问到这个 Web Server。能不能省掉这个 Windows 机器呢？</p>
<p>现在我们试着用 SSH 来实现本地浏览器直接访问到这个隔离环境中的 Web Server。</p>
<p>假设 Web Server 是：10.1.1.123:8083， SSH 账号是：user</p>
<p>先配置好本地直接 <code>ssh user@10.1.1.123</code> （参考前面的 <code>ProxyCommand</code> 配置过程，最好是免密也配置好），然后在你的笔记本上执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CNfL 0.0.0.0:8088:10.1.1.123:8083 user@10.1.1.123</span><br></pre></td></tr></table></figure>
<p>或者：(<a href="mailto:root@100.1.2.3">root@100.1.2.3</a> -p 54900 是可达10.1.1.123的代理服务器)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CNfL 0.0.0.0:8089:10.1.1.123:8083 root@100.1.2.3 -p 54900</span><br></pre></td></tr></table></figure>
<p>这表示在本地启动一个 8088 的端口，将这个 8088 端口映射到 10.1.1.123 的 8083 端口上，用的 SSH 账号是 user</p>
<p>然后在笔记本上的浏览器中输入：127.0.0.1:8088 就看到了如下界面：</p>
<p><img src="https://img.hi-linux.com/staticfile/bOUSWh-2024-01-22-CPWM1b.png" alt></p>
<p>反过来，<strong>也可以让隔离环境机器通过代理上网，比如安装 yum</strong></p>
<h2><span id="为什么有时候-ssh-比较慢比如总是需要-30-秒钟后才能正常登录">为什么有时候 SSH 比较慢，比如总是需要 30 秒钟后才能正常登录</span></h2>
<p>先了解如下知识点，在 ~/.ssh/config 配置文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GSSAPIAuthentication&#x3D;no</span><br></pre></td></tr></table></figure>
<p>禁掉 GSSAPI 认证，GSSAPIAuthentication 是个什么鬼东西请自行 Google (多一次没必要的授权认证过程，然后等待超时)。 这里要理解 SSH 登录的时候有很多种认证方式（公钥、密码等等），具体怎么调试请记住强大的命令参数 <code>ssh -vvv</code> 上面讲到的技巧都能通过 <code>-vvv</code> 看到具体过程。</p>
<p>比如我第一次碰到 ssh 比较慢总是需要 30 秒后才登录，不能忍受，于是登录的时候加上 -vvv 明显看到控制台停在了：GSSAPIAuthentication 然后 Google 了一下，禁掉就好了</p>
<p>当然还有去掉每次 SSH 都需要先输入 Yes</p>
<h2><span id="批量打通所有机器之间的-ssh-登录免密码">批量打通所有机器之间的 SSH 登录免密码</span></h2>
<p><strong>Expect 在有些公司是被禁止的</strong></p>
<p>SSH 免密码的原理是将本机的 Pubkey 复制到目标机器的 <code>~/.ssh/authorized_keys</code> 里面。可以手工复制粘贴，也可以 ssh-copy-id 等。</p>
<p>如果有 100 台机器，互相两两打通还是比较费事（大概需要100*99次 copy key）。 下面通过 expect 来解决输入密码，然后配合 Shell 脚本来批量解决这个问题。</p>
<p><img src="https://img.hi-linux.com/staticfile/OkaCp5-2024-01-22-dxXOti.png" alt></p>
<p>这个脚本需要四个参数：目标IP、用户名、密码、Home 目录，也就是 SSH 到一台机器的时候帮我们自动填上 yes，和密码，这样就不需要人肉一个个输入了。</p>
<p>再在外面写一个循环对每个 IP 执行如下操作：</p>
<p><img src="https://img.hi-linux.com/staticfile/S3qQYl-2024-01-22-BqCQTy.png" alt></p>
<p>if 代码部分检查本机 ~/.ssh/ 下有没有 id_rsa.pub，也就是是否以前生成过密钥对，没生成的话就帮忙生成一次。</p>
<p>for 循环部分一次把生成的密钥对和 authorized_keys 复制到所有机器上，这样所有机器之间都不需要输入密码就能互相登陆了（当然本机也不需要输入密码登录所有机器）</p>
<p>最后一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh $user@$n &quot;hostname -i&quot;</span><br></pre></td></tr></table></figure>
<p>验证一下没有输密码是否能成功 SSH 上去。</p>
<p><strong>思考一下，为什么这么做就可以打通两两之间的免密码登录，这里没有把所有机器的 PubKey 复制到其他所有机器上去啊</strong></p>
<blockquote>
<p>答案：其实这个脚本做了一个取巧投机的事，那就是让所有机器共享一套公钥、私钥。<br>
有时候我也会把我的 Windows 笔记本和我专用的某台虚拟机共享一套秘钥，这样任何新申请的机器打通一次账号就可以在两台机器上随便登录。请保护好自己的私钥</p>
</blockquote>
<p>如果免密写入 authorized_keys 成功，但是通过 SSH Pubkey 认证的时候还是有可能失败，这是因为 Pubkey 认证要求：</p>
<ul>
<li>authorized_keys  文件权限要对</li>
<li>.ssh 文件夹权限要对</li>
<li>/home/user 文件夹权限要对 ----这个容易忽视掉</li>
</ul>
<h2><span id="留个作业第一次-ssh-某台机器的时候总是出来一个警告需要-yes-确认才能往下走怎么干掉他">留个作业：第一次 SSH 某台机器的时候总是出来一个警告，需要 Yes 确认才能往下走，怎么干掉他？</span></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; StrictHostKeyChecking&#x3D;no</span><br><span class="line">&gt; UserKnownHostsFile&#x3D;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>
<p><strong>这里只是帮大家入门了解 SSH ，掌握好这些配置文件和 -vvv 后有好多好玩的可以去挖掘，同时也请在留言中说出你的黑技能</strong></p>
<h2><span id="~sshconfig-参考配置">~/.ssh/config 参考配置</span></h2>
<p>下面是我个人常用的 SSH Config 配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat ~/.ssh/config</span></span><br><span class="line"><span class="meta">#</span><span class="bash">GSSAPIAuthentication=no</span></span><br><span class="line">StrictHostKeyChecking=no</span><br><span class="line"><span class="meta">#</span><span class="bash">TCPKeepAlive=yes</span></span><br><span class="line">CheckHostIP=no</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"ServerAliveInterval [seconds]"</span> configuration <span class="keyword">in</span> the SSH configuration so that your ssh client sends a <span class="string">"dummy packet"</span> on a regular interval so that the router thinks that the connection is active even <span class="keyword">if</span> it<span class="string">'s particularly quiet</span></span></span><br><span class="line">ServerAliveInterval=15</span><br><span class="line"><span class="meta">#</span><span class="bash">ServerAliveCountMax=6</span></span><br><span class="line">ForwardAgent=yes</span><br><span class="line"></span><br><span class="line">UserKnownHostsFile /dev/null</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">reuse the same connection</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath /tmp/ssh_mux_%h_%p_%r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">keep one connection <span class="keyword">in</span> 72hour</span></span><br><span class="line">ControlPersist 72h</span><br><span class="line"></span><br><span class="line">Host 192.168.1.*</span><br><span class="line">ProxyCommand ssh user@us.jump exec /usr/bin/nc %h %p 2&gt;/dev/null</span><br><span class="line">Host 192.168.2.*</span><br><span class="line">ProxyCommand ssh user@cn.jump exec /usr/bin/nc %h %p 2&gt;/dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash">ProxyCommand /bin/nc -x localhost:12346 %h %p</span></span><br><span class="line"></span><br><span class="line">Host 172</span><br><span class="line">    HostName 10.172.1.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump root@1.2.3.4:12345</span><br><span class="line"></span><br><span class="line">Host 176</span><br><span class="line">    HostName 10.176.1.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump admin@1.2.3.4:12346</span><br><span class="line">    </span><br><span class="line">Host 10.5.*.*, 10.*.*.*</span><br><span class="line">    port 22</span><br><span class="line">			user root</span><br><span class="line">			ProxyJump plantegg@1.2.3.4:12347</span><br></pre></td></tr></table></figure>
<p>ProxyJump 完全可以取代 ProxyCommand，比如 ProxyJump 不再依赖 nc、也更灵活一些。</p>
<h2><span id="etcsshssh_config-参考配置">/etc/ssh/ssh_config 参考配置</span></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">Protocol 2</span><br><span class="line">ServerAliveInterval 30</span><br><span class="line">User admin</span><br><span class="line"></span><br><span class="line">host 10.10.55.*</span><br><span class="line">ProxyCommand ssh -l admin admin.jump  exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line"># uos is a hostname</span><br><span class="line">Host 10.10.1.13* 192.168.2.133 uos</span><br><span class="line">ProxyCommand ssh -l root -p 54900 1.1.1.1 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line">#debug for git proxy</span><br><span class="line">Host github.com</span><br><span class="line">#    LogLevel DEBUG3</span><br><span class="line">#    ProxyCommand ssh  -l root gfw.jump exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line">#    ProxyCommand ssh -oProxyCommand&#x3D;&#39;ssh -l admin gfw.jump:22&#39; -l root gfw.jump2 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ForwardAgent yes</span><br><span class="line">ForwardX11 yes</span><br><span class="line">ForwardX11Trusted yes</span><br><span class="line"></span><br><span class="line">    SendEnv LANG LC_*</span><br><span class="line">    HashKnownHosts yes</span><br><span class="line">    GSSAPIAuthentication no</span><br><span class="line">    GSSAPIDelegateCredentials no</span><br><span class="line">    Compression yes</span><br></pre></td></tr></table></figure>
<h2><span id="其他知识点">其他知识点</span></h2>
<p>参数的优先级是：<strong>命令行配置选项 &gt; ~/.ssh/config &gt; /etc/ssh/ssh_config</strong></p>
<p>在 SSH 的 <strong>身份验证阶段，SSH只支持服务端保留公钥，客户端保留私钥的方式</strong>，所以方式只有两种：客户端生成密钥对，将公钥分发给服务端；服务端生成密钥对，将私钥分发给客户端。只不过出于安全性和便利性，一般都是客户端生成密钥对并分发公钥（阿里云服务器秘钥对–服务器将一对密钥中的公钥放在 authorized_keys, 私钥给client登陆用）</p>
<p>服务器上的 <code>/etc/ssh/ssh_host*</code> 是用来验证服务器身份的秘钥对（对应 Client的 Known_hosts), <strong>在主机验证阶段，服务端持有的是私钥，客户端保存的是来自于服务端的公钥。注意，这和身份验证阶段密钥的持有方是相反的。</strong></p>
<p>SSH 支持多种身份验证机制，<strong>它们的验证顺序如下：gssapi-with-mic,hostbased,publickey,keyboard-interactive,password</strong>，但常见的是密码认证机制 (password) 和公钥认证机制 (public key). 当公钥认证机制未通过时，再进行密码认证机制的验证。这些认证顺序可以通过 SSH 配置文件(注意，不是sshd 的配置文件)中的指令 PreferredAuthentications 改变。</p>
<h3><span id="永久隧道">永久隧道</span></h3>
<p>大多时候隧道会失效，或者断开，我们需要有重连机制，一般可以通过 autossh（需要单独安装）搞定自动重连，再配合 Systemd 或者 Crond 搞定永久自动重连</p>
<p>比如以下代码在 gf 开启 2 个远程转发端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">remote_port&#x3D;(30081 30082)</span><br><span class="line">for port in &quot;$&#123;remote_port[@]&#125;&quot;</span><br><span class="line">do</span><br><span class="line">    line&#x3D;&#96;ps aux |grep ssh |grep $port | wc -l&#96;</span><br><span class="line">    if [[ &quot;$line&quot; -lt 1 ]]; then</span><br><span class="line">        autossh -M 0 -fNR gf:$port:127.0.0.1:22 root@gf</span><br><span class="line">    fi;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">line&#x3D;&#96;ps aux |grep ssh |grep 13129 | wc -l&#96;</span><br><span class="line">if [[ &quot;$line&quot; -lt 1 ]]; then</span><br><span class="line">    nohup ssh -fNR gf:13129:172.16.1.2:3129 root@gf</span><br><span class="line">fi;</span><br><span class="line"></span><br><span class="line">#cat &#x2F;etc&#x2F;cron.d&#x2F;jump</span><br><span class="line">#* * * * * root sh &#x2F;root&#x2F;drds_private_cloud&#x2F;jump.sh</span><br></pre></td></tr></table></figure>
<p>或者另外创建一个 Service 服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;AutoSSH tunnel on 31081 to gf server</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment&#x3D;&quot;AUTOSSH_GATETIME&#x3D;0&quot;</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;autossh -M 0 -q -N -o &quot;ServerAliveInterval 60&quot; -o &quot;ServerAliveCountMax 3&quot; -NR gf:31081:172.16.1.2:22 -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa root@gf</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>
<h3><span id="调试-ssh终极大招">调试 SSH–终极大招</span></h3>
<p>好多问题我都是 Debug 发现的</p>
<ul>
<li>客户端增加参数 -vvv 会把所有流程在控制台显示出来。卡在哪个环节；密码不对还是 Key 不对一看就知道</li>
<li>server 端还可以：<code>/usr/sbin/sshd -ddd -p 2222</code> 在 2222 端口对 sshd 进行 Debug，看输出信息验证为什么 pubkey 不能 Login 等. 一般都是权限不对，/root 以及 /root/.ssh 文件夹的权限和owner都要对，更不要说 /root/.ssh/authorized_keys 了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;sshd -ddd -p 2222</span><br></pre></td></tr></table></figure>
<h3><span id="ssh-提示信息"></span></h3>
<p>可以用一下脚本生成一个彩色文件，放到 /etc/motd 中就行</p>
<p>Basic colors are numbered:</p>
<ul>
<li>1 – Red</li>
<li>2 – Green</li>
<li>3 – Yellow</li>
<li>4 – Blue</li>
<li>5 – Magenta</li>
<li>6 – Cyan</li>
<li>7 – White</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">export TERM=xterm-256color</span><br><span class="line"></span><br><span class="line">read one five fifteen rest &lt; /proc/loadavg</span><br><span class="line">echo "$(tput setaf 2)</span><br><span class="line">Kernel: `uname -v | awk -v OFS=' ' '&#123;print $4, $5&#125;'`</span><br><span class="line">                                                                                                                                   </span><br><span class="line">        \\   ^__^</span><br><span class="line">         \\  (oo)\\_______</span><br><span class="line">            (__)\\       )\\\/\\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br><span class="line"></span><br><span class="line">本机器为长稳测试环境, 千万不要kill进程, 不要跑负载过重的任务</span><br><span class="line"></span><br><span class="line">有任何需要请联系 ** 多谢!</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput setaf 4)Load Averages......: <span class="variable">$&#123;one&#125;</span>, <span class="variable">$&#123;five&#125;</span>, <span class="variable">$&#123;fifteen&#125;</span> (1, 5, 15 min)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput setaf 5)</span></span><br><span class="line"> ______________</span><br><span class="line">本机器为长稳测试环境, 千万不要kill进程, 不要跑负载过重的任务</span><br><span class="line"></span><br><span class="line">有任何需要请联系 ** 多谢!</span><br><span class="line"> --------------</span><br><span class="line">        \\   ^__^</span><br><span class="line">         \\  (oo)\\_______</span><br><span class="line">            (__)\\       )\\\/\\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(tput sgr0)<span class="string">"</span></span></span><br></pre></td></tr></table></figure>
<p>以上脚本运行结果</p>
<p><img src="https://img.hi-linux.com/staticfile/8Hcheo-2024-01-22-Cpn0tg.png" alt></p>
<h3><span id="sshd-banner">SSHD Banner</span></h3>
<p><code>Banner</code>指定用户登录后，sshd 向其展示的信息文件（<code>Banner /usr/local/etc/warning.txt</code>），默认不展示任何内容。</p>
<p>或者配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"># no default banner path</span><br><span class="line">#Banner none</span><br><span class="line">#在配置文件末尾添加Banner &#x2F;etc&#x2F;ssh&#x2F;my_banner这一行内容：</span><br><span class="line">Banner &#x2F;etc&#x2F;ssh&#x2F;my_banner</span><br></pre></td></tr></table></figure>
<p><code>/etc/ssh/my_banner</code> 中可以放置提示内容。</p>
<h3><span id="验证秘钥对">验证秘钥对</span></h3>
<p><strong>-y</strong> Read a private OpenSSH format file and print an OpenSSH public key to stdout.</p>
<blockquote>
<p>cd ~/.ssh/ ; ssh-keygen -y -f id_rsa | cut -d’ ’ -f 2  ;  cut -d’ ’ -f 2 id_rsa.pub</p>
</blockquote>
<p><code>ssh-keygen -y -e -f &lt;private key&gt;</code>获取一个私钥并打印相应的公钥，该公钥可以直接与您可用的公钥进行比较</p>
<h3><span id="github-上你的公钥">Github 上你的公钥</span></h3>
<p>Github 可以取到你的公钥，如果别人让你查看他的服务器，直接给 <a href="https://github.com/plantegg.keys" target="_blank" rel="noopener">https://github.com/plantegg.keys</a> 这个链接，让他把下载的 Key 加到 ~/.ssh/authorized_keys 里面就行了。</p>
<h3><span id="通过-ssh-keygen-生成公钥">通过 ssh-keygen 生成公钥</span></h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &lt;&lt;&lt;y</span><br><span class="line">ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &lt;&lt;&lt;y &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">//修改 Passphrase</span><br><span class="line">ssh-keygen -p -P "12345" -N "abcde" -f .ssh/id_rsa</span><br><span class="line">//ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]</span><br><span class="line">//或者直接通过提示一步步修改：</span><br><span class="line">ssh-keygen -p</span><br></pre></td></tr></table></figure>
<p>删除或者修改 Passphrase</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; run &#96;ssh-keygen -p&#96; in a terminal. It will then prompt you for a keyfile (defaulted to the correct file for me, &#96;~&#x2F;.ssh&#x2F;id_rsa&#96;), the old passphrase (enter what you have now) and the new passphrase (enter nothing). </span><br><span class="line"></span><br><span class="line">[要注意 OpenSSH 不同版本使用的不同 format](https:&#x2F;&#x2F;www.ibm.com&#x2F;support&#x2F;pages&#x2F;openssl-wont-understand-rsa-keys-rfc4716-format)，用 OpenSSH 8.0 默认用 &quot;RFC4716&quot; 格式，老的 4.0 默认是 PKCS8 格式</span><br><span class="line"></span><br><span class="line">去修改 DSA 密钥后 Openssh 4.0 不认。 </span><br><span class="line"></span><br><span class="line">&gt; -m key_format</span><br><span class="line">&gt;         Specify a key format for the -i (import) or -e (export) conversion options.  The sup‐</span><br><span class="line">&gt;         ported key formats are: “RFC4716” (RFC 4716&#x2F;SSH2 public or private key), “PKCS8” (PEM</span><br><span class="line">&gt;         PKCS8 public key) or “PEM” (PEM public key).  The default conversion format is</span><br><span class="line">&gt;         “RFC4716”.</span><br></pre></td></tr></table></figure>
<p>如果用 8.0 去修改 PKCS8 格式的 key 可以指定格式参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p  -m &quot;PKCS8&quot; -f .&#x2F;id_dsa</span><br></pre></td></tr></table></figure>
<h3><span id="ssh-agent">SSH-Agent</span></h3>
<p>私钥设置了密码以后，每次使用都必须输入密码，有时让人感觉非常麻烦。比如，连续使用<code>scp</code>命令远程拷贝文件时，每次都要求输入密码。</p>
<p><code>ssh-agent</code>命令就是为了解决这个问题而设计的，它让用户在整个 Bash 对话（session）之中，只在第一次使用 SSH 命令时输入密码，然后将私钥保存在内存中，后面都不需要再输入私钥的密码了。</p>
<p>第一步，使用下面的命令新建一次命令行对话。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval &#96;ssh-agent&#96;</span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>ssh-agent</code> 会先自动在后台运行，并将需要设置的环境变量输出在屏幕上，类似下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent</span><br><span class="line">SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-barrett&#x2F;ssh-22841-agent; export SSH_AUTH_SOCK;</span><br><span class="line">SSH_AGENT_PID&#x3D;22842; export SSH_AGENT_PID;</span><br><span class="line">echo Agent pid 22842;</span><br></pre></td></tr></table></figure>
<p><code>eval</code>命令的作用，就是运行上面的 <code>ssh-agent</code> 命令的输出，设置环境变量。</p>
<p>第二步，在新建的 Shell 对话里面，使用 <code>ssh-add</code> 命令添加默认的私钥（比如<code>~/.ssh/id_rsa</code>，或<code>~/.ssh/id_dsa</code>，或<code>~/.ssh/id_ecdsa</code>，或<code>~/.ssh/id_ed25519</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add</span><br><span class="line">Enter passphrase for &#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa: ********</span><br><span class="line">Identity added: &#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa (&#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_dsa)</span><br></pre></td></tr></table></figure>
<p>上面例子中，添加私钥时，会要求输入密码。以后，在这个对话里面再使用密钥时，就不需要输入私钥的密码了，因为私钥已经加载到内存里面了。</p>
<p>如果添加的不是默认私钥，<code>ssh-add</code>命令需要显式指定私钥文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add my-other-key-file</span><br></pre></td></tr></table></figure>
<p>上面的命令中，<code>my-other-key-file</code>就是用户指定的私钥文件。</p>
<p>SSH agent 程序能够将您的已解密的私钥缓存起来，在需要的时候用它来解密key chanllge返回给 SSHD  <a href="https://webcache.googleusercontent.com/search?q=cache:7OfvSBFki10J:https://www.ibm.com/developerworks/cn/linux/security/openssh/part2/+&amp;cd=7&amp;hl=en&amp;ct=clnk&amp;gl=hk" target="_blank" rel="noopener">https://webcache.googleusercontent.com/search?q=cache:7OfvSBFki10J:https://www.ibm.com/developerworks/cn/linux/security/openssh/part2/+&amp;cd=7&amp;hl=en&amp;ct=clnk&amp;gl=hk</a> keychain介绍</p>
<h3><span id="安装-sshd-和-debug">安装 sshd 和 debug</span></h3>
<p>sshd 有自己的一对或多对密钥。它使用密钥向客户端证明自己的身份。所有密钥都是公钥和私钥成对出现，公钥的文件名一般是私钥文件名加上后缀<code>.pub</code>。</p>
<p>DSA 格式的密钥文件默认为 <code>/etc/ssh/ssh_host_dsa_key</code>（公钥为<code>ssh_host_dsa_key.pub</code>），RSA 格式的密钥为 <code>/etc/ssh/ssh_host_rsa_key</code>（公钥为 <code>ssh_host_rsa_key.pub</code>）。如果需要支持 SSH 1 协议，则必须有密钥<code>/etc/ssh/ssh_host_key</code>。</p>
<p>如果密钥不是默认文件，那么可以通过配置文件 <code>sshd_config</code> 的 <code>HostKey</code> 配置项指定。默认密钥的 <code>HostKey</code> 设置如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># HostKey for protocol version 1</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_key</span><br><span class="line"></span><br><span class="line"># HostKeys for protocol version 2</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_key</span><br><span class="line"># HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_dsa_ke</span><br></pre></td></tr></table></figure>
<p>注意，如果重装 sshd，<code>/etc/ssh</code>下的密钥都会重新生成（这些密钥对用于验证Server的身份），导致客户端重新 ssh 连接服务器时，会跳出警告，拒绝连接。为了避免这种情况，可以在重装 sshd 时，先备份<code>/etc/ssh</code>目录，重装后再恢复这个目录。</p>
<blockquote>
<p>调试：非后台(-D)和debug(-d)模式启动sshd，同时监听2222和3333端口</p>
<p>sshd -D -d -p 2222 -p 3333</p>
</blockquote>
<p>sshd config 配置多端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line">Port 22022</span><br><span class="line">Port 22</span><br><span class="line">#AddressFamily any</span><br><span class="line">#ListenAddress 0.0.0.0</span><br></pre></td></tr></table></figure>
<h3><span id="scp-设置-socks-代理">Scp 设置 socks 代理</span></h3>
<blockquote>
<p>scp -o “ProxyCommand=nc -X 5 -x <strong>[SOCKS_HOST]</strong>:<strong>[SOCKS_PORT]</strong> %h %p” <strong>[LOCAL/FILE/PATH]</strong> <strong>[REMOTE_USER]</strong>@<strong>[REMOTE_HOST]</strong>:<strong>[REMOTE/FILE/PATH]</strong></p>
</blockquote>
<p>其中[SOCKS_HOST]和[SOCKS_PORT]是 Socks 代理的 LOCAL_ADDRESS 和 LOCAL_PORT。[LOCAL/FILE/PATH]、[REMOTE_USER]、[REMOTE_HOST]和[REMOTE/FILE/PATH] 分别是要复制文件的本地路径、要复制到的远端主机的用户名、要复制到的远端主机名、要复制文件的远端路径，这些参数与不使用代理时一样。“ProxyCommand=nc” 表示当前运行命令的主机上需要有 nc 命令。</p>
<h3><span id="proxycommand">ProxyCommand</span></h3>
<blockquote>
<p>Specifies the proxy command for the connection. This command is launched prior to making the connection to Hostname. %h is replaced with the host defined in HostName and %p is replaced with 22 or is overridden by a Port directive.</p>
</blockquote>
<p>在 SSH 连接目标主机前先执行 ProxyCommand 中的命令，比如 <code>.ssh/config</code> 中有如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">host remote-host</span><br><span class="line">ProxyCommand ssh -l root -p 52146 1.2.3.4 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以上配置等价下面的命令</span><br><span class="line">ssh -o ProxyCommand&#x3D;&quot;ssh -l root -p 52146 1.2.3.4 exec &#x2F;usr&#x2F;bin&#x2F;nc %h %p&quot; remote-host</span><br><span class="line">&#x2F;&#x2F;or 等价</span><br><span class="line">ssh -o ProxyCommand&#x3D;&quot;ssh -l root -p 52146 -W %h:%p 1.2.3.4 &quot; remote-host</span><br><span class="line">&#x2F;&#x2F;or 等价 debug1: Setting implicit ProxyCommand from ProxyJump: ssh -l root -p 52146 -vvv -W &#39;[%h]:%p&#39; 1.2.3.4</span><br><span class="line">ssh -J root@1.2.3.4:52146 remote-host</span><br></pre></td></tr></table></figure>
<p>如上配置指的是，如果执行ssh remote-host 命中host规则，那么先执行命令 ssh -l root -p 52146 1.2.3.4 exec /usr/bin/nc 同时把remote-host和端口(默认22)传给nc</p>
<p>ProxyCommand 和 ProxyJump 很类似，ProxyJump 使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ssh到centos8机器上，走的是gf这台跳板机，本地一般和centos8不通</span><br><span class="line">ssh -J gf:22 centos8</span><br></pre></td></tr></table></figure>
<h3><span id="proxyjump">ProxyJump</span></h3>
<p>需要 <code>OpenSSH 7.3</code> 以上版本才可以使用 <code>ProxyJump</code>, 相对 ProxyCommand 更简洁方便些</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ssh 116 就可以通过 jumpserver:50023 连上 root@1.116.2.1:22</span><br><span class="line">Host 116</span><br><span class="line">    HostName 1.116.2.1</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump admin@jumpserver:50023</span><br><span class="line"></span><br><span class="line">#ssh 1.112.任意ip 都会默认走 jumpserver 跳转过去</span><br><span class="line">Host 1.112.*.*</span><br><span class="line">    Port 22</span><br><span class="line">    User root</span><br><span class="line">    ProxyJump root@jumpserver</span><br></pre></td></tr></table></figure>
<h3><span id="加密算法"></span></h3>
<p>列出本地所支持默认的加密算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#ssh -Q key                                                            </span><br><span class="line">ssh-ed25519</span><br><span class="line">ssh-ed25519-cert-v01@openssh.com</span><br><span class="line">ssh-rsa</span><br><span class="line">ssh-dss</span><br><span class="line">ecdsa-sha2-nistp256</span><br><span class="line">ecdsa-sha2-nistp384</span><br><span class="line">ecdsa-sha2-nistp521</span><br><span class="line">ssh-rsa-cert-v01@openssh.com</span><br><span class="line">ssh-dss-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp256-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp384-cert-v01@openssh.com</span><br><span class="line">ecdsa-sha2-nistp521-cert-v01@openssh.com</span><br><span class="line"></span><br><span class="line">ssh -Q cipher       # List supported ciphers</span><br><span class="line">ssh -Q mac          # List supported MACs</span><br><span class="line">ssh -Q key          # List supported public key types</span><br><span class="line">ssh -Q kex          # List supported key exchange algorithms</span><br></pre></td></tr></table></figure>
<p>比如连服务器报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug1: kex: algorithm: (no match)</span><br><span class="line">Unable to negotiate with server port 22: no matching key exchange method found. Their offer: diffie-hellman-group1-sha1,diffie-hellman-group14-sha1</span><br></pre></td></tr></table></figure>
<p>表示服务端支持 diffie-hellman-group1-sha1,diffie-hellman-group14-sha1 加密，但是client端不支持，那么可以指定算法来强制client端使用某种和server一致的加密方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh  -oKexAlgorithms&#x3D;+diffie-hellman-group14-sha1 -l user</span><br><span class="line"></span><br><span class="line">或者config中配置：</span><br><span class="line">host server_ip</span><br><span class="line">KexAlgorithms +diffie-hellman-group1-sha1</span><br></pre></td></tr></table></figure>
<p>如果仍然报以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debug2: first_kex_follows 0</span><br><span class="line">debug2: reserved 0</span><br><span class="line">debug1: kex: algorithm: diffie-hellman-group14-sha1</span><br><span class="line">debug1: kex: host key algorithm: (no match)</span><br><span class="line">Unable to negotiate with server_ip port 22: no matching host key type found. Their offer: ssh-rsa</span><br></pre></td></tr></table></figure>
<p>那么可以配置来解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">    HostKeyAlgorithms +ssh-rsa</span><br><span class="line">    PubkeyAcceptedKeyTypes +ssh-rsa</span><br></pre></td></tr></table></figure>
<p>When an SSH client connects to a server, each side offers lists of connection parameters to the other. These are, with the corresponding <a href="https://man.openbsd.org/ssh_config.5" target="_blank" rel="noopener">ssh_config</a> keyword:</p>
<ul>
<li><code>KexAlgorithms</code>: the key exchange methods that are used to generate per-connection keys</li>
<li><code>HostkeyAlgorithms</code>: the public key algorithms accepted for an SSH server to authenticate itself to an SSH client</li>
<li><code>Ciphers</code>: the ciphers to encrypt the connection</li>
<li><code>MACs</code>: the message authentication codes used to detect traffic modification</li>
</ul>
<h2><span id="无所不能的-ssh-三大转发模式">无所不能的 SSH 三大转发模式</span></h2>
<p>了解完前面的一些小知识，再来看看无所不能的三大杀招。上面的各种代理基本都是由这三种转发模式实现的。</p>
<p>SSH 能够做动态转发、本地转发、远程转发。先简要概述下他们的特点和使用场景</p>
<p><strong><a href="https://www.skywind.me/blog/archives/2546" target="_blank" rel="noopener">三个转发模式的比较</a>：</strong></p>
<ul>
<li>动态转发完全可以代替本地转发，只是动态转发是 <code>socks5协议</code>，当正确上网用，本地转发是 TCP 协议</li>
<li>本地转发完全是把动态转发特例化到访问某个固定目标的转发，类似 Iptable 的 Port Forwarding</li>
<li>远程转发是启动转端口的机器同时连上两端的两个机器，把本来不连通的两端拼接起来，中间显得多了个节点。</li>
<li>三个转发模式可以串联使用</li>
</ul>
<p>动态转发常用来正确上网，本地转发用来打洞，这两种转发启动的端口都是在本地；远程转发也是打洞的一种，只不过启用的端口在远程机器上。</p>
<p><img src="https://img.hi-linux.com/staticfile/sKbEgK-2024-01-22-mnPbqn.png" alt></p>
<h3><span id="动态转发-d-socks5-协议">动态转发 (-D)  SOCKS5 协议</span></h3>
<p>动态转发指的是，本机与 SSH 服务器之间创建了一个加密连接，然后本机内部针对某个端口的通信，都通过这个加密连接转发。它的一个使用场景就是，访问所有外部网站，都通过 SSH 转发。</p>
<p>动态转发需要把本地端口绑定到 SSH 服务器。<strong>至于 SSH 服务器要去访问哪一个网站，完全是动态的，取决于原始通信，所以叫做动态转发</strong>。</p>
<p>动态的意思就是：需要访问的目标、端口还不确定。后面要讲的本地转发、远程转发都是针对具体 IP、Port 的转发。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -D 4444 ssh-server -N</span></span><br><span class="line">//或者如下方式：</span><br><span class="line">nohup ssh -qTfnN -D *:13658 root@jump vmstat 10  &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>注意，这种转发采用了 SOCKS5 协议。访问外部网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。<code>-N</code>参数表示，这个 SSH 连接不能执行远程命令，只能充当隧道。</p>
<p><img src="https://img.hi-linux.com/staticfile/8wIxNP-2024-01-22-qJOasK.png" alt></p>
<p>下面是 SSH  隧道建立后的一个<strong>使用实例</strong>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -x socks5://localhost:4444 http://www.example.com</span><br><span class="line">or</span><br><span class="line">curl --socks5-hostname localhost:4444 https://www.twitter.com</span><br></pre></td></tr></table></figure>
<p>上面命令中，curl 的 <code>-x</code> 参数指定代理服务器，即通过 SOCKS5 协议的本地<code>3000</code>端口，访问<code>http://www.example.com</code>。</p>
<p>官方文档关于 <code>-D</code> 的介绍</p>
<blockquote>
<p>-D [bind_address:]port<br>
Specifies a local “dynamic” application-level port forwarding.  This works by allocat‐<br>
ing a socket to listen to port on the local side, optionally bound to the specified<br>
bind_address.  Whenever a connection is made to this port, the connection is forwarded<br>
over the secure channel, and the application protocol is then used to determine where<br>
to connect to from the remote machine.  Currently the SOCKS4 and SOCKS5 protocols are<br>
supported, and ssh will act as a SOCKS server.  Only root can forward privileged ports.<br>
Dynamic port forwardings can also be specified in the configuration file.</p>
</blockquote>
<p>特别注意，如果 <code>ssh -D</code> 要启动的本地 Port 已经被占用了是不会报错的，但是实际 Socks 代理会没启动成功。</p>
<h3><span id="本地转发-l">本地转发 (-L)</span></h3>
<p>本地转发（Local Forwarding）指的是，SSH 服务器作为中介的跳板机，建立本地计算机与特定<code>目标网站</code>之间的加密连接。本地转发是在本地计算机的 SSH 客户端建立的转发规则。</p>
<p>典型使用场景就是，打洞，经过跳板机访问无法直接连通的服务。</p>
<p>它会指定一个本地端口（Local-Port），所有发向那个端口的请求，都会转发到 SSH 跳板机（ssh-server），然后 SSH 跳板机作为中介，将收到的请求发到目标服务器（target-host）的目标端口（target-port）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -L :<span class="built_in">local</span>-port:target-host:target-port ssh-server  //target-host是ssh-server的target-host, target-host 域名解析、路由都是由 ssh-server 完成</span></span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>-L</code>参数表示本地转发，<code>local-port</code>是本地端口，<code>target-host</code>是你想要访问的目标服务器，<code>target-port</code>是目标服务器的端口，<code>ssh-server</code> 是 SSH 跳板机。当你访问 localhost:local-port 的时候会通过 ssh-server 把请求转给 target-host:target-port</p>
<p><img src="https://img.hi-linux.com/staticfile/INjeHZ-2024-01-22-EWAI33.png" alt></p>
<p>上图对应的命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 53682:remote-server:53682 ssh-server</span><br></pre></td></tr></table></figure>
<p>然后，访问本机的 53682 端口，就是访问 <code>remote-server</code> 的 53682 端口.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;localhost:53682</span><br></pre></td></tr></table></figure>
<p>注意，<strong>本地端口转发采用 HTTP 协议，不用转成 SOCKS5 协议</strong>。如果需要 HTTP 的动态代理，可以先起 Socks5 动态代理，然后再起一个本地转发给动态代理的 Socks5 端口，这样就有一个 HTTP 代理了，能给 Yum、Docker 之类的使用。</p>
<p>这个命令最好加上<code>-N</code>参数，表示不在 SSH 跳板机执行远程命令，让 SSH 只充当隧道。另外还有一个<code>-f</code>参数表示 SSH 连接在后台运行。</p>
<p>如果经常使用本地转发，可以将设置写入 SSH 客户端的用户个人配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host test.example.com</span><br><span class="line">LocalForward client-IP:client-port server-IP:server-port</span><br></pre></td></tr></table></figure>
<h3><span id="远程转发-r">远程转发(-R)</span></h3>
<p>远程端口指的是在远程 SSH 服务器建立的转发规则。主要是执行 SSH 转发的机器别人连不上，所以需要一台 Client 能连上的机器当远程转发端口，要不就是本地转发了。</p>
<p>由于本机无法访问内网 SSH 跳板机，就无法从外网发起 SSH 隧道，建立端口转发。必须反过来，从 SSH 跳板机发起隧道，建立端口转发，这时就形成了远程端口转发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -fNR 30.1.2.3:30081:166.100.64.1:3128 root@30.1.2.3 -p 2728</span><br></pre></td></tr></table></figure>
<p>上面的命令，首先需要注意，<strong>不是在 30.1.2.3 或者 166.100.64.1 上执行的，而是找一台能联通 30.1.2.3 和 166.100.64.1 的机器来执行</strong>，在执行前 Remote Clients 能连上 30.1.2.3 但是 30.1.2.3 和 166.100.64.1 不通，所以需要一个中介将 30.1.2.3 和166.100.64.1打通，这个中介就是下图中的MobaXterm所在的机器，命令在 MobaXterm 机器上执行</p>
<p><img src="https://img.hi-linux.com/staticfile/PER8yY-2024-01-22-IvkyqB.png" alt></p>
<p>执行上面的命令以后，跳板机 30.1.2.3 到 166.100.64.1 的隧道已经建立了，这个隧道是依赖两边都能连通的 MobaXterm 机器。然后，就可以从 Remote Client 访问目标服务器了，即在 Remote Client 上执行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;30.1.2.3:30081</span><br></pre></td></tr></table></figure>
<p>执行上面的命令以后，命令就会输出服务器 166.100.64.1 的3128端口返回的内容。</p>
<p>如果经常执行远程端口转发，可以将设置写入 SSH 客户端的用户个人配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host test.example.com</span><br><span class="line">RemoteForward local-IP:local-port target-ip:target-port</span><br></pre></td></tr></table></figure>
<p>注意远程转发需要：</p>
<blockquote>
<ol>
<li>sshd_config 里要打开 <code>AllowTcpForwarding</code> 选项，否则 <code>-R</code> 远程端口转发会失败。</li>
<li>默认转发到远程主机上的端口绑定的是 <code>127.0.0.1</code>，<a href="https://serverfault.com/questions/997124/ssh-r-binds-to-127-0-0-1-only-on-remote" target="_blank" rel="noopener">如要绑定 <code>0.0.0.0</code> 需要打开 sshd_config 里的 <code>GatewayPorts</code> 选项(然后ssh -R 后加上 *:port )</a>。这个选项如果由于权限没法打开也有办法，可配合 <code>ssh -L</code> 将端口绑定到 <code>0.0.0.0</code>。</li>
</ol>
</blockquote>
<p>开通远程转发后，如果需要动态代理（比如访问所有 Web 服务），那么可以在 30081 端口机器上(30.1.2.3)执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ssh -qTfnN -D *:13658 root@127.0.0.1 -p 30081 vmstat 10  &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>表示在 30081 机器上(30.1.2.3)启动了一个 Socks5 动态代理服务</p>
<h2><span id="调试转发-代理是否能联通">调试转发、代理是否能联通</span></h2>
<h3><span id="通过-curl-调试"></span></h3>
<blockquote>
<p>curl -I --socks5-hostname localhost:13659 <a href="http://twitter.com" target="_blank" rel="noopener">twitter.com</a></p>
<p>curl -x socks5://localhost:13659 <a href="http://twitter.com" target="_blank" rel="noopener">twitter.com</a></p>
</blockquote>
<p>Suppose you have a socks5 proxy running on localhost:13659 .</p>
<p><a href="https://blog.emacsos.com/use-socks5-proxy-in-curl.html" target="_blank" rel="noopener">In curl &gt;= 7.21.7, you can use</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -x socks5h://localhost:13659 http://www.google.com/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In a proxy string, socks5h:// and socks4a:// mean that the hostname is<br>
resolved by the SOCKS server. socks5:// and socks4:// mean that the<br>
hostname is resolved locally. socks4a:// means to use SOCKS4a, which is<br>
an extension of SOCKS4. Let’s make urllib3 honor it.</p>
</blockquote>
<p>In curl &gt;= 7.18.0, you can use</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --socks5-hostname localhost:13659 http://www.google.com/</span><br></pre></td></tr></table></figure>
<p><code>--proxy</code> 参数含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The --socks5 option is basically considered obsolete since curl 7.21.7. This is because starting in that release, you can now specify the proxy protocol directly in the string that you specify the proxy host name and port number with already. The server you specify with --proxy. If you use a socks5:&#x2F;&#x2F; scheme, curl will go with SOCKS5 with local name resolve but if you instead use socks5h:&#x2F;&#x2F; it will pick SOCKS5 with proxy-resolved host name.</span><br></pre></td></tr></table></figure>
<h3><span id="wget">wget</span></h3>
<p><strong>指定命令行参数</strong>,通过命令行指定 HTTP 代理服务器的方式如下：</p>
<blockquote>
<p>wget -Y on -e “http_proxy=http://<strong>[HTTP_HOST]</strong>:<strong>[HTTP_PORT]</strong>” <a href="http://facebook.com/" target="_blank" rel="noopener">http://facebook.com/</a></p>
</blockquote>
<p>其中：[HTTP_HOST]和[HTTP_PORT]是 HTTP Proxy 的 ADDRESS 和 PORT。</p>
<ul>
<li>-Y 表示是否使用代理，on表示使用代理。</li>
<li>-e 执行后面跟的命令，相当于在.wgetrc配置文件中添加了一条命令，将 http_proxy 设置为需要使用的代理服务器。</li>
<li>–limit-rate=2.5k 限制下载速度，进行测试</li>
</ul>
<h2><span id="pki-public-key-infrastructure证书">PKI (Public Key Infrastructure)证书</span></h2>
<p>X.509 只是一种常用的证书格式，一般以PEM编码，PEM 编码的证书通常以 <strong><code>.pem</code>、<code>.crt</code> 或 <code>.cer</code></strong> 为后缀。再次提醒，这只是“通常”情况，实际上某些工具可能并不遵循这些惯例。通过pem证书可以访问需要认证的 HTTPS 服务(比如Etcd、Apiserver 等)</p>
<ul>
<li><strong>ASN.1 用于定义数据类型</strong>，例如证书（certificate）和秘钥（key）——就像用 JSON 定义一个 request body —— X.509 用 ASN.1 定义。</li>
<li>DER 是一组将 ASN.1 编码成二进制（比特和字节）的编码规则（encoding rules）。</li>
<li>PKCS#7 and PKCS#12 是比 X.509 更大的数据结构（封装格式），也用 ASN.1 定义，其中能包含除了证书之外的其他东西。二者分别在 Java 和 Microsoft 产品中使用较多。</li>
<li>DER 编码之后是二进制数据，不方便复制粘贴，因此大部分证书都是用 PEM 编码的，它用 base64 对 DER 进行编码，然后再加上自己的 label。</li>
<li>私钥通常用是 PEM 编码的 PKCS#8 对象，但有时也会用密码来加密。</li>
</ul>
<p>通过命令 <code>cat /etc/kubernetes/pki/ca.crt | openssl x509 -text</code> 也可以得到下图信息</p>
<p><img src="https://img.hi-linux.com/staticfile/6ET22D-2024-01-22-hjfjim.png" alt></p>
<h3><span id="公钥-私钥常见扩展名">公钥、私钥常见扩展名</span></h3>
<ul>
<li>公钥：<code>.pub</code> or <code>.pem</code>，<code>ca.crt</code></li>
<li>私钥：<code>.prv,</code> <code>.key</code>, or <code>.pem</code> , <code>ca.key</code>。</li>
</ul>
<h3><span id="证书生成过程演示">证书生成过程演示</span></h3>
<p>并不是所有的场景都需要向这些大型的 CA 机构申请公钥证书，在任何一个企业，组织或是团体内都可以自己形这样的“小王国”，也就是说，你可以自行生成这样的证书，只需要你自己保证自己的生成证书的私钥的安全，以及不需要扩散到整个互联网。下面，我们用 <code>openssl</code>命令来演示这个过程。</p>
<ol>
<li>生成 CA 机构的证书（公钥） <code>ca.crt</code> 和私钥 <code>ca.key</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 \</span><br><span class="line">    -new -nodes -x509 \</span><br><span class="line">    -days 365 \</span><br><span class="line">    -out ca.crt \</span><br><span class="line">    -keyout ca.key \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;SO&#x2F;ST&#x3D;Earth&#x2F;L&#x3D;Mountain&#x2F;O&#x3D;CoolShell&#x2F;OU&#x3D;HQ&#x2F;CN&#x3D;localhost&quot;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>生成 alice 的私钥</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out alice.key 2048</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>生成 Alice 的 CSR – Certificate Signing Request</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key alice.key -days 365 -out alice.csr \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;CN&#x2F;ST&#x3D;Beijing&#x2F;L&#x3D;Haidian&#x2F;O&#x3D;CoolShell&#x2F;OU&#x3D;Test&#x2F;CN&#x3D;localhost.alice&quot;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用 CA 给 Alice 签名证书</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl x509  -req -in alice.csr \</span><br><span class="line">    -extfile &lt;(printf &quot;subjectAltName&#x3D;DNS:localhost.alice&quot;) \ </span><br><span class="line">    -CA ca.crt -CAkey ca.key  \</span><br><span class="line">    -days 365 -sha256 -CAcreateserial \</span><br><span class="line">    -out alice.crt</span><br></pre></td></tr></table></figure>
<h2><span id="参考资料">参考资料：</span></h2>
<ul>
<li><a href="http://docs.corp-inc.com/pages/editpage.action?pageId=203555361" target="_blank" rel="noopener">http://docs.corp-inc.com/pages/editpage.action?pageId=203555361</a></li>
<li><a href="https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/SSH_keys_(简体中文)</a></li>
<li><a href="https://wangdoc.com/ssh/key.html" target="_blank" rel="noopener">https://wangdoc.com/ssh/key.html</a></li>
<li><a href="https://robotmoon.com/ssh-tunnels/" target="_blank" rel="noopener">https://robotmoon.com/ssh-tunnels/</a></li>
<li><a href="https://blog.gwlab.page/vpn-over-ssh-the-socks-proxy-8a8d7bdc7028" target="_blank" rel="noopener">通过SSH动态转发来建立Socks代以及各种场景应用案例</a></li>
<li><a href="https://daniel.haxx.se/blog/2020/05/26/curl-ootw-socks5/" target="_blank" rel="noopener">https://daniel.haxx.se/blog/2020/05/26/curl-ootw-socks5/</a></li>
<li><a href="http://www.allanjude.com/bsd/AsiaBSDCon2017_-_SSH_Performance.pdf" target="_blank" rel="noopener">SSH Performance</a></li>
<li><a href="https://stackoverflow.com/questions/8849240/why-when-i-transfer-a-file-through-sftp-it-takes-longer-than-ftp" target="_blank" rel="noopener">Why when I transfer a file through SFTP, it takes longer than FTP?</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/413732839" target="_blank" rel="noopener">一行代码解决scp在Internet传输慢的问题</a></li>
<li><a href="https://www.cnxct.com/everything-about-pki-zh/" target="_blank" rel="noopener">关于证书（certificate）和公钥基础设施（PKI）的一切</a></li>
<li><a href="https://coolshell.cn/articles/21708.html" target="_blank" rel="noopener">网络数字身份认证术</a></li>
</ul>
<blockquote>
<p>本文转载自：「 plantegg 的博客 」，原文：<a href="http://tinyurl.com/25py66n3" target="_blank" rel="noopener">http://tinyurl.com/25py66n3</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p>
</blockquote>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "10135-1588830050631-449",
			        "name": "「奇妙的 Linux 世界」",
			        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",
			        "keyword": "VIP"
			    });
			}
			</script>
		
                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/posts/52460.html" data-toggle="tooltip" data-placement="top" title="简单一招，轻松把 Nginx 服务器性能提升 50 倍">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/posts/19661.html" data-toggle="tooltip" data-placement="top" title="国内外公共/加密 DNS 服务器列表">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                
                    <!-- disqus 评论框 start -->
                    <div class="comment">
                        <div id="lv-container" data-id="city" data-uid="MTAyMC8yNzg2My80NDQw"></div>
                    </div>
                    <!-- disqus 评论框 end -->
                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">本文试图解决的问题</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">注意事项</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">正确上网</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">正确上网之 HTTP 特殊代理 – 利用 SSH 本地转发是 HTTP 协议</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">内部堡垒机、跳板机都需要密码+动态码，太复杂了，怎么解？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">我有很多不同机房（或者说不同客户）的机器都需要跳板机来登录，能一次直接 SSH 上去吗？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">将隔离环境中的 Web 端口映射到本地（本地代理）</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">为什么有时候 SSH 比较慢，比如总是需要 30 秒钟后才能正常登录</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">批量打通所有机器之间的 SSH 登录免密码</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">留个作业：第一次 SSH 某台机器的时候总是出来一个警告，需要 Yes 确认才能往下走，怎么干掉他？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">~&#x2F;.ssh&#x2F;config 参考配置</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">&#x2F;etc&#x2F;ssh&#x2F;ssh_config 参考配置</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">其他知识点</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.1.</span> <span class="toc-nav-text">永久隧道</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.2.</span> <span class="toc-nav-text">调试 SSH–终极大招</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.3.</span> <span class="toc-nav-text"></span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.4.</span> <span class="toc-nav-text">SSHD Banner</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.5.</span> <span class="toc-nav-text">验证秘钥对</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.6.</span> <span class="toc-nav-text">Github 上你的公钥</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.7.</span> <span class="toc-nav-text">通过 ssh-keygen 生成公钥</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.8.</span> <span class="toc-nav-text">SSH-Agent</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.9.</span> <span class="toc-nav-text">安装 sshd 和 debug</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.10.</span> <span class="toc-nav-text">Scp 设置 socks 代理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.11.</span> <span class="toc-nav-text">ProxyCommand</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.12.</span> <span class="toc-nav-text">ProxyJump</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.13.</span> <span class="toc-nav-text"></span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">无所不能的 SSH 三大转发模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">13.1.</span> <span class="toc-nav-text">动态转发 (-D)  SOCKS5 协议</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">13.2.</span> <span class="toc-nav-text">本地转发 (-L)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">13.3.</span> <span class="toc-nav-text">远程转发(-R)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">调试转发、代理是否能联通</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">14.1.</span> <span class="toc-nav-text"></span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">14.2.</span> <span class="toc-nav-text">wget</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">15.</span> <span class="toc-nav-text">PKI (Public Key Infrastructure)证书</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">15.1.</span> <span class="toc-nav-text">公钥、私钥常见扩展名</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">15.2.</span> <span class="toc-nav-text">证书生成过程演示</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">16.</span> <span class="toc-nav-text">参考资料：</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#技巧" title="技巧">技巧</a>
                        
                          <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                        
                          <a class="tag" href="/tags/#SSH" title="SSH">SSH</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://bestgeek.org/" target="_blank">极客视界</a></li>
                    
                        <li><a href="https://666666.dev/" target="_blank">IT 人必备工具箱</a></li>
                    
                        <li><a href="https://mp.weixin.qq.com/s/ZgoeD1FBp7eouyxBte4MWw" target="_blank">Linux 技术交流群</a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






    <!-- 来必力City版公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
       (function(d, s) {
           var j, e = d.getElementsByTagName(s)[0];
    
           if (typeof LivereTower === 'function') { return; }
    
           j = d.createElement(s);
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;
    
           e.parentNode.insertBefore(j, e);
       })(document, 'script');
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    <!-- 来必力City版 公共JS代码 end -->



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                    <li>
                        <a href="/atom.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/80imike">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/2093524665">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Mike 2025 | Hosted by <a href="https://pages.coding.me" target="_blank" rel="noopener" style="font-weight: bold">Coding Pages</a>
                    <br>
                    Theme by <a href="http://beantech.org" target="_blank" rel="noopener">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://www.huweihuang.com" target="_blank" rel="noopener">胡伟煌</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huweihuang&repo=hexo-theme-huweihuang&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://www.hi-linux.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->



<script defer src="https://umami.hi-linux.com/script.js"
    data-website-id="db99ccfc-f114-4595-8f3b-9dd1fbd3bf19"></script>


	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://www.hi-linux.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script>(function(w,d, s, id) {w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js, fjs = d.getElementsByTagName(s)[0];js = d.createElement(s); js.id = id;js.src = 'https://cdn.webpushr.com/app.min.js';fjs.parentNode.appendChild(js);}(window,document, 'script', 'webpushr-jssdk'));webpushr('init','BF9JK7xV9kjWTdMx2lr6RWaPfXV7wNuZaVAJ1bfIGoBNJavqLEBVFMKLubITnCA4bh2fI9iH9tMF95nXnPt7xxY');</script></body>

</html>
