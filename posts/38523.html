<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="Linux,运维,Nginx,Zabbix,Centos,Ansible,MySQL,Python,Docker,ELK,Haproxy,Git,Nodejs,安全,技术">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          万字总结，体系化带你全面认识 Linux 系统安全强化 - 奇妙的 Linux 世界
        
    </title>

    <link rel="canonical" href="https://www.hi-linux.com/posts/38523.html">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
<link rel="stylesheet" href="/css/beantech.min.css">

    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/toc.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="奇妙的 Linux 世界" type="application/atom+xml">
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/building.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#技巧" title="技巧">技巧</a>
                            
                              <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                            
                              <a class="tag" href="/tags/#安全" title="安全">安全</a>
                            
                        </div>
                        <h1>万字总结，体系化带你全面认识 Linux 系统安全强化</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Mike on
                            2021-05-24
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">奇妙的 Linux 世界</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <div id="vip-container"><p>本指南旨在说明如何尽可能地加强 Linux 的安全性和隐私性，并且不限于任何特定的指南。</p>
<p>免责声明：如果您不确定自己在做什么，请不要尝试在本文中使用任何内容。</p>
<p>本指南仅关注安全性和隐私性，而不关注性能，可用性或其他内容。</p>
<p>列出的所有命令都将需要 root 特权。以 <code>$</code> 符号开头的单词表示一个变量，不同终端之间可能会有所不同。</p>
<h2><span id="选择正确的linux发行版">选择正确的Linux发行版</span></h2>
<p>选择一个好的 Linux 发行版有很多因素。</p>
<ul>
<li>
<p>避免分发冻结程序包，因为它们在安全更新中通常很落后</p>
</li>
<li>
<p>不使用与 Systemd 机制的发行版。 Systemd 包含许多不必要的攻击面；它尝试做的事情远远超出了必要，并且超出了初始化系统应做的事情。</p>
</li>
<li>
<p>使用 musl 作为默认的 C 库。 Musl 专注于最小化，这会导致很小的攻击面，而其他 C 库（例如 glibc）过于复杂，容易产生漏洞。例如，与 musl 中的极少数漏洞相比，glibc 中的一百多个漏洞已被公开披露。尽管仅靠披露的 CVE 本身通常是不准确的统计信息，但有时这种情况有时可以用来表示过分的问题。 Musl还具有不错的漏洞利用缓解措施，尤其是其新的强化内存分配器。</p>
</li>
<li>
<p>最好默认情况下使用 LibreSSL 而不是 OpenSSL 的发行版。OpenSSL 包含大量完全不必要的攻击面，并且遵循不良的安全做法。例如，它仍然保持 OS / 2和 VMS 支持这些已有数十年历史的古老操作系统。这些令人讨厌的安全做法导致了可怕的 Heartbleed 漏洞。LibreSSL 是 OpenBSD 团队的 OpenSSL 分支，它采用了出色的编程实践并消除了很多攻击面。在 LibreSSL 成立的第一年内，它缓解了许多漏洞，其中包括一些高严重性的漏洞。</p>
</li>
</ul>
<p>用作强化操作系统基础的最佳发行版是 Gentoo Linux，因为它可以让您精确地配置系统，以达到理想的效果，这将非常有用，尤其是参考我们在后面的章节中使用更安全的编译标志。</p>
<p>但是，由于 Gentoo 的巨大可用性缺陷，它对于许多人来说可能并不顺手。在这种情况下，Void Linux的 Musl 构建是一个很好的折衷方案。</p>
<a id="more"></a>
<h2><span id="内核">内核</span></h2>
<p>内核是操作系统的核心，不幸的是很容易受到攻击。正如Brad Spengler曾经说过的那样，可以将其视为系统上最大，最易受攻击的setuid根二进制文件。因此，对内核进行尽可能多的强化非常重要。</p>
<h3><span id="stable-vs-lts-内核">Stable vs LTS 内核</span></h3>
<p>Linux 内核以两种主要形式发布：稳定和长期支持（LTS）。稳定版本是较新的版本，而 LTS 发行版本是较老的稳定版本，长期以来一直受支持。选择上述任何一个发行版本都有许多后果。</p>
<p>Linux 内核未使用 CVE 标识安全漏洞。这意味着大多数安全漏洞的修复程序不能向后移植到 LTS 内核。但是稳定版本包含到目前为止进行的所有安全修复。</p>
<p>但是，有了这些修复程序，稳定的内核将包含更多新功能，因此大大增加了内核的攻击面，并引入了大量新错误。相反，LTS 内核的受攻击面较小，因为这些功能没有被不断添加。</p>
<p>此外，稳定的内核还包括更新的强化功能，以减轻 LTS 内核没有的某些利用。此类功能的一些示例是Lockdown LSM 和 STACKLEAK GCC 插件。</p>
<p>总而言之，在选择稳定或 LTS 内核时需要权衡取舍。LTS 内核具有较少的强化功能，并且并非当时所有的公共错误修复都已向后移植，但是通常它的攻击面更少，并且引入未知错误的可能性也较小。稳定的内核具有更多的强化功能，并且包括所有已知的错误修复，但它也具有更多的攻击面以及引入更多未知错误的机会更大。最后，最好使用较新的 LTS 分支（如4.19内核）。</p>
<h3><span id="sysctl">Sysctl</span></h3>
<p>Sysctl 是允许用户配置某些内核设置并启用各种安全功能或禁用危险功能以减少攻击面的工具。要临时更改设置，您可以执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w $tunable &#x3D; $value</span><br></pre></td></tr></table></figure>
<p>要永久更改 sysctls，您可以将要更改的 sysctls 添加到 /etc/sysctl.conf 或 /etc/sysctl.d 中的相应文件，具体取决于您的Linux发行版。</p>
<p>以下是您应更改的建议 sysctl 设置。</p>
<h3><span id="kernel-self-protection">Kernel self-protection</span></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.kptr_restrict&#x3D;2</span><br></pre></td></tr></table></figure>
<p>内核指针指向内核内存中的特定位置。这些在利用内核方面可能非常有用，但是默认情况下不会隐藏内核指针，例如，通过读取 /proc/kallsyms 的内容即可轻松发现它们。此设置旨在减轻内核指针泄漏。另外，您可以设置 <code>kernel.kptr_restrict = 1</code> 以仅从没有 CAP_SYSLOG 功能的进程中隐藏内核指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.dmesg_restrict&#x3D;1</span><br></pre></td></tr></table></figure>
<p>dmesg 是内核日志，它公开了大量有用的内核调试信息，但这通常会泄漏敏感信息，例如内核指针。更改上述 sysctl 设置会将内核日志限制为 CAP_SYSLOG 功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.printk&#x3D;3 3 3 3</span><br></pre></td></tr></table></figure>
<p>尽管 dmesg_restrict 的值，启动过程中内核日志仍将显示在控制台中。能够在引导过程中记录屏幕的恶意软件可能会滥用此恶意软件以获得更高的特权。此选项可防止这些信息泄漏。必须将其与下面描述的某些引导参数结合使用才能完全有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel.unprivileged_bpf_disabled&#x3D;1</span><br><span class="line">net.core.bpf_jit_harden&#x3D;2</span><br></pre></td></tr></table></figure>
<p>eBPF 暴露了很大的攻击面，因此需加以限制。这些系统将 eBPF 限制为 CAP_BPF 功能（在 5.8 之前的内核版本上为 CAP_SYS_ADMIN ），并启用 JIT 强化技术，例如常量绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev.tty.ldisc_autoload&#x3D;0</span><br></pre></td></tr></table></figure>
<p>这将加载 TTY 行规则限制为 CAP_SYS_MODULE 功能，以防止非特权的攻击者使用 TIOCSETD ioctl加载易受攻击的线路规则，而该 TIOCSETD ioctl 之前已在许多漏洞利用中被滥用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.unprivileged_userfaultfd&#x3D;0</span><br></pre></td></tr></table></figure>
<p>userfaultfd() 系统调用经常被滥用以利用“事后使用(use-after-free)”缺陷。因此，该 sysctl 用于将此 syscall 限制为 CAP_SYS_PTRACE 功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.kexec_load_disabled&#x3D;1</span><br></pre></td></tr></table></figure>
<p>kexec 是一个系统调用，用于在运行时引导另一个内核。可以滥用此功能来加载恶意内核并在内核模式下获得任意代码执行能力，因此该 sysctl 设置将被禁用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.sysrq&#x3D;4</span><br></pre></td></tr></table></figure>
<p>SysRq 密钥向非特权用户公开了许多潜在的危险调试功能。与通常的假设相反，SysRq 不仅是物理攻击的问题，而且还可以远程触发。该 sysctl 的值使其可以使用户只能使用SAK密钥，这对于安全地访问 root 是必不可少的。或者，您可以简单地将值设置为 0 以完全禁用 SysRq。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.unprivileged_userns_clone&#x3D;0</span><br></pre></td></tr></table></figure>
<p>用户名称空间是内核中的一项功能，旨在改善沙箱并使非特权用户易于访问它，但是，此功能公开了重要的内核攻击面，以进行特权升级，因此该 sysctl 将用户名称空间的使用限制为 CAP_SYS_ADMIN 功能。对于无特权的沙箱，建议使用具有很少攻击面的 setuid 二进制文件，以最大程度地减少特权升级的可能性。沙箱章节部分将进一步讨论此主题。</p>
<p>请注意，尽管该 sysctl 仅在某些Linux发行版中存在，因为它需要内核补丁。如果您的内核不包含此补丁，则可以通过设置 user.max_user_namespaces = 0 来完全禁用用户名称空间（包括 root 用户）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.perf_event_paranoid&#x3D;3</span><br></pre></td></tr></table></figure>
<p>性能事件会增加大量内核攻击面，并导致大量漏洞。此 sysctl 设置将性能事件的所有使用限制为 CAP_PERFMON 功能（5.8 之前的内核版本为 CAP_SYS_ADMIN）。</p>
<p>请注意，此 sysctl 设置需要在某些发行版中具备相关的内核补丁。否则，此设置等效于<code>kernel.perf_event_paranoid = 2</code>，它仅限制此功能的子集。</p>
<h3><span id="网络">网络</span></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies&#x3D;1</span><br></pre></td></tr></table></figure>
<p>这有助于防止 SYN 泛洪攻击，这种攻击是拒绝服务攻击的一种形式，在这种攻击中，攻击者发送大量虚假的 SYN 请求，以尝试消耗足够的资源以使系统对合法流量不响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_rfc1337&#x3D;1</span><br></pre></td></tr></table></figure>
<p>这通过丢弃处于时间等待状态的套接字的RST数据包来防止 time-wait 状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.rp_filter&#x3D;1</span><br><span class="line">net.ipv4.conf.default.rp_filter&#x3D;1</span><br></pre></td></tr></table></figure>
<p>这些启用了源验证，以验证从计算机所有网络接口接收到的数据包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.all.secure_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.secure_redirects&#x3D;0</span><br><span class="line">net.ipv6.conf.all.accept_redirects&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.all.send_redirects&#x3D;0</span><br><span class="line">net.ipv4.conf.default.send_redirects&#x3D;0</span><br></pre></td></tr></table></figure>
<p>这些设置禁用了 ICMP 重定向，以防止中间人攻击并最大程度地减少信息泄露。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.icmp_echo_ignore_all&#x3D;1</span><br></pre></td></tr></table></figure>
<p>此设置使您的系统忽略所有 ICMP 请求，以避免 Smurf 攻击，使设备更难以在网络上枚举，并防止通过 ICMP 时间戳识别时钟指纹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.accept_source_route&#x3D;0</span><br><span class="line">net.ipv4.conf.default.accept_source_route&#x3D;0</span><br><span class="line">net.ipv6.conf.all.accept_source_route&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_source_route&#x3D;0</span><br></pre></td></tr></table></figure>
<p>源路由是一种允许用户重定向网络流量的机制。由于这可用于执行中间人攻击，在中间人攻击中，出于恶意目的将流量重定向，因此上述设置将会禁用此功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.accept_ra&#x3D;0</span><br><span class="line">net.ipv6.conf.default.accept_ra&#x3D;0</span><br></pre></td></tr></table></figure>
<p>恶意的 IPv6 路由广告可能会导致中间人攻击，因此应将其禁用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_sack&#x3D;0</span><br><span class="line">net.ipv4.tcp_dsack&#x3D;0</span><br><span class="line">net.ipv4.tcp_fack&#x3D;0</span><br></pre></td></tr></table></figure>
<p>禁用 TCP SACK。ACK 通常被利用，并且在许多情况下是不必要的，因此如果您不需要它，则应将其禁用。</p>
<h3><span id="用户空间">用户空间</span></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.yama.ptrace_scope&#x3D;2</span><br></pre></td></tr></table></figure>
<p>ptrace 是一个系统调用，它允许程序调试、修改和检查另一个正在运行的进程，从而使攻击者可以轻易修改其他正在运行的程序的内存。设置将 ptrace 的使用限制为仅具有 CAP_SYS_PTRACE 功能的进程。或者，将 sysctl 设置为 3 以完全禁用 ptrace。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.mmap_rnd_bits&#x3D;32</span><br><span class="line">vm.mmap_rnd_compat_bits&#x3D;16</span><br></pre></td></tr></table></figure>
<p>ASLR 是一种常见的漏洞利用缓解措施，它可以使进程的关键部分在内存中的位置随机化。这可能会使各种各样的漏洞利用更困难，因为它们首先需要信息泄漏。上述设置增加了用于 mmap ASLR 的熵的位数，从而提高了其有效性。</p>
<p><strong>这些sysctls的值必须根据CPU体系结构进行设置。以上值与x86兼容，但其他体系结构可能有所不同。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.protected_symlinks&#x3D;1</span><br><span class="line">fs.protected_hardlinks&#x3D;1</span><br></pre></td></tr></table></figure>
<p>仅当在可全局写入的粘性目录之外，当符号链接和关注者的所有者匹配或目录所有者与符号链接的所有者匹配时，才允许遵循符号链接。这还可以防止没有对源文件的读/写访问权限的用户创建硬链接。这两者都阻止了许多常见的 TOCTOU 漏洞（time-of-check-to-time-of-use）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.protected_fifos&#x3D;2</span><br><span class="line">fs.protected_regular&#x3D;2</span><br></pre></td></tr></table></figure>
<p>这些阻止了在可能由攻击者控制的环境（例如，全局可写目录）中创建文件，从而使数据欺骗攻击更加困难。</p>
<h3><span id="引导参数">引导参数</span></h3>
<p>引导参数在引导时使用引导加载程序（bootloader）将设置传递给内核。类似于sysctl，可以使用某些设置来提高安全性。引导加载程序通常在引导参数设置方式上有所不同。下面列出了一些示例，但是您应该研究特定 bootloader 的修改参数的必要步骤。</p>
<p>如果使用 GRUB 作为引导程序，请编辑 <code>/etc/default/grub</code> 并将参数添加到<code>GRUB_CMDLINE_LINUX_DEFAULT=line</code>。</p>
<p>如果使用 Syslinux，请编辑 /boot/syslinux/syslinux.cfg 并将它们添加到 APPEND 行中。</p>
<p>如果使用 systemd-boot，请编辑您的加载程序条目，并将其附加到 linux 行的末尾。</p>
<p>建议使用以下设置以提高安全性。</p>
<h3><span id="kernel-self-protection">Kernel self-protection</span></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slab_nomerge</span><br></pre></td></tr></table></figure>
<p>这将禁用 slab 合并，这将通过防止覆盖合并的缓存中的对象并使其更难以影响 slab 缓存的布局，从而大大增加了堆利用的难度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slub_debug&#x3D;FZ</span><br></pre></td></tr></table></figure>
<p>这些启用健全性检查（F）和重新分区（Z）。健全性检查会添加各种检查，以防止某些slab操作中的损坏。重新分区会在 slab 周围添加额外的区域，以检测 slab 何时被覆盖超过其实际大小，从而有助于检测溢出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_on_alloc&#x3D;1 init_on_free&#x3D;1</span><br></pre></td></tr></table></figure>
<p>这样可以在分配和空闲时间期间将内存清零，这可以帮助减轻使用后使用的漏洞并清除内存中的敏感信息。如果您的内核版本低于 5.3，则这些选项不存在。而是在上述 slub_debug 选项后面附加 “P”，以获得 slub_debug=FZP 并添加 page_poison=1。由于它们实际上是一种调试功能，刚好具有一些安全性，因此它们在释放时提供的内存擦除形式较弱。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page_alloc.shuffle&#x3D;1</span><br></pre></td></tr></table></figure>
<p>此选项使页分配器空闲列表随机化，从而通过降低页分配的可预测性来提高安全性，同时这也提高了性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pti&#x3D;on</span><br></pre></td></tr></table></figure>
<p>这将启用内核页表隔离，从而减轻崩溃并防止某些 KASLR 绕过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsyscall&#x3D;none</span><br></pre></td></tr></table></figure>
<p>这将禁用 vsyscall，因为它们已过时且已被 vDSO 取代。 vsyscall 也在内存中的固定地址上，使其成为 ROP 攻击的潜在目标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugfs&#x3D;off</span><br></pre></td></tr></table></figure>
<p>这将禁用 debugfs，它会公开许多有关内核的敏感信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oops&#x3D;panic</span><br></pre></td></tr></table></figure>
<p>有时某些内核漏洞利用会导致所谓的 “oops”。此参数将引发内核对此类事件 panic，从而防止这些攻击。但是，有时错误的驱动程序会导致无害的操作，这会导致系统崩溃，这意味着此引导参数只能在某些硬件上使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.sig_enforce&#x3D;1</span><br></pre></td></tr></table></figure>
<p>这仅允许加载已使用有效密钥签名的内核模块，使加载恶意内核模块更加困难。</p>
<p>这可以防止加载所有树外内核模块（包括 DKMS 模块），除非您已对其进行签名，这意味着诸如 VirtualBox 或 Nvidia 驱动程序之类的模块可能不可用，但根据您的设置可能并不重要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lockdown&#x3D;confidentiality</span><br></pre></td></tr></table></figure>
<p>内核锁定 LSM 可以消除用户空间代码滥用以升级为内核特权并提取敏感信息的许多方法。为了在用户空间和内核之间实现清晰的安全边界，此LSM是必需的。上面的选项在 confidentiality 模式（最严格的选项）中启用此功能。这意味着 <code>module.sig_enforce=1</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mce&#x3D;0</span><br></pre></td></tr></table></figure>
<p>这将导致内核对 ECC 内存中无法利用的错误 panic，而这些错误可能会被利用。对于没有 ECC 内存的系统，这是不必要的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quiet loglevel&#x3D;0</span><br></pre></td></tr></table></figure>
<p>这些参数可防止引导期间信息泄漏，并且必须与上面的 kernel.printk sysctl 结合使用。</p>
<h3><span id="cpu缓解">CPU缓解</span></h3>
<p>最好启用适用于您的CPU的所有CPU缓解措施，以确保您不受已知漏洞的影响。这是启用所有内置缓解措施的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spectre_v2&#x3D;on spec_store_bypass_disable&#x3D;on tsx&#x3D;off tsx_async_abort&#x3D;full,nosmt mds&#x3D;full,nosmt l1tf&#x3D;full,force nosmt&#x3D;force kvm.nx_huge_pages&#x3D;force</span><br></pre></td></tr></table></figure>
<p>您必须研究系统受其影响的 CPU 漏洞，并相应地选择上述缓解措施。请记住，您将需要安装微代码更新，以完全免受这些漏洞的影响。但所有这些操作都可能导致性能显着下降。</p>
<h3><span id="结果">结果</span></h3>
<p>如果遵循了以上所有建议（不包括特定的 CPU 缓解措施），则将具有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slab_nomerge slub_debug&#x3D;FZ init_on_alloc&#x3D;1 init_on_free&#x3D;1 page_alloc.shuffle&#x3D;1 pti&#x3D;on vsyscall&#x3D;none debugfs&#x3D;off oops&#x3D;panic module.sig_enforce&#x3D;1 lockdown&#x3D;confidentiality mce&#x3D;0 quiet loglevel&#x3D;0</span><br></pre></td></tr></table></figure>
<p>如果将 GRUB 用作引导加载程序，则可能需要重新生成 GRUB 配置文件才能应用这些文件。</p>
<h3><span id="hidepid">hidepid</span></h3>
<p>proc 是一个伪文件系统，其中包含有关系统上当前正在运行的所有进程的信息。默认情况下，所有用户都可以访问此程序，这可能使攻击者可以窥探其他进程。要只允许用户看到自己的进程，而不能看到其他用户的进程，则必须使用 hidepid=2，gid=proc 挂载选项来挂载 /proc。gid=proc 将 proc 组从此功能中排除，因此您可以将特定的用户或进程列入白名单。添加这些选项的一种方法是编辑 /etc/fstab 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc &#x2F;proc proc nosuid,nodev,noexec,hidepid&#x3D;2,gid&#x3D;proc 0 0</span><br></pre></td></tr></table></figure>
<p>systemd-logind 仍然需要查看其他用户的进程，因此，要使用户会话在 systemd 系统上正常工作，必须创建 <code>/etc/systemd/system/systemd-logind.service.d/hidepid.conf</code> 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">SupplementaryGroups&#x3D;proc</span><br></pre></td></tr></table></figure>
<h3><span id="减少内核攻击面">减少内核攻击面</span></h3>
<p>最好禁用不是绝对必要的任何功能，以最大程度地减少潜在的内核攻击面。这些功能不必一定很危险，它们可以只是被删除以减少攻击面的良性代码。切勿禁用您不了解的随机事物。以下是一些可能有用的示例，具体取决于您的设置。</p>
<h3><span id="引导参数">引导参数</span></h3>
<p>引导参数通常可以用来减少攻击面，这样的例子之一是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipv6.disable&#x3D;1</span><br></pre></td></tr></table></figure>
<p>这将禁用整个IPv6堆栈，如果您尚未迁移到该堆栈，则可能不需要该堆栈。如果正在使用的IPv6，请不要使用此引导参数。</p>
<h3><span id="将内核模块列入黑名单">将内核模块列入黑名单</span></h3>
<p>内核允许非特权的用户通过模块自动加载来间接导致某些模块被加载。这使攻击者可以自动加载易受攻击的模块，然后加以利用。一个这样的示例是 CVE-2017-6074，其中攻击者可以通过启动DCCP连接来触发DCCP内核模块的加载，然后利用该内核模块中的漏洞。</p>
<p>可以通过将文件插入 <code>/etc/modprobe.d</code> 并将指定的内核模块列入黑名单的方法，将特定的内核模块列入黑名单。</p>
<p>Install 参数告诉 modprobe 运行特定命令，而不是像往常一样加载模块。 /bin/false 是仅返回 1 的命令，该命令实际上不会执行任何操作。两者都告诉内核运行 /bin/false 而不是加载模块，这将防止攻击者利用该模块。以下是最有可能不需要的内核模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">install dccp &#x2F;bin&#x2F;false</span><br><span class="line">install sctp &#x2F;bin&#x2F;false</span><br><span class="line">install rds &#x2F;bin&#x2F;false</span><br><span class="line">install tipc &#x2F;bin&#x2F;false</span><br><span class="line">install n-hdlc &#x2F;bin&#x2F;false</span><br><span class="line">install ax25 &#x2F;bin&#x2F;false</span><br><span class="line">install netrom &#x2F;bin&#x2F;false</span><br><span class="line">install x25 &#x2F;bin&#x2F;false</span><br><span class="line">install rose &#x2F;bin&#x2F;false</span><br><span class="line">install decnet &#x2F;bin&#x2F;false</span><br><span class="line">install econet &#x2F;bin&#x2F;false</span><br><span class="line">install af_802154 &#x2F;bin&#x2F;false</span><br><span class="line">install ipx &#x2F;bin&#x2F;false</span><br><span class="line">install appletalk &#x2F;bin&#x2F;false</span><br><span class="line">install psnap &#x2F;bin&#x2F;false</span><br><span class="line">install p8023 &#x2F;bin&#x2F;false</span><br><span class="line">install p8022 &#x2F;bin&#x2F;false</span><br><span class="line">install can &#x2F;bin&#x2F;false</span><br><span class="line">install atm &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure>
<p>特别是模糊的网络协议会增加大量的远程攻击面。此黑名单：</p>
<ul>
<li>DCCP — Datagram Congestion Control Protocol</li>
<li>SCTP — Stream Control Transmission Protocol</li>
<li>RDS — Reliable Datagram Sockets</li>
<li>TIPC — Transparent Inter-process Communication</li>
<li>HDLC — High-Level Data Link Control</li>
<li>AX25 — Amateur X.25</li>
<li>NetRom</li>
<li>X25</li>
<li>ROSE</li>
<li>DECnet</li>
<li>Econet</li>
<li>af_802154 — IEEE 802.15.4</li>
<li>IPX — Internetwork Packet Exchange</li>
<li>AppleTalk</li>
<li>PSNAP — Subnetwork Access Protocol</li>
<li>p8023 — Novell raw IEEE 802.3</li>
<li>p8022 — IEEE 802.2</li>
<li>CAN — Controller Area Network</li>
<li>ATM</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">install cramfs &#x2F;bin&#x2F;false</span><br><span class="line">install freevxfs &#x2F;bin&#x2F;false</span><br><span class="line">install jffs2 &#x2F;bin&#x2F;false</span><br><span class="line">install hfs &#x2F;bin&#x2F;false</span><br><span class="line">install hfsplus &#x2F;bin&#x2F;false</span><br><span class="line">install squashfs &#x2F;bin&#x2F;false</span><br><span class="line">install udf &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure>
<p>将各种稀有文件系统列入黑名单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">install cifs &#x2F;bin&#x2F;true</span><br><span class="line">install nfs &#x2F;bin&#x2F;true</span><br><span class="line">install nfsv3 &#x2F;bin&#x2F;true</span><br><span class="line">install nfsv4 &#x2F;bin&#x2F;true</span><br><span class="line">install gfs2 &#x2F;bin&#x2F;true</span><br></pre></td></tr></table></figure>
<p>如果不使用网络文件系统，也可以将其列入黑名单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install vivid &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure>
<p><a href="https://href.li/?https://www.kernel.org/doc/html/v4.12/media/v4l-drivers/vivid.html" target="_blank" rel="noopener">vivid driver</a>驱动程序仅用于测试目的，并且是特权提升漏洞的原因，因此应禁用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install bluetooth &#x2F;bin&#x2F;false</span><br><span class="line">install btusb &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure>
<p>禁用具有安全问题历史记录的蓝牙。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install uvcvideo &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure>
<p>这会禁用网络摄像头，以防止其被用来监视您。</p>
<p>您也可以将麦克风模块列入黑名单，但这在系统之间可能会有所不同。要查找模块的名称，请在 /proc/asound/modules 中查找并将其列入黑名单。例如，一个这样的模块是 snd_hda_intel。</p>
<p>请注意，尽管有时麦克风的内核模块与扬声器的模块相同。这意味着像这样禁用麦克风也可能会无意中禁用任何扬声器，虽然扬声器也有可能变成麦克风，所以这不一定是消极的结果。</p>
<p>最好从物理上删除这些设备，或者至少在 BIOS/UEFI 中禁用它们。禁用内核模块并不总是那么有效。</p>
<h3><span id="rfkill">rfkill</span></h3>
<p>可以通过rfkill将无线设备列入黑名单，以进一步减少远程攻击面。要将所有无线设备列入黑名单，请执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill block all</span><br></pre></td></tr></table></figure>
<p>WiFi可以通过以下方式解锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill unblock wifi</span><br></pre></td></tr></table></figure>
<p>在使用systemd的系统上，rfkill在所有会话中均保持不变，但是，在使用其他init系统的系统上，您可能必须创建一个init脚本以在引导时执行这些命令。</p>
<h3><span id="其他内核指针泄漏">其他内核指针泄漏</span></h3>
<p>前面的部分已经防止了一些内核指针泄漏，但是还有更多泄漏。</p>
<p>在文件系统上，/boot 中存在内核映像和 System.map 文件。/usr/src和/{,usr/} lib/modules目录中还有其他敏感的内核信息。您应该限制这些目录的文件权限，以使它们只能由root用户读取。您还应该删除 System.map 文件，因为除高级调试外，它们都不需要。</p>
<p>此外，某些日志记录守护程序（例如 systemd 的 journalctl ）包括内核日志，可用于绕过上述 dmesg_restrict 保护。从 adm 组中删除用户通常足以撤销对以下日志的访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -d $user adm</span><br></pre></td></tr></table></figure>
<h3><span id="限制对-sysfs-的访问">限制对 sysfs 的访问</span></h3>
<p>sysfs 是伪文件系统，可提供大量的内核和硬件信息。它通常安装在/sys上。 sysfs 导致大量信息泄漏，尤其是内核指针泄漏。Whonix 的 security-misc 软件包包括 hide-hardware-info 脚本，该脚本限制访问此目录以及 /proc 中的一些脚本，以试图隐藏潜在的硬件标识符并防止内核指针泄漏。该脚本是可配置的，并允许基于组将特定的应用程序列入白名单。建议应用此方法，并使其在启动时使用 init 脚本执行。或者这样<a href="https://href.li/?https://github.com/Whonix/security-misc/blob/master/lib/systemd/system/hide-hardware-info.service" target="_blank" rel="noopener">做成systemd服务</a>。</p>
<p>为了使基本功能在使用 systemd 的系统上运行，必须将一些系统服务列入白名单。这可以通过创建 <code>/etc/systemd/system/user@.service.d/sysfs.conf</code> 并添加以下内容来完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">SupplementaryGroups&#x3D;sysfs</span><br></pre></td></tr></table></figure>
<p>但是，这不能解决所有问题。许多应用程序可能仍会中断，您需要将它们正确列入白名单。</p>
<h3><span id="linux强化">Linux强化</span></h3>
<p>某些发行版（例如 Arch Linux ）包括强化的内核程序包。它包含许多强化补丁程序和更注重安全性的内核配置。如果可能的话，建议安装它。</p>
<h3><span id="grsecurity">Grsecurity</span></h3>
<p>Grsecurity 是一组内核修补程序，可以大大提高内核安全性。这些补丁曾经可以免费获得，但是现在<a href="https://href.li/?https://grsecurity.net/passing_the_baton" target="_blank" rel="noopener">需要购买</a>了。如果可用，则强烈建议您获取它。Grsecurity 提供了最新的内核和用户空间保护。</p>
<h3><span id="内核运行时防护">内核运行时防护</span></h3>
<p>Linux Kernel Runtime Guard（LKRG）是一个内核模块，可确保运行时内核的完整性并检测漏洞。它可以杀死整个类别的内核漏洞。但这并不是一个完美的缓解方法，因为LKRG在设计上可以绕开。它仅适用于现成的恶意软件。但是，尽管可能性不大，但LKRG本身可能会像其他任何内核模块一样公开新的漏洞。</p>
<h3><span id="自编译内核">自编译内核</span></h3>
<p>建议编译您自己的内核，同时启用尽可能少的内核模块和尽可能多的安全性功能，以将内核的受攻击面保持在绝对最低限度。</p>
<p>另外，应用内核强化补丁，例如如上所述的 linux-hardened 或 grsecurity。</p>
<p>发行版编译的内核还具有公共内核指针/符号，这对于漏洞利用非常有用。编译自己的内核将为您提供独特的内核符号，连同 kptr_restrict，dmesg_restrict 和其他针对内核指针泄漏的强化措施，将使攻击者更加难以创建依赖于内核指针知识的漏洞利用程序。</p>
<p>您就可以从<a href="https://href.li/?https://www.whonix.org/wiki/Hardened-kernel" target="_blank" rel="noopener">Whonix的强化内核</a>中汲取灵感或使用它。</p>
<h2><span id="强制访问措施">强制访问措施</span></h2>
<p>强制访问控制（MAC）系统对程序可以访问的内容进行细粒度的控制。这意味着您的浏览器将无权访问您的整个主目录或类似目录。</p>
<p>最常用的 MAC 措施是 SELinux 和 AppArmor。SELinux比AppArmor 更安全，因为它的粒度更细。例如，它是基于inode而不是基于路径的，允许强制执行明显更严格的限制，可以过滤内核 ioctl 等。不幸的是，这是以难以使用和难以学习为代价的，因此某些人可能会首选 AppArmor。</p>
<p>要在内核中启用 AppArmor，必须设置以下引导参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apparmor&#x3D;1 security&#x3D;apparmor</span><br></pre></td></tr></table></figure>
<p>要启用 SELinux，请设置以下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selinux&#x3D;1 security&#x3D;selinux</span><br></pre></td></tr></table></figure>
<p>请记住，仅启用 MAC 措施本身并不能神奇地提高安全性。您必须制定严格的政策才能充分利用它。例如，要创建 AppArmor 配置文件，请执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa-genprof $path_to_program</span><br></pre></td></tr></table></figure>
<p>打开程序，然后像往常一样开始使用它。AppArmor 将检测需要访问哪些文件，并将它们添加到配置文件中（如果您选择的话）。但是，仅凭这一点不足以提供高质量的配置文件。请参阅<a href="https://href.li/?https://gitlab.com/apparmor/apparmor/-/wikis/Documentation" target="_blank" rel="noopener">AppArmor文档</a>以获取更多详细信息。</p>
<p>如果您想更进一步，则可以通过实施 initramfs 勾子来设置一个完整的系统MAC策略，该策略限制每个单个用户空间进程，该挂钩对 init 系统强制实施MAC策略。这就是 Android 使用 SELinux 的方式，以及 Whonix 未来将如何使用 AppArmor 的方式。对于加强实施最小特权原则的强大安全模型是必要的。</p>
<h2><span id="沙箱">沙箱</span></h2>
<h3><span id="应用沙箱">应用沙箱</span></h3>
<p>沙箱可让您在隔离的环境中运行程序，该环境对系统的其余部分具有有限的访问权限或完全没有访问权限。您可以使用它们来保护应用程序安全或运行不受信任的程序。</p>
<p>建议与 AppArmor 或 SELinux 一起在单独的用户帐户中使用<a href="https://href.li/?https://github.com/containers/bubblewrap" target="_blank" rel="noopener">Bubblewrap</a>到沙箱程序。您也可以考虑改用 gVisor，它的优点是为每个来宾提供了自己的内核。</p>
<p>这些方法中的任何一个都可以用来创建一个功能强大的沙箱，并且暴露的攻击面最小。如果您不想自己创建沙箱，请在完成后考虑使用 Whonix 的 sandbox-app-launcher。<a href="https://href.li/?https://madaidans-insecurities.github.io/linux.html#firejail" target="_blank" rel="noopener">您不应该使用Firejail</a>。</p>
<p>诸如 Docker 和 LXC 之类的容器解决方案经常被误导为沙盒形式。它们太宽松了，无法广泛支持各种应用程序，因此不能认为它们是强大的应用程序沙箱。</p>
<h3><span id="常见沙箱逃逸">常见沙箱逃逸</span></h3>
<h4><span id="pulseaudio">PulseAudio</span></h4>
<p>PulseAudio 是一种常见的声音服务器，但在编写时并未考虑隔离或沙盒的问题，这使其成为重复出现的沙盒逃逸漏洞。为了防止这种情况，建议您从沙箱中阻止对 PulseAudio 的访问，或者从系统中完全卸载它。</p>
<h4><span id="d-bus">D-Bus</span></h4>
<p>D-Bus 是台式机 Linux 上最流行的进程间通信形式，但它也是沙箱逃逸的另一种常见途径，因为它允许与服务自由交互。这些漏洞的一个例子就是 Firejail。您应该从沙箱中阻止对 D-Bus 的访问，或者通过 MAC 以细粒度的规则进行调解。</p>
<h4><span id="gui隔离">GUI隔离</span></h4>
<p>任何 Xorg 窗口都可以访问另一个窗口。这允许琐碎的键盘记录或屏幕截图程序，甚至可以记录诸如 root 密码之类的内容。您可以使用嵌套的 X11 服务器（例如 Xpra 或 Xephyr 和 bubblewrap）将 Xorg 窗口沙箱化。默认情况下，Wayland 将窗口彼此隔离，这将是一个比 Xorg 更好的选择，尽管 Wayland 可能不如 Xorg 普遍可用，因为它在开发中较早。</p>
<h4><span id="ptrace">ptrace</span></h4>
<p>如前所述，ptrace 是一个系统调用，可能会被滥用破坏在沙箱外部运行的进程。为避免这种情况，您可以通过 sysctl 启用内核 YAMA ptrace 限制，也可以在 seccomp 过滤器中将 ptrace syscall 列入黑名单。</p>
<h4><span id="tiocsti">TIOCSTI</span></h4>
<p>TIOCSTI 是一个 ioctl，它允许注入终端命令，并为攻击者提供了一种简单的机制，可以在同一用户会话内的其他进程之间横向移动。可以通过将 seccomp 过滤器中的 ioctl 列入黑名单或使用 bubblewrap 的 <code>–new-session</code> 参数来缓解这种攻击。</p>
<h4><span id="systemd-沙箱">Systemd 沙箱</span></h4>
<p>虽然不建议使用 systemd，但有些系统可能无法切换。这些人至少可以使用沙盒服务，因此他们只能访问所需的内容。这是一个沙箱化 systemd 服务的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">CapabilityBoundingSet&#x3D;CAP_NET_BIND_SERVICE</span><br><span class="line">ProtectSystem&#x3D;strict</span><br><span class="line">ProtectHome&#x3D;true</span><br><span class="line">ProtectKernelTunables&#x3D;true</span><br><span class="line">ProtectKernelModules&#x3D;true</span><br><span class="line">ProtectControlGroups&#x3D;true</span><br><span class="line">ProtectKernelLogs&#x3D;true</span><br><span class="line">ProtectHostname&#x3D;true</span><br><span class="line">ProtectClock&#x3D;true</span><br><span class="line">ProtectProc&#x3D;invisible</span><br><span class="line">ProcSubset&#x3D;pid</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line">PrivateUsers&#x3D;yes</span><br><span class="line">PrivateDevices&#x3D;true</span><br><span class="line">MemoryDenyWriteExecute&#x3D;true</span><br><span class="line">NoNewPrivileges&#x3D;true</span><br><span class="line">LockPersonality&#x3D;true</span><br><span class="line">RestrictRealtime&#x3D;true</span><br><span class="line">RestrictSUIDSGID&#x3D;true</span><br><span class="line">RestrictAddressFamilies&#x3D;AF_INET</span><br><span class="line">RestrictNamespaces&#x3D;yes</span><br><span class="line">SystemCallFilter&#x3D;write read openat close brk fstat lseek mmap mprotect munmap rt_sigaction rt_sigprocmask ioctl nanosleep select access execve getuid arch_prctl set_tid_address set_robust_list prlimit64 pread64 getrandom</span><br><span class="line">SystemCallArchitectures&#x3D;native</span><br><span class="line">UMask&#x3D;0077</span><br><span class="line">IPAddressDeny&#x3D;any</span><br><span class="line">AppArmorProfile&#x3D;&#x2F;etc&#x2F;apparmor.d&#x2F;usr.bin.example</span><br></pre></td></tr></table></figure>
<p>所有选项的说明：</p>
<ul>
<li><code>CapabilityBoundingSet=</code> — Specifies the <a href="https://href.li/?https://madaidans-insecurities.github.io/guides/linux-hardening.html#capabilities" target="_blank" rel="noopener">capabilities</a> the process is given.</li>
<li><code>ProtectHome=true</code> — Makes all home directories inaccessible.</li>
<li><code>ProtectKernelTunables=true</code> — Mounts kernel tunables such as those modified through <code>sysctl</code> as read-only.</li>
<li><code>ProtectKernelModules=true</code> — Denies module loading and unloading.</li>
<li><code>ProtectControlGroups=true</code> — Mounts all control group hierarchies as read-only.</li>
<li><code>ProtectKernelLogs=true</code> — Prevents accessing the kernel logs.</li>
<li><code>ProtectHostname=true</code> — Prevents changes to the system hostname.</li>
<li><code>ProtectClock</code> — Prevents changes to the system clock.</li>
<li><code>ProtectProc=invisible</code> — Hides all outside processes.</li>
<li><code>ProcSubset=pid</code> — Permits access to only the pid subset of <code>/proc</code>.</li>
<li><code>PrivateTmp=true</code> — Mounts an empty tmpfs over <code>/tmp</code> and <code>/var/tmp</code>, therefore hiding their previous contents.</li>
<li><code>PrivateUsers=true</code> — Sets up an empty user namespace to hide other user accounts on the system.</li>
<li><code>PrivateDevices=true</code> — Creates a new <code>/dev</code> mount with minimal devices present.</li>
<li><code>MemoryDenyWriteExecute=true</code> — Enforces a memory W^X policy.</li>
<li><code>NoNewPrivileges=true</code> — Prevents escalating privileges.</li>
<li><code>LockPersonality=true</code> — Locks down the <code>personality()</code> syscall to prevent switching execution domains.</li>
<li><code>RestrictRealtime=true</code> — Prevents attempts to enable realtime scheduling.</li>
<li><code>RestrictSUIDSGID=true</code> — Prevents executing setuid or setgid binaries.</li>
<li><code>RestrictAddressFamilies=AF_INET</code> — Restricts the usable socket address families to IPv4 only (<code>AF_INET</code>).</li>
<li><code>RestrictNamespaces=true</code> — Prevents creating any new namespaces.</li>
<li><code>SystemCallFilter=...</code> — Restricts the allowed syscalls to the absolute minimum. If you aren’t willing to maintain your own custom seccomp filter, then systemd provides many [predefined system call sets](<a href="https://href.li/?https://www.freedesktop.org/software/systemd/man/systemd.exec.html#System" target="_blank" rel="noopener">https://www.freedesktop.org/software/systemd/man/systemd.exec.html#System</a> Call Filtering) that you can use. <code>@system-service</code> will be suitable for many use cases.</li>
<li><code>SystemCallArchitectures=native</code> — Prevents executing syscalls from other CPU architectures.</li>
<li><code>UMask=0077</code> — Sets the <a href="https://href.li/?https://madaidans-insecurities.github.io/guides/linux-hardening.html#umask" target="_blank" rel="noopener">umask</a> to a more restrictive value.</li>
<li><code>IPAddressDeny=any</code> — Blocks all incoming and outgoing traffic to/from any IP address. Set <code>IPAddressAllow=</code> to configure a whitelist. Alternatively, setup a network namespace with <code>PrivateNetwork=true</code>.</li>
<li><code>AppArmorProfile=...</code> — Runs the process under the specified AppArmor profile.</li>
</ul>
<p>您不能仅将此示例配置复制到您的配置中，每种服务的要求各不相同，并且必须针对每种服务微调沙箱。要了解有关您可以设置的所有选项的更多信息，请阅读<a href="https://href.li/?https://www.freedesktop.org/software/systemd/man/systemd.exec.html" target="_blank" rel="noopener">systemd.exec手册页</a>。</p>
<p>如果您使用的系统不是 systemd 而是 init，那么可以使用 bubblewrap 轻松复制所有这些选项。</p>
<h3><span id="gvisor">gVisor</span></h3>
<p>普通沙箱固有地与主机共享同一内核。您信任我们已经评估为不安全的内核，可以正确限制这些程序。由于主机内核的整个攻击面已完全暴露，因此沙盒中的内核利用程序可以绕过任何限制。已经进行了一些努力来限制使用 seccomp 的攻击面，但不足以完全解决此问题。</p>
<p>GVisor 是解决此问题的方法。它为每个应用程序提供了自己的内核，该内核以内存安全的语言重新实现了 Linux 内核的大部分系统调用，从而提供了明显更强的隔离性。</p>
<h3><span id="虚拟机">虚拟机</span></h3>
<p>虽然不是传统的 “沙盒”，但虚拟机通过虚拟化全新系统来分离进程，从而提供了非常强大的隔离性。KVM是内核模块，它允许内核充当管理程序，而QEMU是利用KVM的仿真器。Virt-manager 和 GNOME Boxs都是良好且易于使用的 GUI，用于管理 KVM / QEMU 虚拟机。不建议使用 Virtualbox 的<a href="https://href.li/?https://www.whonix.org/wiki/KVM#Why_Use_KVM_Over_VirtualBox.3F" target="_blank" rel="noopener">原因</a>有很多。</p>
<h2><span id="强化内存分配器">强化内存分配器</span></h2>
<p>hardened_malloc 是一种硬化的内存分配器，可为堆内存损坏漏洞提供实质性的保护。它很大程度上基于 OpenBSD 的 malloc 设计，但具有许多改进。</p>
<p>可以通过 LD_PRELOAD 环境变量针对每个应用程序使用 hardened_malloc。例如，假设您编译的库位于 <code>/usr/lib/libhardened_malloc.so</code>，则可以执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD&#x3D;&quot;&#x2F;usr&#x2F;lib&#x2F;libhardened_malloc.so&quot; $program</span><br></pre></td></tr></table></figure>
<p>通过全局预加载该库，也可以在系统范围内使用它，这是使用它的推荐方法。为此，请编辑 /etc/ld.so.preload 并插入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;lib&#x2F;libhardened_malloc.so</span><br></pre></td></tr></table></figure>
<p>尽管大多数应用程序都可以正常工作，但 hardened_malloc 可能会破坏某些应用程序。建议使用以下选项编译 hardened_malloc 以最大程度地减少损坏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SLAB_QUARANTINE_RANDOM_LENGTH&#x3D;0 </span><br><span class="line">CONFIG_SLAB_QUARANTINE_QUEUE_LENGTH&#x3D;0 </span><br><span class="line">CONFIG_GUARD_SLABS_INTERVAL&#x3D;8</span><br></pre></td></tr></table></figure>
<p>您还应该使用sysctl设置以下内容，以适应hardened_malloc创建的大量保护页：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count&#x3D;524240</span><br></pre></td></tr></table></figure>
<p><a href="https://href.li/?https://www.whonix.org/wiki/Hardened_Malloc" target="_blank" rel="noopener">Whonix项目</a>为基于Debian的发行版提供了hardened_malloc软件包。</p>
<h2><span id="强化编译标志">强化编译标志</span></h2>
<p>编译自己的程序可以带来很多好处，因为它使您能够优化程序的安全性。但是，执行完全相反的操作并降低安全性很容易，如果您不确定自己在做什么，请跳过本节。在基于源的发行版（例如Gentoo）上，这将是最简单的，但也可以在其他发行版上这样做。</p>
<p>某些编译选项可用于添加其他漏洞利用缓解措施，从而消除整个类别的常见漏洞。您可能听说过常规保护，例如位置独立可执行文件，堆栈粉碎保护程序，立即绑定，只读重定位和 FORTIFY_SOURCE，但是本节将不做介绍，因为它们已被广泛采用。相反，它将讨论诸如控制流完整性和影子堆栈之类的现代漏洞利用缓解措施。</p>
<p>本节涉及主要用 C 或 C ++ 编写的本机程序。您必须使用 Clang 编译器，因为这些功能在 GCC 上不可用。请记住，由于未广泛采用这些缓解措施，因此某些应用程序在启用它们后可能无法运行。</p>
<ul>
<li>控制流完整性（CFI）是一种缓解漏洞利用的方法，旨在防止诸如 ROP 或 JOP 之类的代码重用攻击。由于更广泛采用的缓解措施（例如 NX）使过时的利用技术过时了，因此使用这些技术利用了很大一部分漏洞。Clang 支持细粒度的前沿 CFI，这意味着它可以有效缓解JOP攻击。Clang 的 CFI 本身并不能减轻ROP；您还必须使用下面记录的单独机制。要启用此功能，必须应用以下编译标志： <code>-flto -fvisibility=hidden -fsanitize=cfi</code></li>
<li>影子堆栈通过将程序复制到其他隐藏堆栈中来保护程序的返回地址。然后比较主堆栈和影子堆栈中的返回地址，看两者是否不同。如果是这样，则表明存在攻击，程序将中止，从而减轻了 ROP 攻击。Clang 具有称为 ShadowCallStack 的功能，可以完成此操作，但是，仅在 ARM64 上可用。要启用此功能，必须应用以下编译标志： <code>-fsanitize=shadow-call-stack</code></li>
<li>如果上述 ShadowCallStack 不是一个选项，则可以选择使用具有相似目标的 SafeStack。但是，不幸的是，此功能有许多漏洞，因此效果不甚理想。如果仍然希望启用此功能，则必须应用以下编译标志： <code>-fsanitize=safe-stack</code></li>
<li>最常见的内存损坏漏洞之一是未初始化的内存。Clang 有一个选项可以使用零或特定模式自动初始化变量。建议将变量初始化为零，因为使用其他模式比利用漏洞缓解功能更适合发现错误。要启用此功能，必须应用以下编译标志： -ftrivial-auto-var-init=zero -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang 但该选项的存在目前正在<a href="https://href.li/?https://lists.llvm.org/pipermail/cfe-dev/2020-April/065221.html" target="_blank" rel="noopener">辩论</a>中。</li>
</ul>
<h2><span id="内存安全语言">内存安全语言</span></h2>
<p>用内存安全语言编写的程序会自动受到保护，免受各种安全漏洞的影响，这些安全漏洞包括缓冲区溢出，未初始化的变量，售后使用等。</p>
<p>Microsoft 和 Google 的安全研究人员进行的研究证明，已发现的大多数漏洞都是内存安全问题。这样的内存安全语言的示例包括 Rust，Swift 和 Java，而内存不安全语言的示例包括 C 和 C ++。如果可行，应使用内存安全替代品替换尽可能多的程序。</p>
<h2><span id="root-账户">Root 账户</span></h2>
<p>root 可以执行任何操作，并且可以访问您的整个系统。因此，应尽可能将其锁定，以使攻击者无法轻松获得 root 用户访问权限。</p>
<h3><span id="etcsecuretty">/etc/securetty</span></h3>
<p>/etc/securetty 文件指定允许您以 root 用户身份登录的位置。该文件应保留为空，以便任何人都不能从终端上这样做。</p>
<h3><span id="限制-su">限制 su</span></h3>
<p>su 可让您从终端切换用户。默认情况下，它尝试以 root 用户身份登录。要将 su 的使用限制在 wheel 组中，请编辑 <code>/etc/pam.d/su</code> 和 <code>/etc/pam.d/su-l</code> 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth required pam_wheel.so use_uid</span><br></pre></td></tr></table></figure>
<p>您应该在 wheel 组中拥有尽可能少的用户。</p>
<h3><span id="锁定-root-账户">锁定 root 账户</span></h3>
<p>要锁定 root 帐户以防止任何人以 root 身份登录，请执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -l root</span><br></pre></td></tr></table></figure>
<p>在执行此操作之前，请确保您具有获取根的替代方法（例如，从活动 USB 引导并更改为文件系统的chroot ），以免您无意中将自己锁定在系统之外。</p>
<h3><span id="拒绝通过-ssh-的远程-root-登陆">拒绝通过 SSH 的远程 root 登陆</span></h3>
<p>为了防止某人通过 SSH 以 root 身份登录，请编辑 <code>/etc/ssh/sshd_config</code> 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br></pre></td></tr></table></figure>
<h3><span id="增加散列回合数">增加散列回合数</span></h3>
<p>您可以增加 shadow 使用的哈希回合数，从而通过迫使攻击者计算更多的哈希值来破解您的密码，从而提高哈希密码的安全性。默认情况下，shadow 使用 5000 次回合，但是您可以将其增加到任意数量。尽管配置的回合越多，登录速度就越慢。编辑 /etc/pam.d/passwd 并添加回合选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password required pam_unix.so sha512 shadow nullok rounds&#x3D;65536</span><br></pre></td></tr></table></figure>
<p>这使 shadow 执行 65536 次散列回合。</p>
<p>应用此设置后，密码不会自动重新加密，因此您需要使用以下方法重置密码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd $username</span><br></pre></td></tr></table></figure>
<h3><span id="限制-xorg-root-访问">限制 Xorg root 访问</span></h3>
<p>默认情况下，某些发行版以 root 用户身份运行 Xorg，这是一个问题，因为 Xorg 包含大量古老而又复杂的代码，这增加了巨大的攻击面，并使其更有可能拥有可以获取 root 特权的漏洞利用程序。要阻止它作为 root 用户执行，请编辑 <code>/etc/X11/Xwrapper.config</code> 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">needs_root_rights &#x3D; no</span><br></pre></td></tr></table></figure>
<h3><span id="安全访问root">安全访问root</span></h3>
<p>恶意软件可以使用多种方法来嗅探 root 帐户的密码。因此，访问根帐户的传统方式是不安全的，最好根本不访问根，但这实际上是不可行的。本节详细介绍了访问根帐户的最安全方法。在安装操作系统后，应立即应用这些说明，以确保该软件不含恶意软件。</p>
<p>您绝对不能使用普通用户帐户访问 root，因为 root 可能已被盗用。您也不能直接登录到根帐户。通过执行以下操作，创建一个单独的“管理员”用户帐户，该帐户仅用于访问 root 用户，而不能用于访问其他用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd admin</span><br></pre></td></tr></table></figure>
<p>执行并来设置一个非常强的密码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd admin</span><br></pre></td></tr></table></figure>
<p>仅允许该帐户使用您首选的权限提升机制。例如，如果使用 sudo，则通过执行以下命令来添加 sudoers异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo -f &#x2F;etc&#x2F;sudoers.d&#x2F;admin-account</span><br></pre></td></tr></table></figure>
<p>然后输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure>
<p>确保没有其他帐户可以访问 sudo（或您的首选机制）</p>
<p>现在，要实际登录到该帐户，请先重新启动-例如，这可以防止受损的窗口管理器执行登录欺骗。当提供登录提示时，请通过按键盘上的以下组合键来激活安全注意键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alt + SysRq + k</span><br></pre></td></tr></table></figure>
<p>这将杀死当前虚拟控制台上的所有应用程序，从而克服登录欺骗攻击。现在，您可以安全地登录到您的管理员帐户，并使用 root 用户执行任务。完成后，注销管理员帐户，然后重新登录到非特权用户帐户。</p>
<h2><span id="防火墙">防火墙</span></h2>
<p>防火墙可以控制传入和传出的网络流量，并且可以用来阻止或允许某些类型的流量。除非有特殊原因，否则应始终阻止所有传入流量。建议设置严格的 iptables 或 nftables 防火墙。火墙必须针对您的系统进行微调，并且没有一个适合所有防火墙的规则集。建议您熟悉创建防火墙规则。<a href="https://href.li/?https://wiki.archlinux.org/index.php/Iptables" target="_blank" rel="noopener">Arch Wiki</a>和<a href="https://href.li/?https://linux.die.net/man/8/iptables" target="_blank" rel="noopener">手册页</a>都是很好的资源。</p>
<p>这是基本 iptables 配置的示例，该配置禁止所有传入的网络流量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD DROP [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">:TCP - [0:0]</span><br><span class="line">:UDP - [0:0]</span><br><span class="line">-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -m conntrack --ctstate INVALID -j DROP</span><br><span class="line">-A INPUT -p udp -m conntrack --ctstate NEW -j UDP</span><br><span class="line">-A INPUT -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP</span><br><span class="line">-A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">-A INPUT -p tcp -j REJECT --reject-with tcp-reset</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-proto-unreachable</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
<p>但是，您不应尝试在实际系统上使用此示例。它仅适用于某些台式机系统。</p>
<h2><span id="身份标识">身份标识</span></h2>
<p>为了保护隐私，最好最大程度地减少可追溯到您的信息量。</p>
<h3><span id="主机名和用户名">主机名和用户名</span></h3>
<p>请勿在主机名或用户名中添加唯一标识的内容。将它们保留为通用名称，例如 “host” 和 “user”，以便它们无法识别您。</p>
<h3><span id="timezones-locales-keymaps">Timezones / Locales / Keymaps</span></h3>
<p>如果可能，应将您的时区设置为 “UTC”，将区域设置和键盘映射设置为 “US”。</p>
<h3><span id="机器id">机器ID</span></h3>
<p>一个独一无二的机器ID被存储在 <code>/var/lib/dbus/machine-id</code> （ systemd 系统是保存在 <code>/etc/machine-id</code> ）这些应编辑为通用名称，例如<a href="https://href.li/?https://github.com/Whonix/dist-base-files/blob/master/etc/machine-id" target="_blank" rel="noopener">Whonix ID</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b08dfa6083e7567a1921a715000001fb</span><br></pre></td></tr></table></figure>
<h3><span id="mac地址欺骗">MAC地址欺骗</span></h3>
<p>MAC 地址是分配给网络接口控制器（NIC）的唯一标识符。每次您连接到网络时（ WIFI 或以太网）则您的 MAC 地址已暴露。这使人们可以使用它来跟踪您并在本地网络上唯一地标识您。</p>
<p>但您不应该完全随机化 MAC 地址。拥有完全随机的 MAC 地址是显而易见的，并且会对您脱颖而出的行为产生不利影响。</p>
<p>MAC 地址的 OUI（组织唯一标识符）部分标识芯片组的制造商。对 MAC 地址的这一部分进行随机化处理可能会为您提供以前从未使用过的OUI，数十年来从未使用过的 OUI 或在您所在的地区极为罕见的 OUI，因此使您脱颖而出，很明显地表明您在欺骗 MAC 地址。</p>
<p>MAC 地址的末尾标识您的特定设备，并且可以用来跟踪您的设备。仅对 MAC 地址的这一部分进行随机化可防止您被跟踪，同时仍使MAC地址看起来可信。</p>
<p>要欺骗这些地址，请首先执行以下命令找出您的网络接口名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure>
<p>接下来，安装 macchanger 并执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">macchanger -e $network_interface</span><br></pre></td></tr></table></figure>
<p>要在每次引导时随机分配 MAC 地址，您应该为您的特定初始化系统创建一个初始化脚本。这是 systemd的一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;macchanger on eth0</span><br><span class="line">Wants&#x3D;network-pre.target</span><br><span class="line">Before&#x3D;network-pre.target</span><br><span class="line">BindsTo&#x3D;sys-subsystem-net-devices-eth0.device</span><br><span class="line">After&#x3D;sys-subsystem-net-devices-eth0.device</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;macchanger -e eth0</span><br><span class="line">Type&#x3D;oneshot</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>
<p>上面的示例在启动时欺骗了 eth0 接口的 MAC 地址。将 eth0 替换为您的网络接口。</p>
<h3><span id="时间攻击">时间攻击</span></h3>
<p>几乎每个系统都有不同的时间。这可用于时钟偏斜指纹攻击，几毫秒的差异足以使用户被暴露识别。</p>
<h4><span id="icmp时间戳">ICMP时间戳</span></h4>
<p>ICMP 时间戳会在查询答复中泄漏系统时间。阻止这些攻击的最简单方法是利用防火墙阻止传入连接，或者使内核忽略 ICMP 请求。</p>
<h4><span id="tcp-时间戳">TCP 时间戳</span></h4>
<p>TCP 时间戳也会泄漏系统时间。内核尝试通过对每个连接使用随机偏移量来解决此问题，但<a href="https://href.li/?https://forums.whonix.org/t/do-ntp-and-tcp-timestamps-really-leak-your-local-time/7824/10" target="_blank" rel="noopener">这不足以解决问题</a>。因此应该禁用 TCP 时间戳，可以通过使用 sysctl 设置以下内容来完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps&#x3D;0</span><br></pre></td></tr></table></figure>
<h4><span id="tcp-初始化序号">TCP 初始化序号</span></h4>
<p>TCP 初始序列号（ISN）是泄漏系统时间的另一种方法。为了减轻这种情况，您必须<a href="https://href.li/?https://github.com/0xsirus/tirdad" target="_blank" rel="noopener">安装tirdad内核模块</a>，该模块会生成用于连接的随机ISN。</p>
<h4><span id="时间同步">时间同步</span></h4>
<p>时间同步对于匿名性和安全性至关重要。错误的系统时钟可能使您遭受时钟偏斜指纹攻击，或者可以用来为您提供过时的 HTTPS 证书，从而绕过证书到期或吊销。</p>
<p>最流行的时间同步方法 NTP 是不安全的，因为它未经加密和未经身份验证，因此攻击者可以轻易地拦截和修改请求。NTP 还会以 NTP 时间戳格式泄漏本地系统时间，该格式可用于时钟偏斜指纹识别，如前所述。</p>
<p>因此，您应该卸载所有 NTP 客户端并禁用 systemd-timesyncd（如果正在使用）。您可以通过安全连接（HTTPS或最好是Torion服务）连接到受信任的网站，而不是 NTP，并从 HTTP 标头中提取当前时间。达到此目的的工具是 sdwdate 或我自己的<a href="https://href.li/?https://gitlab.com/madaidan/secure-time-sync" target="_blank" rel="noopener">安全时间同步工具</a>。</p>
<h3><span id="按键指纹">按键指纹</span></h3>
<p>可以通过他们在键盘上输入键的方式来对人进行指纹识别。您可以通过键入速度，在两次按键之间的暂停，每次按键被按下和释放的确切时间等方式来唯一地进行指纹识别。可以使用<a href="https://href.li/?https://www.keytrac.net/en/tryout" target="_blank" rel="noopener">KeyTrac</a>在线进行测试。</p>
<p><a href="https://href.li/?https://github.com/vmonaco/kloak" target="_blank" rel="noopener">Kloak</a>是一种工具，旨在通过混淆按键和释放事件之间的时间间隔来克服这种跟踪方法。当按键被按下时，它会引入随机延迟，然后由应用程序选择。</p>
<h2><span id="文件权限">文件权限</span></h2>
<p>默认情况下，文件的权限是非常宽松的。您应该在整个系统中搜索权限不当的文件和目录，并对其进行限制。例如，在诸如 Debian 之类的某些发行版中，用户的 Home 目录是全局可读的。</p>
<p>这可以通过执行以下操作来限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 &#x2F;home&#x2F;$user</span><br></pre></td></tr></table></figure>
<p>另外一些示例是/boot，/usr /src和/ {,usr /} lib/modules 它们包含内核映像，System.map和其他各种文件，所有这些文件都可能泄漏有关内核的敏感信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 &#x2F;boot &#x2F;usr&#x2F;src &#x2F;lib&#x2F;modules &#x2F;usr&#x2F;lib&#x2F;modules</span><br></pre></td></tr></table></figure>
<p>在基于 Debian 的发行版中，必须使用 dpkg-statoverride 保留文件许可权。否则，它们将在更新期间被覆盖。</p>
<p>Whonix的<a href="https://href.li/?https://www.whonix.org/wiki/SUID_Disabler_and_Permission_Hardener" target="_blank" rel="noopener">SUID Disabler和Permission Hardener</a>会自动应用本节中详细介绍的步骤。</p>
<h3><span id="setuid-setgid">setuid / setgid</span></h3>
<p>Setuid / SUID 允许用户使用二进制文件所有者的特权执行二进制文件。这通常用于允许非特权用户使用通常仅为 root 用户保留的某些功能。因此，许多 SUID 二进制文件都有特权升级安全漏洞的历史记录。 Setgid / SGID 类似，但适用于组而不是用户。要使用 setuid 或 setgid 位查找系统上的所有二进制文件，请执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -type f \( -perm -4000 -o -perm -2000 \)</span><br></pre></td></tr></table></figure>
<p>然后，您应该删除不使用的程序上的所有不必要的 setuid / setgid 位，或将其替换为功能。要删除 setuid 位，请执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-s $path_to_program</span><br></pre></td></tr></table></figure>
<p>要删除 setgid 位，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod g-s $path_to_program</span><br></pre></td></tr></table></figure>
<p>要向文件添加功能，请执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcap $capability+ep $path_to_program</span><br></pre></td></tr></table></figure>
<p>或者，要删除不必要的功能，请执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcap -r $path_to_program</span><br></pre></td></tr></table></figure>
<h3><span id="umask">umask</span></h3>
<p>umask 设置新创建文件的默认文件权限。默认的 umask 是0022，它不是很安全，因为它为系统上的每个用户提供了对新创建文件的读取访问权限。要使所有者以外的任何人都不可读新文件，请编辑 /etc/profile 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask 0077</span><br></pre></td></tr></table></figure>
<h2><span id="核心转储">核心转储</span></h2>
<p>核心转储包含特定时间（通常是该程序崩溃时）该程序的已记录内存。它们可能包含敏感信息，例如密码和加密密钥，因此必须将其禁用。</p>
<p>禁用它们的方法主要有三种：sysctl，systemd 和 ulimit</p>
<h3><span id="sysctl">sysctl</span></h3>
<p>通过 sysctl 设置以下设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.core_pattern&#x3D;|&#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure>
<h3><span id="systemd">systemd</span></h3>
<p>创建 <code>/etc/systemd/coredump.conf.d/disable.conf</code> 并添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Coredump]</span><br><span class="line">Storage&#x3D;none</span><br></pre></td></tr></table></figure>
<h3><span id="ulimit">ulimit</span></h3>
<p>编辑/etc/security/limits.conf并添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* hard core 0</span><br></pre></td></tr></table></figure>
<h3><span id="setuid进程">setuid进程</span></h3>
<p>即使在进行了这些设置之后，以提升的特权运行的进程仍可能会转储其内存。</p>
<p>为了防止他们这样做，请通过 sysctl 设置以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.suid_dumpable&#x3D;0</span><br></pre></td></tr></table></figure>
<h2><span id="swap">Swap</span></h2>
<p>与核心转储类似，交换或分页将部分内存复制到磁盘，其中可能包含敏感信息。应该将内核配置为仅在绝对必要时进行交换，相应的 sysctl 设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness&#x3D;1</span><br></pre></td></tr></table></figure>
<h2><span id="pam">PAM</span></h2>
<p>PAM 是用于用户身份验证的框架。这就是您登录时使用的机制。您可以通过要求使用强密码或在失败的登录尝试后强制执行延迟验证来使其更加安全。</p>
<p>要强制使用强密码，可以使用 pam_pwquality。它强制执行密码的可配置策略。例如，如果您希望密码至少包含 16 个字符（最小），与旧密码（difok）至少 6 个不同的字符，至少 3 个数字（dcredit），至少 2 个大写字母（ucredit），至少 2 个字符小写字母（lcredit）和至少 3 个其他字符（ocredit），然后编辑 /etc/pam.d/passwd 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password required pam_pwquality.so retry&#x3D;2 minlen&#x3D;16 difok&#x3D;6 dcredit&#x3D;-3 ucredit&#x3D;-2 lcredit&#x3D;-2 ocredit&#x3D;-3 enforce_for_root</span><br><span class="line">password required pam_unix.so use_authtok sha512 shadow</span><br></pre></td></tr></table></figure>
<p>要强制执行延迟验证，可以使用 pam_faildelay。要在两次失败的登录尝试之间添加至少4秒的延迟以阻止暴力破解尝试，请编辑 /etc/pam.d/system-login 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth optional pam_faildelay.so delay&#x3D;4000000</span><br></pre></td></tr></table></figure>
<p>4000000 是 4 秒（以微秒为单位）。</p>
<h2><span id="microcode更新">Microcode更新</span></h2>
<p>Microcode 更新对于修复关键的 CPU 漏洞（如 Meltdown 和 Spectre 等）至关重要。大多数发行版都将这些发行版包含在其软件仓库中，例如<a href="https://href.li/?https://wiki.archlinux.org/index.php/Microcode" target="_blank" rel="noopener">Arch Linux</a>和<a href="https://href.li/?https://wiki.debian.org/Microcode" target="_blank" rel="noopener">Debian</a>。</p>
<h2><span id="ipv6-隐私扩展">IPv6 隐私扩展</span></h2>
<p>IPv6 地址是从计算机的 MAC 地址生成的，从而使您的 IPv6 地址是唯一的，并直接绑定到计算机。隐私扩展会生成一个随机的 IPv6 地址，以减轻这种形式的跟踪。请注意，如果您开启了 MAC 地址欺骗机制或禁用了 IPv6，则无需执行这些步骤。</p>
<p>要启用这些功能，请通过sysctl设置以下设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.use_tempaddr&#x3D;2</span><br><span class="line">net.ipv6.conf.default.use_tempaddr&#x3D;2</span><br></pre></td></tr></table></figure>
<h3><span id="networkmanager">NetworkManager</span></h3>
<p>要为NetworkManager启用隐私扩展，请编辑 <code>/etc/NetworkManager/NetworkManager.conf</code> 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[connection]</span><br><span class="line">ipv6.ip6-privacy&#x3D;2</span><br></pre></td></tr></table></figure>
<h3><span id="systemd-networkd">systemd-networkd</span></h3>
<p>要为 systemd-networkd 启用隐私扩展，请创建 <code>/etc/systemd/network/ipv6-privacy.conf</code> 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Network]</span><br><span class="line">IPv6PrivacyExtensions&#x3D;kernel</span><br></pre></td></tr></table></figure>
<h3><span id="分区和挂载选项">分区和挂载选项</span></h3>
<p>文件系统应分为多个分区，以对其权限进行细粒度控制。可以添加不同的安装选项以限制可以执行的操作：</p>
<ul>
<li>nodev - 禁止使用设备</li>
<li>nosuid - 禁止setuid或setgid位</li>
<li>noexec - 禁止执行任何二进制文件</li>
</ul>
<p>这些安装选项应在 /etc/fstab 中尽可能设置。如果您不能使用单独的分区，请创建绑定挂载。一个更安全的 /etc/fstab 的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;        &#x2F;          ext4    defaults                              1 1</span><br><span class="line">&#x2F;home    &#x2F;home      ext4    defaults,nosuid,noexec,nodev          1 2</span><br><span class="line">&#x2F;tmp     &#x2F;tmp       ext4    defaults,bind,nosuid,noexec,nodev     1 2</span><br><span class="line">&#x2F;var     &#x2F;var       ext4    defaults,bind,nosuid                  1 2</span><br><span class="line">&#x2F;boot    &#x2F;boot      ext4    defaults,nosuid,noexec,nodev          1 2</span><br></pre></td></tr></table></figure>
<p>请注意，可以<a href="https://href.li/?https://chromium.googlesource.com/chromiumos/docs/+/master/security/noexec_shell_scripts.md" target="_blank" rel="noopener">通过shell脚本绕过noexec</a>。</p>
<h2><span id="熵">熵</span></h2>
<p>熵基本上反应操作系统信息收集的随机程度，对于诸如加密之类的事情至关重要。因此，最好通过安装其他随机数生成器（如<a href="https://href.li/?http://www.issihosts.com/haveged/" target="_blank" rel="noopener">haveged</a>和<a href="https://href.li/?https://github.com/smuellerDD/jitterentropy-rngd" target="_blank" rel="noopener">jitterentropy</a>）从各种来源收集尽可能多的熵。</p>
<p>为了使jitterentropy正确运行，必须通过创建 <code>/usr/lib/modules-load.d/jitterentropy.conf</code> 并添加以下内容尽早加载内核模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jitterentropy_rng</span><br></pre></td></tr></table></figure>
<h3><span id="rdrand">RDRAND</span></h3>
<p>RDRAN 是提供随机数的 CPU 指令。如果可用，内核会自动将其用作熵源。但是由于它是专有的并且是 CPU 身的一部分，因此无法审核和验证其安全性。您甚至无法对代码进行反向工程。该RNG以前曾遭受过漏洞的攻击，其中有些可能是后门攻击。通过设置以下引导参数可以不信任此功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random.trust_cpu&#x3D;off</span><br></pre></td></tr></table></figure>
<h2><span id="以-root-身份编辑文件">以 root 身份编辑文件</span></h2>
<p>建议不要以 root 用户身份运行普通的文本编辑器。大多数文本编辑器可以做的不仅仅是简单地编辑文本文件，而且还可以被利用。例如，以 root 身份打开 vi 并输入：sh。现在，您具有一个可以访问整个系统的 root shell，攻击者可以轻松利用该 shell。</p>
<p>解决方案是使用 sudoedit。这会将文件复制到一个临时位置，以普通用户身份打开文本编辑器，编辑该临时文件并以root用户身份覆盖原始文件。这样，实际的编辑器就不会以 root 身份运行。要使用 sudoedit，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudoedit $path_to_file</span><br></pre></td></tr></table></figure>
<p>默认情况下，它使用 vi，但是可以通过 EDITOR 或 SUDO_EDITOR 环境变量来切换默认编辑器。例如，要使用 nano，请执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR&#x3D;nano sudoedit $path_to_file</span><br></pre></td></tr></table></figure>
<p>可以在 /etc/environment 中全局设置此环境变量。</p>
<h2><span id="特定发行版的安全强化">特定发行版的安全强化</span></h2>
<h3><span id="http包管理器镜像">HTTP包管理器镜像</span></h3>
<p>默认情况下，Linux发行版通常使用 HTTP 或 HTTP 和 HTTPS 镜像的混合来从其软件存储库下载软件包。人们认为这很好，因为程序包管理器会在安装前验证程序包的签名。但是，从历史上看，已经有很多绕过此方法的地方。您应将软件包管理器配置为从 HTTPS 镜像专门下载以进行深度防御。</p>
<h3><span id="apt-seccomp-bpf">APT seccomp-bpf</span></h3>
<p>自软件包管理器 Debian Buster 以来，APT 已支持可选的 seccomp-bpf 过滤。这限制了允许执行APT的系统调用，这可能严重限制攻击者尝试利用APT中的漏洞时对系统造成危害的能力。要启用此功能，请创建 <code>/etc/apt/apt.conf.d/40sandbox</code> 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APT::Sandbox::Seccomp &quot;true&quot;;</span><br></pre></td></tr></table></figure>
<h2><span id="物理安全">物理安全</span></h2>
<p>全盘加密可确保对驱动器上的所有数据进行加密，并且不会被物理攻击者读取。大多数发行版都支持在安装过程中启用加密，请确保设置了强密码。您也可以使用<a href="https://href.li/?https://wiki.archlinux.org/index.php/Dm-crypt" target="_blank" rel="noopener">dm-crypt</a>手动加密驱动器。</p>
<p>请注意，全盘加密不包括 /boot，这样仍然可以修改内核、引导加载程序和其他关键文件。为了完全防止篡改，您还必须实施经过验证的引导。</p>
<h3><span id="bios-uefi强化">BIOS / UEFI强化</span></h3>
<p>如果您仍在使用旧版 BIOS，则应迁移到 UEFI，以利用较新的安全功能。大多数 BIOS 或 UEFI 实现都支持设置密码。最好启用它并设置一个非常强壮的密码。虽然这是很弱的保护，因为重置密码很简单。它通常存储在易失性内存中，因此攻击者只需要能够卸下 CMOS 电池几秒钟，或者他们就可以使用某些主板上的跳线将其重置。</p>
<p>您还应该禁用所有未使用的设备和引导选项，例如USB引导，以减少攻击面。</p>
<p>别忽略 BIOS 或 UEFI 的更新，确保将其更新。将其与常规操作系统更新一样重要。</p>
<p>此外，请参阅<a href="https://href.li/?https://github.com/nsacyber/Hardware-and-Firmware-Security-Guidance" target="_blank" rel="noopener">《NSA的硬件和固件安全指南》</a></p>
<h3><span id="bootloader-密码">Bootloader 密码</span></h3>
<p>引导加载程序会在引导过程的早期执行，并负责加载操作系统。保护它非常重要，否则，它可能会被篡改。例如，本地攻击者可以通过在启动时使用 <code>init=/bin/bash</code> 作为内核参数来轻松获得 root shell，该命令告诉内核执行 /bin/bash 而不是常规的 init 系统。您可以通过为引导加载程序设置密码来防止这种情况。仅设置引导程序密码不足以完全保护它。还必须按照以下说明设置经过验证的启动。</p>
<h4><span id="grub">Grub</span></h4>
<p>要为 GRUB 设置密码，请执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkpasswd-pbkdf2</span><br></pre></td></tr></table></figure>
<p>输入您的密码，该密码将生成一个字符串。它将类似于 &quot;grub.pbkdf2.sha512.10000.C4009… &quot; 。创建 <code>/etc/grub.d/40_password</code> 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set superusers&#x3D;&quot;$username&quot;</span><br><span class="line">password_pbkdf2 $username $password</span><br></pre></td></tr></table></figure>
<p>用 grub-mkpasswd-pbkdf2 生成的字符串替换 “$password”。 “$username” 将用于被允许使用GRUB命令行，编辑菜单项和执行任何菜单项的超级用户。对于大多数人来说，这只是 &quot;root”。</p>
<p>重新生成您的配置文件，GRUB 现在将受到密码保护。</p>
<p>要仅限制编辑引导参数并访问 GRUB 控制台，同时仍然允许您引导，请编辑 <code>/boot/grub/grub.cfg</code> 并在 &quot;menuentry $OSName &quot; 旁边添加 <code>-–unrestricted</code> 参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menuentry &#39;Arch Linux&#39; --unrestricted</span><br></pre></td></tr></table></figure>
<p>您将需要再次重新生成配置文件以应用此更改。</p>
<h3><span id="syslinux">Syslinux</span></h3>
<p>Syslinux 可以设置主密码或菜单密码。引导任何条目都需要主密码，而引导特定条目仅需要菜单密码。</p>
<p>要为 Syslinux 设置主密码，请编辑 <code>/boot/syslinux/syslinux.cfg</code> 并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MENU MASTER PASSWD $password</span><br></pre></td></tr></table></figure>
<p>要设置菜单密码，请编辑 <code>/boot/syslinux/syslinux.cfg</code> ，并在带有您要密码保护的项目的标签内，添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MENU PASSWD $password</span><br></pre></td></tr></table></figure>
<p>将 “$password” 替换为您要设置的密码。</p>
<p>这些密码可以是纯文本，也可以使用MD5，SHA-1，SHA-256 或 SHA-512 进行散列。建议先使用强哈希算法（例如SHA-256或SHA-512）对密码进行哈希处理，以避免将其存储为明文形式。</p>
<h3><span id="systemd-boot">systemd-boot</span></h3>
<p>systemd-boot 具有防止在引导时编辑内核参数的选项。在 loader.conf文件中，添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editor no</span><br></pre></td></tr></table></figure>
<p>systemd-boot 并不正式支持保护内核参数编辑器的密码，但是您可以<a href="https://href.li/?https://github.com/kitsunyan/systemd-boot-password" target="_blank" rel="noopener">使用systemd-boot-password来实现</a>。</p>
<h3><span id="验证引导">验证引导</span></h3>
<p>经过验证的引导通过密码验证来确保引导链和基本系统的完整性。这可用于确保物理攻击者无法修改设备上的软件。</p>
<p>如果没有经过验证的引导，则一旦获得物理访问权限，就可以轻松绕过上述所有预防措施。经过验证的引导不仅像许多人认为的那样是为了物理安全。它还可以用于防止远程恶意软件持久化——如果攻击者设法破坏了整个系统并获得了很高的特权，则经过验证的引导将在重新引导后还原其更改，并确保它们无法持久化。</p>
<p>经过验证的最常见的引导实现是UEFI安全引导，但是它本身并不是一个完整的实现，因为它仅会验证引导加载程序和内核，这意味着可以通过以下方法：</p>
<ul>
<li>仅UEFI安全启动就没有一成不变的信任根，因此物理攻击者仍然可以刷新设备的固件。为了减轻这种情况，请结合使用UEFI安全启动和 Intel Boot Guard 或 AMD Secure Boot。</li>
<li>远程攻击者（或不使用加密的物理攻击者）可以简单地修改操作系统的任何其他特权部分。例如，如果他们有修改内核的特权，那么他们也可以修改 /sbin/init 来有效地获得相同的结果。因此，仅验证内核和引导加载程序不会对远程攻击者产生任何影响。为了减轻这种情况，您必须使用<a href="https://href.li/?https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/verity.html" target="_blank" rel="noopener">dm-verity</a>验证基本操作系统，尽管由于传统Linux发行版的布局，这非常困难且笨拙。</li>
</ul>
<p>通常，很难在传统Linux上实现可靠的经过验证的引导实现。</p>
<h3><span id="usbs">USBs</span></h3>
<p>USB设备为物理攻击提供了重要的攻击面。例如<a href="https://href.li/?https://srlabs.de/bites/badusb/" target="_blank" rel="noopener">BadUSB</a>和<a href="https://href.li/?https://en.wikipedia.org/wiki/Stuxnet" target="_blank" rel="noopener">Stuxnet</a>是此类攻击的范例。最佳实践是禁止所有新连接的USB且仅将受信任设备列入白名单，<a href="https://href.li/?https://usbguard.github.io/" target="_blank" rel="noopener">USBGuard</a>对此非常有用。</p>
<p>您也可以将nousb用作内核引导参数，以禁用内核中的所有USB支持。可以 sysctl 设置kernel.deny_new_usb=1</p>
<h3><span id="dma攻击">DMA攻击</span></h3>
<p>直接内存访问（DMA）攻击涉及通过插入某些物理设备来完全访问所有系统内存。这可以通过控制设备可访问的内存区域的<a href="https://href.li/?https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit" target="_blank" rel="noopener">IOMMU</a>或将特别易受攻击的内核模块列入黑名单来缓解。</p>
<p>要启用 IOMMU，请设置以下内核引导参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intel_iommu&#x3D;on amd_iommu&#x3D;on</span><br></pre></td></tr></table></figure>
<p>您只需要为特定的 CPU 制造商启用该选项，但同时启用这两个选项就没有问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efi&#x3D;disable_early_pci_dma</span><br></pre></td></tr></table></figure>
<p>通过在非常早的启动过程中禁用所有 PCI 桥接器上的 busmaster 位，此选项可<a href="https://href.li/?https://mjg59.dreamwidth.org/54433.html" target="_blank" rel="noopener">修复上述IOMMU中的漏洞</a>。</p>
<p>此外，Thunderbolt 和 FireWire 通常容易受到 DMA 攻击。要禁用它们，请将这些内核模块列入黑名单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install firewire-core &#x2F;bin&#x2F;false</span><br><span class="line">install thunderbolt &#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure>
<h3><span id="冷启动攻击">冷启动攻击</span></h3>
<p>当攻击者在擦除 RAM 中的数据之前对其进行分析时，就会发生<a href="https://href.li/?https://en.wikipedia.org/wiki/Cold_boot_attack" target="_blank" rel="noopener">冷启动攻击</a>。使用现代 RAM 时，冷启动攻击不太实用，因为 RAM 通常会在几秒钟或几分钟内清除，除非将其放入冷却液（如液氮或冷冻机）中。攻击者必须在几秒钟内将设备中的RAM棒拔出并将其暴露于液氮中，而且确保用户不会注意到。</p>
<p>如果冷启动攻击是威胁模型的一部分，请在关机后保护计算机几分钟，以确保没有人可以访问您的 RAM 记忆棒。您也可以将 RAM 棒焊接到主板上，以使其更难以卡住。如果使用笔记本电脑，请取出电池，然后直接用充电电缆供电。关机后请拔出电缆，以确保RAM彻底断电无法访问。</p>
<p>在内核自我保护启动参数部分中，空闲时内存清零选项将用零覆盖内存中的敏感数据。此外，强化的内存分配器可以通过 <code>CONFIG_ZERO_ON_FREE</code> 配置选项清除用户空间堆内存中的敏感数据。尽管如此，某些数据仍可能保留在内存中。</p>
<p>此外，现代内核还包括<a href="https://href.li/?https://lwn.net/Articles/730006/" target="_blank" rel="noopener">复位攻击缓解</a>措施，该命令可命令固件在关机时擦除数据，尽管这需要<a href="https://href.li/?https://www.trustedcomputinggroup.org/wp-content/uploads/Platform-Reset-Attack-Mitigation-Specification.pdf" target="_blank" rel="noopener">固件支持</a>。</p>
<p>确保正常关闭计算机，以使上述缓解措施可以开始。</p>
<p>如果以上都不适用您的威胁模型，则可以实施<a href="https://href.li/?https://tails.boum.org/contribute/design/memory_erasure/" target="_blank" rel="noopener">Tails的内存擦除过程</a>，该过程将擦除大部分内存（视频内存除外），并且已被证明是有效的。</p>
<h2><span id="最佳实践">最佳实践</span></h2>
<p>一旦对系统进行了尽可能多的加固，就应该遵循良好的隐私和安全性惯例：</p>
<ul>
<li>禁用或删除不需要的东西以最小化攻击面。</li>
<li>保持更新。配置 cron 任务或 init 脚本以每天更新系统。</li>
<li>不要泄漏有关您或您的系统的任何信息，无论它看起来多么渺小。</li>
<li>遵循<a href="https://href.li/?https://madaidans-insecurities.github.io/security-privacy-advice.html" target="_blank" rel="noopener">常规的安全和隐私建议</a></li>
</ul>
<p>尽管已经进行了强化，但您必须记住 Linux 仍然是一个有缺陷的操作系统，没有任何强化可以完全修复它。</p>
<h2><span id="其他指南">其他指南</span></h2>
<p>您应该进行尽可能多的研究，而不要依赖单一的信息来源。最大的安全问题之一就是用户。这些是我认为有价值的其他指南的链接：</p>
<ul>
<li>
<p><a href="https://href.li/?https://wiki.archlinux.org/index.php/Security" target="_blank" rel="noopener">Arch Linux Security wiki page</a></p>
</li>
<li>
<p><a href="https://href.li/?https://www.whonix.org/wiki/Documentation" target="_blank" rel="noopener">Whonix Documentation</a></p>
</li>
<li>
<p><a href="https://href.li/?https://apps.nsa.gov/iaarchive/library/ia-guidance/security-configuration/operating-systems/guide-to-the-secure-configuration-of-red-hat-enterprise.cfm" target="_blank" rel="noopener">NSA RHEL 5 Hardening Guide</a> (稍有过时，但仍包含有用的信息）</p>
</li>
<li>
<p><a href="https://href.li/?https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings" target="_blank" rel="noopener">KSPP recommended kernel settings</a></p>
</li>
<li>
<p><a href="https://href.li/?https://github.com/a13xp0p0v/kconfig-hardened-check/" target="_blank" rel="noopener">kconfig-hardened-check</a></p>
</li>
</ul>
<h2><span id="术语">术语</span></h2>
<p>您可能需要重新生成 GRUB 配置，以应用对引导加载程序所做的某些更改。在不同的发行版之间，执行此操作的步骤有时可能会有所不同。例如，在诸如 Arch Linux 之类的发行版上，应通过执行以下命令来重新生成配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o $path_to_grub_config</span><br></pre></td></tr></table></figure>
<p>“$path_to_grub_config” 取决于您如何设置系统。它通常是 <code>/boot/grub/grub.cfg</code>或 <code>/boot/EFI/grub/grub.cfg</code>，但是在执行此命令之前，请务必确保正确。</p>
<p>另外，在 Debian 或 Ubuntu 等发行版上，您应该执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure>
<h2><span id="能力">能力</span></h2>
<p>在 Linux 内核中，“root 特权” 分为各种不同的能力（<a href="https://href.li/?https://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">capabilities</a>）。这在应用最小特权原则时很有帮助——可以给它们仅授予特定的子集，而不是授予进程总的 root 特权。例如，如果程序只需要设置系统时间，则只需要 CAP_SYS_TIME 而不是 root 所有能力。这会限制可能造成的损害，但是，您仍必须谨慎授予能力，因为无论如何，其中许多能力<a href="https://href.li/?https://forums.grsecurity.net/viewtopic.php?t=2522" target="_blank" rel="noopener">可能会被滥用以获取完整的root特权</a>。</p>
<p>本文翻译自：<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html" target="_blank" rel="noopener">https://madaidans-insecurities.github.io/guides/linux-hardening.html</a></p>
<p><strong>如需『 Linux 系统安全强化指南 』PDF 高清版，可在公众号对话框回复关键字：「<code>LinuxSecurity</code>」获取。</strong></p>
<blockquote>
<p>本文转载自：「 GAO CHAO’S NEW BLOG 」，原文：<a href="http://t.cn/A6VwHzjQ" target="_blank" rel="noopener">http://t.cn/A6VwHzjQ</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p>
</blockquote>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "10135-1588830050631-449",
			        "name": "「奇妙的 Linux 世界」",
			        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",
			        "keyword": "VIP"
			    });
			}
			</script>
		
                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/posts/13355.html" data-toggle="tooltip" data-placement="top" title="如何在 Linux 下优雅的查看系统 CPU 信息">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/posts/50201.html" data-toggle="tooltip" data-placement="top" title="小白也能看懂的网络基础 | 02 连接设备？">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                
                    <!-- disqus 评论框 start -->
                    <div class="comment">
                        <div id="lv-container" data-id="city" data-uid="MTAyMC8yNzg2My80NDQw"></div>
                    </div>
                    <!-- disqus 评论框 end -->
                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">选择正确的Linux发行版</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">内核</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">Stable vs LTS 内核</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">Sysctl</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">Kernel self-protection</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">网络</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.5.</span> <span class="toc-nav-text">用户空间</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.6.</span> <span class="toc-nav-text">引导参数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.7.</span> <span class="toc-nav-text">Kernel self-protection</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.8.</span> <span class="toc-nav-text">CPU缓解</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.9.</span> <span class="toc-nav-text">结果</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.10.</span> <span class="toc-nav-text">hidepid</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.11.</span> <span class="toc-nav-text">减少内核攻击面</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.12.</span> <span class="toc-nav-text">引导参数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.13.</span> <span class="toc-nav-text">将内核模块列入黑名单</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.14.</span> <span class="toc-nav-text">rfkill</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.15.</span> <span class="toc-nav-text">其他内核指针泄漏</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.16.</span> <span class="toc-nav-text">限制对 sysfs 的访问</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.17.</span> <span class="toc-nav-text">Linux强化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.18.</span> <span class="toc-nav-text">Grsecurity</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.19.</span> <span class="toc-nav-text">内核运行时防护</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.20.</span> <span class="toc-nav-text">自编译内核</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">强制访问措施</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">沙箱</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">应用沙箱</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">常见沙箱逃逸</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.2.1.</span> <span class="toc-nav-text">PulseAudio</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.2.2.</span> <span class="toc-nav-text">D-Bus</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.2.3.</span> <span class="toc-nav-text">GUI隔离</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.2.4.</span> <span class="toc-nav-text">ptrace</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.2.5.</span> <span class="toc-nav-text">TIOCSTI</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.2.6.</span> <span class="toc-nav-text">Systemd 沙箱</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">gVisor</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.4.</span> <span class="toc-nav-text">虚拟机</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">强化内存分配器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">强化编译标志</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">内存安全语言</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">Root 账户</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">8.1.</span> <span class="toc-nav-text">&#x2F;etc&#x2F;securetty</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">8.2.</span> <span class="toc-nav-text">限制 su</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">8.3.</span> <span class="toc-nav-text">锁定 root 账户</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">8.4.</span> <span class="toc-nav-text">拒绝通过 SSH 的远程 root 登陆</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">8.5.</span> <span class="toc-nav-text">增加散列回合数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">8.6.</span> <span class="toc-nav-text">限制 Xorg root 访问</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">8.7.</span> <span class="toc-nav-text">安全访问root</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">防火墙</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">身份标识</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.1.</span> <span class="toc-nav-text">主机名和用户名</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.2.</span> <span class="toc-nav-text">Timezones &#x2F; Locales &#x2F; Keymaps</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.3.</span> <span class="toc-nav-text">机器ID</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.4.</span> <span class="toc-nav-text">MAC地址欺骗</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.5.</span> <span class="toc-nav-text">时间攻击</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.5.1.</span> <span class="toc-nav-text">ICMP时间戳</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.5.2.</span> <span class="toc-nav-text">TCP 时间戳</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.5.3.</span> <span class="toc-nav-text">TCP 初始化序号</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.5.4.</span> <span class="toc-nav-text">时间同步</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.6.</span> <span class="toc-nav-text">按键指纹</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">文件权限</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">11.1.</span> <span class="toc-nav-text">setuid &#x2F; setgid</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">11.2.</span> <span class="toc-nav-text">umask</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">核心转储</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.1.</span> <span class="toc-nav-text">sysctl</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.2.</span> <span class="toc-nav-text">systemd</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.3.</span> <span class="toc-nav-text">ulimit</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.4.</span> <span class="toc-nav-text">setuid进程</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">Swap</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">PAM</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">15.</span> <span class="toc-nav-text">Microcode更新</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">16.</span> <span class="toc-nav-text">IPv6 隐私扩展</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">16.1.</span> <span class="toc-nav-text">NetworkManager</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">16.2.</span> <span class="toc-nav-text">systemd-networkd</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">16.3.</span> <span class="toc-nav-text">分区和挂载选项</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">17.</span> <span class="toc-nav-text">熵</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">17.1.</span> <span class="toc-nav-text">RDRAND</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">18.</span> <span class="toc-nav-text">以 root 身份编辑文件</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">19.</span> <span class="toc-nav-text">特定发行版的安全强化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">19.1.</span> <span class="toc-nav-text">HTTP包管理器镜像</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">19.2.</span> <span class="toc-nav-text">APT seccomp-bpf</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">20.</span> <span class="toc-nav-text">物理安全</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">20.1.</span> <span class="toc-nav-text">BIOS &#x2F; UEFI强化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">20.2.</span> <span class="toc-nav-text">Bootloader 密码</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">20.2.1.</span> <span class="toc-nav-text">Grub</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">20.3.</span> <span class="toc-nav-text">Syslinux</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">20.4.</span> <span class="toc-nav-text">systemd-boot</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">20.5.</span> <span class="toc-nav-text">验证引导</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">20.6.</span> <span class="toc-nav-text">USBs</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">20.7.</span> <span class="toc-nav-text">DMA攻击</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">20.8.</span> <span class="toc-nav-text">冷启动攻击</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">21.</span> <span class="toc-nav-text">最佳实践</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">22.</span> <span class="toc-nav-text">其他指南</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">23.</span> <span class="toc-nav-text">术语</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">24.</span> <span class="toc-nav-text">能力</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#技巧" title="技巧">技巧</a>
                        
                          <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                        
                          <a class="tag" href="/tags/#安全" title="安全">安全</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://www.mike.org.cn/" target="_blank">简单.生活</a></li>
                    
                        <li><a href="http://shang.qq.com/wpa/qunwpa?idkey=ea4c43493c2269428ac6ef6141de4b6d78e5ab2d41380ca4099b833b62884ee9" target="_blank">技术交流群</a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






    <!-- 来必力City版公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
       (function(d, s) {
           var j, e = d.getElementsByTagName(s)[0];
    
           if (typeof LivereTower === 'function') { return; }
    
           j = d.createElement(s);
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;
    
           e.parentNode.insertBefore(j, e);
       })(document, 'script');
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    <!-- 来必力City版 公共JS代码 end -->



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                <% if (config.RSS) { %>
                    <li>
                        <a href="<%= config.root + 'atom.xml' %>">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                <% } %>
                <% if (config.twitter_username) { %>
                    <li>
                        <a target="_blank" href="https://twitter.com/<%= config.twitter_username %>">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                <% } %>
                <% if (config.zhihu_username) { %>
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/<%= config.zhihu_username %>">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                <% } %>

                <% if (config.weibo_username) { %>
                    <li>
                        <a target="_blank" href="http://weibo.com/<%= config.weibo_username %>">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                <% } %>

                <% if (config.facebook_username) { %>
                    <li>
                        <a target="_blank" href="https://www.facebook.com/<%= config.facebook_username %>">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                <% } %>

                <% if (config.github_username) { %>
                    <li>
                        <a target="_blank"  href="https://github.com/<%= config.github_username %>">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                <% } %>

                <% if (config.linkedin_username) { %>
                    <li>
                        <a target="_blank"  href="https://www.linkedin.com/in/<%= config.linkedin_username %>">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                <% } %>

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; <%= config.author %> <%= new Date().getFullYear() %> | Hosted by <a href="https://pages.coding.me" target="_blank" rel="noopener" style="font-weight: bold">Coding Pages</a>
                    <br>
                    Theme by <a href="http://beantech.org" target="_blank" rel="noopener">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://www.huweihuang.com" target="_blank" rel="noopener">胡伟煌</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huweihuang&repo=hexo-theme-huweihuang&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<%- js('js/jquery.min.js') %>

<!-- Bootstrap Core JavaScript -->
<%- js('js/bootstrap.min.js') %>

<!-- Custom Theme JavaScript -->
<%- js('js/hux-blog.min.js') %>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("<%= config.url%><%= config.root%>js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<% if (config.ga_track_id) { %>
<script>
    // dynamic User by Hux
    var _gaId = '<%= config.ga_track_id %>';
    var _gaDomain = '<%= config.ga_domain %>';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>

<% } %>


<!-- Baidu Tongji -->
<% if (config.ba_track_id) { %>
<script>
    // dynamic User by Hux
    var _baId = '<%= config.ba_track_id %>';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>
<% } %>





	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://www.hi-linux.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script>(function(w,d, s, id) {w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js, fjs = d.getElementsByTagName(s)[0];js = d.createElement(s); js.id = id;js.src = 'https://cdn.webpushr.com/app.min.js';fjs.parentNode.appendChild(js);}(window,document, 'script', 'webpushr-jssdk'));webpushr('init','BF9JK7xV9kjWTdMx2lr6RWaPfXV7wNuZaVAJ1bfIGoBNJavqLEBVFMKLubITnCA4bh2fI9iH9tMF95nXnPt7xxY');</script></body>

</html>
