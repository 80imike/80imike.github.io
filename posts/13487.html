<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="Linux,运维,Nginx,Zabbix,Centos,Ansible,MySQL,Python,Docker,Kubernetes,K3s,AI,WireGuard,ELK,Haproxy,Git,Nodejs,安全,技术">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          图解 Kubernetes 网络流量流转路径 - 奇妙的 Linux 世界
        
    </title>

    <link rel="canonical" href="https://www.hi-linux.com/posts/13487.html">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
<link rel="stylesheet" href="/css/beantech.min.css">

    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/toc.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="奇妙的 Linux 世界" type="application/atom+xml">
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/building.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                            
                              <a class="tag" href="/tags/#Docker" title="Docker">Docker</a>
                            
                              <a class="tag" href="/tags/#Kubernetes" title="Kubernetes">Kubernetes</a>
                            
                        </div>
                        <h1>图解 Kubernetes 网络流量流转路径</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Mike on
                            2022-09-20
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">奇妙的 Linux 世界</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <div id="vip-container"><blockquote>
<p>本文翻译自 <a href="https://learnk8s.io/kubernetes-network-packets%EF%BC%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E9%80%90%E5%AD%97%E7%BF%BB%E8%AF%91%EF%BC%8C%E5%B8%A6%E5%85%A5%E4%BA%86%E4%BA%9B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82" target="_blank" rel="noopener">https://learnk8s.io/kubernetes-network-packets，并没有逐字翻译，带入了些自己的理解。</a></p>
</blockquote>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-1-2022-09-19-c7m4AB.svg" alt></p>
<p>阅读本文，你可以了解在 Kubernetes 内外，数据包是如何转发的，从原始的 Web 请求开始，到托管应用程序的容器。</p>
<h2><span id="kubernetes-网络要求">Kubernetes 网络要求</span></h2>
<p>在深入了解在 Kubernetes 集群中数据包如何流转的细节之前，先明确一下 Kubernetes 对网络的要求。</p>
<p>Kubernetes 网络模型定义了一组基本规则：</p>
<ul>
<li>在不使用网络地址转换 (NAT) 的情况下，集群中的 Pod 能够与任意其他 Pod 进行通信。</li>
<li>在不使用网络地址转换 (NAT) 的情况下，在集群节点上运行的程序能与同一节点上的任何 Pod 进行通信。</li>
<li>每个 Pod 都有自己的 IP 地址（IP-per-Pod），并且任意其他 Pod 都可以通过相同的这个地址访问它。</li>
</ul>
<p>这些要求，不会将具体实现限制在某种解决方案上。</p>
<a id="more"></a>
<p>相反，它们笼统地描述了集群网络的特性。</p>
<p>为了满足这些限制，你必须解决以下挑战:</p>
<ol>
<li>如何确保同一个 Pod 中的容器行为就像它们在同一个主机上一样？</li>
<li>集群中的 Pod 能否访问其他 Pod？</li>
<li>Pod 可以访问服务吗？服务是负载均衡的吗？</li>
<li>Pod 可以接收集群外部的流量吗？</li>
</ol>
<p>在本文中，将重点关注前三点，从 Pod 内的网络，容器到容器的通信说起。</p>
<h2><span id="linux-网络命名空间如何在-pod-中工作">Linux 网络命名空间如何在 Pod 中工作</span></h2>
<p>让我们来看一个运行应用的主容器和伴随一起的另一个容器。</p>
<p>在示例中，有一个带有 nginx 和 busybox 容器的 Pod:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: multi-container-Pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: container-1</span><br><span class="line">      image: busybox</span><br><span class="line">      command: [&#39;&#x2F;bin&#x2F;sh&#39;, &#39;-c&#39;, &#39;sleep 1d&#39;]</span><br><span class="line">    - name: container-2</span><br><span class="line">      image: nginx</span><br></pre></td></tr></table></figure>
<p>部署时，会发生以下事情：</p>
<ol>
<li>Pod 在节点上拥有独立的网络命名空间。</li>
<li>分配一个 IP 地址给 Pod ，两个容器之间共享端口。</li>
<li>两个容器共享相同的网络命名空间，并在本地彼此可见。</li>
</ol>
<p>网络配置在后台迅速完成。</p>
<p>但是，让我们退后一步，尝试理解为什么运行容器需要上述动作。</p>
<p><a href="https://iximiuz.com/en/posts/container-networking-is-simple/" target="_blank" rel="noopener">在 Linux 中，网络命名空间是独立的、隔离的逻辑空间。</a></p>
<p>你可以将网络命名空间视为，将物理网络接口分割小块之后的独立部分。</p>
<p>每个部分都可以单独配置，并拥有自己的网络规则和资源。</p>
<p>这些包括防火墙规则、接口（虚拟的或物理的）、路由以及与网络相关的所有内容。</p>
<ol>
<li>物理网络接口持有根网络命名空间。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-2-2022-09-19-2lGj37.svg" alt></p>
<ol start="2">
<li>你可以使用 Linux 网络命名空间来创建独立的网络。每个网络都是独立的，除非你进行配置，默认不会与其他网络互通。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-3-2022-09-19-0Iv3p7.svg" alt></p>
<p>但最终，还是需要物理接口处理所有真实的数据包，所有虚拟接口都是基于物理接口创建的。</p>
<p>网络命名空间可以通过 <a href="https://man7.org/linux/man-pages/man8/ip-netns.8.html" target="_blank" rel="noopener">ip-netns</a> 进行管理，使用 <code>ip netns list</code> 可以列出主机上的命名空间。</p>
<blockquote>
<p>需要注意的是，创建的网络命名空间会出现在 <code>/var/run/netns</code> 下面，但 Docker 并没有遵循这一规则。</p>
</blockquote>
<p>例如，这是 Kubernetes 节点的一些命名空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns list</span><br><span class="line"></span><br><span class="line">cni-0f226515-e28b-df13-9f16-dd79456825ac (id: 3)</span><br><span class="line">cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd (id: 4)</span><br><span class="line">cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e (id: 2)</span><br><span class="line">cni-7619c818-5b66-5d45-91c1-1c516f559291 (id: 1)</span><br><span class="line">cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8 (id: 0)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 cni- 前缀；这意味着命名空间是由 CNI 插件创建的。</p>
</blockquote>
<p>当你创建一个 Pod，Pod 被分配给一个节点后，CNI 将：</p>
<ol>
<li>分配 IP 地址。</li>
<li>将容器连接到网络。</li>
</ol>
<p>如果 Pod 包含多个容器，那么这些容器都将被放在同一个命名空间中。</p>
<ol>
<li>当创建 Pod 时，容器运行时会给容器创建一个网络命名空间。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-4-20220919141522939-2022-09-19-nMCwoz.svg" alt></p>
<ol start="2">
<li>然后 CNI 负责给 Pod 分配一个 IP 地址。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-5-2022-09-19-sBtEl3.svg" alt></p>
<ol start="3">
<li>最后 CNI 将容器连接到网络的其余部分。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-6-2022-09-19-MiJzyw.svg" alt></p>
<p>那么，当你列出节点上的容器的命名空间会发生什么呢？</p>
<p>你可以通过 SSH 连接到 Kubernetes 节点并查看命名空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ lsns -t net</span><br><span class="line"></span><br><span class="line">        NS TYPE NPROCS   PID USER     NETNSID NSFS                           COMMAND</span><br><span class="line">4026531992 net     171     1 root  unassigned &#x2F;run&#x2F;docker&#x2F;netns&#x2F;default      &#x2F;sbin&#x2F;init noembed norestore</span><br><span class="line">4026532286 net       2  4808 65535          0 &#x2F;run&#x2F;docker&#x2F;netns&#x2F;56c020051c3b &#x2F;pause</span><br><span class="line">4026532414 net       5  5489 65535          1 &#x2F;run&#x2F;docker&#x2F;netns&#x2F;7db647b9b187 &#x2F;pause</span><br></pre></td></tr></table></figure>
<p><code>lsns</code> 是一个用于列出主机上所有可用命名空间的命令。</p>
<blockquote>
<p>请记住，Linux 中有<a href="https://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener">多种命名空间类型</a>。</p>
</blockquote>
<p>Nginx 容器在哪里？</p>
<p>那些 pause 容器是什么？</p>
<h2><span id="在-pod-中pause-容器创建了网络命名空间">在 Pod 中，pause 容器创建了网络命名空间</span></h2>
<p>先列出节点上的所有命名空间，看看能否找到 Nginx 容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ lsns</span><br><span class="line">        NS TYPE   NPROCS   PID USER            COMMAND</span><br><span class="line"># truncated output</span><br><span class="line">4026532414 net         5  5489 65535           &#x2F;pause</span><br><span class="line">4026532513 mnt         1  5599 root            sleep 1d</span><br><span class="line">4026532514 uts         1  5599 root            sleep 1d</span><br><span class="line">4026532515 pid         1  5599 root            sleep 1d</span><br><span class="line">4026532516 mnt         3  5777 root            nginx: master process nginx -g daemon off;</span><br><span class="line">4026532517 uts         3  5777 root            nginx: master process nginx -g daemon off;</span><br><span class="line">4026532518 pid         3  5777 root            nginx: master process nginx -g daemon off;</span><br></pre></td></tr></table></figure>
<p>Nginx 容器在挂载 (<code>mnt</code>)、Unix time-sharing (<code>uts</code>) 和 PID (<code>pid</code>) 命名空间中，但不在网络命名空间 (<code>net</code>) 中。</p>
<p>不幸的是，<code>lsns</code> 只显示每个进程最小的 PID，但你可以根据这个进程 ID 进一步过滤。</p>
<p>使用以下命令，在所有命名空间中检索 Nginx 容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo lsns -p 5777</span><br><span class="line"></span><br><span class="line">       NS TYPE   NPROCS   PID USER  COMMAND</span><br><span class="line">4026531835 cgroup    178     1 root  &#x2F;sbin&#x2F;init noembed norestore</span><br><span class="line">4026531837 user      178     1 root  &#x2F;sbin&#x2F;init noembed norestore</span><br><span class="line">4026532411 ipc         5  5489 65535 &#x2F;pause</span><br><span class="line">4026532414 net         5  5489 65535 &#x2F;pause</span><br><span class="line">4026532516 mnt         3  5777 root  nginx: master process nginx -g daemon off;</span><br><span class="line">4026532517 uts         3  5777 root  nginx: master process nginx -g daemon off;</span><br><span class="line">4026532518 pid         3  5777 root  nginx: master process nginx -g daemon off;</span><br></pre></td></tr></table></figure>
<p><code>pause</code> 进程再次出现，它劫持了网络命名空间。</p>
<p>这是怎么回事？</p>
<p><em><strong>集群中的每个 Pod 都有一个额外的隐藏容器在后台运行，称为 pause 容器。</strong></em></p>
<p>列出在节点上运行的容器并获取 pause 容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps | grep pause</span><br><span class="line"></span><br><span class="line">fa9666c1d9c6   k8s.gcr.io&#x2F;pause:3.4.1  &quot;&#x2F;pause&quot;  k8s_POD_kube-dns-599484b884-sv2js…</span><br><span class="line">44218e010aeb   k8s.gcr.io&#x2F;pause:3.4.1  &quot;&#x2F;pause&quot;  k8s_POD_blackbox-exporter-55c457d…</span><br><span class="line">5fb4b5942c66   k8s.gcr.io&#x2F;pause:3.4.1  &quot;&#x2F;pause&quot;  k8s_POD_kube-dns-599484b884-cq99x…</span><br><span class="line">8007db79dcf2   k8s.gcr.io&#x2F;pause:3.4.1  &quot;&#x2F;pause&quot;  k8s_POD_konnectivity-agent-84f87c…</span><br></pre></td></tr></table></figure>
<p>可以看到，节点上的每一个 Pod 都会有一个对应的 pause 容器。</p>
<p>这个 <code>pause</code> 容器负责创建和维持网络命名空间。</p>
<p><a href="https://www.aquasec.com/cloud-native-academy/container-security/container-runtime/" target="_blank" rel="noopener">底层容器运行时</a>会完成网络命名空间的创建，通常是由 <code>containerd</code> 或 <code>CRI-O</code> 完成。</p>
<p>在部署 Pod 和创建容器之前，由运行时创建网络命名空间。</p>
<p>容器运行时会自动完成这些，不需要手工执行 <code>ip netns</code> 创建命名空间。</p>
<p>话题回到 pause 容器。</p>
<p>它包含非常少的代码，并且在部署后立即进入睡眠状态。</p>
<p>但是，<a href="https://www.ianlewis.org/en/almighty-pause-container" target="_blank" rel="noopener">它是必不可少的，并且在 Kubernetes 生态系统中起着至关重要的作用</a>。</p>
<ol>
<li>创建 Pod 时，容器运行时会创建一个带有睡眠容器的网络命名空间。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-7-20220919141528218-2022-09-19-7EsuRT.svg" alt></p>
<ol start="2">
<li>Pod 中的其他容器都会加入由 pause 容器创建的网络名称空间。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-8-20220919141535160-2022-09-19-JOFs8C.svg" alt></p>
<ol start="3">
<li>此时，CNI 分配 IP 地址并将容器连接到网络。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-9-2022-09-19-Wxey6q.svg" alt></p>
<p>一个进入睡眠状态的容器有什么用？</p>
<p>为了理解它的用途，让我们想象一个 Pod 有两个容器，就像前面的例子一样，但没有 pause 容器。</p>
<p>一旦容器启动，CNI 将会：</p>
<ol>
<li>使 busybox 容器加入之前的网络命名空间。</li>
<li>分配 IP 地址。</li>
<li>将容器连接到网络。</li>
</ol>
<p>如果 Nginx 崩溃了怎么办？</p>
<p>CNI 将不得不再次执行所有步骤，并且两个容器的网络都将中断。</p>
<p>由于睡眠容器不太可能有任何错误，因此创建网络命名空间通常是一种更安全、更健壮的选择。</p>
<blockquote>
<p>如果 Pod 中的一个容器崩溃了，剩下的仍然可以回复其他网络请求。</p>
</blockquote>
<h2><span id="分配一个-ip-地址给-pod">分配一个 IP 地址给 Pod</span></h2>
<p>前面我提到 Pod 和两个容器将具有同一个 IP 地址。</p>
<p>那是怎样配置的呢？</p>
<blockquote>
<p>在 Pod 网络命名空间内，创建了一个接口，并分配了一个 IP 地址。</p>
</blockquote>
<p>让我们验证一下。</p>
<p>首先，找到 Pod 的 IP 地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get Pod multi-container-Pod -o jsonpath&#x3D;&#123;.status.PodIP&#125;</span><br><span class="line"></span><br><span class="line">10.244.4.40</span><br></pre></td></tr></table></figure>
<p>接下来，找到相关的网络命名空间。</p>
<p>由于网络命名空间是从物理接口创建的，需要先访问集群节点。</p>
<blockquote>
<p>如果你运行的是 minikube，使用 <code>minikube ssh</code> 访问节点。如果在云厂中运行，那么应该有某种方法可以通过 SSH 访问节点。</p>
</blockquote>
<p>进入后，找到最新创建的命名网络命名空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lt &#x2F;var&#x2F;run&#x2F;netns</span><br><span class="line"></span><br><span class="line">total 0</span><br><span class="line">-r--r--r-- 1 root root 0 Sep 25 13:34 cni-0f226515-e28b-df13-9f16-dd79456825ac</span><br><span class="line">-r--r--r-- 1 root root 0 Sep 24 09:39 cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd</span><br><span class="line">-r--r--r-- 1 root root 0 Sep 24 09:39 cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e</span><br><span class="line">-r--r--r-- 1 root root 0 Sep 24 09:39 cni-7619c818-5b66-5d45-91c1-1c516f559291</span><br><span class="line">-r--r--r-- 1 root root 0 Sep 24 09:39 cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8</span><br></pre></td></tr></table></figure>
<p>在示例中，就是 <code>cni-0f226515-e28b-df13-9f16-dd79456825ac</code>。然后，可以在该命名空间内运行 <code>exec</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac ip a</span><br><span class="line"></span><br><span class="line"># output truncated</span><br><span class="line">3: eth0@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.244.4.40&#x2F;32 brd 10.244.4.40 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::14a4:f8ff:fe4f:5677&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>这个 IP 就是 Pod 的 IP 地址！通过查找 @if12 中的 12 找到网络接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip link | grep -A1 ^12</span><br><span class="line"></span><br><span class="line">12: vethweplb3f36a0@if16: mtu 1376 qdisc noqueue master weave state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 72:1c:73:d9:d9:f6 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure>
<p>你还可以验证 Nginx 容器是否监听了来自该命名空间内的 HTTP 流量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac netstat -lnp</span><br><span class="line"></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      692698&#x2F;nginx: master</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      692698&#x2F;nginx: master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你无法通过 SSH 访问集群中的工作节点，你可以使用 <code>kubectl exec</code> 获取到 busybox 容器的 shell 并直接在内部使用 <code>ip</code> 和 <code>netstat</code> 命令。</p>
</blockquote>
<p>刚刚我们介绍了容器之间的通信，再来看看如何建立 Pod 到 Pod 的通信吧。</p>
<h2><span id="查看集群中-pod-到-pod-的流量">查看集群中 Pod 到 Pod 的流量</span></h2>
<p>Pod 到 Pod 的通信有两种可能的情况：</p>
<ol>
<li>Pod 流量的目的地是同一节点上的 Pod。</li>
<li>Pod 流量的目的地是在不同节点上的 Pod。</li>
</ol>
<p>整个工作流依赖于虚拟接口对和网桥，下面先来了解一下这部分的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了让一个 Pod 与其他 Pod 通信，它必须先访问节点的根命名空间。</span><br></pre></td></tr></table></figure>
<p>通过虚拟以太网对来实现 Pod 和根命名空间的连接。</p>
<p>这些虚拟接口设备（veth 中的 v）连接并充当两个命名空间之间的隧道。</p>
<p>使用此 <code>veth</code> 设备，你将一端连接到 Pod 的命名空间，另一端连接到根命名空间。</p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-10-2022-09-19-zqzPW6.svg" alt></p>
<p>CNI 可以帮你执行这些操作，但你也可以手动执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip link add veth1 netns Pod-namespace type veth peer veth2 netns root</span><br></pre></td></tr></table></figure>
<p>现在 Pod 的命名空间有一个可以访问根命名空间的 <code>隧道</code>。</p>
<p>节点上，新建的每一个 Pod 都会设置这样的 <code>veth</code> 对。</p>
<p>一个是，创建接口对；另一个是为以太网设备分配地址并配置默认路由。</p>
<p>下面看看如何在 Pod 的命名空间中设置 <code>veth1</code> 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac ip addr add 10.244.4.40&#x2F;24 dev veth1</span><br><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac ip link set veth1 up</span><br><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac ip route add default via 10.244.4.40</span><br></pre></td></tr></table></figure>
<p>在节点上，让我们创建另一个 <code>veth2</code> 对：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr add 169.254.132.141&#x2F;16 dev veth2</span><br><span class="line">$ ip link set veth2 up</span><br></pre></td></tr></table></figure>
<p>可以像前面一样检查现有的 <code>veth</code> 对。</p>
<p>在 Pod 的命名空间中，检索 <code>eth0</code> 接口的后缀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns exec cni-0f226515-e28b-df13-9f16-dd79456825ac ip link show type veth</span><br><span class="line"></span><br><span class="line">3: eth0@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>
<p>在这种情况下，可以使用命令 <code>grep -A1 ^12</code> 查找（或滚动到目标所在处）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip link show type veth</span><br><span class="line"></span><br><span class="line"># output truncated</span><br><span class="line">12: cali97e50e215bd@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netns cni-0f226515-e28b-df13-9f16-dd79456825ac</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以使用 <code>ip -n cni-0f226515-e28b-df13-9f16-dd79456825ac link show type veth</code>.命令</p>
</blockquote>
<p>注意 <code>3: eth0@if12和12: cali97e50e215bd@if3</code> 接口上的符号。</p>
<p>从 Pod 命名空间，该 <code>eth0</code> 接口连接到根命名空间的 12 号接口，因此是 <code>@if12</code>.</p>
<p>在 <code>veth</code> 对的另一端，根命名空间连接到 Pod 命名空间的 3 号接口。</p>
<p>接下来是连接 <code>veth</code> 对两端的桥接器。</p>
<h2><span id="pod-网络命名空间连接到以太网桥">Pod 网络命名空间连接到以太网桥</span></h2>
<p>网桥会汇聚位于根命名空间中的每一个虚拟接口。这个网桥允许虚拟 pair 之间的流量，也允许穿过公共根命名空间的流量。</p>
<p>补充一下相关原理。</p>
<p>以太网桥位于 <a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener">OSI 网络模型</a> 的第 2 层。</p>
<p>你可以将网桥视为接受来自不同命名空间和接口的连接的虚拟交换机。</p>
<p><a href="https://ops.tips/blog/using-network-namespaces-and-bridge-to-isolate-servers/" target="_blank" rel="noopener">以太网桥可以连接节点上的多个可用网络。</a></p>
<p>因此，可以使用网桥连接两个接口，即 Pod 命名空间的 <code>veth</code> 连接到同一节点上另一个 Pod 的 <code>veth</code>。</p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-11-20220919141543937-2022-09-19-lVtOgN.svg" alt></p>
<p>接下来，继续看网桥和 veth 对的用途。</p>
<h2><span id="跟踪在同一节点上-pod-到-pod-的流量">跟踪在同一节点上 Pod 到 Pod 的流量</span></h2>
<p>假设同一个节点上有两个 Pod，Pod-A 向 Pod-B 发送消息。</p>
<ol>
<li>由于访问目标不在同一个命名空间，Pod-A 将数据包发送到其默认接口 eth0。 这个接口与 veth 对的一端绑定，作为隧道。这样，数据包会被转发到节点上的根命名空间。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-12-20220919141632527-2022-09-19-NRPgWl.svg" alt></p>
<ol start="2">
<li>以太网网桥作为一个虚拟交换机，需要目标 Pod-B 的 MAC 地址才能工作。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-13-2022-09-19-M7QRru.svg" alt></p>
<ol start="3">
<li>ARP 协议会解决这个问题。当帧到达网桥时，会向所有连接的设备发送 ARP 广播。网桥广播询问持有 Pod-B 的 IP 地址</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-14-2022-09-19-Ibitey.svg" alt></p>
<ol start="4">
<li>此时会收到一个带有 Pod-B IP 的 MAC 地址应答，这条消息会被存储在桥接 ARP 缓存(查找表)中。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-15-2022-09-19-y5ldCP.svg" alt></p>
<ol start="5">
<li>IP 地址和 MAC 地址的映射关系存储之后，网桥就在表中查找，并将数据包转发到正确的端点。数据包到达根命名空间内 Pod-B 的 veth 之后，很快又到达 Pod-B 命名空间内的 eth0 接口。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-16-20220919141551029-2022-09-19-DusApt.svg" alt></p>
<p>至此，Pod-A 和 Pod-B 之间的通信就成功了。</p>
<h2><span id="跟踪不同节点上的-pod-到-pod-通信">跟踪不同节点上的 Pod 到 Pod 通信</span></h2>
<p>对于跨节点 Pod 之间的通信，会经过额外的通信跳跃。</p>
<ol>
<li>前几个步骤保持不变，直到数据包到达根命名空间并需要发送到 Pod-B。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-17-2022-09-19-xXNQzL.svg" alt></p>
<ol start="2">
<li>当目的 IP 不在本地网络中时，报文被转发到节点的默认网关。节点的出口网关或默认网关，通常位于节点与网络相连的物理接口 eth0 上。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-18-2022-09-19-h2DI4L.svg" alt></p>
<p>此时 不会发生 ARP 解析，因为源 IP 和目标 IP 不在同一个网段中。</p>
<p>网段的检查是使用按位运算完成的。</p>
<p>当目的 IP 不在当前网络段时，数据包被转发到节点的默认网关。</p>
<h2><span id="按位运算的工作原理">按位运算的工作原理</span></h2>
<p>在确定数据包的转发位置时，源节点必须执行位运算</p>
<p><a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND" target="_blank" rel="noopener">这也称为与操作。</a></p>
<p>复习一下，按位与运算的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 AND 0 &#x3D; 0</span><br><span class="line">0 AND 1 &#x3D; 0</span><br><span class="line">1 AND 0 &#x3D; 0</span><br><span class="line">1 AND 1 &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>除了 1 与 1 以外的都是 false。</p>
<p>如果源节点的 IP 为 192.168.1.1，子网掩码为 /24，目标 IP 为 172.16.1.1/16，则按位与运算将得知它们位于不同的网段上。</p>
<p>这意味着目标 IP 与数据包的源不在同一个网络上，数据包将通过默认网关转发。</p>
<p>数学时间。</p>
<p>我们必须从二进制的 32 位地址开始进行 AND 操作。</p>
<p>先找出源 IP 网络和目标 IP 网段。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Binary</th>
<th style="text-align:left">Converted</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Src. IP Address</td>
<td style="text-align:left">11000000.10101000.00000001.00000001</td>
<td style="text-align:left">192.168.1.1</td>
</tr>
<tr>
<td style="text-align:left">Src. Subnet Mask</td>
<td style="text-align:left">11111111.11111111.11111111.00000000</td>
<td style="text-align:left">255.255.255.0(/24)</td>
</tr>
<tr>
<td style="text-align:left">Src. Network</td>
<td style="text-align:left">11000000.10101000.00000001.00000000</td>
<td style="text-align:left">192.168.1.0</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Dst. IP Address</td>
<td style="text-align:left">10101100.00010000.00000001.00000001</td>
<td style="text-align:left">172.16.1.1</td>
</tr>
<tr>
<td style="text-align:left">Dst. Subnet Mask</td>
<td style="text-align:left">11111111.11111111.00000000.00000000</td>
<td style="text-align:left">255.255.0.0(/16)</td>
</tr>
<tr>
<td style="text-align:left">Dst. Network</td>
<td style="text-align:left">10101100.00010000.00000000.00000000</td>
<td style="text-align:left">172.16.0.0</td>
</tr>
</tbody>
</table>
<p>按位运算之后，需要将目标 IP 与数据包源节点的子网进行比较。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Binary</th>
<th style="text-align:left">Converted</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Dst. IP Address</td>
<td style="text-align:left">10101100.00010000.00000001.00000001</td>
<td style="text-align:left">172.16.1.1</td>
</tr>
<tr>
<td style="text-align:left">Src. Subnet Mask</td>
<td style="text-align:left">11111111.11111111.11111111.00000000</td>
<td style="text-align:left">255.255.255.0(/24)</td>
</tr>
<tr>
<td style="text-align:left">Network Result</td>
<td style="text-align:left">10101100.00010000.00000001.00000000</td>
<td style="text-align:left">172.16.1.0</td>
</tr>
</tbody>
</table>
<p>运算的结果是 172.16.1.0，不等于 192.168.1.0（源节点的网络）。说明源 IP 地址和目标 IP 地址不在同一个网络上。</p>
<p>如果目标 IP 是 192.168.1.2，即与发送 IP 在同一子网中，则 AND 操作将得到节点的本地网络。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Binary</th>
<th style="text-align:left">Converted</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Dst. IP Address</td>
<td style="text-align:left">11000000.10101000.00000001.00000010</td>
<td style="text-align:left">192.168.1.2</td>
</tr>
<tr>
<td style="text-align:left">Src. Subnet Mask</td>
<td style="text-align:left">11111111.11111111.11111111.00000000</td>
<td style="text-align:left">255.255.255.0(/24)</td>
</tr>
<tr>
<td style="text-align:left">Network</td>
<td style="text-align:left">11000000.10101000.00000001.00000000</td>
<td style="text-align:left">192.168.1.0</td>
</tr>
</tbody>
</table>
<p>进行逐位比较后，ARP 通过查找表查找默认网关的 MAC 地址。</p>
<p>如果有条目，将立即转发数据包。</p>
<p>否则，先进行广播以找到网关的 MAC 地址。</p>
<ol>
<li>现在，数据包路由到另一个节点的默认接口，我们称为 Node-B。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-19-2022-09-19-O2NAMf.svg" alt></p>
<ol start="2">
<li>以相反的顺序。现在，数据包位于 Node-B 的根命名空间，并到达网桥，这里会进行 ARP 解析。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-20-2022-09-19-sncbQT.svg" alt></p>
<ol start="3">
<li>路由系统将返回与 Pod-B 相连的接口的 MAC 地址。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-21-2022-09-19-l9iVbm.svg" alt></p>
<ol start="4">
<li>网桥通过 Pod-B 的 <code>veth</code> 设备转发帧，并到达 Pod-B 的命名空间。</li>
</ol>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-22-20220919141556537-2022-09-19-8ckOcx.svg" alt></p>
<p>至此，你应该已经熟悉了 Pod 之间的流量是如何流转的。下面，让我们花点时间来看看 CNI 如何管理上诉内容。</p>
<h2><span id="容器网络接口-cni">容器网络接口 - CNI</span></h2>
<p><a href="https://github.com/containernetworking/cni/blob/main/SPEC.md" target="_blank" rel="noopener">容器网络接口（CNI）主要关注的是当前节点中的网络。</a></p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-23-2022-09-19-PBGpbi.svg" alt></p>
<p>可以将 CNI 看作为解决 Kubernetes 网络需求，而遵循的一组规则。</p>
<p>有这些 CNI 实现可供使用：</p>
<ul>
<li><a href="https://www.tigera.io/project-calico/" target="_blank" rel="noopener">Calico</a></li>
<li><a href="https://cilium.io/" target="_blank" rel="noopener">Cillium</a></li>
<li><a href="https://github.com/flannel-io/flannel" target="_blank" rel="noopener">Flannel</a></li>
<li><a href="https://www.weave.works/docs/net/latest/overview/" target="_blank" rel="noopener">Weave Net</a></li>
<li>其他网络插件</li>
</ul>
<p>他们都遵循相同的 CNI 标准。</p>
<p>如果没有 CNI，你需要人工完成如下操作：</p>
<ul>
<li>创建接口。</li>
<li>创建 veth 对。</li>
<li>设置网络命名空间。</li>
<li>设置静态路由。</li>
<li>配置以太网桥。</li>
<li>分配 IP 地址。</li>
<li>创建 NAT 规则。</li>
<li>还有其他大量事情。</li>
</ul>
<p>这还不包括，在删除或重启 Pod 时，需要进行类似的全部操作。</p>
<p>CNI 必须支持<a href="https://github.com/containernetworking/cni/blob/main/SPEC.md#cni-operations" target="_blank" rel="noopener">四种不同的操作</a>：</p>
<ul>
<li>ADD - 向网络添加一个容器。</li>
<li>DEL - 从网络中删除一个容器。</li>
<li>CHECK - 如果容器的网络出现问题，则返回错误。</li>
<li>VERSION - 显示插件的版本。</li>
</ul>
<p>我们一起看下，CNI 是如何工作的。</p>
<p>当 Pod 被分配到特定节点时，Kubelet 自身不会初始化网络。</p>
<p>相反，Kubelet 将这个任务交给 CNI。</p>
<p><em>但是，Kubelet 以 JSON 格式指定配置并发送至 CNI 插件。</em></p>
<p>你可以进入节点上的 <code>/etc/cni/net.d</code> 文件夹，使用以下命令查看当前的 CNI 配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ cat 10-calico.conflist</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;k8s-Pod-network&quot;,</span><br><span class="line">  &quot;cniVersion&quot;: &quot;0.3.1&quot;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;calico&quot;,</span><br><span class="line">      &quot;datastore_type&quot;: &quot;kubernetes&quot;,</span><br><span class="line">      &quot;mtu&quot;: 0,</span><br><span class="line">      &quot;nodename_file_optional&quot;: false,</span><br><span class="line">      &quot;log_level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;log_file_path&quot;: &quot;&#x2F;var&#x2F;log&#x2F;calico&#x2F;cni&#x2F;cni.log&quot;,</span><br><span class="line">      &quot;ipam&quot;: &#123; &quot;type&quot;: &quot;calico-ipam&quot;, &quot;assign_ipv4&quot; : &quot;true&quot;, &quot;assign_ipv6&quot; : &quot;false&quot;&#125;,</span><br><span class="line">      &quot;container_settings&quot;: &#123;</span><br><span class="line">          &quot;allow_ip_forwarding&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;policy&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;k8s&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;kubernetes&quot;: &#123;</span><br><span class="line">          &quot;k8s_api_root&quot;:&quot;https:&#x2F;&#x2F;10.96.0.1:443&quot;,</span><br><span class="line">          &quot;kubeconfig&quot;: &quot;&#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;calico-kubeconfig&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;bandwidth&quot;,</span><br><span class="line">      &quot;capabilities&quot;: &#123;&quot;bandwidth&quot;: true&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;&quot;type&quot;: &quot;portmap&quot;, &quot;snat&quot;: true, &quot;capabilities&quot;: &#123;&quot;portMappings&quot;: true&#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 CNI 插件都会使用不同类型的网络配置。</p>
<p>例如，Calico 使用基于 BGP 的三层网络连接 Pod</p>
<p>Cilium 从三层到七层使用的是基于 eBPF 的 overlay 网络</p>
<p>与 Calico 一样，Cilium 也支持通过配置网络策略来限制流量。</p>
<p>那么你应该使用哪一个呢？主要有两类 CNI。</p>
<p>在第一类中，使用基本网络设置（也称为平面网络），从集群的 IP 池为 Pod 分配 IP 地址的 CNI。</p>
<p>这种方式可能很快耗尽 IP 地址，而成为负担。</p>
<p>相反，另一类是使用 overlay 网络。</p>
<p>简单来说，overlay 网络是主（底层）网络之上的重建网络。</p>
<p>overlay 网络通过封装来自底层网络的数据包工作，这些数据包被发送到另一个节点上的 Pod。</p>
<p>overlay 网络的一种流行技术是 VXLAN，它可以在 L3 网络上建立 L2 域的隧道。</p>
<p>那么哪个更好呢？</p>
<p>没有单一的答案，这取决于你的需求。</p>
<p>你是否正在构建具有数万个节点的大型集群？</p>
<p>也许 overlay 网络更好。</p>
<p>你是否在意更简单的配置和审查网络流量，而不会愿意在复杂网络中丢失这种能力？</p>
<p>扁平网络更适合你。</p>
<p>现在我们讨论完了 CNI，接着让我们来看看 Pod 到服务的通信是如何连接的。</p>
<h2><span id="检查-pod-到-service-的流量">检查 Pod 到 Service 的流量</span></h2>
<p>由于 Pod 在 Kubernetes 中是动态的，分配给 Pod 的 IP 地址不是静态的。</p>
<p>Pod 的 IP 是短暂的，每次创建或删除 Pod 时都会发生变化。</p>
<p>Kubernetes 中的 Service 解决了这个问题，为连接一组 Pod 提供了可靠的机制。</p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-24-2022-09-19-8P1MI3.svg" alt></p>
<p>默认情况下，在 Kubernetes 中创建 Service 时，<a href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies" target="_blank" rel="noopener">被分配一个虚拟 IP</a>。</p>
<p>在 Service 中，可以使用选择器将 Service 与目标 Pod 相关联。</p>
<p>当删除或添加一个 Pod 时会发生什么呢？</p>
<blockquote>
<p>Service 的虚拟 IP 保持静态不变。</p>
</blockquote>
<p>但流量可以再无需干预的情况下，到达新创建的 Pod。</p>
<p>换句话说，Kubernetes 中的 Service 类似于负载均衡器。</p>
<p>但它们是如何工作的？</p>
<h2><span id="使用-netfilter-和-iptables-拦截和重写流量">使用 Netfilter 和 Iptables 拦截和重写流量</span></h2>
<p>Kubernetes 中的 Service 是基于 Linux 内核中的两个组件构建的：</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">网络过滤器</a></li>
<li><a href="https://en.wikipedia.org/wiki/Iptables" target="_blank" rel="noopener">iptables</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Netfilter 是一个可以配置数据包过滤、创建 NAT 、端口转发规则以及管理网络中流量的框架</span><br></pre></td></tr></table></figure>
<p>此外，它可以屏蔽和禁止未经同意的访问。</p>
<p>另一方面，iptables 是一个用户态程序，可以用来配置 Linux 内核防火墙的 IP 数据包过滤规则。</p>
<p>iptables 是作为不同的 Netfilter 模块实现的。</p>
<p>可以使用 iptables CLI 即时修改过滤规则，并将它们插入 netfilters 挂载点。</p>
<p>过滤器配置在不同的表中，其中包含用于处理网络流量数据包的链。</p>
<p>不同的协议使用不同的内核模块和程序。</p>
<blockquote>
<p>当提到 iptables 时，通常指的是 IPv4。对于 IPv6 ，终端工具是 ip6tables。</p>
</blockquote>
<p>iptables 有五种链，每一种链都直接映射到 Netfilter 的钩子上。</p>
<p>从 iptables 的角度来看，它们是：</p>
<ul>
<li><code>PRE_ROUTING</code></li>
<li><code>INPUT</code></li>
<li><code>FORWARD</code></li>
<li><code>OUTPUT</code></li>
<li><code>POST_ROUTING</code></li>
</ul>
<p>它们对应地映射到 Netfilter 钩子：</p>
<ul>
<li><code>NF_IP_PRE_ROUTING</code></li>
<li><code>NF_IP_LOCAL_IN</code></li>
<li><code>NF_IP_FORWARD</code></li>
<li><code>NF_IP_LOCAL_OUT</code></li>
<li><code>NF_IP_POST_ROUTING</code></li>
</ul>
<p>当一个数据包到达时，根据它所处的阶段，将 “触发” 一个 Netfilter 钩子。这个钩子会执行特定的 iptables 过滤规则。</p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-25-20220919141602921-2022-09-19-tsberQ.svg" alt></p>
<p>哎呀！看起来很复杂！</p>
<p>不过没什么好担心的。</p>
<p>这就是我们使用 Kubernetes 的原因，以上所有内容都是通过使用 Service 抽象出来的，并且一个简单的 YAML 定义可以自动设置这些规则。</p>
<p>如果你有兴趣查看 iptables 规则，可以连接到节点并运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables-save</span><br></pre></td></tr></table></figure>
<p>你还可以使用<a href="https://github.com/Nudin/iptable_vis" target="_blank" rel="noopener">这个工具来可视化</a>节点上的 iptables 链。</p>
<p>这是来自 GKE 节点上的可视化 iptables 链的示例图：</p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-26-2022-09-19-GirLZG.svg" alt></p>
<p>注意，这里可能配置了几百条规则，想想一下自己动手怎么配置！</p>
<p>至此，我们已经了解了，相同节点上的 Pod 和不同节点上 Pod 之间是如何通信的。</p>
<p>在 Pod 与 Service 的通信中，链路的前半部分是一样的。</p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-27-2022-09-19-zcNnij.svg" alt></p>
<p>当请求从 Pod-A 走向 Pod-B 时，由于 Pod-B 在 Service 的 “后面”，在传输的过程中，会有一些不一样。</p>
<p>原始的请求，在 Pod-A 命名空间的 eth0 接口发出。</p>
<p>接着，请求通过 <code>veth</code>到达根名称空间的网桥。</p>
<p>一旦到达网桥，数据包就会立即通过默认网关转发。</p>
<p>与 Pod-to-Pod 部分一样，主机进行按位比较。由于服务的虚拟 IP 不是节点 CIDR 的一部分，因此数据包将立即通过默认网关转发。</p>
<p>如果默认网关的 MAC 地址尚未出现在查找表中，则会进行 ARP 解析找出默认网关的 MAC 地址。</p>
<p>现在神奇的事情发生了。</p>
<p>在数据包通过节点的路由之前，Netfilter 的 <code>NF_IP_PRE_ROUTING</code> 挂钩被触发，并执行 iptables 规则。这个规则会修改 Pod-A 数据包的目标 IP 地址 DNAT。</p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-28-2022-09-19-xAplcC.svg" alt></p>
<p>前面服务的虚拟 IP 地址被重写为 Pod-B 的 IP 地址。</p>
<p>接下来，数据包路由过程与 Pod 到 Pod 的通信一样。</p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-29-2022-09-19-7aqxsB.svg" alt></p>
<p>数据包重写后，通信是 Pod 到 Pod。</p>
<p>然而，在所有这些通信中，使用了一个第三方的功能。</p>
<p><a href="https://www.linuxtopia.org/Linux_Firewall_iptables/x1298.html" target="_blank" rel="noopener">此功能称为 conntrack</a> 或链路跟踪。</p>
<p>当 Pod-B 发回响应时，conntrack 会将数据包与链路相关联，并跟踪其来源。</p>
<p>NAT 严重依赖于 conntrack。</p>
<p>如果没有链路跟踪，将不知道将包含响应的数据包发回何处。</p>
<p>使用 conntrack 时，数据包的返回路径很容易设置为相同的源或目标 NAT 更改。</p>
<p>通信的另一部分与现在的链路相反。</p>
<p>Pod-B 接收并处理了请求，现在将数据发送回 Pod-A。</p>
<p>现在会发生什么呢？</p>
<h2><span id="检查来自服务的响应">检查来自服务的响应</span></h2>
<p>Pod-B 发送响应，将其 IP 地址设置为源地址，并将 Pod-A 的 IP 地址设置为目标地址。</p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-30-20220919141614676-2022-09-19-4nUE8X.svg" alt></p>
<p>当数据包到达 Pod-A 所在节点的接口时，会发生另一个 NAT。</p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-31-2022-09-19-PS5DQz.svg" alt></p>
<p>这时，conntrack 开始工作，修改源 IP 地址，iptables 规则执行 SNAT，并将 Pod-B 的源 IP 地址修改为原始服务的虚拟 IP。</p>
<p><img src="https://img.hi-linux.com/staticfile/k8s-network-32-2022-09-19-bQ6FAb.svg" alt></p>
<p>对于 Pod-A 来说，响应是来自于 Service 而不是 Pod-B。</p>
<p>其余的都是一样的。一旦 SNAT 完成，数据包就会到达根命名空间中的网桥，并通过 <code>veth</code> 对转发到 <code>Pod-A</code>。</p>
<h2><span id="总结一下">总结一下</span></h2>
<p>让我们一起回顾下本文相关要点</p>
<ul>
<li>容器如何在本地或 Pod 内通信。</li>
<li>在相同节点和不同节点上的 Pod 如何通信。</li>
<li>Pod-to-Service - Pod 如何将流量发送到 Kubernetes 中服务后面的 Pod 时。</li>
<li>什么是命名空间、veth、iptables、chains、conntrack、Netfilter、CNI、overlay 网络，以及 Kubernetes 网络工具箱中所需的一切。</li>
</ul>
<blockquote>
<p>本文转载自：「 陈少文的博客 」，原文：<a href="https://url.hi-linux.com/GQueR" target="_blank" rel="noopener">https://url.hi-linux.com/GQueR</a> ，版权归原作者所有。欢迎投稿，投稿邮箱: <a href="mailto:editor@hi-linux.com">editor@hi-linux.com</a>。</p>
</blockquote>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "10135-1588830050631-449",
			        "name": "「奇妙的 Linux 世界」",
			        "qrcode": "https://www.hi-linux.com/img/wechat/mp_qrcode_12.jpg",
			        "keyword": "VIP"
			    });
			}
			</script>
		
                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/posts/35875.html" data-toggle="tooltip" data-placement="top" title="如何使用 KubeSeal 高效加密和管理 Kubernetes 集群的 Secret">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/posts/20680.html" data-toggle="tooltip" data-placement="top" title="如何使用 cri-docker 解决 Kubernetes 1.24 不支持 Docker 的问题">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                
                    <!-- disqus 评论框 start -->
                    <div class="comment">
                        <div id="lv-container" data-id="city" data-uid="MTAyMC8yNzg2My80NDQw"></div>
                    </div>
                    <!-- disqus 评论框 end -->
                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">Kubernetes 网络要求</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">Linux 网络命名空间如何在 Pod 中工作</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">在 Pod 中，pause 容器创建了网络命名空间</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">分配一个 IP 地址给 Pod</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">查看集群中 Pod 到 Pod 的流量</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">Pod 网络命名空间连接到以太网桥</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">跟踪在同一节点上 Pod 到 Pod 的流量</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">跟踪不同节点上的 Pod 到 Pod 通信</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">按位运算的工作原理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">容器网络接口 - CNI</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">检查 Pod 到 Service 的流量</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">使用 Netfilter 和 Iptables 拦截和重写流量</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">检查来自服务的响应</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vip-container"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">总结一下</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                        
                          <a class="tag" href="/tags/#Docker" title="Docker">Docker</a>
                        
                          <a class="tag" href="/tags/#Kubernetes" title="Kubernetes">Kubernetes</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://bestgeek.org/" target="_blank">极客视界</a></li>
                    
                        <li><a href="https://mp.weixin.qq.com/s/ZgoeD1FBp7eouyxBte4MWw" target="_blank">技术交流群</a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                        <li><a href="" target="_blank"></a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






    <!-- 来必力City版公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
       (function(d, s) {
           var j, e = d.getElementsByTagName(s)[0];
    
           if (typeof LivereTower === 'function') { return; }
    
           j = d.createElement(s);
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;
    
           e.parentNode.insertBefore(j, e);
       })(document, 'script');
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    <!-- 来必力City版 公共JS代码 end -->



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                    <li>
                        <a href="/atom.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/80imike">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/2093524665">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Mike 2025 | Hosted by <a href="https://pages.coding.me" target="_blank" rel="noopener" style="font-weight: bold">Coding Pages</a>
                    <br>
                    Theme by <a href="http://beantech.org" target="_blank" rel="noopener">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://www.huweihuang.com" target="_blank" rel="noopener">胡伟煌</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huweihuang&repo=hexo-theme-huweihuang&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://www.hi-linux.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->



<script defer src="https://umami.hi-linux.com/script.js"
    data-website-id="db99ccfc-f114-4595-8f3b-9dd1fbd3bf19"></script>


	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://www.hi-linux.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script>(function(w,d, s, id) {w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js, fjs = d.getElementsByTagName(s)[0];js = d.createElement(s); js.id = id;js.src = 'https://cdn.webpushr.com/app.min.js';fjs.parentNode.appendChild(js);}(window,document, 'script', 'webpushr-jssdk'));webpushr('init','BF9JK7xV9kjWTdMx2lr6RWaPfXV7wNuZaVAJ1bfIGoBNJavqLEBVFMKLubITnCA4bh2fI9iH9tMF95nXnPt7xxY');</script></body>

</html>
